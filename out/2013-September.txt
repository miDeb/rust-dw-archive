From kevin at sb.org  Sun Sep  1 00:27:48 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 1 Sep 2013 00:27:48 -0700
Subject: [rust-dev] Cross-module priv visibility?
Message-ID: <43818495-56E3-48C4-9DC0-1C2FBC3F89BE@sb.org>

What are the intended rules for cross-module visibility of priv items? My impression was that either parents were supposed to be able to see their children's priv items, or children could see their parents' priv items, or maybe both. But it seems that right now neither is true. I know that there are bugs right now with visibility, so I'm not sure what was actually intended here.

-Kevin

From jon.mb at proinbox.com  Sun Sep  1 01:48:52 2013
From: jon.mb at proinbox.com (John Mija)
Date: Sun, 01 Sep 2013 09:48:52 +0100
Subject: [rust-dev] Mozilla using Go
Message-ID: <5222FF74.8010603@proinbox.com>

Hi! I've seen that Mozilla has used Go to build Heka 
(https://github.com/mozilla-services/heka). And although Go was meant to 
build servers while Rust was meant to build concurrent applications, 
Rust is better engineered that Go (much safer, more modular, optional GC).

Then, when is better intended use case of Rust respect to Go?
I expect Rust to be the next language for desktop applications if it 
gains as much maturity as Go but I'm unsure respect to the server side.

From dobkeratops0 at yahoo.co.uk  Sun Sep  1 02:19:28 2013
From: dobkeratops0 at yahoo.co.uk (Walter Walter)
Date: Sun, 1 Sep 2013 10:19:28 +0100 (BST)
Subject: [rust-dev] impl restriction between crates
Message-ID: <1378027168.17601.YahooMailNeo@web133204.mail.ir2.yahoo.com>

r.e. "impl's" on a type outside its original library crate .. i understand this is to preclude inter-crate clashes, if 2 library writers attempt to over-ride the same function.

i might be barking up the wrong tree here- rust has obviously been designed with the benefit of a lot of experience behind it.
but...

Would it be feasible to relax this error to a warning - or perhaps enable this behaviour with compiler options;
one compromise might be to only make it an error when compiling a library**.


potential use cases:-

[1] When writing code that is never going to be put into a library, you'd be able to extend existing types with greater ease (less traits to make.. naming is hard, the fewer things you have to name the better).
People writing smaller programs might make better use of existing types - especially while they're evolving.. and what doesn't evolve.. Any difference between usability of libary types and your own provides an incentive for NIH. a current example is the iterators which need the ".iter()" on the collection.. i've been tempeted to make workarounds to that.

Open-world is a big draw to rust, it's over half the reason for my interest in this language... looking for a solution to the way headers & classes interact badly in C++.

[2] Greater symetry between your own code where you may not have settled on libary/module divisons ..
lets say you seperate part of a program out after it? moves beyond a certain size, you'd have to start introducing extra traits... its just one more refactoring barrier.

[3] I just thought about this for trying to write anIDE plugin..
.. currently you must compile an entire crate when something changes, which is very slow.

But what if an IDE tool could divide the crate up into 1 crate per sourcefile, perhaps automatically generating an alternate 'main.rs' to pull these together. 

this is much like scenario [2]... this would involve having the same code compiling as either a multitude of crates, or being pulled together as one crate.
in particular node ID's are enumerated for the entire crate, demanding a 'rebuild'. But I dont think you'd routinely/manually want to divide things up into one crate per sourcefile.


personally i think i would prefer the restriction not to exist at all, i wouldn't mind the potential for libary link errors appearing;

I read the opinion that it doesn't matter because you can submit changes to the original library code being opensource, but i think its *much* more feasible for members of the rust community to request changes or splits in eachother libraries versus submitting changes to the *standard* libaries, which, being used by more people are going to have greater momentum ,more disagreement, longer time to agree on the most widely accepted methods ... an individual library writer need merely be mindful of this hazrd.
Doesn't matter if something is opensource .. it can be hard to change - its a point of disagreement and individuals might not considerevery other use case.


In C++ I hear some people objecting to extention methods for the same reason, but this objection sounds unfounded to me because you can just make overloaded functions anyway already, and i've never ran into those being a problem. its just nicer to have the same a.foo(b) calling syntax available for everything ..


is it possible for the module system to assist disambiguating if clashes do occur? there's always some use directives around.. could those prioritize the use of one supplied method over another.

I know Go has a similar open world idea .. and a similar issue, no extending outside a package, just within sources of the same package, and there you have to make a new type to extend.. which is probably worse than making a new trait IMO. So perhaps rust is already the best balance here, i dont know. I do like the fact that in go methods aren't actually part of anything when defined, even less pre-planning going on, and their interfaces just gather them after they're written, but i prefer the inter-module behaviour of traits over what go does.


** .. you might say thats' inconsistent, different rules where the same source compiles, but you already have that by the fact this issue exists at all.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/e2fc8cc9/attachment-0001.html>

From matthieu.monrocq at gmail.com  Sun Sep  1 02:30:01 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 1 Sep 2013 11:30:01 +0200
Subject: [rust-dev] Mozilla using Go
In-Reply-To: <5222FF74.8010603@proinbox.com>
References: <5222FF74.8010603@proinbox.com>
Message-ID: <CAKE6Rfg73mUya4ee3mH+W2O=8g6APM5jg1B04Yu_iOr0ahq5Jw@mail.gmail.com>

In a practical manner, I would say that Go is production ready whilst Rust
still has some way to go (!). Rust 1.0 is approaching, but is not there
yet, and there are still syntax/semantic questions being examined and lots
of work on the runtime... not to mention the lack of libraries (compared to
Go) largely due to the language still not being finalized.

I believe Rust could supplant Go (I see nothing in Go that Rust cannot do)
and cast a much wider net, but first it has to mature.

-- Matthieu


On Sun, Sep 1, 2013 at 10:48 AM, John Mija <jon.mb at proinbox.com> wrote:

> Hi! I've seen that Mozilla has used Go to build Heka (
> https://github.com/mozilla-**services/heka<https://github.com/mozilla-services/heka>).
> And although Go was meant to build servers while Rust was meant to build
> concurrent applications, Rust is better engineered that Go (much safer,
> more modular, optional GC).
>
> Then, when is better intended use case of Rust respect to Go?
> I expect Rust to be the next language for desktop applications if it gains
> as much maturity as Go but I'm unsure respect to the server side.
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/8f381cd2/attachment.html>

From amitava.shee at gmail.com  Sun Sep  1 05:18:04 2013
From: amitava.shee at gmail.com (Amitava Shee)
Date: Sun, 1 Sep 2013 08:18:04 -0400
Subject: [rust-dev] make check fails
In-Reply-To: <CABq6+ae=YADNzh-bQ4Kk3WMF2Knh7_r0dciKZ7GtAXhbDjjY2A@mail.gmail.com>
References: <CAPifMvA36W6DYWDRzQsQ0snp43HfJAEwiSeh6CwnzbnGbJ+QBw@mail.gmail.com>
	<CABq6+ae=YADNzh-bQ4Kk3WMF2Knh7_r0dciKZ7GtAXhbDjjY2A@mail.gmail.com>
Message-ID: <CAPifMvD2_rgLVQ_y-MJVrfNtzXrf3Z8PaJgpzCh4DDUpFDFX3g@mail.gmail.com>

Thanks. I added a comment in the issue with instructions to raise the file
descriptor limits (temporary workaround). For the convenience of others, I
am repeating it here.

Reboot after running these commands

echo 'kern.maxfiles=20480' | sudo tee -a /etc/sysctl.conf
echo -e 'limit maxfiles 8192 20480\nlimit maxproc 1000 2000' | sudo tee -a
/etc/launchd.conf
echo 'ulimit -n 4096' | sudo tee -a /etc/profile

-Amitava

On Sat, Aug 31, 2013 at 2:12 PM, Kevin Cantu <me at kevincantu.org> wrote:

> I see that, too.  Filed an issue for it: seems like some kind of
> libc::pipe problem on OS X with that that function.
> https://github.com/mozilla/rust/issues/8904
>
>
> Kevin
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/73718cc5/attachment.html>

From garethdanielsmith at gmail.com  Sun Sep  1 06:37:39 2013
From: garethdanielsmith at gmail.com (Gareth Smith)
Date: Sun, 01 Sep 2013 14:37:39 +0100
Subject: [rust-dev] changing roles
In-Reply-To: <5221333F.1040501@mozilla.com>
References: <5221333F.1040501@mozilla.com>
Message-ID: <52234323.8060700@gmail.com>

You have done an excellent job. Thank you.

Gareth

On 31/08/13 01:05, Graydon Hoare wrote:
> Hi,
>
> As I'm sure many of you who know me are aware, my role as technical 
> lead on Rust has been quite draining over the years. Both to myself 
> and to those I've worked with, it just isn't a great fit for me.
>
> In recognition of this, I am stepping aside to work elsewhere in the 
> organization, and Brian will be assuming the role of technical lead of 
> Rust.
>
> Brian is one of the most skilled, judicious, professional and 
> productive developers I've ever worked with. Along with the 
> exceptional skill and dedication of the rest of the Rust team, I have 
> complete confidence in the remaining path to a successful 1.x series 
> of what has shaped up to be an excellent language.
>
> It has been a rare pleasure and privilege to work with the Rust team, 
> both those inside Mozilla and in the broader community.
>
> Thanks,
>
> -Graydon
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From simon.sapin at exyr.org  Sun Sep  1 06:47:22 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sun, 01 Sep 2013 14:47:22 +0100
Subject: [rust-dev] App runtime based on Servo
In-Reply-To: <52224263.4010902@proinbox.com>
References: <52224263.4010902@proinbox.com>
Message-ID: <5223456A.5060104@exyr.org>

Le 31/08/2013 20:22, John Mija a ?crit :
>   From my point of view, there is no technology related to User
> Interfaces more advanced than web-based (HTML5/CSS3).
>
> [...]
>
> Now, what do think about to have a similar technology but using Servo?
> To being able to develop desktop apps in Rust (or Go via bindings to
> Rust libraris) and JS or Dart for the UI.

I don?t know about adding Go or Dart to the mix, but it is definitely 
one of Servo?s goals to be embeddable as a library in a larger application.

-- 
Simon Sapin

From bjzaba at yahoo.com.au  Sun Sep  1 06:49:03 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sun, 1 Sep 2013 23:49:03 +1000
Subject: [rust-dev] Mozilla using Go
In-Reply-To: <5222FF74.8010603@proinbox.com>
References: <5222FF74.8010603@proinbox.com>
Message-ID: <291C645B-D5E3-42B9-83BB-0A94851DD834@yahoo.com.au>

My understanding is that Rust is meant more for real-time, performance/security critical applications, such as user-facing guis and rendering engines. This also fits nicely with games and graphics applications. There is also the real possibility of it being useful in embedded systems. Go is designed more for large, server-side applications. The core devs have said many times that they don't consider Go to be a competitor.

~Brendan

On 01/09/2013, at 6:48 PM, John Mija <jon.mb at proinbox.com> wrote:

> Hi! I've seen that Mozilla has used Go to build Heka (https://github.com/mozilla-services/heka). And although Go was meant to build servers while Rust was meant to build concurrent applications, Rust is better engineered that Go (much safer, more modular, optional GC).
> 
> Then, when is better intended use case of Rust respect to Go?
> I expect Rust to be the next language for desktop applications if it gains as much maturity as Go but I'm unsure respect to the server side.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From corey at octayn.net  Sun Sep  1 06:50:42 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 1 Sep 2013 09:50:42 -0400
Subject: [rust-dev] Mozilla using Go
In-Reply-To: <291C645B-D5E3-42B9-83BB-0A94851DD834@yahoo.com.au>
References: <5222FF74.8010603@proinbox.com>
	<291C645B-D5E3-42B9-83BB-0A94851DD834@yahoo.com.au>
Message-ID: <CA++BO6SdZKy_ChQztpHPMbEYSOtsZWqJ_ZFpGu_3Wdf+TcZgWA@mail.gmail.com>

IMO Rust is very applicable as a general purpose language, perhaps
moreso than C++.

On Sun, Sep 1, 2013 at 9:49 AM, Brendan Zabarauskas <bjzaba at yahoo.com.au> wrote:
> My understanding is that Rust is meant more for real-time, performance/security critical applications, such as user-facing guis and rendering engines. This also fits nicely with games and graphics applications. There is also the real possibility of it being useful in embedded systems. Go is designed more for large, server-side applications. The core devs have said many times that they don't consider Go to be a competitor.
>
> ~Brendan
>
> On 01/09/2013, at 6:48 PM, John Mija <jon.mb at proinbox.com> wrote:
>
>> Hi! I've seen that Mozilla has used Go to build Heka (https://github.com/mozilla-services/heka). And although Go was meant to build servers while Rust was meant to build concurrent applications, Rust is better engineered that Go (much safer, more modular, optional GC).
>>
>> Then, when is better intended use case of Rust respect to Go?
>> I expect Rust to be the next language for desktop applications if it gains as much maturity as Go but I'm unsure respect to the server side.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From reshef.dov at gmail.com  Sun Sep  1 06:58:56 2013
From: reshef.dov at gmail.com (Dov Reshef)
Date: Sun, 1 Sep 2013 16:58:56 +0300
Subject: [rust-dev] Cross-module priv visibility?
In-Reply-To: <43818495-56E3-48C4-9DC0-1C2FBC3F89BE@sb.org>
References: <43818495-56E3-48C4-9DC0-1C2FBC3F89BE@sb.org>
Message-ID: <CAFJonDBfBKUyFN79obW96eQ4cUvmVJczNC6AmP7RYsypL-YN2Q@mail.gmail.com>

Have a look here:
https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-30#visibility-in-module-system
.

And here: https://github.com/mozilla/rust/issues/8169.



On Sun, Sep 1, 2013 at 10:27 AM, Kevin Ballard <kevin at sb.org> wrote:

> What are the intended rules for cross-module visibility of priv items? My
> impression was that either parents were supposed to be able to see their
> children's priv items, or children could see their parents' priv items, or
> maybe both. But it seems that right now neither is true. I know that there
> are bugs right now with visibility, so I'm not sure what was actually
> intended here.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/56c6c0a2/attachment-0001.html>

From oren at ben-kiki.org  Sun Sep  1 08:23:43 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sun, 1 Sep 2013 18:23:43 +0300
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <52213DE0.2000109@mozilla.com>
References: <52211DE7.7050909@mozilla.com>
	<52213DE0.2000109@mozilla.com>
Message-ID: <CADJiDhvOkcSLs3_qUpx-yNYTaG5X+tUgrQwBVuKA3n2CAn2w7A@mail.gmail.com>

Since swap seems to have its own problems - would it be possible to tweak
the stealing idea so the compiler would know there's a burrowed mutable
pointer to the hole, effectively preventing further access to it in the
vulnerable block?

I really would like to be able to use this approach, it really improved my
code...


On Sat, Aug 31, 2013 at 3:50 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> On 8/30/13 3:39 PM, Patrick Walton wrote:
>
>> Thoughts? Does this seem useful? Are there soundness issues I didn't
>> notice?
>>
>
> Brian pointed out a massive soundness hole in this, unfortunately. The
> problem is that you can read from the original locations; the right to read
> is not "shut off" during the borrow. I think the fix would have to be to
> replace this with some sort of "generalized swap" operation.
>
>
> Patrick
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/ffc75245/attachment.html>

From pwalton at mozilla.com  Sun Sep  1 08:25:07 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sun, 01 Sep 2013 08:25:07 -0700
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
 of linearity
In-Reply-To: <CADJiDhvOkcSLs3_qUpx-yNYTaG5X+tUgrQwBVuKA3n2CAn2w7A@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvOkcSLs3_qUpx-yNYTaG5X+tUgrQwBVuKA3n2CAn2w7A@mail.gmail.com>
Message-ID: <52235C53.5070801@mozilla.com>

On 9/1/13 8:23 AM, Oren Ben-Kiki wrote:
> Since swap seems to have its own problems - would it be possible to
> tweak the stealing idea so the compiler would know there's a burrowed
> mutable pointer to the hole, effectively preventing further access to it
> in the vulnerable block?
>
> I really would like to be able to use this approach, it really improved
> my code...

What's the problem with a generalized swap (>= 2 elements, any 
permutation) for your use case?

Patrick


From flaper87 at gmail.com  Sun Sep  1 12:45:03 2013
From: flaper87 at gmail.com (Flaper87)
Date: Sun, 1 Sep 2013 21:45:03 +0200
Subject: [rust-dev] Mozilla using Go
In-Reply-To: <CA++BO6SdZKy_ChQztpHPMbEYSOtsZWqJ_ZFpGu_3Wdf+TcZgWA@mail.gmail.com>
References: <5222FF74.8010603@proinbox.com>
	<291C645B-D5E3-42B9-83BB-0A94851DD834@yahoo.com.au>
	<CA++BO6SdZKy_ChQztpHPMbEYSOtsZWqJ_ZFpGu_3Wdf+TcZgWA@mail.gmail.com>
Message-ID: <CAMOT3C0o_Deii2k_JPQ6DXQU-HiO5AX0CYsM_9xh+9C-uTUKiQ@mail.gmail.com>

2013/9/1 Corey Richardson <corey at octayn.net>

> IMO Rust is very applicable as a general purpose language, perhaps
> moreso than C++.
>

I agree with the above! I don't see Rust being bound to a specific area, I
think it can be used in many different types of applications.


-- 
Flavio (@flaper87) Percoco
http://www.flaper87.org
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130901/7c385371/attachment.html>

From catamorphism at gmail.com  Mon Sep  2 16:37:34 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 2 Sep 2013 16:37:34 -0700
Subject: [rust-dev] Questions about linked lists in Rust
In-Reply-To: <CAKs_8PnhSAjPL_bvKTRm2O1ZgkLmB--3EVmTF3qTgrTFXEDu4g@mail.gmail.com>
References: <CAKs_8PnhSAjPL_bvKTRm2O1ZgkLmB--3EVmTF3qTgrTFXEDu4g@mail.gmail.com>
Message-ID: <CADcg8==C13_cbxAxzBPrfG6Abn-Kktuev=NKBHJzNWgtAmO5zg@mail.gmail.com>

On Wed, Aug 28, 2013 at 8:22 PM, Nicholas Bishop
<nicholasbishop at gmail.com> wrote:
> Hi,
>
> I'm new to Rust, currently trying out a few simple tests to get a
> handle on things.
>
> I have a few questions about linked lists. I see there are two list
> modules in extra, one for ~ pointers and one for @ pointers. (I'm
> using the current trunk rather than 0.7 if that makes a difference.)
>

Hi, Nicholas --

There are two list modules because one is a singly linked list --
list.rs -- and one is a doubly linked list -- dlist.rs . Off the top
of my head I'm not sure if there's a reason why list.rs uses @
pointers.

> The interfaces between the two look quite different however. Is this
> because one is newer and the other hasn't caught up yet, or are the
> differences by design and the two interfaces will stay more or less as
> they are?
>

I would expect that the interfaces will be different, since one might
want to use a doubly-linked list for different purposes than a singly
linked list.

> In extra::list, I don't see methods to append or remove a single
> element. Intentional or todo?

Probably to-do.

>
> In extra::dlist, there are methods to remove the back or front
> element, but not an arbitrary link?

Probably to-do.

>
> On a related note, I'd be interested to read about implementing data
> structures in Rust. The examples of structs in the tutorial are mostly
> very simple (Point, Circle, etc). The use of Rust's pointers get much
> more complicated when dealing with non-tree structures. For example,
> extra::dlist uses raw pointers rather than @ pointers for links. An
> overview of what the tradeoffs look like (code clarity,
> memory-leak/memory-corruption issues, performance numbers, memory
> usage) and some cookbook patterns could be quite helpful.

This would make a great topic for a blog post -- perhaps someone has
even already written it! As far as existing code examples go,
extra::treemap might be a good one to study.

Cheers,
Tim


-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From niko at alum.mit.edu  Mon Sep  2 17:04:17 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 2 Sep 2013 20:04:17 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
 of linearity
In-Reply-To: <52213DE0.2000109@mozilla.com>
References: <52211DE7.7050909@mozilla.com>
 <52213DE0.2000109@mozilla.com>
Message-ID: <20130903000417.GB21849@Mr-Bennet>

On Fri, Aug 30, 2013 at 05:50:40PM -0700, Patrick Walton wrote:
> Brian pointed out a massive soundness hole in this, unfortunately.
> The problem is that you can read from the original locations; the
> right to read is not "shut off" during the borrow. I think the fix
> would have to be to replace this with some sort of "generalized swap"
> operation.

One thing that I've been wanting to do is to generalize our move
rules. Currently, we do not permit you to move data from borrowed
locations -- but we COULD safely permit this, under certain
conso long as you 

From niko at alum.mit.edu  Mon Sep  2 17:08:43 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 2 Sep 2013 20:08:43 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
 of linearity
In-Reply-To: <20130903000417.GB21849@Mr-Bennet>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<20130903000417.GB21849@Mr-Bennet>
Message-ID: <20130903000843.GA12491@Mr-Bennet>

Sorry, sent that e-mail prematurely. Short version is that I think we
could generalize our move rules somewhat precisely for the purpose of
accommodating this situation, but the question is whether it would
ultimately be expressive enough. There would have to be rules against
making fn calls, reading const pointers, and similar things while
borrowed data is in a moved out state. Ultimately, it probably winds
up being equivalent to a "multi-swap" primitive, so perhaps that's a
better approach anyhow! (Plus it avoids the need to worry about what
to do in the case of failure, I haven't really about that before)


Niko

On Mon, Sep 02, 2013 at 08:04:17PM -0400, Niko Matsakis wrote:
> On Fri, Aug 30, 2013 at 05:50:40PM -0700, Patrick Walton wrote:
> > Brian pointed out a massive soundness hole in this, unfortunately.
> > The problem is that you can read from the original locations; the
> > right to read is not "shut off" during the borrow. I think the fix
> > would have to be to replace this with some sort of "generalized swap"
> > operation.
> 
> One thing that I've been wanting to do is to generalize our move
> rules. Currently, we do not permit you to move data from borrowed
> locations -- but we COULD safely permit this, under certain
> conso long as you 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From niko at alum.mit.edu  Mon Sep  2 17:13:05 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 2 Sep 2013 20:13:05 -0400
Subject: [rust-dev] Questions about linked lists in Rust
In-Reply-To: <CADcg8==C13_cbxAxzBPrfG6Abn-Kktuev=NKBHJzNWgtAmO5zg@mail.gmail.com>
References: <CAKs_8PnhSAjPL_bvKTRm2O1ZgkLmB--3EVmTF3qTgrTFXEDu4g@mail.gmail.com>
	<CADcg8==C13_cbxAxzBPrfG6Abn-Kktuev=NKBHJzNWgtAmO5zg@mail.gmail.com>
Message-ID: <20130903001305.GB12491@Mr-Bennet>

On Mon, Sep 02, 2013 at 04:37:34PM -0700, Tim Chevalier wrote:
> There are two list modules because one is a singly linked list --
> list.rs -- and one is a doubly linked list -- dlist.rs . Off the top
> of my head I'm not sure if there's a reason why list.rs uses @
> pointers.

The reason that list uses `@` pointers is because it is indended to
serve as the venerable "cons-list" data structure found in Lisp and
many functional languages. The real advantage of this data structure
is that it is persistent, meaning you can prepend items to the list
without modifying the old copies of the list. To make this convenient,
garbage collection is required. If you only have one copy of the list,
you might as well use a `~[]` vector.


Niko

From echristo at gmail.com  Tue Sep  3 10:43:40 2013
From: echristo at gmail.com (Eric Christopher)
Date: Tue, 3 Sep 2013 10:43:40 -0700
Subject: [rust-dev] Disabling LLVM Asserts
In-Reply-To: <CA++BO6RRFJs4wrXcZ-BV1pi3x5dmCtTOoruSunQKWCmCHWYkJw@mail.gmail.com>
References: <CA++BO6RRFJs4wrXcZ-BV1pi3x5dmCtTOoruSunQKWCmCHWYkJw@mail.gmail.com>
Message-ID: <CALehDX5b-LWUiHAmXTcvbUXu=KQ2JP-3-=nDoV1hV=ZQxopAZw@mail.gmail.com>

On Sat, Aug 31, 2013 at 5:21 PM, Corey Richardson <corey at octayn.net> wrote:
> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-08-27#llvm-asserts
> discusses disabling LLVM assertions. I don't think it just risks
> segfaults, doesn't it also run the risk of invalid codegen for
> incorrect uses?
>

It does all of these things yes. It costs, last I checked, about 5-10%
of compile time in clang to leave assertions on as well as some
additional code size. If another data point is useful here the
chromium guys leave asserts on in the clang toolchain they use.

-eric

From corey at octayn.net  Tue Sep  3 11:34:22 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 3 Sep 2013 14:34:22 -0400
Subject: [rust-dev] Out of -Z flags
Message-ID: <CA++BO6SorWO6Nu1iJAAy0Ji=bDMpmLgWpmhg37RcM3Aw3Q827w@mail.gmail.com>

Right now Z flags are implemented using a bit flag stored in a uint,
which is only reliably 32 bits on the platforms we use. We could
extend it to a u64, or we could use an enum, but we can't continue
doing this, because https://github.com/mozilla/rust/pull/8955 uses the
last available bit.

From josh at joshmatthews.net  Tue Sep  3 11:39:54 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Tue, 3 Sep 2013 14:39:54 -0400
Subject: [rust-dev] Out of -Z flags
In-Reply-To: <CA++BO6SorWO6Nu1iJAAy0Ji=bDMpmLgWpmhg37RcM3Aw3Q827w@mail.gmail.com>
References: <CA++BO6SorWO6Nu1iJAAy0Ji=bDMpmLgWpmhg37RcM3Aw3Q827w@mail.gmail.com>
Message-ID: <CAOvJiVUBCrueR5LHbQqCDNjxCPrtjhH5_stQ0dZXT+PUVKXBQw@mail.gmail.com>

We could free one up by moving basic debug-info back into the -g flag. Now
that we have automated tests, it's a lot less likely to get busted and
frustrate people.


On 3 September 2013 14:34, Corey Richardson <corey at octayn.net> wrote:

> Right now Z flags are implemented using a bit flag stored in a uint,
> which is only reliably 32 bits on the platforms we use. We could
> extend it to a u64, or we could use an enum, but we can't continue
> doing this, because https://github.com/mozilla/rust/pull/8955 uses the
> last available bit.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130903/bd9f71c1/attachment.html>

From bjzaba at yahoo.com.au  Tue Sep  3 18:06:14 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Wed, 4 Sep 2013 11:06:14 +1000
Subject: [rust-dev] Formatting complex trait definitions and impls
References: <64EA98D6-4174-4DF8-ACD1-C9ACAC1BEDED@yahoo.com.au>
Message-ID: <C21F656A-1278-4C98-BC3F-200C92E2EF82@yahoo.com.au>

Has anybody worked out a decent way to lay out complex definitions? This is what I'm starting to do:

   pub trait AffineSpace
   <
       S: Field,
       V: VectorSpace<S>
   >
   :   Eq
   +   Zero
   +   Add<V, Self>
   +   Sub<Self, V>
   +   ScalarMul<S>
   {
       // ...
   }

impls are harder though:

   impl<S: Field> Sub<Point3<S>, Vec3<S>> for Point3<S> { ? }

Any ideas? This is one way maybe, but it looks terrible:

   impl
   <
       S: Field
   >
   Sub
   <
       Point3<S>,
       Vec3<S>
   >
   for Point3<S>
   {
        // ... 
   }

Stacking it is probably overkill for that impl, but there a most likely going to be worse ones. Maybe this is more of a problem with the current syntax?

~Brendan


From niko at alum.mit.edu  Wed Sep  4 03:20:10 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 4 Sep 2013 06:20:10 -0400
Subject: [rust-dev] Out of -Z flags
In-Reply-To: <CA++BO6SorWO6Nu1iJAAy0Ji=bDMpmLgWpmhg37RcM3Aw3Q827w@mail.gmail.com>
References: <CA++BO6SorWO6Nu1iJAAy0Ji=bDMpmLgWpmhg37RcM3Aw3Q827w@mail.gmail.com>
Message-ID: <20130904102010.GA6112@Mr-Bennet>

Just switch it to u64.


Niko

On Tue, Sep 03, 2013 at 02:34:22PM -0400, Corey Richardson wrote:
> Right now Z flags are implemented using a bit flag stored in a uint,
> which is only reliably 32 bits on the platforms we use. We could
> extend it to a u64, or we could use an enum, but we can't continue
> doing this, because https://github.com/mozilla/rust/pull/8955 uses the
> last available bit.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From qwertie256 at gmail.com  Wed Sep  4 09:58:09 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Wed, 4 Sep 2013 10:58:09 -0600
Subject: [rust-dev] Structural enums for datasort refinements
In-Reply-To: <CAHuo6ZDsRDQHATu2R+gsbvMveaDCVzqLeNDOB4UdtWT5=WmTFQ@mail.gmail.com>
References: <CAHuo6ZDsRDQHATu2R+gsbvMveaDCVzqLeNDOB4UdtWT5=WmTFQ@mail.gmail.com>
Message-ID: <CAHuo6ZAijC_j0FOj-EMDb7Qi=jqQRAM8SFd+D7Td0JhmhRVTuw@mail.gmail.com>

On Wed, Aug 28, 2013 at 11:19 AM, David Piepgrass <qwertie256 at gmail.com>wrote:

>
> From: Bill Myers <bill_myers at outlook.com>
>>
>> I was reading a proposal about adding "datasort refinements" to make enum
>> variants first-class types, and it seems to me there is a simpler and more
>> effective way of solving the problem.
>>
>> The idea is that if A, B and C are types, then "A | B | C" is a
>> "structural" enum type that can be either A, B or C.
>>
>> ...
>
>
> Hi, I'm just your friendly everyday lurker... Assuming there's nothing in
> this proposal that fundamentally breaks the language, I just wanted to say
> I think this idea is fantastic. You almost don't need Some(T) since
> Option<T> could just be None|T.
>
> I would add that I recall recently some people were discussing how to do a
> "variant" type in Rust. If all struct types in a program are assigned a
> unique tag, this very same feature could support a variant type, which is
> defined as the union of all types. Then any struct converts implicitly to
> variant (oh, and since I just wrote a parser generator that supports
> inverted sets like ~('a'..'z'), it occurs to me that the type system could
> readily support "any type except A | B" as well.)
>
> The tag could either be a unique integer index, or a pointer to a global
> variable that contains type information (the latter, it seems to me,
> automatically solves the dynamic linking problem "how do we ensure two
> unrelated DLLs have unique tags?" DLL loaders already support relocation in
> case of conflicts.)
>
> Oops, I just remembered that Rust implements enum types using a fixed-size
memory area that is as large as the largest possible item. So a variant (or
"anything except") type, having unlimited size, doesn't directly fit into
that model.

But the compiler could switch to a heap representation for variants. Or,
better, variants could use a smart fixed-size representation in which heap
allocation is used only when the variant is storing a larger type. For
instance, a variant could always use two words, one word for the type tag
and one word for the value. If the current data type T is one word or
smaller, it is stored directly in the second word. Otherwise, the second
word is a ~T pointer.

Just an idea.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130904/bb70cc58/attachment.html>

From steve at steveklabnik.com  Wed Sep  4 12:29:48 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Wed, 04 Sep 2013 12:29:48 -0700
Subject: [rust-dev] Mozilla using Go
In-Reply-To: <5222FF74.8010603@proinbox.com>
References: <5222FF74.8010603@proinbox.com>
Message-ID: <52278A2C.1000608@steveklabnik.com>

The Rust team already has a page about Go[1]. The two languages, as you
mention, aren't exactly competing.

This thread has been okay so far, but I'd advise everyone to pay close
attention to the Code of Conduct[2]: threads like this have a tendency
to devolve quickly. Bashing other languages is not appropriate. Thanks
for keeping it clean so far. :)

1:
https://github.com/mozilla/rust/wiki/Doc-language-FAQ#have-you-seen-this-google-language-go-how-does-rust-compare
2: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 294 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130904/fa6282dd/attachment.sig>

From dwrenshaw at gmail.com  Thu Sep  5 09:29:59 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Thu, 5 Sep 2013 09:29:59 -0700
Subject: [rust-dev] instantiating parameterized impls
Message-ID: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>

Hi,

When I try to compile the below program, why do I get a "conflicting
implementations" error? I do not define any implementations of Bar, so
the parameterized impl of Foo should never get instantiated, right?

-------------------

trait Foo {
    fn foo() -> Self;
}

trait Bar : std::num::Zero { }

impl <T : Bar> Foo for T {
    fn foo() -> T {
        std::num::Zero::zero()
    }
}

impl Foo for u16 {
    fn foo () -> u16 {
        100
    }
}

fn main() {

    // should be 100
    let x : u16 = Foo::foo();
    printfln!("%s", x);

}

// error: conflicting implementations for trait `Foo`

------------------


When I asked about this on IRC, cmr indicated that this is probably
the intended behavior of rustc, but that most people want to change
it. Is that true, and when can we expect a fix?


Thanks,
David

From catamorphism at gmail.com  Thu Sep  5 12:36:54 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Thu, 5 Sep 2013 12:36:54 -0700
Subject: [rust-dev] instantiating parameterized impls
In-Reply-To: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>
References: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>
Message-ID: <CADcg8=mrHpfNBBR+ovMyx9q4REOU+=S-kB5moyXP_d+VWOUPQA@mail.gmail.com>

On Thu, Sep 5, 2013 at 9:29 AM, David Renshaw <dwrenshaw at gmail.com> wrote:
> Hi,
>
> When I try to compile the below program, why do I get a "conflicting
> implementations" error? I do not define any implementations of Bar, so
> the parameterized impl of Foo should never get instantiated, right?
>
> -------------------
>
> trait Foo {
>     fn foo() -> Self;
> }
>
> trait Bar : std::num::Zero { }
>
> impl <T : Bar> Foo for T {
>     fn foo() -> T {
>         std::num::Zero::zero()
>     }
> }
>
> impl Foo for u16 {
>     fn foo () -> u16 {
>         100
>     }
> }
>
> fn main() {
>
>     // should be 100
>     let x : u16 = Foo::foo();
>     printfln!("%s", x);
>
> }
>
> // error: conflicting implementations for trait `Foo`
>
> ------------------
>

The reason is that there is no guarantee that you will never use this
code in a context where another module defines an impl of Bar for u16.
In that scenario, you would have two different impls of Foo for u16,
and no way to disambiguate. In Haskell, this is called the
"overlapping instances" problem; it happens because traits in Rust,
and type classes in Haskell, are open rather than closed (when you
define a trait, you don't have any way of knowing all the impls of it
for a particular type).

>
> When I asked about this on IRC, cmr indicated that this is probably
> the intended behavior of rustc, but that most people want to change
> it. Is that true, and when can we expect a fix?

I'm not sure that most people want to change it. Handling the issue in
general is quite subtle (see
http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf
). One workaround is to use newtypes:

struct Wrapper<T> { x: T }
...
impl <T: Bar>  Foo for Wrapper<T> { ...

and then there's no ambiguity.

Cheers,
Tim




-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From steven099 at gmail.com  Thu Sep  5 13:25:07 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Thu, 5 Sep 2013 16:25:07 -0400
Subject: [rust-dev] instantiating parameterized impls
In-Reply-To: <CADcg8=mrHpfNBBR+ovMyx9q4REOU+=S-kB5moyXP_d+VWOUPQA@mail.gmail.com>
References: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>
	<CADcg8=mrHpfNBBR+ovMyx9q4REOU+=S-kB5moyXP_d+VWOUPQA@mail.gmail.com>
Message-ID: <CANjmGJuFQWNzC+gGbg=sTxqv=0YctZm2k0HC+f-rqF_vOQMkFg@mail.gmail.com>

On Thu, Sep 5, 2013 at 3:36 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> The reason is that there is no guarantee that you will never use this
>  code in a context where another module defines an impl of Bar for u16.
> In that scenario, you would have two different impls of Foo for u16,
> and no way to disambiguate. In Haskell, this is called the
> "overlapping instances" problem; it happens because traits in Rust,
> and type classes in Haskell, are open rather than closed (when you
> define a trait, you don't have any way of knowing all the impls of it
> for a particular type).


Strictly speaking, you know about all impls of Bar for all types available
to your crate when you compile your crate, and if you own Bar, then you
even know that new impls can't be introduced in your dependencies which
could break your code. You could even have `impl <T: Bar> Foo for T` and
`impl<T: Baz> Foo for T`, as long as you own at least one of Bar or Baz,
since it is then possible for the compiler to know that types in other
crates which depend on yours can't implement both. Its just a matter of how
smart you want the compiler to be, and how much you want to avoid changes
up the dependency chain being able to break things down the dependency
chain (which isn't entirely avoidable anyways).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130905/005af4ab/attachment.html>

From dobkeratops0 at yahoo.co.uk  Thu Sep  5 15:45:29 2013
From: dobkeratops0 at yahoo.co.uk (Walter Walter)
Date: Thu, 5 Sep 2013 23:45:29 +0100 (BST)
Subject: [rust-dev] mod.rs.. in crate root?
Message-ID: <1378421129.17008.YahooMailNeo@web133201.mail.ir2.yahoo.com>

have i understood this correctly- 

with mod.rs in subdirectories, you can now make a rust module heirachy look exactly like the source directory tree? (nice..)

... but only so long as you dont have mutliple sources in the crate-roots' directory,just one main including each directory-module.
(thats certainly the way i'll set anything up i do from now on, if so..)

could this be extended to multiple sources in the crate 'root'/'root directory.. perhaps by using the same rule, if you start with "mod.rs"? as the crate root.

would it have any undesirable side effects.. does it seem more consistent or less consistent.. would there be any other better ways of doing that.. is this already possible perhaps.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130905/22b82882/attachment.html>

From niko at alum.mit.edu  Fri Sep  6 08:31:23 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 6 Sep 2013 11:31:23 -0400
Subject: [rust-dev] instantiating parameterized impls
In-Reply-To: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>
References: <CABR6rW_rTPpeUeLkCk8au6EGSS2wpOQ+iEqg7fs0RXiEuPRJcw@mail.gmail.com>
Message-ID: <20130906153123.GE30156@Mr-Bennet>

Hi David,

My current thinking on the matter is that eventually, I would like to
take advantage of the coherence rules to permit a program like
this. Coherence means that given a specific type T and trait U, we can
always tell whether T implements U.  This implies that we could do the
check as you described it.

However, implementing this is a bit far off. I think it is best done
as part of a general rewrite of the trait and method resolution
code. I have started that, but put it on hold to deal with #6801
(borrowck treatment of closures) and then the treatment of moves and
zeroing (#5016).

Also, I am not sure how much of this has been discussed and agreed
to. One of my longstanding "to do" items is to write up my thinking on
trait resolution as a blog post and then discuss at a meeting. You are
giving me some motivation to do that, since I'd love to be able to
point you to a fully explained blog post :)


Niko

On Thu, Sep 05, 2013 at 09:29:59AM -0700, David Renshaw wrote:
> Hi,
> 
> When I try to compile the below program, why do I get a "conflicting
> implementations" error? I do not define any implementations of Bar, so
> the parameterized impl of Foo should never get instantiated, right?
> 
> -------------------
> 
> trait Foo {
>     fn foo() -> Self;
> }
> 
> trait Bar : std::num::Zero { }
> 
> impl <T : Bar> Foo for T {
>     fn foo() -> T {
>         std::num::Zero::zero()
>     }
> }
> 
> impl Foo for u16 {
>     fn foo () -> u16 {
>         100
>     }
> }
> 
> fn main() {
> 
>     // should be 100
>     let x : u16 = Foo::foo();
>     printfln!("%s", x);
> 
> }
> 
> // error: conflicting implementations for trait `Foo`
> 
> ------------------
> 
> 
> When I asked about this on IRC, cmr indicated that this is probably
> the intended behavior of rustc, but that most people want to change
> it. Is that true, and when can we expect a fix?
> 
> 
> Thanks,
> David
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From rexlen at gmail.com  Sat Sep  7 05:11:40 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Sat, 7 Sep 2013 14:11:40 +0200
Subject: [rust-dev] functions
Message-ID: <CAM0XVgsZ_yxQxEEAPX6J2_3Dn_CDsSMQCKuUxLSnybxnXm_qyA@mail.gmail.com>

Is it possibile, or will be possibile, to use default parameters and/or
named parameters in Rust?
In the docs i couldn't find anything about this (may be my fault...)
Regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/aff6c68d/attachment.html>

From dbau.pp at gmail.com  Sat Sep  7 05:51:05 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 07 Sep 2013 22:51:05 +1000
Subject: [rust-dev] functions
In-Reply-To: <CAM0XVgsZ_yxQxEEAPX6J2_3Dn_CDsSMQCKuUxLSnybxnXm_qyA@mail.gmail.com>
References: <CAM0XVgsZ_yxQxEEAPX6J2_3Dn_CDsSMQCKuUxLSnybxnXm_qyA@mail.gmail.com>
Message-ID: <522B2139.4090406@gmail.com>

On 07/09/13 22:11, Renato Lenzi wrote:
> Is it possibile, or will be possibile, to use default parameters 
> and/or named parameters in Rust?
> In the docs i couldn't find anything about this (may be my fault...)
> Regards.
>
It is not possible currently, but there's an open bug [6973] and with 
(quite) a bit of discussion. Two current methods for simulating them 
would be defining wrapper functions for the common shortcuts, or passing 
the default/named args as a struct and use a "functional record update" 
(FRU), e.g.

   struct FooArgs {
      x: int,
      y: int,
      z: int,
   }

   static DEFAULT_FOO: FooArgs = FooArgs { x: 1, y: 2, z: 3 };

   /// a, b are compulsory, anything in rest is a default arg
   fn foo(a: uint, b: uint, rest: FooArgs) { ... }


   fn main() {
     // only defaults
     foo(10, 100, DEFAULT_FOO);

     // y = -3, defaults for the rest
     foo(10, 100, FooArgs { y: -3, .. DEFAULT_FOO }) // `..` indicates 
an FRU
   }

This one is unfortunately ugly, but it seems to get the job done.

Huon

[6973]: https://github.com/mozilla/rust/issues/6973

From oren at ben-kiki.org  Sat Sep  7 08:39:42 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 7 Sep 2013 18:39:42 +0300
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <52213DE0.2000109@mozilla.com>
References: <52211DE7.7050909@mozilla.com>
	<52213DE0.2000109@mozilla.com>
Message-ID: <CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>

Another thought on this. Currently, either the compiler is satisfies that
the code is 100% safe, or we slap an "unsafe" keyword around the code and
put 100% of the responsibility on the programmer, with no support from the
Rust system.

Wouldn't it make sense to have a "not statically safe, but verified at run
time" safety as a middle ground?

In the context of the "stolen" proposal, when one "steals" a pointer, the
original location could be set to null, and only be restored to a non-null
pointer when the value is "put back". This means any access to it would
cause an exception - which is what one would intuitively expect a hold to
behave like.

I have a feeling that there is a non-trivial amount of code which is
"actually safe" but would impossible to convince the compiler it is
"statically safe". Surely having run-time safety in such cases is better
than none at all...?



On Sat, Aug 31, 2013 at 3:50 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> On 8/30/13 3:39 PM, Patrick Walton wrote:
>
>> Thoughts? Does this seem useful? Are there soundness issues I didn't
>> notice?
>>
>
> Brian pointed out a massive soundness hole in this, unfortunately. The
> problem is that you can read from the original locations; the right to read
> is not "shut off" during the borrow. I think the fix would have to be to
> replace this with some sort of "generalized swap" operation.
>
>
> Patrick
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/c41c22db/attachment.html>

From pwalton at mozilla.com  Sat Sep  7 08:55:09 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 07 Sep 2013 08:55:09 -0700
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
 of linearity
In-Reply-To: <CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
Message-ID: <522B4C5D.8010400@mozilla.com>

On 9/7/13 8:39 AM, Oren Ben-Kiki wrote:
> I have a feeling that there is a non-trivial amount of code which is
> "actually safe" but would impossible to convince the compiler it is
> "statically safe". Surely having run-time safety in such cases is better
> than none at all...?

I would be fine with this, but one big problem is that null pointer 
dereferences are undefined behavior in LLVM.

Patrick


From oren at ben-kiki.org  Sat Sep  7 09:09:20 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 7 Sep 2013 19:09:20 +0300
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <522B4C5D.8010400@mozilla.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
Message-ID: <CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>

Is there any system in actual use where actually dereferencing a null
pointer will not cause an exception? I mean, _sure_, the C spec says the
result is "undefined", but isn't this just a leftover from the "bad old
days", like also supporting non-byte-addressible machines (with
non-power-of-two word size!), and other such horribleness?

If in practice on any machine today (X86, ARM, PowerPC, MIPS, SPARC, ...)
every null pointer will fault (which I strongly hope will...), then I'd be
quite happy in saying formally that accessing a hole leads to "undefined
behavior" and make good use of knowledge that any such access will, in
fact, fault, on any machine I might be coding to today.


On Sat, Sep 7, 2013 at 6:55 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> On 9/7/13 8:39 AM, Oren Ben-Kiki wrote:
>
>> I have a feeling that there is a non-trivial amount of code which is
>> "actually safe" but would impossible to convince the compiler it is
>> "statically safe". Surely having run-time safety in such cases is better
>> than none at all...?
>>
>
> I would be fine with this, but one big problem is that null pointer
> dereferences are undefined behavior in LLVM.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/0d9f6bc5/attachment.html>

From danielmicay at gmail.com  Sat Sep  7 09:20:40 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 12:20:40 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
Message-ID: <CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>

On Sat, Sep 7, 2013 at 12:09 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> If in practice on any machine today (X86, ARM, PowerPC, MIPS, SPARC, ...)
> every null pointer will fault (which I strongly hope will...), then I'd be
> quite happy in saying formally that accessing a hole leads to "undefined
> behavior" and make good use of knowledge that any such access will, in
> fact, fault, on any machine I might be coding to today.
>

You get a segmentation fault on Linux because the first page is marked
read-only for userland processes. It's valid on almost any hardware to
dereference a pointer equal to zero, which is how LLVM defines the null
pointer. However, LLVM explicitly considers a dereference of the null
pointer to be undefined behaviour so it doesn't matter how it could or
couldn't be implemented in hardware.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/b65f5b3f/attachment.html>

From oren at ben-kiki.org  Sat Sep  7 13:15:26 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 7 Sep 2013 23:15:26 +0300
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
Message-ID: <CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>

I miss-spoke; when I said "machine" I meant "platform" (combination of HW
and SW). Is unintentionally dereferencing a null pointer a silent error on
any existing platform?

But isn't a very good question either. A better one would be: Would it be
_useful_ to define `steal` and use it in programs, such that it triggers a
null pointer dereference (undefined behavior and all) if someone tries to
access the hole? This is a softer question and I suspect the answer is
"yes" - at least until a better way to safely update structures in-place is
found...


On Sat, Sep 7, 2013 at 7:20 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Sep 7, 2013 at 12:09 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> If in practice on any machine today (X86, ARM, PowerPC, MIPS, SPARC, ...)
>> every null pointer will fault (which I strongly hope will...), then I'd be
>> quite happy in saying formally that accessing a hole leads to "undefined
>> behavior" and make good use of knowledge that any such access will, in
>> fact, fault, on any machine I might be coding to today.
>>
>
> You get a segmentation fault on Linux because the first page is marked
> read-only for userland processes. It's valid on almost any hardware to
> dereference a pointer equal to zero, which is how LLVM defines the null
> pointer. However, LLVM explicitly considers a dereference of the null
> pointer to be undefined behaviour so it doesn't matter how it could or
> couldn't be implemented in hardware.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/317e3d73/attachment.html>

From danielmicay at gmail.com  Sat Sep  7 13:22:47 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 16:22:47 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
Message-ID: <CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>

On Sat, Sep 7, 2013 at 4:15 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I miss-spoke; when I said "machine" I meant "platform" (combination of HW
> and SW). Is unintentionally dereferencing a null pointer a silent error on
> any existing platform?
>

Yes, it's only a segmentation fault in userland code on platforms where the
kernel is set up to make the lowest page read-only. Rust still needs to be
memory safe in a kernel.

 But isn't a very good question either. A better one would be: Would it be
> _useful_ to define `steal` and use it in programs, such that it triggers a
> null pointer dereference (undefined behavior and all) if someone tries to
> access the hole? This is a softer question and I suspect the answer is
> "yes" - at least until a better way to safely update structures in-place is
> found...
>

It would be undefined behaviour, so it wouldn't be useful. Rust is a memory
safe language and can't allow safe code to generate LLVM IR invoking
undefined behaviour.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/de1f33b1/attachment.html>

From rexlen at gmail.com  Sat Sep  7 13:25:07 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Sat, 7 Sep 2013 22:25:07 +0200
Subject: [rust-dev] Fwd:  functions
In-Reply-To: <522B2139.4090406@gmail.com>
References: <CAM0XVgsZ_yxQxEEAPX6J2_3Dn_CDsSMQCKuUxLSnybxnXm_qyA@mail.gmail.com>
	<522B2139.4090406@gmail.com>
Message-ID: <CAM0XVgsykYwC5jWUXQW1CqUvdBX3fM6fXU=tMG=hR-2e5B9+Rg@mail.gmail.com>

Yes, this is a smart workaround..... i hope we will have something better
in Rust but this a good answer to this need.

Regards,




On 07/09/13 22:11, Renato Lenzi wrote:

> Is it possibile, or will be possibile, to use default parameters and/or
> named parameters in Rust?
> In the docs i couldn't find anything about this (may be my fault...)
> Regards.
>
>  It is not possible currently, but there's an open bug [6973] and with
(quite) a bit of discussion. Two current methods for simulating them would
be defining wrapper functions for the common shortcuts, or passing the
default/named args as a struct and use a "functional record update" (FRU),
e.g.

  struct FooArgs {
     x: int,
     y: int,
     z: int,
  }

  static DEFAULT_FOO: FooArgs = FooArgs { x: 1, y: 2, z: 3 };

  /// a, b are compulsory, anything in rest is a default arg
  fn foo(a: uint, b: uint, rest: FooArgs) { ... }


  fn main() {
    // only defaults
    foo(10, 100, DEFAULT_FOO);

    // y = -3, defaults for the rest
    foo(10, 100, FooArgs { y: -3, .. DEFAULT_FOO }) // `..` indicates an FRU
  }

This one is unfortunately ugly, but it seems to get the job done.

Huon

[6973]: https://github.com/mozilla/**rust/issues/6973<https://github.com/mozilla/rust/issues/6973>
______________________________**_________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/193847c2/attachment.html>

From irving at naml.us  Sat Sep  7 13:27:11 2013
From: irving at naml.us (Geoffrey Irving)
Date: Sat, 7 Sep 2013 13:27:11 -0700
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
Message-ID: <51E9E108-658F-462A-9F08-24624931656E@naml.us>

To clarify why undefined behavior is really bad in practice: if LLVM ever detects that your code performs undefined behavior according to the standard, it is *designed* to take full advantage of that fact when making optimizations.  In other words, all hell will break lose, in potentially very complicated and subtle ways.

Geoffrey

On Sep 7, 2013, at 1:22 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Sep 7, 2013 at 4:15 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> I miss-spoke; when I said "machine" I meant "platform" (combination of HW and SW). Is unintentionally dereferencing a null pointer a silent error on any existing platform?
> 
> Yes, it's only a segmentation fault in userland code on platforms where the kernel is set up to make the lowest page read-only. Rust still needs to be memory safe in a kernel.
> 
> But isn't a very good question either. A better one would be: Would it be _useful_ to define `steal` and use it in programs, such that it triggers a null pointer dereference (undefined behavior and all) if someone tries to access the hole? This is a softer question and I suspect the answer is "yes" - at least until a better way to safely update structures in-place is found...
> 
> It would be undefined behaviour, so it wouldn't be useful. Rust is a memory safe language and can't allow safe code to generate LLVM IR invoking undefined behaviour. 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/bba77908/attachment.sig>

From danielmicay at gmail.com  Sat Sep  7 13:32:43 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 16:32:43 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <51E9E108-658F-462A-9F08-24624931656E@naml.us>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
Message-ID: <CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>

On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us> wrote:

> To clarify why undefined behavior is really bad in practice: if LLVM ever
> detects that your code performs undefined behavior according to the
> standard, it is *designed* to take full advantage of that fact when making
> optimizations.  In other words, all hell will break lose, in potentially
> very complicated and subtle ways.
>
> Geoffrey
>

Note that there's no detection of undefined behaviour or optimizations
based upon it being detected. LLVM simply operates on valid LLVM bytecode,
and if it performs undefined behaviour it is not valid LLVM bytecode. The
optimization passes and code generation will base all of their assumptions
on the invariants provided by the specification, including that null
pointers are never dereferenced.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/9c6e7527/attachment-0001.html>

From oren at ben-kiki.org  Sat Sep  7 13:34:49 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 7 Sep 2013 23:34:49 +0300
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <51E9E108-658F-462A-9F08-24624931656E@naml.us>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
Message-ID: <CADJiDhuFkePF4ejF=NPj2uFid7wOSnmzA-_foZZ6yG3G7xWebQ@mail.gmail.com>

Alas. So I guess it all depends on someone finding a smart safe way to
generalize the swap operation, or something... as things stand, it is
extremely difficult to efficiently and safely implement complex nested
containers. I will admit I am using the `steal` function for now, it just
makes things so much easier, but I know I'll have to pay for my sins down
the line...



On Sat, Sep 7, 2013 at 11:27 PM, Geoffrey Irving <irving at naml.us> wrote:

> To clarify why undefined behavior is really bad in practice: if LLVM ever
> detects that your code performs undefined behavior according to the
> standard, it is *designed* to take full advantage of that fact when making
> optimizations.  In other words, all hell will break lose, in potentially
> very complicated and subtle ways.
>
> Geoffrey
>
> On Sep 7, 2013, at 1:22 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> > On Sat, Sep 7, 2013 at 4:15 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> > I miss-spoke; when I said "machine" I meant "platform" (combination of
> HW and SW). Is unintentionally dereferencing a null pointer a silent error
> on any existing platform?
> >
> > Yes, it's only a segmentation fault in userland code on platforms where
> the kernel is set up to make the lowest page read-only. Rust still needs to
> be memory safe in a kernel.
> >
> > But isn't a very good question either. A better one would be: Would it
> be _useful_ to define `steal` and use it in programs, such that it triggers
> a null pointer dereference (undefined behavior and all) if someone tries to
> access the hole? This is a softer question and I suspect the answer is
> "yes" - at least until a better way to safely update structures in-place is
> found...
> >
> > It would be undefined behaviour, so it wouldn't be useful. Rust is a
> memory safe language and can't allow safe code to generate LLVM IR invoking
> undefined behaviour.
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/7e876dff/attachment.html>

From irving at naml.us  Sat Sep  7 13:37:09 2013
From: irving at naml.us (Geoffrey Irving)
Date: Sat, 7 Sep 2013 13:37:09 -0700
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
	<CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
Message-ID: <CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>


On Sep 7, 2013, at 1:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us> wrote:
> To clarify why undefined behavior is really bad in practice: if LLVM ever detects that your code performs undefined behavior according to the standard, it is *designed* to take full advantage of that fact when making optimizations.  In other words, all hell will break lose, in potentially very complicated and subtle ways.
> 
> Geoffrey
> 
> Note that there's no detection of undefined behaviour or optimizations based upon it being detected. LLVM simply operates on valid LLVM bytecode, and if it performs undefined behaviour it is not valid LLVM bytecode. The optimization passes and code generation will base all of their assumptions on the invariants provided by the specification, including that null pointers are never dereferenced.

That may be true; I got the opposite impression from this article:

    http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html

Geoffrey
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/7f772629/attachment.sig>

From danielmicay at gmail.com  Sat Sep  7 13:42:24 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 16:42:24 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
	<CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
	<CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>
Message-ID: <CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>

On Sat, Sep 7, 2013 at 4:37 PM, Geoffrey Irving <irving at naml.us> wrote:

>
> On Sep 7, 2013, at 1:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> > On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us> wrote:
> > To clarify why undefined behavior is really bad in practice: if LLVM
> ever detects that your code performs undefined behavior according to the
> standard, it is *designed* to take full advantage of that fact when making
> optimizations.  In other words, all hell will break lose, in potentially
> very complicated and subtle ways.
> >
> > Geoffrey
> >
> > Note that there's no detection of undefined behaviour or optimizations
> based upon it being detected. LLVM simply operates on valid LLVM bytecode,
> and if it performs undefined behaviour it is not valid LLVM bytecode. The
> optimization passes and code generation will base all of their assumptions
> on the invariants provided by the specification, including that null
> pointers are never dereferenced.
>
> That may be true; I got the opposite impression from this article:
>
>
> http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
>
> Geoffrey
>

You're getting a very wrong impression if you think it optimizes based on
those assumptions only when it can detect undefined behaviour. It
completely ignores the possibility of undefined behaviour in the
optimization passes by assuming all of the invariants required for the
bytecode to be valid hold true.

The `-fcatch-undefined-behaviour` switch inserts runtime checks.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/e54a6f4b/attachment.html>

From danielmicay at gmail.com  Sat Sep  7 13:44:52 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 16:44:52 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
	<CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
	<CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>
	<CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>
Message-ID: <CA+DvKQJ5QRhsE9QcHoGHaJ+JknjUcOz0HeOr4n-Vnyqa8O7o_w@mail.gmail.com>

On Sat, Sep 7, 2013 at 4:42 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Sep 7, 2013 at 4:37 PM, Geoffrey Irving <irving at naml.us> wrote:
>
>>
>> On Sep 7, 2013, at 1:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>>
>> > On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us> wrote:
>> > To clarify why undefined behavior is really bad in practice: if LLVM
>> ever detects that your code performs undefined behavior according to the
>> standard, it is *designed* to take full advantage of that fact when making
>> optimizations.  In other words, all hell will break lose, in potentially
>> very complicated and subtle ways.
>> >
>> > Geoffrey
>> >
>> > Note that there's no detection of undefined behaviour or optimizations
>> based upon it being detected. LLVM simply operates on valid LLVM bytecode,
>> and if it performs undefined behaviour it is not valid LLVM bytecode. The
>> optimization passes and code generation will base all of their assumptions
>> on the invariants provided by the specification, including that null
>> pointers are never dereferenced.
>>
>> That may be true; I got the opposite impression from this article:
>>
>>
>> http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
>>
>> Geoffrey
>>
>
> You're getting a very wrong impression if you think it optimizes based on
> those assumptions only when it can detect undefined behaviour. It
> completely ignores the possibility of undefined behaviour in the
> optimization passes by assuming all of the invariants required for the
> bytecode to be valid hold true.
>
> The `-fcatch-undefined-behaviour` switch inserts runtime checks.
>

Note that `clang` generating traps on certain operations left undefined by
C to aid in debugging is unrelated to Rust, because we don't compile to C
and then compile with `clang`. There are no exceptions to the undefined
behaviour rules for us.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/066bcf4b/attachment-0001.html>

From irving at naml.us  Sat Sep  7 13:47:40 2013
From: irving at naml.us (Geoffrey Irving)
Date: Sat, 7 Sep 2013 13:47:40 -0700
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
	<CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
	<CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>
	<CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>
Message-ID: <B950BE10-5DDE-4B67-A173-C3849F19D5C3@naml.us>

On Sep 7, 2013, at 1:42 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Sep 7, 2013 at 4:37 PM, Geoffrey Irving <irving at naml.us> wrote:
> 
> On Sep 7, 2013, at 1:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> 
> > On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us> wrote:
> > To clarify why undefined behavior is really bad in practice: if LLVM ever detects that your code performs undefined behavior according to the standard, it is *designed* to take full advantage of that fact when making optimizations.  In other words, all hell will break lose, in potentially very complicated and subtle ways.
> >
> > Geoffrey
> >
> > Note that there's no detection of undefined behaviour or optimizations based upon it being detected. LLVM simply operates on valid LLVM bytecode, and if it performs undefined behaviour it is not valid LLVM bytecode. The optimization passes and code generation will base all of their assumptions on the invariants provided by the specification, including that null pointers are never dereferenced.
> 
> That may be true; I got the opposite impression from this article:
> 
>     http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
> 
> Geoffrey
> 
> You're getting a very wrong impression if you think it optimizes based on those assumptions only when it can detect undefined behaviour. It completely ignores the possibility of undefined behaviour in the optimization passes by assuming all of the invariants required for the bytecode to be valid hold true.
> 
> The `-fcatch-undefined-behaviour` switch inserts runtime checks.

I think we're saying the same thing: I didn't intend to imply that it optimizes based on those assumptions only if it can prove that undefined behavior never occurs.  If it detects undefined behavior along certain paths, it will assume those paths can never occur, and then propagate those assumptions backwards through the program in an attempt to make simplifications.  Thus, a null pointer access somewhere could easily complete a weirdly incorrect assumption causing a previous branch to be taken incorrectly.

Geoffrey
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/3d706e12/attachment.sig>

From danielmicay at gmail.com  Sat Sep  7 13:49:25 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 7 Sep 2013 16:49:25 -0400
Subject: [rust-dev] RFC: Stealing: lexically-scoped temporary violation
	of linearity
In-Reply-To: <B950BE10-5DDE-4B67-A173-C3849F19D5C3@naml.us>
References: <52211DE7.7050909@mozilla.com> <52213DE0.2000109@mozilla.com>
	<CADJiDhvEKRy9n-6b0M7cqdO4ow9tRJGT7y2BkLZach-rkXED5w@mail.gmail.com>
	<522B4C5D.8010400@mozilla.com>
	<CADJiDhsUMS1MiVabqyWGGRs=uZK_PxQmWDR-eU0vJJNtcpKSaw@mail.gmail.com>
	<CA+DvKQLXjNJ7ryP3ZFTwnuGDqBJY1XPBkGDV-60u-YAZC=3pdA@mail.gmail.com>
	<CADJiDhuRhmM8AxarU1tReqT8N1NW6VoHxOSHPCnjqBwpkEx5cg@mail.gmail.com>
	<CA+DvKQKp4K=jSM7rJuqWnYu=xFSBXvA9ODMvZTdHc+G2NAznRg@mail.gmail.com>
	<51E9E108-658F-462A-9F08-24624931656E@naml.us>
	<CA+DvKQ+QzV8G0cfhZuyyRjnnJ_WcV6QniDp2qeufyYebF7ANQQ@mail.gmail.com>
	<CF1F03D7-8181-4ABC-91BE-8C9F130E99EE@naml.us>
	<CA+DvKQ++jKUCitZ8Q7yX7_W0e6ZRQAcCr=pP0bCT2rE7qLmFZA@mail.gmail.com>
	<B950BE10-5DDE-4B67-A173-C3849F19D5C3@naml.us>
Message-ID: <CA+DvKQL8Oe6dGeRrCAN_U2WTCgXn36tVVU74qaTfFXhfoNQEuw@mail.gmail.com>

On Sat, Sep 7, 2013 at 4:47 PM, Geoffrey Irving <irving at naml.us> wrote:

> On Sep 7, 2013, at 1:42 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> > On Sat, Sep 7, 2013 at 4:37 PM, Geoffrey Irving <irving at naml.us> wrote:
> >
> > On Sep 7, 2013, at 1:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> >
> > > On Sat, Sep 7, 2013 at 4:27 PM, Geoffrey Irving <irving at naml.us>
> wrote:
> > > To clarify why undefined behavior is really bad in practice: if LLVM
> ever detects that your code performs undefined behavior according to the
> standard, it is *designed* to take full advantage of that fact when making
> optimizations.  In other words, all hell will break lose, in potentially
> very complicated and subtle ways.
> > >
> > > Geoffrey
> > >
> > > Note that there's no detection of undefined behaviour or optimizations
> based upon it being detected. LLVM simply operates on valid LLVM bytecode,
> and if it performs undefined behaviour it is not valid LLVM bytecode. The
> optimization passes and code generation will base all of their assumptions
> on the invariants provided by the specification, including that null
> pointers are never dereferenced.
> >
> > That may be true; I got the opposite impression from this article:
> >
> >
> http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
> >
> > Geoffrey
> >
> > You're getting a very wrong impression if you think it optimizes based
> on those assumptions only when it can detect undefined behaviour. It
> completely ignores the possibility of undefined behaviour in the
> optimization passes by assuming all of the invariants required for the
> bytecode to be valid hold true.
> >
> > The `-fcatch-undefined-behaviour` switch inserts runtime checks.
>
> I think we're saying the same thing: I didn't intend to imply that it
> optimizes based on those assumptions only if it can prove that undefined
> behavior never occurs.  If it detects undefined behavior along certain
> paths, it will assume those paths can never occur, and then propagate those
> assumptions backwards through the program in an attempt to make
> simplifications.  Thus, a null pointer access somewhere could easily
> complete a weirdly incorrect assumption causing a previous branch to be
> taken incorrectly.
>
> Geoffrey
>

Ah okay, we're on the same page then :).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130907/d0e5b46a/attachment.html>

From martindemello at gmail.com  Sun Sep  8 00:00:04 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Sun, 8 Sep 2013 00:00:04 -0700
Subject: [rust-dev] c structs with bitfields
Message-ID: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>

I was looking at the bindgen bug for incorrect bitfield handling

https://github.com/crabtw/rust-bindgen/issues/8

but from a quick pass through the rust manual I can't figure out what
the correct behaviour would be.

What, for example, would the correct bindgen output for the following be:

struct bit {
  int alpha : 12;
  int beta : 6;
  int gamma : 2;
};

martin

From corey at octayn.net  Sun Sep  8 07:31:00 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 8 Sep 2013 10:31:00 -0400
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
Message-ID: <CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>

On Sun, Sep 8, 2013 at 3:00 AM, Martin DeMello <martindemello at gmail.com>wrote:

> I was looking at the bindgen bug for incorrect bitfield handling
>
> https://github.com/crabtw/rust-bindgen/issues/8
>
> but from a quick pass through the rust manual I can't figure out what
> the correct behaviour would be.
>
> What, for example, would the correct bindgen output for the following be:
>
> struct bit {
>   int alpha : 12;
>   int beta : 6;
>   int gamma : 2;
> };
>
>
You'll have to check what the various C compilers do with bitfields. I
imagine they pack the bitfields into the smallest integer type that will
contain them all. But, almost everything about bitfields is entirely
implementation defined, so it's probably going to be difficult to come up
with what to do correctly in any portable way.

Once you actually figure out what to generate, though, methods for
getting/setting the bitfields would probably be best.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130908/8e3e357c/attachment.html>

From matthieu.monrocq at gmail.com  Sun Sep  8 10:49:08 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 8 Sep 2013 19:49:08 +0200
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
Message-ID: <CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>

Actually, for bitfields the types into which the bits are packed are not
left to the compiler. If you said "int c : 4", then it will use a "int".

If you have:

int a : 24;
int b : 24;
int c : 16;

and int is 32 bits on your platform, then a will be 24 somewhere in 32
bits, same thing for b, and c will be 16 bits somewhere in 32 bits; for a
single bit field cannot be split among several underlying integers.

Exactly where the bits lie within the type, though, is part of the ABI.

-- Matthieu


On Sun, Sep 8, 2013 at 4:31 PM, Corey Richardson <corey at octayn.net> wrote:

> On Sun, Sep 8, 2013 at 3:00 AM, Martin DeMello <martindemello at gmail.com>wrote:
>
>> I was looking at the bindgen bug for incorrect bitfield handling
>>
>> https://github.com/crabtw/rust-bindgen/issues/8
>>
>> but from a quick pass through the rust manual I can't figure out what
>> the correct behaviour would be.
>>
>> What, for example, would the correct bindgen output for the following be:
>>
>> struct bit {
>>   int alpha : 12;
>>   int beta : 6;
>>   int gamma : 2;
>> };
>>
>>
> You'll have to check what the various C compilers do with bitfields. I
> imagine they pack the bitfields into the smallest integer type that will
> contain them all. But, almost everything about bitfields is entirely
> implementation defined, so it's probably going to be difficult to come up
> with what to do correctly in any portable way.
>
> Once you actually figure out what to generate, though, methods for
> getting/setting the bitfields would probably be best.
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130908/d1925a19/attachment-0001.html>

From corey at octayn.net  Sun Sep  8 10:50:24 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 8 Sep 2013 13:50:24 -0400
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
Message-ID: <CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>

On Sun, Sep 8, 2013 at 1:49 PM, Matthieu Monrocq <matthieu.monrocq at gmail.com
> wrote:

> Actually, for bitfields the types into which the bits are packed are not
> left to the compiler. If you said "int c : 4", then it will use a "int".
>
> If you have:
>
> int a : 24;
> int b : 24;
> int c : 16;
>
> and int is 32 bits on your platform, then a will be 24 somewhere in 32
> bits, same thing for b, and c will be 16 bits somewhere in 32 bits; for a
> single bit field cannot be split among several underlying integers.
>
>
I didn't get that understanding from my reading of the C11 standard; which
standard and section says this? I could have misunderstood.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130908/dcca9ca5/attachment.html>

From matthieu.monrocq at gmail.com  Sun Sep  8 12:36:10 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 8 Sep 2013 21:36:10 +0200
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
Message-ID: <CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>

I was using the C++11 Standard actually, but I spoke from memory.
Consulting n3485 9.6 [class.bit] it is indeed less clear-cut than I thought.

1/ [...] The value of the integral constant expression may be larger than
the number of bits in the
object representation (3.9) of the bit-field?s type; in such cases the
extra bits are used as padding bits and
do not participate in the value representation (3.9) of the bit-field. [...]

Seems to indicate that the type used for the bit-field does matter. That is
if the underlying type is too narrow, then the representable range of
values is cropped.

However it continue thusly:

1/ [...] Bit-fields are packed into some addressable allocation unit. [
Note: Bit-fields straddle allocation units on some machines and not on
others. [...]

Unfortunately it is unclear, now that I read back, what "allocation unit"
truly means. I searched in gcc documentation and even them defer the
decision to the ABI [1]


In any case, given that:

1/ [...] Allocation of bit-fields within a class object is
implementation-defined. Alignment of bit-fields is implementation-defined.
[...]

and

1/ [...] Bit-fields are assigned right-to-left on some machines,
left-to-right on others. [...]

So it appears that one would really need to check the ABI even for the
least properties of bit-fields.


-- Matthieu

[1]:
http://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html



On Sun, Sep 8, 2013 at 7:50 PM, Corey Richardson <corey at octayn.net> wrote:

> On Sun, Sep 8, 2013 at 1:49 PM, Matthieu Monrocq <
> matthieu.monrocq at gmail.com> wrote:
>
>> Actually, for bitfields the types into which the bits are packed are not
>> left to the compiler. If you said "int c : 4", then it will use a "int".
>>
>> If you have:
>>
>> int a : 24;
>> int b : 24;
>> int c : 16;
>>
>> and int is 32 bits on your platform, then a will be 24 somewhere in 32
>> bits, same thing for b, and c will be 16 bits somewhere in 32 bits; for a
>> single bit field cannot be split among several underlying integers.
>>
>>
> I didn't get that understanding from my reading of the C11 standard; which
> standard and section says this? I could have misunderstood.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130908/0989263b/attachment.html>

From martindemello at gmail.com  Sun Sep  8 16:20:34 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Sun, 8 Sep 2013 16:20:34 -0700
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
Message-ID: <CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>

So am I right that bitfield widths would first need to be added to the
rust struct definition and code generator before they can be added to
bindgen? I poked around the AST and middle code a bit but couldn't
find it if it was there.

martin

On Sun, Sep 8, 2013 at 12:36 PM, Matthieu Monrocq
<matthieu.monrocq at gmail.com> wrote:
> I was using the C++11 Standard actually, but I spoke from memory. Consulting
> n3485 9.6 [class.bit] it is indeed less clear-cut than I thought.
>
> 1/ [...] The value of the integral constant expression may be larger than
> the number of bits in the
> object representation (3.9) of the bit-field?s type; in such cases the extra
> bits are used as padding bits and
> do not participate in the value representation (3.9) of the bit-field. [...]
>
> Seems to indicate that the type used for the bit-field does matter. That is
> if the underlying type is too narrow, then the representable range of values
> is cropped.
>
> However it continue thusly:
>
> 1/ [...] Bit-fields are packed into some addressable allocation unit. [
> Note: Bit-fields straddle allocation units on some machines and not on
> others. [...]
>
> Unfortunately it is unclear, now that I read back, what "allocation unit"
> truly means. I searched in gcc documentation and even them defer the
> decision to the ABI [1]
>
>
> In any case, given that:
>
> 1/ [...] Allocation of bit-fields within a class object is
> implementation-defined. Alignment of bit-fields is implementation-defined.
> [...]
>
> and
>
> 1/ [...] Bit-fields are assigned right-to-left on some machines,
> left-to-right on others. [...]
>
> So it appears that one would really need to check the ABI even for the least
> properties of bit-fields.
>
>
> -- Matthieu
>
> [1]:
> http://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html
>
>
>
> On Sun, Sep 8, 2013 at 7:50 PM, Corey Richardson <corey at octayn.net> wrote:
>>
>> On Sun, Sep 8, 2013 at 1:49 PM, Matthieu Monrocq
>> <matthieu.monrocq at gmail.com> wrote:
>>>
>>> Actually, for bitfields the types into which the bits are packed are not
>>> left to the compiler. If you said "int c : 4", then it will use a "int".
>>>
>>> If you have:
>>>
>>> int a : 24;
>>> int b : 24;
>>> int c : 16;
>>>
>>> and int is 32 bits on your platform, then a will be 24 somewhere in 32
>>> bits, same thing for b, and c will be 16 bits somewhere in 32 bits; for a
>>> single bit field cannot be split among several underlying integers.
>>>
>>
>> I didn't get that understanding from my reading of the C11 standard; which
>> standard and section says this? I could have misunderstood.
>
>

From corey at octayn.net  Sun Sep  8 17:14:30 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 8 Sep 2013 20:14:30 -0400
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
	<CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
Message-ID: <CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>

On Sun, Sep 8, 2013 at 7:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
> So am I right that bitfield widths would first need to be added to the
> rust struct definition and code generator before they can be added to
> bindgen? I poked around the AST and middle code a bit but couldn't
> find it if it was there.
>

Rust doesn't have bitfields and neither does LLVM, nor do I think we should:

1. bitfield members aren't addressable.
2. It would be near impossible to replicate the exact behavior of
every C compiler for every platform and ABI it supports.
3. They add significant additional complexity.

From martindemello at gmail.com  Sun Sep  8 17:20:31 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Sun, 8 Sep 2013 17:20:31 -0700
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
	<CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
	<CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>
Message-ID: <CAFrFfuHrqGbSz1HPDD2abQUv=L7BmkmCd=jFmAt=0X8yJThceA@mail.gmail.com>

On Sun, Sep 8, 2013 at 5:14 PM, Corey Richardson <corey at octayn.net> wrote:
> On Sun, Sep 8, 2013 at 7:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>> So am I right that bitfield widths would first need to be added to the
>> rust struct definition and code generator before they can be added to
>> bindgen? I poked around the AST and middle code a bit but couldn't
>> find it if it was there.
>>
>
> Rust doesn't have bitfields and neither does LLVM, nor do I think we should:
>
> 1. bitfield members aren't addressable.
> 2. It would be near impossible to replicate the exact behavior of
> every C compiler for every platform and ABI it supports.
> 3. They add significant additional complexity.

Which returns me to the higher-level question, then - what is the
correct thing for bindgen to do if handed a C struct with them?

martin

From corey at octayn.net  Sun Sep  8 19:37:26 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 8 Sep 2013 22:37:26 -0400
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAFrFfuHrqGbSz1HPDD2abQUv=L7BmkmCd=jFmAt=0X8yJThceA@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
	<CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
	<CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>
	<CAFrFfuHrqGbSz1HPDD2abQUv=L7BmkmCd=jFmAt=0X8yJThceA@mail.gmail.com>
Message-ID: <CA++BO6RCaSgB3NMLKE0bXoFsY=D8q=NovC8q70Qz=EhPvK2sYQ@mail.gmail.com>

Emit an error and fail, I'd say, unless you can tell it which ABI it's
targetting so it knows how to handle it.

On Sun, Sep 8, 2013 at 8:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
> On Sun, Sep 8, 2013 at 5:14 PM, Corey Richardson <corey at octayn.net> wrote:
>> On Sun, Sep 8, 2013 at 7:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>>> So am I right that bitfield widths would first need to be added to the
>>> rust struct definition and code generator before they can be added to
>>> bindgen? I poked around the AST and middle code a bit but couldn't
>>> find it if it was there.
>>>
>>
>> Rust doesn't have bitfields and neither does LLVM, nor do I think we should:
>>
>> 1. bitfield members aren't addressable.
>> 2. It would be near impossible to replicate the exact behavior of
>> every C compiler for every platform and ABI it supports.
>> 3. They add significant additional complexity.
>
> Which returns me to the higher-level question, then - what is the
> correct thing for bindgen to do if handed a C struct with them?
>
> martin

From lists at ncameron.org  Mon Sep  9 00:04:07 2013
From: lists at ncameron.org (Nick Cameron)
Date: Mon, 9 Sep 2013 19:04:07 +1200
Subject: [rust-dev] Subtyping in Rust
Message-ID: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>

Is there somewhere I can look for a description of subtyping in Rust? I
don't see any mention of it in the manual or tutorial.

Thanks, Nick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130909/f7fd03ea/attachment.html>

From corey at octayn.net  Mon Sep  9 05:51:38 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 9 Sep 2013 08:51:38 -0400
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
Message-ID: <CA++BO6ToiQTTi-31XdQ+oW-cNGb6zqFYHGaK+jrWRnhC8HX5hw@mail.gmail.com>

On Mon, Sep 9, 2013 at 3:04 AM, Nick Cameron <lists at ncameron.org> wrote:
> Is there somewhere I can look for a description of subtyping in Rust? I
> don't see any mention of it in the manual or tutorial.
>

Rust has 0 subtyping except that: every type is considered a subtype
of `bottom` (which has no syntax, but it's the return type of a
divergent function (one that never returns) such as fail!()), and
every lifetime is considered a sublifetime of `'static`

From niko at alum.mit.edu  Mon Sep  9 06:34:58 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 9 Sep 2013 09:34:58 -0400
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
Message-ID: <20130909133458.GE3459@Mr-Bennet>

By subtyping, do you mean defining class hierarchies as in C++ or
Java?  This is currently not supported. Typically such hierarchies
are modeled either using an `enum` (most common) or using a `trait`.

Enums are perfect for cases where there is a limited set of
possibilities. Traits are perfect for "open-ended" situations where
you have an interface and many ways to fulfill it. The two techniques
*can* be combined for cases that fall between the two extremes.

We have considered adding a limited form of struct inheritance (so
that one struct can build on another) but afaik this feature is not
planned in the short term.


Niko

On Mon, Sep 09, 2013 at 07:04:07PM +1200, Nick Cameron wrote:
> Is there somewhere I can look for a description of subtyping in Rust? I
> don't see any mention of it in the manual or tutorial.
> 
> Thanks, Nick

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From jon.mb at proinbox.com  Mon Sep  9 07:09:14 2013
From: jon.mb at proinbox.com (John Mija)
Date: Mon, 09 Sep 2013 15:09:14 +0100
Subject: [rust-dev] Embed language in Rust
Message-ID: <522DD68A.5080600@proinbox.com>

Which would be the best way (respect to performance) to embed a language 
like Go in Rust?

(a) Since the Go compilers are written in C, it could be wrapped the 
functions for compiling and linking, and then to do a system call to run 
the binary.

(b) To call directly to the binaries to compile, link, and a last call 
to run the final binary.

(c) Create a VM but it takes a lot of memory and it is necessary to be 
an export in virtual machines to get a good performance, but the 
negative part is that it takes a lot of memory. Lua works of this way; 
it is basically a library written in C with an implementation based into 
a VM to be easily embedded.

(d) Compile Go source to Rust.

* * *

Why to use Go like embedded language?

Go would be a great language for the user interface code of an 
application like a game; the syntax is simple, with garbage-collection 
getting simpler code that is developed faster, and the concurrency model 
fits well to handle events asynchronously.

From chris at cmoz.me  Mon Sep  9 07:17:31 2013
From: chris at cmoz.me (Chris Molozian)
Date: Mon, 9 Sep 2013 15:17:31 +0100
Subject: [rust-dev] Embed language in Rust
In-Reply-To: <522DD68A.5080600@proinbox.com>
References: <522DD68A.5080600@proinbox.com>
Message-ID: <etPan.522dd87b.66334873.1625@Christophers-MacBook-Air.local>

Hi John,

It might be worth checking out Squirrel:?http://www.squirrel-lang.org/?as an embeddable games programming language. I've not used it myself, I always turn to Lua first (out of habit) but I've heard great things about it.

It would be interesting to see bindings for it for Rust. :)

Cheers,

Chris

On 9 September 2013 at 15:09:20, John Mija (jon.mb at proinbox.com) wrote:

Which would be the best way (respect to performance) to embed a language  
like Go in Rust?  

(a) Since the Go compilers are written in C, it could be wrapped the  
functions for compiling and linking, and then to do a system call to run  
the binary.  

(b) To call directly to the binaries to compile, link, and a last call  
to run the final binary.  

(c) Create a VM but it takes a lot of memory and it is necessary to be  
an export in virtual machines to get a good performance, but the  
negative part is that it takes a lot of memory. Lua works of this way;  
it is basically a library written in C with an implementation based into  
a VM to be easily embedded.  

(d) Compile Go source to Rust.  

* * *  

Why to use Go like embedded language?  

Go would be a great language for the user interface code of an  
application like a game; the syntax is simple, with garbage-collection  
getting simpler code that is developed faster, and the concurrency model  
fits well to handle events asynchronously.  
_______________________________________________  
Rust-dev mailing list  
Rust-dev at mozilla.org  
https://mail.mozilla.org/listinfo/rust-dev  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130909/c2b400e1/attachment.html>

From quixoptic at googlemail.com  Fri Sep  6 12:27:49 2013
From: quixoptic at googlemail.com (Alex)
Date: Fri, 6 Sep 2013 20:27:49 +0100
Subject: [rust-dev] Type parameters in trait bounds
Message-ID: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>

Hey Everyone,

I'm new to rust but enjoying it a lot. I'm having trouble with the
following code example:


use std::hashmap::{HashMap, Map};


fn do_something<'input, M: Map<int, &'input str>> (key: int, map: &M){
    match map.find(key){
        Some(result) => println(fmt!("%s", result)),
        None => println("no match")
    };
}

fn main(){
    let  map : HashMap<int, &str> = HashMap::new();
    map.insert(1, "one");
    do_something(1, map);
}


This fails with a compilation error:

example.rs:4:44: 4:47 error: Illegal lifetime 'input: only 'self is allowed
as part of a type declaration
example.rs:4 fn do_something<'input, M: Map<int, &'input str>> (key: int,
map: &M){


Now, I'm probably misunderstanding a bunch of things here, firstly all the
example code I've seen out there uses the HashMap type directly rather than
the Map trait, is this idiomatic? Secondly, I'm still getting my head
around lifetimes and probably have this all muddled so any pointers there
would be welcome.

Thanks
Alex Good
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130906/b4887358/attachment.html>

From oren at ben-kiki.org  Mon Sep  9 10:14:50 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 9 Sep 2013 20:14:50 +0300
Subject: [rust-dev] Type parameters in trait bounds
In-Reply-To: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>
References: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>
Message-ID: <CADJiDhv-g8gqKBq2=GQAJcvPWSsFw0rd2WEs+G3yQgJYVCdWHQ@mail.gmail.com>

Rust newbie here as well, trying to develop an intuition for these things
myself :-) Off the top of my head - you are saying the map holds entries
whose lifetime is 'input; but there's no guarantee that the map lifetime
itself wouldn't be longer than that. Try saying &'input M instead of &M and
see how it goes.

Oren.


On Fri, Sep 6, 2013 at 10:27 PM, Alex <quixoptic at googlemail.com> wrote:

> Hey Everyone,
>
> I'm new to rust but enjoying it a lot. I'm having trouble with the
> following code example:
>
>
> use std::hashmap::{HashMap, Map};
>
>
> fn do_something<'input, M: Map<int, &'input str>> (key: int, map: &M){
>     match map.find(key){
>         Some(result) => println(fmt!("%s", result)),
>         None => println("no match")
>     };
> }
>
> fn main(){
>     let  map : HashMap<int, &str> = HashMap::new();
>     map.insert(1, "one");
>     do_something(1, map);
> }
>
>
> This fails with a compilation error:
>
> example.rs:4:44: 4:47 error: Illegal lifetime 'input: only 'self is
> allowed as part of a type declaration
> example.rs:4 fn do_something<'input, M: Map<int, &'input str>> (key: int,
> map: &M){
>
>
> Now, I'm probably misunderstanding a bunch of things here, firstly all the
> example code I've seen out there uses the HashMap type directly rather than
> the Map trait, is this idiomatic? Secondly, I'm still getting my head
> around lifetimes and probably have this all muddled so any pointers there
> would be welcome.
>
> Thanks
> Alex Good
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130909/a0575695/attachment.html>

From martindemello at gmail.com  Mon Sep  9 11:47:45 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Mon, 9 Sep 2013 11:47:45 -0700
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CA++BO6RCaSgB3NMLKE0bXoFsY=D8q=NovC8q70Qz=EhPvK2sYQ@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
	<CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
	<CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>
	<CAFrFfuHrqGbSz1HPDD2abQUv=L7BmkmCd=jFmAt=0X8yJThceA@mail.gmail.com>
	<CA++BO6RCaSgB3NMLKE0bXoFsY=D8q=NovC8q70Qz=EhPvK2sYQ@mail.gmail.com>
Message-ID: <CAFrFfuEkEFh3symNGz8JXX6vZ7q+FtsFOVy1ZFC3ua8ni_MGpg@mail.gmail.com>

That seems less than ideal - I mean, there are definitely c libraries
out there with bitfield widths in their header files, and we should be
able to use them from rust. And if we do, there should be a way to
generate the bindings that is systematic enough to be captured within
bindgen (possibly with a flag specifying the ABI).

martin

On Sun, Sep 8, 2013 at 7:37 PM, Corey Richardson <corey at octayn.net> wrote:
> Emit an error and fail, I'd say, unless you can tell it which ABI it's
> targetting so it knows how to handle it.
>
> On Sun, Sep 8, 2013 at 8:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>> On Sun, Sep 8, 2013 at 5:14 PM, Corey Richardson <corey at octayn.net> wrote:
>>> On Sun, Sep 8, 2013 at 7:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>>>> So am I right that bitfield widths would first need to be added to the
>>>> rust struct definition and code generator before they can be added to
>>>> bindgen? I poked around the AST and middle code a bit but couldn't
>>>> find it if it was there.
>>>>
>>>
>>> Rust doesn't have bitfields and neither does LLVM, nor do I think we should:
>>>
>>> 1. bitfield members aren't addressable.
>>> 2. It would be near impossible to replicate the exact behavior of
>>> every C compiler for every platform and ABI it supports.
>>> 3. They add significant additional complexity.
>>
>> Which returns me to the higher-level question, then - what is the
>> correct thing for bindgen to do if handed a C struct with them?
>>
>> martin

From lists at ncameron.org  Mon Sep  9 15:20:02 2013
From: lists at ncameron.org (Nick Cameron)
Date: Tue, 10 Sep 2013 10:20:02 +1200
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <20130909133458.GE3459@Mr-Bennet>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
	<20130909133458.GE3459@Mr-Bennet>
Message-ID: <CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>

To clarify I meant subtyping in the sense of when are types compatible for
some kind of conversion. As opposed to subsumption or subclassing (or at
least, not limited to these cases).

If I have |e as U| when does that succeed, and when does it fail. (Actually
from the manual it was unclear how much checking is done statically vs
dynamically, but that is kind of a tangent). Presumably the cast only
succeeds if the dynamic type of e is a subtype of U (or it can be coerced
or converted to U). An example from the manual (sect 8.1.10) shows that an
instance of an impl can be cast to the type of an implemented trait, are
there other relationships where casting is allowed?

The manual states (sect 7.2.11.5):

"A numeric value can be cast to any numeric type. A raw pointer value can
be cast to or from any integral type or raw pointer type. Any other cast is
unsupported and will fail to compile."

But the last sentence is contradicted by the example in section 8.1.10

Separately, I remember that the various pointer types can be implicitly
converted. I couldn't find anywhere where these conversions are defined. Is
my memory bad or my search skills?

Thanks, Nick


On Tue, Sep 10, 2013 at 1:34 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> By subtyping, do you mean defining class hierarchies as in C++ or
> Java?  This is currently not supported. Typically such hierarchies
> are modeled either using an `enum` (most common) or using a `trait`.
>
> Enums are perfect for cases where there is a limited set of
> possibilities. Traits are perfect for "open-ended" situations where
> you have an interface and many ways to fulfill it. The two techniques
> *can* be combined for cases that fall between the two extremes.
>
> We have considered adding a limited form of struct inheritance (so
> that one struct can build on another) but afaik this feature is not
> planned in the short term.
>
>
> Niko
>
> On Mon, Sep 09, 2013 at 07:04:07PM +1200, Nick Cameron wrote:
> > Is there somewhere I can look for a description of subtyping in Rust? I
> > don't see any mention of it in the manual or tutorial.
> >
> > Thanks, Nick
>
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130910/ec1ff6af/attachment.html>

From jon.mb at proinbox.com  Tue Sep 10 00:01:11 2013
From: jon.mb at proinbox.com (John Mija)
Date: Tue, 10 Sep 2013 08:01:11 +0100
Subject: [rust-dev] Rust compiler  bootstrapped
Message-ID: <522EC3B7.4040304@proinbox.com>

After of reading an article seen in HN "Strange Loops: Ken Thompson and 
the Self-referencing C Compiler" 
(https://news.ycombinator.com/item?id=6355978)

I'm worried if that issue could happens in the Rust compiler.
Does Rust compiler is bootstrapped?

From marijnh at gmail.com  Tue Sep 10 00:39:32 2013
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Tue, 10 Sep 2013 09:39:32 +0200
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <522EC3B7.4040304@proinbox.com>
References: <522EC3B7.4040304@proinbox.com>
Message-ID: <CAJnHWXvk0VHx09REVpj22Pf_CcSSchZ=kvR3txaSH9x105XiUQ@mail.gmail.com>

The Rust team is aware of this possibility, and is guarding against it
by keeping a log of checksums and source git revisions for the various
versions of the compiler, so that compilers downloaded from the net
can be checked, and we could, if something dodgy is found, back-track
to a known trusted version of the compiler (or even all the way back
to the OCaml bootstrap compiler, though that'd be a lot of work).

It is theoretically possible that someone manages to sneak in a commit
that adds an exploit to the compiler, but since patches are reviewed,
that is not terribly likely to succeed. Also, Rust is a small target
still, and it would be a marvelous feat of engineering to install a
functioning exploit in a compiler that is being overhauled and changed
all the time.

From simon.sapin at exyr.org  Tue Sep 10 08:47:03 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Tue, 10 Sep 2013 17:47:03 +0200
Subject: [rust-dev] Proposed API for character encodings
Message-ID: <522F3EF7.1000507@exyr.org>

Hi,

TR;DR: the actual proposal is at the end of this email.

Rust today has good support for UTF-8 which new content definitely 
should use, but many systems still have to deal with legacy content that 
uses other character encodings. There are several projects around to 
implement more encodings in Rust. The most further along in my opinion 
is rust-encoding, notably because it implements the right specification.

rust-encoding: https://github.com/lifthrasiir/rust-encoding

The spec: http://encoding.spec.whatwg.org/
It has more precise definitions of error handling than some original 
RFCs, and better reflects the reality of legacy content on the web.

There was some discussion in the past few days about importing 
rust-encoding (or part of it) into Rust?s libstd or libextra. Before 
that, I think it is important to define a good API. The spec defines one 
for JavaScript, but we should not copy that exactly. rust-encoding?s API 
is mostly good, but I think that error handling could be simplified.


In abstract terms, an encoding (such as "UTF-8") is made of a decoder 
and an encoder. A decoder converts a stream of bytes into a stream of 
text (Unicode scalar values, ie. code points excluding surrogates), 
while an encoder does the reverse. This does not cover other kinds of 
stream transformation such as base64, compression, encryption, etc.

Bytes are represented in Rust by u8, text by str/char.

(Side note: Because of constraints imposed by JavaScript and to avoid 
costly conversions, Servo will probably use a different data type for 
representing text. This encoding API could eventually become generic 
over a Text trait, but I think that it should stick to str for now.)


The most convenient way to represent a "stream" is with a vector or 
string. This however requires the whole input to be in memory before 
decoding/encoding can start, and that to be finished before any of the 
output can be used. It should definitely be possible to eg. decode some 
content as it arrives from the network, and parse it in a pipeline.

The most fundamental type API is one where the user repeatedly "pushes" 
chunks of input into a decoder/encoders object (that may maintain state 
between chunks) and gets the output so far in return, then signals the 
end of the input.

In iterator adapter where the users "pulls" output from the decoder 
which "pulls" from the input can be nicer, but is easy to build on top 
of a "push-based" API, while the reverse requires tasks.

Iterator<u8> and Iterator<char> are tempting, but we may need to work on 
big chucks at a time for efficiency: Iterator<~[u8]> and Iterator<~str>. 
Or could single-byte/char iterators be reliably inlined to achieve 
similar efficiency?


Finally, this API also needs to support several kinds of errors 
handling. For example, a decoder should abort at the invalid byte 
sequence for XML, but insert U+FFFD (replacement character) for HTML. 
I?m not decided yet whether to just have the closed set of error 
handling modes defined in the spec, or make this open-ended with conditions.


Based on all the above, here is a proposed API. Encoders are ommited, 
but they are mostly the same as decoders with [u8] and str swapped.


/// Types implementing this trait are "algorithms"
/// such as UTF8, UTF-16, SingleByteEncoding, etc.
/// Values of these types are "encodings" as defined in the WHATWG spec:
/// UTF-8, UTF-16-LE, Windows-1252, etc.
trait Encoding {
     /// Could become an associated type with a ::new() constructor
     /// when the language supports that.
     fn new_decoder(&self) -> ~Decoder;

     /// Simple, "one shot" API.
     /// Decode a single byte string that is entirely in memory.
     /// May raise the decoding_error condition.
     fn decode(&self, input: &[u8]) -> Result<~str, DecodeError> {
         // Implementation (using a Decoder) left out.
         // This is a default method, but not meant to be overridden.
     }
}

/// Takes the invalid byte sequence.
/// Return a replacement string, or None to abort with a DecodeError.
condition! {
     pub decoding_error : ~[u8] -> Option<~str>;
}

struct DecodeError {
     input_byte_offset: uint,
     invalid_byte_sequence: ~[u8],
}

/// Each implementation of Encoding has one corresponding implementation
/// of Decoder (and one of Encoder).
///
/// A new Decoder instance should be used for every input.
/// A Decoder instance should be discarded after DecodeError was returned.
trait Decoder {
     /// Call this repeatedly with a chunck of input bytes.
     /// As much as possible of the decoded text is appended to output.
     /// May raise the decoding_error condition.
     fn feed(input: &[u8], output: &mut ~str) -> Option<DecodeError>;

     /// Call this to indicate the end of the input.
     /// The Decoder instance should be discarded afterwards.
     /// Some encodings may append some final output at this point.
     /// May raise the decoding_error condition.
     fn flush(output: &mut ~str) -> Option<DecodeError>;
}

/// "Pull-based" API.
struct DecoderIterator<I> {
     input_iterator: I,
     priv state: DecoderIteratorState<I>,
}


impl<I: Iterator<~[u8]>> DecoderIterator<I> {
     fn new(input_iterator: I) -> DecoderIterator<I> {
         // Implementation left out.
     }

     /// Consume the whole input iterator and return a single decoded 
string.
     /// May raise the decoding_error condition.
     fn concat(&mut self) -> Result<~str, DecodeError> {
         // Implementation left out.
     }
}

impl<I: Iterator<~[u8]>> Iterator<Result<~str, DecodeError>> for 
DecoderIterator<I> {
     /// Call .next() once on the input iterator and decode the result.
     /// May raise the decoding_error condition.
     /// Returns None after DecodeError was returned once,
     /// even if the input iterator is not exhausted yet.
     fn next(&mut self) -> Option<Result<~str, DecodeError>> {
         // Implementation left out.
     }
}



Cheers,
-- 
Simon Sapin

From banderson at mozilla.com  Tue Sep 10 14:02:21 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 10 Sep 2013 14:02:21 -0700
Subject: [rust-dev] Rust compiler  bootstrapped
In-Reply-To: <522EC3B7.4040304@proinbox.com>
References: <522EC3B7.4040304@proinbox.com>
Message-ID: <522F88DD.1080905@mozilla.com>

On 09/10/2013 12:01 AM, John Mija wrote:
> After of reading an article seen in HN "Strange Loops: Ken Thompson 
> and the Self-referencing C Compiler" 
> (https://news.ycombinator.com/item?id=6355978)

Every month or so I waste time imagining how to add an easter egg based 
on this idea, but it would take a lot of effort and probably not pass 
review. It would primarily be an opportunity to create a pull request 
titled "Reflections on Trusting Rust".

From kevin at sb.org  Tue Sep 10 20:20:30 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 10 Sep 2013 20:20:30 -0700
Subject: [rust-dev] Rust compiler  bootstrapped
In-Reply-To: <522F88DD.1080905@mozilla.com>
References: <522EC3B7.4040304@proinbox.com> <522F88DD.1080905@mozilla.com>
Message-ID: <933AF63D-BD2A-4686-B753-050F1B470B33@sb.org>

Given the degrading effect this would have on anyone's faith in the compiler, you could also call this "Reflections on Rusting Trust".

-Kevin

On Sep 10, 2013, at 2:02 PM, Brian Anderson <banderson at mozilla.com> wrote:

> On 09/10/2013 12:01 AM, John Mija wrote:
>> After of reading an article seen in HN "Strange Loops: Ken Thompson and the Self-referencing C Compiler" (https://news.ycombinator.com/item?id=6355978)
> 
> Every month or so I waste time imagining how to add an easter egg based on this idea, but it would take a lot of effort and probably not pass review. It would primarily be an opportunity to create a pull request titled "Reflections on Trusting Rust".
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From gmaxwell at gmail.com  Wed Sep 11 00:27:25 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 11 Sep 2013 00:27:25 -0700
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <522EC3B7.4040304@proinbox.com>
References: <522EC3B7.4040304@proinbox.com>
Message-ID: <CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>

On Tue, Sep 10, 2013 at 12:01 AM, John Mija <jon.mb at proinbox.com> wrote:
> After of reading an article seen in HN "Strange Loops: Ken Thompson and the
> Self-referencing C Compiler" (https://news.ycombinator.com/item?id=6355978)
>
> I'm worried if that issue could happens in the Rust compiler.
> Does Rust compiler is bootstrapped?

Make sure you read David Wheeler's page on diverse double compilation
which is the cure for this concern:
http://www.dwheeler.com/trusting-trust/

Presumably before rust reaches a point of earth-shaking importance
there will be an second implementation which can compile the first
compiler, thus permitting this solution. :)

From corey at octayn.net  Wed Sep 11 05:50:39 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 11 Sep 2013 08:50:39 -0400
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
Message-ID: <CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>

On Wed, Sep 11, 2013 at 3:27 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> Presumably before rust reaches a point of earth-shaking importance
> there will be an second implementation which can compile the first
> compiler, thus permitting this solution. :)

I wouldn't be so sure of that. There's a ton of trickiness around the
type and borrow checker and everything else, and I'm not sure anyone
would *want* to reimplement it. What gain would there be?

From zcarterc at gmail.com  Wed Sep 11 06:52:59 2013
From: zcarterc at gmail.com (Carter Charbonneau)
Date: Wed, 11 Sep 2013 07:52:59 -0600
Subject: [rust-dev] Fwd:  Rust compiler bootstrapped
In-Reply-To: <CAA+VN--8j9hvsiKF4_DW1pK_iE_GfDQd8dNJfaj5OO5neMjtag@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
	<CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
	<CAA+VN--8j9hvsiKF4_DW1pK_iE_GfDQd8dNJfaj5OO5neMjtag@mail.gmail.com>
Message-ID: <CAA+VN-_J9FMn-mSYUBDnQRGLRk0rNf3EeeAd5njzRCO8hpT9GQ@mail.gmail.com>

For trusting trust, couldn't the second compiler skip all of that and say
"if it compiles with main rustc, we expect it to be correct"?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130911/19bfec26/attachment.html>

From lists at dhardy.name  Wed Sep 11 08:26:48 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Wed, 11 Sep 2013 17:26:48 +0200
Subject: [rust-dev] Zurich/CH Meetup
In-Reply-To: <51FE39B5.1040600@seld.be>
References: <51FE39B5.1040600@seld.be>
Message-ID: <2112333.scNfimRqL1@tph-l10036>

Hello,

Did anything ever happen about this? Sorry, I stopped reading the mailing list 
a while back...

I'd be interested, if not very much involved with Rust at the moment. (I live 
in Basel.)

Cheers

On Sunday 04 August 2013 13:23:33 Jordi Boggiano wrote:
> Heya,
> 
> I know this is a long shot given I don't see many EU people on IRC, but
> would there be anyone around Zurich or in Switzerland at all that wants
> to gather up for a small Rust meetup (or we can just go have a beer)?
> 
> Cheers

From j.boggiano at seld.be  Wed Sep 11 08:40:26 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Wed, 11 Sep 2013 17:40:26 +0200
Subject: [rust-dev] Zurich/CH Meetup
In-Reply-To: <2112333.scNfimRqL1@tph-l10036>
References: <51FE39B5.1040600@seld.be> <2112333.scNfimRqL1@tph-l10036>
Message-ID: <52308EEA.8030300@seld.be>

On 11.09.2013 17:26, Diggory Hardy wrote:
> Did anything ever happen about this? Sorry, I stopped reading the mailing list 
> a while back...
> 
> I'd be interested, if not very much involved with Rust at the moment. (I live 
> in Basel.)

Nope, only one other person got back to me (off list) so I put the idea
on hold for now. Maybe I will try to start something towards end of
October because I don't have much time now. I put you on the spam list
then :)

I imagine more people from outside the rust community could be
interested in at least a first "intro" meetup, then we can see where to
go from there.

Cheers

From loebel.marvin at gmail.com  Wed Sep 11 08:19:39 2013
From: loebel.marvin at gmail.com (=?windows-1252?Q?Marvin_L=F6bel?=)
Date: Wed, 11 Sep 2013 17:19:39 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <522F3EF7.1000507@exyr.org>
References: <522F3EF7.1000507@exyr.org>
Message-ID: <52308A0B.2080108@gmail.com>

On 09/10/2013 05:47 PM, Simon Sapin wrote:
> Hi,
>
> TR;DR: the actual proposal is at the end of this email.
>
> Rust today has good support for UTF-8 which new content definitely 
> should use, but many systems still have to deal with legacy content 
> that uses other character encodings. There are several projects around 
> to implement more encodings in Rust. The most further along in my 
> opinion is rust-encoding, notably because it implements the right 
> specification.
>
> rust-encoding: https://github.com/lifthrasiir/rust-encoding
>
> The spec: http://encoding.spec.whatwg.org/
> It has more precise definitions of error handling than some original 
> RFCs, and better reflects the reality of legacy content on the web.
>
> There was some discussion in the past few days about importing 
> rust-encoding (or part of it) into Rust?s libstd or libextra. Before 
> that, I think it is important to define a good API. The spec defines 
> one for JavaScript, but we should not copy that exactly. 
> rust-encoding?s API is mostly good, but I think that error handling 
> could be simplified.
>
>
> In abstract terms, an encoding (such as "UTF-8") is made of a decoder 
> and an encoder. A decoder converts a stream of bytes into a stream of 
> text (Unicode scalar values, ie. code points excluding surrogates), 
> while an encoder does the reverse. This does not cover other kinds of 
> stream transformation such as base64, compression, encryption, etc.
>
> Bytes are represented in Rust by u8, text by str/char.
>
> (Side note: Because of constraints imposed by JavaScript and to avoid 
> costly conversions, Servo will probably use a different data type for 
> representing text. This encoding API could eventually become generic 
> over a Text trait, but I think that it should stick to str for now.)
>
>
> The most convenient way to represent a "stream" is with a vector or 
> string. This however requires the whole input to be in memory before 
> decoding/encoding can start, and that to be finished before any of the 
> output can be used. It should definitely be possible to eg. decode 
> some content as it arrives from the network, and parse it in a pipeline.
>
> The most fundamental type API is one where the user repeatedly 
> "pushes" chunks of input into a decoder/encoders object (that may 
> maintain state between chunks) and gets the output so far in return, 
> then signals the end of the input.
>
> In iterator adapter where the users "pulls" output from the decoder 
> which "pulls" from the input can be nicer, but is easy to build on top 
> of a "push-based" API, while the reverse requires tasks.
>
> Iterator<u8> and Iterator<char> are tempting, but we may need to work 
> on big chucks at a time for efficiency: Iterator<~[u8]> and 
> Iterator<~str>. Or could single-byte/char iterators be reliably 
> inlined to achieve similar efficiency?
>
>
> Finally, this API also needs to support several kinds of errors 
> handling. For example, a decoder should abort at the invalid byte 
> sequence for XML, but insert U+FFFD (replacement character) for HTML. 
> I?m not decided yet whether to just have the closed set of error 
> handling modes defined in the spec, or make this open-ended with 
> conditions.
>
>
> Based on all the above, here is a proposed API. Encoders are ommited, 
> but they are mostly the same as decoders with [u8] and str swapped.
>
>
> /// Types implementing this trait are "algorithms"
> /// such as UTF8, UTF-16, SingleByteEncoding, etc.
> /// Values of these types are "encodings" as defined in the WHATWG spec:
> /// UTF-8, UTF-16-LE, Windows-1252, etc.
> trait Encoding {
>     /// Could become an associated type with a ::new() constructor
>     /// when the language supports that.
>     fn new_decoder(&self) -> ~Decoder;
>
>     /// Simple, "one shot" API.
>     /// Decode a single byte string that is entirely in memory.
>     /// May raise the decoding_error condition.
>     fn decode(&self, input: &[u8]) -> Result<~str, DecodeError> {
>         // Implementation (using a Decoder) left out.
>         // This is a default method, but not meant to be overridden.
>     }
> }
>
> /// Takes the invalid byte sequence.
> /// Return a replacement string, or None to abort with a DecodeError.
> condition! {
>     pub decoding_error : ~[u8] -> Option<~str>;
> }
>
> struct DecodeError {
>     input_byte_offset: uint,
>     invalid_byte_sequence: ~[u8],
> }
>
> /// Each implementation of Encoding has one corresponding implementation
> /// of Decoder (and one of Encoder).
> ///
> /// A new Decoder instance should be used for every input.
> /// A Decoder instance should be discarded after DecodeError was 
> returned.
> trait Decoder {
>     /// Call this repeatedly with a chunck of input bytes.
>     /// As much as possible of the decoded text is appended to output.
>     /// May raise the decoding_error condition.
>     fn feed(input: &[u8], output: &mut ~str) -> Option<DecodeError>;
>
>     /// Call this to indicate the end of the input.
>     /// The Decoder instance should be discarded afterwards.
>     /// Some encodings may append some final output at this point.
>     /// May raise the decoding_error condition.
>     fn flush(output: &mut ~str) -> Option<DecodeError>;
> }
>
> /// "Pull-based" API.
> struct DecoderIterator<I> {
>     input_iterator: I,
>     priv state: DecoderIteratorState<I>,
> }
>
>
> impl<I: Iterator<~[u8]>> DecoderIterator<I> {
>     fn new(input_iterator: I) -> DecoderIterator<I> {
>         // Implementation left out.
>     }
>
>     /// Consume the whole input iterator and return a single decoded 
> string.
>     /// May raise the decoding_error condition.
>     fn concat(&mut self) -> Result<~str, DecodeError> {
>         // Implementation left out.
>     }
> }
>
> impl<I: Iterator<~[u8]>> Iterator<Result<~str, DecodeError>> for 
> DecoderIterator<I> {
>     /// Call .next() once on the input iterator and decode the result.
>     /// May raise the decoding_error condition.
>     /// Returns None after DecodeError was returned once,
>     /// even if the input iterator is not exhausted yet.
>     fn next(&mut self) -> Option<Result<~str, DecodeError>> {
>         // Implementation left out.
>     }
> }
Looking at it first, I found a few things strange:
- new_decoder returns an trait object, which incurs dynamic dispatch costs
- Encoding uses explicit self despite not having any state
- Decoder doesn't use explicit self despite having state
- Decoder get's passed the target ~str on each feed and and flush call, 
despite it being always the same (should be passed on construction of 
the Decoder state and used internally)
- I find the fact that flush itself can cause an DecodingError, despite 
not decoding anything new strange. flush should also maybe be called in 
the Decoder destructor.

However, after playing around with it for a while I found that
- If new_decoder returns a generic type, that must be passed in as a 
type parameter or be implemented as an assoziated type, which we don't 
have yet.
- Calling assoziated functions on Encoding is currently impossible 
without an workaround because you can't specify the self type. But even 
if we can again it would look like this: `Encoding::<for 
Utf8>::decode(source)`. Having assoziated function trait lookup on types 
would ease that somewhat.
- Additionally, if new_decoder results in type parameters on Encoding, 
then you have to rely on inference for not having to specify them.
- You can't pass the &mut ~str into a new Decoder using the Encoding 
trait because we need Higher Kinded Types for the 'self parameter.

Based on this I have written two working proof of concepts of the 
proposed traits.
I left API designs like error handling as is, but made Decoder having a 
proper state.

The first variant implements an Encoding as I think it should work: 
Assoziated functions for new_decoder and decode:
https://gist.github.com/Kimundi/6523377

The second variant works around the verbosity of specifying the right 
implementation by making trait lookup happen with a method call:
https://gist.github.com/Kimundi/6522973



From quixoptic at googlemail.com  Wed Sep 11 04:42:37 2013
From: quixoptic at googlemail.com (Alex)
Date: Wed, 11 Sep 2013 12:42:37 +0100
Subject: [rust-dev] Type parameters in trait bounds
In-Reply-To: <CADJiDhv-g8gqKBq2=GQAJcvPWSsFw0rd2WEs+G3yQgJYVCdWHQ@mail.gmail.com>
References: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>
	<CADJiDhv-g8gqKBq2=GQAJcvPWSsFw0rd2WEs+G3yQgJYVCdWHQ@mail.gmail.com>
Message-ID: <5230572D.9040109@gmail.com>

So that solves the first error, now I have something like the following

    example.rs:4:44: 4:47 error: Illegal lifetime 'input: only 'self is 
allowed as part of a type declaration
    example.rs:4 fn do_something<'input, M: Map<int, &'input str>> (key: 
int, map: &'input M){

Which is weird because this isn't a type devlaration right? Anyway, 
putting 'self as the lifetime (despite that making no sense) gives me this:

    error: internal compiler error: unexpected failure
    note: the compiler hit an unexpected failure path. this is a bug
    note: try running with RUST_LOG=rustc=1,::rt::backtrace to get 
further details and report the results to github.com/mozilla/rust/issues

So I guess I'll go and report that.
                                                         ^~~
Removing the 'input lifetime on str (which also doesn't really make 
sense to do but I thought I would try), results in

    example.rs:4:36: 4:40 error: Illegal anonymous lifetime: anonymous 
lifetimes are not permitted here
    example.rs:4 fn do_something<'input, M: Map<int, &str>> (key: int, 
map: &'input M){

Any other ideas?

Thanks
Alex

On Mon 09 Sep 2013 18:14:50 BST, Oren Ben-Kiki wrote:
> Rust newbie here as well, trying to develop an intuition for these
> things myself :-) Off the top of my head - you are saying the map
> holds entries whose lifetime is 'input; but there's no guarantee that
> the map lifetime itself wouldn't be longer than that. Try saying
> &'input M instead of &M and see how it goes.
>
> Oren.
>
>
> On Fri, Sep 6, 2013 at 10:27 PM, Alex <quixoptic at googlemail.com
> <mailto:quixoptic at googlemail.com>> wrote:
>
>     Hey Everyone,
>
>     I'm new to rust but enjoying it a lot. I'm having trouble with the
>     following code example:
>
>
>     use std::hashmap::{HashMap, Map};
>
>
>     fn do_something<'input, M: Map<int, &'input str>> (key: int, map: &M){
>         match map.find(key){
>             Some(result) => println(fmt!("%s", result)),
>             None => println("no match")
>         };
>     }
>
>     fn main(){
>         let  map : HashMap<int, &str> = HashMap::new();
>         map.insert(1, "one");
>         do_something(1, map);
>     }
>
>
>     This fails with a compilation error:
>
>     example.rs:4:44: 4:47 error: Illegal lifetime 'input: only 'self
>     is allowed as part of a type declaration
>     example.rs:4 <http://example.rs:4> fn do_something<'input, M:
>     Map<int, &'input str>> (key: int, map: &M){
>
>
>     Now, I'm probably misunderstanding a bunch of things here, firstly
>     all the example code I've seen out there uses the HashMap type
>     directly rather than the Map trait, is this idiomatic? Secondly,
>     I'm still getting my head around lifetimes and probably have this
>     all muddled so any pointers there would be welcome.
>
>     Thanks
>     Alex Good
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

From luke at snabb.co  Wed Sep 11 08:50:41 2013
From: luke at snabb.co (Luke Gorrie)
Date: Wed, 11 Sep 2013 17:50:41 +0200
Subject: [rust-dev] Zurich/CH Meetup
In-Reply-To: <52308EEA.8030300@seld.be>
References: <51FE39B5.1040600@seld.be> <2112333.scNfimRqL1@tph-l10036>
	<52308EEA.8030300@seld.be>
Message-ID: <CAA2XHbcyNBCdgp8C+qUwFFmaNDMH5y6PNSzKQVqbgson-LAzBw@mail.gmail.com>

On 11 September 2013 17:40, Jordi Boggiano <j.boggiano at seld.be> wrote:

> Nope, only one other person got back to me (off list) so I put the idea
> on hold for now.


FYI, t'was me that replied off list, and I happen to be giving a (non-Rust)
talk at Zurich IT Geeks (ETH) in an hour from now. So if anybody wants to
come and have a beer afterwards then we could call that an informal Rust
meetup :)

Details:
http://www.meetup.com/zhgeeks/events/130168722/?a=cr1_grp&rv=cr1&_af_eid=130168722&_af=event(beer
likely at the ETH student pub at the venue).

Cheers,
-Luke
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130911/dc6c9209/attachment.html>

From j.boggiano at seld.be  Wed Sep 11 09:00:23 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Wed, 11 Sep 2013 18:00:23 +0200
Subject: [rust-dev] Zurich/CH Meetup
In-Reply-To: <CAA2XHbcyNBCdgp8C+qUwFFmaNDMH5y6PNSzKQVqbgson-LAzBw@mail.gmail.com>
References: <51FE39B5.1040600@seld.be> <2112333.scNfimRqL1@tph-l10036>
	<52308EEA.8030300@seld.be>
	<CAA2XHbcyNBCdgp8C+qUwFFmaNDMH5y6PNSzKQVqbgson-LAzBw@mail.gmail.com>
Message-ID: <52309397.9070207@seld.be>

On 11.09.2013 17:50, Luke Gorrie wrote:
> FYI, t'was me that replied off list, and I happen to be giving a
> (non-Rust) talk at Zurich IT Geeks (ETH) in an hour from now. So if
> anybody wants to come and have a beer afterwards then we could call that
> an informal Rust meetup :)

I was planning on coming already, so let's say two make a party ;)

Cheers


From niko at alum.mit.edu  Wed Sep 11 09:53:30 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 11 Sep 2013 12:53:30 -0400
Subject: [rust-dev] Type parameters in trait bounds
In-Reply-To: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>
References: <CAEkVCQwSaJ2We8QFBvvSs=uv0NODwdwdzaRUG6y-uZ-A5rzAdw@mail.gmail.com>
Message-ID: <20130911165330.GC4542@Mr-Bennet>

Hi Alex,

This is Issue #5121, I believe. That error message is certainly
confusing but basically it's a bug and known limitation. I hope to
lift it...soonish as part of the fix for finishing the work on
lifetime syntax (#4846).


Niko


On Fri, Sep 06, 2013 at 08:27:49PM +0100, Alex wrote:
> Hey Everyone,
> 
> I'm new to rust but enjoying it a lot. I'm having trouble with the
> following code example:
> 
> 
> use std::hashmap::{HashMap, Map};
> 
> 
> fn do_something<'input, M: Map<int, &'input str>> (key: int, map: &M){
>     match map.find(key){
>         Some(result) => println(fmt!("%s", result)),
>         None => println("no match")
>     };
> }
> 
> fn main(){
>     let  map : HashMap<int, &str> = HashMap::new();
>     map.insert(1, "one");
>     do_something(1, map);
> }
> 
> 
> This fails with a compilation error:
> 
> example.rs:4:44: 4:47 error: Illegal lifetime 'input: only 'self is allowed
> as part of a type declaration
> example.rs:4 fn do_something<'input, M: Map<int, &'input str>> (key: int,
> map: &M){
> 
> 
> Now, I'm probably misunderstanding a bunch of things here, firstly all the
> example code I've seen out there uses the HashMap type directly rather than
> the Map trait, is this idiomatic? Secondly, I'm still getting my head
> around lifetimes and probably have this all muddled so any pointers there
> would be welcome.
> 
> Thanks
> Alex Good

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From simon.sapin at exyr.org  Wed Sep 11 15:44:15 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Thu, 12 Sep 2013 00:44:15 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <52308A0B.2080108@gmail.com>
References: <522F3EF7.1000507@exyr.org> <52308A0B.2080108@gmail.com>
Message-ID: <5230F23F.4030404@exyr.org>

Le 11/09/2013 17:19, Marvin L?bel a ?crit :
> On 09/10/2013 05:47 PM, Simon Sapin wrote:
>> Hi,
>>
>> TR;DR: the actual proposal is at the end of this email.
>>
>> Rust today has good support for UTF-8 which new content definitely
>> should use, but many systems still have to deal with legacy content
>> that uses other character encodings. There are several projects around
>> to implement more encodings in Rust. The most further along in my
>> opinion is rust-encoding, notably because it implements the right
>> specification.
>>
>> rust-encoding: https://github.com/lifthrasiir/rust-encoding
>>
>> The spec: http://encoding.spec.whatwg.org/
>> It has more precise definitions of error handling than some original
>> RFCs, and better reflects the reality of legacy content on the web.
>>
>> There was some discussion in the past few days about importing
>> rust-encoding (or part of it) into Rust?s libstd or libextra. Before
>> that, I think it is important to define a good API. The spec defines
>> one for JavaScript, but we should not copy that exactly.
>> rust-encoding?s API is mostly good, but I think that error handling
>> could be simplified.
>>
>>
>> In abstract terms, an encoding (such as "UTF-8") is made of a decoder
>> and an encoder. A decoder converts a stream of bytes into a stream of
>> text (Unicode scalar values, ie. code points excluding surrogates),
>> while an encoder does the reverse. This does not cover other kinds of
>> stream transformation such as base64, compression, encryption, etc.
>>
>> Bytes are represented in Rust by u8, text by str/char.
>>
>> (Side note: Because of constraints imposed by JavaScript and to avoid
>> costly conversions, Servo will probably use a different data type for
>> representing text. This encoding API could eventually become generic
>> over a Text trait, but I think that it should stick to str for now.)
>>
>>
>> The most convenient way to represent a "stream" is with a vector or
>> string. This however requires the whole input to be in memory before
>> decoding/encoding can start, and that to be finished before any of the
>> output can be used. It should definitely be possible to eg. decode
>> some content as it arrives from the network, and parse it in a pipeline.
>>
>> The most fundamental type API is one where the user repeatedly
>> "pushes" chunks of input into a decoder/encoders object (that may
>> maintain state between chunks) and gets the output so far in return,
>> then signals the end of the input.
>>
>> In iterator adapter where the users "pulls" output from the decoder
>> which "pulls" from the input can be nicer, but is easy to build on top
>> of a "push-based" API, while the reverse requires tasks.
>>
>> Iterator<u8> and Iterator<char> are tempting, but we may need to work
>> on big chucks at a time for efficiency: Iterator<~[u8]> and
>> Iterator<~str>. Or could single-byte/char iterators be reliably
>> inlined to achieve similar efficiency?
>>
>>
>> Finally, this API also needs to support several kinds of errors
>> handling. For example, a decoder should abort at the invalid byte
>> sequence for XML, but insert U+FFFD (replacement character) for HTML.
>> I?m not decided yet whether to just have the closed set of error
>> handling modes defined in the spec, or make this open-ended with
>> conditions.
>>
>>
>> Based on all the above, here is a proposed API. Encoders are ommited,
>> but they are mostly the same as decoders with [u8] and str swapped.
>>
>>
>> /// Types implementing this trait are "algorithms"
>> /// such as UTF8, UTF-16, SingleByteEncoding, etc.
>> /// Values of these types are "encodings" as defined in the WHATWG spec:
>> /// UTF-8, UTF-16-LE, Windows-1252, etc.
>> trait Encoding {
>>      /// Could become an associated type with a ::new() constructor
>>      /// when the language supports that.
>>      fn new_decoder(&self) -> ~Decoder;
>>
>>      /// Simple, "one shot" API.
>>      /// Decode a single byte string that is entirely in memory.
>>      /// May raise the decoding_error condition.
>>      fn decode(&self, input: &[u8]) -> Result<~str, DecodeError> {
>>          // Implementation (using a Decoder) left out.
>>          // This is a default method, but not meant to be overridden.
>>      }
>> }
>>
>> /// Takes the invalid byte sequence.
>> /// Return a replacement string, or None to abort with a DecodeError.
>> condition! {
>>      pub decoding_error : ~[u8] -> Option<~str>;
>> }
>>
>> struct DecodeError {
>>      input_byte_offset: uint,
>>      invalid_byte_sequence: ~[u8],
>> }
>>
>> /// Each implementation of Encoding has one corresponding implementation
>> /// of Decoder (and one of Encoder).
>> ///
>> /// A new Decoder instance should be used for every input.
>> /// A Decoder instance should be discarded after DecodeError was
>> returned.
>> trait Decoder {
>>      /// Call this repeatedly with a chunck of input bytes.
>>      /// As much as possible of the decoded text is appended to output.
>>      /// May raise the decoding_error condition.
>>      fn feed(input: &[u8], output: &mut ~str) -> Option<DecodeError>;
>>
>>      /// Call this to indicate the end of the input.
>>      /// The Decoder instance should be discarded afterwards.
>>      /// Some encodings may append some final output at this point.
>>      /// May raise the decoding_error condition.
>>      fn flush(output: &mut ~str) -> Option<DecodeError>;
>> }
>>
>> /// "Pull-based" API.
>> struct DecoderIterator<I> {
>>      input_iterator: I,
>>      priv state: DecoderIteratorState<I>,
>> }
>>
>>
>> impl<I: Iterator<~[u8]>> DecoderIterator<I> {
>>      fn new(input_iterator: I) -> DecoderIterator<I> {
>>          // Implementation left out.
>>      }
>>
>>      /// Consume the whole input iterator and return a single decoded
>> string.
>>      /// May raise the decoding_error condition.
>>      fn concat(&mut self) -> Result<~str, DecodeError> {
>>          // Implementation left out.
>>      }
>> }
>>
>> impl<I: Iterator<~[u8]>> Iterator<Result<~str, DecodeError>> for
>> DecoderIterator<I> {
>>      /// Call .next() once on the input iterator and decode the result.
>>      /// May raise the decoding_error condition.
>>      /// Returns None after DecodeError was returned once,
>>      /// even if the input iterator is not exhausted yet.
>>      fn next(&mut self) -> Option<Result<~str, DecodeError>> {
>>          // Implementation left out.
>>      }
>> }
> Looking at it first, I found a few things strange:
> - new_decoder returns an trait object, which incurs dynamic dispatch costs

I should have added that in Servo?s main use-case, the encoding is not 
known at compile time but is based on a string label that typically 
comes from a Content-Type HTTP header:

   fn get_encoding_from_label(label: &str) -> ~Encoding { /* ... */ }

In this case, we do want dynamic dispatch.

If you know the encoding at compile time and want static dispatch, it is 
perfectly fine to use a specific type such as UTF8Decoder directly, 
without trait objects.


> - Encoding uses explicit self despite not having any state

It?s not exactly "state", but as explained in the comments an "encoding" 
is a value of a type that implements the Encoding trait, not just the 
type itself. For example, rust-encoding has a SingleByteEncoding 
representing many different encoding, with each value pointing at 
different tables.


> - Decoder doesn't use explicit self despite having state

That?s a mistake. .feed() and .flush() should be proper methods with self.

> - Decoder get's passed the target ~str on each feed and and flush call,
> despite it being always the same (should be passed on construction of
> the Decoder state and used internally)

The point is that it doesn?t have to be the same string. Each decoded 
chunks could be passed to the next step of a pipeline, eg. to an 
incremental parser.

> - I find the fact that flush itself can cause an DecodingError, despite
> not decoding anything new strange.

.flush() indicates the end of the input. It can trigger an error eg. if 
the last input chunck ends with an incomplete but so far valid-looking 
UTF-8 byte sequence.

To anticipate another possible question: .flush() most often doesn?t 
write any output, but it can write a termination sequence in some 
encodings like ISO-2022-JP.


> flush should also maybe be called in
> the Decoder destructor.

I don?t think so. The point of .flush() is to deal with possible 
remaining output or error. If you?re dropping everything you don?t care 
about that.


> However, after playing around with it for a while I found that
> - If new_decoder returns a generic type, that must be passed in as a
> type parameter or be implemented as an assoziated type, which we don't
> have yet.

Yes, as said in the comments, Decoder and Encoder should ideally be 
associated types and .new_decoder() would not be needed at all, but we 
don?t have that yet.


> - Calling assoziated functions on Encoding is currently impossible
> without an workaround because you can't specify the self type. But even
> if we can again it would look like this: `Encoding::<for
> Utf8>::decode(source)`. Having assoziated function trait lookup on types
> would ease that somewhat.

Just use self. It?s needed anyway.


> - Additionally, if new_decoder results in type parameters on Encoding,
> then you have to rely on inference for not having to specify them.

See comments on this below.


> - You can't pass the &mut ~str into a new Decoder using the Encoding
> trait because we need Higher Kinded Types for the 'self parameter.

Sorry, I don?t understand this part :/


> Based on this I have written two working proof of concepts of the
> proposed traits.
> I left API designs like error handling as is, but made Decoder having a
> proper state.
>
> The first variant implements an Encoding as I think it should work:
> Assoziated functions for new_decoder and decode:
> https://gist.github.com/Kimundi/6523377
>
> The second variant works around the verbosity of specifying the right
> implementation by making trait lookup happen with a method call:
> https://gist.github.com/Kimundi/6522973

As we discussed on IRC I believe that this does not cover the case where 
you do want dynamic dispatch.


Thank you for your feedback!

Cheers,
-- 
Simon Sapin

From steven099 at gmail.com  Wed Sep 11 19:53:11 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Wed, 11 Sep 2013 22:53:11 -0400
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
	<20130909133458.GE3459@Mr-Bennet>
	<CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>
Message-ID: <CANjmGJsW+Y2AqYMso2s1nE-0JccEKOX1rNeofUdbPrVUgZ=r9A@mail.gmail.com>

On Mon, Sep 9, 2013 at 6:20 PM, Nick Cameron <lists at ncameron.org> wrote:

>
> Separately, I remember that the various pointer types can be implicitly
> converted. I couldn't find anywhere where these conversions are defined. Is
> my memory bad or my search skills?
>

You can implicitly borrow a pointer's referent by assigning the pointer to
a compatible borrowed-pointer-typed variable / function argument. There be
dragons in the manual, though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130911/45f4dcf9/attachment.html>

From lindsey at composition.al  Wed Sep 11 21:17:38 2013
From: lindsey at composition.al (Lindsey Kuper)
Date: Thu, 12 Sep 2013 00:17:38 -0400
Subject: [rust-dev] libsyntax default methods refactor -- anyone know what
	went wrong here?
Message-ID: <CALnXJiomMGWJviz=Xi6Bsmh6gd3Dgu5WiBu3b=f51-ivgtNxeQ@mail.gmail.com>

So, I've been trying to use default methods to streamline various
parts of the Rust compiler and libraries.  Most recently, I tried
attacking the impls of Visitor in libsyntax.  Since the Visitor trait
already had default methods, the patch consists entirely of removed
lines:

https://github.com/lkuper/rust/commit/7950e5fbc26494c437237cb1a5b4583f7b6881e8

It builds without issue, but unfortunately, the results of `make
check` are interesting.  I get three run-pass test failures:

failures:
    [run-pass] run-pass/issue-2216.rs
    [run-pass] run-pass/issue-9047.rs
    [run-pass] run-pass/labeled-break.rs

These three tests all have something to do with labeled
break/continue, and they all segfault.  (Gist of all build messages
here: https://gist.github.com/lkuper/6532993) Anyone have an idea why
this change would result in this failure?  The Visitor trait is used
all over the compiler, but I didn't have to touch it at all, so it
seems like the problem should be local to libsyntax.

Lindsey

From pnkfelix at mozilla.com  Thu Sep 12 03:03:36 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Thu, 12 Sep 2013 12:03:36 +0200
Subject: [rust-dev] libsyntax default methods refactor -- anyone know
 what went wrong here?
In-Reply-To: <CALnXJiomMGWJviz=Xi6Bsmh6gd3Dgu5WiBu3b=f51-ivgtNxeQ@mail.gmail.com>
References: <CALnXJiomMGWJviz=Xi6Bsmh6gd3Dgu5WiBu3b=f51-ivgtNxeQ@mail.gmail.com>
Message-ID: <52319178.2010401@mozilla.com>

Lindsey (cc'ing rust-dev)-

Its not due to your changes.  These are problems that are in master that 
for some reasons bors has not caught:

Issue #9127: debug no-optimize make check yields three failures
https://github.com/mozilla/rust/issues/9127

Cheers,
-Felix


On 12/09/2013 06:17, Lindsey Kuper wrote:
> So, I've been trying to use default methods to streamline various
> parts of the Rust compiler and libraries.  Most recently, I tried
> attacking the impls of Visitor in libsyntax.  Since the Visitor trait
> already had default methods, the patch consists entirely of removed
> lines:
>
> https://github.com/lkuper/rust/commit/7950e5fbc26494c437237cb1a5b4583f7b6881e8
>
> It builds without issue, but unfortunately, the results of `make
> check` are interesting.  I get three run-pass test failures:
>
> failures:
>      [run-pass] run-pass/issue-2216.rs
>      [run-pass] run-pass/issue-9047.rs
>      [run-pass] run-pass/labeled-break.rs
>
> These three tests all have something to do with labeled
> break/continue, and they all segfault.  (Gist of all build messages
> here: https://gist.github.com/lkuper/6532993) Anyone have an idea why
> this change would result in this failure?  The Visitor trait is used
> all over the compiler, but I didn't have to touch it at all, so it
> seems like the problem should be local to libsyntax.
>
> Lindsey
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/4409dbd9/attachment.html>

From davidb at davidb.org  Thu Sep 12 08:16:04 2013
From: davidb at davidb.org (David Brown)
Date: Thu, 12 Sep 2013 08:16:04 -0700
Subject: [rust-dev] Compiler assertion and trait impl question
Message-ID: <20130912151602.GA24598@davidb.org>

Consider the following code
----------------------------------------------------------------------
pub trait Inner {
    fn secret(&self);
}

// This doesn't seem to help.
impl Inner for @Inner {
    fn secret(&self) { self.secret(); }
}

pub trait Wrapper {
    fn blort(&self);
}

impl<T: Inner> Wrapper for T {
    fn blort(&self) { self.secret(); }
}

// This function causes an assertion failure in rustc:
// task <unnamed> failed at 'assertion failed: rp.is_none()', /home/davidb/rust/rust/src/librustc/middle/typeck/collect.rs:1108
// fn blort<'self, T: Inner>(item: &'self @T) {
    // item.secret();
// }

struct Client;

impl Inner for Client {
    fn secret(&self) { }
}

fn main() {
    let buf = @Client;
    buf.secret(); // Works

    // error: failed to find an implementation of trait Inner for
    // @Client
    buf.blort();
}
----------------------------------------------------------------------

This fails to compile:
  wrap.rs:32:4: 41:5 error: type `Client` does not implement any method in scope named `with_data`

I'm modeling this after looking at the code in libstd/io.rs, but I'm
not sure what I'm missing.

I seem to be able to make it work by using 'impl Inner for @Client',
but I'm not sure why that is required.

Also, the commented out function causes an assertion failure in the
compiler (it was a workaround attempt).

Thanks,
David

From cce at ccs.neu.edu  Thu Sep 12 08:49:12 2013
From: cce at ccs.neu.edu (Carl Eastlund)
Date: Thu, 12 Sep 2013 11:49:12 -0400
Subject: [rust-dev] Compiler assertion and trait impl question
In-Reply-To: <20130912151602.GA24598@davidb.org>
References: <20130912151602.GA24598@davidb.org>
Message-ID: <CAEOPtY2CvJyGVrOqa_es9-=fKq_CM0_BQSvBp=9OuDEtG+N=jA@mail.gmail.com>

This looks like bug 6396; function lifetimes don't work when named "self"
apparently.  Try naming it something else.

https://github.com/mozilla/rust/issues/6396

Carl Eastlund


On Thu, Sep 12, 2013 at 11:16 AM, David Brown <davidb at davidb.org> wrote:

> Consider the following code
> ------------------------------**------------------------------**----------
> pub trait Inner {
>    fn secret(&self);
> }
>
> // This doesn't seem to help.
> impl Inner for @Inner {
>    fn secret(&self) { self.secret(); }
> }
>
> pub trait Wrapper {
>    fn blort(&self);
> }
>
> impl<T: Inner> Wrapper for T {
>    fn blort(&self) { self.secret(); }
> }
>
> // This function causes an assertion failure in rustc:
> // task <unnamed> failed at 'assertion failed: rp.is_none()',
> /home/davidb/rust/rust/src/**librustc/middle/typeck/collect**.rs:1108<http://collect.rs:1108>
> // fn blort<'self, T: Inner>(item: &'self @T) {
>    // item.secret();
> // }
>
> struct Client;
>
> impl Inner for Client {
>    fn secret(&self) { }
> }
>
> fn main() {
>    let buf = @Client;
>    buf.secret(); // Works
>
>    // error: failed to find an implementation of trait Inner for
>    // @Client
>    buf.blort();
> }
> ------------------------------**------------------------------**----------
>
> This fails to compile:
>  wrap.rs:32:4: 41:5 error: type `Client` does not implement any method in
> scope named `with_data`
>
> I'm modeling this after looking at the code in libstd/io.rs, but I'm
> not sure what I'm missing.
>
> I seem to be able to make it work by using 'impl Inner for @Client',
> but I'm not sure why that is required.
>
> Also, the commented out function causes an assertion failure in the
> compiler (it was a workaround attempt).
>
> Thanks,
> David
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/277790ab/attachment.html>

From thadguidry at gmail.com  Thu Sep 12 09:06:23 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 12 Sep 2013 11:06:23 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
Message-ID: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>

I have updated and added new steps (Step 5) that correctly install the
needed pthread libraries for Windows users of MinGW.

Rust now correctly compiles Stage0, Stage1, Stage2 out of the box
 following the updated guide here:
https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust


The new package details for the pthread libraries provided from 'mingw-get
show' , for those interested are below:


Package: mingw32-libpthread-old                       Subsystem: mingw32
Components: dll

POSIX threading library for Win32
---------------------------------

pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
implementation  of  pthreads for Windows. Pthreads is an API for writing
multithreaded applications following the POSIX standard.

The  mingw32-libpthread-old  package  provides  the  MinGW  pthreads-w32
runtime  dll  associated  with  MinGW  GCC  4.5.2  and  older. Due to an
unfortunate naming choice, upgrading to newer GCC will also install  the
newer,  renamed  pthreads-w32  DLLs, removing the old DLL. While the may
not affect the new GCC, threaded applications compiled using  the  older
compiler  will break, as they will miss this runtime library. Therefore,
the old runtime library is provided  here  using  a  new  package  name:
mingw32-libpthread-old,  so that it can be (re)installed parallel to the
new pthreads-w32 runtime libraries.


Package: mingw32-libpthreadgc                         Subsystem: mingw32
Components: dll

POSIX threading library for Win32
---------------------------------

pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
implementation  of  pthreads for Windows. Pthreads is an API for writing
multithreaded applications following the POSIX standard.

There are two mingw32 versions of the pthread-w32 runtime  library:  the
standard  one,  provided by this package, is called libpthreadgc but may
also be referred to as  'libpthread'.  The  non-standard  one  uses  C++
exception handling, and is called libpthreadgce. (Note that the standard
library may be used successfully with C++ code;  indeed,  on  most  *nix
platorms  the  system  pthreads  implementation  follows the behavior of
mingw32-libpthreadgc, and NOT the behavior of  the  'GCE'  version).  We
recommend  that  most  users rely on mingw32-libpthreadgc ('GC') and not
mingw32-libpthreadgce ('GCE').

The mingw32-libpthreadgc and mingw32-libpthreadgce packages provide  the
two  runtime libraries (most people need not install the 'GCE' one). The
associated mingw32-pthreads-w32 package provides the  documentation  for
the  pthreads-w32 library, as well as the related development files. The
mingw32-libquserex  package  provides  optional  support  for   enhanced
standards conformance of the GCE runtime.

mingw32-libpthreadgc is a  required  component  of  the  MinGW  Compiler
Suite.

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/d9b67c9f/attachment.html>

From pnkfelix at mozilla.com  Thu Sep 12 09:54:03 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Thu, 12 Sep 2013 18:54:03 +0200
Subject: [rust-dev] Compiler assertion and trait impl question
In-Reply-To: <CAEOPtY2CvJyGVrOqa_es9-=fKq_CM0_BQSvBp=9OuDEtG+N=jA@mail.gmail.com>
References: <20130912151602.GA24598@davidb.org>
	<CAEOPtY2CvJyGVrOqa_es9-=fKq_CM0_BQSvBp=9OuDEtG+N=jA@mail.gmail.com>
Message-ID: <5231F1AB.3090605@mozilla.com>

Carl, David (cc'ing rust-dev)_

Note that #6396 is about the 'self lifetime.

That may or may not be related to the rustc assertion failure that David 
mentions in one of his comments, but I think the bulk of his example 
does not use lifetimes at all.  (So I'm assuming that his main issues 
about `impl Inner for @Inner` are something else.)

-Felix

On 12/09/2013 17:49, Carl Eastlund wrote:
> This looks like bug 6396; function lifetimes don't work when named 
> "self" apparently.  Try naming it something else.
>
> https://github.com/mozilla/rust/issues/6396
>
> Carl Eastlund
>
>
> On Thu, Sep 12, 2013 at 11:16 AM, David Brown <davidb at davidb.org 
> <mailto:davidb at davidb.org>> wrote:
>
>     Consider the following code
>     ----------------------------------------------------------------------
>     pub trait Inner {
>        fn secret(&self);
>     }
>
>     // This doesn't seem to help.
>     impl Inner for @Inner {
>        fn secret(&self) { self.secret(); }
>     }
>
>     pub trait Wrapper {
>        fn blort(&self);
>     }
>
>     impl<T: Inner> Wrapper for T {
>        fn blort(&self) { self.secret(); }
>     }
>
>     // This function causes an assertion failure in rustc:
>     // task <unnamed> failed at 'assertion failed: rp.is_none()',
>     /home/davidb/rust/rust/src/librustc/middle/typeck/collect.rs:1108
>     <http://collect.rs:1108>
>     // fn blort<'self, T: Inner>(item: &'self @T) {
>        // item.secret();
>     // }
>
>     struct Client;
>
>     impl Inner for Client {
>        fn secret(&self) { }
>     }
>
>     fn main() {
>        let buf = @Client;
>        buf.secret(); // Works
>
>        // error: failed to find an implementation of trait Inner for
>        // @Client
>        buf.blort();
>     }
>     ----------------------------------------------------------------------
>
>     This fails to compile:
>      wrap.rs:32:4: 41:5 error: type `Client` does not implement any
>     method in scope named `with_data`
>
>     I'm modeling this after looking at the code in libstd/io.rs
>     <http://io.rs>, but I'm
>     not sure what I'm missing.
>
>     I seem to be able to make it work by using 'impl Inner for @Client',
>     but I'm not sure why that is required.
>
>     Also, the commented out function causes an assertion failure in the
>     compiler (it was a workaround attempt).
>
>     Thanks,
>     David
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/0ab1c948/attachment.html>

From cce at ccs.neu.edu  Thu Sep 12 10:03:19 2013
From: cce at ccs.neu.edu (Carl Eastlund)
Date: Thu, 12 Sep 2013 13:03:19 -0400
Subject: [rust-dev] Compiler assertion and trait impl question
In-Reply-To: <5231F1AB.3090605@mozilla.com>
References: <20130912151602.GA24598@davidb.org>
	<CAEOPtY2CvJyGVrOqa_es9-=fKq_CM0_BQSvBp=9OuDEtG+N=jA@mail.gmail.com>
	<5231F1AB.3090605@mozilla.com>
Message-ID: <CAEOPtY2mxPHFcN9jdvZ63t_cnNxN4tYALSm+dYRZ6c9-PEEG1g@mail.gmail.com>

Oh, yes, sorry.  I saw the assertion failure and responded to that, and
missed the other problem he was talking about.

Carl Eastlund


On Thu, Sep 12, 2013 at 12:54 PM, Felix S. Klock II <pnkfelix at mozilla.com>wrote:

>  Carl, David (cc'ing rust-dev)_
>
> Note that #6396 is about the 'self lifetime.
>
> That may or may not be related to the rustc assertion failure that David
> mentions in one of his comments, but I think the bulk of his example does
> not use lifetimes at all.  (So I'm assuming that his main issues about
> `impl Inner for @Inner` are something else.)
>
> -Felix
>
>
> On 12/09/2013 17:49, Carl Eastlund wrote:
>
> This looks like bug 6396; function lifetimes don't work when named "self"
> apparently.  Try naming it something else.
>
> https://github.com/mozilla/rust/issues/6396
>
> Carl Eastlund
>
>
> On Thu, Sep 12, 2013 at 11:16 AM, David Brown <davidb at davidb.org> wrote:
>
>> Consider the following code
>> ----------------------------------------------------------------------
>> pub trait Inner {
>>    fn secret(&self);
>> }
>>
>> // This doesn't seem to help.
>> impl Inner for @Inner {
>>    fn secret(&self) { self.secret(); }
>> }
>>
>> pub trait Wrapper {
>>    fn blort(&self);
>> }
>>
>> impl<T: Inner> Wrapper for T {
>>    fn blort(&self) { self.secret(); }
>> }
>>
>> // This function causes an assertion failure in rustc:
>> // task <unnamed> failed at 'assertion failed: rp.is_none()',
>> /home/davidb/rust/rust/src/librustc/middle/typeck/collect.rs:1108
>> // fn blort<'self, T: Inner>(item: &'self @T) {
>>    // item.secret();
>> // }
>>
>> struct Client;
>>
>> impl Inner for Client {
>>    fn secret(&self) { }
>> }
>>
>> fn main() {
>>    let buf = @Client;
>>    buf.secret(); // Works
>>
>>    // error: failed to find an implementation of trait Inner for
>>    // @Client
>>    buf.blort();
>> }
>> ----------------------------------------------------------------------
>>
>> This fails to compile:
>>  wrap.rs:32:4: 41:5 error: type `Client` does not implement any method
>> in scope named `with_data`
>>
>> I'm modeling this after looking at the code in libstd/io.rs, but I'm
>> not sure what I'm missing.
>>
>> I seem to be able to make it work by using 'impl Inner for @Client',
>> but I'm not sure why that is required.
>>
>> Also, the commented out function causes an assertion failure in the
>> compiler (it was a workaround attempt).
>>
>> Thanks,
>> David
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/6a492ef1/attachment-0001.html>

From davidb at davidb.org  Thu Sep 12 10:16:32 2013
From: davidb at davidb.org (David Brown)
Date: Thu, 12 Sep 2013 10:16:32 -0700
Subject: [rust-dev] Compiler assertion and trait impl question
In-Reply-To: <5231F1AB.3090605@mozilla.com>
References: <20130912151602.GA24598@davidb.org>
	<CAEOPtY2CvJyGVrOqa_es9-=fKq_CM0_BQSvBp=9OuDEtG+N=jA@mail.gmail.com>
	<5231F1AB.3090605@mozilla.com>
Message-ID: <FF50C682-6087-4F28-B930-F90B9F193E39@davidb.org>

6396 does seem to be the issue with the commented out function, and changing self to another identifier lets that compile.

But, yes, my main issue is with the impl of inner. I did get a variant to compile and now I'm getting a runtime failure about 'borrowed' that I'll look into more this evening.

David

On Sep 12, 2013, at 9:54 AM, "Felix S. Klock II" <pnkfelix at mozilla.com> wrote:

> Carl, David (cc'ing rust-dev)_
> 
> Note that #6396 is about the 'self lifetime.
> 
> That may or may not be related to the rustc assertion failure that David mentions in one of his comments, but I think the bulk of his example does not use lifetimes at all.  (So I'm assuming that his main issues about `impl Inner for @Inner` are something else.)
> 
> -Felix
> 
> On 12/09/2013 17:49, Carl Eastlund wrote:
>> This looks like bug 6396; function lifetimes don't work when named "self" apparently.  Try naming it something else.
>> 
>> https://github.com/mozilla/rust/issues/6396
>> 
>> Carl Eastlund
>> 
>> 
>> On Thu, Sep 12, 2013 at 11:16 AM, David Brown <davidb at davidb.org> wrote:
>>> Consider the following code
>>> ----------------------------------------------------------------------
>>> pub trait Inner {
>>>    fn secret(&self);
>>> }
>>> 
>>> // This doesn't seem to help.
>>> impl Inner for @Inner {
>>>    fn secret(&self) { self.secret(); }
>>> }
>>> 
>>> pub trait Wrapper {
>>>    fn blort(&self);
>>> }
>>> 
>>> impl<T: Inner> Wrapper for T {
>>>    fn blort(&self) { self.secret(); }
>>> }
>>> 
>>> // This function causes an assertion failure in rustc:
>>> // task <unnamed> failed at 'assertion failed: rp.is_none()', /home/davidb/rust/rust/src/librustc/middle/typeck/collect.rs:1108
>>> // fn blort<'self, T: Inner>(item: &'self @T) {
>>>    // item.secret();
>>> // }
>>> 
>>> struct Client;
>>> 
>>> impl Inner for Client {
>>>    fn secret(&self) { }
>>> }
>>> 
>>> fn main() {
>>>    let buf = @Client;
>>>    buf.secret(); // Works
>>> 
>>>    // error: failed to find an implementation of trait Inner for
>>>    // @Client
>>>    buf.blort();
>>> }
>>> ----------------------------------------------------------------------
>>> 
>>> This fails to compile:
>>>  wrap.rs:32:4: 41:5 error: type `Client` does not implement any method in scope named `with_data`
>>> 
>>> I'm modeling this after looking at the code in libstd/io.rs, but I'm
>>> not sure what I'm missing.
>>> 
>>> I seem to be able to make it work by using 'impl Inner for @Client',
>>> but I'm not sure why that is required.
>>> 
>>> Also, the commented out function causes an assertion failure in the
>>> compiler (it was a workaround attempt).
>>> 
>>> Thanks,
>>> David
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> -- 
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/fb4ab344/attachment.html>

From vadimcn at gmail.com  Thu Sep 12 12:22:31 2013
From: vadimcn at gmail.com (Vadim)
Date: Thu, 12 Sep 2013 12:22:31 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
Message-ID: <CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>

Thanks Thad!

It feels to me that Windows dev setup is getting overly complicated.  Is
there still any reason not to upgrade to GCC 4.7?   This would remove the
need to do all that dance with component downgrades.  BTW, this also
affects users of official Rust releases
(#8598<https://github.com/mozilla/rust/issues/8598>
).

I don't think build bot environment upgrades can be done via a PR, so we'll
need help from someone on the core Rust team.   Also, a new stage0 compiler
snapshot will need to be cranked out because of
#5878<https://github.com/mozilla/rust/issues/5878>
.

Vadim



On Thu, Sep 12, 2013 at 9:06 AM, Thad Guidry <thadguidry at gmail.com> wrote:

> I have updated and added new steps (Step 5) that correctly install the
> needed pthread libraries for Windows users of MinGW.
>
> Rust now correctly compiles Stage0, Stage1, Stage2 out of the box
>  following the updated guide here:
> https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
>
>
> The new package details for the pthread libraries provided from 'mingw-get
> show' , for those interested are below:
>
>
> Package: mingw32-libpthread-old                       Subsystem: mingw32
> Components: dll
>
> POSIX threading library for Win32
> ---------------------------------
>
> pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
> implementation  of  pthreads for Windows. Pthreads is an API for writing
> multithreaded applications following the POSIX standard.
>
> The  mingw32-libpthread-old  package  provides  the  MinGW  pthreads-w32
> runtime  dll  associated  with  MinGW  GCC  4.5.2  and  older. Due to an
> unfortunate naming choice, upgrading to newer GCC will also install  the
> newer,  renamed  pthreads-w32  DLLs, removing the old DLL. While the may
> not affect the new GCC, threaded applications compiled using  the  older
> compiler  will break, as they will miss this runtime library. Therefore,
> the old runtime library is provided  here  using  a  new  package  name:
> mingw32-libpthread-old,  so that it can be (re)installed parallel to the
> new pthreads-w32 runtime libraries.
>
>
> Package: mingw32-libpthreadgc                         Subsystem: mingw32
> Components: dll
>
> POSIX threading library for Win32
> ---------------------------------
>
> pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
> implementation  of  pthreads for Windows. Pthreads is an API for writing
> multithreaded applications following the POSIX standard.
>
> There are two mingw32 versions of the pthread-w32 runtime  library:  the
> standard  one,  provided by this package, is called libpthreadgc but may
> also be referred to as  'libpthread'.  The  non-standard  one  uses  C++
> exception handling, and is called libpthreadgce. (Note that the standard
> library may be used successfully with C++ code;  indeed,  on  most  *nix
> platorms  the  system  pthreads  implementation  follows the behavior of
> mingw32-libpthreadgc, and NOT the behavior of  the  'GCE'  version).  We
> recommend  that  most  users rely on mingw32-libpthreadgc ('GC') and not
> mingw32-libpthreadgce ('GCE').
>
> The mingw32-libpthreadgc and mingw32-libpthreadgce packages provide  the
> two  runtime libraries (most people need not install the 'GCE' one). The
> associated mingw32-pthreads-w32 package provides the  documentation  for
> the  pthreads-w32 library, as well as the related development files. The
> mingw32-libquserex  package  provides  optional  support  for   enhanced
> standards conformance of the GCE runtime.
>
> mingw32-libpthreadgc is a  required  component  of  the  MinGW  Compiler
> Suite.
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/fa15b11e/attachment.html>

From thadguidry at gmail.com  Thu Sep 12 12:39:49 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 12 Sep 2013 14:39:49 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
Message-ID: <CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>

Yeah, there should not be a reason anymore, if I am correct, to not have
GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
also , and if it works, then we can close out
(#8598<https://github.com/mozilla/rust/issues/8598>
).  (I also would like to get rid of the 4.5 downgrade needed).... but that
does need more testing from the core Rust team and others.

It's something that Brian has been counting on me to help make happen, and
Alex is also contributing to some of that effort by fixing various LLVM
build issues that affect Windows Rust users as you mention in
(#8598<https://github.com/mozilla/rust/issues/8598>
).

Agreed, if a new stage0 compiler snapshot can be created, then we should be
in the clear to also close out
#5878<https://github.com/mozilla/rust/issues/5878>
.



On Thu, Sep 12, 2013 at 2:22 PM, Vadim <vadimcn at gmail.com> wrote:

> Thanks Thad!
>
> It feels to me that Windows dev setup is getting overly complicated.  Is
> there still any reason not to upgrade to GCC 4.7?   This would remove the
> need to do all that dance with component downgrades.  BTW, this also
> affects users of official Rust releases (#8598<https://github.com/mozilla/rust/issues/8598>
> ).
>
> I don't think build bot environment upgrades can be done via a PR, so
> we'll need help from someone on the core Rust team.   Also, a new stage0
> compiler snapshot will need to be cranked out because of #5878<https://github.com/mozilla/rust/issues/5878>
> .
>
> Vadim
>
>
>
> On Thu, Sep 12, 2013 at 9:06 AM, Thad Guidry <thadguidry at gmail.com> wrote:
>
>> I have updated and added new steps (Step 5) that correctly install the
>> needed pthread libraries for Windows users of MinGW.
>>
>> Rust now correctly compiles Stage0, Stage1, Stage2 out of the box
>>  following the updated guide here:
>> https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
>>
>>
>> The new package details for the pthread libraries provided from
>> 'mingw-get show' , for those interested are below:
>>
>>
>> Package: mingw32-libpthread-old                       Subsystem: mingw32
>> Components: dll
>>
>> POSIX threading library for Win32
>> ---------------------------------
>>
>> pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
>> implementation  of  pthreads for Windows. Pthreads is an API for writing
>> multithreaded applications following the POSIX standard.
>>
>> The  mingw32-libpthread-old  package  provides  the  MinGW  pthreads-w32
>> runtime  dll  associated  with  MinGW  GCC  4.5.2  and  older. Due to an
>> unfortunate naming choice, upgrading to newer GCC will also install  the
>> newer,  renamed  pthreads-w32  DLLs, removing the old DLL. While the may
>> not affect the new GCC, threaded applications compiled using  the  older
>> compiler  will break, as they will miss this runtime library. Therefore,
>> the old runtime library is provided  here  using  a  new  package  name:
>> mingw32-libpthread-old,  so that it can be (re)installed parallel to the
>> new pthreads-w32 runtime libraries.
>>
>>
>> Package: mingw32-libpthreadgc                         Subsystem: mingw32
>> Components: dll
>>
>> POSIX threading library for Win32
>> ---------------------------------
>>
>> pthreads-w32 seeks  to  provide  a  freely  available  and  high-quality
>> implementation  of  pthreads for Windows. Pthreads is an API for writing
>> multithreaded applications following the POSIX standard.
>>
>> There are two mingw32 versions of the pthread-w32 runtime  library:  the
>> standard  one,  provided by this package, is called libpthreadgc but may
>> also be referred to as  'libpthread'.  The  non-standard  one  uses  C++
>> exception handling, and is called libpthreadgce. (Note that the standard
>> library may be used successfully with C++ code;  indeed,  on  most  *nix
>> platorms  the  system  pthreads  implementation  follows the behavior of
>> mingw32-libpthreadgc, and NOT the behavior of  the  'GCE'  version).  We
>> recommend  that  most  users rely on mingw32-libpthreadgc ('GC') and not
>> mingw32-libpthreadgce ('GCE').
>>
>> The mingw32-libpthreadgc and mingw32-libpthreadgce packages provide  the
>> two  runtime libraries (most people need not install the 'GCE' one). The
>> associated mingw32-pthreads-w32 package provides the  documentation  for
>> the  pthreads-w32 library, as well as the related development files. The
>> mingw32-libquserex  package  provides  optional  support  for   enhanced
>> standards conformance of the GCE runtime.
>>
>> mingw32-libpthreadgc is a  required  component  of  the  MinGW  Compiler
>> Suite.
>>
>> --
>> -Thad
>> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/67083395/attachment.html>

From luis at debethencourt.com  Thu Sep 12 13:12:19 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Thu, 12 Sep 2013 16:12:19 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
Message-ID: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>

Hello everyone,

I'm interested in helping with some module development. A good way to learn
Rust by using it and help Rust at the same time.

Of the wanted modules in this page:
https://github.com/mozilla/rust/wiki/Libs

I'm attracted to datetime:
https://github.com/mozilla/rust/wiki/Lib-datetime

Just want to make sure there isn't anybody working on this to avoid
accidental duplication.

Thanks,
Luis
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/ea9f9202/attachment-0001.html>

From luis at debethencourt.com  Thu Sep 12 13:14:04 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Thu, 12 Sep 2013 16:14:04 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
Message-ID: <CAPA4HGXGzmp+d_NuCb3_K-VT=seRt+6xWVV_F1CfdbPCUO5Q=w@mail.gmail.com>

Forgot to say I'm luisbg in IRC.
For all of those who have seen/read me there.

:)


On 12 September 2013 16:12, Luis de Bethencourt <luis at debethencourt.com>wrote:

> Hello everyone,
>
> I'm interested in helping with some module development. A good way to
> learn Rust by using it and help Rust at the same time.
>
> Of the wanted modules in this page:
> https://github.com/mozilla/rust/wiki/Libs
>
> I'm attracted to datetime:
> https://github.com/mozilla/rust/wiki/Lib-datetime
>
> Just want to make sure there isn't anybody working on this to avoid
> accidental duplication.
>
> Thanks,
> Luis
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/56486171/attachment.html>

From banderson at mozilla.com  Thu Sep 12 14:10:34 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 12 Sep 2013 14:10:34 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
Message-ID: <52322DCA.8040104@mozilla.com>

On 09/12/2013 12:39 PM, Thad Guidry wrote:
> Yeah, there should not be a reason anymore, if I am correct, to not 
> have GCC 4.7 in MinGW for Rust Windows users anymore.  I will give 
> that a try also , and if it works, then we can close out (#8598 
> <https://github.com/mozilla/rust/issues/8598>). (I also would like to 
> get rid of the 4.5 downgrade needed).... but that does need more 
> testing from the core Rust team and others.
>
> It's something that Brian has been counting on me to help make happen, 
> and Alex is also contributing to some of that effort by fixing various 
> LLVM build issues that affect Windows Rust users as you mention in 
> (#8598 <https://github.com/mozilla/rust/issues/8598>).
>
> Agreed, if a new stage0 compiler snapshot can be created, then we 
> should be in the clear to also close out #5878 
> <https://github.com/mozilla/rust/issues/5878>.
>
>

Thanks for everybody's amazing contributions to our Windows support. If 
somebody makes the changes necessary to work with a newer toolchain then 
we will upgrade the bots. It's unlikely we can do this before 0.8 
though, due in two weeks.

I gather that some folks would like to switch to the mingw-w64 toolchain 
as well. Is that in the cards here?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/8587c784/attachment.html>

From corey at octayn.net  Thu Sep 12 14:28:09 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 12 Sep 2013 17:28:09 -0400
Subject: [rust-dev] This Week in Rust
Message-ID: <CA++BO6QDSK21yFhmc--zkAh7kEtixww13n+_bGX7rPT1RCYDzw@mail.gmail.com>

Sorry it is late; it has been on my blog and reddit, but I forgot to
post it here. Content copied from
http://cmr.github.io/blog/2013/09/07/this-week-in-rust/

--

Welcome to another *This Week in Rust*.

# What's cooking in master?

65 pull requests were merged this week, and bors has had some idle time when
there wasn't anything approved in the queue.

## Breaking changes

- `std::os::glob` has been replaced with a [pure Rust
  version](https://github.com/mozilla/rust/pull/8914), for cross-platform and
  compatability reasons.
- `std::str::from_bytes` has been
  [renamed](https://github.com/mozilla/rust/pull/8997) to
  `std::str::from_utf8`, to be explicit about what it accepts.
- Casting to bool with `as` is [no longer
  allowed](https://github.com/mozilla/rust/pull/8980), and surrogate
  characters are no longer allowed in strings.
- char is [no longer](https://github.com/mozilla/rust/pull/8974) treated as an
  integer type (meaning it can't be casted to/from them), which removes the
  ability for safe code to create invalid characters.
- Opening a listening socket and actually listening on it [have been
  split](https://github.com/mozilla/rust/pull/8954). If you're jiggy with the
  jive, listen and accept are now separate operations. (*ed*: this used to say
  bind and accept wereseparate; thanks to ecr for the correction.)

## Additions

- `let` var hygiene has [landed](https://github.com/mozilla/rust/pull/9026).
  I'm sure this has cool implications, but I don't really know what they are.
- An [`export_name` attribute](https://github.com/mozilla/rust/pull/8903) has
  been added to control what symbol name something is exported as (similar to
  `no_mangle`).
- An `ExactSize` trait [has been
  added](https://github.com/mozilla/rust/pull/8884) to mark an iterator that
  always accurately reports its size in the `size_hint` method.
- `ToStr` has been [implemented](https://github.com/mozilla/rust/pull/8960)
  for char and Ascii.
- Safe accessors of `MutexArc` [have been
  implemented](https://github.com/mozilla/rust/pull/8966)
- A bytes iterator [has been added](https://github.com/mozilla/rust/pull/8935)
  for newrt readers.
- Stream is [automatically
  implemented](https://github.com/mozilla/rust/pull/8984) for types which
  implement Reader and Writer from newrt.
- An `unreachable` macro [has been
  added](https://github.com/mozilla/rust/pull/8992) for better error reporting
  than a function could do.
- newrt [can now do](https://github.com/mozilla/rust/pull/9000) simple DNS
  resolution.
- strptime/strftime [now support](https://github.com/mozilla/rust/pull/9016)
  fractional seconds, out to tenths of a nanosecond.

## Changes etc

- Name mangling [has been
  improved](https://github.com/mozilla/rust/pull/8875).
- `rust_log.cpp` [has been
  converted](https://github.com/mozilla/rust/pull/8880) into pure Rust.
- Debuginfo [now does closure
  capture](https://github.com/mozilla/rust/pull/8855) and very large structs.
- A [bunch](https://github.com/mozilla/rust/pull/8947)
  [of](https://github.com/mozilla/rust/pull/8927)
  [repr](https://github.com/mozilla/rust/pull/8928) improvements landed.

# Meeting

There was no meteting this week listed on the wiki or that I saw.

# Projects

- [rust-nanomsg](https://github.com/glycerine/rust-nanomsg) - bindings to the
  nanomsg library.

From thadguidry at gmail.com  Thu Sep 12 14:57:15 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 12 Sep 2013 16:57:15 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <52322DCA.8040104@mozilla.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
Message-ID: <CAChbWaMnSFHFr92QvxVFHxmhNdY1y+v3rFL+tqbUnW27CE1dcw@mail.gmail.com>

Yes, that's the game plan I have...and klutzy and Vadim.... getting the
mingw-w64 toolchain working.


On Thu, Sep 12, 2013 at 4:10 PM, Brian Anderson <banderson at mozilla.com>wrote:

>  On 09/12/2013 12:39 PM, Thad Guidry wrote:
>
> Yeah, there should not be a reason anymore, if I am correct, to not have
> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
> also , and if it works, then we can close out (#8598<https://github.com/mozilla/rust/issues/8598>
> ).  (I also would like to get rid of the 4.5 downgrade needed).... but
> that does need more testing from the core Rust team and others.
>
>  It's something that Brian has been counting on me to help make happen,
> and Alex is also contributing to some of that effort by fixing various LLVM
> build issues that affect Windows Rust users as you mention in (#8598<https://github.com/mozilla/rust/issues/8598>
> ).
>
>  Agreed, if a new stage0 compiler snapshot can be created, then we should
> be in the clear to also close out #5878<https://github.com/mozilla/rust/issues/5878>
> .
>
>
>
> Thanks for everybody's amazing contributions to our Windows support. If
> somebody makes the changes necessary to work with a newer toolchain then we
> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
> in two weeks.
>
> I gather that some folks would like to switch to the mingw-w64 toolchain
> as well. Is that in the cards here?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/5a6c3265/attachment.html>

From vadimcn at gmail.com  Thu Sep 12 15:06:16 2013
From: vadimcn at gmail.com (Vadim)
Date: Thu, 12 Sep 2013 15:06:16 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <52322DCA.8040104@mozilla.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
Message-ID: <CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>

Hi Brian,

Actually, I would argue that these changes *should* be made before 0.8
release in order to smoothen the path of people who will install 0.8 to try
it out.

Regarding the work to be done, as far as I know all you need is:
1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
2. "mingw-get update"
3. "mingw-get upgrade"
4. run %rust%\configure  (not sure if actually needed, but won't hurt)
5. "make clean"
6. "make check", which will fail at building stage1 std crate because step
3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
8. "make check" again, which should succeed this time

Can somebody please verify that this works?


Re mingw-w64: sort of works, however its' phtreads implementation seems to
be buggy <https://github.com/mozilla/rust/issues/8996#issuecomment-24292739>.
Also see this thread<http://sourceforge.net/mailarchive/forum.php?thread_name=CAKEnbTNV4iDok-k9Gg-Wmr85utFPxLf4wmAabjJZ1WaCFVE5PQ%40mail.gmail.com&forum_name=mingw-w64-public>.
I don't think we'll should migrate to it just yet.

Vadim



On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>wrote:

>  On 09/12/2013 12:39 PM, Thad Guidry wrote:
>
> Yeah, there should not be a reason anymore, if I am correct, to not have
> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
> also , and if it works, then we can close out (#8598<https://github.com/mozilla/rust/issues/8598>
> ).  (I also would like to get rid of the 4.5 downgrade needed).... but
> that does need more testing from the core Rust team and others.
>
>  It's something that Brian has been counting on me to help make happen,
> and Alex is also contributing to some of that effort by fixing various LLVM
> build issues that affect Windows Rust users as you mention in (#8598<https://github.com/mozilla/rust/issues/8598>
> ).
>
>  Agreed, if a new stage0 compiler snapshot can be created, then we should
> be in the clear to also close out #5878<https://github.com/mozilla/rust/issues/5878>
> .
>
>
>
> Thanks for everybody's amazing contributions to our Windows support. If
> somebody makes the changes necessary to work with a newer toolchain then we
> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
> in two weeks.
>
> I gather that some folks would like to switch to the mingw-w64 toolchain
> as well. Is that in the cards here?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/cf0d44b8/attachment-0001.html>

From thadguidry at gmail.com  Thu Sep 12 18:56:54 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 12 Sep 2013 20:56:54 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
Message-ID: <CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>

Doesn't work...

Errors regarding libuv and mswsock...

http://pastebin.mozilla.org/3038909



On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:

> Hi Brian,
>
> Actually, I would argue that these changes *should* be made before 0.8
> release in order to smoothen the path of people who will install 0.8 to try
> it out.
>
> Regarding the work to be done, as far as I know all you need is:
> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
> 2. "mingw-get update"
> 3. "mingw-get upgrade"
>  4. run %rust%\configure  (not sure if actually needed, but won't hurt)
> 5. "make clean"
> 6. "make check", which will fail at building stage1 std crate because step
> 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
> 8. "make check" again, which should succeed this time
>
> Can somebody please verify that this works?
>
>
> Re mingw-w64: sort of works, however its' phtreads implementation seems
> to be buggy<https://github.com/mozilla/rust/issues/8996#issuecomment-24292739>.
> Also see this thread<http://sourceforge.net/mailarchive/forum.php?thread_name=CAKEnbTNV4iDok-k9Gg-Wmr85utFPxLf4wmAabjJZ1WaCFVE5PQ%40mail.gmail.com&forum_name=mingw-w64-public>.
> I don't think we'll should migrate to it just yet.
>
> Vadim
>
>
>
> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>>  On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>
>> Yeah, there should not be a reason anymore, if I am correct, to not have
>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>> also , and if it works, then we can close out (#8598<https://github.com/mozilla/rust/issues/8598>
>> ).  (I also would like to get rid of the 4.5 downgrade needed).... but
>> that does need more testing from the core Rust team and others.
>>
>>  It's something that Brian has been counting on me to help make happen,
>> and Alex is also contributing to some of that effort by fixing various LLVM
>> build issues that affect Windows Rust users as you mention in (#8598<https://github.com/mozilla/rust/issues/8598>
>> ).
>>
>>  Agreed, if a new stage0 compiler snapshot can be created, then we
>> should be in the clear to also close out #5878<https://github.com/mozilla/rust/issues/5878>
>> .
>>
>>
>>
>> Thanks for everybody's amazing contributions to our Windows support. If
>> somebody makes the changes necessary to work with a newer toolchain then we
>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>> in two weeks.
>>
>> I gather that some folks would like to switch to the mingw-w64 toolchain
>> as well. Is that in the cards here?
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/9b399b0b/attachment.html>

From luis at debethencourt.com  Thu Sep 12 19:52:57 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Thu, 12 Sep 2013 22:52:57 -0400
Subject: [rust-dev] This Week in Rust
In-Reply-To: <CA++BO6QDSK21yFhmc--zkAh7kEtixww13n+_bGX7rPT1RCYDzw@mail.gmail.com>
References: <CA++BO6QDSK21yFhmc--zkAh7kEtixww13n+_bGX7rPT1RCYDzw@mail.gmail.com>
Message-ID: <CAPA4HGVU3g97cuckQk46B=gJv8xua9LtzeEZbiu7ObbVe72EJg@mail.gmail.com>

Thanks Corey!

This updates are great to keep track of all things Rust. Kudos :)

Luis


On 12 September 2013 17:28, Corey Richardson <corey at octayn.net> wrote:

> Sorry it is late; it has been on my blog and reddit, but I forgot to
> post it here. Content copied from
> http://cmr.github.io/blog/2013/09/07/this-week-in-rust/
>
> --
>
> Welcome to another *This Week in Rust*.
>
> # What's cooking in master?
>
> 65 pull requests were merged this week, and bors has had some idle time
> when
> there wasn't anything approved in the queue.
>
> ## Breaking changes
>
> - `std::os::glob` has been replaced with a [pure Rust
>   version](https://github.com/mozilla/rust/pull/8914), for cross-platform
> and
>   compatability reasons.
> - `std::str::from_bytes` has been
>   [renamed](https://github.com/mozilla/rust/pull/8997) to
>   `std::str::from_utf8`, to be explicit about what it accepts.
> - Casting to bool with `as` is [no longer
>   allowed](https://github.com/mozilla/rust/pull/8980), and surrogate
>   characters are no longer allowed in strings.
> - char is [no longer](https://github.com/mozilla/rust/pull/8974) treated
> as an
>   integer type (meaning it can't be casted to/from them), which removes the
>   ability for safe code to create invalid characters.
> - Opening a listening socket and actually listening on it [have been
>   split](https://github.com/mozilla/rust/pull/8954). If you're jiggy with
> the
>   jive, listen and accept are now separate operations. (*ed*: this used to
> say
>   bind and accept wereseparate; thanks to ecr for the correction.)
>
> ## Additions
>
> - `let` var hygiene has [landed](https://github.com/mozilla/rust/pull/9026
> ).
>   I'm sure this has cool implications, but I don't really know what they
> are.
> - An [`export_name` attribute](https://github.com/mozilla/rust/pull/8903)
> has
>   been added to control what symbol name something is exported as (similar
> to
>   `no_mangle`).
> - An `ExactSize` trait [has been
>   added](https://github.com/mozilla/rust/pull/8884) to mark an iterator
> that
>   always accurately reports its size in the `size_hint` method.
> - `ToStr` has been [implemented](https://github.com/mozilla/rust/pull/8960
> )
>   for char and Ascii.
> - Safe accessors of `MutexArc` [have been
>   implemented](https://github.com/mozilla/rust/pull/8966)
> - A bytes iterator [has been added](
> https://github.com/mozilla/rust/pull/8935)
>   for newrt readers.
> - Stream is [automatically
>   implemented](https://github.com/mozilla/rust/pull/8984) for types which
>   implement Reader and Writer from newrt.
> - An `unreachable` macro [has been
>   added](https://github.com/mozilla/rust/pull/8992) for better error
> reporting
>   than a function could do.
> - newrt [can now do](https://github.com/mozilla/rust/pull/9000) simple DNS
>   resolution.
> - strptime/strftime [now support](
> https://github.com/mozilla/rust/pull/9016)
>   fractional seconds, out to tenths of a nanosecond.
>
> ## Changes etc
>
> - Name mangling [has been
>   improved](https://github.com/mozilla/rust/pull/8875).
> - `rust_log.cpp` [has been
>   converted](https://github.com/mozilla/rust/pull/8880) into pure Rust.
> - Debuginfo [now does closure
>   capture](https://github.com/mozilla/rust/pull/8855) and very large
> structs.
> - A [bunch](https://github.com/mozilla/rust/pull/8947)
>   [of](https://github.com/mozilla/rust/pull/8927)
>   [repr](https://github.com/mozilla/rust/pull/8928) improvements landed.
>
> # Meeting
>
> There was no meteting this week listed on the wiki or that I saw.
>
> # Projects
>
> - [rust-nanomsg](https://github.com/glycerine/rust-nanomsg) - bindings to
> the
>   nanomsg library.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/dcbe060e/attachment.html>

From spam at scientician.net  Thu Sep 12 21:57:20 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Fri, 13 Sep 2013 06:57:20 +0200
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
Message-ID: <l0u5v8$q0n$1@ger.gmane.org>

On 2013-09-12 22:12, Luis de Bethencourt wrote:
> Hello everyone,
> 
> I'm interested in helping with some module development. A good way to learn
> Rust by using it and help Rust at the same time.
> 
> Of the wanted modules in this page:
> https://github.com/mozilla/rust/wiki/Libs
> 

I see that this page does have a link to design docs for JSR-310 which
is probably a good bet as to a usable DateTime API design (for Java at
least). I just thought I'd mention that the documentation for the
"nearly final" (i.e. barring serious bugs) API has been released at:

   http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html

Even if this is for Java, the design decisions about how the conepts of
date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)
would apply in any language. They are also all essential concepts when
working seriously with date/time even though the distinctions may not
appear so at first.

(I should mention that the lead on the JSR-310 spec was also the author
of JodaTime which gets much deserved credit by Java developers for
bringing date/time manipulation on the JVM out of the dark ages of
java.util.Date. JSR-310 is a slightly reworked/simplified version of
that API, so it's a sort of "what are the essentials?" version of JodaTime.)

Regards,



From vadimcn at gmail.com  Thu Sep 12 23:19:04 2013
From: vadimcn at gmail.com (Vadim)
Date: Thu, 12 Sep 2013 23:19:04 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
Message-ID: <CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>

Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
broke mswsock.h (though the file didn't change).


On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:

> Doesn't work...
>
> Errors regarding libuv and mswsock...
>
> http://pastebin.mozilla.org/3038909
>
>
>
> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>
>> Hi Brian,
>>
>> Actually, I would argue that these changes *should* be made before 0.8
>> release in order to smoothen the path of people who will install 0.8 to try
>> it out.
>>
>> Regarding the work to be done, as far as I know all you need is:
>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>> 2. "mingw-get update"
>> 3. "mingw-get upgrade"
>>  4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>> 5. "make clean"
>> 6. "make check", which will fail at building stage1 std crate because
>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>> 8. "make check" again, which should succeed this time
>>
>> Can somebody please verify that this works?
>>
>>
>> Re mingw-w64: sort of works, however its' phtreads implementation seems
>> to be buggy<https://github.com/mozilla/rust/issues/8996#issuecomment-24292739>.
>> Also see this thread<http://sourceforge.net/mailarchive/forum.php?thread_name=CAKEnbTNV4iDok-k9Gg-Wmr85utFPxLf4wmAabjJZ1WaCFVE5PQ%40mail.gmail.com&forum_name=mingw-w64-public>.
>> I don't think we'll should migrate to it just yet.
>>
>> Vadim
>>
>>
>>
>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>wrote:
>>
>>>  On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>>
>>> Yeah, there should not be a reason anymore, if I am correct, to not have
>>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>>> also , and if it works, then we can close out (#8598<https://github.com/mozilla/rust/issues/8598>
>>> ).  (I also would like to get rid of the 4.5 downgrade needed).... but
>>> that does need more testing from the core Rust team and others.
>>>
>>>  It's something that Brian has been counting on me to help make happen,
>>> and Alex is also contributing to some of that effort by fixing various LLVM
>>> build issues that affect Windows Rust users as you mention in (#8598<https://github.com/mozilla/rust/issues/8598>
>>> ).
>>>
>>>  Agreed, if a new stage0 compiler snapshot can be created, then we
>>> should be in the clear to also close out #5878<https://github.com/mozilla/rust/issues/5878>
>>> .
>>>
>>>
>>>
>>> Thanks for everybody's amazing contributions to our Windows support. If
>>> somebody makes the changes necessary to work with a newer toolchain then we
>>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>>> in two weeks.
>>>
>>> I gather that some folks would like to switch to the mingw-w64 toolchain
>>> as well. Is that in the cards here?
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130912/17ffa439/attachment-0001.html>

From niko at alum.mit.edu  Fri Sep 13 02:48:41 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 13 Sep 2013 05:48:41 -0400
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
	<20130909133458.GE3459@Mr-Bennet>
	<CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>
Message-ID: <20130913094841.GD6242@Mr-Bennet>

I see. There is actually some debate about the proper behavior of `as`,
but I believe the conversions that it will currently apply are:

1. Between scalar types (e.g., int to i32 and vice versa)
2. Into an object type (from @T into @Trait)
3. Borrowing (@T or ~T into &T)
4. Converting between unsafe pointer types, and I think uint to *T as well

It has been proposed to limit `as` to #1 and rely instead on a
combination of type ascription (`expr : T`), implicit conversions, and
transmute calls for some of the others.

In principle we could use library calls or traits for almost
everything `as` does, except that we have been resisting the idea of
compile-time evaluation of functions, meaning that we wanted to have
operators for anything that would be legal as part of a constant
definition. I am not sure if this principled stand is worth it,
though, since `as` is a troublesome and heavily overloaded operator.


Niko

On Tue, Sep 10, 2013 at 10:20:02AM +1200, Nick Cameron wrote:
> To clarify I meant subtyping in the sense of when are types compatible for
> some kind of conversion. As opposed to subsumption or subclassing (or at
> least, not limited to these cases).
> 
> If I have |e as U| when does that succeed, and when does it fail. (Actually
> from the manual it was unclear how much checking is done statically vs
> dynamically, but that is kind of a tangent). Presumably the cast only
> succeeds if the dynamic type of e is a subtype of U (or it can be coerced
> or converted to U). An example from the manual (sect 8.1.10) shows that an
> instance of an impl can be cast to the type of an implemented trait, are
> there other relationships where casting is allowed?
> 
> The manual states (sect 7.2.11.5):
> 
> "A numeric value can be cast to any numeric type. A raw pointer value can
> be cast to or from any integral type or raw pointer type. Any other cast is
> unsupported and will fail to compile."
> 
> But the last sentence is contradicted by the example in section 8.1.10
> 
> Separately, I remember that the various pointer types can be implicitly
> converted. I couldn't find anywhere where these conversions are defined. Is
> my memory bad or my search skills?
> 
> Thanks, Nick
> 
> 
> On Tue, Sep 10, 2013 at 1:34 AM, Niko Matsakis <niko at alum.mit.edu> wrote:
> 
> > By subtyping, do you mean defining class hierarchies as in C++ or
> > Java?  This is currently not supported. Typically such hierarchies
> > are modeled either using an `enum` (most common) or using a `trait`.
> >
> > Enums are perfect for cases where there is a limited set of
> > possibilities. Traits are perfect for "open-ended" situations where
> > you have an interface and many ways to fulfill it. The two techniques
> > *can* be combined for cases that fall between the two extremes.
> >
> > We have considered adding a limited form of struct inheritance (so
> > that one struct can build on another) but afaik this feature is not
> > planned in the short term.
> >
> >
> > Niko
> >
> > On Mon, Sep 09, 2013 at 07:04:07PM +1200, Nick Cameron wrote:
> > > Is there somewhere I can look for a description of subtyping in Rust? I
> > > don't see any mention of it in the manual or tutorial.
> > >
> > > Thanks, Nick
> >
> > > _______________________________________________
> > > Rust-dev mailing list
> > > Rust-dev at mozilla.org
> > > https://mail.mozilla.org/listinfo/rust-dev
> >
> >

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From niko at alum.mit.edu  Fri Sep 13 02:51:13 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 13 Sep 2013 05:51:13 -0400
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
	<CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
Message-ID: <20130913095113.GE6242@Mr-Bennet>

People seem to reimplement C++ compilers, despite there being an
enormous amount of complex just parsing it... that said, the trickiest
and least specified part of the type checker right now is probably the
type inferencing algorithm, which I hope we can overhaul for something
that is clearer or more easily specified.


Niko

On Wed, Sep 11, 2013 at 08:50:39AM -0400, Corey Richardson wrote:
> On Wed, Sep 11, 2013 at 3:27 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> > Presumably before rust reaches a point of earth-shaking importance
> > there will be an second implementation which can compile the first
> > compiler, thus permitting this solution. :)
> 
> I wouldn't be so sure of that. There's a ton of trickiness around the
> type and borrow checker and everything else, and I'm not sure anyone
> would *want* to reimplement it. What gain would there be?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From robertknight at gmail.com  Fri Sep 13 03:27:29 2013
From: robertknight at gmail.com (Robert Knight)
Date: Fri, 13 Sep 2013 11:27:29 +0100
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <20130913095113.GE6242@Mr-Bennet>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
	<CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
	<20130913095113.GE6242@Mr-Bennet>
Message-ID: <CAJGrnh3s9fVASihhzs34=SHd7RNzoYfXcGm1fXxvCc+aq64RDw@mail.gmail.com>

> People seem to reimplement C++ compilers,
> despite there being an enormous amount of complex just parsing it

Realistically though, how many implementations are libre and complete
enough to actually build a C++ compiler?



On 13 September 2013 10:51, Niko Matsakis <niko at alum.mit.edu> wrote:
> People seem to reimplement C++ compilers, despite there being an
> enormous amount of complex just parsing it... that said, the trickiest
> and least specified part of the type checker right now is probably the
> type inferencing algorithm, which I hope we can overhaul for something
> that is clearer or more easily specified.
>
>
> Niko
>
> On Wed, Sep 11, 2013 at 08:50:39AM -0400, Corey Richardson wrote:
>> On Wed, Sep 11, 2013 at 3:27 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> > Presumably before rust reaches a point of earth-shaking importance
>> > there will be an second implementation which can compile the first
>> > compiler, thus permitting this solution. :)
>>
>> I wouldn't be so sure of that. There's a ton of trickiness around the
>> type and borrow checker and everything else, and I'm not sure anyone
>> would *want* to reimplement it. What gain would there be?
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From russel at winder.org.uk  Fri Sep 13 11:45:16 2013
From: russel at winder.org.uk (Russel Winder)
Date: Fri, 13 Sep 2013 19:45:16 +0100
Subject: [rust-dev] Trouble building Rust
Message-ID: <1379097916.4456.22.camel@anglides.winder.org.uk>

I am running Debian Unstable, fully up to date. I have a clone of the
Rust Git repository, again fully up to date. Everything used to build
fine, but sometime recently something has changed, I assume in the
Debian set up that means that I am no longer able to build Rust. Well I
can'#t make the documentation which causes a build fail. Has anyone seen
this and found a way forward?

I tried manually running pandoc on rust.md but Make seems to think that
hasn't done enough, I guess the problem is a dependency that always
causes  doc/version_info.html to be rebuilt.

Thanks.


compile_and_link: x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/librust.so
Warning: removing previous 'librust-*.so' libraries: x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib//librust-28ac9d9c3782cf3d-0.8-pre.so
version-info: doc/version_info.html
sed -e "s/VERSION/0.8-pre/; s/SHORT_HASH/7c8f503a/;\
	            s/STAMP/7c8f503ac543e0ffe18986b8d6f8548df21cefa3/;" /home/Checkouts/Git/Git/Rust/doc/version_info.html.template >doc/version_info.html
pandoc: doc/rust.html
pandoc: /usr/share/pandoc/data/templates/default.html: openBinaryFile: does not exist (No such file or directory)

events.js:72
        throw er; // Unhandled 'error' event
              ^
Error: write EPIPE
    at errnoException (net.js:901:11)
    at Object.afterWrite (net.js:718:19)
make: *** [doc/rust.html] Error 1


-- 
Russel.
=============================================================================
Dr Russel Winder      t: +44 20 7585 2200   voip: sip:russel.winder at ekiga.net
41 Buckmaster Road    m: +44 7770 465 077   xmpp: russel at winder.org.uk
London SW11 1EN, UK   w: www.russel.org.uk  skype: russel_winder
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: This is a digitally signed message part
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/e3e18266/attachment.sig>

From m at minhdo.org  Thu Sep 12 22:17:09 2013
From: m at minhdo.org (Minh Do)
Date: Fri, 13 Sep 2013 13:17:09 +0800
Subject: [rust-dev] Working on rusti as final year project
In-Reply-To: <521B85C2.8060804@minhdo.org>
References: <521B85C2.8060804@minhdo.org>
Message-ID: <52329FD5.8090107@minhdo.org>

On 08/27/2013 12:43 AM, Minh Do wrote:
> My name is Do Nhat Minh, currently a final year Computer Science 
> student at Nanyang Technological University in Singapore. I have 
> played with Rust and found the experience to be very pleasant. I think 
> Rust make sensible trade-offs and managed to stay small, compared to C++.
>
> I have been granted permission by my university supervisor to work on 
> rusti as my final year project. I hope with this contribution, Rust 
> will be even stronger a competitor to Go and D.
>
> This will be my first time working on something this size and this 
> long a duration. I would love to hear your advice or experience 
> implementing rusti.
>
> Thank you for your time.
>
> Regards,
> Minh
Hi,

I'm working on figuring out why rusti segfaults. So far, I'm able to 
extract very little information.

Attached is a backtrace from rusti using gdb. SIGSEGV is signaled inside 
jemalloc's tcache_alloc_easy, line 286. Below is the piece code where it 
fails.

274    JEMALLOC_ALWAYS_INLINE void *
275    tcache_alloc_easy(tcache_bin_t *tbin)
276    {
277        void *ret;
278
279        if (tbin->ncached == 0) {
280            tbin->low_water = -1;
281            return (NULL);
282        }
283        tbin->ncached--;
284        if ((int)tbin->ncached < tbin->low_water)
285            tbin->low_water = tbin->ncached;
286        ret = tbin->avail[tbin->ncached]; // <- XXX fail here
287        return (ret);
288    }

jemalloc is trying to read from tbin->avail at tbin->ncached. 
tbin->ncached was 1227353920 (or 0x4927ef40) which is too big in my 
opinion. All the other values in tbin were unusually high or low, which 
leads me to suspect tbin is uninitialized or there is a memory overrun.

I run valgrind on rusti in the hope of catching memory overruns, but it 
does not help much. Valgrind only prints some warning about conditional 
jumps depending on uninitialized variables and then reports an invalid 
read with the identical backtrace. However, at the top, valgrind prints 
the below text, which I find quite interesting.

==31583== Syscall param read(buf) points to unaddressable byte(s)
==31583==    at 0x40170C7: read (in /usr/lib/ld-2.18.so)
==31583==    by 0x400586C: open_verify (in /usr/lib/ld-2.18.so)
==31583==    by 0x4005CA6: open_path (in /usr/lib/ld-2.18.so)
==31583==    by 0x4008495: _dl_map_object (in /usr/lib/ld-2.18.so)
==31583==    by 0x400C281: openaux (in /usr/lib/ld-2.18.so)
==31583==    by 0x400E773: _dl_catch_error (in /usr/lib/ld-2.18.so)
==31583==    by 0x400C4E4: _dl_map_object_deps (in /usr/lib/ld-2.18.so)
==31583==    by 0x4002E93: dl_main (in /usr/lib/ld-2.18.so)
==31583==    by 0x4015174: _dl_sysdep_start (in /usr/lib/ld-2.18.so)
==31583==    by 0x4004AE5: _dl_start (in /usr/lib/ld-2.18.so)
==31583==    by 0x4001277: ??? (in /usr/lib/ld-2.18.so)
==31583==  Address 0x7fec7f700 is on thread 1's stack

I then try linking directly with Rust's libstd (since it's the first 
thing that's linked with the code being compiled) in rusti's main() 
before anything is done. Below is the addition.

diff --git a/src/librusti/rusti.rs b/src/librusti/rusti.rs
index 8d61a97..2f72cfa 100644
--- a/src/librusti/rusti.rs
+++ b/src/librusti/rusti.rs
@@ -84,6 +84,9 @@ use syntax::print::pprust;
  use program::Program;
  use utils::*;

+use rustc::lib::llvm::llvm;
+use std::unstable::intrinsics;
+
  mod program;
  pub mod utils;

@@ -505,6 +508,17 @@ pub fn main() {
  pub fn main_args(args: &[~str]) {
      #[fixed_stack_segment]; #[inline(never)];

+    unsafe {
+        let manager = 
llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());
+        let path = 
"/path/to/rust/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.8-pre.so";
+        do path.with_c_str |buf_t| {
+            if !llvm::LLVMRustLoadCrate(manager, buf_t) {
+                debug!(~"Could not link");
+            }
+            debug!("linked: %s", path);
+        }
+    }
+
      let input = io::stdin();
      let out = io::stdout();
      let mut repl = Repl {

Rusti now also fails in the scheduler sometimes if it happens to switch 
threads while LLVMRustLoadCrate is being executed. Below is the backtrace.

#0  rust_thread_start (ptr=0x7ffff1c1f5e0) at src/rt/sync/rust_thread.cpp:36
#1  0x00007ffff548b0a2 in start_thread () from /usr/lib/libpthread.so.0
#2  0x00007ffff3217a2d in clone () from /usr/lib/libc.so.6

The above failure in the scheduler and the curious message by valgrind 
makes me wonder about the scheduler and the runtime. However, when git 
grep-ing for rust_thread, I don't see how it is hooked into Rust. Could 
someone enlighten me on this?

More importantly, does anyone have any suggestion about my approach or 
any leads on this?

Regards,
Minh
-------------- next part --------------
#0  0x00007f43cecc7737 in SignalHandler(int) ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustllvm.so
#1  <signal handler called>
#2  0x00007f43cdb1fd9d in tcache_alloc_easy (tbin=0x7f43ca8062e8) at ../../../../src/rt/jemalloc/include/jemalloc/internal/tcache.h:286
#3  tcache_alloc_small (zero=true, size=1315, tcache=0x7f43ca806000) at ../../../../src/rt/jemalloc/include/jemalloc/internal/tcache.h:300
#4  arena_malloc (try_tcache=true, zero=true, size=1315, arena=0x0) at ../../../../src/rt/jemalloc/include/jemalloc/internal/arena.h:916
#5  icallocx (arena=0x0, try_tcache=true, size=1315) at include/jemalloc/internal/jemalloc_internal.h:803
#6  icalloc (size=1315) at include/jemalloc/internal/jemalloc_internal.h:812
#7  calloc (num=<optimized out>, size=<optimized out>) at ../../../../src/rt/jemalloc/src/jemalloc.c:1079
#8  0x00007f43d1b0f75f in _dl_new_object () from /lib64/ld-linux-x86-64.so.2
#9  0x00007f43d1b0b204 in _dl_map_object_from_fd () from /lib64/ld-linux-x86-64.so.2
#10 0x00007f43d1b0cff5 in _dl_map_object () from /lib64/ld-linux-x86-64.so.2
#11 0x00007f43d1b17917 in dl_open_worker () from /lib64/ld-linux-x86-64.so.2
#12 0x00007f43d1b13774 in _dl_catch_error () from /lib64/ld-linux-x86-64.so.2
#13 0x00007f43d1b1732b in _dl_open () from /lib64/ld-linux-x86-64.so.2
#14 0x00007f43cd4dc02b in ?? () from /usr/lib/libdl.so.2
#15 0x00007f43d1b13774 in _dl_catch_error () from /lib64/ld-linux-x86-64.so.2
#16 0x00007f43cd4dc5dd in ?? () from /usr/lib/libdl.so.2
#17 0x00007f43cd4dc0c1 in dlopen () from /usr/lib/libdl.so.2
#18 0x00007f43cecb12e7 in llvm::sys::DynamicLibrary::getPermanentLibrary(char const*, std::string*) ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustllvm.so
#19 0x00007f43cdfdf46c in RustMCJITMemoryManager::loadCrate (this=this at entry=0x7f43ca85e100, 
    file=file at entry=0x7f43c2220020 "/home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.8-pre.so", err=err at entry=0x7f43caa48070) at src/rustllvm/RustWrapper.cpp:132
#20 0x00007f43cdfdfcfb in LLVMRustLoadCrate (mem=0x7f43ca85e100, 
    crate=0x7f43c2220020 "/home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.8-pre.so") at src/rustllvm/RustWrapper.cpp:271
#21 0x00007f43d02c385e in back::link::jit::exec::_c689f4ad2731ee34::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so
#22 0x00007f43d02c5a27 in back::link::write::run_passes::_8982e8a461f435::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so
#23 0x00007f43d0335568 in driver::driver::phase_5_run_llvm_passes::anon::expr_fn_97090 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so
#24 0x00007f43d00538e1 in util::common::time_72396::_c4d0513e54dc658e::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so
#25 0x00007f43d03352d2 in driver::driver::phase_5_run_llvm_passes::_af1696f6788ce06d::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so
#26 0x00007f43cf87f799 in run::_bdca1c883dbff4c::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librusti-53e0ef2ae196aaff-0.8-pre.so
#27 0x00007f43cf8a17c5 in run_line::anon::expr_fn_17258 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librusti-53e0ef2ae196aaff-0.8-pre.so
#28 0x00007f43cf89ecb1 in task::__extensions__::try_16906::anon::expr_fn_17066 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/librusti-53e0ef2ae196aaff-0.8-pre.so
#29 0x00007f43d147b6b0 in task::spawn::spawn_raw::anon::expr_fn_37755 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#30 0x00007f43d14c25c0 in rt::task::__extensions__::build_start_wrapper::anon::anon::expr_fn_44126 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#31 0x00007f43d14c0ab7 in rt::task::__extensions__::run::anon::expr_fn_44054 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#32 0x00007f43cdb12834 in rust_try (f=<optimized out>, fptr=<optimized out>, env=<optimized out>) at src/rt/rust_builtin.cpp:523
#33 0x00007f43d14c09ec in rt::task::Unwinder::try::_199ab8d6eb226980EIaH::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#34 0x00007f43d14c0861 in rt::task::Task::run::_199ab8d6eb22698022aG::v0.8$x2dpre ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#35 0x00007f43d14c21ac in rt::task::__extensions__::build_start_wrapper::anon::expr_fn_44111 ()
   from /home/minh/Documents/Workplace/rust/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/libstd-6c65cf4b443341b1-0.8-pre.so
#36 0x0000000000000000 in ?? ()

From catamorphism at gmail.com  Fri Sep 13 11:50:03 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Fri, 13 Sep 2013 11:50:03 -0700
Subject: [rust-dev] Trouble building Rust
In-Reply-To: <1379097916.4456.22.camel@anglides.winder.org.uk>
References: <1379097916.4456.22.camel@anglides.winder.org.uk>
Message-ID: <CADcg8==iT9GskHJmqfy5_rX8hA-LTEjpZN=HidOC_kFuwPY+Dw@mail.gmail.com>

I don't know what the bug with the docs is, but in the meantime, you
can build without the docs by doing:

./configure --disable-docs

and then rebuilding.

Cheers,
Tim

-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From danielmicay at gmail.com  Fri Sep 13 11:57:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 13 Sep 2013 14:57:03 -0400
Subject: [rust-dev] Working on rusti as final year project
In-Reply-To: <52329FD5.8090107@minhdo.org>
References: <521B85C2.8060804@minhdo.org> <52329FD5.8090107@minhdo.org>
Message-ID: <CA+DvKQL7tr09U9dPzBVJGH1Z+AjNAix41eZXWfCpeFNqkNFGcw@mail.gmail.com>

On Fri, Sep 13, 2013 at 1:17 AM, Minh Do <m at minhdo.org> wrote:

> On 08/27/2013 12:43 AM, Minh Do wrote:
>
>> My name is Do Nhat Minh, currently a final year Computer Science student
>> at Nanyang Technological University in Singapore. I have played with Rust
>> and found the experience to be very pleasant. I think Rust make sensible
>> trade-offs and managed to stay small, compared to C++.
>>
>> I have been granted permission by my university supervisor to work on
>> rusti as my final year project. I hope with this contribution, Rust will be
>> even stronger a competitor to Go and D.
>>
>> This will be my first time working on something this size and this long a
>> duration. I would love to hear your advice or experience implementing rusti.
>>
>> Thank you for your time.
>>
>> Regards,
>> Minh
>>
> Hi,
>
> I'm working on figuring out why rusti segfaults. So far, I'm able to
> extract very little information.
>
> Attached is a backtrace from rusti using gdb. SIGSEGV is signaled inside
> jemalloc's tcache_alloc_easy, line 286. Below is the piece code where it
> fails.
>
> 274    JEMALLOC_ALWAYS_INLINE void *
> 275    tcache_alloc_easy(tcache_bin_t *tbin)
> 276    {
> 277        void *ret;
> 278
> 279        if (tbin->ncached == 0) {
> 280            tbin->low_water = -1;
> 281            return (NULL);
> 282        }
> 283        tbin->ncached--;
> 284        if ((int)tbin->ncached < tbin->low_water)
> 285            tbin->low_water = tbin->ncached;
> 286        ret = tbin->avail[tbin->ncached]; // <- XXX fail here
> 287        return (ret);
> 288    }
>
> jemalloc is trying to read from tbin->avail at tbin->ncached.
> tbin->ncached was 1227353920 (or 0x4927ef40) which is too big in my
> opinion. All the other values in tbin were unusually high or low, which
> leads me to suspect tbin is uninitialized or there is a memory overrun.
>
> I run valgrind on rusti in the hope of catching memory overruns, but it
> does not help much. Valgrind only prints some warning about conditional
> jumps depending on uninitialized variables and then reports an invalid read
> with the identical backtrace. However, at the top, valgrind prints the
> below text, which I find quite interesting.
>
> ==31583== Syscall param read(buf) points to unaddressable byte(s)
> ==31583==    at 0x40170C7: read (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x400586C: open_verify (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4005CA6: open_path (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4008495: _dl_map_object (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x400C281: openaux (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x400E773: _dl_catch_error (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x400C4E4: _dl_map_object_deps (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4002E93: dl_main (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4015174: _dl_sysdep_start (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4004AE5: _dl_start (in /usr/lib/ld-2.18.so)
> ==31583==    by 0x4001277: ??? (in /usr/lib/ld-2.18.so)
> ==31583==  Address 0x7fec7f700 is on thread 1's stack
>
> I then try linking directly with Rust's libstd (since it's the first thing
> that's linked with the code being compiled) in rusti's main() before
> anything is done. Below is the addition.
>
> diff --git a/src/librusti/rusti.rs b/src/librusti/rusti.rs
> index 8d61a97..2f72cfa 100644
> --- a/src/librusti/rusti.rs
> +++ b/src/librusti/rusti.rs
> @@ -84,6 +84,9 @@ use syntax::print::pprust;
>  use program::Program;
>  use utils::*;
>
> +use rustc::lib::llvm::llvm;
> +use std::unstable::intrinsics;
> +
>  mod program;
>  pub mod utils;
>
> @@ -505,6 +508,17 @@ pub fn main() {
>  pub fn main_args(args: &[~str]) {
>      #[fixed_stack_segment]; #[inline(never)];
>
> +    unsafe {
> +        let manager = llvm::LLVMRustPrepareJIT(**
> intrinsics::morestack_addr());
> +        let path = "/path/to/rust/x86_64-unknown-**
> linux-gnu/stage2/lib/rustc/**x86_64-unknown-linux-gnu/lib/l**
> ibstd-6c65cf4b443341b1-0.8-**pre.so<http://libstd-6c65cf4b443341b1-0.8-pre.so>
> ";
> +        do path.with_c_str |buf_t| {
> +            if !llvm::LLVMRustLoadCrate(**manager, buf_t) {
> +                debug!(~"Could not link");
> +            }
> +            debug!("linked: %s", path);
> +        }
> +    }
> +
>      let input = io::stdin();
>      let out = io::stdout();
>      let mut repl = Repl {
>
> Rusti now also fails in the scheduler sometimes if it happens to switch
> threads while LLVMRustLoadCrate is being executed. Below is the backtrace.
>
> #0  rust_thread_start (ptr=0x7ffff1c1f5e0) at
> src/rt/sync/rust_thread.cpp:36
> #1  0x00007ffff548b0a2 in start_thread () from /usr/lib/libpthread.so.0
> #2  0x00007ffff3217a2d in clone () from /usr/lib/libc.so.6
>
> The above failure in the scheduler and the curious message by valgrind
> makes me wonder about the scheduler and the runtime. However, when git
> grep-ing for rust_thread, I don't see how it is hooked into Rust. Could
> someone enlighten me on this?
>
> More importantly, does anyone have any suggestion about my approach or any
> leads on this?
>
> Regards,
> Minh
>

Compile jemalloc with --enable-debug (you can add it to rt.mk) and it will
check for things like double-free.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/2904265f/attachment.html>

From luis at debethencourt.com  Fri Sep 13 12:10:21 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Fri, 13 Sep 2013 15:10:21 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <l0u5v8$q0n$1@ger.gmane.org>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
Message-ID: <CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>

Hello Bardur,

Thank you so much for the reference resource of JSR-310 and its design docs.
I looked over it briefly and it is indeed very valuable.

It was listed in the wiki page, but the link was to the former home of it.
I have updated it.

Since nobody has claimed this module, I will start working on this module
tomorrow Saturday.
Is that OK?

Please, please, I would love more comments and ideas. Will start asking for
reviews once I have some code to show.

Thanks,
Luis





On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net> wrote:

> On 2013-09-12 22:12, Luis de Bethencourt wrote:
> > Hello everyone,
> >
> > I'm interested in helping with some module development. A good way to
> learn
> > Rust by using it and help Rust at the same time.
> >
> > Of the wanted modules in this page:
> > https://github.com/mozilla/rust/wiki/Libs
> >
>
> I see that this page does have a link to design docs for JSR-310 which
> is probably a good bet as to a usable DateTime API design (for Java at
> least). I just thought I'd mention that the documentation for the
> "nearly final" (i.e. barring serious bugs) API has been released at:
>
>    http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html
>
> Even if this is for Java, the design decisions about how the conepts of
> date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)
> would apply in any language. They are also all essential concepts when
> working seriously with date/time even though the distinctions may not
> appear so at first.
>
> (I should mention that the lead on the JSR-310 spec was also the author
> of JodaTime which gets much deserved credit by Java developers for
> bringing date/time manipulation on the JVM out of the dark ages of
> java.util.Date. JSR-310 is a slightly reworked/simplified version of
> that API, so it's a sort of "what are the essentials?" version of
> JodaTime.)
>
> Regards,
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/355ebe11/attachment.html>

From garethdanielsmith at gmail.com  Fri Sep 13 12:40:55 2013
From: garethdanielsmith at gmail.com (Gareth Smith)
Date: Fri, 13 Sep 2013 20:40:55 +0100
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
Message-ID: <52336A47.8040605@gmail.com>

I think its great that you are going to be working on this. A 
comprehensive datetime library is very important. That said I have not 
got any particular ideas or comments.

I have not used Joda time/JSR-310 but the docs look promising and lots 
of people seem to recommend it.

Cheers
Gareth


On 13/09/13 20:10, Luis de Bethencourt wrote:
> Hello Bardur,
>
> Thank you so much for the reference resource of JSR-310 and its design 
> docs.
> I looked over it briefly and it is indeed very valuable.
>
> It was listed in the wiki page, but the link was to the former home of it.
> I have updated it.
>
> Since nobody has claimed this module, I will start working on this 
> module tomorrow Saturday.
> Is that OK?
>
> Please, please, I would love more comments and ideas. Will start 
> asking for reviews once I have some code to show.
>
> Thanks,
> Luis
>
>
>
>
>
> On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net 
> <mailto:spam at scientician.net>> wrote:
>
>     On 2013-09-12 22:12, Luis de Bethencourt wrote:
>     > Hello everyone,
>     >
>     > I'm interested in helping with some module development. A good
>     way to learn
>     > Rust by using it and help Rust at the same time.
>     >
>     > Of the wanted modules in this page:
>     > https://github.com/mozilla/rust/wiki/Libs
>     >
>
>     I see that this page does have a link to design docs for JSR-310 which
>     is probably a good bet as to a usable DateTime API design (for Java at
>     least). I just thought I'd mention that the documentation for the
>     "nearly final" (i.e. barring serious bugs) API has been released at:
>
>     http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html
>
>     Even if this is for Java, the design decisions about how the
>     conepts of
>     date/time are modeled (Instant vs. *DateTime, Periods, Durations,
>     etc.)
>     would apply in any language. They are also all essential concepts when
>     working seriously with date/time even though the distinctions may not
>     appear so at first.
>
>     (I should mention that the lead on the JSR-310 spec was also the
>     author
>     of JodaTime which gets much deserved credit by Java developers for
>     bringing date/time manipulation on the JVM out of the dark ages of
>     java.util.Date. JSR-310 is a slightly reworked/simplified version of
>     that API, so it's a sort of "what are the essentials?" version of
>     JodaTime.)
>
>     Regards,
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/774a7471/attachment.html>

From aaron.dandy at live.com  Fri Sep 13 12:51:29 2013
From: aaron.dandy at live.com (Aaron Dandy)
Date: Fri, 13 Sep 2013 13:51:29 -0600
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>,
	<l0u5v8$q0n$1@ger.gmane.org>,
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
Message-ID: <BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>

I remember reading this article: http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a while back and really appreciating date time & time zone libraries. Also after reading news of the leap second triggering a bug on a bunch of systems I now question all assumptions I make about our representations of time. I can no longer say that a minute is 60 seconds long with a straight face. Next up I guess we programmers have a year 2038 problem to deal with too. This library will be a big deal to write but there thankfully there should be a lot of existing knowledge to learn from.

Date: Fri, 13 Sep 2013 15:10:21 -0400
From: luis at debethencourt.com
To: spam at scientician.net
CC: rust-dev at mozilla.org
Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?

Hello Bardur,
Thank you so much for the reference resource of JSR-310 and its design docs.I looked over it briefly and it is indeed very valuable.
It was listed in the wiki page, but the link was to the former home of it.
I have updated it.
Since nobody has claimed this module, I will start working on this module tomorrow Saturday.Is that OK?
Please, please, I would love more comments and ideas. Will start asking for reviews once I have some code to show.

Thanks,Luis




On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net> wrote:

On 2013-09-12 22:12, Luis de Bethencourt wrote:

> Hello everyone,

>

> I'm interested in helping with some module development. A good way to learn

> Rust by using it and help Rust at the same time.

>

> Of the wanted modules in this page:

> https://github.com/mozilla/rust/wiki/Libs

>



I see that this page does have a link to design docs for JSR-310 which

is probably a good bet as to a usable DateTime API design (for Java at

least). I just thought I'd mention that the documentation for the

"nearly final" (i.e. barring serious bugs) API has been released at:



   http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html



Even if this is for Java, the design decisions about how the conepts of

date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)

would apply in any language. They are also all essential concepts when

working seriously with date/time even though the distinctions may not

appear so at first.



(I should mention that the lead on the JSR-310 spec was also the author

of JodaTime which gets much deserved credit by Java developers for

bringing date/time manipulation on the JVM out of the dark ages of

java.util.Date. JSR-310 is a slightly reworked/simplified version of

that API, so it's a sort of "what are the essentials?" version of JodaTime.)



Regards,





_______________________________________________

Rust-dev mailing list

Rust-dev at mozilla.org

https://mail.mozilla.org/listinfo/rust-dev




_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/e3a69200/attachment-0001.html>

From dteller at mozilla.com  Fri Sep 13 13:05:26 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Fri, 13 Sep 2013 22:05:26 +0200
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <52336A47.8040605@gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<52336A47.8040605@gmail.com>
Message-ID: <52337006.2060600@mozilla.com>

I believe that it would be a good idea to ensure that the Rust datetime
library is a superset of the JS Date object and that it passes a port of
the EcmaScript tests.

Cheers,
 David

On 9/13/13 9:40 PM, Gareth Smith wrote:
> I think its great that you are going to be working on this. A
> comprehensive datetime library is very important. That said I have not
> got any particular ideas or comments.
> 
> I have not used Joda time/JSR-310 but the docs look promising and lots
> of people seem to recommend it.
> 
> Cheers
> Gareth


-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From thadguidry at gmail.com  Fri Sep 13 13:08:44 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Fri, 13 Sep 2013 15:08:44 -0500
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
Message-ID: <CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>

One idea and use case for Paleontologists and Geologists coming over to
Rust in droves... :-)

Generically, just be able to handle simple Geologic addition and
subtraction against an Epoch itself (reference date)
http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
abbreviations.

And additionally, store, understand, and output them:

B.Y.B.P = Billion Years Before Present
M.Y.B.P = Million Years Before Present




On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com> wrote:

> I remember reading this article:
> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
> while back and really appreciating date time & time zone libraries. Also
> after reading news of the leap second triggering a bug on a bunch of
> systems I now question all assumptions I make about our representations of
> time. I can no longer say that a minute is 60 seconds long with a straight
> face. Next up I guess we programmers have a year 2038 problem to deal with
> too. This library will be a big deal to write but there thankfully there
> should be a lot of existing knowledge to learn from.
>
> ------------------------------
> Date: Fri, 13 Sep 2013 15:10:21 -0400
> From: luis at debethencourt.com
> To: spam at scientician.net
> CC: rust-dev at mozilla.org
> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>
>
> Hello Bardur,
>
> Thank you so much for the reference resource of JSR-310 and its design
> docs.
> I looked over it briefly and it is indeed very valuable.
>
> It was listed in the wiki page, but the link was to the former home of it.
> I have updated it.
>
> Since nobody has claimed this module, I will start working on this module
> tomorrow Saturday.
> Is that OK?
>
> Please, please, I would love more comments and ideas. Will start asking
> for reviews once I have some code to show.
>
> Thanks,
> Luis
>
>
>
>
>
> On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net> wrote:
>
> On 2013-09-12 22:12, Luis de Bethencourt wrote:
> > Hello everyone,
> >
> > I'm interested in helping with some module development. A good way to
> learn
> > Rust by using it and help Rust at the same time.
> >
> > Of the wanted modules in this page:
> > https://github.com/mozilla/rust/wiki/Libs
> >
>
> I see that this page does have a link to design docs for JSR-310 which
> is probably a good bet as to a usable DateTime API design (for Java at
> least). I just thought I'd mention that the documentation for the
> "nearly final" (i.e. barring serious bugs) API has been released at:
>
>    http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html
>
> Even if this is for Java, the design decisions about how the conepts of
> date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)
> would apply in any language. They are also all essential concepts when
> working seriously with date/time even though the distinctions may not
> appear so at first.
>
> (I should mention that the lead on the JSR-310 spec was also the author
> of JodaTime which gets much deserved credit by Java developers for
> bringing date/time manipulation on the JVM out of the dark ages of
> java.util.Date. JSR-310 is a slightly reworked/simplified version of
> that API, so it's a sort of "what are the essentials?" version of
> JodaTime.)
>
> Regards,
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________ Rust-dev mailing list
> Rust-dev at mozilla.org https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/9306e5fb/attachment.html>

From corey at octayn.net  Fri Sep 13 13:12:07 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 13 Sep 2013 16:12:07 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
Message-ID: <CA++BO6TiU=hsD2_uHspibd+xoMBLr0DNa2TibupVf7Dj9rF1+w@mail.gmail.com>

On Fri, Sep 13, 2013 at 3:10 PM, Luis de Bethencourt
<luis at debethencourt.com> wrote:
> Please, please, I would love more comments and ideas. Will start asking for
> reviews once I have some code to show.
>

Joda-Time looks quite nice. My only desire from a datetime lib is
"easy to use correctly".

From thadguidry at gmail.com  Fri Sep 13 13:20:25 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Fri, 13 Sep 2013 15:20:25 -0500
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
Message-ID: <CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>

Additionally,

Be able to convert "bya" to "mya" ?  http://en.wikipedia.org/wiki/Bya

The short scale is now commonly used, btw... but also need to deal with
this for conversions:

http://en.wikipedia.org/wiki/Long_and_short_scales

There should be a preference boolean for conversion output for short or
long scale... especially concerning above a thousand million.

That's enough to get you going with some wild ideas that Jodatime does not
handle.



On Fri, Sep 13, 2013 at 3:08 PM, Thad Guidry <thadguidry at gmail.com> wrote:

> One idea and use case for Paleontologists and Geologists coming over to
> Rust in droves... :-)
>
> Generically, just be able to handle simple Geologic addition and
> subtraction against an Epoch itself (reference date)
> http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
> abbreviations.
>
> And additionally, store, understand, and output them:
>
> B.Y.B.P = Billion Years Before Present
> M.Y.B.P = Million Years Before Present
>
>
>
>
> On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com> wrote:
>
>> I remember reading this article:
>> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
>> while back and really appreciating date time & time zone libraries. Also
>> after reading news of the leap second triggering a bug on a bunch of
>> systems I now question all assumptions I make about our representations of
>> time. I can no longer say that a minute is 60 seconds long with a straight
>> face. Next up I guess we programmers have a year 2038 problem to deal with
>> too. This library will be a big deal to write but there thankfully there
>> should be a lot of existing knowledge to learn from.
>>
>> ------------------------------
>> Date: Fri, 13 Sep 2013 15:10:21 -0400
>> From: luis at debethencourt.com
>> To: spam at scientician.net
>> CC: rust-dev at mozilla.org
>> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>>
>>
>> Hello Bardur,
>>
>> Thank you so much for the reference resource of JSR-310 and its design
>> docs.
>> I looked over it briefly and it is indeed very valuable.
>>
>> It was listed in the wiki page, but the link was to the former home of it.
>> I have updated it.
>>
>> Since nobody has claimed this module, I will start working on this module
>> tomorrow Saturday.
>> Is that OK?
>>
>> Please, please, I would love more comments and ideas. Will start asking
>> for reviews once I have some code to show.
>>
>> Thanks,
>> Luis
>>
>>
>>
>>
>>
>> On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net>wrote:
>>
>> On 2013-09-12 22:12, Luis de Bethencourt wrote:
>> > Hello everyone,
>> >
>> > I'm interested in helping with some module development. A good way to
>> learn
>> > Rust by using it and help Rust at the same time.
>> >
>> > Of the wanted modules in this page:
>> > https://github.com/mozilla/rust/wiki/Libs
>> >
>>
>> I see that this page does have a link to design docs for JSR-310 which
>> is probably a good bet as to a usable DateTime API design (for Java at
>> least). I just thought I'd mention that the documentation for the
>> "nearly final" (i.e. barring serious bugs) API has been released at:
>>
>>
>> http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html
>>
>> Even if this is for Java, the design decisions about how the conepts of
>> date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)
>> would apply in any language. They are also all essential concepts when
>> working seriously with date/time even though the distinctions may not
>> appear so at first.
>>
>> (I should mention that the lead on the JSR-310 spec was also the author
>> of JodaTime which gets much deserved credit by Java developers for
>> bringing date/time manipulation on the JVM out of the dark ages of
>> java.util.Date. JSR-310 is a slightly reworked/simplified version of
>> that API, so it's a sort of "what are the essentials?" version of
>> JodaTime.)
>>
>> Regards,
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________ Rust-dev mailing list
>> Rust-dev at mozilla.org https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>



-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/05af6a0f/attachment-0001.html>

From luis at debethencourt.com  Fri Sep 13 13:31:22 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Fri, 13 Sep 2013 16:31:22 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
Message-ID: <CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>

Cool!

Great and awesome feedback. The summary is that Joda-Time is what we should
aspire to have.

My goal is to first cover the "most common use cases", and as Corey says,
"easy to use correctly".

After that I can start considering the corner cases like bya and mya. Which
sound very fun and interesting, but not high priority.
Hopefully by then I won't be too consumed by the question of what is Time.

Thanks, will keep you guys updated,
Luis



On 13 September 2013 16:20, Thad Guidry <thadguidry at gmail.com> wrote:

> Additionally,
>
> Be able to convert "bya" to "mya" ?  http://en.wikipedia.org/wiki/Bya
>
> The short scale is now commonly used, btw... but also need to deal with
> this for conversions:
>
> http://en.wikipedia.org/wiki/Long_and_short_scales
>
> There should be a preference boolean for conversion output for short or
> long scale... especially concerning above a thousand million.
>
> That's enough to get you going with some wild ideas that Jodatime does not
> handle.
>
>
>
> On Fri, Sep 13, 2013 at 3:08 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>
>> One idea and use case for Paleontologists and Geologists coming over to
>> Rust in droves... :-)
>>
>> Generically, just be able to handle simple Geologic addition and
>> subtraction against an Epoch itself (reference date)
>> http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
>> abbreviations.
>>
>> And additionally, store, understand, and output them:
>>
>> B.Y.B.P = Billion Years Before Present
>> M.Y.B.P = Million Years Before Present
>>
>>
>>
>>
>> On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com>wrote:
>>
>>> I remember reading this article:
>>> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
>>> while back and really appreciating date time & time zone libraries. Also
>>> after reading news of the leap second triggering a bug on a bunch of
>>> systems I now question all assumptions I make about our representations of
>>> time. I can no longer say that a minute is 60 seconds long with a straight
>>> face. Next up I guess we programmers have a year 2038 problem to deal with
>>> too. This library will be a big deal to write but there thankfully there
>>> should be a lot of existing knowledge to learn from.
>>>
>>> ------------------------------
>>> Date: Fri, 13 Sep 2013 15:10:21 -0400
>>> From: luis at debethencourt.com
>>> To: spam at scientician.net
>>> CC: rust-dev at mozilla.org
>>> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>>>
>>>
>>> Hello Bardur,
>>>
>>> Thank you so much for the reference resource of JSR-310 and its design
>>> docs.
>>> I looked over it briefly and it is indeed very valuable.
>>>
>>> It was listed in the wiki page, but the link was to the former home of
>>> it.
>>> I have updated it.
>>>
>>> Since nobody has claimed this module, I will start working on this
>>> module tomorrow Saturday.
>>> Is that OK?
>>>
>>> Please, please, I would love more comments and ideas. Will start asking
>>> for reviews once I have some code to show.
>>>
>>> Thanks,
>>> Luis
>>>
>>>
>>>
>>>
>>>
>>> On 13 September 2013 00:57, Bardur Arantsson <spam at scientician.net>wrote:
>>>
>>> On 2013-09-12 22:12, Luis de Bethencourt wrote:
>>> > Hello everyone,
>>> >
>>> > I'm interested in helping with some module development. A good way to
>>> learn
>>> > Rust by using it and help Rust at the same time.
>>> >
>>> > Of the wanted modules in this page:
>>> > https://github.com/mozilla/rust/wiki/Libs
>>> >
>>>
>>> I see that this page does have a link to design docs for JSR-310 which
>>> is probably a good bet as to a usable DateTime API design (for Java at
>>> least). I just thought I'd mention that the documentation for the
>>> "nearly final" (i.e. barring serious bugs) API has been released at:
>>>
>>>
>>> http://download.java.net/jdk8/docs/technotes/guides/datetime/index.html
>>>
>>> Even if this is for Java, the design decisions about how the conepts of
>>> date/time are modeled (Instant vs. *DateTime, Periods, Durations, etc.)
>>> would apply in any language. They are also all essential concepts when
>>> working seriously with date/time even though the distinctions may not
>>> appear so at first.
>>>
>>> (I should mention that the lead on the JSR-310 spec was also the author
>>> of JodaTime which gets much deserved credit by Java developers for
>>> bringing date/time manipulation on the JVM out of the dark ages of
>>> java.util.Date. JSR-310 is a slightly reworked/simplified version of
>>> that API, so it's a sort of "what are the essentials?" version of
>>> JodaTime.)
>>>
>>> Regards,
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________ Rust-dev mailing list
>>> Rust-dev at mozilla.org https://mail.mozilla.org/listinfo/rust-dev
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>>
>> --
>> -Thad
>> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>
>
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/ec3e673e/attachment.html>

From flaper87 at gmail.com  Fri Sep 13 14:13:28 2013
From: flaper87 at gmail.com (Flaper87)
Date: Fri, 13 Sep 2013 23:13:28 +0200
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
	<CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
Message-ID: <CAMOT3C1UQYQa8CsvqW9W3_8+7wYEoTvGoMbjyJPiENAjOtDJkw@mail.gmail.com>

2013/9/13 Luis de Bethencourt <luis at debethencourt.com>

> Cool!
>
> Great and awesome feedback. The summary is that Joda-Time is what we
> should aspire to have.
>
> My goal is to first cover the "most common use cases", and as Corey says,
> "easy to use correctly".
>
> After that I can start considering the corner cases like bya and mya.
> Which sound very fun and interesting, but not high priority.
> Hopefully by then I won't be too consumed by the question of what is Time.
>


Another thing that I'd like to see there is a good handling of TZs. Many
datetime libraries got that wrong. Here's a blog post Armin wrote that may
be helpful.

http://lucumr.pocoo.org/2011/7/15/eppur-si-muove/

Thanks for taking care of this.
FF

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/29a28d24/attachment.html>

From corey at octayn.net  Fri Sep 13 14:21:13 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 13 Sep 2013 17:21:13 -0400
Subject: [rust-dev] Windows Help for rustdoc_ng
Message-ID: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>

Hi all,

I've hit a wall with rustdoc_ng. It fails to build on Windows with
http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1435/steps/compile/logs/stdio,
the error being:

note: i686-pc-mingw32\stage1\bin\rustc\i686-pc-mingw32\bin\lib.o:fake:(.text+0x68373):
undefined reference to `SetLastError'

I find this very strange that it manifests in rustdoc_ng. The only
reason I could see it failing is that it would need to link to
libstd's dependencies (kernel32 in this case).

Does anyone know what's going on here?

From luis at debethencourt.com  Fri Sep 13 14:27:15 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Fri, 13 Sep 2013 17:27:15 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAMOT3C1UQYQa8CsvqW9W3_8+7wYEoTvGoMbjyJPiENAjOtDJkw@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
	<CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
	<CAMOT3C1UQYQa8CsvqW9W3_8+7wYEoTvGoMbjyJPiENAjOtDJkw@mail.gmail.com>
Message-ID: <CAPA4HGXHS5=TCinRqYrBrQVHrLA8_LRKZ1-j=h1ANE4+aN+qjQ@mail.gmail.com>

That is a really good article and a very valid point.

Writing down all the feedback for future reference in my development.

Thanks FF,
Luis


On 13 September 2013 17:13, Flaper87 <flaper87 at gmail.com> wrote:

>
>
>
> 2013/9/13 Luis de Bethencourt <luis at debethencourt.com>
>
>> Cool!
>>
>> Great and awesome feedback. The summary is that Joda-Time is what we
>> should aspire to have.
>>
>> My goal is to first cover the "most common use cases", and as Corey says,
>> "easy to use correctly".
>>
>> After that I can start considering the corner cases like bya and mya.
>> Which sound very fun and interesting, but not high priority.
>> Hopefully by then I won't be too consumed by the question of what is Time.
>>
>
>
> Another thing that I'd like to see there is a good handling of TZs. Many
> datetime libraries got that wrong. Here's a blog post Armin wrote that may
> be helpful.
>
> http://lucumr.pocoo.org/2011/7/15/eppur-si-muove/
>
> Thanks for taking care of this.
> FF
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/4ae56022/attachment-0001.html>

From simon.sapin at exyr.org  Fri Sep 13 15:03:43 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 14 Sep 2013 00:03:43 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <522F3EF7.1000507@exyr.org>
References: <522F3EF7.1000507@exyr.org>
Message-ID: <52338BBF.4000803@exyr.org>

Here is an updated proposal, based on email and IRC feedback. The 
changes are:

* Fix .feed() and .flush() to have the self parameter they need.

* Remove the iterator stuff. I don?t find it super useful, and it?s easy 
enough to build on top of the "push" API. KISS.

* Duplicate the "one shot" convenience API in Decoder so that it?s 
usable without involving trait objects and dynamic dispatch.

* Make the output generic in the low-level API by having StringWriter 
instead of ~str

* Add encoding_from_label()

* De-emphasize the Encoding trait by moving it to the end. It is only 
useful together with encoding_from_label() and other dynamic-dispatch 
scenarios. If the encoding to use is known at compile time, one can use 
eg. UTF8Decoder directly.


Again, this is only decoders. Encoders are basically the same, with [u8] 
and str swapped. Maybe the output could just be std::rt::io::Writer.


/// Each implementation of Encoding has one corresponding implementation
/// of Decoder (and one of Encoder).
///
/// A new Decoder instance should be used for every input.
/// A Decoder instance should be discarded
/// after DecodeError was returned.
trait Decoder {
     /// Simple, "one shot" API.
     /// Decode a single byte string that is entirely in memory.
     /// May raise the decoding_error condition.
     fn decode(input: &[u8]) -> Result<~str, DecodeError> {
         // Implementation left out.
         // This is a default method, but not meant to be overridden.
     }

     fn new() -> Self;

     /// Call this repeatedly with a chunck of input bytes.
     /// As much as possible of the decoded text is appended to output.
     /// May raise the decoding_error condition.
     fn feed<W: StringWriter>(&self, input: &[u8], output: &mut W)
                           -> Option<DecodeError>;

     /// Call this to indicate the end of the input.
     /// The Decoder instance should be discarded afterwards.
     /// Some encodings may append some final output at this point.
     /// May raise the decoding_error condition.
     fn flush<W: StringWriter>(&self, output: &mut W)
                            -> Option<DecodeError>;
}

/// Takes the invalid byte sequence.
/// Return a replacement string, or None to abort with a DecodeError.
condition! {
     pub decoding_error : ~[u8] -> Option<~str>;
}

/// Functions to be used with decoding_error::cond.trap
mod decoding_error_handlers {
     fn fatal(_: ~[u8]) -> Option<~str> { None }
     fn replacement(_: ~[u8]) -> Option<~str> { Some(~"\uFFFD") }
}

struct DecodeError {
     input_byte_offset: uint,
     invalid_byte_sequence: ~[u8],
}

trait StringWriter {
     fn write_char(&mut self, c: char);
     fn write_str(&mut self, s: &str);
}


/// Only supports the set of labels defined in the spec
/// http://encoding.spec.whatwg.org/#encodings
/// Such a label can come eg. from an HTTP header:
/// Content-Type: text/plain; charset=<label>
fn encoding_from_label(label: &str) -> &'static Encoding {
     // Implementation left out
}

/// Types implementing this trait are "algorithms"
/// such as UTF8, UTF-16, SingleByteEncoding, etc.
/// Values of these types are "encodings" as defined in the WHATWG spec:
/// UTF-8, UTF-16-LE, Windows-1252, etc.
trait Encoding {
     /// Could become an associated type with a ::new() constructor
     /// when the language supports that.
     fn new_decoder(&self) -> ~Decoder;

     /// Simple, "one shot" API.
     /// Decode a single byte string that is entirely in memory.
     /// May raise the decoding_error condition.
     fn decode(&self, input: &[u8]) -> Result<~str, DecodeError> {
         // Implementation (using a Decoder) left out.
         // This is a default method, but not meant to be overridden.
     }
}


What do you think?
-- 
Simon Sapin

From kevin at sb.org  Fri Sep 13 15:29:06 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 13 Sep 2013 15:29:06 -0700
Subject: [rust-dev] Windows Help for rustdoc_ng
In-Reply-To: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>
References: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>
Message-ID: <E170437D-CD09-4DF0-9B59-EFF5010ECA17@sb.org>

This looks rather similar to the error I was getting with PR #8203, which was a set of undefined references under Windows.

http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1212/steps/compile/logs/stdio

I don't know if it's actually related though.

-Kevin

On Sep 13, 2013, at 2:21 PM, Corey Richardson <corey at octayn.net> wrote:

> Hi all,
> 
> I've hit a wall with rustdoc_ng. It fails to build on Windows with
> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1435/steps/compile/logs/stdio,
> the error being:
> 
> note: i686-pc-mingw32\stage1\bin\rustc\i686-pc-mingw32\bin\lib.o:fake:(.text+0x68373):
> undefined reference to `SetLastError'
> 
> I find this very strange that it manifests in rustdoc_ng. The only
> reason I could see it failing is that it would need to link to
> libstd's dependencies (kernel32 in this case).
> 
> Does anyone know what's going on here?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From jfager at gmail.com  Fri Sep 13 16:21:25 2013
From: jfager at gmail.com (Jason Fager)
Date: Fri, 13 Sep 2013 19:21:25 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
	<CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
Message-ID: <CAFEbTaUNcs_7CWas-D4nmzkkZK4mdGkfM6mvqi8fA8ukM66bxQ@mail.gmail.com>

Joda-Time and JSR-310 are similar APIs but different implementations. It's
the same guy behind both, here he is explaining why he wanted 310 instead
of just standardizing Joda:

http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html?m=1


On Friday, September 13, 2013, Luis de Bethencourt wrote:

> Cool!
>
> Great and awesome feedback. The summary is that Joda-Time is what we
> should aspire to have.
>
> My goal is to first cover the "most common use cases", and as Corey says,
> "easy to use correctly".
>
> After that I can start considering the corner cases like bya and mya.
> Which sound very fun and interesting, but not high priority.
> Hopefully by then I won't be too consumed by the question of what is Time.
>
> Thanks, will keep you guys updated,
> Luis
>
>
>
> On 13 September 2013 16:20, Thad Guidry <thadguidry at gmail.com> wrote:
>
> Additionally,
>
> Be able to convert "bya" to "mya" ?  http://en.wikipedia.org/wiki/Bya
>
> The short scale is now commonly used, btw... but also need to deal with
> this for conversions:
>
> http://en.wikipedia.org/wiki/Long_and_short_scales
>
> There should be a preference boolean for conversion output for short or
> long scale... especially concerning above a thousand million.
>
> That's enough to get you going with some wild ideas that Jodatime does not
> handle.
>
>
>
> On Fri, Sep 13, 2013 at 3:08 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>
> One idea and use case for Paleontologists and Geologists coming over to
> Rust in droves... :-)
>
> Generically, just be able to handle simple Geologic addition and
> subtraction against an Epoch itself (reference date)
> http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
> abbreviations.
>
> And additionally, store, understand, and output them:
>
> B.Y.B.P = Billion Years Before Present
> M.Y.B.P = Million Years Before Present
>
>
>
>
> On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com> wrote:
>
> I remember reading this article:
> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
> while back and really appreciating date time & time zone libraries. Also
> after reading news of the leap second triggering a bug on a bunch of
> systems I now question all assumptions I make about our representations of
> time. I can no longer say that a minute is 60 seconds long with a straight
> face. Next up I guess we programmers have a year 2038 problem to deal with
> too. This library will be a big deal to write but there thankfully there
> should be a lot of existing knowledge to learn from.
>
> ------------------------------
> Date: Fri, 13 Sep 2013 15:10:21 -0400
> From: luis at debethencourt.com
> To: spam at scientician.net
> CC: rust-dev at mozilla.org
> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>
>
> Hello Bardur,
>
> Thank you so much for the reference resource of JSR-310 and its design
> docs.
> I looked over it briefly and it is indeed very valuable.
>
> It was listed in the wiki page, but the link was to the former home of it.
> I have updated it.
>
> Since nobody has claimed this module, I will start working on this module
> tomorrow Saturday.
> Is that OK?
>
> Please, please, I would love more comments and ideas. Will start asking
> for reviews once I have some code to show.
>
> Thanks,
> Luis
>
>
>
>
>
> On 13 September 2013 00:57, Bardur Arantsson <spam at scientici
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/125cee90/attachment.html>

From vadimcn at gmail.com  Fri Sep 13 17:17:12 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 13 Sep 2013 17:17:12 -0700
Subject: [rust-dev] Windows Help for rustdoc_ng
In-Reply-To: <E170437D-CD09-4DF0-9B59-EFF5010ECA17@sb.org>
References: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>
	<E170437D-CD09-4DF0-9B59-EFF5010ECA17@sb.org>
Message-ID: <CADecdi+4wg_KznHPh-BYSBsOAafT+Ah9FHNwcPwh--OaJf6rEQ@mail.gmail.com>

Could this be due to inlining?   E.g. a function from libstd that calls an
external function gets inlined into another crate (rustc in this case), and
now rustc itself needs to be linked with kernel32...?


On Fri, Sep 13, 2013 at 3:29 PM, Kevin Ballard <kevin at sb.org> wrote:

> This looks rather similar to the error I was getting with PR #8203, which
> was a set of undefined references under Windows.
>
>
> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1212/steps/compile/logs/stdio
>
> I don't know if it's actually related though.
>
> -Kevin
>
> On Sep 13, 2013, at 2:21 PM, Corey Richardson <corey at octayn.net> wrote:
>
> > Hi all,
> >
> > I've hit a wall with rustdoc_ng. It fails to build on Windows with
> >
> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1435/steps/compile/logs/stdio
> ,
> > the error being:
> >
> > note:
> i686-pc-mingw32\stage1\bin\rustc\i686-pc-mingw32\bin\lib.o:fake:(.text+0x68373):
> > undefined reference to `SetLastError'
> >
> > I find this very strange that it manifests in rustdoc_ng. The only
> > reason I could see it failing is that it would need to link to
> > libstd's dependencies (kernel32 in this case).
> >
> > Does anyone know what's going on here?
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/0f1a6fe2/attachment.html>

From luis at debethencourt.com  Fri Sep 13 18:09:46 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Fri, 13 Sep 2013 21:09:46 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAFEbTaUNcs_7CWas-D4nmzkkZK4mdGkfM6mvqi8fA8ukM66bxQ@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
	<CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
	<CAFEbTaUNcs_7CWas-D4nmzkkZK4mdGkfM6mvqi8fA8ukM66bxQ@mail.gmail.com>
Message-ID: <CAPA4HGVM4XN0ukyBVpKeWwhGzaaM-rZzhvUjXFYoOGHcQBXBAQ@mail.gmail.com>

That is a very interesting read.

We certainly should learn from the experiences of other languages. This
being a good example.
I will be revisiting the linked documents listed in this thread repeatedly.

Fortunately the issue he mentions about NULLs creating random bugs, is
taken care of by Rust's safety.

Thanks,
Luis


On 13 September 2013 19:21, Jason Fager <jfager at gmail.com> wrote:

> Joda-Time and JSR-310 are similar APIs but different implementations. It's
> the same guy behind both, here he is explaining why he wanted 310 instead
> of just standardizing Joda:
>
> http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html?m=1
>
>
> On Friday, September 13, 2013, Luis de Bethencourt wrote:
>
>> Cool!
>>
>> Great and awesome feedback. The summary is that Joda-Time is what we
>> should aspire to have.
>>
>> My goal is to first cover the "most common use cases", and as Corey says,
>> "easy to use correctly".
>>
>> After that I can start considering the corner cases like bya and mya.
>> Which sound very fun and interesting, but not high priority.
>> Hopefully by then I won't be too consumed by the question of what is Time.
>>
>> Thanks, will keep you guys updated,
>> Luis
>>
>>
>>
>> On 13 September 2013 16:20, Thad Guidry <thadguidry at gmail.com> wrote:
>>
>> Additionally,
>>
>> Be able to convert "bya" to "mya" ?  http://en.wikipedia.org/wiki/Bya
>>
>> The short scale is now commonly used, btw... but also need to deal with
>> this for conversions:
>>
>> http://en.wikipedia.org/wiki/Long_and_short_scales
>>
>> There should be a preference boolean for conversion output for short or
>> long scale... especially concerning above a thousand million.
>>
>> That's enough to get you going with some wild ideas that Jodatime does
>> not handle.
>>
>>
>>
>> On Fri, Sep 13, 2013 at 3:08 PM, Thad Guidry <thadguidry at gmail.com>wrote:
>>
>> One idea and use case for Paleontologists and Geologists coming over to
>> Rust in droves... :-)
>>
>> Generically, just be able to handle simple Geologic addition and
>> subtraction against an Epoch itself (reference date)
>> http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
>> abbreviations.
>>
>> And additionally, store, understand, and output them:
>>
>> B.Y.B.P = Billion Years Before Present
>> M.Y.B.P = Million Years Before Present
>>
>>
>>
>>
>> On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com>wrote:
>>
>> I remember reading this article:
>> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
>> while back and really appreciating date time & time zone libraries. Also
>> after reading news of the leap second triggering a bug on a bunch of
>> systems I now question all assumptions I make about our representations of
>> time. I can no longer say that a minute is 60 seconds long with a straight
>> face. Next up I guess we programmers have a year 2038 problem to deal with
>> too. This library will be a big deal to write but there thankfully there
>> should be a lot of existing knowledge to learn from.
>>
>> ------------------------------
>> Date: Fri, 13 Sep 2013 15:10:21 -0400
>> From: luis at debethencourt.com
>> To: spam at scientician.net
>> CC: rust-dev at mozilla.org
>> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>>
>>
>> Hello Bardur,
>>
>> Thank you so much for the reference resource of JSR-310 and its design
>> docs.
>> I looked over it briefly and it is indeed very valuable.
>>
>> It was listed in the wiki page, but the link was to the former home of it.
>> I have updated it.
>>
>> Since nobody has claimed this module, I will start working on this module
>> tomorrow Saturday.
>> Is that OK?
>>
>> Please, please, I would love more comments and ideas. Will start asking
>> for reviews once I have some code to show.
>>
>> Thanks,
>> Luis
>>
>>
>>
>>
>>
>> On 13 September 2013 00:57, Bardur Arantsson <spam at scientici
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/c3df6084/attachment-0001.html>

From lindsey at composition.al  Fri Sep 13 20:06:05 2013
From: lindsey at composition.al (Lindsey Kuper)
Date: Fri, 13 Sep 2013 23:06:05 -0400
Subject: [rust-dev] libsyntax default methods refactor -- anyone know
 what went wrong here?
In-Reply-To: <52319178.2010401@mozilla.com>
References: <CALnXJiomMGWJviz=Xi6Bsmh6gd3Dgu5WiBu3b=f51-ivgtNxeQ@mail.gmail.com>
	<52319178.2010401@mozilla.com>
Message-ID: <CALnXJirLCVBTbOQYz-xqmmOcrCuJQLYsk44p8Fnfxg_V72b_Uw@mail.gmail.com>

On Thu, Sep 12, 2013 at 6:03 AM, Felix S. Klock II <pnkfelix at mozilla.com> wrote:
> Lindsey (cc'ing rust-dev)-
>
> Its not due to your changes.  These are problems that are in master that for
> some reasons bors has not caught:
>
> Issue #9127: debug no-optimize make check yields three failures
> https://github.com/mozilla/rust/issues/9127
>
> Cheers,
> -Felix

Yep, turns out I get the same failures when I build a clean master.  I
TRUSTED YOU, BORS!  *shakes fist*

Thanks for looking into this.

Lindsey

From klutzytheklutzy at gmail.com  Fri Sep 13 21:16:55 2013
From: klutzytheklutzy at gmail.com (klutzy k)
Date: Sat, 14 Sep 2013 13:16:55 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
Message-ID: <CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>

Mingw added new winapi at mswsock.h:

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
#endif

but they forgot to add definition of WSAPOLLFD.

Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
but seems like it's not on mainstream.

Anyway, we (including libuv) don't use the api. Removing the codeblock helps us.

On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
> broke mswsock.h (though the file didn't change).
>
>
>
> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>>
>> Doesn't work...
>>
>> Errors regarding libuv and mswsock...
>>
>> http://pastebin.mozilla.org/3038909
>>
>>
>>
>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>>>
>>> Hi Brian,
>>>
>>> Actually, I would argue that these changes *should* be made before 0.8
>>> release in order to smoothen the path of people who will install 0.8 to try
>>> it out.
>>>
>>> Regarding the work to be done, as far as I know all you need is:
>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>>> 2. "mingw-get update"
>>> 3. "mingw-get upgrade"
>>> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>>> 5. "make clean"
>>> 6. "make check", which will fail at building stage1 std crate because
>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>>> 8. "make check" again, which should succeed this time
>>>
>>> Can somebody please verify that this works?
>>>
>>>
>>> Re mingw-w64: sort of works, however its' phtreads implementation seems
>>> to be buggy.   Also see this thread.  I don't think we'll should migrate to
>>> it just yet.
>>>
>>> Vadim
>>>
>>>
>>>
>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
>>> wrote:
>>>>
>>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>>>
>>>> Yeah, there should not be a reason anymore, if I am correct, to not have
>>>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>>>> also , and if it works, then we can close out (#8598).  (I also would like
>>>> to get rid of the 4.5 downgrade needed).... but that does need more testing
>>>> from the core Rust team and others.
>>>>
>>>> It's something that Brian has been counting on me to help make happen,
>>>> and Alex is also contributing to some of that effort by fixing various LLVM
>>>> build issues that affect Windows Rust users as you mention in (#8598).
>>>>
>>>> Agreed, if a new stage0 compiler snapshot can be created, then we should
>>>> be in the clear to also close out #5878.
>>>>
>>>>
>>>>
>>>> Thanks for everybody's amazing contributions to our Windows support. If
>>>> somebody makes the changes necessary to work with a newer toolchain then we
>>>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>>>> in two weeks.
>>>>
>>>> I gather that some folks would like to switch to the mingw-w64 toolchain
>>>> as well. Is that in the cards here?
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>>
>> --
>> -Thad
>> Thad on Freebase.com
>> Thad on LinkedIn
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From m at minhdo.org  Fri Sep 13 21:21:56 2013
From: m at minhdo.org (Minh Do)
Date: Sat, 14 Sep 2013 12:21:56 +0800
Subject: [rust-dev] Working on rusti as final year project
In-Reply-To: <CA+DvKQL7tr09U9dPzBVJGH1Z+AjNAix41eZXWfCpeFNqkNFGcw@mail.gmail.com>
References: <521B85C2.8060804@minhdo.org> <52329FD5.8090107@minhdo.org>
	<CA+DvKQL7tr09U9dPzBVJGH1Z+AjNAix41eZXWfCpeFNqkNFGcw@mail.gmail.com>
Message-ID: <5233E464.9060000@minhdo.org>

On 09/14/2013 02:57 AM, Daniel Micay wrote:
> On Fri, Sep 13, 2013 at 1:17 AM, Minh Do <m at minhdo.org 
> <mailto:m at minhdo.org>> wrote:
>
>     On 08/27/2013 12:43 AM, Minh Do wrote:
>
>         My name is Do Nhat Minh, currently a final year Computer
>         Science student at Nanyang Technological University in
>         Singapore. I have played with Rust and found the experience to
>         be very pleasant. I think Rust make sensible trade-offs and
>         managed to stay small, compared to C++.
>
>         I have been granted permission by my university supervisor to
>         work on rusti as my final year project. I hope with this
>         contribution, Rust will be even stronger a competitor to Go and D.
>
>         This will be my first time working on something this size and
>         this long a duration. I would love to hear your advice or
>         experience implementing rusti.
>
>         Thank you for your time.
>
>         Regards,
>         Minh
>
>     Hi,
>
>     I'm working on figuring out why rusti segfaults. So far, I'm able
>     to extract very little information.
>
>     Attached is a backtrace from rusti using gdb. SIGSEGV is signaled
>     inside jemalloc's tcache_alloc_easy, line 286. Below is the piece
>     code where it fails.
>
>     274    JEMALLOC_ALWAYS_INLINE void *
>     275    tcache_alloc_easy(tcache_bin_t *tbin)
>     276    {
>     277        void *ret;
>     278
>     279        if (tbin->ncached == 0) {
>     280            tbin->low_water = -1;
>     281            return (NULL);
>     282        }
>     283        tbin->ncached--;
>     284        if ((int)tbin->ncached < tbin->low_water)
>     285            tbin->low_water = tbin->ncached;
>     286        ret = tbin->avail[tbin->ncached]; // <- XXX fail here
>     287        return (ret);
>     288    }
>
>     jemalloc is trying to read from tbin->avail at tbin->ncached.
>     tbin->ncached was 1227353920 (or 0x4927ef40) which is too big in
>     my opinion. All the other values in tbin were unusually high or
>     low, which leads me to suspect tbin is uninitialized or there is a
>     memory overrun.
>
>     I run valgrind on rusti in the hope of catching memory overruns,
>     but it does not help much. Valgrind only prints some warning about
>     conditional jumps depending on uninitialized variables and then
>     reports an invalid read with the identical backtrace. However, at
>     the top, valgrind prints the below text, which I find quite
>     interesting.
>
>     ==31583== Syscall param read(buf) points to unaddressable byte(s)
>     ==31583==    at 0x40170C7: read (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x400586C: open_verify (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x4005CA6: open_path (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x4008495: _dl_map_object (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x400C281: openaux (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x400E773: _dl_catch_error (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x400C4E4: _dl_map_object_deps (in
>     /usr/lib/ld-2.18.so <http://ld-2.18.so>)
>     ==31583==    by 0x4002E93: dl_main (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x4015174: _dl_sysdep_start (in
>     /usr/lib/ld-2.18.so <http://ld-2.18.so>)
>     ==31583==    by 0x4004AE5: _dl_start (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==    by 0x4001277: ??? (in /usr/lib/ld-2.18.so
>     <http://ld-2.18.so>)
>     ==31583==  Address 0x7fec7f700 is on thread 1's stack
>
>     I then try linking directly with Rust's libstd (since it's the
>     first thing that's linked with the code being compiled) in rusti's
>     main() before anything is done. Below is the addition.
>
>     diff --git a/src/librusti/rusti.rs <http://rusti.rs>
>     b/src/librusti/rusti.rs <http://rusti.rs>
>     index 8d61a97..2f72cfa 100644
>     --- a/src/librusti/rusti.rs <http://rusti.rs>
>     +++ b/src/librusti/rusti.rs <http://rusti.rs>
>     @@ -84,6 +84,9 @@ use syntax::print::pprust;
>      use program::Program;
>      use utils::*;
>
>     +use rustc::lib::llvm::llvm;
>     +use std::unstable::intrinsics;
>     +
>      mod program;
>      pub mod utils;
>
>     @@ -505,6 +508,17 @@ pub fn main() {
>      pub fn main_args(args: &[~str]) {
>          #[fixed_stack_segment]; #[inline(never)];
>
>     +    unsafe {
>     +        let manager =
>     llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());
>     +        let path =
>     "/path/to/rust/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.8-pre.so
>     <http://libstd-6c65cf4b443341b1-0.8-pre.so>";
>     +        do path.with_c_str |buf_t| {
>     +            if !llvm::LLVMRustLoadCrate(manager, buf_t) {
>     +                debug!(~"Could not link");
>     +            }
>     +            debug!("linked: %s", path);
>     +        }
>     +    }
>     +
>          let input = io::stdin();
>          let out = io::stdout();
>          let mut repl = Repl {
>
>     Rusti now also fails in the scheduler sometimes if it happens to
>     switch threads while LLVMRustLoadCrate is being executed. Below is
>     the backtrace.
>
>     #0  rust_thread_start (ptr=0x7ffff1c1f5e0) at
>     src/rt/sync/rust_thread.cpp:36
>     #1  0x00007ffff548b0a2 in start_thread () from
>     /usr/lib/libpthread.so.0
>     #2  0x00007ffff3217a2d in clone () from /usr/lib/libc.so.6
>
>     The above failure in the scheduler and the curious message by
>     valgrind makes me wonder about the scheduler and the runtime.
>     However, when git grep-ing for rust_thread, I don't see how it is
>     hooked into Rust. Could someone enlighten me on this?
>
>     More importantly, does anyone have any suggestion about my
>     approach or any leads on this?
>
>     Regards,
>     Minh
>
>
> Compile jemalloc with --enable-debug (you can add it to rt.mk 
> <http://rt.mk>) and it will check for things like double-free.
Hi Daniel,

Below is how I added --enable-debug to rt.mk. However, I don't see any 
debug messages printed out. Could you please tell me how I can make 
jemalloc print out debug messages?

diff --git a/mk/rt.mk b/mk/rt.mk
index e31f222..69fc6ce 100644
--- a/mk/rt.mk
+++ b/mk/rt.mk
@@ -220,7 +220,7 @@ endif
  ifeq ($(OSTYPE_$(1)), linux-androideabi)
  $$(JEMALLOC_LIB_$(1)_$(2)):
         cd $$(RT_BUILD_DIR_$(1)_$(2))/jemalloc; 
$(S)src/rt/jemalloc/configure \
-               --disable-experimental --build=$(CFG_BUILD_TRIPLE) 
--host=$(1) --disable-tls \
+               --enable-debug --disable-experimental 
--build=$(CFG_BUILD_TRIPLE) --host=$(1) --disable-tls \
                 EXTRA_CFLAGS="$$(CFG_GCCISH_CFLAGS) 
$$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)" \
                 LDFLAGS="$$(CFG_GCCISH_LINK_FLAGS) 
$$(LIBUV_FLAGS_$$(HOST_$(1)))" \
                 CC="$$(CC_$(1))" \
@@ -230,7 +230,7 @@ $$(JEMALLOC_LIB_$(1)_$(2)):
  else
  $$(JEMALLOC_LIB_$(1)_$(2)):
         cd $$(RT_BUILD_DIR_$(1)_$(2))/jemalloc; 
$(S)src/rt/jemalloc/configure \
-               --disable-experimental --build=$(CFG_BUILD_TRIPLE) 
--host=$(1) \
+               --enable-debug --disable-experimental 
--build=$(CFG_BUILD_TRIPLE) --host=$(1) \
                 EXTRA_CFLAGS="$$(CFG_GCCISH_CFLAGS) 
$$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)" \
                 LDFLAGS="$$(CFG_GCCISH_LINK_FLAGS) 
$$(LIBUV_FLAGS_$$(HOST_$(1)))" \
                 CC="$$(CC_$(1))" \

Regards,
Minh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130914/ab263c08/attachment-0001.html>

From klutzytheklutzy at gmail.com  Fri Sep 13 21:38:04 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Sat, 14 Sep 2013 13:38:04 +0900
Subject: [rust-dev] Windows Help for rustdoc_ng
In-Reply-To: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>
References: <CA++BO6SUp_XgdT1vkbUkzQ1pwsFkAOzoz5_HABBQUmtR+3BLew@mail.gmail.com>
Message-ID: <CADzE6JM9fXtYyj1i7BnbYg9kGphFBGVHePHOzc+qA-QTo8i9qg@mail.gmail.com>

This? https://github.com/mozilla/rust/issues/9055

Windows APIs use stdcall, which implies all apis are decorated as
"_SetLastError at 16", while cdecl APIs are decorated as "_SetLastError".
Our rustc is wrong so it generates llvm IR with wrong calling convention.
And when gcc prints linke error, it removes the first underscore so
you get "SetLastError" undefined. It's kinda confusing :(



On Sat, Sep 14, 2013 at 6:21 AM, Corey Richardson <corey at octayn.net> wrote:
> Hi all,
>
> I've hit a wall with rustdoc_ng. It fails to build on Windows with
> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1435/steps/compile/logs/stdio,
> the error being:
>
> note: i686-pc-mingw32\stage1\bin\rustc\i686-pc-mingw32\bin\lib.o:fake:(.text+0x68373):
> undefined reference to `SetLastError'
>
> I find this very strange that it manifests in rustdoc_ng. The only
> reason I could see it failing is that it would need to link to
> libstd's dependencies (kernel32 in this case).
>
> Does anyone know what's going on here?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From vadimcn at gmail.com  Fri Sep 13 23:21:57 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 13 Sep 2013 23:21:57 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
Message-ID: <465696506198446370@unknownmsgid>

Yes, but we can't check this into Rust repo.  Maybe it can be worked around
by -DWSAPOLLFD somewhere in makefiles...

And just as a heads-up, these seems to be another problem,- with LLVM:
http://sourceforge.net/p/mingw/bugs/2043/

Vadim

On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:

Mingw added new winapi at mswsock.h:

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);

#endif

but they forgot to add definition of WSAPOLLFD.

Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
but seems like it's not on mainstream.

Anyway, we (including libuv) don't use the api. Removing the codeblock
helps us.

On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:

Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow

broke mswsock.h (though the file didn't change).




On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:


Doesn't work...


Errors regarding libuv and mswsock...


http://pastebin.mozilla.org/3038909




On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:


Hi Brian,


Actually, I would argue that these changes *should* be made before 0.8

release in order to smoothen the path of people who will install 0.8 to try

it out.


Regarding the work to be done, as far as I know all you need is:

1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin

2. "mingw-get update"

3. "mingw-get upgrade"

4. run %rust%\configure  (not sure if actually needed, but won't hurt)

5. "make clean"

6. "make check", which will fail at building stage1 std crate because

step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.

7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin

8. "make check" again, which should succeed this time


Can somebody please verify that this works?



Re mingw-w64: sort of works, however its' phtreads implementation seems

to be buggy.   Also see this thread.  I don't think we'll should migrate to

it just yet.


Vadim




On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>

wrote:


On 09/12/2013 12:39 PM, Thad Guidry wrote:


Yeah, there should not be a reason anymore, if I am correct, to not have

GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try

also , and if it works, then we can close out (#8598).  (I also would like

to get rid of the 4.5 downgrade needed).... but that does need more testing

from the core Rust team and others.


It's something that Brian has been counting on me to help make happen,

and Alex is also contributing to some of that effort by fixing various LLVM

build issues that affect Windows Rust users as you mention in (#8598).


Agreed, if a new stage0 compiler snapshot can be created, then we should

be in the clear to also close out #5878.




Thanks for everybody's amazing contributions to our Windows support. If

somebody makes the changes necessary to work with a newer toolchain then we

will upgrade the bots. It's unlikely we can do this before 0.8 though, due

in two weeks.


I gather that some folks would like to switch to the mingw-w64 toolchain

as well. Is that in the cards here?


_______________________________________________

Rust-dev mailing list

Rust-dev at mozilla.org

https://mail.mozilla.org/listinfo/rust-dev




_______________________________________________

Rust-dev mailing list

Rust-dev at mozilla.org

https://mail.mozilla.org/listinfo/rust-dev





--

-Thad

Thad on Freebase.com

Thad on LinkedIn




_______________________________________________

Rust-dev mailing list

Rust-dev at mozilla.org

https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130913/797ede4d/attachment.html>

From klutzytheklutzy at gmail.com  Fri Sep 13 23:25:29 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Sat, 14 Sep 2013 15:25:29 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <465696506198446370@unknownmsgid>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
Message-ID: <CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>

I've solved it some minutes ago :)

<klutzy> at /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
<klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
<klutzy> but there isn't [such #define] in 4.8.1 header.
<klutzy> this causes /include/fenv.h not included when llvm does
#include <fenv.h>

The c++config.h has such lines:
/* Define to 1 if you have the <fenv.h> header file. */
/* #undef _GLIBCXX_HAVE_FENV_H */

I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
works. We can't recommend users to do this hack though.



On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
> Yes, but we can't check this into Rust repo.  Maybe it can be worked around
> by -DWSAPOLLFD somewhere in makefiles...
>
> And just as a heads-up, these seems to be another problem,- with LLVM:
> http://sourceforge.net/p/mingw/bugs/2043/
>
> Vadim
>
> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:
>
> Mingw added new winapi at mswsock.h:
>
> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
>
> #endif
>
> but they forgot to add definition of WSAPOLLFD.
>
> Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
> but seems like it's not on mainstream.
>
> Anyway, we (including libuv) don't use the api. Removing the codeblock helps
> us.
>
> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
>
> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
>
> broke mswsock.h (though the file didn't change).
>
>
>
>
> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>
>
> Doesn't work...
>
>
> Errors regarding libuv and mswsock...
>
>
> http://pastebin.mozilla.org/3038909
>
>
>
>
> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>
>
> Hi Brian,
>
>
> Actually, I would argue that these changes *should* be made before 0.8
>
> release in order to smoothen the path of people who will install 0.8 to try
>
> it out.
>
>
> Regarding the work to be done, as far as I know all you need is:
>
> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>
> 2. "mingw-get update"
>
> 3. "mingw-get upgrade"
>
> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>
> 5. "make clean"
>
> 6. "make check", which will fail at building stage1 std crate because
>
> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>
> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>
> 8. "make check" again, which should succeed this time
>
>
> Can somebody please verify that this works?
>
>
>
> Re mingw-w64: sort of works, however its' phtreads implementation seems
>
> to be buggy.   Also see this thread.  I don't think we'll should migrate to
>
> it just yet.
>
>
> Vadim
>
>
>
>
> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
>
> wrote:
>
>
> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>
>
> Yeah, there should not be a reason anymore, if I am correct, to not have
>
> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>
> also , and if it works, then we can close out (#8598).  (I also would like
>
> to get rid of the 4.5 downgrade needed).... but that does need more testing
>
> from the core Rust team and others.
>
>
> It's something that Brian has been counting on me to help make happen,
>
> and Alex is also contributing to some of that effort by fixing various LLVM
>
> build issues that affect Windows Rust users as you mention in (#8598).
>
>
> Agreed, if a new stage0 compiler snapshot can be created, then we should
>
> be in the clear to also close out #5878.
>
>
>
>
> Thanks for everybody's amazing contributions to our Windows support. If
>
> somebody makes the changes necessary to work with a newer toolchain then we
>
> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>
> in two weeks.
>
>
> I gather that some folks would like to switch to the mingw-w64 toolchain
>
> as well. Is that in the cards here?
>
>
> _______________________________________________
>
> Rust-dev mailing list
>
> Rust-dev at mozilla.org
>
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
>
> Rust-dev mailing list
>
> Rust-dev at mozilla.org
>
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
>
> --
>
> -Thad
>
> Thad on Freebase.com
>
> Thad on LinkedIn
>
>
>
>
> _______________________________________________
>
> Rust-dev mailing list
>
> Rust-dev at mozilla.org
>
> https://mail.mozilla.org/listinfo/rust-dev
>
>

From klutzytheklutzy at gmail.com  Fri Sep 13 23:35:31 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Sat, 14 Sep 2013 15:35:31 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
Message-ID: <CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>

some more explanation:

#include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
be included.
The header contains:

    #include <bits/c++config.h>
    #if _GLIBCXX_HAVE_FENV_H
    # include_next <fenv.h>
    #endif

where bits/c++config.h is at /lib/gcc/mingw32/<ver>/include/c++/mingw32.
However, for some reason (I don't know), they removed `#define
_GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
so `#include_next <fenv.h>` does not occur, which is
`/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.

On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> I've solved it some minutes ago :)
>
> <klutzy> at /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
> <klutzy> but there isn't [such #define] in 4.8.1 header.
> <klutzy> this causes /include/fenv.h not included when llvm does
> #include <fenv.h>
>
> The c++config.h has such lines:
> /* Define to 1 if you have the <fenv.h> header file. */
> /* #undef _GLIBCXX_HAVE_FENV_H */
>
> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
> works. We can't recommend users to do this hack though.
>
>
>
> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
>> Yes, but we can't check this into Rust repo.  Maybe it can be worked around
>> by -DWSAPOLLFD somewhere in makefiles...
>>
>> And just as a heads-up, these seems to be another problem,- with LLVM:
>> http://sourceforge.net/p/mingw/bugs/2043/
>>
>> Vadim
>>
>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:
>>
>> Mingw added new winapi at mswsock.h:
>>
>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
>>
>> #endif
>>
>> but they forgot to add definition of WSAPOLLFD.
>>
>> Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
>> but seems like it's not on mainstream.
>>
>> Anyway, we (including libuv) don't use the api. Removing the codeblock helps
>> us.
>>
>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
>>
>> broke mswsock.h (though the file didn't change).
>>
>>
>>
>>
>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>>
>>
>> Doesn't work...
>>
>>
>> Errors regarding libuv and mswsock...
>>
>>
>> http://pastebin.mozilla.org/3038909
>>
>>
>>
>>
>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>>
>> Hi Brian,
>>
>>
>> Actually, I would argue that these changes *should* be made before 0.8
>>
>> release in order to smoothen the path of people who will install 0.8 to try
>>
>> it out.
>>
>>
>> Regarding the work to be done, as far as I know all you need is:
>>
>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>>
>> 2. "mingw-get update"
>>
>> 3. "mingw-get upgrade"
>>
>> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>>
>> 5. "make clean"
>>
>> 6. "make check", which will fail at building stage1 std crate because
>>
>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>>
>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>>
>> 8. "make check" again, which should succeed this time
>>
>>
>> Can somebody please verify that this works?
>>
>>
>>
>> Re mingw-w64: sort of works, however its' phtreads implementation seems
>>
>> to be buggy.   Also see this thread.  I don't think we'll should migrate to
>>
>> it just yet.
>>
>>
>> Vadim
>>
>>
>>
>>
>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
>>
>> wrote:
>>
>>
>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>
>>
>> Yeah, there should not be a reason anymore, if I am correct, to not have
>>
>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>>
>> also , and if it works, then we can close out (#8598).  (I also would like
>>
>> to get rid of the 4.5 downgrade needed).... but that does need more testing
>>
>> from the core Rust team and others.
>>
>>
>> It's something that Brian has been counting on me to help make happen,
>>
>> and Alex is also contributing to some of that effort by fixing various LLVM
>>
>> build issues that affect Windows Rust users as you mention in (#8598).
>>
>>
>> Agreed, if a new stage0 compiler snapshot can be created, then we should
>>
>> be in the clear to also close out #5878.
>>
>>
>>
>>
>> Thanks for everybody's amazing contributions to our Windows support. If
>>
>> somebody makes the changes necessary to work with a newer toolchain then we
>>
>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>>
>> in two weeks.
>>
>>
>> I gather that some folks would like to switch to the mingw-w64 toolchain
>>
>> as well. Is that in the cards here?
>>
>>
>> _______________________________________________
>>
>> Rust-dev mailing list
>>
>> Rust-dev at mozilla.org
>>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>> _______________________________________________
>>
>> Rust-dev mailing list
>>
>> Rust-dev at mozilla.org
>>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>>
>> --
>>
>> -Thad
>>
>> Thad on Freebase.com
>>
>> Thad on LinkedIn
>>
>>
>>
>>
>> _______________________________________________
>>
>> Rust-dev mailing list
>>
>> Rust-dev at mozilla.org
>>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>

From klutzytheklutzy at gmail.com  Sat Sep 14 00:52:13 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Sat, 14 Sep 2013 16:52:13 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
Message-ID: <CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>

I've finished `make` on gcc 4.8.1, but `make check-fast` failed:

    task <unnamed> failed at 'assertion failed: `(left == right) &&
(right == left)`
    (left: `t_317::TwoU64s{one: 98784247808u64, two: 257698037760u64}`,
    right: `t_317::TwoU64s{one: 22u64, two: 94489280535u64}`)',
    C:\home\stone\rust-vanilla\src\test\run-pass\extern-pass-TwoU64s-ref.rs:27
    make: *** [i686-pc-mingw32/test/run_pass_stage2_driver-i686-pc-mingw32.out]
Error 101

I previously met this when I tested on mingw-w64/32bit.
(https://github.com/mozilla/rust/issues/8996)
Seems like the failure is related to recent gcc.


On Sat, Sep 14, 2013 at 3:35 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> some more explanation:
>
> #include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
> be included.
> The header contains:
>
>     #include <bits/c++config.h>
>     #if _GLIBCXX_HAVE_FENV_H
>     # include_next <fenv.h>
>     #endif
>
> where bits/c++config.h is at /lib/gcc/mingw32/<ver>/include/c++/mingw32.
> However, for some reason (I don't know), they removed `#define
> _GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
> so `#include_next <fenv.h>` does not occur, which is
> `/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.
>
> On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
>> I've solved it some minutes ago :)
>>
>> <klutzy> at /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
>> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
>> <klutzy> but there isn't [such #define] in 4.8.1 header.
>> <klutzy> this causes /include/fenv.h not included when llvm does
>> #include <fenv.h>
>>
>> The c++config.h has such lines:
>> /* Define to 1 if you have the <fenv.h> header file. */
>> /* #undef _GLIBCXX_HAVE_FENV_H */
>>
>> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
>> works. We can't recommend users to do this hack though.
>>
>>
>>
>> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
>>> Yes, but we can't check this into Rust repo.  Maybe it can be worked around
>>> by -DWSAPOLLFD somewhere in makefiles...
>>>
>>> And just as a heads-up, these seems to be another problem,- with LLVM:
>>> http://sourceforge.net/p/mingw/bugs/2043/
>>>
>>> Vadim
>>>
>>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:
>>>
>>> Mingw added new winapi at mswsock.h:
>>>
>>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
>>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
>>>
>>> #endif
>>>
>>> but they forgot to add definition of WSAPOLLFD.
>>>
>>> Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
>>> but seems like it's not on mainstream.
>>>
>>> Anyway, we (including libuv) don't use the api. Removing the codeblock helps
>>> us.
>>>
>>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
>>>
>>> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
>>>
>>> broke mswsock.h (though the file didn't change).
>>>
>>>
>>>
>>>
>>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>>>
>>>
>>> Doesn't work...
>>>
>>>
>>> Errors regarding libuv and mswsock...
>>>
>>>
>>> http://pastebin.mozilla.org/3038909
>>>
>>>
>>>
>>>
>>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>>>
>>>
>>> Hi Brian,
>>>
>>>
>>> Actually, I would argue that these changes *should* be made before 0.8
>>>
>>> release in order to smoothen the path of people who will install 0.8 to try
>>>
>>> it out.
>>>
>>>
>>> Regarding the work to be done, as far as I know all you need is:
>>>
>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>>>
>>> 2. "mingw-get update"
>>>
>>> 3. "mingw-get upgrade"
>>>
>>> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>>>
>>> 5. "make clean"
>>>
>>> 6. "make check", which will fail at building stage1 std crate because
>>>
>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>>>
>>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>>>
>>> 8. "make check" again, which should succeed this time
>>>
>>>
>>> Can somebody please verify that this works?
>>>
>>>
>>>
>>> Re mingw-w64: sort of works, however its' phtreads implementation seems
>>>
>>> to be buggy.   Also see this thread.  I don't think we'll should migrate to
>>>
>>> it just yet.
>>>
>>>
>>> Vadim
>>>
>>>
>>>
>>>
>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
>>>
>>> wrote:
>>>
>>>
>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>>
>>>
>>> Yeah, there should not be a reason anymore, if I am correct, to not have
>>>
>>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>>>
>>> also , and if it works, then we can close out (#8598).  (I also would like
>>>
>>> to get rid of the 4.5 downgrade needed).... but that does need more testing
>>>
>>> from the core Rust team and others.
>>>
>>>
>>> It's something that Brian has been counting on me to help make happen,
>>>
>>> and Alex is also contributing to some of that effort by fixing various LLVM
>>>
>>> build issues that affect Windows Rust users as you mention in (#8598).
>>>
>>>
>>> Agreed, if a new stage0 compiler snapshot can be created, then we should
>>>
>>> be in the clear to also close out #5878.
>>>
>>>
>>>
>>>
>>> Thanks for everybody's amazing contributions to our Windows support. If
>>>
>>> somebody makes the changes necessary to work with a newer toolchain then we
>>>
>>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>>>
>>> in two weeks.
>>>
>>>
>>> I gather that some folks would like to switch to the mingw-w64 toolchain
>>>
>>> as well. Is that in the cards here?
>>>
>>>
>>> _______________________________________________
>>>
>>> Rust-dev mailing list
>>>
>>> Rust-dev at mozilla.org
>>>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>>
>>> Rust-dev mailing list
>>>
>>> Rust-dev at mozilla.org
>>>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>>
>>>
>>> --
>>>
>>> -Thad
>>>
>>> Thad on Freebase.com
>>>
>>> Thad on LinkedIn
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>>
>>> Rust-dev mailing list
>>>
>>> Rust-dev at mozilla.org
>>>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>

From jmgrosen at gmail.com  Sat Sep 14 09:27:59 2013
From: jmgrosen at gmail.com (John)
Date: Sat, 14 Sep 2013 09:27:59 -0700
Subject: [rust-dev] Problems with extern mod = "..."
Message-ID: <CALd-RHWGOvTiEn9C87KXenC8pqC4U2ZLgOW_ikn981uBbN0DrA@mail.gmail.com>

I've been trying to get rustpkg to automatically fetch and build a dependency
using the extern mod = "..." syntax, but it doesn't seem to be working. For
example:

extern mod sax = "github.com/bjz/sax-rs#71d0e361ae";
fn main() {}

produces the error:
task <unnamed> failed at 'Unhandled condition: nonexistent_package:
(package_id::PkgId{path: std::path::PosixPath{is_absolute: false,
components: ~[~"github.com", ~"bjz", ~"sax-rs"]}, short_name:
~"sax-rs", version: ExactRevision(~"71d0e361ae")}, ~"supplied path for
package dir does not exist, and couldn\'t interpret it as a URL
fragment")', /path/to/rust/src/libstd/condition.rs:43

And https://github.com/bjz/sax-rs is a rustpkg-compatible repo.

Any ideas why I'm running into this? (Or is it just a bug?)

-- 
John Grosen

From jmgrosen at gmail.com  Sat Sep 14 09:52:31 2013
From: jmgrosen at gmail.com (John)
Date: Sat, 14 Sep 2013 09:52:31 -0700
Subject: [rust-dev] Problems with extern mod = "..."
In-Reply-To: <CALd-RHWGOvTiEn9C87KXenC8pqC4U2ZLgOW_ikn981uBbN0DrA@mail.gmail.com>
References: <CALd-RHWGOvTiEn9C87KXenC8pqC4U2ZLgOW_ikn981uBbN0DrA@mail.gmail.com>
Message-ID: <CALd-RHUAKK5uFEu1F0oJwPMKzRKcDr=t2=v8uSX2WHHWPJiEWw@mail.gmail.com>

I updated to latest Rust, and now I get this error:

error: Couldn't find package github.com/bjz/sax-rs#71d0e361ae, which
is needed by generator-0.1, in any of the workspaces in the RUST_PATH
(~[std::path::PosixPath{is_absolute: true, components: ~[~"path",
~"to", ~"gl-rs", ~".rust"]}, std::path::PosixPath{is_absolute: true,
components: ~[~"path", ~"to", ~"gl-rs"]}])
task <unnamed> failed at 'Unhandled condition: nonexistent_package:
(package_id::PkgId{path: std::path::PosixPath{is_absolute: false,
components: ~[~"github.com", ~"bjz", ~"sax-rs"]}, short_name:
~"sax-rs", version: ExactRevision(~"71d0e361ae")}, ~"Dependency not
found")', /Users/john/Projects/rust/src/libstd/condition.rs:43
task <unnamed> failed at 'killed by linked failure',
/path/to/Projects/rust/src/libstd/rt/kill.rs:627

Not sure if that's better or worse.

On Sat, Sep 14, 2013 at 9:27 AM, John <jmgrosen at gmail.com> wrote:
> I've been trying to get rustpkg to automatically fetch and build a dependency
> using the extern mod = "..." syntax, but it doesn't seem to be working. For
> example:
>
> extern mod sax = "github.com/bjz/sax-rs#71d0e361ae";
> fn main() {}
>
> produces the error:
> task <unnamed> failed at 'Unhandled condition: nonexistent_package:
> (package_id::PkgId{path: std::path::PosixPath{is_absolute: false,
> components: ~[~"github.com", ~"bjz", ~"sax-rs"]}, short_name:
> ~"sax-rs", version: ExactRevision(~"71d0e361ae")}, ~"supplied path for
> package dir does not exist, and couldn\'t interpret it as a URL
> fragment")', /path/to/rust/src/libstd/condition.rs:43
>
> And https://github.com/bjz/sax-rs is a rustpkg-compatible repo.
>
> Any ideas why I'm running into this? (Or is it just a bug?)
>
> --
> John Grosen



-- 
John Grosen
cogito, ergo sum.

From catamorphism at gmail.com  Sat Sep 14 10:03:21 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Sat, 14 Sep 2013 10:03:21 -0700
Subject: [rust-dev] Problems with extern mod = "..."
In-Reply-To: <CALd-RHUAKK5uFEu1F0oJwPMKzRKcDr=t2=v8uSX2WHHWPJiEWw@mail.gmail.com>
References: <CALd-RHWGOvTiEn9C87KXenC8pqC4U2ZLgOW_ikn981uBbN0DrA@mail.gmail.com>
	<CALd-RHUAKK5uFEu1F0oJwPMKzRKcDr=t2=v8uSX2WHHWPJiEWw@mail.gmail.com>
Message-ID: <CADcg8==QqFGL6DVcCcY5qRhmmXvdidtf0Y_xeP8tnCkXTbWGkQ@mail.gmail.com>

On Sat, Sep 14, 2013 at 9:52 AM, John <jmgrosen at gmail.com> wrote:
> I updated to latest Rust, and now I get this error:
>
> error: Couldn't find package github.com/bjz/sax-rs#71d0e361ae, which
> is needed by generator-0.1, in any of the workspaces in the RUST_PATH
> (~[std::path::PosixPath{is_absolute: true, components: ~[~"path",
> ~"to", ~"gl-rs", ~".rust"]}, std::path::PosixPath{is_absolute: true,
> components: ~[~"path", ~"to", ~"gl-rs"]}])
> task <unnamed> failed at 'Unhandled condition: nonexistent_package:
> (package_id::PkgId{path: std::path::PosixPath{is_absolute: false,
> components: ~[~"github.com", ~"bjz", ~"sax-rs"]}, short_name:
> ~"sax-rs", version: ExactRevision(~"71d0e361ae")}, ~"Dependency not
> found")', /Users/john/Projects/rust/src/libstd/condition.rs:43
> task <unnamed> failed at 'killed by linked failure',
> /path/to/Projects/rust/src/libstd/rt/kill.rs:627
>
> Not sure if that's better or worse.

Good catch. I filed an issue on this:

https://github.com/mozilla/rust/issues/9193

In short, I broke this with a recent change to rustpkg from a few days
ago, and because we don't have automated tests that use the network,
the regression wasn't caught.

As a workaround for now, you can manually check the repo into a local
workspace that's in your RUST_PATH. Sorry about that!

Cheers,
Tim




-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From jon.mb at proinbox.com  Sat Sep 14 15:39:47 2013
From: jon.mb at proinbox.com (John Mija)
Date: Sat, 14 Sep 2013 23:39:47 +0100
Subject: [rust-dev] Resources for newbies
Message-ID: <5234E5B3.5020807@proinbox.com>

Since Rust is close to 0.8 (with a syntax almost stable), each time 
there will be more interest to be learned by newbies (like me) so I 
think that could help some resources if were converted to Rust:

+ The tour of Go (http://tour.golang.org/) is licensed under Apache

	https://code.google.com/p/go-tour/

+ A graphical web-based front-end for gdb

	https://github.com/sirnewton01/godbg/

From flaper87 at gmail.com  Sat Sep 14 15:42:15 2013
From: flaper87 at gmail.com (Flaper87)
Date: Sun, 15 Sep 2013 00:42:15 +0200
Subject: [rust-dev] Resources for newbies
In-Reply-To: <5234E5B3.5020807@proinbox.com>
References: <5234E5B3.5020807@proinbox.com>
Message-ID: <CAMOT3C1qj-OEjFqMA6ofSFLcJYcvB2FbACt87FuF416ZNTNUiw@mail.gmail.com>

2013/9/15 John Mija <jon.mb at proinbox.com>

> Since Rust is close to 0.8 (with a syntax almost stable), each time there
> will be more interest to be learned by newbies (like me) so I think that
> could help some resources if were converted to Rust:
>
> + The tour of Go (http://tour.golang.org/) is licensed under Apache
>
>         https://code.google.com/p/go-**tour/<https://code.google.com/p/go-tour/>
>
> + A graphical web-based front-end for gdb
>
>         https://github.com/**sirnewton01/godbg/<https://github.com/sirnewton01/godbg/>



FWIW, I've started this[0] and I'll be adding more things in the next
couple of weeks. I'd love to have some help from other folks if they want.
:D

[0] https://github.com/FlaPer87/rust-for-real

Cheers,
FF

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/ca3ac9c9/attachment.html>

From klutzytheklutzy at gmail.com  Sat Sep 14 22:33:41 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Sun, 15 Sep 2013 14:33:41 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
Message-ID: <CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>

The error is due to abi change of win32 gcc. reported here:
https://github.com/mozilla/rust/issues/9205

On Sat, Sep 14, 2013 at 4:52 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> I've finished `make` on gcc 4.8.1, but `make check-fast` failed:
>
>     task <unnamed> failed at 'assertion failed: `(left == right) &&
> (right == left)`
>     (left: `t_317::TwoU64s{one: 98784247808u64, two: 257698037760u64}`,
>     right: `t_317::TwoU64s{one: 22u64, two: 94489280535u64}`)',
>     C:\home\stone\rust-vanilla\src\test\run-pass\extern-pass-TwoU64s-ref.rs:27
>     make: *** [i686-pc-mingw32/test/run_pass_stage2_driver-i686-pc-mingw32.out]
> Error 101
>
> I previously met this when I tested on mingw-w64/32bit.
> (https://github.com/mozilla/rust/issues/8996)
> Seems like the failure is related to recent gcc.
>
>
> On Sat, Sep 14, 2013 at 3:35 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
>> some more explanation:
>>
>> #include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
>> be included.
>> The header contains:
>>
>>     #include <bits/c++config.h>
>>     #if _GLIBCXX_HAVE_FENV_H
>>     # include_next <fenv.h>
>>     #endif
>>
>> where bits/c++config.h is at /lib/gcc/mingw32/<ver>/include/c++/mingw32.
>> However, for some reason (I don't know), they removed `#define
>> _GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
>> so `#include_next <fenv.h>` does not occur, which is
>> `/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.
>>
>> On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
>>> I've solved it some minutes ago :)
>>>
>>> <klutzy> at /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
>>> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
>>> <klutzy> but there isn't [such #define] in 4.8.1 header.
>>> <klutzy> this causes /include/fenv.h not included when llvm does
>>> #include <fenv.h>
>>>
>>> The c++config.h has such lines:
>>> /* Define to 1 if you have the <fenv.h> header file. */
>>> /* #undef _GLIBCXX_HAVE_FENV_H */
>>>
>>> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
>>> works. We can't recommend users to do this hack though.
>>>
>>>
>>>
>>> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
>>>> Yes, but we can't check this into Rust repo.  Maybe it can be worked around
>>>> by -DWSAPOLLFD somewhere in makefiles...
>>>>
>>>> And just as a heads-up, these seems to be another problem,- with LLVM:
>>>> http://sourceforge.net/p/mingw/bugs/2043/
>>>>
>>>> Vadim
>>>>
>>>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:
>>>>
>>>> Mingw added new winapi at mswsock.h:
>>>>
>>>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
>>>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
>>>>
>>>> #endif
>>>>
>>>> but they forgot to add definition of WSAPOLLFD.
>>>>
>>>> Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
>>>> but seems like it's not on mainstream.
>>>>
>>>> Anyway, we (including libuv) don't use the api. Removing the codeblock helps
>>>> us.
>>>>
>>>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
>>>>
>>>> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
>>>>
>>>> broke mswsock.h (though the file didn't change).
>>>>
>>>>
>>>>
>>>>
>>>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>>>>
>>>>
>>>> Doesn't work...
>>>>
>>>>
>>>> Errors regarding libuv and mswsock...
>>>>
>>>>
>>>> http://pastebin.mozilla.org/3038909
>>>>
>>>>
>>>>
>>>>
>>>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>>>>
>>>>
>>>> Hi Brian,
>>>>
>>>>
>>>> Actually, I would argue that these changes *should* be made before 0.8
>>>>
>>>> release in order to smoothen the path of people who will install 0.8 to try
>>>>
>>>> it out.
>>>>
>>>>
>>>> Regarding the work to be done, as far as I know all you need is:
>>>>
>>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>>>>
>>>> 2. "mingw-get update"
>>>>
>>>> 3. "mingw-get upgrade"
>>>>
>>>> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
>>>>
>>>> 5. "make clean"
>>>>
>>>> 6. "make check", which will fail at building stage1 std crate because
>>>>
>>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
>>>>
>>>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
>>>>
>>>> 8. "make check" again, which should succeed this time
>>>>
>>>>
>>>> Can somebody please verify that this works?
>>>>
>>>>
>>>>
>>>> Re mingw-w64: sort of works, however its' phtreads implementation seems
>>>>
>>>> to be buggy.   Also see this thread.  I don't think we'll should migrate to
>>>>
>>>> it just yet.
>>>>
>>>>
>>>> Vadim
>>>>
>>>>
>>>>
>>>>
>>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
>>>>
>>>> wrote:
>>>>
>>>>
>>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>>>>
>>>>
>>>> Yeah, there should not be a reason anymore, if I am correct, to not have
>>>>
>>>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
>>>>
>>>> also , and if it works, then we can close out (#8598).  (I also would like
>>>>
>>>> to get rid of the 4.5 downgrade needed).... but that does need more testing
>>>>
>>>> from the core Rust team and others.
>>>>
>>>>
>>>> It's something that Brian has been counting on me to help make happen,
>>>>
>>>> and Alex is also contributing to some of that effort by fixing various LLVM
>>>>
>>>> build issues that affect Windows Rust users as you mention in (#8598).
>>>>
>>>>
>>>> Agreed, if a new stage0 compiler snapshot can be created, then we should
>>>>
>>>> be in the clear to also close out #5878.
>>>>
>>>>
>>>>
>>>>
>>>> Thanks for everybody's amazing contributions to our Windows support. If
>>>>
>>>> somebody makes the changes necessary to work with a newer toolchain then we
>>>>
>>>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
>>>>
>>>> in two weeks.
>>>>
>>>>
>>>> I gather that some folks would like to switch to the mingw-w64 toolchain
>>>>
>>>> as well. Is that in the cards here?
>>>>
>>>>
>>>> _______________________________________________
>>>>
>>>> Rust-dev mailing list
>>>>
>>>> Rust-dev at mozilla.org
>>>>
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>>
>>>> Rust-dev mailing list
>>>>
>>>> Rust-dev at mozilla.org
>>>>
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>>
>>>>
>>>>
>>>> --
>>>>
>>>> -Thad
>>>>
>>>> Thad on Freebase.com
>>>>
>>>> Thad on LinkedIn
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>>
>>>> Rust-dev mailing list
>>>>
>>>> Rust-dev at mozilla.org
>>>>
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>

From luis at debethencourt.com  Sat Sep 14 23:48:49 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Sun, 15 Sep 2013 02:48:49 -0400
Subject: [rust-dev] Resources for newbies
In-Reply-To: <CAMOT3C1qj-OEjFqMA6ofSFLcJYcvB2FbACt87FuF416ZNTNUiw@mail.gmail.com>
References: <5234E5B3.5020807@proinbox.com>
	<CAMOT3C1qj-OEjFqMA6ofSFLcJYcvB2FbACt87FuF416ZNTNUiw@mail.gmail.com>
Message-ID: <CAPA4HGVRb_cj8y2gxPEbrvgki6Xxtf7EkYg3GshdqV2QkhNV5w@mail.gmail.com>

FF,

The rust-for-real is great. I've read through it and it was very
educational about Tasks Management.

I think people would be interested if you gave them precise things you want
added to your project. I think it would be very interesting if you started
a thread in this mailing list about it.

John,

The Rust Tour (same as Go Tour but in Rust) would be awesome. Definite +1
here.

Cheers!
Luis



On 14 September 2013 18:42, Flaper87 <flaper87 at gmail.com> wrote:

>
>
>
> 2013/9/15 John Mija <jon.mb at proinbox.com>
>
>> Since Rust is close to 0.8 (with a syntax almost stable), each time there
>> will be more interest to be learned by newbies (like me) so I think that
>> could help some resources if were converted to Rust:
>>
>> + The tour of Go (http://tour.golang.org/) is licensed under Apache
>>
>>         https://code.google.com/p/go-**tour/<https://code.google.com/p/go-tour/>
>>
>> + A graphical web-based front-end for gdb
>>
>>         https://github.com/**sirnewton01/godbg/<https://github.com/sirnewton01/godbg/>
>
>
>
> FWIW, I've started this[0] and I'll be adding more things in the next
> couple of weeks. I'd love to have some help from other folks if they want.
> :D
>
> [0] https://github.com/FlaPer87/rust-for-real
>
> Cheers,
> FF
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/5e30b0ff/attachment.html>

From flaper87 at gmail.com  Sun Sep 15 02:50:08 2013
From: flaper87 at gmail.com (Flaper87)
Date: Sun, 15 Sep 2013 11:50:08 +0200
Subject: [rust-dev] Rust for real: Learning Rust by example
Message-ID: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>

Hi Guys,

I'm writing this email in the hope of finding some help from you.

I recently started this project[0] into which I'll be adding examples of
Rust's internal modules - starting from std and then extra - as small
programs that can be compiled and ran independently. As for now, there are
2 examples for tasks already.

If any of you feels confident enough with any of Rusts modules and wants to
write examples - with docstrings and README explaining what's happening -
please, feel free to send PR.

I created a dir for task's examples into which I put 2 rust files -I'll add
more later - with contextualized examples. The first is a simple example of
how to use tasks and the second shows how to use nested tasks. I'm planning
to add another for inter tasks communications and another for tasks
"control" - supervised, unlinked, poisoning tasks, etc. I think this
structure would work well for other modules as well.

I'm also planning to add support for rustpkg and let it build the whole
thing if someone wants to do that.

If you have any better idea, suggestion please, share.

Cheers,
FF

 [0] https://github.com/FlaPer87/rust-for-real

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/aa81b082/attachment-0001.html>

From david.yu.ftw at gmail.com  Sun Sep 15 06:15:33 2013
From: david.yu.ftw at gmail.com (David Yu)
Date: Sun, 15 Sep 2013 21:15:33 +0800
Subject: [rust-dev] Rust for real: Learning Rust by example
In-Reply-To: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
References: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
Message-ID: <CAOkdov+kZUm98Ad3W9X6qNx69jiWfjMdXRSK1aRMfGPdMp-o8Q@mail.gmail.com>

On Sun, Sep 15, 2013 at 5:50 PM, Flaper87 <flaper87 at gmail.com> wrote:

> Hi Guys,
>
> I'm writing this email in the hope of finding some help from you.
>
> I recently started this project[0] into which I'll be adding examples of
> Rust's internal modules - starting from std and then extra - as small
> programs that can be compiled and ran independently. As for now, there are
> 2 examples for tasks already.
>
> If any of you feels confident enough with any of Rusts modules and wants
> to write examples - with docstrings and README explaining what's happening
> - please, feel free to send PR.
>
> I created a dir for task's examples into which I put 2 rust files -I'll
> add more later - with contextualized examples. The first is a simple
> example of how to use tasks and the second shows how to use nested tasks.
> I'm planning to add another for inter tasks communications and another for
> tasks "control" - supervised, unlinked, poisoning tasks, etc. I think this
> structure would work well for other modules as well.
>
> I'm also planning to add support for rustpkg and let it build the whole
> thing if someone wants to do that.
>
> If you have any better idea, suggestion please, share.
>
Great initiative.  Thanks for sharing!

>
> Cheers,
> FF
>
>  [0] https://github.com/FlaPer87/rust-for-real
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
When the cat is away, the mouse is alone.
- David Yu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/785e54fb/attachment.html>

From brianuhrin at gmail.com  Sun Sep 15 08:34:50 2013
From: brianuhrin at gmail.com (Brian Uhrin)
Date: Sun, 15 Sep 2013 11:34:50 -0400
Subject: [rust-dev] Rust for real: Learning Rust by example
In-Reply-To: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
References: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
Message-ID: <CAD3_g4Pbu6xAWuFhiTT1goSx5+SuS0CS6OpFzVDJyXk0KJsEEQ@mail.gmail.com>

On Sun, Sep 15, 2013 at 5:50 AM, Flaper87 <flaper87 at gmail.com> wrote:

> Hi Guys,
>
> I'm writing this email in the hope of finding some help from you.
>
> I recently started this project[0] into which I'll be adding examples of
> Rust's internal modules - starting from std and then extra - as small
> programs that can be compiled and ran independently. As for now, there are
> 2 examples for tasks already.
>
> If any of you feels confident enough with any of Rusts modules and wants
> to write examples - with docstrings and README explaining what's happening
> - please, feel free to send PR.
>
> I created a dir for task's examples into which I put 2 rust files -I'll
> add more later - with contextualized examples. The first is a simple
> example of how to use tasks and the second shows how to use nested tasks.
> I'm planning to add another for inter tasks communications and another for
> tasks "control" - supervised, unlinked, poisoning tasks, etc. I think this
> structure would work well for other modules as well.
>
> I'm also planning to add support for rustpkg and let it build the whole
> thing if someone wants to do that.
>
> If you have any better idea, suggestion please, share.
>
> Cheers,
> FF
>
>  [0] https://github.com/FlaPer87/rust-for-real
>
> I am currently taking an independent study class at the University of
Pittsburgh and chose Rust as the topic.  I planned to have the project
consist of a beginners tutorial,  some non-trivial code examples, an
overview and code examples from the servo project, and some examples of
c/c++ memory safety issues that Rust is trying to avoid.  Right now I am
still learning and have played in std and extra.  I will be doing a lot
more work there and hopefully I will develop some examples that I can add
to your project.

Brian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/46b938fd/attachment.html>

From luis at debethencourt.com  Sun Sep 15 10:35:08 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Sun, 15 Sep 2013 13:35:08 -0400
Subject: [rust-dev] Rust for real: Learning Rust by example
In-Reply-To: <CAD3_g4Pbu6xAWuFhiTT1goSx5+SuS0CS6OpFzVDJyXk0KJsEEQ@mail.gmail.com>
References: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
	<CAD3_g4Pbu6xAWuFhiTT1goSx5+SuS0CS6OpFzVDJyXk0KJsEEQ@mail.gmail.com>
Message-ID: <CAPA4HGVruXr0Cfa3kD1S6ywX60frsimyDRt1DuCk7i_Chy51Ow@mail.gmail.com>

Nice! Looking forward to this covering more modules.

Hopefully I will have time to contribute sometime soon.

FF (I assume that is how you want to be called),
Could you populate the Readme file with more information about the project?
It would get more people interested in it.

Luis


On 15 September 2013 11:34, Brian Uhrin <brianuhrin at gmail.com> wrote:

>
> On Sun, Sep 15, 2013 at 5:50 AM, Flaper87 <flaper87 at gmail.com> wrote:
>
>> Hi Guys,
>>
>> I'm writing this email in the hope of finding some help from you.
>>
>> I recently started this project[0] into which I'll be adding examples of
>> Rust's internal modules - starting from std and then extra - as small
>> programs that can be compiled and ran independently. As for now, there are
>> 2 examples for tasks already.
>>
>> If any of you feels confident enough with any of Rusts modules and wants
>> to write examples - with docstrings and README explaining what's happening
>> - please, feel free to send PR.
>>
>> I created a dir for task's examples into which I put 2 rust files -I'll
>> add more later - with contextualized examples. The first is a simple
>> example of how to use tasks and the second shows how to use nested tasks.
>> I'm planning to add another for inter tasks communications and another for
>> tasks "control" - supervised, unlinked, poisoning tasks, etc. I think this
>> structure would work well for other modules as well.
>>
>> I'm also planning to add support for rustpkg and let it build the whole
>> thing if someone wants to do that.
>>
>> If you have any better idea, suggestion please, share.
>>
>> Cheers,
>> FF
>>
>>  [0] https://github.com/FlaPer87/rust-for-real
>>
>> I am currently taking an independent study class at the University of
> Pittsburgh and chose Rust as the topic.  I planned to have the project
> consist of a beginners tutorial,  some non-trivial code examples, an
> overview and code examples from the servo project, and some examples of
> c/c++ memory safety issues that Rust is trying to avoid.  Right now I am
> still learning and have played in std and extra.  I will be doing a lot
> more work there and hopefully I will develop some examples that I can add
> to your project.
>
> Brian
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/6e2a7cc8/attachment.html>

From luis at debethencourt.com  Sun Sep 15 11:12:10 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Sun, 15 Sep 2013 14:12:10 -0400
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGVM4XN0ukyBVpKeWwhGzaaM-rZzhvUjXFYoOGHcQBXBAQ@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<l0u5v8$q0n$1@ger.gmane.org>
	<CAPA4HGVNdfLCPAd5d_exR1pc6b8rp4PbhW4Aw44Z6WhkJU3=wg@mail.gmail.com>
	<BAY177-W261677EA4BB2D0D720B2BA883B0@phx.gbl>
	<CAChbWaOGZ=51kn+onBw=V_dA9hcsMwThAgbWGfVr5wcjJGz9gA@mail.gmail.com>
	<CAChbWaNBsh37427MKA=McDCn_d0XbnPJE-8yV05tD1MKqrqN3w@mail.gmail.com>
	<CAPA4HGXWE=nTh8YVU96e0henY8ZqpKDU0J5HeG4WwPuRuMBCeg@mail.gmail.com>
	<CAFEbTaUNcs_7CWas-D4nmzkkZK4mdGkfM6mvqi8fA8ukM66bxQ@mail.gmail.com>
	<CAPA4HGVM4XN0ukyBVpKeWwhGzaaM-rZzhvUjXFYoOGHcQBXBAQ@mail.gmail.com>
Message-ID: <CAPA4HGVMSRh5k4_K35b2nLRNXim2hS7TF+qnzrh+3GhbF2PjiA@mail.gmail.com>

Hello all,

I've created this repository as a placeholder:
https://github.com/luisbg/rust-datetime

It won't have much content for a while since I won't commit until there is
at least one usable API function, and I'm currently in the researching and
planning stage. Patience.

Thanks,
Luis


On 13 September 2013 21:09, Luis de Bethencourt <luis at debethencourt.com>wrote:

> That is a very interesting read.
>
> We certainly should learn from the experiences of other languages. This
> being a good example.
> I will be revisiting the linked documents listed in this thread repeatedly.
>
> Fortunately the issue he mentions about NULLs creating random bugs, is
> taken care of by Rust's safety.
>
> Thanks,
> Luis
>
>
> On 13 September 2013 19:21, Jason Fager <jfager at gmail.com> wrote:
>
>> Joda-Time and JSR-310 are similar APIs but different
>> implementations. It's the same guy behind both, here he is explaining why
>> he wanted 310 instead of just standardizing Joda:
>>
>> http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html?m=1
>>
>>
>> On Friday, September 13, 2013, Luis de Bethencourt wrote:
>>
>>> Cool!
>>>
>>> Great and awesome feedback. The summary is that Joda-Time is what we
>>> should aspire to have.
>>>
>>> My goal is to first cover the "most common use cases", and as Corey
>>> says, "easy to use correctly".
>>>
>>> After that I can start considering the corner cases like bya and mya.
>>> Which sound very fun and interesting, but not high priority.
>>> Hopefully by then I won't be too consumed by the question of what is
>>> Time.
>>>
>>> Thanks, will keep you guys updated,
>>> Luis
>>>
>>>
>>>
>>> On 13 September 2013 16:20, Thad Guidry <thadguidry at gmail.com> wrote:
>>>
>>> Additionally,
>>>
>>> Be able to convert "bya" to "mya" ?  http://en.wikipedia.org/wiki/Bya
>>>
>>> The short scale is now commonly used, btw... but also need to deal with
>>> this for conversions:
>>>
>>> http://en.wikipedia.org/wiki/Long_and_short_scales
>>>
>>> There should be a preference boolean for conversion output for short or
>>> long scale... especially concerning above a thousand million.
>>>
>>> That's enough to get you going with some wild ideas that Jodatime does
>>> not handle.
>>>
>>>
>>>
>>> On Fri, Sep 13, 2013 at 3:08 PM, Thad Guidry <thadguidry at gmail.com>wrote:
>>>
>>> One idea and use case for Paleontologists and Geologists coming over to
>>> Rust in droves... :-)
>>>
>>> Generically, just be able to handle simple Geologic addition and
>>> subtraction against an Epoch itself (reference date)
>>> http://en.wikipedia.org/wiki/Epoch_(reference_date) using known
>>> abbreviations.
>>>
>>> And additionally, store, understand, and output them:
>>>
>>> B.Y.B.P = Billion Years Before Present
>>> M.Y.B.P = Million Years Before Present
>>>
>>>
>>>
>>>
>>> On Fri, Sep 13, 2013 at 2:51 PM, Aaron Dandy <aaron.dandy at live.com>wrote:
>>>
>>> I remember reading this article:
>>> http://noda-time.blogspot.com/2011/08/what-wrong-with-datetime-anyway.html a
>>> while back and really appreciating date time & time zone libraries. Also
>>> after reading news of the leap second triggering a bug on a bunch of
>>> systems I now question all assumptions I make about our representations of
>>> time. I can no longer say that a minute is 60 seconds long with a straight
>>> face. Next up I guess we programmers have a year 2038 problem to deal with
>>> too. This library will be a big deal to write but there thankfully there
>>> should be a lot of existing knowledge to learn from.
>>>
>>> ------------------------------
>>> Date: Fri, 13 Sep 2013 15:10:21 -0400
>>> From: luis at debethencourt.com
>>> To: spam at scientician.net
>>> CC: rust-dev at mozilla.org
>>> Subject: Re: [rust-dev] lib: Is anybody working on the datetime library?
>>>
>>>
>>> Hello Bardur,
>>>
>>> Thank you so much for the reference resource of JSR-310 and its design
>>> docs.
>>> I looked over it briefly and it is indeed very valuable.
>>>
>>> It was listed in the wiki page, but the link was to the former home of
>>> it.
>>> I have updated it.
>>>
>>> Since nobody has claimed this module, I will start working on this
>>> module tomorrow Saturday.
>>> Is that OK?
>>>
>>> Please, please, I would love more comments and ideas. Will start asking
>>> for reviews once I have some code to show.
>>>
>>> Thanks,
>>> Luis
>>>
>>>
>>>
>>>
>>>
>>> On 13 September 2013 00:57, Bardur Arantsson <spam at scientici
>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/429f3f91/attachment-0001.html>

From steve at steveklabnik.com  Sun Sep 15 14:14:29 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Sun, 15 Sep 2013 14:14:29 -0700
Subject: [rust-dev] Rust for real: Learning Rust by example
In-Reply-To: <CAD3_g4Pbu6xAWuFhiTT1goSx5+SuS0CS6OpFzVDJyXk0KJsEEQ@mail.gmail.com>
References: <CAMOT3C3pnLsg=1og+3fkhU+F_jO46LVw97WF+FFJq2riJ285vQ@mail.gmail.com>
	<CAD3_g4Pbu6xAWuFhiTT1goSx5+SuS0CS6OpFzVDJyXk0KJsEEQ@mail.gmail.com>
Message-ID: <CABL+ZB6sZUAV5B7KqPxUX1cfzRro5uNnE7w4UOHcmRqAtLwqRQ@mail.gmail.com>

Brian! You go to my alma mater.

Examples are always helpful, I've been slowly chugging away at adding them
myself. Extra help would be great!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130915/393e2c13/attachment.html>

From lists at ncameron.org  Sun Sep 15 16:38:51 2013
From: lists at ncameron.org (Nick Cameron)
Date: Mon, 16 Sep 2013 11:38:51 +1200
Subject: [rust-dev] Subtyping in Rust
In-Reply-To: <20130913094841.GD6242@Mr-Bennet>
References: <CAA5tgF3YJZ_fEGi+1UiTBywpy8O2fxHn5HEJJj4Oz-Ry08bs3Q@mail.gmail.com>
	<20130909133458.GE3459@Mr-Bennet>
	<CAA5tgF0CRTrEqbpup8Qm6kGiks9vzqujtGOp89kRv8B3F-XAEA@mail.gmail.com>
	<20130913094841.GD6242@Mr-Bennet>
Message-ID: <CAA5tgF0NOJHHkdpJh0sQb0D28Gbo73rA4sV4cd71xL2kp1KRBA@mail.gmail.com>

Thank you for the info, Steven and Niko!

I would personally prefer more implicit conversions (but I have not really
thought through the matter). I am not sure what you mean by transmute
calls. How would you use a library call to change the type of an expression
without implicit or explicit conversions?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/2da381d7/attachment.html>

From aaron.dandy at live.com  Sun Sep 15 23:51:50 2013
From: aaron.dandy at live.com (Aaron Dandy)
Date: Mon, 16 Sep 2013 00:51:50 -0600
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>,
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>,
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>,
	<52322DCA.8040104@mozilla.com>,
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>,
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>,
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>,
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>,
	<465696506198446370@unknownmsgid>,
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>,
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>,
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>,
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
Message-ID: <BAY177-W1211328C720010A7E760E088260@phx.gbl>

Klutzy helped me through a bunch of issues tonight and I am now building stage 2 from HEAD using GCC 4.8. I put the procedure I used up on the GitHub wiki for others to try and also linked it from the main getting started page: " https://github.com/mozilla/rust/wiki/Note-Building-Rust-Before-0.8-on-Windows-Systems . Huge thanks for Klutzy helping me out.
Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin$ rustc.exe hello.rs
Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin$ helloHello, world.
> Date: Sun, 15 Sep 2013 14:33:41 +0900
> From: klutzytheklutzy at gmail.com
> To: vadimcn at gmail.com
> CC: rust-dev at mozilla.org
> Subject: Re: [rust-dev] Windows Users can build Rust properly again !
> 
> The error is due to abi change of win32 gcc. reported here:
> https://github.com/mozilla/rust/issues/9205
> 
> On Sat, Sep 14, 2013 at 4:52 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> > I've finished `make` on gcc 4.8.1, but `make check-fast` failed:
> >
> >     task <unnamed> failed at 'assertion failed: `(left == right) &&
> > (right == left)`
> >     (left: `t_317::TwoU64s{one: 98784247808u64, two: 257698037760u64}`,
> >     right: `t_317::TwoU64s{one: 22u64, two: 94489280535u64}`)',
> >     C:\home\stone\rust-vanilla\src\test\run-pass\extern-pass-TwoU64s-ref.rs:27
> >     make: *** [i686-pc-mingw32/test/run_pass_stage2_driver-i686-pc-mingw32.out]
> > Error 101
> >
> > I previously met this when I tested on mingw-w64/32bit.
> > (https://github.com/mozilla/rust/issues/8996)
> > Seems like the failure is related to recent gcc.
> >
> >
> > On Sat, Sep 14, 2013 at 3:35 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> >> some more explanation:
> >>
> >> #include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
> >> be included.
> >> The header contains:
> >>
> >>     #include <bits/c++config.h>
> >>     #if _GLIBCXX_HAVE_FENV_H
> >>     # include_next <fenv.h>
> >>     #endif
> >>
> >> where bits/c++config.h is at /lib/gcc/mingw32/<ver>/include/c++/mingw32.
> >> However, for some reason (I don't know), they removed `#define
> >> _GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
> >> so `#include_next <fenv.h>` does not occur, which is
> >> `/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.
> >>
> >> On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com> wrote:
> >>> I've solved it some minutes ago :)
> >>>
> >>> <klutzy> at /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
> >>> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
> >>> <klutzy> but there isn't [such #define] in 4.8.1 header.
> >>> <klutzy> this causes /include/fenv.h not included when llvm does
> >>> #include <fenv.h>
> >>>
> >>> The c++config.h has such lines:
> >>> /* Define to 1 if you have the <fenv.h> header file. */
> >>> /* #undef _GLIBCXX_HAVE_FENV_H */
> >>>
> >>> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
> >>> works. We can't recommend users to do this hack though.
> >>>
> >>>
> >>>
> >>> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
> >>>> Yes, but we can't check this into Rust repo.  Maybe it can be worked around
> >>>> by -DWSAPOLLFD somewhere in makefiles...
> >>>>
> >>>> And just as a heads-up, these seems to be another problem,- with LLVM:
> >>>> http://sourceforge.net/p/mingw/bugs/2043/
> >>>>
> >>>> Vadim
> >>>>
> >>>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com> wrote:
> >>>>
> >>>> Mingw added new winapi at mswsock.h:
> >>>>
> >>>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
> >>>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
> >>>>
> >>>> #endif
> >>>>
> >>>> but they forgot to add definition of WSAPOLLFD.
> >>>>
> >>>> Someone submitted patch at http://sourceforge.net/p/mingw/bugs/1980/
> >>>> but seems like it's not on mainstream.
> >>>>
> >>>> Anyway, we (including libuv) don't use the api. Removing the codeblock helps
> >>>> us.
> >>>>
> >>>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
> >>>>
> >>>> Hmm.  Looks like mingw released a new version with gcc 4.8 and that somehow
> >>>>
> >>>> broke mswsock.h (though the file didn't change).
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com> wrote:
> >>>>
> >>>>
> >>>> Doesn't work...
> >>>>
> >>>>
> >>>> Errors regarding libuv and mswsock...
> >>>>
> >>>>
> >>>> http://pastebin.mozilla.org/3038909
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
> >>>>
> >>>>
> >>>> Hi Brian,
> >>>>
> >>>>
> >>>> Actually, I would argue that these changes *should* be made before 0.8
> >>>>
> >>>> release in order to smoothen the path of people who will install 0.8 to try
> >>>>
> >>>> it out.
> >>>>
> >>>>
> >>>> Regarding the work to be done, as far as I know all you need is:
> >>>>
> >>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
> >>>>
> >>>> 2. "mingw-get update"
> >>>>
> >>>> 3. "mingw-get upgrade"
> >>>>
> >>>> 4. run %rust%\configure  (not sure if actually needed, but won't hurt)
> >>>>
> >>>> 5. "make clean"
> >>>>
> >>>> 6. "make check", which will fail at building stage1 std crate because
> >>>>
> >>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
> >>>>
> >>>> 7. copy dlls saved in step 1 into %rust%\build\i686-pc-mingw32\stage0\bin
> >>>>
> >>>> 8. "make check" again, which should succeed this time
> >>>>
> >>>>
> >>>> Can somebody please verify that this works?
> >>>>
> >>>>
> >>>>
> >>>> Re mingw-w64: sort of works, however its' phtreads implementation seems
> >>>>
> >>>> to be buggy.   Also see this thread.  I don't think we'll should migrate to
> >>>>
> >>>> it just yet.
> >>>>
> >>>>
> >>>> Vadim
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <banderson at mozilla.com>
> >>>>
> >>>> wrote:
> >>>>
> >>>>
> >>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
> >>>>
> >>>>
> >>>> Yeah, there should not be a reason anymore, if I am correct, to not have
> >>>>
> >>>> GCC 4.7 in MinGW for Rust Windows users anymore.  I will give that a try
> >>>>
> >>>> also , and if it works, then we can close out (#8598).  (I also would like
> >>>>
> >>>> to get rid of the 4.5 downgrade needed).... but that does need more testing
> >>>>
> >>>> from the core Rust team and others.
> >>>>
> >>>>
> >>>> It's something that Brian has been counting on me to help make happen,
> >>>>
> >>>> and Alex is also contributing to some of that effort by fixing various LLVM
> >>>>
> >>>> build issues that affect Windows Rust users as you mention in (#8598).
> >>>>
> >>>>
> >>>> Agreed, if a new stage0 compiler snapshot can be created, then we should
> >>>>
> >>>> be in the clear to also close out #5878.
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> Thanks for everybody's amazing contributions to our Windows support. If
> >>>>
> >>>> somebody makes the changes necessary to work with a newer toolchain then we
> >>>>
> >>>> will upgrade the bots. It's unlikely we can do this before 0.8 though, due
> >>>>
> >>>> in two weeks.
> >>>>
> >>>>
> >>>> I gather that some folks would like to switch to the mingw-w64 toolchain
> >>>>
> >>>> as well. Is that in the cards here?
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>>
> >>>> Rust-dev mailing list
> >>>>
> >>>> Rust-dev at mozilla.org
> >>>>
> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>>
> >>>> Rust-dev mailing list
> >>>>
> >>>> Rust-dev at mozilla.org
> >>>>
> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> --
> >>>>
> >>>> -Thad
> >>>>
> >>>> Thad on Freebase.com
> >>>>
> >>>> Thad on LinkedIn
> >>>>
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>>
> >>>> Rust-dev mailing list
> >>>>
> >>>> Rust-dev at mozilla.org
> >>>>
> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/25bab973/attachment-0001.html>

From thadguidry at gmail.com  Mon Sep 16 07:25:03 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 16 Sep 2013 09:25:03 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <BAY177-W1211328C720010A7E760E088260@phx.gbl>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
Message-ID: <CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>

Good Job on documenting the build steps, Dandy !  Closer and closer we get
to flawless building on Windows.


On Mon, Sep 16, 2013 at 1:51 AM, Aaron Dandy <aaron.dandy at live.com> wrote:

> Klutzy helped me through a bunch of issues tonight and I am now building
> stage 2 from HEAD using GCC 4.8. I put the procedure I used up on the
> GitHub wiki for others to try and also linked it from the main getting
> started page: "
> https://github.com/mozilla/rust/wiki/Note-Building-Rust-Before-0.8-on-Windows-Systems .
> Huge thanks for Klutzy helping me out.
>
> Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin
> $ rustc.exe hello.rs
>
> Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin
> $ hello
> Hello, world.
>
> > Date: Sun, 15 Sep 2013 14:33:41 +0900
> > From: klutzytheklutzy at gmail.com
> > To: vadimcn at gmail.com
> > CC: rust-dev at mozilla.org
> > Subject: Re: [rust-dev] Windows Users can build Rust properly again !
>
> >
> > The error is due to abi change of win32 gcc. reported here:
> > https://github.com/mozilla/rust/issues/9205
> >
> > On Sat, Sep 14, 2013 at 4:52 PM, klutzy <klutzytheklutzy at gmail.com>
> wrote:
> > > I've finished `make` on gcc 4.8.1, but `make check-fast` failed:
> > >
> > > task <unnamed> failed at 'assertion failed: `(left == right) &&
> > > (right == left)`
> > > (left: `t_317::TwoU64s{one: 98784247808u64, two: 257698037760u64}`,
> > > right: `t_317::TwoU64s{one: 22u64, two: 94489280535u64}`)',
> > >
> C:\home\stone\rust-vanilla\src\test\run-pass\extern-pass-TwoU64s-ref.rs:27
> > > make: ***
> [i686-pc-mingw32/test/run_pass_stage2_driver-i686-pc-mingw32.out]
> > > Error 101
> > >
> > > I previously met this when I tested on mingw-w64/32bit.
> > > (https://github.com/mozilla/rust/issues/8996)
> > > Seems like the failure is related to recent gcc.
> > >
> > >
> > > On Sat, Sep 14, 2013 at 3:35 PM, klutzy <klutzytheklutzy at gmail.com>
> wrote:
> > >> some more explanation:
> > >>
> > >> #include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
> > >> be included.
> > >> The header contains:
> > >>
> > >> #include <bits/c++config.h>
> > >> #if _GLIBCXX_HAVE_FENV_H
> > >> # include_next <fenv.h>
> > >> #endif
> > >>
> > >> where bits/c++config.h is at
> /lib/gcc/mingw32/<ver>/include/c++/mingw32.
> > >> However, for some reason (I don't know), they removed `#define
> > >> _GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
> > >> so `#include_next <fenv.h>` does not occur, which is
> > >> `/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.
> > >>
> > >> On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com>
> wrote:
> > >>> I've solved it some minutes ago :)
> > >>>
> > >>> <klutzy> at
> /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
> > >>> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
> > >>> <klutzy> but there isn't [such #define] in 4.8.1 header.
> > >>> <klutzy> this causes /include/fenv.h not included when llvm does
> > >>> #include <fenv.h>
> > >>>
> > >>> The c++config.h has such lines:
> > >>> /* Define to 1 if you have the <fenv.h> header file. */
> > >>> /* #undef _GLIBCXX_HAVE_FENV_H */
> > >>>
> > >>> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and it
> > >>> works. We can't recommend users to do this hack though.
> > >>>
> > >>>
> > >>>
> > >>> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
> > >>>> Yes, but we can't check this into Rust repo. Maybe it can be worked
> around
> > >>>> by -DWSAPOLLFD somewhere in makefiles...
> > >>>>
> > >>>> And just as a heads-up, these seems to be another problem,- with
> LLVM:
> > >>>> http://sourceforge.net/p/mingw/bugs/2043/
> > >>>>
> > >>>> Vadim
> > >>>>
> > >>>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com>
> wrote:
> > >>>>
> > >>>> Mingw added new winapi at mswsock.h:
> > >>>>
> > >>>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
> > >>>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
> > >>>>
> > >>>> #endif
> > >>>>
> > >>>> but they forgot to add definition of WSAPOLLFD.
> > >>>>
> > >>>> Someone submitted patch at
> http://sourceforge.net/p/mingw/bugs/1980/
> > >>>> but seems like it's not on mainstream.
> > >>>>
> > >>>> Anyway, we (including libuv) don't use the api. Removing the
> codeblock helps
> > >>>> us.
> > >>>>
> > >>>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
> > >>>>
> > >>>> Hmm. Looks like mingw released a new version with gcc 4.8 and that
> somehow
> > >>>>
> > >>>> broke mswsock.h (though the file didn't change).
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com>
> wrote:
> > >>>>
> > >>>>
> > >>>> Doesn't work...
> > >>>>
> > >>>>
> > >>>> Errors regarding libuv and mswsock...
> > >>>>
> > >>>>
> > >>>> http://pastebin.mozilla.org/3038909
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
> > >>>>
> > >>>>
> > >>>> Hi Brian,
> > >>>>
> > >>>>
> > >>>> Actually, I would argue that these changes *should* be made before
> 0.8
> > >>>>
> > >>>> release in order to smoothen the path of people who will install
> 0.8 to try
> > >>>>
> > >>>> it out.
> > >>>>
> > >>>>
> > >>>> Regarding the work to be done, as far as I know all you need is:
> > >>>>
> > >>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
> > >>>>
> > >>>> 2. "mingw-get update"
> > >>>>
> > >>>> 3. "mingw-get upgrade"
> > >>>>
> > >>>> 4. run %rust%\configure (not sure if actually needed, but won't
> hurt)
> > >>>>
> > >>>> 5. "make clean"
> > >>>>
> > >>>> 6. "make check", which will fail at building stage1 std crate
> because
> > >>>>
> > >>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs them.
> > >>>>
> > >>>> 7. copy dlls saved in step 1 into
> %rust%\build\i686-pc-mingw32\stage0\bin
> > >>>>
> > >>>> 8. "make check" again, which should succeed this time
> > >>>>
> > >>>>
> > >>>> Can somebody please verify that this works?
> > >>>>
> > >>>>
> > >>>>
> > >>>> Re mingw-w64: sort of works, however its' phtreads implementation
> seems
> > >>>>
> > >>>> to be buggy. Also see this thread. I don't think we'll should
> migrate to
> > >>>>
> > >>>> it just yet.
> > >>>>
> > >>>>
> > >>>> Vadim
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <
> banderson at mozilla.com>
> > >>>>
> > >>>> wrote:
> > >>>>
> > >>>>
> > >>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
> > >>>>
> > >>>>
> > >>>> Yeah, there should not be a reason anymore, if I am correct, to not
> have
> > >>>>
> > >>>> GCC 4.7 in MinGW for Rust Windows users anymore. I will give that a
> try
> > >>>>
> > >>>> also , and if it works, then we can close out (#8598). (I also
> would like
> > >>>>
> > >>>> to get rid of the 4.5 downgrade needed).... but that does need more
> testing
> > >>>>
> > >>>> from the core Rust team and others.
> > >>>>
> > >>>>
> > >>>> It's something that Brian has been counting on me to help make
> happen,
> > >>>>
> > >>>> and Alex is also contributing to some of that effort by fixing
> various LLVM
> > >>>>
> > >>>> build issues that affect Windows Rust users as you mention in
> (#8598).
> > >>>>
> > >>>>
> > >>>> Agreed, if a new stage0 compiler snapshot can be created, then we
> should
> > >>>>
> > >>>> be in the clear to also close out #5878.
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> Thanks for everybody's amazing contributions to our Windows
> support. If
> > >>>>
> > >>>> somebody makes the changes necessary to work with a newer toolchain
> then we
> > >>>>
> > >>>> will upgrade the bots. It's unlikely we can do this before 0.8
> though, due
> > >>>>
> > >>>> in two weeks.
> > >>>>
> > >>>>
> > >>>> I gather that some folks would like to switch to the mingw-w64
> toolchain
> > >>>>
> > >>>> as well. Is that in the cards here?
> > >>>>
> > >>>>
> > >>>> _______________________________________________
> > >>>>
> > >>>> Rust-dev mailing list
> > >>>>
> > >>>> Rust-dev at mozilla.org
> > >>>>
> > >>>> https://mail.mozilla.org/listinfo/rust-dev
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> _______________________________________________
> > >>>>
> > >>>> Rust-dev mailing list
> > >>>>
> > >>>> Rust-dev at mozilla.org
> > >>>>
> > >>>> https://mail.mozilla.org/listinfo/rust-dev
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> --
> > >>>>
> > >>>> -Thad
> > >>>>
> > >>>> Thad on Freebase.com
> > >>>>
> > >>>> Thad on LinkedIn
> > >>>>
> > >>>>
> > >>>>
> > >>>>
> > >>>> _______________________________________________
> > >>>>
> > >>>> Rust-dev mailing list
> > >>>>
> > >>>> Rust-dev at mozilla.org
> > >>>>
> > >>>> https://mail.mozilla.org/listinfo/rust-dev
> > >>>>
> > >>>>
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/9960711c/attachment.html>

From acrichton at mozilla.com  Mon Sep 16 13:43:39 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Mon, 16 Sep 2013 13:43:39 -0700
Subject: [rust-dev] Rust's newest full-time Engineer
Message-ID: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>

Greetings rust-dev! I wanted to announce to everyone that today is my first day at Mozilla as an engineer working on Rust!

I started using Rust last December for a project of mine, and once I got fed up with compiler errors I decided to try my hand at improving the compiler itself. The community was incredibly helpful in getting me on my feet contributing to rust, and it's been awesome seeing how rust and the community around it have evolved since I started working on it.

I'm incredibly excited to have the opportunity to work on Rust with everyone who's been contributing, and I can't wait to help Rust reach 1.0 even faster.

From thadguidry at gmail.com  Mon Sep 16 13:55:14 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 16 Sep 2013 15:55:14 -0500
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
Message-ID: <CAChbWaN+tc9ijAOPwX6=o-sihFVwt1WcxDHwfuFGggPPQBDfyw@mail.gmail.com>

Congrats Alex !  And thanks for patching up LLVM build and moving things
forward with Rust !

We still have over 1000+ things (issues) for you to steadily work on....
so, grab some tea. :-)


On Mon, Sep 16, 2013 at 3:43 PM, Alex Crichton <acrichton at mozilla.com>wrote:

> Greetings rust-dev! I wanted to announce to everyone that today is my
> first day at Mozilla as an engineer working on Rust!
>
> I started using Rust last December for a project of mine, and once I got
> fed up with compiler errors I decided to try my hand at improving the
> compiler itself. The community was incredibly helpful in getting me on my
> feet contributing to rust, and it's been awesome seeing how rust and the
> community around it have evolved since I started working on it.
>
> I'm incredibly excited to have the opportunity to work on Rust with
> everyone who's been contributing, and I can't wait to help Rust reach 1.0
> even faster.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/1040af90/attachment.html>

From banderson at mozilla.com  Mon Sep 16 14:03:03 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 16 Sep 2013 14:03:03 -0700
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
Message-ID: <52377207.3050706@mozilla.com>

On 09/16/2013 01:43 PM, Alex Crichton wrote:
> Greetings rust-dev! I wanted to announce to everyone that today is my first day at Mozilla as an engineer working on Rust!
>

Welcome aboard!

From maikklein at googlemail.com  Mon Sep 16 14:06:51 2013
From: maikklein at googlemail.com (Maik Klein)
Date: Mon, 16 Sep 2013 23:06:51 +0200
Subject: [rust-dev] Is our UdpSocket misbehaving?
Message-ID: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>

https://gist.github.com/MaikKlein/6586333

Basically what happens is that a packet is read "partially" if the buffer
is to small for the packet. According to
http://gafferongames.com/networking-for-game-programmers/sending-and-receiving-packets/this
should not happen.

In my case I send [99u8,99u8] which should be of size 512 and my buffer is
[0u8,..1] which should be of size 256. But it still receives the first 99.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/7fa0ab51/attachment.html>

From jeaye at arrownext.com  Mon Sep 16 14:31:48 2013
From: jeaye at arrownext.com (Jeaye)
Date: Mon, 16 Sep 2013 14:31:48 -0700
Subject: [rust-dev] Is our UdpSocket misbehaving?
In-Reply-To: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
References: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
Message-ID: <20130916213148.GA19381@arrow.hsd1.ca.comcast.net>

This sounds like reasonable behavior to me. Keep in mind that your
data, [99u8, 99u8] has type [u8, ..2] and size size of 2 bytes, not
the 512 you're expecing. 

On Mon, Sep 16, 2013 at 11:06:51PM +0200, Maik Klein wrote:
>    [1]https://gist.github.com/MaikKlein/6586333
>    Basically what happens is that a packet is read "partially" if the
>    buffer is to small for the packet. According to
>    [2]http://gafferongames.com/networking-for-game-programmers/sending-and
>    -receiving-packets/ this should not happen.
>    In my case I send [99u8,99u8] which should be of size 512 and my buffer
>    is [0u8,..1] which should be of size 256. But it still receives the
>    first 99.
> 
> References
> 
>    1. https://gist.github.com/MaikKlein/6586333
>    2. http://gafferongames.com/networking-for-game-programmers/sending-and-receiving-packets/

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From luis at debethencourt.com  Mon Sep 16 14:57:06 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Mon, 16 Sep 2013 17:57:06 -0400
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <52377207.3050706@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
	<52377207.3050706@mozilla.com>
Message-ID: <CAPA4HGUxB4kahMq542Zj6qRNN5SWgsUCKBtZxPa=f0bmcxtyxg@mail.gmail.com>

Congrats Alex! and thank you :)

It is fantastic to see Rust and its community grow at such an amazing pace.

Luis


On 16 September 2013 17:03, Brian Anderson <banderson at mozilla.com> wrote:

> On 09/16/2013 01:43 PM, Alex Crichton wrote:
>
>> Greetings rust-dev! I wanted to announce to everyone that today is my
>> first day at Mozilla as an engineer working on Rust!
>>
>>
> Welcome aboard!
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/6cd9d4da/attachment.html>

From banderson at mozilla.com  Mon Sep 16 15:18:48 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 16 Sep 2013 15:18:48 -0700
Subject: [rust-dev] Is our UdpSocket misbehaving?
In-Reply-To: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
References: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
Message-ID: <523783C8.70602@mozilla.com>

On 09/16/2013 02:06 PM, Maik Klein wrote:
> https://gist.github.com/MaikKlein/6586333
>
> Basically what happens is that a packet is read "partially" if the 
> buffer is to small for the packet. According to 
> http://gafferongames.com/networking-for-game-programmers/sending-and-receiving-packets/ 
> this should not happen.
>
> In my case I send [99u8,99u8] which should be of size 512 and my 
> buffer is [0u8,..1] which should be of size 256. But it still receives 
> the first 99.

I'm not sure what is correct, but this behavior appears to be inherited 
from libuv. I wonder if the rest of the packet is delivered in 
subsequent reads or if part of the packet is just discarded.

From vadimcn at gmail.com  Mon Sep 16 15:36:48 2013
From: vadimcn at gmail.com (Vadim)
Date: Mon, 16 Sep 2013 15:36:48 -0700
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
Message-ID: <CADecdi+64syOeanZuZe1XtYjkxUBde3uHfCS6xxUZyYzD4ESGg@mail.gmail.com>

Congrats Alex!


On Mon, Sep 16, 2013 at 1:43 PM, Alex Crichton <acrichton at mozilla.com>wrote:

> Greetings rust-dev! I wanted to announce to everyone that today is my
> first day at Mozilla as an engineer working on Rust!
>
> I started using Rust last December for a project of mine, and once I got
> fed up with compiler errors I decided to try my hand at improving the
> compiler itself. The community was incredibly helpful in getting me on my
> feet contributing to rust, and it's been awesome seeing how rust and the
> community around it have evolved since I started working on it.
>
> I'm incredibly excited to have the opportunity to work on Rust with
> everyone who's been contributing, and I can't wait to help Rust reach 1.0
> even faster.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/399df58e/attachment-0001.html>

From ecreed at cs.washington.edu  Mon Sep 16 15:42:53 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 16 Sep 2013 15:42:53 -0700
Subject: [rust-dev] Is our UdpSocket misbehaving?
In-Reply-To: <523783C8.70602@mozilla.com>
References: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
	<523783C8.70602@mozilla.com>
Message-ID: <CANbMr6HtbOvYNOXnUD750F6ZB-i=5dPtD71ShiZO8+CiNV3JLg@mail.gmail.com>

I left a XXX about this
here<https://github.com/mozilla/rust/blob/master/src/libstd/rt/uv/uvio.rs#L958>.
I'm pretty sure libuv drops the remainder of the packet, but I haven't
confirmed that.
I think the best way to deal with this is to raise a PartialPacketRead
condition.


On Mon, Sep 16, 2013 at 3:18 PM, Brian Anderson <banderson at mozilla.com>wrote:

> On 09/16/2013 02:06 PM, Maik Klein wrote:
>
>> https://gist.github.com/**MaikKlein/6586333<https://gist.github.com/MaikKlein/6586333>
>>
>> Basically what happens is that a packet is read "partially" if the buffer
>> is to small for the packet. According to http://gafferongames.com/**
>> networking-for-game-**programmers/sending-and-**receiving-packets/<http://gafferongames.com/networking-for-game-programmers/sending-and-receiving-packets/>this should not happen.
>>
>> In my case I send [99u8,99u8] which should be of size 512 and my buffer
>> is [0u8,..1] which should be of size 256. But it still receives the first
>> 99.
>>
>
> I'm not sure what is correct, but this behavior appears to be inherited
> from libuv. I wonder if the rest of the packet is delivered in subsequent
> reads or if part of the packet is just discarded.
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/262f4073/attachment.html>

From jfager at gmail.com  Mon Sep 16 15:43:47 2013
From: jfager at gmail.com (Jason Fager)
Date: Mon, 16 Sep 2013 18:43:47 -0400
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <CADecdi+64syOeanZuZe1XtYjkxUBde3uHfCS6xxUZyYzD4ESGg@mail.gmail.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
	<CADecdi+64syOeanZuZe1XtYjkxUBde3uHfCS6xxUZyYzD4ESGg@mail.gmail.com>
Message-ID: <CAFEbTaUGGQyx-qcDDyUrnNpY+5WWj8G2yXa7Ls-OYtRb4B++WA@mail.gmail.com>

Congrats, Alex, well deserved!  With how active you are on the project I
thought you were already on the team :)

On Monday, September 16, 2013, Vadim wrote:

> Congrats Alex!
>
>
> On Mon, Sep 16, 2013 at 1:43 PM, Alex Crichton <acrichton at mozilla.com<javascript:_e({}, 'cvml', 'acrichton at mozilla.com');>
> > wrote:
>
>> Greetings rust-dev! I wanted to announce to everyone that today is my
>> first day at Mozilla as an engineer working on Rust!
>>
>> I started using Rust last December for a project of mine, and once I got
>> fed up with compiler errors I decided to try my hand at improving the
>> compiler itself. The community was incredibly helpful in getting me on my
>> feet contributing to rust, and it's been awesome seeing how rust and the
>> community around it have evolved since I started working on it.
>>
>> I'm incredibly excited to have the opportunity to work on Rust with
>> everyone who's been contributing, and I can't wait to help Rust reach 1.0
>> even faster.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/34b66066/attachment.html>

From banderson at mozilla.com  Mon Sep 16 15:53:04 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 16 Sep 2013 15:53:04 -0700
Subject: [rust-dev] Is our UdpSocket misbehaving?
In-Reply-To: <CANbMr6HtbOvYNOXnUD750F6ZB-i=5dPtD71ShiZO8+CiNV3JLg@mail.gmail.com>
References: <CAHOWPUJjH3k1MptRbRjbLrpZ47sG5wC84e3qyRwZxnd89+reig@mail.gmail.com>
	<523783C8.70602@mozilla.com>
	<CANbMr6HtbOvYNOXnUD750F6ZB-i=5dPtD71ShiZO8+CiNV3JLg@mail.gmail.com>
Message-ID: <52378BD0.5000100@mozilla.com>

On 09/16/2013 03:42 PM, Eric Reed wrote:
> I left a XXX about this here 
> <https://github.com/mozilla/rust/blob/master/src/libstd/rt/uv/uvio.rs#L958>. 
> I'm pretty sure libuv drops the remainder of the packet, but I haven't 
> confirmed that.
> I think the best way to deal with this is to raise a PartialPacketRead 
> condition.
>

Thanks, Eric. I opened this issue 
https://github.com/mozilla/rust/issues/9238
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/37f35bf5/attachment.html>

From olson.jeffery at gmail.com  Mon Sep 16 17:35:41 2013
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Mon, 16 Sep 2013 17:35:41 -0700
Subject: [rust-dev] Rust session at Seattle CodeCamp, Sep 28th 2013
Message-ID: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>

Howdy,

I've proposed, and received approval for, a session on Rust (clever titled
"The Rust Programming Language") for the upcoming 2013 Seattle CodeCamp.
The event is being held in Redmond, WA on the 28th of September at DigiPen.

If you happen to be in the area and have nothing better to do on a
Saturday, please drop in and hang out with your fellow rust programmer(s)
and help minister to the heathens (joking! great crowd, truly).

Session info at: https://seattle.codecamp.us/Sessions/Details/2366

Registration, schedule, etc also available at the link cited.

Cheers,
Jeff
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/87eed465/attachment.html>

From vadimcn at gmail.com  Mon Sep 16 17:39:33 2013
From: vadimcn at gmail.com (Vadim)
Date: Mon, 16 Sep 2013 17:39:33 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CADecdi+qVFb9JTB9d=5eKu1eG6CbYGs3=W9bPcWG7Y4eZ4YA1A@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
	<CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
Message-ID: <CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>

I've created a patch which allows to build Rust on latest mingw without
manual patching:
https://github.com/vadimcn/rust/commit/49bbb0a219883f2af6b71c58faad7c009aed159a
With this, Rust builds and passes all tests, except for the ones caused by GCC
ABI change <https://github.com/mozilla/rust/issues/9205>.

Brian, would it be acceptable to commit this in order to unblock migration
to latest mingw?

Vadim


On Mon, Sep 16, 2013 at 7:25 AM, Thad Guidry <thadguidry at gmail.com> wrote:

> Good Job on documenting the build steps, Dandy !  Closer and closer we get
> to flawless building on Windows.
>
>
> On Mon, Sep 16, 2013 at 1:51 AM, Aaron Dandy <aaron.dandy at live.com> wrote:
>
>> Klutzy helped me through a bunch of issues tonight and I am now building
>> stage 2 from HEAD using GCC 4.8. I put the procedure I used up on the
>> GitHub wiki for others to try and also linked it from the main getting
>> started page: "
>> https://github.com/mozilla/rust/wiki/Note-Building-Rust-Before-0.8-on-Windows-Systems .
>> Huge thanks for Klutzy helping me out.
>>
>> Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin
>> $ rustc.exe hello.rs
>>
>> Aaron at GIR /c/projects/rust/i686-pc-mingw32/stage2/bin
>> $ hello
>> Hello, world.
>>
>> > Date: Sun, 15 Sep 2013 14:33:41 +0900
>> > From: klutzytheklutzy at gmail.com
>> > To: vadimcn at gmail.com
>> > CC: rust-dev at mozilla.org
>> > Subject: Re: [rust-dev] Windows Users can build Rust properly again !
>>
>> >
>> > The error is due to abi change of win32 gcc. reported here:
>> > https://github.com/mozilla/rust/issues/9205
>> >
>> > On Sat, Sep 14, 2013 at 4:52 PM, klutzy <klutzytheklutzy at gmail.com>
>> wrote:
>> > > I've finished `make` on gcc 4.8.1, but `make check-fast` failed:
>> > >
>> > > task <unnamed> failed at 'assertion failed: `(left == right) &&
>> > > (right == left)`
>> > > (left: `t_317::TwoU64s{one: 98784247808u64, two: 257698037760u64}`,
>> > > right: `t_317::TwoU64s{one: 22u64, two: 94489280535u64}`)',
>> > >
>> C:\home\stone\rust-vanilla\src\test\run-pass\extern-pass-TwoU64s-ref.rs:27
>> > > make: ***
>> [i686-pc-mingw32/test/run_pass_stage2_driver-i686-pc-mingw32.out]
>> > > Error 101
>> > >
>> > > I previously met this when I tested on mingw-w64/32bit.
>> > > (https://github.com/mozilla/rust/issues/8996)
>> > > Seems like the failure is related to recent gcc.
>> > >
>> > >
>> > > On Sat, Sep 14, 2013 at 3:35 PM, klutzy <klutzytheklutzy at gmail.com>
>> wrote:
>> > >> some more explanation:
>> > >>
>> > >> #include <fenv.h> causes /lib/gcc/mingw32/<ver>/include/c++/fenv.h to
>> > >> be included.
>> > >> The header contains:
>> > >>
>> > >> #include <bits/c++config.h>
>> > >> #if _GLIBCXX_HAVE_FENV_H
>> > >> # include_next <fenv.h>
>> > >> #endif
>> > >>
>> > >> where bits/c++config.h is at
>> /lib/gcc/mingw32/<ver>/include/c++/mingw32.
>> > >> However, for some reason (I don't know), they removed `#define
>> > >> _GLIBCXX_HAVE_FENV_H 1` somewhere between 4.6.2 and 4.8.1.
>> > >> so `#include_next <fenv.h>` does not occur, which is
>> > >> `/include/fenv.h`. It contains some definitions e.g. `FE_ALL_EXCEPT`.
>> > >>
>> > >> On Sat, Sep 14, 2013 at 3:25 PM, klutzy <klutzytheklutzy at gmail.com>
>> wrote:
>> > >>> I've solved it some minutes ago :)
>> > >>>
>> > >>> <klutzy> at
>> /path/to/mingw/lib/gcc/mingw32/<ver>/include/c++/mingw32/bits/c++config.h:
>> > >>> <klutzy> there is #define _GLIBCXX_HAVE_FENV_H 1 in 4.6.1's header
>> > >>> <klutzy> but there isn't [such #define] in 4.8.1 header.
>> > >>> <klutzy> this causes /include/fenv.h not included when llvm does
>> > >>> #include <fenv.h>
>> > >>>
>> > >>> The c++config.h has such lines:
>> > >>> /* Define to 1 if you have the <fenv.h> header file. */
>> > >>> /* #undef _GLIBCXX_HAVE_FENV_H */
>> > >>>
>> > >>> I added `#define _GLIBCXX_HAVE_FENV_H 1` at the file directly, and
>> it
>> > >>> works. We can't recommend users to do this hack though.
>> > >>>
>> > >>>
>> > >>>
>> > >>> On Sat, Sep 14, 2013 at 3:21 PM, Vadim <vadimcn at gmail.com> wrote:
>> > >>>> Yes, but we can't check this into Rust repo. Maybe it can be
>> worked around
>> > >>>> by -DWSAPOLLFD somewhere in makefiles...
>> > >>>>
>> > >>>> And just as a heads-up, these seems to be another problem,- with
>> LLVM:
>> > >>>> http://sourceforge.net/p/mingw/bugs/2043/
>> > >>>>
>> > >>>> Vadim
>> > >>>>
>> > >>>> On Sep 13, 2013, at 9:16 PM, klutzy k <klutzytheklutzy at gmail.com>
>> wrote:
>> > >>>>
>> > >>>> Mingw added new winapi at mswsock.h:
>> > >>>>
>> > >>>> #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
>> > >>>> int WSAAPI WSAPoll(WSAPOLLFD, ULONG, INT);
>> > >>>>
>> > >>>> #endif
>> > >>>>
>> > >>>> but they forgot to add definition of WSAPOLLFD.
>> > >>>>
>> > >>>> Someone submitted patch at
>> http://sourceforge.net/p/mingw/bugs/1980/
>> > >>>> but seems like it's not on mainstream.
>> > >>>>
>> > >>>> Anyway, we (including libuv) don't use the api. Removing the
>> codeblock helps
>> > >>>> us.
>> > >>>>
>> > >>>> On Fri, Sep 13, 2013 at 3:19 PM, Vadim <vadimcn at gmail.com> wrote:
>> > >>>>
>> > >>>> Hmm. Looks like mingw released a new version with gcc 4.8 and that
>> somehow
>> > >>>>
>> > >>>> broke mswsock.h (though the file didn't change).
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> On Thu, Sep 12, 2013 at 6:56 PM, Thad Guidry <thadguidry at gmail.com>
>> wrote:
>> > >>>>
>> > >>>>
>> > >>>> Doesn't work...
>> > >>>>
>> > >>>>
>> > >>>> Errors regarding libuv and mswsock...
>> > >>>>
>> > >>>>
>> > >>>> http://pastebin.mozilla.org/3038909
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> On Thu, Sep 12, 2013 at 5:06 PM, Vadim <vadimcn at gmail.com> wrote:
>> > >>>>
>> > >>>>
>> > >>>> Hi Brian,
>> > >>>>
>> > >>>>
>> > >>>> Actually, I would argue that these changes *should* be made before
>> 0.8
>> > >>>>
>> > >>>> release in order to smoothen the path of people who will install
>> 0.8 to try
>> > >>>>
>> > >>>> it out.
>> > >>>>
>> > >>>>
>> > >>>> Regarding the work to be done, as far as I know all you need is:
>> > >>>>
>> > >>>> 1. Save libgcc_s_dw2-1.dll and libstdc++-6.dll from %mingw%\bin
>> > >>>>
>> > >>>> 2. "mingw-get update"
>> > >>>>
>> > >>>> 3. "mingw-get upgrade"
>> > >>>>
>> > >>>> 4. run %rust%\configure (not sure if actually needed, but won't
>> hurt)
>> > >>>>
>> > >>>> 5. "make clean"
>> > >>>>
>> > >>>> 6. "make check", which will fail at building stage1 std crate
>> because
>> > >>>>
>> > >>>> step 3 upgraded libgcc and libstdc++ and stage0 compiler needs
>> them.
>> > >>>>
>> > >>>> 7. copy dlls saved in step 1 into
>> %rust%\build\i686-pc-mingw32\stage0\bin
>> > >>>>
>> > >>>> 8. "make check" again, which should succeed this time
>> > >>>>
>> > >>>>
>> > >>>> Can somebody please verify that this works?
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> Re mingw-w64: sort of works, however its' phtreads implementation
>> seems
>> > >>>>
>> > >>>> to be buggy. Also see this thread. I don't think we'll should
>> migrate to
>> > >>>>
>> > >>>> it just yet.
>> > >>>>
>> > >>>>
>> > >>>> Vadim
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> On Thu, Sep 12, 2013 at 2:10 PM, Brian Anderson <
>> banderson at mozilla.com>
>> > >>>>
>> > >>>> wrote:
>> > >>>>
>> > >>>>
>> > >>>> On 09/12/2013 12:39 PM, Thad Guidry wrote:
>> > >>>>
>> > >>>>
>> > >>>> Yeah, there should not be a reason anymore, if I am correct, to
>> not have
>> > >>>>
>> > >>>> GCC 4.7 in MinGW for Rust Windows users anymore. I will give that
>> a try
>> > >>>>
>> > >>>> also , and if it works, then we can close out (#8598). (I also
>> would like
>> > >>>>
>> > >>>> to get rid of the 4.5 downgrade needed).... but that does need
>> more testing
>> > >>>>
>> > >>>> from the core Rust team and others.
>> > >>>>
>> > >>>>
>> > >>>> It's something that Brian has been counting on me to help make
>> happen,
>> > >>>>
>> > >>>> and Alex is also contributing to some of that effort by fixing
>> various LLVM
>> > >>>>
>> > >>>> build issues that affect Windows Rust users as you mention in
>> (#8598).
>> > >>>>
>> > >>>>
>> > >>>> Agreed, if a new stage0 compiler snapshot can be created, then we
>> should
>> > >>>>
>> > >>>> be in the clear to also close out #5878.
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> Thanks for everybody's amazing contributions to our Windows
>> support. If
>> > >>>>
>> > >>>> somebody makes the changes necessary to work with a newer
>> toolchain then we
>> > >>>>
>> > >>>> will upgrade the bots. It's unlikely we can do this before 0.8
>> though, due
>> > >>>>
>> > >>>> in two weeks.
>> > >>>>
>> > >>>>
>> > >>>> I gather that some folks would like to switch to the mingw-w64
>> toolchain
>> > >>>>
>> > >>>> as well. Is that in the cards here?
>> > >>>>
>> > >>>>
>> > >>>> _______________________________________________
>> > >>>>
>> > >>>> Rust-dev mailing list
>> > >>>>
>> > >>>> Rust-dev at mozilla.org
>> > >>>>
>> > >>>> https://mail.mozilla.org/listinfo/rust-dev
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> _______________________________________________
>> > >>>>
>> > >>>> Rust-dev mailing list
>> > >>>>
>> > >>>> Rust-dev at mozilla.org
>> > >>>>
>> > >>>> https://mail.mozilla.org/listinfo/rust-dev
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> --
>> > >>>>
>> > >>>> -Thad
>> > >>>>
>> > >>>> Thad on Freebase.com
>> > >>>>
>> > >>>> Thad on LinkedIn
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>>
>> > >>>> _______________________________________________
>> > >>>>
>> > >>>> Rust-dev mailing list
>> > >>>>
>> > >>>> Rust-dev at mozilla.org
>> > >>>>
>> > >>>> https://mail.mozilla.org/listinfo/rust-dev
>> > >>>>
>> > >>>>
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/5241b10f/attachment-0001.html>

From bjzaba at yahoo.com.au  Mon Sep 16 17:56:34 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Tue, 17 Sep 2013 10:56:34 +1000
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
Message-ID: <854C5FA3-770D-4455-8545-886C97CC1077@yahoo.com.au>

Congratulations! You've already made some significant contributions to Rust, and we greatly appreciate your efforts. Could think of nobody better to be working on Rust full time.

~Brendan

On 17/09/2013, at 6:43 AM, Alex Crichton <acrichton at mozilla.com> wrote:

> Greetings rust-dev! I wanted to announce to everyone that today is my first day at Mozilla as an engineer working on Rust!
> 
> I started using Rust last December for a project of mine, and once I got fed up with compiler errors I decided to try my hand at improving the compiler itself. The community was incredibly helpful in getting me on my feet contributing to rust, and it's been awesome seeing how rust and the community around it have evolved since I started working on it.
> 
> I'm incredibly excited to have the opportunity to work on Rust with everyone who's been contributing, and I can't wait to help Rust reach 1.0 even faster.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Mon Sep 16 17:58:15 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 16 Sep 2013 17:58:15 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
	<CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
	<CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>
Message-ID: <5237A927.30309@mozilla.com>

On 09/16/2013 05:39 PM, Vadim wrote:
> I've created a patch which allows to build Rust on latest mingw 
> without manual patching:
> https://github.com/vadimcn/rust/commit/49bbb0a219883f2af6b71c58faad7c009aed159a
> With this, Rust builds and passes all tests, except for the ones 
> caused by GCC ABI change<https://github.com/mozilla/rust/issues/9205>.
>
> Brian, would it be acceptable to commit this in order to unblock 
> migration to latest mingw?
>
>

Yes, but please add some comments explaining what's going on.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/51b2ea1a/attachment.html>

From vadimcn at gmail.com  Mon Sep 16 18:20:12 2013
From: vadimcn at gmail.com (Vadim)
Date: Mon, 16 Sep 2013 18:20:12 -0700
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <5237A927.30309@mozilla.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
	<CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
	<CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>
	<5237A927.30309@mozilla.com>
Message-ID: <CADecdiJThEL2Rrpeu-B74Q_KBrOT_2bAbnkx8Qcv1w9p93AveQ@mail.gmail.com>

Ok.  How do you want to go about upgrading build bots once this is in?

BTW, looks like it is no longer possible to downgrade mingw to gcc 4.5.
"mingw-get upgrade "g++<4.6"" says "mingw-get: *** ERROR *** there is no
release matching g++<4.6"...
I think we should save a copy of existing mingw folder in case unexpected
problems are discovered.

Vadim

On Mon, Sep 16, 2013 at 5:58 PM, Brian Anderson <banderson at mozilla.com>wrote:

>  On 09/16/2013 05:39 PM, Vadim wrote:
>
>  I've created a patch which allows to build Rust on latest mingw without
> manual patching:
>
> https://github.com/vadimcn/rust/commit/49bbb0a219883f2af6b71c58faad7c009aed159a
>  With this, Rust builds and passes all tests, except for the ones caused
> by GCC ABI change <https://github.com/mozilla/rust/issues/9205>.
>
>  Brian, would it be acceptable to commit this in order to unblock
> migration to latest mingw?
>
>
>
> Yes, but please add some comments explaining what's going on.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130916/93c8786f/attachment.html>

From corey at octayn.net  Mon Sep 16 19:12:11 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 16 Sep 2013 22:12:11 -0400
Subject: [rust-dev] Rust session at Seattle CodeCamp, Sep 28th 2013
In-Reply-To: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>
References: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>
Message-ID: <CA++BO6Qu1rGscs-XFPpuSBNrz343xGmMMatm0J1sy-WQViCdQg@mail.gmail.com>

Awesome! Do you know if it will be recorded?

On Mon, Sep 16, 2013 at 8:35 PM, Jeffery Olson <olson.jeffery at gmail.com> wrote:
> Howdy,
>
> I've proposed, and received approval for, a session on Rust (clever titled
> "The Rust Programming Language") for the upcoming 2013 Seattle CodeCamp. The
> event is being held in Redmond, WA on the 28th of September at DigiPen.
>
> If you happen to be in the area and have nothing better to do on a Saturday,
> please drop in and hang out with your fellow rust programmer(s) and help
> minister to the heathens (joking! great crowd, truly).
>
> Session info at: https://seattle.codecamp.us/Sessions/Details/2366
>
> Registration, schedule, etc also available at the link cited.
>
> Cheers,
> Jeff
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From michaelwoerister at gmail.com  Tue Sep 17 01:10:21 2013
From: michaelwoerister at gmail.com (Michael Woerister)
Date: Tue, 17 Sep 2013 10:10:21 +0200
Subject: [rust-dev] Rust's newest full-time Engineer
In-Reply-To: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
References: <33B44477-E1E1-44E8-A89F-26B828FF9692@mozilla.com>
Message-ID: <52380E6D.5090707@gmail.com>

Hi Alex,
I too applied for the position and after reading through some of your 
pull requests and comments mid-August I remember thinking to myself 
"man, I hope that guy hasn't applied too" :P Your work is awesome! 
Congratulations :)

Cheers,
Michael

On 16.09.2013 22:43, Alex Crichton wrote:
> Greetings rust-dev! I wanted to announce to everyone that today is my first day at Mozilla as an engineer working on Rust!
>
> I started using Rust last December for a project of mine, and once I got fed up with compiler errors I decided to try my hand at improving the compiler itself. The community was incredibly helpful in getting me on my feet contributing to rust, and it's been awesome seeing how rust and the community around it have evolved since I started working on it.
>
> I'm incredibly excited to have the opportunity to work on Rust with everyone who's been contributing, and I can't wait to help Rust reach 1.0 even faster.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From gokcehankara at gmail.com  Tue Sep 17 04:34:10 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 17 Sep 2013 14:34:10 +0300
Subject: [rust-dev] implicit vs explicit generic bounds
Message-ID: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>

Hello,

I have met rust a few days ago and let me pay my respects first for making
such a powerful language. I really hope to succeed making some contribution
in the upcoming days.

I was reading the tutorial (http://static.rust-lang.org/doc/tutorial.html)
specifically the section 16.3 and I was wondering if there's a rationale
behind making generic bounds explicit. For example in C++ I can do:

    // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat -g &&
./a.out
    #include <iostream>
    #include <vector>
    using namespace std;

    class Klass {
    public:
      void print() { cout << "printing the thing" << endl; }
    };

    template <typename T> void print_all(vector<T> &things) {
      for (auto thing : things) {
        thing.print();
      }
    }

    int main() {
      vector<Klass> v1;

      v1.push_back(Klass());
      v1.push_back(Klass());
      v1.push_back(Klass());

      print_all(v1);  // no errors

      vector<int> v2;

      v2.push_back(1);
      v2.push_back(2);
      v2.push_back(3);

      print_all(v2); // /tmp/asd.cc:18:10: error: member reference base
type 'int'
                     // is not a structure or union/tmp/asd.cc:37:3: note:
in
                     // instantiation of function template specialization
                     // 'draw_all<int>' requested here

      return 0;
    }

and it gives me the necessary error at compile time. To my limited
knowledge, this is also statically dispatched so should not cause any
overhead.

I haven't used Haskell much but I know a little bit of Scala. In Scala you
need to be explicit because generics are compiled once to run with
different types. As far as I understand, rust compiles different copies for
each type (monomorphizing?) just like C++ so it might be possible to be
implicit in rust as well.

Having said that, I'm not sure if being explicit is necessarily a bad
thing. It sure looks good for documenting and I haven't thought of any
cases where it falls short except maybe when a function of the same name is
implemented in different traits.

Am I failing to see the obvious?

Thanks in advance,
Gokcehan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130917/3ad2c33c/attachment-0001.html>

From pnkfelix at mozilla.com  Tue Sep 17 05:28:14 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Tue, 17 Sep 2013 14:28:14 +0200
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
Message-ID: <52384ADE.3060603@mozilla.com>

Gokcehan-

My understanding is that C++, due to its policy of SFINAE [1], usually 
provides error feedback after the template has been fully instantiated 
and the fully instantiated version fails to compile. This can lead to 
hard to debug compile-time failures.

Good compilers can help with dissecting the output you get in this case, 
but it is still a real pain to decode in my experience, especially when 
you have nests of template code written in terms of other template 
code.  Since the template parameters do not have bounds, it is not 
possible for a compiler to provide any error feedback given a template 
definition alone (with no client code), and its difficult for the 
compiler to provide good error feedback that is described solely in 
terms of the definition: you are doomed to thinking about the 
intermingling of the definition with the particular instantiation.

Requiring explicit bounds means that the compiler can provide good error 
messages at the point where the parameterized class is *defined* (even 
in the absence of client code!) rather than delaying to the point where 
the parmeterized class is fully instantiated.  This provides me with 
more confidence that the parametric code I write is actually going to 
compose properly with other implementations of the trait-bounds in terms 
of which I have written my code.

That advantage alone is enough to justify this choice for *me*. There 
may be other justifications that I am overlooking.

(It may also be the case that I'm ignorant of what the best C++ tools 
today do, though I'm pretty sure that these drawbacks are consequences 
of core C++ design.)

Cheers,
-Felix

[1] SFINAE: 
http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error

On 17/09/2013 13:34, Gokcehan Kara wrote:
> Hello,
>
> I have met rust a few days ago and let me pay my respects first for 
> making such a powerful language. I really hope to succeed making some 
> contribution in the upcoming days.
>
> I was reading the tutorial 
> (http://static.rust-lang.org/doc/tutorial.html) specifically the 
> section 16.3 and I was wondering if there's a rationale behind making 
> generic bounds explicit. For example in C++ I can do:
>
>     // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat -g && 
> ./a.out
>     #include <iostream>
>     #include <vector>
>     using namespace std;
>     class Klass {
>     public:
>       void print() { cout << "printing the thing" << endl; }
>     };
>     template <typename T> void print_all(vector<T> &things) {
>       for (auto thing : things) {
>         thing.print();
>       }
>     }
>     int main() {
>       vector<Klass> v1;
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>       print_all(v1);  // no errors
>       vector<int> v2;
>       v2.push_back(1);
>       v2.push_back(2);
>       v2.push_back(3);
>       print_all(v2); // /tmp/asd.cc:18:10: error: member reference 
> base type 'int'
>                      // is not a structure or union/tmp/asd.cc:37:3: 
> note: in
>                      // instantiation of function template specialization
>                      // 'draw_all<int>' requested here
>       return 0;
>     }
>
> and it gives me the necessary error at compile time. To my limited 
> knowledge, this is also statically dispatched so should not cause any 
> overhead.
>
> I haven't used Haskell much but I know a little bit of Scala. In Scala 
> you need to be explicit because generics are compiled once to run with 
> different types. As far as I understand, rust compiles different 
> copies for each type (monomorphizing?) just like C++ so it might be 
> possible to be implicit in rust as well.
>
> Having said that, I'm not sure if being explicit is necessarily a bad 
> thing. It sure looks good for documenting and I haven't thought of any 
> cases where it falls short except maybe when a function of the same 
> name is implemented in different traits.
>
> Am I failing to see the obvious?
>
> Thanks in advance,
> Gokcehan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130917/e716291e/attachment.html>

From gokcehankara at gmail.com  Tue Sep 17 06:25:57 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 17 Sep 2013 16:25:57 +0300
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <52384ADE.3060603@mozilla.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
	<52384ADE.3060603@mozilla.com>
Message-ID: <CAEWroOjbOiYt1xnOm_YkT2k37RZ1YROwK989keGGke4EsQJXOA@mail.gmail.com>

Felix, C++ template errors are indeed a joy(!) to deal with. I guess I also
would rather be explicit than to have cryptic error messages that are pages
long. You're also right about the absence of errors without the client code
which makes sense in a context of safety.

It was the first time I heard about SFINAE. It reminds me of
turing-completeness proofs of C++ templates. Does that mean rust generics
are not turing complete?

Gokcehan


On Tue, Sep 17, 2013 at 3:28 PM, Felix S. Klock II <pnkfelix at mozilla.com>wrote:

>  Gokcehan-
>
> My understanding is that C++, due to its policy of SFINAE [1], usually
> provides error feedback after the template has been fully instantiated and
> the fully instantiated version fails to compile.  This can lead to hard to
> debug compile-time failures.
>
> Good compilers can help with dissecting the output you get in this case,
> but it is still a real pain to decode in my experience, especially when you
> have nests of template code written in terms of other template code.  Since
> the template parameters do not have bounds, it is not possible for a
> compiler to provide any error feedback given a template definition alone
> (with no client code), and its difficult for the compiler to provide good
> error feedback that is described solely in terms of the definition: you are
> doomed to thinking about the intermingling of the definition with the
> particular instantiation.
>
> Requiring explicit bounds means that the compiler can provide good error
> messages at the point where the parameterized class is *defined* (even in
> the absence of client code!) rather than delaying to the point where the
> parmeterized class is fully instantiated.  This provides me with more
> confidence that the parametric code I write is actually going to compose
> properly with other implementations of the trait-bounds in terms of which I
> have written my code.
>
> That advantage alone is enough to justify this choice for *me*.  There may
> be other justifications that I am overlooking.
>
> (It may also be the case that I'm ignorant of what the best C++ tools
> today do, though I'm pretty sure that these drawbacks are consequences of
> core C++ design.)
>
> Cheers,
> -Felix
>
> [1] SFINAE:
> http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error
>
>
> On 17/09/2013 13:34, Gokcehan Kara wrote:
>
> Hello,
>
>  I have met rust a few days ago and let me pay my respects first for
> making such a powerful language. I really hope to succeed making some
> contribution in the upcoming days.
>
>  I was reading the tutorial (http://static.rust-lang.org/doc/tutorial.html)
> specifically the section 16.3 and I was wondering if there's a rationale
> behind making generic bounds explicit. For example in C++ I can do:
>
>      // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat -g &&
> ./a.out
>     #include <iostream>
>     #include <vector>
>     using namespace std;
>
>     class Klass {
>     public:
>       void print() { cout << "printing the thing" << endl; }
>     };
>
>     template <typename T> void print_all(vector<T> &things) {
>       for (auto thing : things) {
>         thing.print();
>       }
>     }
>
>     int main() {
>       vector<Klass> v1;
>
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>
>       print_all(v1);  // no errors
>
>       vector<int> v2;
>
>       v2.push_back(1);
>       v2.push_back(2);
>       v2.push_back(3);
>
>       print_all(v2); // /tmp/asd.cc:18:10: error: member reference base
> type 'int'
>                      // is not a structure or union/tmp/asd.cc:37:3: note:
> in
>                      // instantiation of function template specialization
>                      // 'draw_all<int>' requested here
>
>       return 0;
>     }
>
>  and it gives me the necessary error at compile time. To my limited
> knowledge, this is also statically dispatched so should not cause any
> overhead.
>
>  I haven't used Haskell much but I know a little bit of Scala. In Scala
> you need to be explicit because generics are compiled once to run with
> different types. As far as I understand, rust compiles different copies for
> each type (monomorphizing?) just like C++ so it might be possible to be
> implicit in rust as well.
>
>  Having said that, I'm not sure if being explicit is necessarily a bad
> thing. It sure looks good for documenting and I haven't thought of any
> cases where it falls short except maybe when a function of the same name is
> implemented in different traits.
>
>  Am I failing to see the obvious?
>
>  Thanks in advance,
> Gokcehan
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130917/ef103e5a/attachment.html>

From pnkfelix at mozilla.com  Tue Sep 17 06:29:37 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Tue, 17 Sep 2013 15:29:37 +0200
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <CAEWroOjbOiYt1xnOm_YkT2k37RZ1YROwK989keGGke4EsQJXOA@mail.gmail.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
	<52384ADE.3060603@mozilla.com>
	<CAEWroOjbOiYt1xnOm_YkT2k37RZ1YROwK989keGGke4EsQJXOA@mail.gmail.com>
Message-ID: <52385941.6070500@mozilla.com>

Gokcehan (cc'ing rust-dev)-

Correct, rust generics are not Turing-complete.  (To my knowledge; I 
don't think we've written the termination proof for the type-checker 
yet.  :)

Cheers,
-Felix

On 17/09/2013 15:25, Gokcehan Kara wrote:
> Felix, C++ template errors are indeed a joy(!) to deal with. I guess I 
> also would rather be explicit than to have cryptic error messages that 
> are pages long. You're also right about the absence of errors without 
> the client code which makes sense in a context of safety.
>
> It was the first time I heard about SFINAE. It reminds me of 
> turing-completeness proofs of C++ templates. Does that mean rust 
> generics are not turing complete?
>
> Gokcehan
>
>
> On Tue, Sep 17, 2013 at 3:28 PM, Felix S. Klock II 
> <pnkfelix at mozilla.com <mailto:pnkfelix at mozilla.com>> wrote:
>
>     Gokcehan-
>
>     My understanding is that C++, due to its policy of SFINAE [1],
>     usually provides error feedback after the template has been fully
>     instantiated and the fully instantiated version fails to compile. 
>     This can lead to hard to debug compile-time failures.
>
>     Good compilers can help with dissecting the output you get in this
>     case, but it is still a real pain to decode in my experience,
>     especially when you have nests of template code written in terms
>     of other template code. Since the template parameters do not have
>     bounds, it is not possible for a compiler to provide any error
>     feedback given a template definition alone (with no client code),
>     and its difficult for the compiler to provide good error feedback
>     that is described solely in terms of the definition: you are
>     doomed to thinking about the intermingling of the definition with
>     the particular instantiation.
>
>     Requiring explicit bounds means that the compiler can provide good
>     error messages at the point where the parameterized class is
>     *defined* (even in the absence of client code!) rather than
>     delaying to the point where the parmeterized class is fully
>     instantiated.  This provides me with more confidence that the
>     parametric code I write is actually going to compose properly with
>     other implementations of the trait-bounds in terms of which I have
>     written my code.
>
>     That advantage alone is enough to justify this choice for *me*. 
>     There may be other justifications that I am overlooking.
>
>     (It may also be the case that I'm ignorant of what the best C++
>     tools today do, though I'm pretty sure that these drawbacks are
>     consequences of core C++ design.)
>
>     Cheers,
>     -Felix
>
>     [1] SFINAE:
>     http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error
>
>
>     On 17/09/2013 13:34, Gokcehan Kara wrote:
>>     Hello,
>>
>>     I have met rust a few days ago and let me pay my respects first
>>     for making such a powerful language. I really hope to succeed
>>     making some contribution in the upcoming days.
>>
>>     I was reading the tutorial
>>     (http://static.rust-lang.org/doc/tutorial.html) specifically the
>>     section 16.3 and I was wondering if there's a rationale behind
>>     making generic bounds explicit. For example in C++ I can do:
>>
>>         // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat
>>     -g && ./a.out
>>         #include <iostream>
>>         #include <vector>
>>         using namespace std;
>>         class Klass {
>>         public:
>>           void print() { cout << "printing the thing" << endl; }
>>         };
>>         template <typename T> void print_all(vector<T> &things) {
>>           for (auto thing : things) {
>>             thing.print();
>>           }
>>         }
>>         int main() {
>>           vector<Klass> v1;
>>           v1.push_back(Klass());
>>           v1.push_back(Klass());
>>           v1.push_back(Klass());
>>           print_all(v1);  // no errors
>>           vector<int> v2;
>>           v2.push_back(1);
>>           v2.push_back(2);
>>           v2.push_back(3);
>>           print_all(v2); // /tmp/asd.cc:18:10: error: member
>>     reference base type 'int'
>>                          // is not a structure or
>>     union/tmp/asd.cc:37:3: note: in
>>                          // instantiation of function template
>>     specialization
>>                          // 'draw_all<int>' requested here
>>           return 0;
>>         }
>>
>>     and it gives me the necessary error at compile time. To my
>>     limited knowledge, this is also statically dispatched so should
>>     not cause any overhead.
>>
>>     I haven't used Haskell much but I know a little bit of Scala. In
>>     Scala you need to be explicit because generics are compiled once
>>     to run with different types. As far as I understand, rust
>>     compiles different copies for each type (monomorphizing?) just
>>     like C++ so it might be possible to be implicit in rust as well.
>>
>>     Having said that, I'm not sure if being explicit is necessarily a
>>     bad thing. It sure looks good for documenting and I haven't
>>     thought of any cases where it falls short except maybe when a
>>     function of the same name is implemented in different traits.
>>
>>     Am I failing to see the obvious?
>>
>>     Thanks in advance,
>>     Gokcehan
>>
>>
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org  <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>     -- 
>     irc: pnkfelix onirc.mozilla.org  <http://irc.mozilla.org>
>     email: {fklock,pnkfelix}@mozilla.com  <mailto:pnkfelix%7D at mozilla.com>
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130917/1ceb2d9d/attachment-0001.html>

From robertknight at gmail.com  Tue Sep 17 07:59:08 2013
From: robertknight at gmail.com (Robert Knight)
Date: Tue, 17 Sep 2013 15:59:08 +0100
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <52385941.6070500@mozilla.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
	<52384ADE.3060603@mozilla.com>
	<CAEWroOjbOiYt1xnOm_YkT2k37RZ1YROwK989keGGke4EsQJXOA@mail.gmail.com>
	<52385941.6070500@mozilla.com>
Message-ID: <CAJGrnh0TDma1+d4VWYFYK3Ydv5FCKUV7YYkLcuDWC5QyiMYGag@mail.gmail.com>

> (It may also be the case that I'm ignorant of what the best C++ tools today do, though I'm pretty sure that these drawbacks are consequences of core C++ design.)

Recent versions of Clang and GCC have much better diagnostics for
template issues than compilers from a couple of years ago
but you're right - C++ templates are fundamentally compile-time
duck-typing and consequently the error
messages are basically a stack trace.

The recent 'Concepts Lite' proposal for C++1y addresses this by
allowing template arguments
to be allowing template args to be constrained [1].

Regards,
Rob.

[1] http://isocpp.org/blog/2013/02/concepts-lite-constraining-templates-with-predicates-andrew-sutton-bjarne-s

On 17 September 2013 14:29, Felix S. Klock II <pnkfelix at mozilla.com> wrote:
> Gokcehan (cc'ing rust-dev)-
>
> Correct, rust generics are not Turing-complete.  (To my knowledge; I don't
> think we've written the termination proof for the type-checker yet.  :)
>
> Cheers,
> -Felix
>
>
> On 17/09/2013 15:25, Gokcehan Kara wrote:
>
> Felix, C++ template errors are indeed a joy(!) to deal with. I guess I also
> would rather be explicit than to have cryptic error messages that are pages
> long. You're also right about the absence of errors without the client code
> which makes sense in a context of safety.
>
> It was the first time I heard about SFINAE. It reminds me of
> turing-completeness proofs of C++ templates. Does that mean rust generics
> are not turing complete?
>
> Gokcehan
>
>
> On Tue, Sep 17, 2013 at 3:28 PM, Felix S. Klock II <pnkfelix at mozilla.com>
> wrote:
>>
>> Gokcehan-
>>
>> My understanding is that C++, due to its policy of SFINAE [1], usually
>> provides error feedback after the template has been fully instantiated and
>> the fully instantiated version fails to compile.  This can lead to hard to
>> debug compile-time failures.
>>
>> Good compilers can help with dissecting the output you get in this case,
>> but it is still a real pain to decode in my experience, especially when you
>> have nests of template code written in terms of other template code.  Since
>> the template parameters do not have bounds, it is not possible for a
>> compiler to provide any error feedback given a template definition alone
>> (with no client code), and its difficult for the compiler to provide good
>> error feedback that is described solely in terms of the definition: you are
>> doomed to thinking about the intermingling of the definition with the
>> particular instantiation.
>>
>> Requiring explicit bounds means that the compiler can provide good error
>> messages at the point where the parameterized class is *defined* (even in
>> the absence of client code!) rather than delaying to the point where the
>> parmeterized class is fully instantiated.  This provides me with more
>> confidence that the parametric code I write is actually going to compose
>> properly with other implementations of the trait-bounds in terms of which I
>> have written my code.
>>
>> That advantage alone is enough to justify this choice for *me*.  There may
>> be other justifications that I am overlooking.
>>
>> (It may also be the case that I'm ignorant of what the best C++ tools
>> today do, though I'm pretty sure that these drawbacks are consequences of
>> core C++ design.)
>>
>> Cheers,
>> -Felix
>>
>> [1] SFINAE:
>> http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error
>>
>>
>> On 17/09/2013 13:34, Gokcehan Kara wrote:
>>
>> Hello,
>>
>> I have met rust a few days ago and let me pay my respects first for making
>> such a powerful language. I really hope to succeed making some contribution
>> in the upcoming days.
>>
>> I was reading the tutorial (http://static.rust-lang.org/doc/tutorial.html)
>> specifically the section 16.3 and I was wondering if there's a rationale
>> behind making generic bounds explicit. For example in C++ I can do:
>>
>>     // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat -g &&
>> ./a.out
>>     #include <iostream>
>>     #include <vector>
>>     using namespace std;
>>
>>     class Klass {
>>     public:
>>       void print() { cout << "printing the thing" << endl; }
>>     };
>>
>>     template <typename T> void print_all(vector<T> &things) {
>>       for (auto thing : things) {
>>         thing.print();
>>       }
>>     }
>>
>>     int main() {
>>       vector<Klass> v1;
>>
>>       v1.push_back(Klass());
>>       v1.push_back(Klass());
>>       v1.push_back(Klass());
>>
>>       print_all(v1);  // no errors
>>
>>       vector<int> v2;
>>
>>       v2.push_back(1);
>>       v2.push_back(2);
>>       v2.push_back(3);
>>
>>       print_all(v2); // /tmp/asd.cc:18:10: error: member reference base
>> type 'int'
>>                      // is not a structure or union/tmp/asd.cc:37:3: note:
>> in
>>                      // instantiation of function template specialization
>>                      // 'draw_all<int>' requested here
>>
>>       return 0;
>>     }
>>
>> and it gives me the necessary error at compile time. To my limited
>> knowledge, this is also statically dispatched so should not cause any
>> overhead.
>>
>> I haven't used Haskell much but I know a little bit of Scala. In Scala you
>> need to be explicit because generics are compiled once to run with different
>> types. As far as I understand, rust compiles different copies for each type
>> (monomorphizing?) just like C++ so it might be possible to be implicit in
>> rust as well.
>>
>> Having said that, I'm not sure if being explicit is necessarily a bad
>> thing. It sure looks good for documenting and I haven't thought of any cases
>> where it falls short except maybe when a function of the same name is
>> implemented in different traits.
>>
>> Am I failing to see the obvious?
>>
>> Thanks in advance,
>> Gokcehan
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> --
>> irc: pnkfelix on irc.mozilla.org
>> email: {fklock, pnkfelix}@mozilla.com
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From pwalton at mozilla.com  Tue Sep 17 08:59:55 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Tue, 17 Sep 2013 08:59:55 -0700
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
Message-ID: <52387C7B.2080600@mozilla.com>

On 9/17/13 4:34 AM, Gokcehan Kara wrote:
> I haven't used Haskell much but I know a little bit of Scala. In Scala
> you need to be explicit because generics are compiled once to run with
> different types. As far as I understand, rust compiles different copies
> for each type (monomorphizing?) just like C++ so it might be possible to
> be implicit in rust as well.

As Felix said, error messages are a big part of it, but there's also 
another equally important reason: scoping of methods. Without explicit 
bounds it's hard to get the scoping right: the basic problem is that the 
generic function is calling methods it doesn't "know about" at the time 
of definition, so it can't import them from anywhere. This is why C++ 
needs Koenig lookup/argument dependent lookup, which comes with its own 
host of problems. Explicit bounds avoid this issue.

Patrick


From danielmicay at gmail.com  Tue Sep 17 09:08:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 17 Sep 2013 12:08:03 -0400
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
Message-ID: <CA+DvKQLNkFBZSRLUtH1EwkM3SJ9LVVFOLVMB=ZS=HXkuD=x9ng@mail.gmail.com>

On Tue, Sep 17, 2013 at 7:34 AM, Gokcehan Kara <gokcehankara at gmail.com>wrote:

> Hello,
>
> I have met rust a few days ago and let me pay my respects first for making
> such a powerful language. I really hope to succeed making some contribution
> in the upcoming days.
>
> I was reading the tutorial (http://static.rust-lang.org/doc/tutorial.html)
> specifically the section 16.3 and I was wondering if there's a rationale
> behind making generic bounds explicit. For example in C++ I can do:
>
>     // clang++ asd.cc -std=c++11 -Weverything -Wno-c++98-compat -g &&
> ./a.out
>     #include <iostream>
>     #include <vector>
>     using namespace std;
>
>     class Klass {
>     public:
>       void print() { cout << "printing the thing" << endl; }
>     };
>
>     template <typename T> void print_all(vector<T> &things) {
>       for (auto thing : things) {
>         thing.print();
>       }
>     }
>
>     int main() {
>       vector<Klass> v1;
>
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>       v1.push_back(Klass());
>
>       print_all(v1);  // no errors
>
>       vector<int> v2;
>
>       v2.push_back(1);
>       v2.push_back(2);
>       v2.push_back(3);
>
>       print_all(v2); // /tmp/asd.cc:18:10: error: member reference base
> type 'int'
>                      // is not a structure or union/tmp/asd.cc:37:3: note:
> in
>                      // instantiation of function template specialization
>                      // 'draw_all<int>' requested here
>
>       return 0;
>     }
>
> and it gives me the necessary error at compile time. To my limited
> knowledge, this is also statically dispatched so should not cause any
> overhead.
>
> I haven't used Haskell much but I know a little bit of Scala. In Scala you
> need to be explicit because generics are compiled once to run with
> different types. As far as I understand, rust compiles different copies for
> each type (monomorphizing?) just like C++ so it might be possible to be
> implicit in rust as well.
>
> Having said that, I'm not sure if being explicit is necessarily a bad
> thing. It sure looks good for documenting and I haven't thought of any
> cases where it falls short except maybe when a function of the same name is
> implemented in different traits.
>
> Am I failing to see the obvious?
>
> Thanks in advance,
> Gokcehan
>

In addition to what others have mentioned, explicit bounds allow generics
to be type-checked from the definition, rather than each instantiation. You
know that *any* set of type parameters fulfilling the bounds listed in the
API will compile. It's an enforced minimal level of documentation and
results in very clean error messages.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130917/416300fc/attachment.html>

From corey at octayn.net  Tue Sep 17 09:11:54 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 17 Sep 2013 12:11:54 -0400
Subject: [rust-dev] implicit vs explicit generic bounds
In-Reply-To: <CA+DvKQLNkFBZSRLUtH1EwkM3SJ9LVVFOLVMB=ZS=HXkuD=x9ng@mail.gmail.com>
References: <CAEWroOjudyh_8yvGnwrcCUPoem9+b_5BxcsUOpRdH5fsZBgSSQ@mail.gmail.com>
	<CA+DvKQLNkFBZSRLUtH1EwkM3SJ9LVVFOLVMB=ZS=HXkuD=x9ng@mail.gmail.com>
Message-ID: <CA++BO6Qtcsu4wKtMmEPTLBwZtySmw9ng8brZAVAKDz3r79PTXw@mail.gmail.com>

On Tue, Sep 17, 2013 at 12:08 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> In addition to what others have mentioned, explicit bounds allow generics to
> be type-checked from the definition, rather than each instantiation. You
> know that *any* set of type parameters fulfilling the bounds listed in the
> API will compile. It's an enforced minimal level of documentation and
> results in very clean error messages.
>

As well as faster compilation: you only need to typecheck once.

From lindsey at composition.al  Tue Sep 17 20:09:02 2013
From: lindsey at composition.al (Lindsey Kuper)
Date: Tue, 17 Sep 2013 23:09:02 -0400
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
	<CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
Message-ID: <CALnXJiozRMjdJZC7LNbBWPozrknUqAzdJPk8t0v4dHxwuVu-Pw@mail.gmail.com>

On Wed, Sep 11, 2013 at 8:50 AM, Corey Richardson <corey at octayn.net> wrote:
> On Wed, Sep 11, 2013 at 3:27 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> Presumably before rust reaches a point of earth-shaking importance
>> there will be an second implementation which can compile the first
>> compiler, thus permitting this solution. :)
>
> I wouldn't be so sure of that. There's a ton of trickiness around the
> type and borrow checker and everything else, and I'm not sure anyone
> would *want* to reimplement it.

At least one academic has expressed interest in doing a clean-slate
verified implementation of Rust -- eventually, once the language is
stable.  (Much easier said than done, of course.)

Lindsey

From danielmicay at gmail.com  Tue Sep 17 22:29:25 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 18 Sep 2013 01:29:25 -0400
Subject: [rust-dev] Working on rusti as final year project
In-Reply-To: <5233E464.9060000@minhdo.org>
References: <521B85C2.8060804@minhdo.org> <52329FD5.8090107@minhdo.org>
	<CA+DvKQL7tr09U9dPzBVJGH1Z+AjNAix41eZXWfCpeFNqkNFGcw@mail.gmail.com>
	<5233E464.9060000@minhdo.org>
Message-ID: <CA+DvKQL0ZOiLhiThXDOEHDrvFv4BhW4dWgyZ8=i=ZVYgqGsiJg@mail.gmail.com>

On Sat, Sep 14, 2013 at 12:21 AM, Minh Do <m at minhdo.org> wrote:

>  On 09/14/2013 02:57 AM, Daniel Micay wrote:
>
>  On Fri, Sep 13, 2013 at 1:17 AM, Minh Do <m at minhdo.org> wrote:
>
>> On 08/27/2013 12:43 AM, Minh Do wrote:
>>
>>> My name is Do Nhat Minh, currently a final year Computer Science student
>>> at Nanyang Technological University in Singapore. I have played with Rust
>>> and found the experience to be very pleasant. I think Rust make sensible
>>> trade-offs and managed to stay small, compared to C++.
>>>
>>> I have been granted permission by my university supervisor to work on
>>> rusti as my final year project. I hope with this contribution, Rust will be
>>> even stronger a competitor to Go and D.
>>>
>>> This will be my first time working on something this size and this long
>>> a duration. I would love to hear your advice or experience implementing
>>> rusti.
>>>
>>> Thank you for your time.
>>>
>>> Regards,
>>> Minh
>>>
>> Hi,
>>
>> I'm working on figuring out why rusti segfaults. So far, I'm able to
>> extract very little information.
>>
>> Attached is a backtrace from rusti using gdb. SIGSEGV is signaled inside
>> jemalloc's tcache_alloc_easy, line 286. Below is the piece code where it
>> fails.
>>
>> 274    JEMALLOC_ALWAYS_INLINE void *
>> 275    tcache_alloc_easy(tcache_bin_t *tbin)
>> 276    {
>> 277        void *ret;
>> 278
>> 279        if (tbin->ncached == 0) {
>> 280            tbin->low_water = -1;
>> 281            return (NULL);
>> 282        }
>> 283        tbin->ncached--;
>> 284        if ((int)tbin->ncached < tbin->low_water)
>> 285            tbin->low_water = tbin->ncached;
>> 286        ret = tbin->avail[tbin->ncached]; // <- XXX fail here
>> 287        return (ret);
>> 288    }
>>
>> jemalloc is trying to read from tbin->avail at tbin->ncached.
>> tbin->ncached was 1227353920 (or 0x4927ef40) which is too big in my
>> opinion. All the other values in tbin were unusually high or low, which
>> leads me to suspect tbin is uninitialized or there is a memory overrun.
>>
>> I run valgrind on rusti in the hope of catching memory overruns, but it
>> does not help much. Valgrind only prints some warning about conditional
>> jumps depending on uninitialized variables and then reports an invalid read
>> with the identical backtrace. However, at the top, valgrind prints the
>> below text, which I find quite interesting.
>>
>> ==31583== Syscall param read(buf) points to unaddressable byte(s)
>> ==31583==    at 0x40170C7: read (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x400586C: open_verify (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4005CA6: open_path (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4008495: _dl_map_object (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x400C281: openaux (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x400E773: _dl_catch_error (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x400C4E4: _dl_map_object_deps (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4002E93: dl_main (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4015174: _dl_sysdep_start (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4004AE5: _dl_start (in /usr/lib/ld-2.18.so)
>> ==31583==    by 0x4001277: ??? (in /usr/lib/ld-2.18.so)
>> ==31583==  Address 0x7fec7f700 is on thread 1's stack
>>
>> I then try linking directly with Rust's libstd (since it's the first
>> thing that's linked with the code being compiled) in rusti's main() before
>> anything is done. Below is the addition.
>>
>> diff --git a/src/librusti/rusti.rs b/src/librusti/rusti.rs
>> index 8d61a97..2f72cfa 100644
>> --- a/src/librusti/rusti.rs
>> +++ b/src/librusti/rusti.rs
>> @@ -84,6 +84,9 @@ use syntax::print::pprust;
>>  use program::Program;
>>  use utils::*;
>>
>> +use rustc::lib::llvm::llvm;
>> +use std::unstable::intrinsics;
>> +
>>  mod program;
>>  pub mod utils;
>>
>> @@ -505,6 +508,17 @@ pub fn main() {
>>  pub fn main_args(args: &[~str]) {
>>      #[fixed_stack_segment]; #[inline(never)];
>>
>> +    unsafe {
>> +        let manager =
>> llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());
>> +        let path =
>> "/path/to/rust/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/
>> libstd-6c65cf4b443341b1-0.8-pre.so";
>> +        do path.with_c_str |buf_t| {
>> +            if !llvm::LLVMRustLoadCrate(manager, buf_t) {
>> +                debug!(~"Could not link");
>> +            }
>> +            debug!("linked: %s", path);
>> +        }
>> +    }
>> +
>>      let input = io::stdin();
>>      let out = io::stdout();
>>      let mut repl = Repl {
>>
>> Rusti now also fails in the scheduler sometimes if it happens to switch
>> threads while LLVMRustLoadCrate is being executed. Below is the backtrace.
>>
>> #0  rust_thread_start (ptr=0x7ffff1c1f5e0) at
>> src/rt/sync/rust_thread.cpp:36
>> #1  0x00007ffff548b0a2 in start_thread () from /usr/lib/libpthread.so.0
>> #2  0x00007ffff3217a2d in clone () from /usr/lib/libc.so.6
>>
>> The above failure in the scheduler and the curious message by valgrind
>> makes me wonder about the scheduler and the runtime. However, when git
>> grep-ing for rust_thread, I don't see how it is hooked into Rust. Could
>> someone enlighten me on this?
>>
>> More importantly, does anyone have any suggestion about my approach or
>> any leads on this?
>>
>> Regards,
>> Minh
>>
>
>  Compile jemalloc with --enable-debug (you can add it to rt.mk) and it
> will check for things like double-free.
>
> Hi Daniel,
>
> Below is how I added --enable-debug to rt.mk. However, I don't see any
> debug messages printed out. Could you please tell me how I can make
> jemalloc print out debug messages?
>
> diff --git a/mk/rt.mk b/mk/rt.mk
> index e31f222..69fc6ce 100644
> --- a/mk/rt.mk
> +++ b/mk/rt.mk
> @@ -220,7 +220,7 @@ endif
>  ifeq ($(OSTYPE_$(1)), linux-androideabi)
>  $$(JEMALLOC_LIB_$(1)_$(2)):
>         cd $$(RT_BUILD_DIR_$(1)_$(2))/jemalloc;
> $(S)src/rt/jemalloc/configure \
> -               --disable-experimental --build=$(CFG_BUILD_TRIPLE)
> --host=$(1) --disable-tls \
> +               --enable-debug --disable-experimental
> --build=$(CFG_BUILD_TRIPLE) --host=$(1) --disable-tls \
>                 EXTRA_CFLAGS="$$(CFG_GCCISH_CFLAGS)
> $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)" \
>                 LDFLAGS="$$(CFG_GCCISH_LINK_FLAGS)
> $$(LIBUV_FLAGS_$$(HOST_$(1)))" \
>                 CC="$$(CC_$(1))" \
> @@ -230,7 +230,7 @@ $$(JEMALLOC_LIB_$(1)_$(2)):
>  else
>  $$(JEMALLOC_LIB_$(1)_$(2)):
>         cd $$(RT_BUILD_DIR_$(1)_$(2))/jemalloc;
> $(S)src/rt/jemalloc/configure \
> -               --disable-experimental --build=$(CFG_BUILD_TRIPLE)
> --host=$(1) \
> +               --enable-debug --disable-experimental
> --build=$(CFG_BUILD_TRIPLE) --host=$(1) \
>                 EXTRA_CFLAGS="$$(CFG_GCCISH_CFLAGS)
> $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)" \
>                 LDFLAGS="$$(CFG_GCCISH_LINK_FLAGS)
> $$(LIBUV_FLAGS_$$(HOST_$(1)))" \
>                 CC="$$(CC_$(1))" \
>
> Regards,
> Minh
>

The --enable-debug switch just turns on some costly assertions. I think if
you're not seeing it abort with a message, then it's not catching any
issues.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130918/5d763ecf/attachment.html>

From luis at debethencourt.com  Wed Sep 18 09:45:10 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Wed, 18 Sep 2013 17:45:10 +0100
Subject: [rust-dev] Rust session at Seattle CodeCamp, Sep 28th 2013
In-Reply-To: <CA++BO6Qu1rGscs-XFPpuSBNrz343xGmMMatm0J1sy-WQViCdQg@mail.gmail.com>
References: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>
	<CA++BO6Qu1rGscs-XFPpuSBNrz343xGmMMatm0J1sy-WQViCdQg@mail.gmail.com>
Message-ID: <CAPA4HGVBSo8MunC=paZeS3PXWHMfZ6OMd7Xe-9irMEEyiHDDHg@mail.gmail.com>

I am also interested in watching a recording of this.

Having in mind that the website is specific to the 2013 edition of the
Codecamp, and there is no mention or links to the replaced 2012 website: I
doubt they record and share it on the web.
There is only one Seattle Codecamp talk in Youtube, and it is from 2010.

Jeffery,
Could you try and get some friend to record the talk?

Anybody that is going wants to help with this?

Luis


On 17 September 2013 03:12, Corey Richardson <corey at octayn.net> wrote:

> Awesome! Do you know if it will be recorded?
>
> On Mon, Sep 16, 2013 at 8:35 PM, Jeffery Olson <olson.jeffery at gmail.com>
> wrote:
> > Howdy,
> >
> > I've proposed, and received approval for, a session on Rust (clever
> titled
> > "The Rust Programming Language") for the upcoming 2013 Seattle CodeCamp.
> The
> > event is being held in Redmond, WA on the 28th of September at DigiPen.
> >
> > If you happen to be in the area and have nothing better to do on a
> Saturday,
> > please drop in and hang out with your fellow rust programmer(s) and help
> > minister to the heathens (joking! great crowd, truly).
> >
> > Session info at: https://seattle.codecamp.us/Sessions/Details/2366
> >
> > Registration, schedule, etc also available at the link cited.
> >
> > Cheers,
> > Jeff
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130918/65dd2c7e/attachment-0001.html>

From olson.jeffery at gmail.com  Wed Sep 18 10:34:06 2013
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Wed, 18 Sep 2013 10:34:06 -0700
Subject: [rust-dev] Rust session at Seattle CodeCamp, Sep 28th 2013
In-Reply-To: <CAPA4HGVBSo8MunC=paZeS3PXWHMfZ6OMd7Xe-9irMEEyiHDDHg@mail.gmail.com>
References: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>
	<CA++BO6Qu1rGscs-XFPpuSBNrz343xGmMMatm0J1sy-WQViCdQg@mail.gmail.com>
	<CAPA4HGVBSo8MunC=paZeS3PXWHMfZ6OMd7Xe-9irMEEyiHDDHg@mail.gmail.com>
Message-ID: <CAEXt_aZHXgWn5rsOLn8K502-muTDp2QB_X9VFJEFgAOVytRfSg@mail.gmail.com>

On Wed, Sep 18, 2013 at 9:45 AM, Luis de Bethencourt <luis at debethencourt.com
> wrote:

> I am also interested in watching a recording of this.
>

As terrified as I am of being recorded for posterity, it would probably be
for the best.


>
> Having in mind that the website is specific to the 2013 edition of the
> Codecamp, and there is no mention or links to the replaced 2012 website: I
> doubt they record and share it on the web.
> There is only one Seattle Codecamp talk in Youtube, and it is from 2010.
>
> Jeffery,
> Could you try and get some friend to record the talk?
>

I can do a screen recording. That doesn't really cover audio (very well) ..
can use the built-in mic on my laptop, if needed. I guess I'll see if I can
rustle something up.


>
> Anybody that is going wants to help with this?
>

The only rustafarian that I know of who may be in the Seattle area at that
time is ecr. He said he might make it, but that was a while back. I guess
I'll follow up.

If anyone else on the list is from Seattle and could make: now's your
chance to speak up!



>
> Luis
>
>
> On 17 September 2013 03:12, Corey Richardson <corey at octayn.net> wrote:
>
>> Awesome! Do you know if it will be recorded?
>>
>> On Mon, Sep 16, 2013 at 8:35 PM, Jeffery Olson <olson.jeffery at gmail.com>
>> wrote:
>> > Howdy,
>> >
>> > I've proposed, and received approval for, a session on Rust (clever
>> titled
>> > "The Rust Programming Language") for the upcoming 2013 Seattle
>> CodeCamp. The
>> > event is being held in Redmond, WA on the 28th of September at DigiPen.
>> >
>> > If you happen to be in the area and have nothing better to do on a
>> Saturday,
>> > please drop in and hang out with your fellow rust programmer(s) and help
>> > minister to the heathens (joking! great crowd, truly).
>> >
>> > Session info at: https://seattle.codecamp.us/Sessions/Details/2366
>> >
>> > Registration, schedule, etc also available at the link cited.
>> >
>> > Cheers,
>> > Jeff
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130918/db3a630f/attachment.html>

From banderson at mozilla.com  Wed Sep 18 15:31:43 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 18 Sep 2013 15:31:43 -0700
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <522F3EF7.1000507@exyr.org>
References: <522F3EF7.1000507@exyr.org>
Message-ID: <523A29CF.9010803@mozilla.com>

On 09/10/2013 08:47 AM, Simon Sapin wrote:
> Hi,
>
> TR;DR: the actual proposal is at the end of this email.

Thanks for working on this. It's crucial.

>
> Rust today has good support for UTF-8 which new content definitely 
> should use, but many systems still have to deal with legacy content 
> that uses other character encodings. There are several projects around 
> to implement more encodings in Rust. The most further along in my 
> opinion is rust-encoding, notably because it implements the right 
> specification.
>
> rust-encoding: https://github.com/lifthrasiir/rust-encoding
>
> The spec: http://encoding.spec.whatwg.org/
> It has more precise definitions of error handling than some original 
> RFCs, and better reflects the reality of legacy content on the web.
>
> There was some discussion in the past few days about importing 
> rust-encoding (or part of it) into Rust?s libstd or libextra. Before 
> that, I think it is important to define a good API. The spec defines 
> one for JavaScript, but we should not copy that exactly. 
> rust-encoding?s API is mostly good, but I think that error handling 
> could be simplified.
>
>
> In abstract terms, an encoding (such as "UTF-8") is made of a decoder 
> and an encoder. A decoder converts a stream of bytes into a stream of 
> text (Unicode scalar values, ie. code points excluding surrogates), 
> while an encoder does the reverse. This does not cover other kinds of 
> stream transformation such as base64, compression, encryption, etc.
>
> Bytes are represented in Rust by u8, text by str/char.
>
> (Side note: Because of constraints imposed by JavaScript and to avoid 
> costly conversions, Servo will probably use a different data type for 
> representing text. This encoding API could eventually become generic 
> over a Text trait, but I think that it should stick to str for now.)
>
>
> The most convenient way to represent a "stream" is with a vector or 
> string. This however requires the whole input to be in memory before 
> decoding/encoding can start, and that to be finished before any of the 
> output can be used. It should definitely be possible to eg. decode 
> some content as it arrives from the network, and parse it in a pipeline.
>
> The most fundamental type API is one where the user repeatedly 
> "pushes" chunks of input into a decoder/encoders object (that may 
> maintain state between chunks) and gets the output so far in return, 
> then signals the end of the input.
>
> In iterator adapter where the users "pulls" output from the decoder 
> which "pulls" from the input can be nicer, but is easy to build on top 
> of a "push-based" API, while the reverse requires tasks.
>
> Iterator<u8> and Iterator<char> are tempting, but we may need to work 
> on big chucks at a time for efficiency: Iterator<~[u8]> and 
> Iterator<~str>. Or could single-byte/char iterators be reliably 
> inlined to achieve similar efficiency?

Can Iterator<&[u8]> work if the iterator itself contains a fixed-sized 
or preallocated buffer? For I/O purposes, allocating a bunch of buffers 
just to write them out to a stream sounds wasteful..

>
>
> Finally, this API also needs to support several kinds of errors 
> handling. For example, a decoder should abort at the invalid byte 
> sequence for XML, but insert U+FFFD (replacement character) for HTML. 
> I?m not decided yet whether to just have the closed set of error 
> handling modes defined in the spec, or make this open-ended with 
> conditions.
>
>
> Based on all the above, here is a proposed API. Encoders are ommited, 
> but they are mostly the same as decoders with [u8] and str swapped.
>
>
> /// Types implementing this trait are "algorithms"
> /// such as UTF8, UTF-16, SingleByteEncoding, etc.
> /// Values of these types are "encodings" as defined in the WHATWG spec:
> /// UTF-8, UTF-16-LE, Windows-1252, etc.
> trait Encoding {
>     /// Could become an associated type with a ::new() constructor
>     /// when the language supports that.
>     fn new_decoder(&self) -> ~Decoder;
>
>     /// Simple, "one shot" API.
>     /// Decode a single byte string that is entirely in memory.
>     /// May raise the decoding_error condition.
>     fn decode(&self, input: &[u8]) -> Result<~str, DecodeError> {
>         // Implementation (using a Decoder) left out.
>         // This is a default method, but not meant to be overridden.
>     }
> }
>
> /// Takes the invalid byte sequence.
> /// Return a replacement string, or None to abort with a DecodeError.
> condition! {
>     pub decoding_error : ~[u8] -> Option<~str>;
> }
>
> struct DecodeError {
>     input_byte_offset: uint,
>     invalid_byte_sequence: ~[u8],
> }
>
> /// Each implementation of Encoding has one corresponding implementation
> /// of Decoder (and one of Encoder).
> ///
> /// A new Decoder instance should be used for every input.
> /// A Decoder instance should be discarded after DecodeError was 
> returned.
> trait Decoder {
>     /// Call this repeatedly with a chunck of input bytes.
>     /// As much as possible of the decoded text is appended to output.
>     /// May raise the decoding_error condition.
>     fn feed(input: &[u8], output: &mut ~str) -> Option<DecodeError>;
>
>     /// Call this to indicate the end of the input.
>     /// The Decoder instance should be discarded afterwards.
>     /// Some encodings may append some final output at this point.
>     /// May raise the decoding_error condition.
>     fn flush(output: &mut ~str) -> Option<DecodeError>;
> }
>
> /// "Pull-based" API.
> struct DecoderIterator<I> {
>     input_iterator: I,
>     priv state: DecoderIteratorState<I>,
> }
>
>
> impl<I: Iterator<~[u8]>> DecoderIterator<I> {
>     fn new(input_iterator: I) -> DecoderIterator<I> {
>         // Implementation left out.
>     }
>
>     /// Consume the whole input iterator and return a single decoded 
> string.
>     /// May raise the decoding_error condition.
>     fn concat(&mut self) -> Result<~str, DecodeError> {

This would probably take self by value if it's consuming the inner iterator?

> // Implementation left out.
>     }
> }
>
> impl<I: Iterator<~[u8]>> Iterator<Result<~str, DecodeError>> for 
> DecoderIterator<I> {
>     /// Call .next() once on the input iterator and decode the result.
>     /// May raise the decoding_error condition.
>     /// Returns None after DecodeError was returned once,
>     /// even if the input iterator is not exhausted yet.
>     fn next(&mut self) -> Option<Result<~str, DecodeError>> {
>         // Implementation left out.
>     }
> }
>
>

I don't understand this iterator. I'm guessing it calls `concat` on the 
`DecoderIterator` during each call to `next`, but `concat` consumes 
`DecoderIterator`s inner `Iterator`, so it subsequent calls to `concat` 
won't work.

This API only deals with Decoding. What about Encoding?

I don't see the utility of the `Encoding` factory type here, especially 
of instantiating it to get a `Decoder`. As you indicate, it's instance 
methods may want to be static methods.

Looks like a fine start to me. Let's do it.



From martindemello at gmail.com  Wed Sep 18 15:43:22 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Wed, 18 Sep 2013 15:43:22 -0700
Subject: [rust-dev] c structs with bitfields
In-Reply-To: <CAFrFfuEkEFh3symNGz8JXX6vZ7q+FtsFOVy1ZFC3ua8ni_MGpg@mail.gmail.com>
References: <CAFrFfuFxVu3-a31BU5N=vvx7MwD7TZ1dX4DjDv07_BH75CR5EA@mail.gmail.com>
	<CA++BO6Qz5UjgUFyOswxnkbUhC4zUNgxtt249B3=37_ENFoeh=A@mail.gmail.com>
	<CAKE6RfiqpkzvQE1TU2af4ukEPG31XqDidwvsMnCWH7Q=FkJ6hw@mail.gmail.com>
	<CA++BO6RQz-2F0fNQSPK9CZ2P5X0kzF-TGDGQh540rSSwNssSVA@mail.gmail.com>
	<CAKE6RfgSpGodFVo7+Xv_myNBEaY_+iGdpWgJu5Y8+u_ivn47Vg@mail.gmail.com>
	<CAFrFfuFtKHT-onueJ_0BP19-7f725DHF8JtRS9N7bWN7nv+Fmg@mail.gmail.com>
	<CA++BO6SHg+8JWg891=tu2=fXvKcT_G4cq5StpCbE7xpNL2hF_A@mail.gmail.com>
	<CAFrFfuHrqGbSz1HPDD2abQUv=L7BmkmCd=jFmAt=0X8yJThceA@mail.gmail.com>
	<CA++BO6RCaSgB3NMLKE0bXoFsY=D8q=NovC8q70Qz=EhPvK2sYQ@mail.gmail.com>
	<CAFrFfuEkEFh3symNGz8JXX6vZ7q+FtsFOVy1ZFC3ua8ni_MGpg@mail.gmail.com>
Message-ID: <CAFrFfuEJE89W3YN-ZvqufreJLY+ROW5AJquLkTNLifyPY7Wv1A@mail.gmail.com>

I've gone ahead and added the code to fail on bitfields, but I note
that the original bug report referenced servo/rust-azure, which has
the following

// FIXME: rust-bindgen can't handle bitfields

[https://github.com/mozilla-servo/rust-azure/blob/master/azure-c.h#L235]

So I'd still like to find a better way of handling this case.

martin

On Mon, Sep 9, 2013 at 11:47 AM, Martin DeMello <martindemello at gmail.com> wrote:
> That seems less than ideal - I mean, there are definitely c libraries
> out there with bitfield widths in their header files, and we should be
> able to use them from rust. And if we do, there should be a way to
> generate the bindings that is systematic enough to be captured within
> bindgen (possibly with a flag specifying the ABI).
>
> martin
>
> On Sun, Sep 8, 2013 at 7:37 PM, Corey Richardson <corey at octayn.net> wrote:
>> Emit an error and fail, I'd say, unless you can tell it which ABI it's
>> targetting so it knows how to handle it.
>>
>> On Sun, Sep 8, 2013 at 8:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>>> On Sun, Sep 8, 2013 at 5:14 PM, Corey Richardson <corey at octayn.net> wrote:
>>>> On Sun, Sep 8, 2013 at 7:20 PM, Martin DeMello <martindemello at gmail.com> wrote:
>>>>> So am I right that bitfield widths would first need to be added to the
>>>>> rust struct definition and code generator before they can be added to
>>>>> bindgen? I poked around the AST and middle code a bit but couldn't
>>>>> find it if it was there.
>>>>>
>>>>
>>>> Rust doesn't have bitfields and neither does LLVM, nor do I think we should:
>>>>
>>>> 1. bitfield members aren't addressable.
>>>> 2. It would be near impossible to replicate the exact behavior of
>>>> every C compiler for every platform and ABI it supports.
>>>> 3. They add significant additional complexity.
>>>
>>> Which returns me to the higher-level question, then - what is the
>>> correct thing for bindgen to do if handed a C struct with them?
>>>
>>> martin

From vadimcn at gmail.com  Wed Sep 18 16:54:06 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 18 Sep 2013 16:54:06 -0700
Subject: [rust-dev] AST transforming syntax extension
Message-ID: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>

Hi,
I want to write a syntax extension that operates on Rust AST, not on
individual tokens.  For example:

fn foo() {
    ...
    my_ext!{
        <statement1>;
        <statement2>;
        ...
    }
    ...
}
where <statement 1..N> are normal Rust statements.

I want to get the AST for code enclosed inside my extension block,
transform it, and insert in place of the original node(s).

Any pointers to where to start?  Are there any existing extensions that do
something close to what I want?

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130918/309b3864/attachment.html>

From corey at octayn.net  Wed Sep 18 17:27:23 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 18 Sep 2013 20:27:23 -0400
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
Message-ID: <CA++BO6R6XBP=XCOMKhDRssLJ+TajimuQWmspVe3jponp7+FHbQ@mail.gmail.com>

Such is not possible at the moment. Syntax extensions operate on token
trees, not AST. Maybe you'd be able to parse the input? Not sure, not
my knowledge area.

On Wed, Sep 18, 2013 at 7:54 PM, Vadim <vadimcn at gmail.com> wrote:
> Hi,
> I want to write a syntax extension that operates on Rust AST, not on
> individual tokens.  For example:
>
> fn foo() {
>     ...
>     my_ext!{
>         <statement1>;
>         <statement2>;
>         ...
>     }
>     ...
> }
> where <statement 1..N> are normal Rust statements.
>
> I want to get the AST for code enclosed inside my extension block, transform
> it, and insert in place of the original node(s).
>
> Any pointers to where to start?  Are there any existing extensions that do
> something close to what I want?
>
> Vadim
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From paul.stansifer at gmail.com  Wed Sep 18 20:06:54 2013
From: paul.stansifer at gmail.com (Paul Stansifer)
Date: Wed, 18 Sep 2013 23:06:54 -0400
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
Message-ID: <CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>

What you describe is the status quo for syntax extensions and macros.

The standard way for a syntax extension (built into the Rust compiler, not
a macro) to operate is to use the macro parser (which in turn uses the Rust
parser) to turn token trees into AST nodes. See libsyntax/ext/ for
implementations of existing syntax extensions.

If you want to write a macro, on the other hand, which is sufficient for
most needs, then you don't need to do anything, because this is what macros
already do -- as soon as they parse, say, `$s1:stmt`, `s1` is a statement
AST node, ready for interpolation.

Does this help?

Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130918/1fcc269d/attachment.html>

From simon.sapin at exyr.org  Thu Sep 19 01:05:27 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Thu, 19 Sep 2013 09:05:27 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <523A29CF.9010803@mozilla.com>
References: <522F3EF7.1000507@exyr.org> <523A29CF.9010803@mozilla.com>
Message-ID: <523AB047.3070407@exyr.org>

Le 18/09/2013 23:31, Brian Anderson a ?crit :
> On 09/10/2013 08:47 AM, Simon Sapin wrote:
>> Iterator<u8> and Iterator<char> are tempting, but we may need to work
>> on big chucks at a time for efficiency: Iterator<~[u8]> and
>> Iterator<~str>. Or could single-byte/char iterators be reliably
>> inlined to achieve similar efficiency?
>
> Can Iterator<&[u8]> work if the iterator itself contains a fixed-sized
> or preallocated buffer? For I/O purposes, allocating a bunch of buffers
> just to write them out to a stream sounds wasteful..
>
> [..]
>
> I don't understand this iterator. I'm guessing it calls `concat` on the
> `DecoderIterator` during each call to `next`, but `concat` consumes
> `DecoderIterator`s inner `Iterator`, so it subsequent calls to `concat`
> won't work.

Valid points, but please see the rest of this thread for the updated 
proposal.

https://mail.mozilla.org/pipermail/rust-dev/2013-September/005556.html

I just removed the iterator stuff as it?s relatively easy to build on 
top of the "push"-based API, and there are many variations of it, so we 
don?t need to figure out the details in the first iteration.


> This API only deals with Decoding. What about Encoding?

As noted in the proposals, it?s basically the same but with [u8] and str 
swapped. I did not include it to keep the size of the email manageable.


> I don't see the utility of the `Encoding` factory type here, especially
> of instantiating it to get a `Decoder`. As you indicate, it's instance
> methods may want to be static methods.

It?s not useful if you know the encoding to use at compile-time. (Eg. 
this format always uses UTF-8.) It?s only useful for code that switches 
encodings at run-time, based eg. on the charset parameter of a 
Content-Type HTTP header. It?s used with a function that I forgot to 
include in the first proposal:

fn get_encoding_from_label(label: &str) -> ~Encoding { /* ... */ }


> Looks like a fine start to me. Let's do it.

I?m also looking for feedback on the error handling. Do you think 
conditions are the right approach? How much power exactly should the 
handlers have?

As to the implementation: rust-encoding has a lot that could be adapted.
https://github.com/lifthrasiir/rust-encoding

I may start doing the work at some point, but I?m not making any promise 
on when. In the meantime, anyone interested feel free to take this up.

Cheers,
-- 
Simon Sapin

From jruderman at gmail.com  Thu Sep 19 02:40:36 2013
From: jruderman at gmail.com (Jesse Ruderman)
Date: Thu, 19 Sep 2013 02:40:36 -0700
Subject: [rust-dev] Fate of &const
Message-ID: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>

The example on https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-09-10#fate-of-const
seems sensible at first, but the rule it suggests would not be safe.
Allowing one closure to take &mut while another takes &const would
create a data race if the two closures are executed in parallel.

task::try only takes one closure and returns a Result, so it does not
have the same problem as the "motivating example".

From olson.jeffery at gmail.com  Thu Sep 19 05:39:56 2013
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Thu, 19 Sep 2013 05:39:56 -0700
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <523AB047.3070407@exyr.org>
References: <522F3EF7.1000507@exyr.org> <523A29CF.9010803@mozilla.com>
	<523AB047.3070407@exyr.org>
Message-ID: <CAEXt_aZJmdjp_eBJAxC+e14kJ74YAzFNY2BGuHV_wpa4Op_Ddw@mail.gmail.com>

On Thu, Sep 19, 2013 at 1:05 AM, Simon Sapin <simon.sapin at exyr.org> wrote:

> Le 18/09/2013 23:31, Brian Anderson a ?crit :
>
>> On 09/10/2013 08:47 AM, Simon Sapin wrote:
>>
>>> Iterator<u8> and Iterator<char> are tempting, but we may need to work
>>> on big chucks at a time for efficiency: Iterator<~[u8]> and
>>> Iterator<~str>. Or could single-byte/char iterators be reliably
>>> inlined to achieve similar efficiency?
>>>
>>
>> Can Iterator<&[u8]> work if the iterator itself contains a fixed-sized
>> or preallocated buffer? For I/O purposes, allocating a bunch of buffers
>> just to write them out to a stream sounds wasteful..
>>
>> [..]
>>
>>
>> I don't understand this iterator. I'm guessing it calls `concat` on the
>> `DecoderIterator` during each call to `next`, but `concat` consumes
>> `DecoderIterator`s inner `Iterator`, so it subsequent calls to `concat`
>> won't work.
>>
>
> Valid points, but please see the rest of this thread for the updated
> proposal.
>
> https://mail.mozilla.org/**pipermail/rust-dev/2013-**September/005556.html<https://mail.mozilla.org/pipermail/rust-dev/2013-September/005556.html>
>

Yes, would like to here opinion on the implications of using a StringWriter
as output for the lower-level API, as mentioned in the proposal.


>
> I just removed the iterator stuff as it?s relatively easy to build on top
> of the "push"-based API, and there are many variations of it, so we don?t
> need to figure out the details in the first iteration.
>
>
>
>  This API only deals with Decoding. What about Encoding?
>>
>
> As noted in the proposals, it?s basically the same but with [u8] and str
> swapped. I did not include it to keep the size of the email manageable.
>
>
>
>  I don't see the utility of the `Encoding` factory type here, especially
>> of instantiating it to get a `Decoder`. As you indicate, it's instance
>> methods may want to be static methods.
>>
>
> It?s not useful if you know the encoding to use at compile-time. (Eg. this
> format always uses UTF-8.) It?s only useful for code that switches
> encodings at run-time, based eg. on the charset parameter of a Content-Type
> HTTP header. It?s used with a function that I forgot to include in the
> first proposal:
>
>
> fn get_encoding_from_label(label: &str) -> ~Encoding { /* ... */ }
>
>
>  Looks like a fine start to me. Let's do it.
>>
>
> I?m also looking for feedback on the error handling. Do you think
> conditions are the right approach? How much power exactly should the
> handlers have?
>
> As to the implementation: rust-encoding has a lot that could be adapted.
> https://github.com/**lifthrasiir/rust-encoding<https://github.com/lifthrasiir/rust-encoding>
>

Can someone comment on whether we should look at adapting what's in
str::from_utf8 (really, str::raw::from_buf_len is where the action is) and
str::from_utf16 for this? Everyone in IRC I ask says that they are
"correct".. they're also highly optimized.. are they appropriate for this
API? And if not, are comfortable having two totally separate paths for
string decoding?


>
> I may start doing the work at some point, but I?m not making any promise
> on when. In the meantime, anyone interested feel free to take this up.
>

Thanks again for taking the time to look at this issue, Simon. I don't
think there's a huge rush, as I imagine we're too close to 0.8 to rush this
in.


>
> Cheers,
> --
> Simon Sapin
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/1bdfc310/attachment.html>

From simon.sapin at exyr.org  Thu Sep 19 06:08:34 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Thu, 19 Sep 2013 14:08:34 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <CAEXt_aZJmdjp_eBJAxC+e14kJ74YAzFNY2BGuHV_wpa4Op_Ddw@mail.gmail.com>
References: <522F3EF7.1000507@exyr.org> <523A29CF.9010803@mozilla.com>
	<523AB047.3070407@exyr.org>
	<CAEXt_aZJmdjp_eBJAxC+e14kJ74YAzFNY2BGuHV_wpa4Op_Ddw@mail.gmail.com>
Message-ID: <523AF752.7090008@exyr.org>

Le 19/09/2013 13:39, Jeffery Olson a ?crit :
>     As to the implementation: rust-encoding has a lot that could be adapted.
>     https://github.com/__lifthrasiir/rust-encoding
>     <https://github.com/lifthrasiir/rust-encoding>
>
>
> Can someone comment on whether we should look at adapting what's in
> str::from_utf8 (really, str::raw::from_buf_len is where the action is)
> and str::from_utf16 for this? Everyone in IRC I ask says that they are
> "correct".. they're also highly optimized.. are they appropriate for
> this API? And if not, are comfortable having two totally separate paths
> for string decoding?

I don?t think anybody is advocating duplicating implementations of the 
same thing. My understanding is that UTF8Decoder and the existing API in 
std::str will end up calling the same code.

That code could be libstd?s existing implementation extended for error 
handling, or rust-encoding?s, or something else. I don?t have a strong 
opinion about it.

UTF-16 is a bit special, because libstd?s existing APIs deal with 
"native-endian" [u16], while encoding APIs will need both UTF-16-LE and 
UTF-16-BE on [u8]. I don?t know how much can be shared.


But once again, I?m more interested in getting the API and the behavior 
right. I trust the smart people working on Rust to refactor and optimize 
the implementation over time.

Cheers,
-- 
Simon Sapin

From bill_myers at outlook.com  Thu Sep 19 08:15:47 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Thu, 19 Sep 2013 15:15:47 +0000
Subject: [rust-dev] Fate of &const
In-Reply-To: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
References: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
Message-ID: <BAY170-W85E332C3680B58489C2880F8210@phx.gbl>

> Allowing one closure to take &mut while another takes &const would
> create a data race if the two closures are executed in parallel.

Closures executable in parallel would probably have kind bounds forbidding &const: http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/ explicitly mentions this.

BTW, how about keeping it, and calling it "&volatile" instead of "&const", since that's what C uses to name something that can be changed outside the program's control?

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/cddd8ff8/attachment.html>

From niko at alum.mit.edu  Thu Sep 19 10:44:36 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Thu, 19 Sep 2013 13:44:36 -0400
Subject: [rust-dev] Fate of &const
In-Reply-To: <BAY170-W85E332C3680B58489C2880F8210@phx.gbl>
References: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
	<BAY170-W85E332C3680B58489C2880F8210@phx.gbl>
Message-ID: <20130919174436.GC16264@Mr-Bennet>

On Thu, Sep 19, 2013 at 03:15:47PM +0000, Bill Myers wrote:
> BTW, how about keeping it, and calling it "&volatile" instead of
> "&const", since that's what C uses to name something that can be
> changed outside the program's control?

That's the best proposed name I've seen. One problem might be that it
has a known meaning to C programmers which is distinct (but
overlapping) from the meaning in Rust...



Niko

From vadimcn at gmail.com  Thu Sep 19 11:02:55 2013
From: vadimcn at gmail.com (Vadim)
Date: Thu, 19 Sep 2013 11:02:55 -0700
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
	<CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>
Message-ID: <CADecdiJZDVHJGYoa7JSwACKyrLqZj2a9NOR7Q4=mMYN7E7Hr_Q@mail.gmail.com>

I'd love to be able to use just macros, however so far my attempts met with
little success.
Here's what I'm trying to do (right now expansion just echoes the input):

macro_rules! stmt_list(
    ( while $cond:expr { $body:tt } ) =>
        ( while $cond { stmt_list!( $body ) } );
    ( $head:stmt ; $rest:tt ) =>
        ( $head ; stmt_list!( $rest ) );
    ( $head:stmt ) =>
        ( $head );
)

fn main()
{
    trace_macros!(true);

    stmt_list!(
        let mut x = 0;
        while x < 10 {
            let y = x + 1;
            x = y
        }
    )
}

C:\rust\test>rustc --pretty expanded parse.rs
stmt_list! { let mut x = 0 ; while x < 10 { let y = x + 1 ; x = y } }
parse.rs:18:14: 18:15 error: No rules expected the token: x
parse.rs:18         while x < 10 {
                          ^

Am I totally off-base trying to do this with macros?   Do I need a syntax
extension?

Vadim


On Wed, Sep 18, 2013 at 8:06 PM, Paul Stansifer <paul.stansifer at gmail.com>wrote:

> What you describe is the status quo for syntax extensions and macros.
>
> The standard way for a syntax extension (built into the Rust compiler, not
> a macro) to operate is to use the macro parser (which in turn uses the Rust
> parser) to turn token trees into AST nodes. See libsyntax/ext/ for
> implementations of existing syntax extensions.
>
> If you want to write a macro, on the other hand, which is sufficient for
> most needs, then you don't need to do anything, because this is what macros
> already do -- as soon as they parse, say, `$s1:stmt`, `s1` is a statement
> AST node, ready for interpolation.
>
> Does this help?
>
> Paul
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/078b3618/attachment-0001.html>

From j.e.aten at gmail.com  Thu Sep 19 11:24:14 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Thu, 19 Sep 2013 11:24:14 -0700
Subject: [rust-dev] rusti - the - repl renovation
Message-ID: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>

Minh Do and I are looking into how to improve rusti -the- repl, so that is
fast, efficient, and stable.  Minh is undertaking this as a final year
project in his CS undergraduate program, and I am mentoring that project
and plan to work on it my spare time.  We had a first conference call this
week.

I've spoken with Alex Crichton and started a few conversations on IRC #rust
to discuss how rusti might ideally work.  I'm posting to rust-dev to
solicit additional feedback, guidance, and input.

Goals (and an important non-goal) for an improved rusti experience:

As an application developer in rust, I want to evaluate the effect of a
small Rust statement or expression, so that I can quickly learn the impact
of that statement and immediately verify or correct its syntax based on
instant feedback.

As a developer, I want to be able to change one variable or function
definition without a full recompile, so that I can quickly and immediately
see the result of, and evaluate the impact of, the change.  [I'm impatient!
I don't want to wait for a full recompile of everything.]

As a person new to Rust, I want be able to try out the syntax and
expressions interactively, so that I can get a quick feel for the language.

Non-goal: comprehensiveness. While naturally we would like rusti to be as
close to rustc semantics as possible, strict conformance is not a goal for
this project.  That is, we don't feel it important that rusti has to cover
absolutely every data type, nor every corner of the runtime of this quickly
evolving language.

Since this last point may be of interest, I will give here a brief
background discussion of this comprehensiveness non-goal.

The interpreters available for other languages (ghci, erl, cling, lush,
gambit-scheme come to mind) are similarly constrained to not be exact
replicas of the compiled semantics of the language.  Experience from these
other languages suggest that there is still great utility is be gained from
having a stable interpreter even for a subset of the compiled semantics.

The important example that is present in my mind, from discussions on the
#rust channel, is that it appears that tasks/coroutines may be difficult or
needlessly complex for a repl (if written in rust itself, which lacks
exceptions) to handle. In other words, it may be very arduous (given
current encodable/decodable constraints) to implement in a rusti repl that
supports task and fail! semantics. While we are open to clever suggestions
about how to make that happen if it is indeed possible, this may still be
undesirable and out-of-scope for a resource-constrained project. The
classic tradeoff of 80% of the benefit for 20% of the effort should be
observed.

In short, we feel there is great value to be had in providing an
interactive prompt for discovering many portions of the language, even if
the user has to move to the rustc compiler to deploy the full power of Rust.


We welcome your input and involvement on all aspects of rusti - the - repl
improvement.

Kind regards,

Jason

--
Jason E. Aten, Ph.D.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/ba8026fa/attachment.html>

From alex at crichton.co  Thu Sep 19 11:51:42 2013
From: alex at crichton.co (Alex Crichton)
Date: Thu, 19 Sep 2013 11:51:42 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
Message-ID: <CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>

> Non-goal: comprehensiveness. While naturally we would like rusti to be as
> close to rustc semantics as possible, strict conformance is not a goal for
> this project.  That is, we don't feel it important that rusti has to cover
> absolutely every data type, nor every corner of the runtime of this quickly
> evolving language.

I agree that this is a good thing for rusti.

> In other words, it may be very arduous (given current
> encodable/decodable constraints) to implement in a rusti repl that supports
> task and fail! semantics.

I think that having `fail!` work is an important aspect of rusti.
Otherwise if you ever trip an assertion it will abort the entire
session (or indexing things out of bounds, etc.).

The main problem here is instructing LLVM to correctly emit exception
handling code, which I *believe* is actually already done. One of the
recent upgrades of LLVM fixed this bug, so it shouldn't be too bad to
get running again.

Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
I think that it should be important to be able to fail! and have the
repl state intact afterwards.

From kevin at sb.org  Thu Sep 19 12:02:07 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 12:02:07 -0700
Subject: [rust-dev] Fate of &const
In-Reply-To: <20130919174436.GC16264@Mr-Bennet>
References: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
	<BAY170-W85E332C3680B58489C2880F8210@phx.gbl>
	<20130919174436.GC16264@Mr-Bennet>
Message-ID: <764722BA-BD8F-4177-8DF0-CC3D8CA17944@sb.org>

I suspect the number of C programmers who know what 'volatile' actually means is a fairly small percentage of total C programmers these days.

-Kevin

On Sep 19, 2013, at 10:44 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Thu, Sep 19, 2013 at 03:15:47PM +0000, Bill Myers wrote:
>> BTW, how about keeping it, and calling it "&volatile" instead of
>> "&const", since that's what C uses to name something that can be
>> changed outside the program's control?
> 
> That's the best proposed name I've seen. One problem might be that it
> has a known meaning to C programmers which is distinct (but
> overlapping) from the meaning in Rust...
> 
> 
> 
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Thu Sep 19 12:03:35 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 19 Sep 2013 15:03:35 -0400
Subject: [rust-dev] Fate of &const
In-Reply-To: <20130919174436.GC16264@Mr-Bennet>
References: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
	<BAY170-W85E332C3680B58489C2880F8210@phx.gbl>
	<20130919174436.GC16264@Mr-Bennet>
Message-ID: <CA+DvKQJchju+w3aXb-a01ADi9ituhQz_qPzdO6zkSVzqmik-hA@mail.gmail.com>

On Thu, Sep 19, 2013 at 1:44 PM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Thu, Sep 19, 2013 at 03:15:47PM +0000, Bill Myers wrote:
> > BTW, how about keeping it, and calling it "&volatile" instead of
> > "&const", since that's what C uses to name something that can be
> > changed outside the program's control?
>
> That's the best proposed name I've seen. One problem might be that it
> has a known meaning to C programmers which is distinct (but
> overlapping) from the meaning in Rust...
>
>
>
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

LLVM also uses the term `volatile` with the same meaning as C, and I expect
we will need to expose it if only to make it possible to write non-useless
#[bench] tests.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/243b625e/attachment.html>

From kevin at sb.org  Thu Sep 19 12:05:56 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 12:05:56 -0700
Subject: [rust-dev] Fate of &const
In-Reply-To: <CA+DvKQJchju+w3aXb-a01ADi9ituhQz_qPzdO6zkSVzqmik-hA@mail.gmail.com>
References: <CAB-YmG0Og5AJvP6A5iMb=kmo-5q-xoCpS=nAmixAthu4kB1bTg@mail.gmail.com>
	<BAY170-W85E332C3680B58489C2880F8210@phx.gbl>
	<20130919174436.GC16264@Mr-Bennet>
	<CA+DvKQJchju+w3aXb-a01ADi9ituhQz_qPzdO6zkSVzqmik-hA@mail.gmail.com>
Message-ID: <D753738E-8BD0-4C13-9DF8-BD78A847920F@sb.org>

We could go with `&unrestricted` instead, which has the benefit of being semantically compatible with the C keyword `restrict` (which only a handful of C programmers even know about). Although it's a bit unwieldy.

-Kevin

On Sep 19, 2013, at 12:03 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Thu, Sep 19, 2013 at 1:44 PM, Niko Matsakis <niko at alum.mit.edu> wrote:
> On Thu, Sep 19, 2013 at 03:15:47PM +0000, Bill Myers wrote:
> > BTW, how about keeping it, and calling it "&volatile" instead of
> > "&const", since that's what C uses to name something that can be
> > changed outside the program's control?
> 
> That's the best proposed name I've seen. One problem might be that it
> has a known meaning to C programmers which is distinct (but
> overlapping) from the meaning in Rust...
> 
> 
> 
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>  
> LLVM also uses the term `volatile` with the same meaning as C, and I expect we will need to expose it if only to make it possible to write non-useless #[bench] tests.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/9d153a8a/attachment.html>

From paul.stansifer at gmail.com  Thu Sep 19 12:05:52 2013
From: paul.stansifer at gmail.com (Paul Stansifer)
Date: Thu, 19 Sep 2013 15:05:52 -0400
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CADecdiJZDVHJGYoa7JSwACKyrLqZj2a9NOR7Q4=mMYN7E7Hr_Q@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
	<CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>
	<CADecdiJZDVHJGYoa7JSwACKyrLqZj2a9NOR7Q4=mMYN7E7Hr_Q@mail.gmail.com>
Message-ID: <CA+VxxZfvNDfsS4ueRa-nW3xvDs6jueYGsR3=hEx19eU5Ej=4Qg@mail.gmail.com>

(note that you should wrap your second RHS in `{}` in order to avoid
hitting the following bugs: https://github.com/mozilla/rust/issues/8012
https://github.com/mozilla/rust/issues/4375)

I had misunderstood your original question: now I see that, by "operate
on", you meant that you wanted to run the macro parser on code that has
already been parsed from tokens into AST. There isn't a mechanism to do
this in the Rust macro system. However, you have discovered a potential
workaround: capture the tokens as a token tree and pass them as an argument
to a macro (which, after all, accepts token trees as arguments).

The parse error is caused by the fact that (perhaps unintuitively), `tt`
only matches a single token if it doesn't see a `(`, `[`, or `{`. I have
not tested the following code (I fear it may run afoul of macro parser
limitations), but this may work:


macro_rules! stmt_list(
    ( while $cond:expr { $($body:tt)+ } ) =>
        ( while $cond { stmt_list!( $($body)+ ) } );
    ( $head:stmt ; $($rest:tt)+ ) =>
        ( $head ; stmt_list!( $($rest)+ ) );
    ( $head:stmt ) =>
        ( $head );
)

Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/deb44910/attachment.html>

From cpeterson at mozilla.com  Thu Sep 19 12:57:57 2013
From: cpeterson at mozilla.com (Chris Peterson)
Date: Thu, 19 Sep 2013 12:57:57 -0700
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
Message-ID: <523B5745.8000902@mozilla.com>

A Rust datetime library has been on my to-do list for a long time. :)

JSR-310 is a very complete solution, but it carries a lot of Java 
baggage. C++11's std::chrono library [1] defines a smaller API for time 
points and durations without calendars (i.e. the hard part). 
std::chrono's API might be more "rustic" than JSR-310's because C++ and 
Rust have operator overloading.

I strongly recommend reading Erik Naggum's "The Long, Painful History of 
Time" [2] about Common Lisp's support for the "concept of time as humans 
experience it."  :)

[1] http://msdn.microsoft.com/en-us/library/hh874757.aspx
[2] http://naggum.no/lugm-time.html


chris

From vadimcn at gmail.com  Thu Sep 19 13:00:10 2013
From: vadimcn at gmail.com (Vadim)
Date: Thu, 19 Sep 2013 13:00:10 -0700
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CA+VxxZfvNDfsS4ueRa-nW3xvDs6jueYGsR3=hEx19eU5Ej=4Qg@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
	<CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>
	<CADecdiJZDVHJGYoa7JSwACKyrLqZj2a9NOR7Q4=mMYN7E7Hr_Q@mail.gmail.com>
	<CA+VxxZfvNDfsS4ueRa-nW3xvDs6jueYGsR3=hEx19eU5Ej=4Qg@mail.gmail.com>
Message-ID: <CADecdiKSQsL780U=w8kkar-FoejijygirCpKWaSUQ7a7Bj8pmw@mail.gmail.com>

On Thu, Sep 19, 2013 at 12:05 PM, Paul Stansifer
<paul.stansifer at gmail.com>wrote:

> (note that you should wrap your second RHS in `{}` in order to avoid
> hitting the following bugs: https://github.com/mozilla/rust/issues/8012
> https://github.com/mozilla/rust/issues/4375)
>
> I had misunderstood your original question: now I see that, by "operate
> on", you meant that you wanted to run the macro parser on code that has
> already been parsed from tokens into AST.
>

Originally I *did* want to operate on AST, because I couldn't get macro
system to parse more than the first statement when I was writing my rules
like this:
    ( $head:stmt ; $($rest:*stmt*);+ ) => ( $head ; stmt_list!( $($rest);+
) );
Apparently interpolated statements cannot be re-parsed again?

So I figured that maybe I could let Rust parser build an AST for me, and
then tweak that.  Hence my question about syntax extensions.

However, later I'd discovered your lambda calculus
interpreter<https://github.com/mozilla/rust/issues/3201>,
and decided to give built-in macros another go, this time using "tt" to
capture tails of statement lists.


> There isn't a mechanism to do this in the Rust macro system. However, you
> have discovered a potential workaround: capture the tokens as a token tree
> and pass them as an argument to a macro (which, after all, accepts token
> trees as arguments).
>

> The parse error is caused by the fact that (perhaps unintuitively), `tt`
> only matches a single token if it doesn't see a `(`, `[`, or `{`. I have
> not tested the following code (I fear it may run afoul of macro parser
> limitations), but this may work:
>

Is tt specifier documented somewhere?   I am guessing it stands for "token
tree", but what is a token tree?   How is it different from AST?


>  macro_rules! stmt_list(
>     ( while $cond:expr { $($body:tt)+ } ) =>
>         ( while $cond { stmt_list!( $($body)+ ) } );
>     ( $head:stmt ; $($rest:tt)+ ) =>
>         ( $head ; stmt_list!( $($rest)+ ) );
>     ( $head:stmt ) =>
>         ( $head );
> )
>
That doesn't seem to work :-(

stmt_list! { let mut x = 0 ; while x < 10 { let y = x + 1 ; x = y } }
parse.rs:17:11: 17:15 error: unexpected token: `an interpolated statement`
parse.rs:17         ( $head ; stmt_list!( $($rest)+ ) );
                       ^~~~

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/2936ef01/attachment-0001.html>

From kevin at sb.org  Thu Sep 19 13:36:39 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 13:36:39 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
Message-ID: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>

One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.

I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.

## Python syntax:

Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.

Pros:
* Simple syntax
* Allows for embedding the closing quote character in the raw string

Cons:
* Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.

## C++11 syntax:

C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).

Pros:
* Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
* Reasonably straightforward

Cons:
* Syntax is slightly complicated

## D syntax:

D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.

The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.

The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like

q"delim
this is some raw text
delim"

It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".

Pros:
* Flexible
* Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)

Cons:
* Overly complicated

## Custom syntax

There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.

Pros:
* Very simple
* Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)

Cons:
* Slightly odd to read

## Conclusion

Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:

C++11: R"("""this is a python docstring""")"
Custom: R"""""""this is a python docstring"""""""

Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.

I welcome any comments, criticisms, or suggestions.

-Kevin

From oren at ben-kiki.org  Thu Sep 19 13:56:33 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Thu, 19 Sep 2013 23:56:33 +0300
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <CADJiDhuShV4gAb+=zrMAFmz9YFBcckT_zOs0AsSmvfbjL2yeXQ@mail.gmail.com>

Just to make sure - how does the C++ syntax behave in the presence of line
breaks? Specifically, what does it do with leading (and trailing) white
space of each line? My guess is that they would be included in the string,
is that correct?

At any rate, having some sort of here documents would be very nice. The C++
syntax is reasonable, though I really don't have a strong preference here.
It might be more Rust-ish to use a macro notation instead:
str!(delimiter"....."delimiter), or something like that.

BTW, I found myself creating (in several languages) an "unindent" string
function that would (1) if the string starts with a line break, remove it;
(2) remove the leading white space of the 1st line from all the lines.
Applying this to "here documents" allows indenting them together with the
code that includes them. In Rust, the downside of this approach is that the
result isn't &'static any more... Not that this warrants making such
complex functionality a built-in of the syntax, of course.

Oren.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/243b2c39/attachment.html>

From paul.stansifer at gmail.com  Thu Sep 19 13:56:26 2013
From: paul.stansifer at gmail.com (Paul Stansifer)
Date: Thu, 19 Sep 2013 16:56:26 -0400
Subject: [rust-dev] AST transforming syntax extension
In-Reply-To: <CADecdiKSQsL780U=w8kkar-FoejijygirCpKWaSUQ7a7Bj8pmw@mail.gmail.com>
References: <CADecdiLmcpP8XrWuDbxiDRcHvPWjVhqeC8+vLg=K5K7Ut-dFpg@mail.gmail.com>
	<CA+VxxZcmf31L5Hrzb+j0Kr+h__cMm1xjJZcq6vf_5-bOe7oHCQ@mail.gmail.com>
	<CADecdiJZDVHJGYoa7JSwACKyrLqZj2a9NOR7Q4=mMYN7E7Hr_Q@mail.gmail.com>
	<CA+VxxZfvNDfsS4ueRa-nW3xvDs6jueYGsR3=hEx19eU5Ej=4Qg@mail.gmail.com>
	<CADecdiKSQsL780U=w8kkar-FoejijygirCpKWaSUQ7a7Bj8pmw@mail.gmail.com>
Message-ID: <CA+VxxZeShK3qYhXq+Xsg3esSjTi9+=q+y4Q8WwvkvjsYn-gk2Q@mail.gmail.com>

> Originally I *did* want to operate on AST, because I couldn't get macro
> system to parse more than the first statement when I was writing my rules
> like this:
>     ( $head:stmt ; $($rest:*stmt*);+ ) => ( $head ; stmt_list!(
> $($rest);+ ) );
> Apparently interpolated statements cannot be re-parsed again?
>
Correct.


>
> Is tt specifier documented somewhere?   I am guessing it stands for "token
> tree", but what is a token tree?   How is it different from AST?
>
A token tree is "almost unparsed": it consists of a sequence of tokens
surrounded by `()`, `[]`, or `{}`, or a single token. It's the AST node
that the macro parser knows how to parse into actually useful AST nodes. It
isn't documented, sadly.



>
>
>>  macro_rules! stmt_list(
>>     ( while $cond:expr { $($body:tt)+ } ) =>
>>         ( while $cond { stmt_list!( $($body)+ ) } );
>>     ( $head:stmt ; $($rest:tt)+ ) =>
>>         ( $head ; stmt_list!( $($rest)+ ) );
>>     ( $head:stmt ) =>
>>         ( $head );
>> )
>>
> That doesn't seem to work :-(
>
Could you try wrapping `{}` inside the parens on the 2nd RHS, and adding a
semicolon after all three invocations of `stmt_list!`? For future debugging
back-and-forth, please contact me in #rust (I'm `pauls`), since that'll be
easier than email?

Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/e5c23566/attachment.html>

From kevin at sb.org  Thu Sep 19 14:05:29 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 14:05:29 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CADJiDhuShV4gAb+=zrMAFmz9YFBcckT_zOs0AsSmvfbjL2yeXQ@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CADJiDhuShV4gAb+=zrMAFmz9YFBcckT_zOs0AsSmvfbjL2yeXQ@mail.gmail.com>
Message-ID: <3E554ADB-0348-49B5-9394-C96450C0C90E@sb.org>

On Sep 19, 2013, at 1:56 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Just to make sure - how does the C++ syntax behave in the presence of line breaks? Specifically, what does it do with leading (and trailing) white space of each line? My guess is that they would be included in the string, is that correct?

It includes every single character that occurs in the source between the delimiters. So

	cout << R"(this is
	a string");

will print "this is", newline, horizontal tab, "a string".

> At any rate, having some sort of here documents would be very nice. The C++ syntax is reasonable, though I really don't have a strong preference here. It might be more Rust-ish to use a macro notation instead: str!(delimiter"....."delimiter), or something like that.

Not possible. This syntax needs to be part of the lexer, and macros/syntax extensions operate on token trees, not on raw source characters.

-Kevin

> BTW, I found myself creating (in several languages) an "unindent" string function that would (1) if the string starts with a line break, remove it; (2) remove the leading white space of the 1st line from all the lines. Applying this to "here documents" allows indenting them together with the code that includes them. In Rust, the downside of this approach is that the result isn't &'static any more... Not that this warrants making such complex functionality a built-in of the syntax, of course.
> 
> Oren.


From martindemello at gmail.com  Thu Sep 19 14:10:21 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Thu, 19 Sep 2013 14:10:21 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>

How complicated would it be to use R"" but with arbitrary paired
delimiters (the way, for instance, ruby does it)? It's very handy to
pick a delimiter you know does not appear in the string, e.g. if you
had a string containing ')' you could use R{this is a string with a )
in it} or R|this is a string with a ) in it|.

martin

On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
>
> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
>
> ## Python syntax:
>
> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
>
> Pros:
> * Simple syntax
> * Allows for embedding the closing quote character in the raw string
>
> Cons:
> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
>
> ## C++11 syntax:
>
> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
>
> Pros:
> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
> * Reasonably straightforward
>
> Cons:
> * Syntax is slightly complicated
>
> ## D syntax:
>
> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
>
> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>
> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
>
> q"delim
> this is some raw text
> delim"
>
> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
>
> Pros:
> * Flexible
> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
>
> Cons:
> * Overly complicated
>
> ## Custom syntax
>
> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
>
> Pros:
> * Very simple
> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
>
> Cons:
> * Slightly odd to read
>
> ## Conclusion
>
> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
>
> C++11: R"("""this is a python docstring""")"
> Custom: R"""""""this is a python docstring"""""""
>
> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
>
> I welcome any comments, criticisms, or suggestions.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From masklinn at masklinn.net  Thu Sep 19 14:13:38 2013
From: masklinn at masklinn.net (Masklinn)
Date: Thu, 19 Sep 2013 23:13:38 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>

On 2013-09-19, at 22:36 , Kevin Ballard wrote:
> 
> I welcome any comments, criticisms, or suggestions.

* C# also has rawstrings, which were not looked at. C#'s rawstrings
  disable escaping entirely but add a new one: doubling quotes will insert
  a single quote in the resulting string (similar to quote-escaping in
  SQL or Smalltalk).
* The docstring comment is incorrect, a docstring is a string in the
  first position of a module, a class statement or a function statement.
  A single-quoted string at these positions will yield a docstring.

  The triple-quoting is a string syntax embedding newlines (single-quoted
  strings can not contain literal newlines in Python, only escaped ones).
  Obviously, triple-quoted python string can be raw.
* The quote-escaping oddness is less of an issue in Python as you can
  also use single-quotes for delimiting, or use triple-quoted strings
  (if you need to embed both single and double quotes in rawstrings).
* Perl's quotes and quote-like operators would certainly deserve mention.

Also,

> windows file paths

windows paths can also use forward slashes so that's not a very
interesting justification.

From kevin at sb.org  Thu Sep 19 14:37:54 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 14:37:54 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
Message-ID: <F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>

I didn't look at Ruby's syntax, but what you just described sounds a little too free-form to me. I believe Ruby at least requires a % as part of the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for rust, as it would conflict with the % operator. I don't think other punctuation would work well either.

-Kevin

On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com> wrote:

> How complicated would it be to use R"" but with arbitrary paired
> delimiters (the way, for instance, ruby does it)? It's very handy to
> pick a delimiter you know does not appear in the string, e.g. if you
> had a string containing ')' you could use R{this is a string with a )
> in it} or R|this is a string with a ) in it|.
> 
> martin
> 
> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
>> 
>> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
>> 
>> ## Python syntax:
>> 
>> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
>> 
>> Pros:
>> * Simple syntax
>> * Allows for embedding the closing quote character in the raw string
>> 
>> Cons:
>> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
>> 
>> ## C++11 syntax:
>> 
>> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
>> 
>> Pros:
>> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
>> * Reasonably straightforward
>> 
>> Cons:
>> * Syntax is slightly complicated
>> 
>> ## D syntax:
>> 
>> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
>> 
>> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>> 
>> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
>> 
>> q"delim
>> this is some raw text
>> delim"
>> 
>> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
>> 
>> Pros:
>> * Flexible
>> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
>> 
>> Cons:
>> * Overly complicated
>> 
>> ## Custom syntax
>> 
>> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
>> 
>> Pros:
>> * Very simple
>> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
>> 
>> Cons:
>> * Slightly odd to read
>> 
>> ## Conclusion
>> 
>> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
>> 
>> C++11: R"("""this is a python docstring""")"
>> Custom: R"""""""this is a python docstring"""""""
>> 
>> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
>> 
>> I welcome any comments, criticisms, or suggestions.
>> 
>> -Kevin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev


From martindemello at gmail.com  Thu Sep 19 14:41:21 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Thu, 19 Sep 2013 14:41:21 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
	<F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
Message-ID: <CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>

Yes, I figured R followed by a non-alphabetical character could serve
the same purpose as ruby's %<char>.

martin

On Thu, Sep 19, 2013 at 2:37 PM, Kevin Ballard <kevin at sb.org> wrote:
> I didn't look at Ruby's syntax, but what you just described sounds a little too free-form to me. I believe Ruby at least requires a % as part of the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for rust, as it would conflict with the % operator. I don't think other punctuation would work well either.
>
> -Kevin
>
> On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com> wrote:
>
>> How complicated would it be to use R"" but with arbitrary paired
>> delimiters (the way, for instance, ruby does it)? It's very handy to
>> pick a delimiter you know does not appear in the string, e.g. if you
>> had a string containing ')' you could use R{this is a string with a )
>> in it} or R|this is a string with a ) in it|.
>>
>> martin
>>
>> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>>> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
>>>
>>> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
>>>
>>> ## Python syntax:
>>>
>>> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
>>>
>>> Pros:
>>> * Simple syntax
>>> * Allows for embedding the closing quote character in the raw string
>>>
>>> Cons:
>>> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
>>>
>>> ## C++11 syntax:
>>>
>>> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
>>>
>>> Pros:
>>> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
>>> * Reasonably straightforward
>>>
>>> Cons:
>>> * Syntax is slightly complicated
>>>
>>> ## D syntax:
>>>
>>> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
>>>
>>> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>>>
>>> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
>>>
>>> q"delim
>>> this is some raw text
>>> delim"
>>>
>>> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
>>>
>>> Pros:
>>> * Flexible
>>> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
>>>
>>> Cons:
>>> * Overly complicated
>>>
>>> ## Custom syntax
>>>
>>> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
>>>
>>> Pros:
>>> * Very simple
>>> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
>>>
>>> Cons:
>>> * Slightly odd to read
>>>
>>> ## Conclusion
>>>
>>> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
>>>
>>> C++11: R"("""this is a python docstring""")"
>>> Custom: R"""""""this is a python docstring"""""""
>>>
>>> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
>>>
>>> I welcome any comments, criticisms, or suggestions.
>>>
>>> -Kevin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>

From kevin at sb.org  Thu Sep 19 14:45:41 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 14:45:41 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
Message-ID: <62438A48-9918-41CC-93BA-D259132AF12F@sb.org>

On Sep 19, 2013, at 2:13 PM, Masklinn <masklinn at masklinn.net> wrote:

> On 2013-09-19, at 22:36 , Kevin Ballard wrote:
>> 
>> I welcome any comments, criticisms, or suggestions.
> 
> * C# also has rawstrings, which were not looked at. C#'s rawstrings
>  disable escaping entirely but add a new one: doubling quotes will insert
>  a single quote in the resulting string (similar to quote-escaping in
>  SQL or Smalltalk).

I've never touched C#. Your description sounds like the "custom syntax" I described. I figured there were existing languages that did this, but none came to mind (I should have known SQL did it though).

> * The docstring comment is incorrect, a docstring is a string in the
>  first position of a module, a class statement or a function statement.
>  A single-quoted string at these positions will yield a docstring.
> 
>  The triple-quoting is a string syntax embedding newlines (single-quoted
>  strings can not contain literal newlines in Python, only escaped ones).
>  Obviously, triple-quoted python string can be raw.

Yes I know, but in my (rather limited) experience with Python, triple-quoted strings are typically used for docstrings. It was just an example anyway.

> * The quote-escaping oddness is less of an issue in Python as you can
>  also use single-quotes for delimiting, or use triple-quoted strings
>  (if you need to embed both single and double quotes in rawstrings).

If I need to embed both ''' and """ in a string, I'm out of luck. For example, I cannot represent the following:

    Triple-quoted strings in Python use the delimiters ''' and """.

> * Perl's quotes and quote-like operators would certainly deserve mention.

I'm not a Perl programmer, but IIRC they look like `q{string}`, right? I don't think this is suitable for Rust because how would you lex `do q{foo()}`? Is this the invalid construct `do some-string` or is it calling a function named q with a closure?

> Also,
> 
>> windows file paths
> 
> windows paths can also use forward slashes so that's not a very
> interesting justification.

Not always. UNC paths must start with \\ (in my testing, //foo/bar/baz is not interpreted as a UNC path by the Windows File Explorer, but \\foo/bar/baz is). There's also paths that start with the verbatim prefix \\?\, which disables interpretation of forward-slashes (among other things).

As I am actively engaged in writing a replacement for the path module, and am currently expanding the test suite for Windows paths, raw strings would be extremely useful to me.

-Kevin

From kevin at sb.org  Thu Sep 19 14:46:21 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Sep 2013 14:46:21 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
	<F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
	<CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>
Message-ID: <AF785968-B355-4770-8AD3-61D007EF3F4C@sb.org>

As I just responded to Masklinn, this is ambiguous. How do you lex `do R{foo()}`?

-Kevin

On Sep 19, 2013, at 2:41 PM, Martin DeMello <martindemello at gmail.com> wrote:

> Yes, I figured R followed by a non-alphabetical character could serve
> the same purpose as ruby's %<char>.
> 
> martin
> 
> On Thu, Sep 19, 2013 at 2:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>> I didn't look at Ruby's syntax, but what you just described sounds a little too free-form to me. I believe Ruby at least requires a % as part of the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for rust, as it would conflict with the % operator. I don't think other punctuation would work well either.
>> 
>> -Kevin
>> 
>> On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com> wrote:
>> 
>>> How complicated would it be to use R"" but with arbitrary paired
>>> delimiters (the way, for instance, ruby does it)? It's very handy to
>>> pick a delimiter you know does not appear in the string, e.g. if you
>>> had a string containing ')' you could use R{this is a string with a )
>>> in it} or R|this is a string with a ) in it|.
>>> 
>>> martin
>>> 
>>> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
>>>> 
>>>> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
>>>> 
>>>> ## Python syntax:
>>>> 
>>>> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
>>>> 
>>>> Pros:
>>>> * Simple syntax
>>>> * Allows for embedding the closing quote character in the raw string
>>>> 
>>>> Cons:
>>>> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
>>>> 
>>>> ## C++11 syntax:
>>>> 
>>>> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
>>>> 
>>>> Pros:
>>>> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
>>>> * Reasonably straightforward
>>>> 
>>>> Cons:
>>>> * Syntax is slightly complicated
>>>> 
>>>> ## D syntax:
>>>> 
>>>> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
>>>> 
>>>> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>>>> 
>>>> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
>>>> 
>>>> q"delim
>>>> this is some raw text
>>>> delim"
>>>> 
>>>> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
>>>> 
>>>> Pros:
>>>> * Flexible
>>>> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
>>>> 
>>>> Cons:
>>>> * Overly complicated
>>>> 
>>>> ## Custom syntax
>>>> 
>>>> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
>>>> 
>>>> Pros:
>>>> * Very simple
>>>> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
>>>> 
>>>> Cons:
>>>> * Slightly odd to read
>>>> 
>>>> ## Conclusion
>>>> 
>>>> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
>>>> 
>>>> C++11: R"("""this is a python docstring""")"
>>>> Custom: R"""""""this is a python docstring"""""""
>>>> 
>>>> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
>>>> 
>>>> I welcome any comments, criticisms, or suggestions.
>>>> 
>>>> -Kevin
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>> 


From martindemello at gmail.com  Thu Sep 19 14:50:47 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Thu, 19 Sep 2013 14:50:47 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <AF785968-B355-4770-8AD3-61D007EF3F4C@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
	<F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
	<CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>
	<AF785968-B355-4770-8AD3-61D007EF3F4C@sb.org>
Message-ID: <CAFrFfuHNpic2Eb1Bz-cgXuFa+cwNTtxm7Sj7ToBxmz1M9NODtQ@mail.gmail.com>

Ah, good point. You could fix it by having a very small whitelist of
acceptable delimiters, but that probably takes it into overcomplex
territory.

martin

On Thu, Sep 19, 2013 at 2:46 PM, Kevin Ballard <kevin at sb.org> wrote:
> As I just responded to Masklinn, this is ambiguous. How do you lex `do R{foo()}`?
>
> -Kevin
>
> On Sep 19, 2013, at 2:41 PM, Martin DeMello <martindemello at gmail.com> wrote:
>
>> Yes, I figured R followed by a non-alphabetical character could serve
>> the same purpose as ruby's %<char>.
>>
>> martin
>>
>> On Thu, Sep 19, 2013 at 2:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>>> I didn't look at Ruby's syntax, but what you just described sounds a little too free-form to me. I believe Ruby at least requires a % as part of the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for rust, as it would conflict with the % operator. I don't think other punctuation would work well either.
>>>
>>> -Kevin
>>>
>>> On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com> wrote:
>>>
>>>> How complicated would it be to use R"" but with arbitrary paired
>>>> delimiters (the way, for instance, ruby does it)? It's very handy to
>>>> pick a delimiter you know does not appear in the string, e.g. if you
>>>> had a string containing ')' you could use R{this is a string with a )
>>>> in it} or R|this is a string with a ) in it|.
>>>>
>>>> martin
>>>>
>>>> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
>>>>>
>>>>> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
>>>>>
>>>>> ## Python syntax:
>>>>>
>>>>> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
>>>>>
>>>>> Pros:
>>>>> * Simple syntax
>>>>> * Allows for embedding the closing quote character in the raw string
>>>>>
>>>>> Cons:
>>>>> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
>>>>>
>>>>> ## C++11 syntax:
>>>>>
>>>>> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
>>>>>
>>>>> Pros:
>>>>> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
>>>>> * Reasonably straightforward
>>>>>
>>>>> Cons:
>>>>> * Syntax is slightly complicated
>>>>>
>>>>> ## D syntax:
>>>>>
>>>>> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
>>>>>
>>>>> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>>>>>
>>>>> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
>>>>>
>>>>> q"delim
>>>>> this is some raw text
>>>>> delim"
>>>>>
>>>>> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
>>>>>
>>>>> Pros:
>>>>> * Flexible
>>>>> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
>>>>>
>>>>> Cons:
>>>>> * Overly complicated
>>>>>
>>>>> ## Custom syntax
>>>>>
>>>>> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
>>>>>
>>>>> Pros:
>>>>> * Very simple
>>>>> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
>>>>>
>>>>> Cons:
>>>>> * Slightly odd to read
>>>>>
>>>>> ## Conclusion
>>>>>
>>>>> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
>>>>>
>>>>> C++11: R"("""this is a python docstring""")"
>>>>> Custom: R"""""""this is a python docstring"""""""
>>>>>
>>>>> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
>>>>>
>>>>> I welcome any comments, criticisms, or suggestions.
>>>>>
>>>>> -Kevin
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>

From smadhueagle at outlook.com  Thu Sep 19 15:19:36 2013
From: smadhueagle at outlook.com (Madhu Srinivasan)
Date: Thu, 19 Sep 2013 22:19:36 +0000
Subject: [rust-dev] rustpkg behavior
Message-ID: <DUB122-W43DA207FC413434FCEAD4CB0210@phx.gbl>

hi fellow rusters, 
I understand that rustpkg is under heavy development and not complete. Having said that, I'd like to know if the following error (w.r.t. rustpkg finding external crates and linking correctly with them) is within it's normal operating parameters :). 
The rust code in question: https://github.com/smadhueagle/rustlings(It is a series of example rust programs)The external crate that it refers to: https://github.com/smadhueagle/rustils
Following the steps in Readme.md on the rustlings repo and building the simplespawn crate results in the following error:
kl-13572:rustlings smadhueagle$ rustpkg build simplespawnWARNING: The Rust package manager is experimental and may be unstabletask <unnamed> failed at 'Unhandled condition: nonexistent_package: (package_id::PkgId{path: std::path::PosixPath{is_absolute: false, components: ~[~"rustils"]}, short_name: ~"rustils", version: NoVersion}, ~"supplied path for package dir does not exist, and couldn't interpret it as a URL fragment")', /private/tmp/rust-nVcw/src/libstd/condition.rs:43task <unnamed> failed at 'killed by linked failure', /private/tmp/rust-nVcw/src/libstd/rt/kill.rs:627
However, when I do the following, everything seems to work and rustc seems to find and link with the rustil module from the .rust directory just fine ... 
kl-13572:rustlings smadhueagle$ rustc src/simplespawn/main.rs warning: no debug symbols in executable (-arch x86_64)kl-13572:rustlings smadhueagle$
Is this behavior normal ? rustpkg works fine if there are no external modules being referred to from the source.
Thanks in advance for your time !
smadhueagle
 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/72529422/attachment.html>

From luis at debethencourt.com  Thu Sep 19 17:00:49 2013
From: luis at debethencourt.com (Luis de Bethencourt)
Date: Fri, 20 Sep 2013 01:00:49 +0100
Subject: [rust-dev] lib: Is anybody working on the datetime library?
In-Reply-To: <523B5745.8000902@mozilla.com>
References: <CAPA4HGW21Org4xCjYD3NWJMddMCLs2AQJ7PNX5KNdQqHkwLz2w@mail.gmail.com>
	<523B5745.8000902@mozilla.com>
Message-ID: <CAPA4HGXyXq6tVk7eHDZZ3t9nb-B_fhANjgxa2auAWqe6-_b3qA@mail.gmail.com>

Hello Chris,

That article by Erik Naggum looks deeply interesting. Just loaded it to
read in bed in a few hours tonight.

Thanks for your input. Might ask you a few questions in the near future.

Luis


On 19 September 2013 20:57, Chris Peterson <cpeterson at mozilla.com> wrote:

> A Rust datetime library has been on my to-do list for a long time. :)
>
> JSR-310 is a very complete solution, but it carries a lot of Java baggage.
> C++11's std::chrono library [1] defines a smaller API for time points and
> durations without calendars (i.e. the hard part). std::chrono's API might
> be more "rustic" than JSR-310's because C++ and Rust have operator
> overloading.
>
> I strongly recommend reading Erik Naggum's "The Long, Painful History of
> Time" [2] about Common Lisp's support for the "concept of time as humans
> experience it."  :)
>
> [1] http://msdn.microsoft.com/en-**us/library/hh874757.aspx<http://msdn.microsoft.com/en-us/library/hh874757.aspx>
> [2] http://naggum.no/lugm-time.**html <http://naggum.no/lugm-time.html>
>
>
> chris
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/acab638c/attachment.html>

From me at kevincantu.org  Thu Sep 19 22:28:18 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Thu, 19 Sep 2013 22:28:18 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFrFfuHNpic2Eb1Bz-cgXuFa+cwNTtxm7Sj7ToBxmz1M9NODtQ@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
	<F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
	<CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>
	<AF785968-B355-4770-8AD3-61D007EF3F4C@sb.org>
	<CAFrFfuHNpic2Eb1Bz-cgXuFa+cwNTtxm7Sj7ToBxmz1M9NODtQ@mail.gmail.com>
Message-ID: <CABq6+adS=uB2eaGCo6JHF+6WuXbmZ4wAJ9tHJ0B62BEr0YGNew@mail.gmail.com>

I think designing good traits to support all these text implementations is
far more important than whatever hungarian notation is preferred for
literals.


Kevin


On Thu, Sep 19, 2013 at 2:50 PM, Martin DeMello <martindemello at gmail.com>wrote:

> Ah, good point. You could fix it by having a very small whitelist of
> acceptable delimiters, but that probably takes it into overcomplex
> territory.
>
> martin
>
> On Thu, Sep 19, 2013 at 2:46 PM, Kevin Ballard <kevin at sb.org> wrote:
> > As I just responded to Masklinn, this is ambiguous. How do you lex `do
> R{foo()}`?
> >
> > -Kevin
> >
> > On Sep 19, 2013, at 2:41 PM, Martin DeMello <martindemello at gmail.com>
> wrote:
> >
> >> Yes, I figured R followed by a non-alphabetical character could serve
> >> the same purpose as ruby's %<char>.
> >>
> >> martin
> >>
> >> On Thu, Sep 19, 2013 at 2:37 PM, Kevin Ballard <kevin at sb.org> wrote:
> >>> I didn't look at Ruby's syntax, but what you just described sounds a
> little too free-form to me. I believe Ruby at least requires a % as part of
> the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for
> rust, as it would conflict with the % operator. I don't think other
> punctuation would work well either.
> >>>
> >>> -Kevin
> >>>
> >>> On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com>
> wrote:
> >>>
> >>>> How complicated would it be to use R"" but with arbitrary paired
> >>>> delimiters (the way, for instance, ruby does it)? It's very handy to
> >>>> pick a delimiter you know does not appear in the string, e.g. if you
> >>>> had a string containing ')' you could use R{this is a string with a )
> >>>> in it} or R|this is a string with a ) in it|.
> >>>>
> >>>> martin
> >>>>
> >>>> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
> >>>>> One feature common to many programming languages that Rust lacks is
> "raw" string literals. Specifically, these are string literals that don't
> interpret backslash-escapes. There are three obvious applications at the
> moment: regular expressions, windows file paths, and format!() strings that
> want to embed { and } chars. I'm sure there are more as well, such as large
> string literals that contain things like HTML text.
> >>>>>
> >>>>> I took a look at 3 programming languages to see what solutions they
> had: D, C++11, and Python. I've reproduced their syntax below, plus one
> more custom syntax, along with pros & cons. I'm hoping we can come up with
> a syntax that makes sense for Rust.
> >>>>>
> >>>>> ## Python syntax:
> >>>>>
> >>>>> Python supports an "r" or "R" prefix on any string literal (both
> "short" strings, delimited with a single quote, or "long" strings,
> delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and
> has the effect of disabling backslash-escapes within the string. For the
> most part. It actually gets a bit weird: if a sequence of backslashes of an
> odd length occurs prior to a quote (of the appropriate quote type for the
> string), then the quote is considered to be escaped, but the backslashes
> are left in the string. This means r"foo\"" evaluates to the string
> `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the
> string `foo\\`.
> >>>>>
> >>>>> Pros:
> >>>>> * Simple syntax
> >>>>> * Allows for embedding the closing quote character in the raw string
> >>>>>
> >>>>> Cons:
> >>>>> * Handling of backslashes is very bizarre, and the closing quote
> character can only be embedded if you want to have a backslash before it.
> >>>>>
> >>>>> ## C++11 syntax:
> >>>>>
> >>>>> C++11 allows for raw strings using a sequence of the form R"seq(raw
> text)seq". In this construct, `seq` is any sequence of (zero or more)
> characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form
> looks like R"(raw text)", which allows for anything in the raw text except
> for the sequence `)"`. The addition of the delimiter sequence allows for
> constructing a raw string containing any sequence at all (as the delimiter
> sequence can be adjusted based on the represented text).
> >>>>>
> >>>>> Pros:
> >>>>> * Allows for embedding any character at all (representable in the
> source file encoding), including the closing quote.
> >>>>> * Reasonably straightforward
> >>>>>
> >>>>> Cons:
> >>>>> * Syntax is slightly complicated
> >>>>>
> >>>>> ## D syntax:
> >>>>>
> >>>>> D supports three different forms of raw strings. The first two are
> similar, being r"raw text" and `raw text`. Besides the choice of
> delimiters, they behave identically, in that the raw text may contain
> anything except for the appropriate quote character. The third syntax is a
> slightly more complicated form of C++11's syntax, and is called a delimited
> string. It takes two forms.
> >>>>>
> >>>>> The first looks like q"(raw text)" where the ( may be any
> non-identifier non-whitespace character. If the character is one of [(<{
> then it is a "nesting delimiter", and the close delimiter must be the
> matching ])>} character, otherwise the close delimiter is the same as the
> open. Furthermore, nesting delimiters do exactly what their name says: they
> nest. If the nesting delimiter is (), then any ( in the raw text must be
> balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates
> to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
> >>>>>
> >>>>> The second uses any identifier as the delimiter. In this case, the
> identifier must immediately be followed by a newline, and in order to close
> the string, the close delimiter must be preceded by a newline. This looks
> like
> >>>>>
> >>>>> q"delim
> >>>>> this is some raw text
> >>>>> delim"
> >>>>>
> >>>>> It's essentially a heredoc. Note that the first newline is not part
> of the string, but the final newline is, so this evaluates to "this is some
> raw text\n".
> >>>>>
> >>>>> Pros:
> >>>>> * Flexible
> >>>>> * Allows for constructing a raw string that contains any desired
> sequence of characters (representable in the source file's encoding)
> >>>>>
> >>>>> Cons:
> >>>>> * Overly complicated
> >>>>>
> >>>>> ## Custom syntax
> >>>>>
> >>>>> There's another approach that none of these three languages take,
> which is to merely allow for doubling up the quote character in order to
> embed a quote. This would look like R"raw string literal ""with embedded
> quotes"".", which becomes `raw string literal "with embedded quotes"`.
> >>>>>
> >>>>> Pros:
> >>>>> * Very simple
> >>>>> * Allows for embedding the close quote character, and therefore, any
> character (representable in the source file encoding)
> >>>>>
> >>>>> Cons:
> >>>>> * Slightly odd to read
> >>>>>
> >>>>> ## Conclusion
> >>>>>
> >>>>> Of the three existing syntaxes examined here, I think C++11's is the
> best. It ties with D's syntax for being the most powerful, but is simpler
> than D's. The custom syntax is just as powerful though. The benefit of the
> C++11 syntax over the custom syntax is it's slightly easier to read the
> C++11 syntax, as the raw text has a 1-to-one mapping with the resulting
> string. The custom syntax is a bit more confusing to read, especially if
> you want to add multiple quotes. As a pathological case, let's try
> representing a Python triple-quoted docstring using both syntaxes:
> >>>>>
> >>>>> C++11: R"("""this is a python docstring""")"
> >>>>> Custom: R"""""""this is a python docstring"""""""
> >>>>>
> >>>>> Based on this examination, I'm leaning towards saying Rust should
> support C++11's raw string literal syntax.
> >>>>>
> >>>>> I welcome any comments, criticisms, or suggestions.
> >>>>>
> >>>>> -Kevin
> >>>>> _______________________________________________
> >>>>> Rust-dev mailing list
> >>>>> Rust-dev at mozilla.org
> >>>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/c991baff/attachment-0001.html>

From klutzytheklutzy at gmail.com  Thu Sep 19 22:49:47 2013
From: klutzytheklutzy at gmail.com (klutzy)
Date: Fri, 20 Sep 2013 14:49:47 +0900
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADecdi+qwsbjGqf1eTT_5rRLpjLmzx+mpSrgTiPQG54rLQ22Uw@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
	<CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
	<CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>
	<5237A927.30309@mozilla.com>
	<CADecdiJThEL2Rrpeu-B74Q_KBrOT_2bAbnkx8Qcv1w9p93AveQ@mail.gmail.com>
	<D84EE373-2484-4673-A152-27EE9A61445A@mozilla.com>
	<CADecdi+qwsbjGqf1eTT_5rRLpjLmzx+mpSrgTiPQG54rLQ22Uw@mail.gmail.com>
Message-ID: <CADzE6JPb6Y-Pp+fUgHYw2nVfrM0Ofq2CeoKir1uyQYHcHqw2ew@mail.gmail.com>

> I wonder if we should just bundle runtime libraries with the stage0 snapshot in the future?

I think we should bundle them: https://github.com/mozilla/rust/issues/9252

On Thu, Sep 19, 2013 at 7:16 AM, Vadim <vadimcn at gmail.com> wrote:
> Okay, looks like my mingw 4 fix went in last night.
>
> Here's my personal recipe for setting up mingw:
> 1. Download and install mingw-get
> 2. Install the required packages.  One can do this in GUI, but I prefer the
> command line, as it's less ambiguous:
>          mingw-get install mingw-developer-toolkit
>          mingw-get install mingw32-base
>          mingw-get install mingw32-gcc-g++
>          mingw-get install mingw32-libpthreadgc
>          mingw-get install msys-wget
> 3. Install GIT and Python, make sure they are on the PATH
> 4. In MSYS shell:  ../configure; make check-fast
>
> Until stage0 snapshot compiler has been rebuilt with new mingw, stage0
> compilation will fail because latest mingw has wrong versions of the runtime
> libraries that rustc depends on.  So:
> 5.. Get old versions of these dlls:
>         mingw-get upgrade "g++<4.6"
>         mingw-get upgrade "libpthread=2.8.0-3"
> 6.. Copy libgcc_s_dw2-1.dll, libstdc++-6.dll and libpthread-2.dll from
> %mingw%\bin into %build%\i686-pc-mingw32\stage0\bin.
> 7. Roll mingw back to the latest:
>         mingw-get upgrade
> 8.. make check-fast
>
> I wonder if we should just bundle runtime libraries with the stage0 snapshot
> in the future?
>
> Vadim
>
>
> On Mon, Sep 16, 2013 at 6:33 PM, Alex Crichton <acrichton at mozilla.com>
> wrote:
>>
>> Hey guys, so we're gonna hold off on upgrading the windows builders until
>> we're 100% sure that we won't bork them with a mingw upgrade. What I think
>> that we can do, on the other hand, is:
>>
>> 1. Land Vadim's patch onto master
>> 2. I spin up a clean windows vm (need to do that anyway)
>> 3. Could you guys send me a list of instructions to build rust on "the
>> most recent" mingw?
>> 4. Once verified, and possible bugs fixed, we can go upgrade the builders
>> and documentation about mingw
>>
>> Ideally the "build instructions" would be:
>>
>> A. Acquire mingw.
>> B. Acquire relevant gcc version 4.X
>> C. ./configure && make
>>
>> It'd be awesome to keep it that simple, and it seems that your patches
>> would have eliminated the need for patching system files?
>>
>> How does that sound to you guys?
>>
>> On Sep 16, 2013, at 6:20 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>

From j.e.aten at gmail.com  Thu Sep 19 23:40:37 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Thu, 19 Sep 2013 23:40:37 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
Message-ID: <CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>

On Thu, Sep 19, 2013 at 11:51 AM, Alex Crichton <alex at crichton.co> wrote:

> Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
> I think that it should be important to be able to fail! and have the
> repl state intact afterwards.
>

Agreed. I'm convinced that fail! should result in an almost-magical "lets
pretend that never happened" jump back in time.

I'm still trying to figure out how to do this efficiently. For code that
has alot of state, serializing and deserializing everything will be too
slow.

Perhaps the best thing is just to fork(2), so we get a new (OS level)
process that has copy-on-write (virtual) memory, and if the compilation +
run succeeds in the child, then have the child "take over". Otherwise the
child dies with an fail! + location message, and we return to the parent
exactly before the child was spawned.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/317bb0f9/attachment.html>

From raphael.catolino at gmail.com  Fri Sep 20 00:07:16 2013
From: raphael.catolino at gmail.com (raphael catolino)
Date: Fri, 20 Sep 2013 09:07:16 +0200
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
Message-ID: <CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>

> Perhaps the best thing is just to fork(2), so we get a new (OS level)
> process that has copy-on-write (virtual) memory, and if the compilation +
> run succeeds in the child, then have the child "take over". Otherwise the
> child dies with an fail! + location message, and we return to the parent
> exactly before the child was spawned.

Do you intend for rusti to work on windows? Because I'm not sure you
could do something like that efficiently there.

On Fri, Sep 20, 2013 at 8:40 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:
> On Thu, Sep 19, 2013 at 11:51 AM, Alex Crichton <alex at crichton.co> wrote:
>>
>> Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
>> I think that it should be important to be able to fail! and have the
>> repl state intact afterwards.
>
>
> Agreed. I'm convinced that fail! should result in an almost-magical "lets
> pretend that never happened" jump back in time.
>
> I'm still trying to figure out how to do this efficiently. For code that has
> alot of state, serializing and deserializing everything will be too slow.
>
> Perhaps the best thing is just to fork(2), so we get a new (OS level)
> process that has copy-on-write (virtual) memory, and if the compilation +
> run succeeds in the child, then have the child "take over". Otherwise the
> child dies with an fail! + location message, and we return to the parent
> exactly before the child was spawned.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From andrew at du.nham.ca  Fri Sep 20 01:02:26 2013
From: andrew at du.nham.ca (Andrew Dunham)
Date: Fri, 20 Sep 2013 01:02:26 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CABq6+adS=uB2eaGCo6JHF+6WuXbmZ4wAJ9tHJ0B62BEr0YGNew@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAFrFfuHQ6WCVq+=-7ckkMAL-OW7AkgNgTz6VpyOzJriLsrcH4w@mail.gmail.com>
	<F4CBD9DF-FE9C-43C1-BF37-488FC523BB74@sb.org>
	<CAFrFfuF7RG9LEzEZpWCqD6s5xmfv_rbA1rujx0=BzVUGHvpeAA@mail.gmail.com>
	<AF785968-B355-4770-8AD3-61D007EF3F4C@sb.org>
	<CAFrFfuHNpic2Eb1Bz-cgXuFa+cwNTtxm7Sj7ToBxmz1M9NODtQ@mail.gmail.com>
	<CABq6+adS=uB2eaGCo6JHF+6WuXbmZ4wAJ9tHJ0B62BEr0YGNew@mail.gmail.com>
Message-ID: <CADSBmCBJy=WrSx7BifOqErVJ9ryghKWx-H3pkcGLM65pjGCJsQ@mail.gmail.com>

The way that Lua does raw strings is also fairly nifty.  Check out
http://www.lua.org/manual/5.2/manual.html, section 3.1, or, in short:

- Strings can be delimited by "[===[", with any number of equals signs.
 The corresponding closing delimiter must match the original number of
equals signs.
- No escaping is done.
- Any kind of end-of-line sequence (i.e. "\r" and "\n" in any order) is
converted to just a newline.
- It can run for multiple lines.

--Andrew D


On Thu, Sep 19, 2013 at 10:28 PM, Kevin Cantu <me at kevincantu.org> wrote:

> I think designing good traits to support all these text implementations is
> far more important than whatever hungarian notation is preferred for
> literals.
>
>
> Kevin
>
>
> On Thu, Sep 19, 2013 at 2:50 PM, Martin DeMello <martindemello at gmail.com>wrote:
>
>> Ah, good point. You could fix it by having a very small whitelist of
>> acceptable delimiters, but that probably takes it into overcomplex
>> territory.
>>
>> martin
>>
>> On Thu, Sep 19, 2013 at 2:46 PM, Kevin Ballard <kevin at sb.org> wrote:
>> > As I just responded to Masklinn, this is ambiguous. How do you lex `do
>> R{foo()}`?
>> >
>> > -Kevin
>> >
>> > On Sep 19, 2013, at 2:41 PM, Martin DeMello <martindemello at gmail.com>
>> wrote:
>> >
>> >> Yes, I figured R followed by a non-alphabetical character could serve
>> >> the same purpose as ruby's %<char>.
>> >>
>> >> martin
>> >>
>> >> On Thu, Sep 19, 2013 at 2:37 PM, Kevin Ballard <kevin at sb.org> wrote:
>> >>> I didn't look at Ruby's syntax, but what you just described sounds a
>> little too free-form to me. I believe Ruby at least requires a % as part of
>> the syntax, e.g. %q{test}. But I don't think %R{test} is a good idea for
>> rust, as it would conflict with the % operator. I don't think other
>> punctuation would work well either.
>> >>>
>> >>> -Kevin
>> >>>
>> >>> On Sep 19, 2013, at 2:10 PM, Martin DeMello <martindemello at gmail.com>
>> wrote:
>> >>>
>> >>>> How complicated would it be to use R"" but with arbitrary paired
>> >>>> delimiters (the way, for instance, ruby does it)? It's very handy to
>> >>>> pick a delimiter you know does not appear in the string, e.g. if you
>> >>>> had a string containing ')' you could use R{this is a string with a )
>> >>>> in it} or R|this is a string with a ) in it|.
>> >>>>
>> >>>> martin
>> >>>>
>> >>>> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>> >>>>> One feature common to many programming languages that Rust lacks is
>> "raw" string literals. Specifically, these are string literals that don't
>> interpret backslash-escapes. There are three obvious applications at the
>> moment: regular expressions, windows file paths, and format!() strings that
>> want to embed { and } chars. I'm sure there are more as well, such as large
>> string literals that contain things like HTML text.
>> >>>>>
>> >>>>> I took a look at 3 programming languages to see what solutions they
>> had: D, C++11, and Python. I've reproduced their syntax below, plus one
>> more custom syntax, along with pros & cons. I'm hoping we can come up with
>> a syntax that makes sense for Rust.
>> >>>>>
>> >>>>> ## Python syntax:
>> >>>>>
>> >>>>> Python supports an "r" or "R" prefix on any string literal (both
>> "short" strings, delimited with a single quote, or "long" strings,
>> delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and
>> has the effect of disabling backslash-escapes within the string. For the
>> most part. It actually gets a bit weird: if a sequence of backslashes of an
>> odd length occurs prior to a quote (of the appropriate quote type for the
>> string), then the quote is considered to be escaped, but the backslashes
>> are left in the string. This means r"foo\"" evaluates to the string
>> `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the
>> string `foo\\`.
>> >>>>>
>> >>>>> Pros:
>> >>>>> * Simple syntax
>> >>>>> * Allows for embedding the closing quote character in the raw string
>> >>>>>
>> >>>>> Cons:
>> >>>>> * Handling of backslashes is very bizarre, and the closing quote
>> character can only be embedded if you want to have a backslash before it.
>> >>>>>
>> >>>>> ## C++11 syntax:
>> >>>>>
>> >>>>> C++11 allows for raw strings using a sequence of the form R"seq(raw
>> text)seq". In this construct, `seq` is any sequence of (zero or more)
>> characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form
>> looks like R"(raw text)", which allows for anything in the raw text except
>> for the sequence `)"`. The addition of the delimiter sequence allows for
>> constructing a raw string containing any sequence at all (as the delimiter
>> sequence can be adjusted based on the represented text).
>> >>>>>
>> >>>>> Pros:
>> >>>>> * Allows for embedding any character at all (representable in the
>> source file encoding), including the closing quote.
>> >>>>> * Reasonably straightforward
>> >>>>>
>> >>>>> Cons:
>> >>>>> * Syntax is slightly complicated
>> >>>>>
>> >>>>> ## D syntax:
>> >>>>>
>> >>>>> D supports three different forms of raw strings. The first two are
>> similar, being r"raw text" and `raw text`. Besides the choice of
>> delimiters, they behave identically, in that the raw text may contain
>> anything except for the appropriate quote character. The third syntax is a
>> slightly more complicated form of C++11's syntax, and is called a delimited
>> string. It takes two forms.
>> >>>>>
>> >>>>> The first looks like q"(raw text)" where the ( may be any
>> non-identifier non-whitespace character. If the character is one of [(<{
>> then it is a "nesting delimiter", and the close delimiter must be the
>> matching ])>} character, otherwise the close delimiter is the same as the
>> open. Furthermore, nesting delimiters do exactly what their name says: they
>> nest. If the nesting delimiter is (), then any ( in the raw text must be
>> balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates
>> to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>> >>>>>
>> >>>>> The second uses any identifier as the delimiter. In this case, the
>> identifier must immediately be followed by a newline, and in order to close
>> the string, the close delimiter must be preceded by a newline. This looks
>> like
>> >>>>>
>> >>>>> q"delim
>> >>>>> this is some raw text
>> >>>>> delim"
>> >>>>>
>> >>>>> It's essentially a heredoc. Note that the first newline is not part
>> of the string, but the final newline is, so this evaluates to "this is some
>> raw text\n".
>> >>>>>
>> >>>>> Pros:
>> >>>>> * Flexible
>> >>>>> * Allows for constructing a raw string that contains any desired
>> sequence of characters (representable in the source file's encoding)
>> >>>>>
>> >>>>> Cons:
>> >>>>> * Overly complicated
>> >>>>>
>> >>>>> ## Custom syntax
>> >>>>>
>> >>>>> There's another approach that none of these three languages take,
>> which is to merely allow for doubling up the quote character in order to
>> embed a quote. This would look like R"raw string literal ""with embedded
>> quotes"".", which becomes `raw string literal "with embedded quotes"`.
>> >>>>>
>> >>>>> Pros:
>> >>>>> * Very simple
>> >>>>> * Allows for embedding the close quote character, and therefore,
>> any character (representable in the source file encoding)
>> >>>>>
>> >>>>> Cons:
>> >>>>> * Slightly odd to read
>> >>>>>
>> >>>>> ## Conclusion
>> >>>>>
>> >>>>> Of the three existing syntaxes examined here, I think C++11's is
>> the best. It ties with D's syntax for being the most powerful, but is
>> simpler than D's. The custom syntax is just as powerful though. The benefit
>> of the C++11 syntax over the custom syntax is it's slightly easier to read
>> the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting
>> string. The custom syntax is a bit more confusing to read, especially if
>> you want to add multiple quotes. As a pathological case, let's try
>> representing a Python triple-quoted docstring using both syntaxes:
>> >>>>>
>> >>>>> C++11: R"("""this is a python docstring""")"
>> >>>>> Custom: R"""""""this is a python docstring"""""""
>> >>>>>
>> >>>>> Based on this examination, I'm leaning towards saying Rust should
>> support C++11's raw string literal syntax.
>> >>>>>
>> >>>>> I welcome any comments, criticisms, or suggestions.
>> >>>>>
>> >>>>> -Kevin
>> >>>>> _______________________________________________
>> >>>>> Rust-dev mailing list
>> >>>>> Rust-dev at mozilla.org
>> >>>>> https://mail.mozilla.org/listinfo/rust-dev
>> >>>
>> >
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/54ad6b36/attachment-0001.html>

From masklinn at masklinn.net  Fri Sep 20 01:13:39 2013
From: masklinn at masklinn.net (Masklinn)
Date: Fri, 20 Sep 2013 10:13:39 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
Message-ID: <698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>

On 2013-09-19, at 23:45 , Kevin Ballard wrote:
> Yes I know, but in my (rather limited) experience with Python, triple-quoted strings are typically used for docstrings. It was just an example anyway.

They're also commonly used for multiline strings as single-quoted strings don't require it.

> 
>> * The quote-escaping oddness is less of an issue in Python as you can
>> also use single-quotes for delimiting, or use triple-quoted strings
>> (if you need to embed both single and double quotes in rawstrings).
> 
> If I need to embed both ''' and """ in a string, I'm out of luck.

The chance of that is as remote as can be. I've never seen or heard of
it happen. And mind, the issue must happen *in a rawstring* which is
even more unlikely.

>> Also,
>> 
>>> windows file paths
>> 
>> windows paths can also use forward slashes so that's not a very
>> interesting justification.
> 
> Not always. UNC paths must start with \\ (in my testing, //foo/bar/baz is not interpreted as a UNC path by the Windows File Explorer, but \\foo/bar/baz is).

True. Do you expect writing literal UNC paths in Rust to be a common occurrence?

> There's also paths that start with the verbatim prefix \\?\, which disables interpretation of forward-slashes (among other things).

That's not really relevant to a rawstrings proposal, why would a
developer embed such a path literally?

> As I am actively engaged in writing a replacement for the path module, and am currently expanding the test suite for Windows paths, raw strings would be extremely useful to me.

I'd have thought it a better idea to use path builders (maybe macros)
and avoid embedding literal path separators in order to avoid
portability issues.

From kevin at sb.org  Fri Sep 20 01:25:22 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 20 Sep 2013 01:25:22 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
Message-ID: <2AF0BB60-D596-4E21-9842-D5BF796F8AFF@sb.org>

On Sep 20, 2013, at 1:13 AM, Masklinn <masklinn at masklinn.net> wrote:

>>> Also,
>>> 
>>>> windows file paths
>>> 
>>> windows paths can also use forward slashes so that's not a very
>>> interesting justification.
>> 
>> Not always. UNC paths must start with \\ (in my testing, //foo/bar/baz is not interpreted as a UNC path by the Windows File Explorer, but \\foo/bar/baz is).
> 
> True. Do you expect writing literal UNC paths in Rust to be a common occurrence?

Maybe not for most people, but I've been writing them a _lot_ lately (I'm rewriting the path module).

Regular expressions is really the most common application here.

>> There's also paths that start with the verbatim prefix \\?\, which disables interpretation of forward-slashes (among other things).
> 
> That's not really relevant to a rawstrings proposal, why would a
> developer embed such a path literally?

Perhaps they want to hard-code a path that refers to something that requires the \\?\ prefix (such as a path that contains / as part of a path component, or is longer than 255 characters).

But just in general, \ is the canonical Windows path separator. I don't think "use /" is particularly great advice. What if this string is intended for displaying?

>> As I am actively engaged in writing a replacement for the path module, and am currently expanding the test suite for Windows paths, raw strings would be extremely useful to me.
> 
> I'd have thought it a better idea to use path builders (maybe macros)
> and avoid embedding literal path separators in order to avoid
> portability issues.

People still use literal path separators in strings all the time in languages that support path-building methods.

-Kevin

From marijnh at gmail.com  Fri Sep 20 01:26:03 2013
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Fri, 20 Sep 2013 10:26:03 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
Message-ID: <CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>

>> If I need to embed both ''' and """ in a string, I'm out of luck.
>
> The chance of that is as remote as can be. I've never seen or heard of
> it happen. And mind, the issue must happen *in a rawstring* which is
> even more unlikely.

You should note that, as soon as you include something in the language
itself, that creates meaningful strings (programs in the language)
that include the token, which are not likely, at some point, to need
to be written as a multiline string in the language itself.

(As a related example, as someone writing JavaScript-analyzing code in
JavaScript, I've had several bugs caused by the fact that the
nonsense, no-one-is-ever-going-to-use-this word __proto__ has a very
hard to suppress special meaning, and you *are* going to use it when
analyzing the elements in another JavaScript program.)

From masklinn at masklinn.net  Fri Sep 20 01:38:11 2013
From: masklinn at masklinn.net (Masklinn)
Date: Fri, 20 Sep 2013 10:38:11 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
Message-ID: <871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>

On 2013-09-20, at 10:26 , Marijn Haverbeke wrote:
>>> If I need to embed both ''' and """ in a string, I'm out of luck.
>> 
>> The chance of that is as remote as can be. I've never seen or heard of
>> it happen. And mind, the issue must happen *in a rawstring* which is
>> even more unlikely.
> 
> You should note that, as soon as you include something in the language
> itself, that creates meaningful strings (programs in the language)
> that include the token, which are not likely, at some point, to need
> to be written as a multiline string in the language itself.

It's already noted, my objections are very much that this is highly
unlikely to be an issue as it only comes to a head when needing
*triple-quoted rawstrings* to include *their own* delimiters
(meaning a triple-quoted rawstring which needs to include both
triple-quoted delimiters at the same time).

Even unlikelier given python will concatenate string literals during
parsing.

On 2013-09-20, at 10:25 , Kevin Ballard wrote:
> Regular expressions is really the most common application here.

Right, which was just about all I was saying in the original message.

> People still use literal path separators in strings all the time in languages that support path-building methods.

Something I don't believe should be encouraged.

From andres.osinski at gmail.com  Fri Sep 20 01:41:55 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Fri, 20 Sep 2013 05:41:55 -0300
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
Message-ID: <CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>

Out of all the mentioned syntaxes, Python's seems simple and easy (and the
corner cases appear to be fairly unlikely for the actual use cases for raw
strings), Ruby's seems very powerful and if a couple of restrictions are
added could probably fit well, and Lua's seem very well designed by
allowing delimiters of arbitrary length.

As a user of higher-level languages, all of these seem appealing to me. I
don't really feel that rawstring should be complicated to use, and I don't
really think the limitations are bad so long as they areexplicitly
documented (which is how it should be).


On Fri, Sep 20, 2013 at 5:38 AM, Masklinn <masklinn at masklinn.net> wrote:

> On 2013-09-20, at 10:26 , Marijn Haverbeke wrote:
> >>> If I need to embed both ''' and """ in a string, I'm out of luck.
> >>
> >> The chance of that is as remote as can be. I've never seen or heard of
> >> it happen. And mind, the issue must happen *in a rawstring* which is
> >> even more unlikely.
> >
> > You should note that, as soon as you include something in the language
> > itself, that creates meaningful strings (programs in the language)
> > that include the token, which are not likely, at some point, to need
> > to be written as a multiline string in the language itself.
>
> It's already noted, my objections are very much that this is highly
> unlikely to be an issue as it only comes to a head when needing
> *triple-quoted rawstrings* to include *their own* delimiters
> (meaning a triple-quoted rawstring which needs to include both
> triple-quoted delimiters at the same time).
>
> Even unlikelier given python will concatenate string literals during
> parsing.
>
> On 2013-09-20, at 10:25 , Kevin Ballard wrote:
> > Regular expressions is really the most common application here.
>
> Right, which was just about all I was saying in the original message.
>
> > People still use literal path separators in strings all the time in
> languages that support path-building methods.
>
> Something I don't believe should be encouraged.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/cc52daa4/attachment.html>

From kevin at sb.org  Fri Sep 20 01:47:03 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 20 Sep 2013 01:47:03 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
Message-ID: <1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>

Python's has really stupid handling of backslashes, and I really don't like how it cannot represent all valid strings. I'd really prefer not to make that same mistake.

Ruby's syntax cannot be used because % lexes as an operator.

Of the 3, Lua's is probably the best, although it's a bit esoteric (with using [[ and nary a quote in sight). It seems roughly equivalent to C++11's syntax though, both in ease of use and flexibility.

-Kevin

On Sep 20, 2013, at 1:41 AM, Andres Osinski <andres.osinski at gmail.com> wrote:

> Out of all the mentioned syntaxes, Python's seems simple and easy (and the corner cases appear to be fairly unlikely for the actual use cases for raw strings), Ruby's seems very powerful and if a couple of restrictions are added could probably fit well, and Lua's seem very well designed by allowing delimiters of arbitrary length.
> 
> As a user of higher-level languages, all of these seem appealing to me. I don't really feel that rawstring should be complicated to use, and I don't really think the limitations are bad so long as they areexplicitly documented (which is how it should be).
> 
> 
> On Fri, Sep 20, 2013 at 5:38 AM, Masklinn <masklinn at masklinn.net> wrote:
> On 2013-09-20, at 10:26 , Marijn Haverbeke wrote:
> >>> If I need to embed both ''' and """ in a string, I'm out of luck.
> >>
> >> The chance of that is as remote as can be. I've never seen or heard of
> >> it happen. And mind, the issue must happen *in a rawstring* which is
> >> even more unlikely.
> >
> > You should note that, as soon as you include something in the language
> > itself, that creates meaningful strings (programs in the language)
> > that include the token, which are not likely, at some point, to need
> > to be written as a multiline string in the language itself.
> 
> It's already noted, my objections are very much that this is highly
> unlikely to be an issue as it only comes to a head when needing
> *triple-quoted rawstrings* to include *their own* delimiters
> (meaning a triple-quoted rawstring which needs to include both
> triple-quoted delimiters at the same time).
> 
> Even unlikelier given python will concatenate string literals during
> parsing.
> 
> On 2013-09-20, at 10:25 , Kevin Ballard wrote:
> > Regular expressions is really the most common application here.
> 
> Right, which was just about all I was saying in the original message.
> 
> > People still use literal path separators in strings all the time in languages that support path-building methods.
> 
> Something I don't believe should be encouraged.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> -- 
> Andr?s Osinski
> http://www.andresosinski.com.ar/
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/1158127c/attachment-0001.html>

From o.renaud at gmx.fr  Fri Sep 20 02:18:52 2013
From: o.renaud at gmx.fr (Olivier Renaud)
Date: Fri, 20 Sep 2013 11:18:52 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <52338BBF.4000803@exyr.org>
References: <522F3EF7.1000507@exyr.org> <52338BBF.4000803@exyr.org>
Message-ID: <1726832.5qjY4bH8Pf@bureau-linux>

I really like the API you are proposing. In particular, the error handling is 
close to what I was expecting from such an API.

I have some remarks, though.

Is there a reason for encoders and decoders to not be reusable ? I think it 
would be reasonable to specify that they get back to their initial state once 
the 'flush' method is called, or when a 'DecodeError' is returned.

Is a condition raised when the order of method calls is not respected ? E.g. 
if one calls 'flush' multiple times, of calls 'feed' and then 'decode' ?

It is not clear what is given as a parameter to the 'decoding_error' 
condition. I guess it's the exact subset of byte sequence that cannot be 
decoded, possibly spanning multiple 'feed' calls. Is that correct ? Is it 
sufficient for variable-length encodings ?

I am doubtful that the encoder is just a decoder with [u8] and str swapped. A 
decoder must deal with a possibly invalid sequence of bytes, while an encoder 
deals with str, which is guaranteed to be a valid utf8 sequence. An encoder 
must handle unmappable characters, whereas a decoder doesn't (actually, it 
depends whether we consider unicode to be universal or not...).

I think it would be a good idea to make a difference between an invalid 
sequence and an unmappable character. I think there should be both an 
'invalid_sequence' and an 'unmappable_char' condition.

Also, the 'fatal' handler is a bit scary, based on the name I'd expect it to 
result in a 'fail!'.

I propose this set of conditions and handlers :

// Decoder conditions
condition! {
     /// The byte sequence is not a valid input
     pub invalid_sequence : ~[u8] -> Option<~str>;
     /// The byte sequence cannot be represented in Unicode (rarely used)
     pub unmappable_bytes : ~[u8] -> Option<~str>;
}

// Encoder condition
condition! {
     /// The Unicode string cannot be represented in the target encoding
     /// (essential for single byte encodings)
     pub unmappable_str : ~str -> Option<~[u8]>;
}

/// Functions to be used with invalid_sequence::cond.trap
/// or unmappable_bytes::cond.trap
mod decoding_error_handlers {
     fn decoder_error(_: ~[u8]) -> Option<~str> { None }
     fn replacement(_: ~[u8]) -> Option<~str> { Some(~"\uFFFD") }
     fn ascii_substitute(_: ~[u8]) -> Option<~str> { Some(~"\u001A") }
     fn ignore(_: ~[u8]) -> Option<~str> { Some(~"") }
}

/// Functions to be used with unmappable_str::cond.trap
mod encoding_error_handlers {
     fn decoder_error(_: ~str) -> Option<~[u8]> { None }
     fn ascii_substitute(_: ~str) -> Option<~[u8]> { Some(~[0x1A]) }
     fn ignore(_: ~str) -> Option<~[u8]> { Some(~[]) }
}

Not sure about this substitute/replacement duality. Maybe we can have only one 
function name 'default', that would be FFFD for unicode and 1A for ascii.

From simon.sapin at exyr.org  Fri Sep 20 03:47:04 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 20 Sep 2013 11:47:04 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <1726832.5qjY4bH8Pf@bureau-linux>
References: <522F3EF7.1000507@exyr.org> <52338BBF.4000803@exyr.org>
	<1726832.5qjY4bH8Pf@bureau-linux>
Message-ID: <523C27A8.3080605@exyr.org>

Le 20/09/2013 10:18, Olivier Renaud a ?crit :
> I really like the API you are proposing. In particular, the error handling is
> close to what I was expecting from such an API.
>
> I have some remarks, though.
>
> Is there a reason for encoders and decoders to not be reusable ? I think it
> would be reasonable to specify that they get back to their initial state once
> the 'flush' method is called, or when a 'DecodeError' is returned.

I don?t have a strong opinion on that. There could be a "reset" or 
similar method, but I don?t see how this is better than just throwing 
the decoder away and making a new one.

With static dispatch and the encoding known at compile-time, you can 
probably have decoders on the stack so making a new one is cheap.

If the encoding is determined at run-time and you use trait objects 
(dynamic dispatch) for decoders, the next input might have a different 
encoding so reusing decoders might not be useful either.


> Is a condition raised when the order of method calls is not respected ? E.g.
> if one calls 'flush' multiple times, of calls 'feed' and then 'decode' ?

Decoder::decode is a static method / associated function. It?s 
independent from everything else.

Other than that, I don?t know. rust-encoding doesn?t do that. AFAIU it 
leaves this behavior undefined, which I think is fine. Do you think it 
should be explicitly checked for?


> It is not clear what is given as a parameter to the 'decoding_error'
> condition. I guess it's the exact subset of byte sequence that cannot be
> decoded, possibly spanning multiple 'feed' calls. Is that correct ? Is it
> sufficient for variable-length encodings ?

Correct, and I think yes. It is called once every time the spec says to 
"run the error algorithm":

http://encoding.spec.whatwg.org/#error


> I am doubtful that the encoder is just a decoder with [u8] and str swapped. A
> decoder must deal with a possibly invalid sequence of bytes, while an encoder
> deals with str, which is guaranteed to be a valid utf8 sequence. An encoder
> must handle unmappable characters, whereas a decoder doesn't

You?re right, I cut some corners. In particular, the encoding_error 
condition can take a single (unsupported) 'char'. Other than that, the 
*API* is (very close to?) the same with [u8] and str swapped.


> (actually, it
> depends whether we consider unicode to be universal or not...).

I suggest we consider it is. (For the purpose of the WHATWG spec it is.) 
If Unicode is missing things, the "right" solution is to add things to 
Unicode.


> I think it would be a good idea to make a difference between an invalid
> sequence and an unmappable character. I think there should be both an
> 'invalid_sequence' and an 'unmappable_char' condition.

That?s the distinction between decoding_error and encoding_error, which 
already exists.


> Also, the 'fatal' handler is a bit scary, based on the name I'd expect it to
> result in a 'fail!'.

I?m open to other names. Maybe "abort"? The idea is that you reject the 
entirety of this input (including previous successful calls to .feed())


> I propose this set of conditions and handlers :
>
> // Decoder conditions
> condition! {
>       /// The byte sequence is not a valid input
>       pub invalid_sequence : ~[u8] -> Option<~str>;
>       /// The byte sequence cannot be represented in Unicode (rarely used)
>       pub unmappable_bytes : ~[u8] -> Option<~str>;
> }
>
> // Encoder condition
> condition! {
>       /// The Unicode string cannot be represented in the target encoding
>       /// (essential for single byte encodings)
>       pub unmappable_str : ~str -> Option<~[u8]>;
> }

I think that unmappable_bytes is not needed, and the other two should 
just be decoding_error and encoding_error. (See above.)


> /// Functions to be used with invalid_sequence::cond.trap
> /// or unmappable_bytes::cond.trap
> mod decoding_error_handlers {
>       fn decoder_error(_: ~[u8]) -> Option<~str> { None }
>       fn replacement(_: ~[u8]) -> Option<~str> { Some(~"\uFFFD") }
>       fn ascii_substitute(_: ~[u8]) -> Option<~str> { Some(~"\u001A") }
>       fn ignore(_: ~[u8]) -> Option<~str> { Some(~"") }
> }
>
> /// Functions to be used with unmappable_str::cond.trap
> mod encoding_error_handlers {
>       fn decoder_error(_: ~str) -> Option<~[u8]> { None }
>       fn ascii_substitute(_: ~str) -> Option<~[u8]> { Some(~[0x1A]) }
>       fn ignore(_: ~str) -> Option<~[u8]> { Some(~[]) }
> }
>
> Not sure about this substitute/replacement duality. Maybe we can have only one
> function name 'default', that would be FFFD for unicode and 1A for ascii.

I think we should only provide two handlers for each of decoding and 
encoding: fail/abort/error, and replace. The latter is U+FFFD 
(replacement character) for decoding and 0x3F (ASCII question mark) for 
encoding as in the WHATWG spec, per web-compatibility constraints.

In particular, "ignore" is terrible and should not be encouraged. 
(Depending on what you?re doing with it, it could lead to security 
issues.) If you do want "ignore" or "ASCII substitute", writing a custom 
condition handler is easy enough.

-- 
Simon Sapin

From simon.sapin at exyr.org  Fri Sep 20 03:52:14 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 20 Sep 2013 11:52:14 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <52338BBF.4000803@exyr.org>
References: <522F3EF7.1000507@exyr.org> <52338BBF.4000803@exyr.org>
Message-ID: <523C28DE.3070201@exyr.org>

Le 13/09/2013 23:03, Simon Sapin a ?crit :
> /// Takes the invalid byte sequence.
> /// Return a replacement string, or None to abort with a DecodeError.
> condition! {
>       pub decoding_error : ~[u8] -> Option<~str>;
> }
>
> /// Functions to be used with decoding_error::cond.trap
> mod decoding_error_handlers {
>       fn fatal(_: ~[u8]) -> Option<~str> { None }
>       fn replacement(_: ~[u8]) -> Option<~str> { Some(~"\uFFFD") }
> }

Allocating ~"\uFFFD" repeatedly is, let?s say, unfortunate. This could 
be avoided by having the return value be:

enum DecodingErrorResult {
     AbortDecoding,
     ReplacementString(~str),
     ReplacementChar(char),
}

Similarly, for encoding:

enum EncodingErrorResult {
     AbortDecoding,
     ReplacamentByteSequence(~[u8]),
     ReplacementByte(u8),
}

-- 
Simon Sapin

From simon.sapin at exyr.org  Fri Sep 20 03:58:19 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 20 Sep 2013 11:58:19 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <52338BBF.4000803@exyr.org>
References: <522F3EF7.1000507@exyr.org> <52338BBF.4000803@exyr.org>
Message-ID: <523C2A4B.1060608@exyr.org>

Le 13/09/2013 23:03, Simon Sapin a ?crit :
> * Make the output generic in the low-level API by having StringWriter
> instead of ~str

This has the nice side effect to let Servo use a different string type 
for decoding, but not for encoding. To fix the latter, the input of 
encoding could be generic as well.

Every encoder other than UTF-8 only needs .iter_chars(), or even a 
Iterator<char>. It?s only the UTF-8 encoding that wants to specialize 
str-as-input to just copy without going through 'char' at all.

Or is it too much, should we just stick with non-generic str?

-- 
Simon Sapin

From andres.osinski at gmail.com  Fri Sep 20 04:02:01 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Fri, 20 Sep 2013 08:02:01 -0300
Subject: [rust-dev] Struct members in trait definitions
Message-ID: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>

Hi all, I have a question which I'm sure must have already been discussed
and dealt with, but I wanted to understand the design rationale:

A lot of trait-level functionality would be enhanced if a trait could
specify members to be included in the struct which implements the trait.
This can be solved in practice by wrapping member access in accessor
methods, but I fail to see why that would be preferable.

The reason I'm asking is because I'm trying to design data structures which
contain a couple of arrays, and I wanted to define the trait by not only a
set of supported operations but by the existence of both arrays so that a
default method could deal with any struct which implements the trait,
instead of having to define for every struct an accessor method for each
structure and then have to call the accessors in the trait to do anything.

Thanks

-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/94a43bea/attachment.html>

From pnkfelix at mozilla.com  Fri Sep 20 04:41:02 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Fri, 20 Sep 2013 13:41:02 +0200
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
Message-ID: <523C344E.10601@mozilla.com>

Andres (cc'ing rust-dev)-

An initial question, since I'm not clear on one thing:

What is your goal in proposing this change?

That is, is your primary concern that you dislike writing either method 
invocations or method definitions?  Or are you concerned about the 
ability of the compiler to optimize the generated code if one uses 
methods instead of struct fields?

----

Justifications for why traits should be expressed in terms of associated 
methods, not associated fields (and thus why Rust does things this way):

1.) Method definitions are strictly more general than fields, in terms 
of allowing other implementations to dynamically compute the value, read 
it from a database, from an input stream, etc).  I assume you already 
are aware of this, and just want to know why we don't provide special 
handling for Trait designers willing to rule out such generality up-front.

2.) Associated struct-fields would either disallow mixing traits whose 
names collide, or would require extending the `impl` item syntax with a 
struct-field renaming feature.

Elaboration of point 2:

Traits are designed to be mixed together; the language should discourage 
patterns that make mixing traits on a single type difficult.

The fields of a struct are written down with the `struct` definition.

The associated methods for an implementation are written down with the 
`impl` item.

If two traits require the same kind of associated state, right now you 
would give them identical method names, and the one struct could 
implement both traits (i.e. mixing them) with no ambiguity.

If traits were to define struct names, to get the same amount of 
generality we would need to provide some way to map the field name of 
the struct to the name expected by the trait within `impl` items.  But 
why do that?  A method definition is a perfectly reasonable way to 
express this.

----

Concrete illustration of point 2 above: How would you express the below 
in your proposal, assuming that *both* T1 and T2 are revised to require 
`state` to be a member field rather than a method?

```rust
trait T1 { fn state(&self) -> int; }

trait T2 { fn state(&self) -> int; }

struct one_int { state: int }

struct two_ints { state: int, state2: int }

impl T1 for one_int { fn state(&self) -> int { self.state } }
impl T2 for one_int { fn state(&self) -> int { self.state } }

impl T1 for two_ints { fn state(&self) -> int { self.state } }
impl T2 for two_ints { fn state(&self) -> int { self.state2 } }
```

----

Again, to be clear: I'm not saying its impossible to express the example 
above via hypothetical Traits with fields.  But I think it would add 
unnecessary complexity (e.g. extensions to `impl` item syntax).  So 
that's why I wanted to know what the driving motivation here is.

If the motivation is concern over syntactic overhead: method invocations 
vs field deference seems trivial.  The method definitions are more 
annoying boilerplate code, but I imagine that one could write an easy 
macro_rules! for the common case where the Trait method name is the same 
as the struct field name.

If the motivation is concern over the quality of the generated code: I 
assume that LLVM does a good job inlining these things. (If I'm wrong 
about that, I'd like to know.)

Cheers,
-Felix


On 20/09/2013 13:02, Andres Osinski wrote:
> Hi all, I have a question which I'm sure must have already been 
> discussed and dealt with, but I wanted to understand the design 
> rationale:
>
> A lot of trait-level functionality would be enhanced if a trait could 
> specify members to be included in the struct which implements the 
> trait. This can be solved in practice by wrapping member access in 
> accessor methods, but I fail to see why that would be preferable.
>
> The reason I'm asking is because I'm trying to design data structures 
> which contain a couple of arrays, and I wanted to define the trait by 
> not only a set of supported operations but by the existence of both 
> arrays so that a default method could deal with any struct which 
> implements the trait, instead of having to define for every struct an 
> accessor method for each structure and then have to call the accessors 
> in the trait to do anything.
>
> Thanks
>
> -- 
> Andr?s Osinski
> http://www.andresosinski.com.ar/
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/e4ae00d7/attachment-0001.html>

From andres.osinski at gmail.com  Fri Sep 20 05:18:00 2013
From: andres.osinski at gmail.com (andres.osinski at gmail.com)
Date: Fri, 20 Sep 2013 12:18:00 +0000
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <523C344E.10601@mozilla.com>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
	<523C344E.10601@mozilla.com>
Message-ID: <135827647-1379679483-cardhu_decombobulator_blackberry.rim.net-2027385176-@b16.c15.bise6.blackberry>

It would be audacious to propose this as a change; I'm merely trying to understand the philosophy behind certain design decisions,

My personal motivation comes from an interest in seeing how expressive Rust can be as a language to model business objects; I think the intersection between high-level logic and type classes with low-level access, extreme efficiency, and deterministic memory access, is a very interesting domain which, thus far, no language manages to handle well, and Rust shows immense promise in that.

Something I really dislike and consider a huge antipattern is the question of logical indirection and boilerplate; anything that hinders the understanding of the code through unnecessary invocations or synax is a big no-no for me (a great example being Java's requirement for type declarations everywhere and the disgusting use of accessor methods everywhere even when they make no sense).

Rust is a very lean language and seems to be extremely concise for what it's capable of. And the thing is, if a trait has a data dependency rather than a behavior (method existence) dependency, then why are we working around the data through methods when it just happens to be that what we really want is to fetch the data in a struct with no logical intermediaries, regardless of whether the compiler turns that into a straight memory access?

The first use case that came to mind was when I was attempting to create a business object library that could be used a starting point for forms, data persistency, serialization, validation, and the like. I wanted to define, for a model, a series of validators that would depend on the struct definition; something easy to do with Enums and macros. However when it came to validation, i wanted to store certain conditions in a data structure, such that all models have a validate() method that would query the data needed to perform validation.

The current trait implementation would require me to needlessly define a getter/setter for the validation data structure in order to have a trait. In reality, i just want to define the trait as a the existence of a certain struct member data definition (a corresponding validators data structure), with no limits in how I may want to access of modify such data.

The beauty of this would be that i would only need to define said member and trait in order to get all the features i could ever want out of a validation library, and default methods would take care of the rest, whereas as it's now, i would have to define the accessors, or use a macro so that any model definition would come with an automatic accessor definition. This is not ideal if I have a system with several hundred models, which may be trivial in their definition but require a useless method definition for each of them.

And while I think it's great that a macro is capable of that, it seems to me that as a language feature it would be substantially more useful.

Like I said before, I'm just toying around; I have little frame of reference as to whether there are hidden downsides to such a feature. I just wanted to know what the community thinks about this.

Thanks
Enviado desde mi BlackBerry de Movistar (http://www.movistar.com.ar)

-----Original Message-----
From: "Felix S. Klock II" <pnkfelix at mozilla.com>
Date: Fri, 20 Sep 2013 13:41:02 
To: Andres Osinski<andres.osinski at gmail.com>
Cc: rust-dev at mozilla.org<rust-dev at mozilla.org>
Subject: Re: [rust-dev] Struct members in trait definitions

Andres (cc'ing rust-dev)-

An initial question, since I'm not clear on one thing:

What is your goal in proposing this change?

That is, is your primary concern that you dislike writing either method 
invocations or method definitions?  Or are you concerned about the 
ability of the compiler to optimize the generated code if one uses 
methods instead of struct fields?

----

Justifications for why traits should be expressed in terms of associated 
methods, not associated fields (and thus why Rust does things this way):

1.) Method definitions are strictly more general than fields, in terms 
of allowing other implementations to dynamically compute the value, read 
it from a database, from an input stream, etc).  I assume you already 
are aware of this, and just want to know why we don't provide special 
handling for Trait designers willing to rule out such generality up-front.

2.) Associated struct-fields would either disallow mixing traits whose 
names collide, or would require extending the `impl` item syntax with a 
struct-field renaming feature.

Elaboration of point 2:

Traits are designed to be mixed together; the language should discourage 
patterns that make mixing traits on a single type difficult.

The fields of a struct are written down with the `struct` definition.

The associated methods for an implementation are written down with the 
`impl` item.

If two traits require the same kind of associated state, right now you 
would give them identical method names, and the one struct could 
implement both traits (i.e. mixing them) with no ambiguity.

If traits were to define struct names, to get the same amount of 
generality we would need to provide some way to map the field name of 
the struct to the name expected by the trait within `impl` items.  But 
why do that?  A method definition is a perfectly reasonable way to 
express this.

----

Concrete illustration of point 2 above: How would you express the below 
in your proposal, assuming that *both* T1 and T2 are revised to require 
`state` to be a member field rather than a method?

```rust
trait T1 { fn state(&self) -> int; }

trait T2 { fn state(&self) -> int; }

struct one_int { state: int }

struct two_ints { state: int, state2: int }

impl T1 for one_int { fn state(&self) -> int { self.state } }
impl T2 for one_int { fn state(&self) -> int { self.state } }

impl T1 for two_ints { fn state(&self) -> int { self.state } }
impl T2 for two_ints { fn state(&self) -> int { self.state2 } }
```

----

Again, to be clear: I'm not saying its impossible to express the example 
above via hypothetical Traits with fields.  But I think it would add 
unnecessary complexity (e.g. extensions to `impl` item syntax).  So 
that's why I wanted to know what the driving motivation here is.

If the motivation is concern over syntactic overhead: method invocations 
vs field deference seems trivial.  The method definitions are more 
annoying boilerplate code, but I imagine that one could write an easy 
macro_rules! for the common case where the Trait method name is the same 
as the struct field name.

If the motivation is concern over the quality of the generated code: I 
assume that LLVM does a good job inlining these things. (If I'm wrong 
about that, I'd like to know.)

Cheers,
-Felix


On 20/09/2013 13:02, Andres Osinski wrote:
> Hi all, I have a question which I'm sure must have already been 
> discussed and dealt with, but I wanted to understand the design 
> rationale:
>
> A lot of trait-level functionality would be enhanced if a trait could 
> specify members to be included in the struct which implements the 
> trait. This can be solved in practice by wrapping member access in 
> accessor methods, but I fail to see why that would be preferable.
>
> The reason I'm asking is because I'm trying to design data structures 
> which contain a couple of arrays, and I wanted to define the trait by 
> not only a set of supported operations but by the existence of both 
> arrays so that a default method could deal with any struct which 
> implements the trait, instead of having to define for every struct an 
> accessor method for each structure and then have to call the accessors 
> in the trait to do anything.
>
> Thanks
>
> -- 
> Andr?s Osinski
> http://www.andresosinski.com.ar/
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/23020174/attachment.html>

From pwalton at mozilla.com  Fri Sep 20 06:54:42 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 20 Sep 2013 06:54:42 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
Message-ID: <523C53A2.1010601@mozilla.com>

On 9/19/13 11:40 PM, Jason E. Aten wrote:
> Agreed. I'm convinced that fail! should result in an almost-magical
> "lets pretend that never happened" jump back in time.

I'm personally fine with adding an unsafe "catch" function or form that 
will stop unwinding if you absolutely have to use it, incidentally. In 
general fail! is not supposed to be used as an exception mechanism, 
because monadic use of Result does that better. But if you're doing 
special things like trying to sandbox Rust code, it seems relatively 
harmless to me. We already have all the low-level infrastructure (DWARF 
unwinding based C++ exceptions) necessary to make it work...

Patrick


From oren at ben-kiki.org  Fri Sep 20 06:58:02 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 20 Sep 2013 16:58:02 +0300
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <523C53A2.1010601@mozilla.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<523C53A2.1010601@mozilla.com>
Message-ID: <CADJiDhtUj_4tJQKDb4Gf4TdJ-XCPDHYEtbckLGum2qE4ZYsiDQ@mail.gmail.com>

Would running test-to-destruction cases that are expected to fail count as
"running in a sandbox"? Currently I spawn them to a separate task and catch
its failure, which is probably better practice - but it would be nice if I
were able to access the message given to fail and compare it with the
expected one. If the unsafe catch would allow for that, it may be
worthwhile to switch to it...


On Fri, Sep 20, 2013 at 4:54 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> On 9/19/13 11:40 PM, Jason E. Aten wrote:
>
>> Agreed. I'm convinced that fail! should result in an almost-magical
>> "lets pretend that never happened" jump back in time.
>>
>
> I'm personally fine with adding an unsafe "catch" function or form that
> will stop unwinding if you absolutely have to use it, incidentally. In
> general fail! is not supposed to be used as an exception mechanism, because
> monadic use of Result does that better. But if you're doing special things
> like trying to sandbox Rust code, it seems relatively harmless to me. We
> already have all the low-level infrastructure (DWARF unwinding based C++
> exceptions) necessary to make it work...
>
> Patrick
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/574c503c/attachment.html>

From simon.sapin at exyr.org  Fri Sep 20 07:01:58 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 20 Sep 2013 15:01:58 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <CANXqsRJ6Fz3bQajY94OAwUdZoJtLhpMTJ5Qti1a-3Kn=fvoc=Q@mail.gmail.com>
References: <522F3EF7.1000507@exyr.org>
	<CANXqsRJ6Fz3bQajY94OAwUdZoJtLhpMTJ5Qti1a-3Kn=fvoc=Q@mail.gmail.com>
Message-ID: <523C5556.1070603@exyr.org>

Le 20/09/2013 13:40, Henri Sivonen a ?crit :
> On Tue, Sep 10, 2013 at 6:47 PM, Simon Sapin<simon.sapin at exyr.org>  wrote:
>>      /// Call this to indicate the end of the input.
>>      /// The Decoder instance should be discarded afterwards.
>>      /// Some encodings may append some final output at this point.
>>      /// May raise the decoding_error condition.
>>      fn flush(output: &mut ~str) -> Option<DecodeError>;
> Please call this "finish" instead of calling it "flush". In other
> APIs, for example JDK APIs, flush really just means flushing the
> current buffers instead of ending the stream, so calling the method
> that does end-of-stream processing "flush" would be confusing.

"flush" is the name that rust-encoding uses, but I argee that "finish" 
is better for what it does.

-- 
Simon Sapin

From simon.sapin at exyr.org  Fri Sep 20 07:15:45 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 20 Sep 2013 15:15:45 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <522F3EF7.1000507@exyr.org>
References: <522F3EF7.1000507@exyr.org>
Message-ID: <523C5891.8000408@exyr.org>

Le 10/09/2013 16:47, Simon Sapin a ?crit :
> TR;DR: the actual proposal is at the end of this email.

I moved this to the wiki, to better deal with updates:
https://github.com/mozilla/rust/wiki/Proposal-for-character-encoding-API

-- 
Simon Sapin

From j.e.aten at gmail.com  Fri Sep 20 07:26:31 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Fri, 20 Sep 2013 07:26:31 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
Message-ID: <CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>

Hi Raphael, that does seem like a small drawback. But I don't see a better
solution. Still open to suggestions.


On Fri, Sep 20, 2013 at 12:07 AM, raphael catolino <
raphael.catolino at gmail.com> wrote:

> > Perhaps the best thing is just to fork(2), so we get a new (OS level)
> > process that has copy-on-write (virtual) memory, and if the compilation +
> > run succeeds in the child, then have the child "take over". Otherwise the
> > child dies with an fail! + location message, and we return to the parent
> > exactly before the child was spawned.
>
> Do you intend for rusti to work on windows? Because I'm not sure you
> could do something like that efficiently there.
>
> On Fri, Sep 20, 2013 at 8:40 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:
> > On Thu, Sep 19, 2013 at 11:51 AM, Alex Crichton <alex at crichton.co>
> wrote:
> >>
> >> Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
> >> I think that it should be important to be able to fail! and have the
> >> repl state intact afterwards.
> >
> >
> > Agreed. I'm convinced that fail! should result in an almost-magical "lets
> > pretend that never happened" jump back in time.
> >
> > I'm still trying to figure out how to do this efficiently. For code that
> has
> > alot of state, serializing and deserializing everything will be too slow.
> >
> > Perhaps the best thing is just to fork(2), so we get a new (OS level)
> > process that has copy-on-write (virtual) memory, and if the compilation +
> > run succeeds in the child, then have the child "take over". Otherwise the
> > child dies with an fail! + location message, and we return to the parent
> > exactly before the child was spawned.
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/e14b0733/attachment.html>

From alex at crichton.co  Fri Sep 20 09:27:39 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 20 Sep 2013 09:27:39 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
Message-ID: <CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>

> Of the 3, Lua's is probably the best, although it's a bit esoteric (with
> using [[ and nary a quote in sight).

I think an important thing to keep in mind is that the main reason
behind creating a new form of literal is for things like:

* Escapes in format! strings
* Possible regular expression syntax (this also may be a syntax extension)
* Type literal windows paths (escaping \ is hard)
* Otherwise long literals which may contain quotes (like html text)

With those in mind, although Lua's syntax is sufficient, is it nice to
use? If the first thing I saw as an introduction to Rust was:

fn main() {
  println!([[Hello, {}!]], "world");
}

I would be a little confused. Now the [[/]] aren't really necessary in
this case, but I'm personally unsure of how usable [[/]] would be
throughout the language. Raw literals in languages like C++ and Lua I
think aren't intended to be used that often. Instead they should be
used only when necessary, and you frequently don't see them in code.
For rust, the use cases which are the cause of this discussion are
actually fairly common, and I'm not sure that we'd want to see [[/]]
all over the place, although of course that's just my opinion :)

Skimming back, I haven't seen a suggestion of the backtick character
as a delimiter. Go takes this approach, and I don't believe that in Go
you can have a backtick anywhere in a backtick literal, and otherwise
what you see is what you get. It's at least something to consider,
though.

From alex at crichton.co  Fri Sep 20 09:48:38 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 20 Sep 2013 09:48:38 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
	<CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
Message-ID: <CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>

It this not possible to do with tasks? If you could architect the
dance between tasks of "who is the current master", then it seems like
you wouldn't need to have forking at all. The "fail and forget" is
automatic because failure is caught at task boundaries anyway. Not
entirely sure if this would work, though.

On Fri, Sep 20, 2013 at 7:26 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:
> Hi Raphael, that does seem like a small drawback. But I don't see a better
> solution. Still open to suggestions.
>
>
> On Fri, Sep 20, 2013 at 12:07 AM, raphael catolino
> <raphael.catolino at gmail.com> wrote:
>>
>> > Perhaps the best thing is just to fork(2), so we get a new (OS level)
>> > process that has copy-on-write (virtual) memory, and if the compilation
>> > +
>> > run succeeds in the child, then have the child "take over". Otherwise
>> > the
>> > child dies with an fail! + location message, and we return to the parent
>> > exactly before the child was spawned.
>>
>> Do you intend for rusti to work on windows? Because I'm not sure you
>> could do something like that efficiently there.
>>
>> On Fri, Sep 20, 2013 at 8:40 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:
>> > On Thu, Sep 19, 2013 at 11:51 AM, Alex Crichton <alex at crichton.co>
>> > wrote:
>> >>
>> >> Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
>> >> I think that it should be important to be able to fail! and have the
>> >> repl state intact afterwards.
>> >
>> >
>> > Agreed. I'm convinced that fail! should result in an almost-magical
>> > "lets
>> > pretend that never happened" jump back in time.
>> >
>> > I'm still trying to figure out how to do this efficiently. For code that
>> > has
>> > alot of state, serializing and deserializing everything will be too
>> > slow.
>> >
>> > Perhaps the best thing is just to fork(2), so we get a new (OS level)
>> > process that has copy-on-write (virtual) memory, and if the compilation
>> > +
>> > run succeeds in the child, then have the child "take over". Otherwise
>> > the
>> > child dies with an fail! + location message, and we return to the parent
>> > exactly before the child was spawned.
>> >
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>
>

From niko at alum.mit.edu  Fri Sep 20 09:53:59 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 20 Sep 2013 12:53:59 -0400
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
Message-ID: <20130920165359.GB18125@Mr-Bennet>

We have considered the option of struct inheritance, and in that
design we included the option of a trait being limited to types that
extend a struct. This creates a less general trait, similar to what
happens in Java is you specify an abstract interface in terms of a
class rather than an interface. The primary motivation for this
feature is efficiency.  Access to those fields, even if it it occurs
through a trait object, would be simple and efficient (whereas
accessors are virtual method calls). As far as I know this is still
"on the table" but will not be implemented in the short term.

What you propose sounds somewhat different. It sounds like you are
suggesting adding fields fields to a trait definition and then, I
suppose, permitting the `impl` to map the field to a pair of
accessors? We've never considered this, but it seems like a lot of
complexity for relatively little benefit, since the generated code
would not be more efficient than today. Perhaps it might be done as
part of general support for property accessors, but that won't come
for some time if ever.

You could also say that impls must map the trait fields to other
fields within the impl'ing type. That would be a middle-ground, since
the offset would not be statically known when using a trait object,
but you would at least know that there is some offset and just load
that, rather than using a full method call. Still I think the
complexity-performance-gain tradeoff doesn't feel high enough.


Niko

On Fri, Sep 20, 2013 at 08:02:01AM -0300, Andres Osinski wrote:
> Hi all, I have a question which I'm sure must have already been discussed
> and dealt with, but I wanted to understand the design rationale:
> 
> A lot of trait-level functionality would be enhanced if a trait could
> specify members to be included in the struct which implements the trait.
> This can be solved in practice by wrapping member access in accessor
> methods, but I fail to see why that would be preferable.
> 
> The reason I'm asking is because I'm trying to design data structures which
> contain a couple of arrays, and I wanted to define the trait by not only a
> set of supported operations but by the existence of both arrays so that a
> default method could deal with any struct which implements the trait,
> instead of having to define for every struct an accessor method for each
> structure and then have to call the accessors in the trait to do anything.
> 
> Thanks
> 
> -- 
> Andr?s Osinski
> http://www.andresosinski.com.ar/

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From clonearmy at gmail.com  Fri Sep 20 10:14:31 2013
From: clonearmy at gmail.com (Meredith L. Patterson)
Date: Fri, 20 Sep 2013 19:14:31 +0200
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <135827647-1379679483-cardhu_decombobulator_blackberry.rim.net-2027385176-@b16.c15.bise6.blackberry>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
	<523C344E.10601@mozilla.com>
	<135827647-1379679483-cardhu_decombobulator_blackberry.rim.net-2027385176-@b16.c15.bise6.blackberry>
Message-ID: <CAPxGCxea97HUSR4M10sshtyjrcmnb0y2oze_QePPVd9JvXK=ZA@mail.gmail.com>

Hi Andres,

I'm thinking about your question from a structural typing point of view, so
let me see if an analogy from Scala (which has its own take on traits)
helps. Scala is more of an OO language than Rust is, and Scala traits can
extend classes (abstract or not), which is how it's possible for a trait to
incorporate members (what Niko just described as "struct inheritance") --
but the trait itself cannot name a new member, only methods, as with Rust.
So in that regard, traits are also an awful lot like Go's interfaces, in
that they describe the interface that a value must be able to satisfy at
compile time. All three languages are structurally typed, but Go has the
fewest bells and whistles in the type system, Scala the most, and Rust
somewhere in the middle (thanks to generics and type bounds). There are
efficiency reasons for that; it's relevant that Scala is a JVM language.

This isn't a particularly concrete answer, but I hope it helps.

Cheers,
--mlp


On Fri, Sep 20, 2013 at 2:18 PM, <andres.osinski at gmail.com> wrote:

> It would be audacious to propose this as a change; I'm merely trying to
> understand the philosophy behind certain design decisions,
>
> My personal motivation comes from an interest in seeing how expressive
> Rust can be as a language to model business objects; I think the
> intersection between high-level logic and type classes with low-level
> access, extreme efficiency, and deterministic memory access, is a very
> interesting domain which, thus far, no language manages to handle well, and
> Rust shows immense promise in that.
>
> Something I really dislike and consider a huge antipattern is the question
> of logical indirection and boilerplate; anything that hinders the
> understanding of the code through unnecessary invocations or synax is a big
> no-no for me (a great example being Java's requirement for type
> declarations everywhere and the disgusting use of accessor methods
> everywhere even when they make no sense).
>
> Rust is a very lean language and seems to be extremely concise for what
> it's capable of. And the thing is, if a trait has a data dependency rather
> than a behavior (method existence) dependency, then why are we working
> around the data through methods when it just happens to be that what we
> really want is to fetch the data in a struct with no logical
> intermediaries, regardless of whether the compiler turns that into a
> straight memory access?
>
> The first use case that came to mind was when I was attempting to create a
> business object library that could be used a starting point for forms, data
> persistency, serialization, validation, and the like. I wanted to define,
> for a model, a series of validators that would depend on the struct
> definition; something easy to do with Enums and macros. However when it
> came to validation, i wanted to store certain conditions in a data
> structure, such that all models have a validate() method that would query
> the data needed to perform validation.
>
> The current trait implementation would require me to needlessly define a
> getter/setter for the validation data structure in order to have a trait.
> In reality, i just want to define the trait as a the existence of a certain
> struct member data definition (a corresponding validators data structure),
> with no limits in how I may want to access of modify such data.
>
> The beauty of this would be that i would only need to define said member
> and trait in order to get all the features i could ever want out of a
> validation library, and default methods would take care of the rest,
> whereas as it's now, i would have to define the accessors, or use a macro
> so that any model definition would come with an automatic accessor
> definition. This is not ideal if I have a system with several hundred
> models, which may be trivial in their definition but require a useless
> method definition for each of them.
>
> And while I think it's great that a macro is capable of that, it seems to
> me that as a language feature it would be substantially more useful.
>
> Like I said before, I'm just toying around; I have little frame of
> reference as to whether there are hidden downsides to such a feature. I
> just wanted to know what the community thinks about this.
>
> Thanks
> Enviado desde mi BlackBerry de Movistar (http://www.movistar.com.ar)
> ------------------------------
> *From: * "Felix S. Klock II" <pnkfelix at mozilla.com>
> *Date: *Fri, 20 Sep 2013 13:41:02 +0200
> *To: *Andres Osinski<andres.osinski at gmail.com>
> *Cc: *rust-dev at mozilla.org<rust-dev at mozilla.org>
> *Subject: *Re: [rust-dev] Struct members in trait definitions
>
> Andres (cc'ing rust-dev)-
>
> An initial question, since I'm not clear on one thing:
>
> What is your goal in proposing this change?
>
> That is, is your primary concern that you dislike writing either method
> invocations or method definitions?  Or are you concerned about the ability
> of the compiler to optimize the generated code if one uses methods instead
> of struct fields?
>
> ----
>
> Justifications for why traits should be expressed in terms of associated
> methods, not associated fields (and thus why Rust does things this way):
>
> 1.) Method definitions are strictly more general than fields, in terms of
> allowing other implementations to dynamically compute the value, read it
> from a database, from an input stream, etc).  I assume you already are
> aware of this, and just want to know why we don't provide special handling
> for Trait designers willing to rule out such generality up-front.
>
> 2.) Associated struct-fields would either disallow mixing traits whose
> names collide, or would require extending the `impl` item syntax with a
> struct-field renaming feature.
>
> Elaboration of point 2:
>
> Traits are designed to be mixed together; the language should discourage
> patterns that make mixing traits on a single type difficult.
>
> The fields of a struct are written down with the `struct` definition.
>
> The associated methods for an implementation are written down with the
> `impl` item.
>
> If two traits require the same kind of associated state, right now you
> would give them identical method names, and the one struct could implement
> both traits (i.e. mixing them) with no ambiguity.
>
> If traits were to define struct names, to get the same amount of
> generality we would need to provide some way to map the field name of the
> struct to the name expected by the trait within `impl` items.  But why do
> that?  A method definition is a perfectly reasonable way to express this.
>
> ----
>
> Concrete illustration of point 2 above: How would you express the below in
> your proposal, assuming that *both* T1 and T2 are revised to require
> `state` to be a member field rather than a method?
>
> ```rust
> trait T1 { fn state(&self) -> int; }
>
> trait T2 { fn state(&self) -> int; }
>
> struct one_int { state: int }
>
> struct two_ints { state: int, state2: int }
>
> impl T1 for one_int { fn state(&self) -> int { self.state } }
> impl T2 for one_int { fn state(&self) -> int { self.state } }
>
> impl T1 for two_ints { fn state(&self) -> int { self.state } }
> impl T2 for two_ints { fn state(&self) -> int { self.state2 } }
> ```
>
> ----
>
> Again, to be clear: I'm not saying its impossible to express the example
> above via hypothetical Traits with fields.  But I think it would add
> unnecessary complexity (e.g. extensions to `impl` item syntax).  So that's
> why I wanted to know what the driving motivation here is.
>
> If the motivation is concern over syntactic overhead: method invocations
> vs field deference seems trivial.  The method definitions are more annoying
> boilerplate code, but I imagine that one could write an easy macro_rules!
> for the common case where the Trait method name is the same as the struct
> field name.
>
> If the motivation is concern over the quality of the generated code: I
> assume that LLVM does a good job inlining these things.  (If I'm wrong
> about that, I'd like to know.)
>
> Cheers,
> -Felix
>
>
> On 20/09/2013 13:02, Andres Osinski wrote:
>
> Hi all, I have a question which I'm sure must have already been discussed
> and dealt with, but I wanted to understand the design rationale:
>
>  A lot of trait-level functionality would be enhanced if a trait could
> specify members to be included in the struct which implements the trait.
> This can be solved in practice by wrapping member access in accessor
> methods, but I fail to see why that would be preferable.
>
>  The reason I'm asking is because I'm trying to design data structures
> which contain a couple of arrays, and I wanted to define the trait by not
> only a set of supported operations but by the existence of both arrays so
> that a default method could deal with any struct which implements the
> trait, instead of having to define for every struct an accessor method for
> each structure and then have to call the accessors in the trait to do
> anything.
>
>  Thanks
>
>  --
> Andr?s Osinski
> http://www.andresosinski.com.ar/
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/8d661471/attachment.html>

From bjzaba at yahoo.com.au  Fri Sep 20 10:15:03 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 21 Sep 2013 03:15:03 +1000
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
Message-ID: <9DEE84F3-F2F6-41FE-BD1A-80A085926D7D@yahoo.com.au>

Adding struct members in traits would be? weird. Where would those members be stored when passing things around by value?

This sounds like something for properties. But as Nikko says it is not a planned feature at the moment ? there is enough on the table for 1.0 as it is. I'm sure they would be a controversial proposal too (although I think they would be nice).

~Brendan

On 20/09/2013, at 9:02 PM, Andres Osinski <andres.osinski at gmail.com> wrote:

> Hi all, I have a question which I'm sure must have already been discussed and dealt with, but I wanted to understand the design rationale:
> 
> A lot of trait-level functionality would be enhanced if a trait could specify members to be included in the struct which implements the trait. This can be solved in practice by wrapping member access in accessor methods, but I fail to see why that would be preferable.
> 
> The reason I'm asking is because I'm trying to design data structures which contain a couple of arrays, and I wanted to define the trait by not only a set of supported operations but by the existence of both arrays so that a default method could deal with any struct which implements the trait, instead of having to define for every struct an accessor method for each structure and then have to call the accessors in the trait to do anything.
> 
> Thanks
> 
> -- 
> Andr?s Osinski
> http://www.andresosinski.com.ar/
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/edebb697/attachment-0001.html>

From j.e.aten at gmail.com  Fri Sep 20 10:25:35 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Fri, 20 Sep 2013 10:25:35 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
	<CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
	<CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>
Message-ID: <4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>

On Sep 20, 2013, at 9:48 AM, Alex Crichton <alex at crichton.co> wrote:

> It this not possible to do with tasks?

I don't see how we can catch and rollback any memory modification that a call into already compiled code might make, not without reimplementing in software the memory protection that the MMU hardware already gives us for free.

From oren at ben-kiki.org  Fri Sep 20 10:55:25 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 20 Sep 2013 20:55:25 +0300
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <9DEE84F3-F2F6-41FE-BD1A-80A085926D7D@yahoo.com.au>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
	<9DEE84F3-F2F6-41FE-BD1A-80A085926D7D@yahoo.com.au>
Message-ID: <CADJiDhuwyRXVSZwedn2ji_bHqP0DGd3mz-ypbws7uVxEhoOx4Q@mail.gmail.com>

How about allowing anonymous fields, like go does? It seems to provide most
of the benefits at very little language complexity cost.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/ab9ed86a/attachment.html>

From thadguidry at gmail.com  Fri Sep 20 11:35:15 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Fri, 20 Sep 2013 13:35:15 -0500
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
Message-ID: <CAChbWaNx_0z267hbmf8Nox_sKndyXqNnbBfTC4fBu_+eDVX9Ag@mail.gmail.com>

Does it HAVE to be a single typed char seen on the English 101 keyboard ?

History Lesson:
The industry in the very early, early days of printing, storing, and
processing characters, both English and non-English, came up with a
solution around the use of Control Characters.

ASCI Char 1 is known as Start Of Header, or abbreviated SOH.
ASCII Char 2 is known as Start of Text, or abbreviated STX.
ASCII Char 3 is known as End of Text, or abbreviated ETX.

It got me thinking of how various industries to this day still use Start of
Text and End of Text... what we are discussing as enclosing a String
verbatim.

Many data operations that I perform with conversion of string fields are
actually done by first wrapping with Control Chars [1] to enclose the
String LITERALLY.

Apple's Enterprise Partner Feed is an example that uses such basic Control
Chars to separate fields and interestingly uses multibyte EOL Control Chars
to retain even unicode contents (Foreign Language strings, that use quotes
of a different nature at times [2] and that sometimes appear in its fields
and that need to be retained inside a database field as well.)

I am wondering if doing something similar to that the industry does with
using Control Chars to represent a STX or ETX would not be even wiser to
subplant String Literal ?  i.e.  do not reinvent the fast spinning wheel
that also has built-in never go flat technology. :)

[1]
http://www.theasciicode.com.ar/ascii-control-characters/start-of-text-ascii-code-2.html
[2] http://en.wikipedia.org/wiki/Non-English_usage_of_quotation_marks

Thoughts ?

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/08845a0e/attachment.html>

From o.renaud at gmx.fr  Fri Sep 20 11:51:11 2013
From: o.renaud at gmx.fr (Olivier Renaud)
Date: Fri, 20 Sep 2013 20:51:11 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <523C27A8.3080605@exyr.org>
References: <522F3EF7.1000507@exyr.org> <1726832.5qjY4bH8Pf@bureau-linux>
	<523C27A8.3080605@exyr.org>
Message-ID: <4585921.BaxRRpczdp@bureau-linux>

Le vendredi 20 septembre 2013 11:47:04 Simon Sapin a ?crit :
> Le 20/09/2013 10:18, Olivier Renaud a ?crit :
> > I really like the API you are proposing. In particular, the error handling
> > is close to what I was expecting from such an API.
> > 
> > I have some remarks, though.
> > 
> > Is there a reason for encoders and decoders to not be reusable ? I think
> > it
> > would be reasonable to specify that they get back to their initial state
> > once the 'flush' method is called, or when a 'DecodeError' is returned.
> I don?t have a strong opinion on that. There could be a "reset" or
> similar method, but I don?t see how this is better than just throwing
> the decoder away and making a new one.

I don't see the need for a 'reset' method. A decoder could return to its 
initial state after a call to 'finish'.

> With static dispatch and the encoding known at compile-time, you can
> probably have decoders on the stack so making a new one is cheap.
> 
> If the encoding is determined at run-time and you use trait objects
> (dynamic dispatch) for decoders, the next input might have a different
> encoding so reusing decoders might not be useful either.

My typical usage of a charset decoder is to read many files on disk, all of 
them using the same charset.

> > Is a condition raised when the order of method calls is not respected ?
> > E.g. if one calls 'flush' multiple times, of calls 'feed' and then
> > 'decode' ?
> Decoder::decode is a static method / associated function. It?s
> independent from everything else.

Oh yes of course, my bad.

> Other than that, I don?t know. rust-encoding doesn?t do that. AFAIU it
> leaves this behavior undefined, which I think is fine. Do you think it
> should be explicitly checked for?

Well, in  my opinion it is not a good idea for an API to have undefined 
behavior. Being explicit about what is disallowed also helps the user to 
understand how the API is supposed to be used. Also, I think it's preferable 
to fail fast, when the state of an object becomes invalid.

There are a handful of reasonable behavior, for the decoder :

* If reusing a decoder is legal, then calling 'feed' after 'finish' is legal 
(we start decoding a new stream), no need to introduce a special case. A 
second call to 'finish' can be a noop (we decode an empty stream)

* If reusing a decoder is illegal:

-- Calling 'feed' after 'finish' should be an error. The API must report that 
it is being misused by the programmer. I don't know what is the recommended 
way to do that in Rust. I think it's ok to fail!, or to have an assert. In 
Java, I'd throw an (unchecked) IllegalStateException, which serves exactly 
this purpose.

-- Calling 'finish' a second time can also be a noop, but it would be better to 
be consistent with the 'feed' after 'finish' behavior and to fail.

Another totally different solution would be to use phantom types, to indicate 
the state of the decoder, but that would be overkill. Or typestates :)

Simpler is better, so I think having a reusable decoder with no special 
"invalid" state is the least problematic solution.

> > It is not clear what is given as a parameter to the 'decoding_error'
> > condition. I guess it's the exact subset of byte sequence that cannot be
> > decoded, possibly spanning multiple 'feed' calls. Is that correct ? Is it
> > sufficient for variable-length encodings ?
> 
> Correct, and I think yes. It is called once every time the spec says to
> "run the error algorithm":
> 
> http://encoding.spec.whatwg.org/#error
> 
> > I am doubtful that the encoder is just a decoder with [u8] and str
> > swapped. A decoder must deal with a possibly invalid sequence of bytes,
> > while an encoder deals with str, which is guaranteed to be a valid utf8
> > sequence. An encoder must handle unmappable characters, whereas a decoder
> > doesn't
> 
> You?re right, I cut some corners. In particular, the encoding_error
> condition can take a single (unsupported) 'char'. Other than that, the
> *API* is (very close to?) the same with [u8] and str swapped.
> 
> > (actually, it
> > depends whether we consider unicode to be universal or not...).
> 
> I suggest we consider it is. (For the purpose of the WHATWG spec it is.)
> If Unicode is missing things, the "right" solution is to add things to
> Unicode.

It simplifies many things, indeed.

> > [...]

From o.renaud at gmx.fr  Fri Sep 20 12:07:22 2013
From: o.renaud at gmx.fr (Olivier Renaud)
Date: Fri, 20 Sep 2013 21:07:22 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <523C28DE.3070201@exyr.org>
References: <522F3EF7.1000507@exyr.org> <52338BBF.4000803@exyr.org>
	<523C28DE.3070201@exyr.org>
Message-ID: <9650470.1tfeY1vnLP@bureau-linux>

Le vendredi 20 septembre 2013 11:52:14 Simon Sapin a ?crit :
> Le 13/09/2013 23:03, Simon Sapin a ?crit :
> > /// Takes the invalid byte sequence.
> > /// Return a replacement string, or None to abort with a DecodeError.
> > condition! {
> > 
> >       pub decoding_error : ~[u8] -> Option<~str>;
> > 
> > }
> > 
> > /// Functions to be used with decoding_error::cond.trap
> > mod decoding_error_handlers {
> > 
> >       fn fatal(_: ~[u8]) -> Option<~str> { None }
> >       fn replacement(_: ~[u8]) -> Option<~str> { Some(~"\uFFFD") }
> > 
> > }
> 
> Allocating ~"\uFFFD" repeatedly is, let?s say, unfortunate. This could
> be avoided by having the return value be:
> 
> enum DecodingErrorResult {
>      AbortDecoding,
>      ReplacementString(~str),
>      ReplacementChar(char),
> }
> 
> Similarly, for encoding:
> 
> enum EncodingErrorResult {
>      AbortDecoding,
>      ReplacamentByteSequence(~[u8]),
>      ReplacementByte(u8),
> }

That's a nice addition, it's even better this way !

I have one more question regarding the error handling : in DecodeError, what 
does 'input_byte_offset' mean ? Is it relative to the 'invalid_byte_sequence' 
or to the beginning of the decoded stream ?

From andres.osinski at gmail.com  Fri Sep 20 12:36:10 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Fri, 20 Sep 2013 16:36:10 -0300
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <CADJiDhuwyRXVSZwedn2ji_bHqP0DGd3mz-ypbws7uVxEhoOx4Q@mail.gmail.com>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
	<9DEE84F3-F2F6-41FE-BD1A-80A085926D7D@yahoo.com.au>
	<CADJiDhuwyRXVSZwedn2ji_bHqP0DGd3mz-ypbws7uVxEhoOx4Q@mail.gmail.com>
Message-ID: <CA+xF-PyMHUeN8uVo9j6jRteYnvj2V2EG-w_qYFkxXfN530etoQ@mail.gmail.com>

When I mention struct members I'm saying that in order for a struct to
satisfy trait properties (explicitly conforming to the interface, not
implicitly like Go), the struct must have implemented the functions for the
trait and also contain the required members.

Looking at a few more examples, I think what I'm looking for here is a
mixin for composition ( inheritance would not be too relevant here) a la
Scala's, or a purpose-made Python asbtract class that defines class members
and methods pertaining only to those members.


On Fri, Sep 20, 2013 at 2:55 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> How about allowing anonymous fields, like go does? It seems to provide
> most of the benefits at very little language complexity cost.
>



-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/2c59b96a/attachment.html>

From kevin at sb.org  Fri Sep 20 12:45:20 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 20 Sep 2013 12:45:20 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
Message-ID: <CB65FA28-C97F-4C07-A84C-2E1E8A16463F@sb.org>

I considered backtick as well. If that approach is used, I would suggest that a doubled-up backtick represent a single backtick in the string, i.e. `error: path ``{}' failed`. This is pretty much equivalent to just using r"" as the syntax, although backtick may be a slightly nicer syntax for it.

-Kevin

On Sep 20, 2013, at 9:27 AM, Alex Crichton <alex at crichton.co> wrote:

>> Of the 3, Lua's is probably the best, although it's a bit esoteric (with
>> using [[ and nary a quote in sight).
> 
> I think an important thing to keep in mind is that the main reason
> behind creating a new form of literal is for things like:
> 
> * Escapes in format! strings
> * Possible regular expression syntax (this also may be a syntax extension)
> * Type literal windows paths (escaping \ is hard)
> * Otherwise long literals which may contain quotes (like html text)
> 
> With those in mind, although Lua's syntax is sufficient, is it nice to
> use? If the first thing I saw as an introduction to Rust was:
> 
> fn main() {
>  println!([[Hello, {}!]], "world");
> }
> 
> I would be a little confused. Now the [[/]] aren't really necessary in
> this case, but I'm personally unsure of how usable [[/]] would be
> throughout the language. Raw literals in languages like C++ and Lua I
> think aren't intended to be used that often. Instead they should be
> used only when necessary, and you frequently don't see them in code.
> For rust, the use cases which are the cause of this discussion are
> actually fairly common, and I'm not sure that we'd want to see [[/]]
> all over the place, although of course that's just my opinion :)
> 
> Skimming back, I haven't seen a suggestion of the backtick character
> as a delimiter. Go takes this approach, and I don't believe that in Go
> you can have a backtick anywhere in a backtick literal, and otherwise
> what you see is what you get. It's at least something to consider,
> though.


From hsivonen at hsivonen.fi  Fri Sep 20 06:09:49 2013
From: hsivonen at hsivonen.fi (Henri Sivonen)
Date: Fri, 20 Sep 2013 16:09:49 +0300
Subject: [rust-dev] Proposed API for character encodings
Message-ID: <CANXqsRLAtRhC1Cxcdj-PEONzoS84SP0tft68_bptnZFyiW_Uaw@mail.gmail.com>

On Tue, Sep 10, 2013 at 6:47 PM, Simon Sapin <simon.sapin at exyr.org> wrote:
>     /// Call this to indicate the end of the input.
>     /// The Decoder instance should be discarded afterwards.
>     /// Some encodings may append some final output at this point.
>     /// May raise the decoding_error condition.
>     fn flush(output: &mut ~str) -> Option<DecodeError>;

Please call this "finish" instead of calling it "flush". In other
APIs, for example JDK APIs, flush really just means flushing the
current buffers instead of ending the stream, so calling the method
that does end-of-stream processing "flush" would be confusing.

-- 
Henri Sivonen
hsivonen at hsivonen.fi
http://hsivonen.iki.fi/

From singingboyo at gmail.com  Thu Sep 19 23:54:13 2013
From: singingboyo at gmail.com (Brandon Sanderson)
Date: Thu, 19 Sep 2013 23:54:13 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
Message-ID: <CAK-XjKUm6BBrH9gGJJdFCTuQ-ty6Ut1P3pz4WK=k0Aa0c+CT6Q@mail.gmail.com>

Could it be possible for rusti to spawn a task that runs the expression,
and then if that results in a fail! it would become a simple child-task
failure cleanup, which in this case means printing the appropriate error
message?

Of course, if there is a lot of state, this might not be feasible, but if
the compile was completed in the main task and the child task only handled
the actual run, it might work.  Depending of course on how compilation is
done for rusti.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130919/e038c258/attachment.html>

From troplin at bluewin.ch  Fri Sep 20 11:29:56 2013
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Fri, 20 Sep 2013 18:29:56 +0000 (UTC)
Subject: [rust-dev] Struct members in trait definitions
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
Message-ID: <814496612401387973.632958troplin-bluewin.ch@news.gmane.org>

Andres Osinski <andres.osinski at gmail.com>
wrote:
> Hi all, I have a question which I'm sure must have already been discussed
> and dealt with, but I wanted to understand the design rationale:
> 
> A lot of trait-level functionality would be enhanced if a trait could
> specify members to be included in the struct which implements the trait.
> This can be solved in practice by wrapping member access in accessor
> methods, but I fail to see why that would be preferable.

IMO this would completely defeat the  advantage of traits over inheritance
based interfaces.

The beauty of traits is, that the trait and the type are separated, only
connected by the implementation:
- You can add an implementation for your custom trait to any existing type.
- You can add an implementation for any existing trait to your custom type.

Now if you add a fields specification to the trait, the former isn't true
anymore. The type has now a dependency on the trait since it must at least
contain a field of a given type, if not even with a given name.

If you the concrete type is under your control, this is obviously not a
problem, as it is the case with inheritance based interfaces. But you
cannot simply assume that for every use case.

Tobi


From ben.striegel at gmail.com  Fri Sep 20 13:35:16 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 20 Sep 2013 16:35:16 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CB65FA28-C97F-4C07-A84C-2E1E8A16463F@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CB65FA28-C97F-4C07-A84C-2E1E8A16463F@sb.org>
Message-ID: <CAAvrL-k6V-kdmGXcufCYdRJYvWHVWc-Q_3AP-pzXBaPOSh-uYg@mail.gmail.com>

As usual, I'm highly resistant to use of the backtick because Markdown uses
it pervasively. Not only would this make it very annoying to embed Markdown
in strings, it can make it impossible to embed inline Rust code in Markdown
editors. Let's leave the backtick as a metasyntactic symbol.


On Fri, Sep 20, 2013 at 3:45 PM, Kevin Ballard <kevin at sb.org> wrote:

> I considered backtick as well. If that approach is used, I would suggest
> that a doubled-up backtick represent a single backtick in the string, i.e.
> `error: path ``{}' failed`. This is pretty much equivalent to just using
> r"" as the syntax, although backtick may be a slightly nicer syntax for it.
>
> -Kevin
>
> On Sep 20, 2013, at 9:27 AM, Alex Crichton <alex at crichton.co> wrote:
>
> >> Of the 3, Lua's is probably the best, although it's a bit esoteric (with
> >> using [[ and nary a quote in sight).
> >
> > I think an important thing to keep in mind is that the main reason
> > behind creating a new form of literal is for things like:
> >
> > * Escapes in format! strings
> > * Possible regular expression syntax (this also may be a syntax
> extension)
> > * Type literal windows paths (escaping \ is hard)
> > * Otherwise long literals which may contain quotes (like html text)
> >
> > With those in mind, although Lua's syntax is sufficient, is it nice to
> > use? If the first thing I saw as an introduction to Rust was:
> >
> > fn main() {
> >  println!([[Hello, {}!]], "world");
> > }
> >
> > I would be a little confused. Now the [[/]] aren't really necessary in
> > this case, but I'm personally unsure of how usable [[/]] would be
> > throughout the language. Raw literals in languages like C++ and Lua I
> > think aren't intended to be used that often. Instead they should be
> > used only when necessary, and you frequently don't see them in code.
> > For rust, the use cases which are the cause of this discussion are
> > actually fairly common, and I'm not sure that we'd want to see [[/]]
> > all over the place, although of course that's just my opinion :)
> >
> > Skimming back, I haven't seen a suggestion of the backtick character
> > as a delimiter. Go takes this approach, and I don't believe that in Go
> > you can have a backtick anywhere in a backtick literal, and otherwise
> > what you see is what you get. It's at least something to consider,
> > though.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/7b565eb0/attachment-0001.html>

From j.e.aten at gmail.com  Fri Sep 20 15:08:54 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Fri, 20 Sep 2013 15:08:54 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
	<CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
	<CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>
	<4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>
Message-ID: <CAPNEFAYj4FpGCqAmrXF8RTTgFtFU2q39KAibiRak8YsG3Gn98w@mail.gmail.com>

Hmm... I'm trying some sanity checks.  This one had a curious result. I did
$ export RUST_THREADS=1
and then started rusti under gdb. Expected: only one thread going.
Observed: I have two threads going instead.

(This is troublesome, because fork will never work if Rust doesn't honor
the request of RUST_THREADS=1; you can't mix threads and fork; explanation:
http://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them)

Q: Is there a way to *really* just get one thread in the rust runtime?
Best case, I'm hoping the two threads observed is just a bug that can be
fixed.

Jason

~~~
jaten at fre:/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin$
env|grep RUST
RUST_THREADS=1
jaten at fre:/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin$
gdb ./rusti
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html
>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/rusti...(no
debugging symbols found)...done.
(gdb) run
Starting program:
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/rusti
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff7fd3700 (LWP 11639)]
WARNING: The Rust REPL is experimental and may be
unstable. If you encounter problems, please use the
compiler instead. Type :help for help.
rusti>   C-c C-c
Program received signal SIGINT, Interrupt.
0x00007ffff4356148 in pthread_join () from
/lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff4356148 in pthread_join () from
/lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff49369d4 in rust_thread::join (this=0x7ffff001f2e0) at
src/rt/sync/rust_thread.cpp:65
#2  0x00007ffff4937469 in rust_raw_thread_join (thread=0x7ffff001f2e0) at
src/rt/rust_builtin.cpp:417
#3  0x00007ffff768f2e9 in
rt::thread::Thread::join::hf3525925b944a51ZTas::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#4  0x00007ffff77cddd3 in rt::run_::h82e8c355ab8d949faz::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#5  0x00007ffff77cb694 in rt::run::hd3cab0f3a053bc41ab::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#6  0x00007ffff770968e in rt::start::h98ebfd32a7b8f1ad::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#7  0x00007ffff77095f7 in
unstable::lang::start::h76d6c774aa357c7aaj::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#8  0x0000000000400c2b in main ()
(gdb) i th
  Id   Target Id         Frame
  2    Thread 0x7ffff7fd3700 (LWP 11639) "rusti" 0x00007ffff46508cd in read
() from /lib/x86_64-linux-gnu/libc.so.6
* 1    Thread 0x7ffff7fd5780 (LWP 11636) "rusti" 0x00007ffff4356148 in
pthread_join () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) thread 2
[Switching to thread 2 (Thread 0x7ffff7fd3700 (LWP 11639))]
#0  0x00007ffff46508cd in read () from /lib/x86_64-linux-gnu/libc.so.6
(gdb) bt
#0  0x00007ffff46508cd in read () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff45e4ff8 in _IO_file_underflow () from
/lib/x86_64-linux-gnu/libc.so.6
#2  0x00007ffff45e603e in _IO_default_uflow () from
/lib/x86_64-linux-gnu/libc.so.6
#3  0x00007ffff45da18a in _IO_getline_info () from
/lib/x86_64-linux-gnu/libc.so.6
#4  0x00007ffff45d906b in fgets () from /lib/x86_64-linux-gnu/libc.so.6
#5  0x00007ffff4946358 in linenoise (prompt=0x7fffefc58058 "rusti> ") at
src/rt/linenoise/linenoise.c:1405
#6  0x00007ffff70a8061 in
rl::rustrt::linenoise::h64cc97493178b67aa3::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libextra-a7c050cfd46b2c9a-0.8-pre.so
#7  0x00007ffff70a8b26 in rl::read::anon::expr_fn::a1 () from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libextra-a7c050cfd46b2c9a-0.8-pre.so
#8  0x00007ffff70a8aba in
c_str::CString::with_ref::hb23b2a52bcdd1fsya0::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libextra-a7c050cfd46b2c9a-0.8-pre.so
#9  0x00007ffff70a89b4 in
c_str::ToCStr::with_c_str::hb23b2a52bcdd1faZ::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libextra-a7c050cfd46b2c9a-0.8-pre.so
#10 0x00007ffff70a8936 in rl::read::h55e92cb2e4e46fea8::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libextra-a7c050cfd46b2c9a-0.8-pre.so
#11 0x00007ffff4d691a2 in get_line::hacc817425f24a23caR::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
librusti-53e0ef2ae196aaff-0.8-pre.so
#12 0x00007ffff4d7b1d2 in main_args::h37a11c4051c2827aO::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
librusti-53e0ef2ae196aaff-0.8-pre.so
#13 0x00007ffff4d7a947 in main::h3a346db0adc4cf51aB::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
librusti-53e0ef2ae196aaff-0.8-pre.so
#14 0x0000000000400bb9 in main::h4eb1c8bbff1fac2ag::v0.0 ()
#15 0x00007ffff7709758 in unstable::lang::start::anon::expr_fn::a1 ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#16 0x00007ffff7719814 in
rt::task::__extensions__::build_start_wrapper::anon::anon::expr_fn::ab ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#17 0x00007ffff761849c in
unstable::finally::Finally$__extensions__::finally::h199ab8d6eb226980ECan::v0.8$x2dpre
()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#18 0x00007ffff77170d5 in rt::task::__extensions__::run::anon::expr_fn::at
()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#19 0x00007ffff7719ce9 in rt::task::Unwinder::try::try_fn::__rust_abi::Vc ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#20 0x00007ffff7719c47 in
rt::task::Unwinder::try::try_fn::hae27117228cab98fVca9::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#21 0x00007ffff4937787 in rust_try (f=0x7ffff7719bf0
<rt::task::Unwinder::try::try_fn::hae27117228cab98fVca9::v0.8$x2dpre>,
fptr=0x7ffff7717080, env=0x7ffff0236348)
    at src/rt/rust_builtin.cpp:523
#22 0x00007ffff7716fa2 in
rt::task::Unwinder::try::h199ab8d6eb226980Vcas::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#23 0x00007ffff7716e36 in
rt::task::Task::run::h199ab8d6eb226980iXar::v0.8$x2dpre ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#24 0x00007ffff7719467 in
rt::task::__extensions__::build_start_wrapper::anon::expr_fn::a2 ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#25 0x00007ffff77b0db5 in
rt::context::Context::new::task_start_wrapper::__rust_abi::se ()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#26 0x00007ffff77b0d67 in
rt::context::Context::new::task_start_wrapper::h1b9fdc38dc3bcfa4sea8::v0.8$x2dpre
()
   from
/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin/../lib/
libstd-6c65cf4b443341b1-0.8-pre.so
#27 0x0000000000000000 in ?? ()
(gdb)

jaten at fre:/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin$
./rustc -v
./rustc 0.8-pre (570431f 2013-09-19 15:56:04 -0700)
host: x86_64-unknown-linux-gnu
jaten at fre:/usr/cn/rust/debug-build/rust/x86_64-unknown-linux-gnu/stage2/bin$

~~~



On Fri, Sep 20, 2013 at 10:25 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:

> On Sep 20, 2013, at 9:48 AM, Alex Crichton <alex at crichton.co> wrote:
>
> > It this not possible to do with tasks?
>
> I don't see how we can catch and rollback any memory modification that a
> call into already compiled code might make, not without reimplementing in
> software the memory protection that the MMU hardware already gives us for
> free.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/1712b97c/attachment.html>

From danielmicay at gmail.com  Fri Sep 20 15:40:06 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 20 Sep 2013 18:40:06 -0400
Subject: [rust-dev] [RFC] Migrating to a composable API in std::option
Message-ID: <CA+DvKQ+GWhyY8nD0o_Zs5x-n5gnkv0BSE-vTWj5BNOyR2Desow@mail.gmail.com>

The current `std::option` API defines 3 versions of most methods, in order
to handle by-value, by-reference and by-mutable-reference. As the module
grows, it will continue to pick up sets of 3 nearly identical methods
rather than one implementation of each.

We could replace the current design with a single by-value implementation
of the methods, and composable `as_mut`/`as_imm` methods to convert
`Option<T>` to `Option<&T>` or `Option<&mut T>`.

This is the same pattern used by iterators, as they keep the element type
separate from the algorithms/adaptors.

https://github.com/mozilla/rust/issues/9355
https://github.com/mozilla/rust/pull/9359
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/d21ae273/attachment.html>

From j.e.aten at gmail.com  Fri Sep 20 17:09:45 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Fri, 20 Sep 2013 17:09:45 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAFnh-mfJDVYrf-9_n59VyFi89DfQfT6zBmvVabv9SO9zR5A-Wg@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
	<CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
	<CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>
	<4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>
	<CAPNEFAYj4FpGCqAmrXF8RTTgFtFU2q39KAibiRak8YsG3Gn98w@mail.gmail.com>
	<CAFnh-mfJDVYrf-9_n59VyFi89DfQfT6zBmvVabv9SO9zR5A-Wg@mail.gmail.com>
Message-ID: <CAPNEFAZ99s1enyvFVEpYxN1z_5nkxYUjY3KMemoaw8+6nJS7Gg@mail.gmail.com>

On Fri, Sep 20, 2013 at 4:24 PM, Alex Crichton <alex at crichton.co> wrote:

> > Q: Is there a way to *really* just get one thread in the rust runtime?
>  Best
> > case, I'm hoping the two threads observed is just a bug that can be
> fixed.
>
> Right now the runtime will always spawn at least one thread, so
> without turning off the runtime you'll have at least two threads.
> That's arguably a bug in the runtime though...
>

Ok. Filed as https://github.com/mozilla/rust/issues/9373
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/dfe2b5fb/attachment-0001.html>

From banderson at mozilla.com  Fri Sep 20 17:54:28 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 20 Sep 2013 17:54:28 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
Message-ID: <523CEE44.9000809@mozilla.com>

On 09/19/2013 11:24 AM, Jason E. Aten wrote:
> Minh Do and I are looking into how to improve rusti -the- repl, so 
> that is fast, efficient, and stable. Minh is undertaking this as a 
> final year project in his CS undergraduate program, and I am mentoring 
> that project and plan to work on it my spare time.  We had a first 
> conference call this week.

I'm very excited about this!

>
> I've spoken with Alex Crichton and started a few conversations on IRC 
> #rust to discuss how rusti might ideally work.  I'm posting to 
> rust-dev to solicit additional feedback, guidance, and input.
>
> Goals (and an important non-goal) for an improved rusti experience:
>
> As an application developer in rust, I want to evaluate the effect of 
> a small Rust statement or expression, so that I can quickly learn the 
> impact of that statement and immediately verify or correct its syntax 
> based on instant feedback.
>
> As a developer, I want to be able to change one variable or function 
> definition without a full recompile, so that I can quickly and 
> immediately see the result of, and evaluate the impact of, the 
> change.  [I'm impatient! I don't want to wait for a full recompile of 
> everything.]

Yes. One of the major flaws in the current rusti is that it maintains no 
state, instead just accumulating a bunch of statements and recompiling 
the entire history every time the user presses enter.

>
> The important example that is present in my mind, from discussions on 
> the #rust channel, is that it appears that tasks/coroutines may be 
> difficult or needlessly complex for a repl (if written in rust itself, 
> which lacks exceptions) to handle. In other words, it may be very 
> arduous (given current encodable/decodable constraints) to implement 
> in a rusti repl that supports task and fail! semantics. While we are 
> open to clever suggestions about how to make that happen if it is 
> indeed possible, this may still be undesirable and out-of-scope for a 
> resource-constrained project. The classic tradeoff of 80% of the 
> benefit for 20% of the effort should be observed.

I don't know why tasks and failure are special in the context of rusti. 
It seems like they should just work as long as the JIT works.


From banderson at mozilla.com  Fri Sep 20 17:59:23 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 20 Sep 2013 17:59:23 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
Message-ID: <523CEF6B.9020701@mozilla.com>

On 09/19/2013 11:40 PM, Jason E. Aten wrote:
> On Thu, Sep 19, 2013 at 11:51 AM, Alex Crichton <alex at crichton.co 
> <mailto:alex at crichton.co>> wrote:
>
>     Basically, I'm OK with leaving out tasks/spawned tasks from rusti, but
>     I think that it should be important to be able to fail! and have the
>     repl state intact afterwards.
>
>
> Agreed. I'm convinced that fail! should result in an almost-magical 
> "lets pretend that never happened" jump back in time.
>
> I'm still trying to figure out how to do this efficiently. For code 
> that has alot of state, serializing and deserializing everything will 
> be too slow.
>
> Perhaps the best thing is just to fork(2), so we get a new (OS level) 
> process that has copy-on-write (virtual) memory, and if the 
> compilation + run succeeds in the child, then have the child "take 
> over". Otherwise the child dies with an fail! + location message, and 
> we return to the parent exactly before the child was spawned.

It seems a shame to be relying on process isolation instead of tasks. If 
I were to just imagine the architecture of a repl that used task 
isolation for crash recovery it might have one task for accepting input 
and another as a sandbox that maintains the repl state and executes 
commands in a loop.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/4b3abcc4/attachment.html>

From oren at ben-kiki.org  Fri Sep 20 18:34:38 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 21 Sep 2013 04:34:38 +0300
Subject: [rust-dev] Struct members in trait definitions
In-Reply-To: <814496612401387973.632958troplin-bluewin.ch@news.gmane.org>
References: <CA+xF-PxJ30ELW2xNN9qD5CA6iyTx77TmcxYh4HevXhUk8caGcw@mail.gmail.com>
	<814496612401387973.632958troplin-bluewin.ch@news.gmane.org>
Message-ID: <CADJiDhvstMh6wCOB8omknv5QasgbyxQbEsRM+tzDFLKnVb_SMA@mail.gmail.com>

AFAIK the go solution walks a thin line here. An anonymous field means one
can directly access any subfield, and also that the container has all the
included struct traits - as implemented by the included struct. It is also
possible to override the implementation.

This is different from what was asked which was the opposite - the go way
is the struct implies the trait, what was asked was that the trait implies
the struct.

I think the go approach makes a lot of sense - I found it to need very
useful and simple (e.g. ambiguities are not allowed). The go docs have a
better description - give it a look...
On Sep 20, 2013 11:30 PM, "Tobias M?ller" <troplin at bluewin.ch> wrote:

> Andres Osinski <andres.osinski at gmail.com>
> wrote:
> > Hi all, I have a question which I'm sure must have already been discussed
> > and dealt with, but I wanted to understand the design rationale:
> >
> > A lot of trait-level functionality would be enhanced if a trait could
> > specify members to be included in the struct which implements the trait.
> > This can be solved in practice by wrapping member access in accessor
> > methods, but I fail to see why that would be preferable.
>
> IMO this would completely defeat the  advantage of traits over inheritance
> based interfaces.
>
> The beauty of traits is, that the trait and the type are separated, only
> connected by the implementation:
> - You can add an implementation for your custom trait to any existing type.
> - You can add an implementation for any existing trait to your custom type.
>
> Now if you add a fields specification to the trait, the former isn't true
> anymore. The type has now a dependency on the trait since it must at least
> contain a field of a given type, if not even with a given name.
>
> If you the concrete type is under your control, this is obviously not a
> problem, as it is the case with inheritance based interfaces. But you
> cannot simply assume that for every use case.
>
> Tobi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/3d833dbd/attachment.html>

From vadimcn at gmail.com  Fri Sep 20 20:23:53 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 20 Sep 2013 20:23:53 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>
References: <CAPNEFAapbUdQYifRXWbUNMU8vFky07W5-2ODk7nhrmVqhT-tog@mail.gmail.com>
	<CAFnh-mc8d9XdCgpsv4tfRJBLp-nqh7nDBpc-u8k4TMFdX_U9Bw@mail.gmail.com>
	<CAPNEFAaakK6tOfvMYt5KJhKzwduG1PqhjTyg=_dwaM_Mo39kWA@mail.gmail.com>
	<CAHb8DBfxivAryWGX7QOQV2BOkBQmjO7rC-ZoPeWRpq9NtfX87A@mail.gmail.com>
	<CAPNEFAbhqeBXtLxCYvUQjn2F-Y+M61tcyLuYxWbW9EJw6n+sfA@mail.gmail.com>
	<CAFnh-mf5+rY0cZ1MGWq_SqOgrS0qzmmBra_SexdtpUY8eow2Dw@mail.gmail.com>
	<4566FF3B-52A6-47C4-9ABE-FD03D00BD73E@gmail.com>
Message-ID: <CADecdiJu86jMB=CaO_oSRLEgvF=cCYW_BB=WR5axsK-kWsKLMA@mail.gmail.com>

In this talk <https://www.youtube.com/watch?v=f9Xfh8pv3Fs> cling devs say
that they did implement transactions.  However the best you could hope for
is to restore internal process state.  You can't do much about external
resources such as file handles, sockets, etc, etc, so I wonder if it's even
worth trying.


On Fri, Sep 20, 2013 at 10:25 AM, Jason E. Aten <j.e.aten at gmail.com> wrote:

> On Sep 20, 2013, at 9:48 AM, Alex Crichton <alex at crichton.co> wrote:
>
> > It this not possible to do with tasks?
>
> I don't see how we can catch and rollback any memory modification that a
> call into already compiled code might make, not without reimplementing in
> software the memory protection that the MMU hardware already gives us for
> free.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130920/2a654048/attachment.html>

From simon.sapin at exyr.org  Fri Sep 20 23:59:26 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 21 Sep 2013 07:59:26 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <9650470.1tfeY1vnLP@bureau-linux>
References: <522F3EF7.1000507@exyr.org>
	<52338BBF.4000803@exyr.org>	<523C28DE.3070201@exyr.org>
	<9650470.1tfeY1vnLP@bureau-linux>
Message-ID: <523D43CE.3010708@exyr.org>

Le 20/09/2013 20:07, Olivier Renaud a ?crit :
> I have one more question regarding the error handling : in DecodeError, what
> does 'input_byte_offset' mean ? Is it relative to the 'invalid_byte_sequence'
> or to the beginning of the decoded stream ?

Good point. I?m not sure. (Remember I make this up as we go along :).)
If it?s from the entirety of the input this would require decoders to 
keep count, which is unnecessary work in cases where you don?t use it. 
(eg. with the Replace error handling.)

So it could be from the beginning of the input in the last call to 
.feed() to the begining of the invalid byte sequence, *which can be 
negative*, in case the invalid sequence started in an earlier .feed() call.

What do you think it should be?

-- 
Simon Sapin

From j.boggiano at seld.be  Sat Sep 21 02:32:15 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Sat, 21 Sep 2013 11:32:15 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAAvrL-k6V-kdmGXcufCYdRJYvWHVWc-Q_3AP-pzXBaPOSh-uYg@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CB65FA28-C97F-4C07-A84C-2E1E8A16463F@sb.org>
	<CAAvrL-k6V-kdmGXcufCYdRJYvWHVWc-Q_3AP-pzXBaPOSh-uYg@mail.gmail.com>
Message-ID: <523D679F.9080204@seld.be>

On 20.09.2013 22:35, Benjamin Striegel wrote:
> As usual, I'm highly resistant to use of the backtick because Markdown
> uses it pervasively. Not only would this make it very annoying to embed
> Markdown in strings, it can make it impossible to embed inline Rust code
> in Markdown editors. Let's leave the backtick as a metasyntactic symbol.

I am not so sure the markdown argument stands, because it is only an
issue in `inline code blocks` really. Blocks fenced with ``` or 4-space
indents can contain backticks just fine, and can typically do in bash
scripts.

In inline blocks, you can always escape them with \` which sure isn't as
nice, but I find it rare to have much more than alpha-numeric
identifiers in inline blocks.

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From pnkfelix at mozilla.com  Sat Sep 21 04:24:23 2013
From: pnkfelix at mozilla.com (Felix Klock)
Date: Sat, 21 Sep 2013 04:24:23 -0700 (PDT)
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <2113539257.5716931.1379762663638.JavaMail.zimbra@mozilla.com>

Kevin (cc'ing rust-dev)-

Of the choices listed here, I prefer the C++11 syntax.

Whatever syntax we choose, I would prefer one that has user-selected delimiting character sequences (as illustrated by the cases of D and C++11).  From my point-of-view, that is the only way to get a "raw string" that really means raw string; otherwise, you end up having to select some exceptional case (e.g. the backslashes, doubled-up quotes, etc of the other options Kevin described).

Cheers,
-Felix

----- Original Message -----
From: "Kevin Ballard" <kevin at sb.org>
To: rust-dev at mozilla.org
Sent: Thursday, September 19, 2013 10:36:39 PM
Subject: [rust-dev] RFC: Syntax for "raw" string literals

One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.

I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.

## Python syntax:

Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.

Pros:
* Simple syntax
* Allows for embedding the closing quote character in the raw string

Cons:
* Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.

## C++11 syntax:

C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).

Pros:
* Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
* Reasonably straightforward

Cons:
* Syntax is slightly complicated

## D syntax:

D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.

The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.

The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like

q"delim
this is some raw text
delim"

It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".

Pros:
* Flexible
* Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)

Cons:
* Overly complicated

## Custom syntax

There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.

Pros:
* Very simple
* Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)

Cons:
* Slightly odd to read

## Conclusion

Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:

C++11: R"("""this is a python docstring""")"
Custom: R"""""""this is a python docstring"""""""

Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.

I welcome any comments, criticisms, or suggestions.

-Kevin
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From o.renaud at gmx.fr  Sat Sep 21 08:38:37 2013
From: o.renaud at gmx.fr (Olivier Renaud)
Date: Sat, 21 Sep 2013 17:38:37 +0200
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <523D43CE.3010708@exyr.org>
References: <522F3EF7.1000507@exyr.org> <9650470.1tfeY1vnLP@bureau-linux>
	<523D43CE.3010708@exyr.org>
Message-ID: <8903983.25X4klXiQW@bureau-linux>

Le samedi 21 septembre 2013 07:59:26 Simon Sapin a ?crit :
> Le 20/09/2013 20:07, Olivier Renaud a ?crit :
> > I have one more question regarding the error handling : in DecodeError,
> > what does 'input_byte_offset' mean ? Is it relative to the
> > 'invalid_byte_sequence' or to the beginning of the decoded stream ?
> 
> Good point. I?m not sure. (Remember I make this up as we go along :).)
> If it?s from the entirety of the input this would require decoders to
> keep count, which is unnecessary work in cases where you don?t use it.
> (eg. with the Replace error handling.)
> 
> So it could be from the beginning of the input in the last call to
> .feed() to the begining of the invalid byte sequence, *which can be
> negative*, in case the invalid sequence started in an earlier .feed() call.
> 
> What do you think it should be?

I'd expect this offset to be absolute. After all, the only thing that the 
programmer can do with this information at this point is to report it to the 
user ; if the programmer wanted to handle the error, he could have done it by 
using a trap. A relative offset has no meaning outside of the processing loop, 
whereas an absolute offset can still be useful even outside of the program (if 
the source of the stream is a file, then an absolute offset will give the exact 
location of the error in the file).

A counter is super cheap, I would'nt worry about its cost. Actually, it just 
has to be incremented once for each call to 'feed'.

Note : for the encoder, you will have to specify wether the offset is a 'code 
point' count or a 'code unit' count.

From cce at ccs.neu.edu  Sat Sep 21 13:52:42 2013
From: cce at ccs.neu.edu (Carl Eastlund)
Date: Sat, 21 Sep 2013 16:52:42 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <2113539257.5716931.1379762663638.JavaMail.zimbra@mozilla.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<2113539257.5716931.1379762663638.JavaMail.zimbra@mozilla.com>
Message-ID: <CAEOPtY0WpXeNpveDkyZVpGkx6M9G2vDt6uRAYPYkEk_D6bb+zg@mail.gmail.com>

You always have to have some exceptional case, though, don't you?  What if
you have a string literal that contains every single character?  Or what if
you have literals in procedurally generated code that might contain any
unknown character?  There's always a possibility that a given delimiter
(sequence of) character(s) might be duplicated inside the literal.  Isn't
there?

Carl Eastlund

On Sat, Sep 21, 2013 at 7:24 AM, Felix Klock <pnkfelix at mozilla.com> wrote:

> Kevin (cc'ing rust-dev)-
>
> Of the choices listed here, I prefer the C++11 syntax.
>
> Whatever syntax we choose, I would prefer one that has user-selected
> delimiting character sequences (as illustrated by the cases of D and
> C++11).  From my point-of-view, that is the only way to get a "raw string"
> that really means raw string; otherwise, you end up having to select some
> exceptional case (e.g. the backslashes, doubled-up quotes, etc of the other
> options Kevin described).
>
> Cheers,
> -Felix
>
> ----- Original Message -----
> From: "Kevin Ballard" <kevin at sb.org>
> To: rust-dev at mozilla.org
> Sent: Thursday, September 19, 2013 10:36:39 PM
> Subject: [rust-dev] RFC: Syntax for "raw" string literals
>
> One feature common to many programming languages that Rust lacks is "raw"
> string literals. Specifically, these are string literals that don't
> interpret backslash-escapes. There are three obvious applications at the
> moment: regular expressions, windows file paths, and format!() strings that
> want to embed { and } chars. I'm sure there are more as well, such as large
> string literals that contain things like HTML text.
>
> I took a look at 3 programming languages to see what solutions they had:
> D, C++11, and Python. I've reproduced their syntax below, plus one more
> custom syntax, along with pros & cons. I'm hoping we can come up with a
> syntax that makes sense for Rust.
>
> ## Python syntax:
>
> Python supports an "r" or "R" prefix on any string literal (both "short"
> strings, delimited with a single quote, or "long" strings, delimited with 3
> quotes). The "r" or "R" prefix denotes a "raw string", and has the effect
> of disabling backslash-escapes within the string. For the most part. It
> actually gets a bit weird: if a sequence of backslashes of an odd length
> occurs prior to a quote (of the appropriate quote type for the string),
> then the quote is considered to be escaped, but the backslashes are left in
> the string. This means r"foo\"" evaluates to the string `foo\"`, and
> similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string
> `foo\\`.
>
> Pros:
> * Simple syntax
> * Allows for embedding the closing quote character in the raw string
>
> Cons:
> * Handling of backslashes is very bizarre, and the closing quote character
> can only be embedded if you want to have a backslash before it.
>
> ## C++11 syntax:
>
> C++11 allows for raw strings using a sequence of the form R"seq(raw
> text)seq". In this construct, `seq` is any sequence of (zero or more)
> characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form
> looks like R"(raw text)", which allows for anything in the raw text except
> for the sequence `)"`. The addition of the delimiter sequence allows for
> constructing a raw string containing any sequence at all (as the delimiter
> sequence can be adjusted based on the represented text).
>
> Pros:
> * Allows for embedding any character at all (representable in the source
> file encoding), including the closing quote.
> * Reasonably straightforward
>
> Cons:
> * Syntax is slightly complicated
>
> ## D syntax:
>
> D supports three different forms of raw strings. The first two are
> similar, being r"raw text" and `raw text`. Besides the choice of
> delimiters, they behave identically, in that the raw text may contain
> anything except for the appropriate quote character. The third syntax is a
> slightly more complicated form of C++11's syntax, and is called a delimited
> string. It takes two forms.
>
> The first looks like q"(raw text)" where the ( may be any non-identifier
> non-whitespace character. If the character is one of [(<{ then it is a
> "nesting delimiter", and the close delimiter must be the matching ])>}
> character, otherwise the close delimiter is the same as the open.
> Furthermore, nesting delimiters do exactly what their name says: they nest.
> If the nesting delimiter is (), then any ( in the raw text must be balanced
> with a ) in the raw text. In other words, q"(foo(bar))" evaluates to
> "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
>
> The second uses any identifier as the delimiter. In this case, the
> identifier must immediately be followed by a newline, and in order to close
> the string, the close delimiter must be preceded by a newline. This looks
> like
>
> q"delim
> this is some raw text
> delim"
>
> It's essentially a heredoc. Note that the first newline is not part of the
> string, but the final newline is, so this evaluates to "this is some raw
> text\n".
>
> Pros:
> * Flexible
> * Allows for constructing a raw string that contains any desired sequence
> of characters (representable in the source file's encoding)
>
> Cons:
> * Overly complicated
>
> ## Custom syntax
>
> There's another approach that none of these three languages take, which is
> to merely allow for doubling up the quote character in order to embed a
> quote. This would look like R"raw string literal ""with embedded
> quotes"".", which becomes `raw string literal "with embedded quotes"`.
>
> Pros:
> * Very simple
> * Allows for embedding the close quote character, and therefore, any
> character (representable in the source file encoding)
>
> Cons:
> * Slightly odd to read
>
> ## Conclusion
>
> Of the three existing syntaxes examined here, I think C++11's is the best.
> It ties with D's syntax for being the most powerful, but is simpler than
> D's. The custom syntax is just as powerful though. The benefit of the C++11
> syntax over the custom syntax is it's slightly easier to read the C++11
> syntax, as the raw text has a 1-to-one mapping with the resulting string.
> The custom syntax is a bit more confusing to read, especially if you want
> to add multiple quotes. As a pathological case, let's try representing a
> Python triple-quoted docstring using both syntaxes:
>
> C++11: R"("""this is a python docstring""")"
> Custom: R"""""""this is a python docstring"""""""
>
> Based on this examination, I'm leaning towards saying Rust should support
> C++11's raw string literal syntax.
>
> I welcome any comments, criticisms, or suggestions.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/7adb9717/attachment.html>

From danielmicay at gmail.com  Sat Sep 21 13:56:44 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 21 Sep 2013 16:56:44 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAEOPtY0WpXeNpveDkyZVpGkx6M9G2vDt6uRAYPYkEk_D6bb+zg@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<2113539257.5716931.1379762663638.JavaMail.zimbra@mozilla.com>
	<CAEOPtY0WpXeNpveDkyZVpGkx6M9G2vDt6uRAYPYkEk_D6bb+zg@mail.gmail.com>
Message-ID: <CA+DvKQL9dDbXkkHvYpoT71Un04MAz0X9PocmbO_iQAXfi0S=Xw@mail.gmail.com>

On Sat, Sep 21, 2013 at 4:52 PM, Carl Eastlund <cce at ccs.neu.edu> wrote:

> You always have to have some exceptional case, though, don't you?  What if
> you have a string literal that contains every single character?  Or what if
> you have literals in procedurally generated code that might contain any
> unknown character?  There's always a possibility that a given delimiter
> (sequence of) character(s) might be duplicated inside the literal.  Isn't
> there?
>
> Carl Eastlund
>

A shell script's here document or a C++11 raw string literal gives you the
ability to choose the sequence ending the literal. You can always pick an
appropriate end delimiter for a given string.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/5f0dfa3c/attachment.html>

From kevin at sb.org  Sat Sep 21 14:05:14 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 21 Sep 2013 14:05:14 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAEOPtY0WpXeNpveDkyZVpGkx6M9G2vDt6uRAYPYkEk_D6bb+zg@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<2113539257.5716931.1379762663638.JavaMail.zimbra@mozilla.com>
	<CAEOPtY0WpXeNpveDkyZVpGkx6M9G2vDt6uRAYPYkEk_D6bb+zg@mail.gmail.com>
Message-ID: <D0022D0E-FA44-4C94-893A-E0A1686DA294@sb.org>

The delimiter can be whatever you want in C++11 syntax (well, with restrictions on the charset, but among that charset it's freeform). You can _always_ pick a delimiter that isn't found in the text.

If you're procedurally generating the text, surely you can also write an algorithm to pick a delimiter. It's not very hard to do so.

-Kevin

On Sep 21, 2013, at 1:52 PM, Carl Eastlund <cce at ccs.neu.edu> wrote:

> You always have to have some exceptional case, though, don't you?  What if you have a string literal that contains every single character?  Or what if you have literals in procedurally generated code that might contain any unknown character?  There's always a possibility that a given delimiter (sequence of) character(s) might be duplicated inside the literal.  Isn't there?
> 
> Carl Eastlund
> 
> On Sat, Sep 21, 2013 at 7:24 AM, Felix Klock <pnkfelix at mozilla.com> wrote:
> Kevin (cc'ing rust-dev)-
> 
> Of the choices listed here, I prefer the C++11 syntax.
> 
> Whatever syntax we choose, I would prefer one that has user-selected delimiting character sequences (as illustrated by the cases of D and C++11).  From my point-of-view, that is the only way to get a "raw string" that really means raw string; otherwise, you end up having to select some exceptional case (e.g. the backslashes, doubled-up quotes, etc of the other options Kevin described).
> 
> Cheers,
> -Felix
> 
> ----- Original Message -----
> From: "Kevin Ballard" <kevin at sb.org>
> To: rust-dev at mozilla.org
> Sent: Thursday, September 19, 2013 10:36:39 PM
> Subject: [rust-dev] RFC: Syntax for "raw" string literals
> 
> One feature common to many programming languages that Rust lacks is "raw" string literals. Specifically, these are string literals that don't interpret backslash-escapes. There are three obvious applications at the moment: regular expressions, windows file paths, and format!() strings that want to embed { and } chars. I'm sure there are more as well, such as large string literals that contain things like HTML text.
> 
> I took a look at 3 programming languages to see what solutions they had: D, C++11, and Python. I've reproduced their syntax below, plus one more custom syntax, along with pros & cons. I'm hoping we can come up with a syntax that makes sense for Rust.
> 
> ## Python syntax:
> 
> Python supports an "r" or "R" prefix on any string literal (both "short" strings, delimited with a single quote, or "long" strings, delimited with 3 quotes). The "r" or "R" prefix denotes a "raw string", and has the effect of disabling backslash-escapes within the string. For the most part. It actually gets a bit weird: if a sequence of backslashes of an odd length occurs prior to a quote (of the appropriate quote type for the string), then the quote is considered to be escaped, but the backslashes are left in the string. This means r"foo\"" evaluates to the string `foo\"`, and similarly r"foo\\\"" is `foo\\\"`, but r"foo\\" is merely the string `foo\\`.
> 
> Pros:
> * Simple syntax
> * Allows for embedding the closing quote character in the raw string
> 
> Cons:
> * Handling of backslashes is very bizarre, and the closing quote character can only be embedded if you want to have a backslash before it.
> 
> ## C++11 syntax:
> 
> C++11 allows for raw strings using a sequence of the form R"seq(raw text)seq". In this construct, `seq` is any sequence of (zero or more) characters except for: space, (, ), \, \t, \v, \n, \r. The simplest form looks like R"(raw text)", which allows for anything in the raw text except for the sequence `)"`. The addition of the delimiter sequence allows for constructing a raw string containing any sequence at all (as the delimiter sequence can be adjusted based on the represented text).
> 
> Pros:
> * Allows for embedding any character at all (representable in the source file encoding), including the closing quote.
> * Reasonably straightforward
> 
> Cons:
> * Syntax is slightly complicated
> 
> ## D syntax:
> 
> D supports three different forms of raw strings. The first two are similar, being r"raw text" and `raw text`. Besides the choice of delimiters, they behave identically, in that the raw text may contain anything except for the appropriate quote character. The third syntax is a slightly more complicated form of C++11's syntax, and is called a delimited string. It takes two forms.
> 
> The first looks like q"(raw text)" where the ( may be any non-identifier non-whitespace character. If the character is one of [(<{ then it is a "nesting delimiter", and the close delimiter must be the matching ])>} character, otherwise the close delimiter is the same as the open. Furthermore, nesting delimiters do exactly what their name says: they nest. If the nesting delimiter is (), then any ( in the raw text must be balanced with a ) in the raw text. In other words, q"(foo(bar))" evaluates to "foo(bar)", but q"(foo(bar)" and q"(foobar))" are both illegal.
> 
> The second uses any identifier as the delimiter. In this case, the identifier must immediately be followed by a newline, and in order to close the string, the close delimiter must be preceded by a newline. This looks like
> 
> q"delim
> this is some raw text
> delim"
> 
> It's essentially a heredoc. Note that the first newline is not part of the string, but the final newline is, so this evaluates to "this is some raw text\n".
> 
> Pros:
> * Flexible
> * Allows for constructing a raw string that contains any desired sequence of characters (representable in the source file's encoding)
> 
> Cons:
> * Overly complicated
> 
> ## Custom syntax
> 
> There's another approach that none of these three languages take, which is to merely allow for doubling up the quote character in order to embed a quote. This would look like R"raw string literal ""with embedded quotes"".", which becomes `raw string literal "with embedded quotes"`.
> 
> Pros:
> * Very simple
> * Allows for embedding the close quote character, and therefore, any character (representable in the source file encoding)
> 
> Cons:
> * Slightly odd to read
> 
> ## Conclusion
> 
> Of the three existing syntaxes examined here, I think C++11's is the best. It ties with D's syntax for being the most powerful, but is simpler than D's. The custom syntax is just as powerful though. The benefit of the C++11 syntax over the custom syntax is it's slightly easier to read the C++11 syntax, as the raw text has a 1-to-one mapping with the resulting string. The custom syntax is a bit more confusing to read, especially if you want to add multiple quotes. As a pathological case, let's try representing a Python triple-quoted docstring using both syntaxes:
> 
> C++11: R"("""this is a python docstring""")"
> Custom: R"""""""this is a python docstring"""""""
> 
> Based on this examination, I'm leaning towards saying Rust should support C++11's raw string literal syntax.
> 
> I welcome any comments, criticisms, or suggestions.
> 
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/e654fd6f/attachment-0001.html>

From j.e.aten at gmail.com  Sat Sep 21 22:37:04 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Sat, 21 Sep 2013 22:37:04 -0700
Subject: [rust-dev] Rust-dev Digest, Vol 39, Issue 61
In-Reply-To: <mailman.12499.1379755938.24863.rust-dev@mozilla.org>
References: <mailman.12499.1379755938.24863.rust-dev@mozilla.org>
Message-ID: <CAPNEFAZULhTTn4tqFnDMMTzYoBNhvB2pdoEt6v4SKPB2N_eo1g@mail.gmail.com>

On Fri, 20 Sep 2013 Brian Anderson  wrote:
>> On 09/19/2013 11:40 PM, Jason E. Aten wrote:
>> Perhaps the best thing is just to fork(2), so we get a new (OS level)
>> process that has copy-on-write (virtual) memory, and if the
>> compilation + run succeeds in the child, then have the child "take
>> over". Otherwise the child dies with an fail! + location message, and
>> we return to the parent exactly before the child was spawned.
>
> It seems a shame to be relying on process isolation instead of tasks. If
> I were to just imagine the architecture of a repl that used task
> isolation for crash recovery it might have one task for accepting input
> and another as a sandbox that maintains the repl state and executes
> commands in a loop.

Yes, it seems a shame. It's even worse than a shame. It adds demands. Using
fork(2) demands a single-threaded runtime. Tasks don't require a single
threaded runtime. And tasks are more portable. Using fork(2) might mean
only supporting Linux or Linux & OSX at first.  Windows support might
require cygwin's fork implementation, whereas tasks are everywhere.

So I agree. It seems a shame. I want to do it with tasks only. I just don't
see how. How can we do this with tasks and get the desired rollback on
fail!()?

I'll detail the problem a little. With only tasks, how do we rollback
changes to global state made by pre-compiled library functions that are
called from JIT-ed and run code? The task doesn't know what the arbitrary
code has done, so the task can't roll it back. Any functions in an
arbitrary C library, any unsafe Rust functions, and the JIT-compilation
itself will have updated global memory, the llvm module's symbols, etc.
Since we've fail!-ed at the end of an arbitrarily long sequence of code,
now we want that reverted all that cleanly and completely. How would a task
do that?

I've been down that road for syntax errors before. I've implemented
rollback of everything that the LLVM-JIT added to an llvm module. It was a
pain, I had to track everything that the llvm jit-compiler did, so I could
roll back on syntax error. It was brittle, introducing a myraid of
undersirable code-interactions and logging to the current transaction code
intertwined with every llvm call. It was a pain, but it worked--for syntax
error rollback.

But here we're not talking about *just* rolling back on syntax error. We
want to roll back not only the effects of a partial JIT-compilation, but to
also rollback after *running that code*.  That code can call into
*arbitrary global memory modifying code*. All that we know is that an
arbitrary set of changes to the process image has ended in a fail!().

I'm certainly open to alternatives.  How will that alternative address the
rollback on fail!() problem?

Process isolation and using the copy-on-write/hardware (MMU) support for
copy-on-write virtual memory has been engineered for just this job. It fits
the situation like a glove. As a bonus: we get rollback of file handle
changes and all the other OS objects that are duplicated by fork(2).

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/83925ff5/attachment.html>

From j.e.aten at gmail.com  Sat Sep 21 22:40:10 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Sat, 21 Sep 2013 22:40:10 -0700
Subject: [rust-dev] rusti - the - repl renovation
Message-ID: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>

// Bah. Resending with the correct title, in hopes this gets threaded
properly in the archives. Sorry for the duplication.

On Sat, Sep 21, 2013 at 10:37 PM, Jason E. Aten <j.e.aten at gmail.com> wrote:

> On Fri, 20 Sep 2013 Brian Anderson  wrote:
> >> On 09/19/2013 11:40 PM, Jason E. Aten wrote:
> >> Perhaps the best thing is just to fork(2), so we get a new (OS level)
> >> process that has copy-on-write (virtual) memory, and if the
> >> compilation + run succeeds in the child, then have the child "take
> >> over". Otherwise the child dies with an fail! + location message, and
> >> we return to the parent exactly before the child was spawned.
> >
> > It seems a shame to be relying on process isolation instead of tasks. If
> > I were to just imagine the architecture of a repl that used task
> > isolation for crash recovery it might have one task for accepting input
> > and another as a sandbox that maintains the repl state and executes
> > commands in a loop.
>
> Yes, it seems a shame. It's even worse than a shame. It adds demands.
> Using fork(2) demands a single-threaded runtime. Tasks don't require a
> single threaded runtime. And tasks are more portable. Using fork(2) might
> mean only supporting Linux or Linux & OSX at first.  Windows support might
> require cygwin's fork implementation, whereas tasks are everywhere.
>
> So I agree. It seems a shame. I want to do it with tasks only. I just
> don't see how. How can we do this with tasks and get the desired rollback
> on fail!()?
>
> I'll detail the problem a little. With only tasks, how do we rollback
> changes to global state made by pre-compiled library functions that are
> called from JIT-ed and run code? The task doesn't know what the arbitrary
> code has done, so the task can't roll it back. Any functions in an
> arbitrary C library, any unsafe Rust functions, and the JIT-compilation
> itself will have updated global memory, the llvm module's symbols, etc.
> Since we've fail!-ed at the end of an arbitrarily long sequence of code,
> now we want that reverted all that cleanly and completely. How would a task
> do that?
>
> I've been down that road for syntax errors before. I've implemented
> rollback of everything that the LLVM-JIT added to an llvm module. It was a
> pain, I had to track everything that the llvm jit-compiler did, so I could
> roll back on syntax error. It was brittle, introducing a myraid of
> undersirable code-interactions and logging to the current transaction code
> intertwined with every llvm call. It was a pain, but it worked--for syntax
> error rollback.
>
> But here we're not talking about *just* rolling back on syntax error. We
> want to roll back not only the effects of a partial JIT-compilation, but to
> also rollback after *running that code*.  That code can call into
> *arbitrary global memory modifying code*. All that we know is that an
> arbitrary set of changes to the process image has ended in a fail!().
>
> I'm certainly open to alternatives.  How will that alternative address the
> rollback on fail!() problem?
>
> Process isolation and using the copy-on-write/hardware (MMU) support for
> copy-on-write virtual memory has been engineered for just this job. It fits
> the situation like a glove. As a bonus: we get rollback of file handle
> changes and all the other OS objects that are duplicated by fork(2).
>
> Jason
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/f85778fe/attachment.html>

From andrew at du.nham.ca  Sat Sep 21 23:27:31 2013
From: andrew at du.nham.ca (Andrew Dunham)
Date: Sat, 21 Sep 2013 23:27:31 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>
References: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>
Message-ID: <CADSBmCBMYRjOGsbb-oq7z0FDNYtFG9f+jnGmefbjbNoWCXgGwQ@mail.gmail.com>

If you'll excuse my jumping in randomly:

The more I think about "rolling back", the more I think this might not be
the only solution.  What about something like this:
- rusti starts a subprocess, communicating with it via pipes
- Whenever the user types something, the subprocess receives the code and
actually runs it
- Whenever something fail!()'s, or a segfault happens, the child process
can just outright exit, and then rusti can restart it

The downside is that you lose all rollback capabilities - but in most
cases, REPLs in other languages don't actually roll everything back.  For
example, it's perfectly possible to have code in the Python REPL that
changes a global variable, and then raises an exception.  For more advanced
use, it might be possible to define something like "transactions", such
that when the child process dies, the superprocess can automatically re-run
previously executed code.

Obviously this isn't ideal, but it solves a whole host of problems,
especially regarding multi-threading and use on Windows.

--Andrew D


On Sat, Sep 21, 2013 at 10:40 PM, Jason E. Aten <j.e.aten at gmail.com> wrote:

> // Bah. Resending with the correct title, in hopes this gets threaded
> properly in the archives. Sorry for the duplication.
>
> On Sat, Sep 21, 2013 at 10:37 PM, Jason E. Aten <j.e.aten at gmail.com>wrote:
>
>> On Fri, 20 Sep 2013 Brian Anderson  wrote:
>> >> On 09/19/2013 11:40 PM, Jason E. Aten wrote:
>>  >> Perhaps the best thing is just to fork(2), so we get a new (OS level)
>> >> process that has copy-on-write (virtual) memory, and if the
>> >> compilation + run succeeds in the child, then have the child "take
>> >> over". Otherwise the child dies with an fail! + location message, and
>> >> we return to the parent exactly before the child was spawned.
>> >
>> > It seems a shame to be relying on process isolation instead of tasks. If
>> > I were to just imagine the architecture of a repl that used task
>> > isolation for crash recovery it might have one task for accepting input
>> > and another as a sandbox that maintains the repl state and executes
>> > commands in a loop.
>>
>> Yes, it seems a shame. It's even worse than a shame. It adds demands.
>> Using fork(2) demands a single-threaded runtime. Tasks don't require a
>> single threaded runtime. And tasks are more portable. Using fork(2) might
>> mean only supporting Linux or Linux & OSX at first.  Windows support might
>> require cygwin's fork implementation, whereas tasks are everywhere.
>>
>> So I agree. It seems a shame. I want to do it with tasks only. I just
>> don't see how. How can we do this with tasks and get the desired rollback
>> on fail!()?
>>
>> I'll detail the problem a little. With only tasks, how do we rollback
>> changes to global state made by pre-compiled library functions that are
>> called from JIT-ed and run code? The task doesn't know what the arbitrary
>> code has done, so the task can't roll it back. Any functions in an
>> arbitrary C library, any unsafe Rust functions, and the JIT-compilation
>> itself will have updated global memory, the llvm module's symbols, etc.
>> Since we've fail!-ed at the end of an arbitrarily long sequence of code,
>> now we want that reverted all that cleanly and completely. How would a task
>> do that?
>>
>> I've been down that road for syntax errors before. I've implemented
>> rollback of everything that the LLVM-JIT added to an llvm module. It was a
>> pain, I had to track everything that the llvm jit-compiler did, so I could
>> roll back on syntax error. It was brittle, introducing a myraid of
>> undersirable code-interactions and logging to the current transaction code
>> intertwined with every llvm call. It was a pain, but it worked--for syntax
>> error rollback.
>>
>> But here we're not talking about *just* rolling back on syntax error. We
>> want to roll back not only the effects of a partial JIT-compilation, but to
>> also rollback after *running that code*.  That code can call into
>> *arbitrary global memory modifying code*. All that we know is that an
>> arbitrary set of changes to the process image has ended in a fail!().
>>
>> I'm certainly open to alternatives.  How will that alternative address
>> the rollback on fail!() problem?
>>
>> Process isolation and using the copy-on-write/hardware (MMU) support for
>> copy-on-write virtual memory has been engineered for just this job. It fits
>> the situation like a glove. As a bonus: we get rollback of file handle
>> changes and all the other OS objects that are duplicated by fork(2).
>>
>> Jason
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130921/2d93e537/attachment-0001.html>

From simon.sapin at exyr.org  Sun Sep 22 01:37:53 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sun, 22 Sep 2013 09:37:53 +0100
Subject: [rust-dev] Proposed API for character encodings
In-Reply-To: <8903983.25X4klXiQW@bureau-linux>
References: <522F3EF7.1000507@exyr.org>
	<9650470.1tfeY1vnLP@bureau-linux>	<523D43CE.3010708@exyr.org>
	<8903983.25X4klXiQW@bureau-linux>
Message-ID: <523EAC61.3090505@exyr.org>

Le 21/09/2013 16:38, Olivier Renaud a ?crit :
> I'd expect this offset to be absolute. After all, the only thing that the
> programmer can do with this information at this point is to report it to the
> user ; if the programmer wanted to handle the error, he could have done it by
> using a trap. A relative offset has no meaning outside of the processing loop,
> whereas an absolute offset can still be useful even outside of the program (if
> the source of the stream is a file, then an absolute offset will give the exact
> location of the error in the file).
>
> A counter is super cheap, I would'nt worry about its cost. Actually, it just
> has to be incremented once for each call to 'feed'.

Well to get the position inside a given chunk of input you still have to 
count individual bytes. (Maybe with Iterator::enumerate?) Unless maybe 
we do dirty pointer arithmetic?

If possible, I?d rather find a way to not have to pay that cost in the 
common case where the error handling is *not* abort and DecodeError is 
never used.

This is also a bit annoying as each implementation will have to repeat 
the counting logic, but maybe it?s still worth it.


> Note : for the encoder, you will have to specify wether the offset is a 'code
> point' count or a 'code unit' count.

Yes. I don?t know yet. If we do [1] and make the input generic it will 
probably have to be code points.

[1] https://mail.mozilla.org/pipermail/rust-dev/2013-September/005662.html

Otherwise, it may be preferable to match Str::slice and count UTF-8 
bytes. (Which I suppose is what you call code units?)

-- 
Simon Sapin

From steven at ashley.net.nz  Sun Sep 22 03:00:30 2013
From: steven at ashley.net.nz (Steven Ashley)
Date: Sun, 22 Sep 2013 22:00:30 +1200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
Message-ID: <CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>

Hi everyone,

Have we considered syntax similar to Ruby style heredocs? I particularly
like the light looking syntax.

- The indentation of the block is determined by the indentation of the eos
marker. Keeping code flow natural.

<<eos
    Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor
    incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud
    eos

- Brackets in the eos marker are flipped to allow <<[[[raw]]]

- eoseos causes a literal eos to be inserted. For example <<"a ""raw""
string"

My main concern is that << might be a common operator. Perhaps <<< would be
ok?

Thoughts?
On 21/09/2013 4:28 AM, "Alex Crichton" <alex at crichton.co> wrote:

> > Of the 3, Lua's is probably the best, although it's a bit esoteric (with
> > using [[ and nary a quote in sight).
>
> I think an important thing to keep in mind is that the main reason
> behind creating a new form of literal is for things like:
>
> * Escapes in format! strings
> * Possible regular expression syntax (this also may be a syntax extension)
> * Type literal windows paths (escaping \ is hard)
> * Otherwise long literals which may contain quotes (like html text)
>
> With those in mind, although Lua's syntax is sufficient, is it nice to
> use? If the first thing I saw as an introduction to Rust was:
>
> fn main() {
>   println!([[Hello, {}!]], "world");
> }
>
> I would be a little confused. Now the [[/]] aren't really necessary in
> this case, but I'm personally unsure of how usable [[/]] would be
> throughout the language. Raw literals in languages like C++ and Lua I
> think aren't intended to be used that often. Instead they should be
> used only when necessary, and you frequently don't see them in code.
> For rust, the use cases which are the cause of this discussion are
> actually fairly common, and I'm not sure that we'd want to see [[/]]
> all over the place, although of course that's just my opinion :)
>
> Skimming back, I haven't seen a suggestion of the backtick character
> as a delimiter. Go takes this approach, and I don't believe that in Go
> you can have a backtick anywhere in a backtick literal, and otherwise
> what you see is what you get. It's at least something to consider,
> though.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130922/4394d6bf/attachment.html>

From thadguidry at gmail.com  Sun Sep 22 06:33:25 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Sun, 22 Sep 2013 08:33:25 -0500
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CADSBmCBMYRjOGsbb-oq7z0FDNYtFG9f+jnGmefbjbNoWCXgGwQ@mail.gmail.com>
References: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>
	<CADSBmCBMYRjOGsbb-oq7z0FDNYtFG9f+jnGmefbjbNoWCXgGwQ@mail.gmail.com>
Message-ID: <CAChbWaP3TvqzYQtb8wgNur47JeruLPVca4hfxud0CeLFnHyx6w@mail.gmail.com>

Andrew and I are on the same thinking path.. a REPL does not have to crash,
nor a process that it tries to understand, and the word should not be in
its vocabulary...just make sure it can handle the idea of "I do not know
what to do here...so I will just ignore this process and continue on with
my life and processes that I do understand to execute".

Erlang got high marks because of very simple handling of Andrew's idea,
it's black message boxing works in a similar fashion, if I recall ...
"crash is not in the vocabulary".

Why is the implementation process so hard ?  Seems easy enough to type
above, anyways.


On Sun, Sep 22, 2013 at 1:27 AM, Andrew Dunham <andrew at du.nham.ca> wrote:

> If you'll excuse my jumping in randomly:
>
> The more I think about "rolling back", the more I think this might not be
> the only solution.  What about something like this:
> - rusti starts a subprocess, communicating with it via pipes
> - Whenever the user types something, the subprocess receives the code and
> actually runs it
> - Whenever something fail!()'s, or a segfault happens, the child process
> can just outright exit, and then rusti can restart it
>
> The downside is that you lose all rollback capabilities - but in most
> cases, REPLs in other languages don't actually roll everything back.  For
> example, it's perfectly possible to have code in the Python REPL that
> changes a global variable, and then raises an exception.  For more advanced
> use, it might be possible to define something like "transactions", such
> that when the child process dies, the superprocess can automatically re-run
> previously executed code.
>
> Obviously this isn't ideal, but it solves a whole host of problems,
> especially regarding multi-threading and use on Windows.
>
> --Andrew D
>
>
> On Sat, Sep 21, 2013 at 10:40 PM, Jason E. Aten <j.e.aten at gmail.com>wrote:
>
>> // Bah. Resending with the correct title, in hopes this gets threaded
>> properly in the archives. Sorry for the duplication.
>>
>> On Sat, Sep 21, 2013 at 10:37 PM, Jason E. Aten <j.e.aten at gmail.com>wrote:
>>
>>> On Fri, 20 Sep 2013 Brian Anderson  wrote:
>>> >> On 09/19/2013 11:40 PM, Jason E. Aten wrote:
>>>  >> Perhaps the best thing is just to fork(2), so we get a new (OS level)
>>> >> process that has copy-on-write (virtual) memory, and if the
>>> >> compilation + run succeeds in the child, then have the child "take
>>> >> over". Otherwise the child dies with an fail! + location message, and
>>> >> we return to the parent exactly before the child was spawned.
>>> >
>>> > It seems a shame to be relying on process isolation instead of tasks.
>>> If
>>> > I were to just imagine the architecture of a repl that used task
>>> > isolation for crash recovery it might have one task for accepting input
>>> > and another as a sandbox that maintains the repl state and executes
>>> > commands in a loop.
>>>
>>> Yes, it seems a shame. It's even worse than a shame. It adds demands.
>>> Using fork(2) demands a single-threaded runtime. Tasks don't require a
>>> single threaded runtime. And tasks are more portable. Using fork(2) might
>>> mean only supporting Linux or Linux & OSX at first.  Windows support might
>>> require cygwin's fork implementation, whereas tasks are everywhere.
>>>
>>> So I agree. It seems a shame. I want to do it with tasks only. I just
>>> don't see how. How can we do this with tasks and get the desired rollback
>>> on fail!()?
>>>
>>> I'll detail the problem a little. With only tasks, how do we rollback
>>> changes to global state made by pre-compiled library functions that are
>>> called from JIT-ed and run code? The task doesn't know what the arbitrary
>>> code has done, so the task can't roll it back. Any functions in an
>>> arbitrary C library, any unsafe Rust functions, and the JIT-compilation
>>> itself will have updated global memory, the llvm module's symbols, etc.
>>> Since we've fail!-ed at the end of an arbitrarily long sequence of code,
>>> now we want that reverted all that cleanly and completely. How would a task
>>> do that?
>>>
>>> I've been down that road for syntax errors before. I've implemented
>>> rollback of everything that the LLVM-JIT added to an llvm module. It was a
>>> pain, I had to track everything that the llvm jit-compiler did, so I could
>>> roll back on syntax error. It was brittle, introducing a myraid of
>>> undersirable code-interactions and logging to the current transaction code
>>> intertwined with every llvm call. It was a pain, but it worked--for syntax
>>> error rollback.
>>>
>>> But here we're not talking about *just* rolling back on syntax error. We
>>> want to roll back not only the effects of a partial JIT-compilation, but to
>>> also rollback after *running that code*.  That code can call into
>>> *arbitrary global memory modifying code*. All that we know is that an
>>> arbitrary set of changes to the process image has ended in a fail!().
>>>
>>> I'm certainly open to alternatives.  How will that alternative address
>>> the rollback on fail!() problem?
>>>
>>> Process isolation and using the copy-on-write/hardware (MMU) support for
>>> copy-on-write virtual memory has been engineered for just this job. It fits
>>> the situation like a glove. As a bonus: we get rollback of file handle
>>> changes and all the other OS objects that are duplicated by fork(2).
>>>
>>> Jason
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130922/a7ebcd24/attachment.html>

From arteme at gmail.com  Sun Sep 22 11:52:18 2013
From: arteme at gmail.com (Artem Egorkine)
Date: Sun, 22 Sep 2013 21:52:18 +0300
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>
Message-ID: <CAJ-XOG=10Uz-RvyoD=hzvsds2vkNQuqNhLL6_3tpg3GL-KeXMQ@mail.gmail.com>

I must be missing something about ruby heredocs, but the indentation had
always been a painful question about them (
http://stackoverflow.com/questions/3772864/how-do-i-remove-leading-whitespace-chars-from-ruby-heredoc).
Another thing, of course, it's that they are by no means raw (which of
course doesn't stop rust from adopting their syntax for raw strings. I
would just say that it would be nice to pick such syntax for raw strings
that allows for both single line raw strings and multi-line raw strings to
be represented easily.
On Sep 22, 2013 1:00 PM, "Steven Ashley" <steven at ashley.net.nz> wrote:

> Hi everyone,
>
> Have we considered syntax similar to Ruby style heredocs? I particularly
> like the light looking syntax.
>
> - The indentation of the block is determined by the indentation of the eos
> marker. Keeping code flow natural.
>
> <<eos
>     Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
> eiusmod tempor
>     incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
> quis nostrud
>     eos
>
> - Brackets in the eos marker are flipped to allow <<[[[raw]]]
>
> - eoseos causes a literal eos to be inserted. For example <<"a ""raw""
> string"
>
> My main concern is that << might be a common operator. Perhaps <<< would
> be ok?
>
> Thoughts?
> On 21/09/2013 4:28 AM, "Alex Crichton" <alex at crichton.co> wrote:
>
>> > Of the 3, Lua's is probably the best, although it's a bit esoteric (with
>> > using [[ and nary a quote in sight).
>>
>> I think an important thing to keep in mind is that the main reason
>> behind creating a new form of literal is for things like:
>>
>> * Escapes in format! strings
>> * Possible regular expression syntax (this also may be a syntax extension)
>> * Type literal windows paths (escaping \ is hard)
>> * Otherwise long literals which may contain quotes (like html text)
>>
>> With those in mind, although Lua's syntax is sufficient, is it nice to
>> use? If the first thing I saw as an introduction to Rust was:
>>
>> fn main() {
>>   println!([[Hello, {}!]], "world");
>> }
>>
>> I would be a little confused. Now the [[/]] aren't really necessary in
>> this case, but I'm personally unsure of how usable [[/]] would be
>> throughout the language. Raw literals in languages like C++ and Lua I
>> think aren't intended to be used that often. Instead they should be
>> used only when necessary, and you frequently don't see them in code.
>> For rust, the use cases which are the cause of this discussion are
>> actually fairly common, and I'm not sure that we'd want to see [[/]]
>> all over the place, although of course that's just my opinion :)
>>
>> Skimming back, I haven't seen a suggestion of the backtick character
>> as a delimiter. Go takes this approach, and I don't believe that in Go
>> you can have a backtick anywhere in a backtick literal, and otherwise
>> what you see is what you get. It's at least something to consider,
>> though.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130922/3cb642ab/attachment-0001.html>

From kevin at sb.org  Sun Sep 22 12:18:34 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 22 Sep 2013 12:18:34 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAJ-XOG=10Uz-RvyoD=hzvsds2vkNQuqNhLL6_3tpg3GL-KeXMQ@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>
	<CAJ-XOG=10Uz-RvyoD=hzvsds2vkNQuqNhLL6_3tpg3GL-KeXMQ@mail.gmail.com>
Message-ID: <ABC8922B-A64F-461D-BA00-54E25F70AD96@sb.org>

Heredocs are primarily intended for multiline strings. Raw strings are intended for strings that have no escapes. Raw strings typically allow newlines, but that is not their primary purpose (and in Rust, regular strings allow newlines anyway). Trying to use a heredoc syntax for raw strings is just a headache (because of indentation, and dealing with the first and/or trailing newline in the heredoc).

-Kevin

On Sep 22, 2013, at 11:52 AM, Artem Egorkine <arteme at gmail.com> wrote:

> I must be missing something about ruby heredocs, but the indentation had always been a painful question about them ( http://stackoverflow.com/questions/3772864/how-do-i-remove-leading-whitespace-chars-from-ruby-heredoc). Another thing, of course, it's that they are by no means raw (which of course doesn't stop rust from adopting their syntax for raw strings. I would just say that it would be nice to pick such syntax for raw strings that allows for both single line raw strings and multi-line raw strings to be represented easily.
> 
> On Sep 22, 2013 1:00 PM, "Steven Ashley" <steven at ashley.net.nz> wrote:
> Hi everyone,
> 
> Have we considered syntax similar to Ruby style heredocs? I particularly like the light looking syntax.
> 
> - The indentation of the block is determined by the indentation of the eos marker. Keeping code flow natural.
> 
> <<eos
>     Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor 
>     incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud
>     eos
> 
> - Brackets in the eos marker are flipped to allow <<[[[raw]]]
> 
> - eoseos causes a literal eos to be inserted. For example <<"a ""raw"" string"
> 
> My main concern is that << might be a common operator. Perhaps <<< would be ok?
> 
> Thoughts?
> 
> On 21/09/2013 4:28 AM, "Alex Crichton" <alex at crichton.co> wrote:
> > Of the 3, Lua's is probably the best, although it's a bit esoteric (with
> > using [[ and nary a quote in sight).
> 
> I think an important thing to keep in mind is that the main reason
> behind creating a new form of literal is for things like:
> 
> * Escapes in format! strings
> * Possible regular expression syntax (this also may be a syntax extension)
> * Type literal windows paths (escaping \ is hard)
> * Otherwise long literals which may contain quotes (like html text)
> 
> With those in mind, although Lua's syntax is sufficient, is it nice to
> use? If the first thing I saw as an introduction to Rust was:
> 
> fn main() {
>   println!([[Hello, {}!]], "world");
> }
> 
> I would be a little confused. Now the [[/]] aren't really necessary in
> this case, but I'm personally unsure of how usable [[/]] would be
> throughout the language. Raw literals in languages like C++ and Lua I
> think aren't intended to be used that often. Instead they should be
> used only when necessary, and you frequently don't see them in code.
> For rust, the use cases which are the cause of this discussion are
> actually fairly common, and I'm not sure that we'd want to see [[/]]
> all over the place, although of course that's just my opinion :)
> 
> Skimming back, I haven't seen a suggestion of the backtick character
> as a delimiter. Go takes this approach, and I don't believe that in Go
> you can have a backtick anywhere in a backtick literal, and otherwise
> what you see is what you get. It's at least something to consider,
> though.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130922/24f1a7d8/attachment.html>

From steven at ashley.net.nz  Sun Sep 22 14:01:26 2013
From: steven at ashley.net.nz (Steven Ashley)
Date: Mon, 23 Sep 2013 09:01:26 +1200
Subject: [rust-dev]  RFC: Syntax for "raw" string literals
In-Reply-To: <ABC8922B-A64F-461D-BA00-54E25F70AD96@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>
	<CAJ-XOG=10Uz-RvyoD=hzvsds2vkNQuqNhLL6_3tpg3GL-KeXMQ@mail.gmail.com>
	<ABC8922B-A64F-461D-BA00-54E25F70AD96@sb.org>
Message-ID: <CAH2AfNbqWuOiSV80KMExXnLjNBWT-8tGKM+KsXRBu5OyaeqsEg@mail.gmail.com>

Oh right, that's fair enough. I think the indentation/escaping issues can
be fixed however the new line issues you mentioned will still exist for
strings split over multiple lines using this syntax.

Good luck!

Steven

On Monday, September 23, 2013, Kevin Ballard wrote:

> Heredocs are primarily intended for multiline strings. Raw strings are
> intended for strings that have no escapes. Raw strings typically allow
> newlines, but that is not their primary purpose (and in Rust, regular
> strings allow newlines anyway). Trying to use a heredoc syntax for raw
> strings is just a headache (because of indentation, and dealing with the
> first and/or trailing newline in the heredoc).
>
> -Kevin
>
> On Sep 22, 2013, at 11:52 AM, Artem Egorkine <arteme at gmail.com> wrote:
>
> I must be missing something about ruby heredocs, but the indentation had
> always been a painful question about them (
> http://stackoverflow.com/questions/3772864/how-do-i-remove-leading-whitespace-chars-from-ruby-heredoc).
> Another thing, of course, it's that they are by no means raw (which of
> course doesn't stop rust from adopting their syntax for raw strings. I
> would just say that it would be nice to pick such syntax for raw strings
> that allows for both single line raw strings and multi-line raw strings to
> be represented easily.
> On Sep 22, 2013 1:00 PM, "Steven Ashley" <steven at ashley.net.nz> wrote:
>
>> Hi everyone,
>>
>> Have we considered syntax similar to Ruby style heredocs? I particularly
>> like the light looking syntax.
>>
>> - The indentation of the block is determined by the indentation of the
>> eos marker. Keeping code flow natural.
>>
>> <<eos
>>     Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
>> eiusmod tempor
>>     incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
>> quis nostrud
>>     eos
>>
>> - Brackets in the eos marker are flipped to allow <<[[[raw]]]
>>
>> - eoseos causes a literal eos to be inserted. For example <<"a ""raw""
>> string"
>>
>> My main concern is that << might be a common operator. Perhaps <<< would
>> be ok?
>>
>> Thoughts?
>> On 21/09/2013 4:28 AM, "Alex Crichton" <alex at crichton.co> wrote:
>>
>>> > Of the 3, Lua's is probably the best, although it's a bit esoteric
>>> (with
>>> > using [[ and nary a quote in sight).
>>>
>>> I think an important thing to keep in mind is that the main reason
>>> behind creating a new form of literal is for things like:
>>>
>>> * Escapes in format! strings
>>> * Possible regular expression syntax (this also may be a syntax
>>> extension)
>>> * Type literal windows paths (escaping \ is hard)
>>> * Otherwise long literals which may contain quotes (like html text)
>>>
>>> With those in mind, although Lua's syntax is sufficient, is it nice to
>>> use? If the first thing I saw as an introduction to Rust was:
>>>
>>> fn main() {
>>>   println!([[Hello, {}!]], "world");
>>> }
>>>
>>> I would be a little confused. Now the [[/]] aren't really necessary in
>>> this case, but I'm personally unsure of how usable [[/]] would be
>>> throughout the language. Raw literals in languages like C++ and Lua I
>>> think aren't intended to be used that often. Instead they should be
>>> used only when necessary, and you frequently don't see them in code.
>>> For rust, the use cases which are the cause of this discussion are
>>> actually fairly common, and I'm not sure that we'd want to see [[/]]
>>> all over the place, although of course that's just my opinion :)
>>>
>>> Skimming back, I haven't seen a suggestion of the backtick character
>>> as a delimiter. Go takes this approach, and I don't believe that in Go
>>> you can have a backtick anywhere in a backtick literal, and otherwise
>>> what you see is what you get. It's at least something to consider,
>>> though.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/2786fbed/attachment.html>

From steven at ashley.net.nz  Sun Sep 22 14:20:29 2013
From: steven at ashley.net.nz (Steven Ashley)
Date: Mon, 23 Sep 2013 09:20:29 +1200
Subject: [rust-dev]  RFC: Syntax for "raw" string literals
In-Reply-To: <CAH2AfNbqWuOiSV80KMExXnLjNBWT-8tGKM+KsXRBu5OyaeqsEg@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<52052126-76E9-435C-A4D4-81236CF3DC58@masklinn.net>
	<62438A48-9918-41CC-93BA-D259132AF12F@sb.org>
	<698B98B8-5478-4960-9434-DEA9A8E25E62@masklinn.net>
	<CAJnHWXstDXM206bw=C-vWVXBZXNvsMic7bkdbQG_hij+poifnA@mail.gmail.com>
	<871496AA-E01E-4142-B595-2D86BE016D2A@masklinn.net>
	<CA+xF-PzzN3Feknh-JSqN52k6X4+5W0X09wZjt+0A9JDWmTe+BQ@mail.gmail.com>
	<1EC6C834-948D-490E-BDCA-9A00821F49DC@sb.org>
	<CAFnh-mfHV=TYtu+Ud650Tkrt=L2Do3nuMqLZkirUOxH3h7QN2w@mail.gmail.com>
	<CAH2AfNYD=GZJevCESMq8cW=Xvf26RBON6eZ-FdP_X_LAJjCt4Q@mail.gmail.com>
	<CAJ-XOG=10Uz-RvyoD=hzvsds2vkNQuqNhLL6_3tpg3GL-KeXMQ@mail.gmail.com>
	<ABC8922B-A64F-461D-BA00-54E25F70AD96@sb.org>
	<CAH2AfNbqWuOiSV80KMExXnLjNBWT-8tGKM+KsXRBu5OyaeqsEg@mail.gmail.com>
Message-ID: <CAH2AfNbmYNAT8AQ4p_g5rroW1NpTh1p1BSi=dcdB_Hx9HmVdqA@mail.gmail.com>

I'm in favour of C++11 syntax.

On Monday, September 23, 2013, Steven Ashley wrote:

> Oh right, that's fair enough. I think the indentation/escaping issues can
> be fixed however the new line issues you mentioned will still exist for
> strings split over multiple lines using this syntax.
>
> Good luck!
>
> Steven
>
> On Monday, September 23, 2013, Kevin Ballard wrote:
>
> Heredocs are primarily intended for multiline strings. Raw strings are
> intended for strings that have no escapes. Raw strings typically allow
> newlines, but that is not their primary purpose (and in Rust, regular
> strings allow newlines anyway). Trying to use a heredoc syntax for raw
> strings is just a headache (because of indentation, and dealing with the
> first and/or trailing newline in the heredoc).
>
> -Kevin
>
> On Sep 22, 2013, at 11:52 AM, Artem Egorkine <arteme at gmail.com> wrote:
>
> I must be missing something about ruby heredocs, but the indentation had
> always been a painful question about them (
> http://stackoverflow.com/questions/3772864/how-do-i-remove-leading-whitespace-chars-from-ruby-heredoc).
> Another thing, of course, it's that they are by no means raw (which of
> course doesn't stop rust from adopting their syntax for raw strings. I
> would just say that it would be nice to pick such syntax for raw strings
> that allows for both single line raw strings and multi-line raw strings to
> be represented easily.
> On Sep 22, 2013 1:00 PM, "Steven Ashley" <steven at ashley.net.nz> wrote:
>
> Hi everyone,
>
> Have we considered syntax similar to Ruby style heredocs? I particularly
> like the light looking syntax.
>
> - The indentation of the block is determined by the indentation of the eos
> marker. Keeping code flow natural.
>
> <<eos
>     Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
> eiusmod tempor
>     incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
> quis nostrud
>     eos
>
> - Brackets in the eos marker are flipped to allow <<[[[raw]]]
>
> - eoseos causes a literal eos to be inserted. For example <<"a ""raw""
> string"
>
> My main concern is that << might be a common operator. Perhaps <<< would
> be ok?
>
> Thoughts?
> On 21/09/2013 4:28 AM, "Alex Crichton" <alex at crichton.co> wrote:
>
> > Of the 3, Lua's is probably the best, although it's a bit esoteric (with
> > using [[ and nary a quote in sight).
>
> I think an important thing to keep in mind is that the main reason
> behind creating a new form of literal is for things like:
>
> * Escapes in format! strings
> * Possible regular expression syntax (this also may be a syntax extension)
> * Type literal windows paths (escaping \ is hard)
> * Otherwise long literals which may contain quotes (like html text)
>
> With those in mind, although Lua's syntax is sufficient, is it nice to
> use? If the first thing I saw as an introduction to Rust was:
>
> fn main() {
>   println!([[Hello, {}!]], "world");
> }
>
> I would be a little confused. Now the [[/]] aren't really necessary in
> this case, but I'm personally unsure of how usable [[/]] would be
> throughout the language. Raw literals in languages like C++ and Lua I
> think aren't intended to be used that often. Instead they should be
> used only when necessary, and you frequently don't see them in code.
> For rust, the use cases which are the cause of this discussion are
> actually fairly common, and I'm not sure that we'd want to see [[/]]
> all over the place, although of course that's just my opinion :)
>
> Skimming back, I haven't seen a suggestion of the backtick character
> as a delimiter. Go takes this approach, and I don't believe that in Go
> you can have a backtick anywhere in a backtick literal, and otherwise
> what you see is what you get. It's at least something to consider,
> though.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
> <
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/2c0bfc78/attachment-0001.html>

From sebastian.sylvan at gmail.com  Sun Sep 22 14:32:00 2013
From: sebastian.sylvan at gmail.com (Sebastian Sylvan)
Date: Sun, 22 Sep 2013 14:32:00 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>

On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:

> One feature common to many programming languages that Rust lacks is "raw"
> string literals.


This is one of those things where I feel almost all languages get wrong,
and probably mostly for historical reasons. IMO there should *only* be raw
string literals on the syntax level. It seems extremely weird to me that
languages have this second-level language that gets interpreted within a
literal. That kind of higher level processing should be part of a
formatting library (e.g. a macro like fmt), rather than an embedded
language inside the literal syntax. So, I think string literals should
contain exactly what they contain in their source form, without any
additional processing. If you want to express characters that are
inconvenient to type, you can use control sequences and a (standard)
formatting library to produce them.

-- 
Sebastian Sylvan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130922/99e09a12/attachment.html>

From kevin at sb.org  Sun Sep 22 14:40:43 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 22 Sep 2013 14:40:43 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
Message-ID: <EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>

I've filed a summary of this conversation as an RFC issue on the GitHub issue tracker.

https://github.com/mozilla/rust/issues/9411

-Kevin

From lists at ncameron.org  Sun Sep 22 14:58:52 2013
From: lists at ncameron.org (Nick Cameron)
Date: Mon, 23 Sep 2013 09:58:52 +1200
Subject: [rust-dev] Syntax Extensions
Message-ID: <CAA5tgF3Ao4aR7wCkAZwY_2avWris0=jvq3fqgVCFn4Sv4zay7Q@mail.gmail.com>

Hi, in various places on the mailing list and in the docs there is mention
of 'syntax extensions' or 'compiled syntax extensions' - some method of
extending the syntax of Rust which is compiled into the compiler, rather
than using macros. Are there any docs for these? Or is there any code which
is a good example to try to follow? (I looked through the libsyntax/ext
directory which seems to be the right place, but I couldn't tell what was
implementation of the feature and what was an example).

What I am actually looking for is a mechanism a bit like Clang
ASTFrontendActions - be able to instrument compilation for tools, rather
than to add new syntax. Syntax extensions sound like they might work - is
that right?

Thanks, Nick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/9c770a4d/attachment.html>

From slabode at aim.com  Sun Sep 22 15:41:34 2013
From: slabode at aim.com (SiegeLord)
Date: Sun, 22 Sep 2013 18:41:34 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
Message-ID: <523F721E.50900@aim.com>

On 09/22/2013 05:40 PM, Kevin Ballard wrote:
> I've filed a summary of this conversation as an RFC issue on the GitHub issue tracker.
>
> https://github.com/mozilla/rust/issues/9411

I've used a variation of the option 10 for my own configuration format's 
raw strings:

delim"raw text"delim

Where delim was an equivalent of an identifier.

If ` is a problem, then maybe using ' works too?

'delim"raw text"delim'

'"raw text"'

-SL

From kevin at sb.org  Sun Sep 22 16:10:42 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 22 Sep 2013 16:10:42 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <523F721E.50900@aim.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
	<523F721E.50900@aim.com>
Message-ID: <FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>

' doesn't work because 'delim is parsed as a lifetime.

-Kevin

On Sep 22, 2013, at 3:41 PM, SiegeLord <slabode at aim.com> wrote:

> On 09/22/2013 05:40 PM, Kevin Ballard wrote:
>> I've filed a summary of this conversation as an RFC issue on the GitHub issue tracker.
>> 
>> https://github.com/mozilla/rust/issues/9411
> 
> I've used a variation of the option 10 for my own configuration format's raw strings:
> 
> delim"raw text"delim
> 
> Where delim was an equivalent of an identifier.
> 
> If ` is a problem, then maybe using ' works too?
> 
> 'delim"raw text"delim'
> 
> '"raw text"'
> 
> -SL
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From slabode at aim.com  Sun Sep 22 16:26:52 2013
From: slabode at aim.com (SiegeLord)
Date: Sun, 22 Sep 2013 19:26:52 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
	<523F721E.50900@aim.com>
	<FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>
Message-ID: <523F7CBC.2030608@aim.com>

On 09/22/2013 07:10 PM, Kevin Ballard wrote:
> ' doesn't work because 'delim is parsed as a lifetime.

The parser will have to be modified to support raw strings in any of 
their manifestations. Is it a fact that there is no possible parser than 
can differentiate between 'delim and 'delim" ? I guess it'll give 
trouble to this current syntax &'foo"blah", but it wouldn't be the first 
place in the grammar where a space was necessary to disambiguate between 
constructs (& & comes to mind).

-SL

From kevin at sb.org  Sun Sep 22 16:45:17 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 22 Sep 2013 16:45:17 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <523F7CBC.2030608@aim.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
	<523F721E.50900@aim.com>
	<FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>
	<523F7CBC.2030608@aim.com>
Message-ID: <22DD6C89-170C-417B-8522-A117205A26D2@sb.org>

It would require changing the rules for lifetimes, with no benefit (and no clear new rule to use anyway). &'foo"delim" is perfectly legal today, and I see no reason to change that.

-Kevin

On Sep 22, 2013, at 4:26 PM, SiegeLord <slabode at aim.com> wrote:

> On 09/22/2013 07:10 PM, Kevin Ballard wrote:
>> ' doesn't work because 'delim is parsed as a lifetime.
> 
> The parser will have to be modified to support raw strings in any of their manifestations. Is it a fact that there is no possible parser than can differentiate between 'delim and 'delim" ? I guess it'll give trouble to this current syntax &'foo"blah", but it wouldn't be the first place in the grammar where a space was necessary to disambiguate between constructs (& & comes to mind).
> 
> -SL


From slabode at aim.com  Sun Sep 22 17:27:19 2013
From: slabode at aim.com (SiegeLord)
Date: Sun, 22 Sep 2013 20:27:19 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <22DD6C89-170C-417B-8522-A117205A26D2@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
	<523F721E.50900@aim.com>
	<FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>
	<523F7CBC.2030608@aim.com>
	<22DD6C89-170C-417B-8522-A117205A26D2@sb.org>
Message-ID: <523F8AE7.9030201@aim.com>

On 09/22/2013 07:45 PM, Kevin Ballard wrote:
> It would require changing the rules for lifetimes, with no benefit (and no clear new rule to use anyway). &'foo"delim" is perfectly legal today, and I see no reason to change that.
It's not as big a change as you make it out to be, but fair enough.

Looking at the parser right now, it seems to me that implementing the 
leading 'R' in C++'s syntax will be just as difficult/easy as doing my 
delim"stuff"delim proposal so I'm sticking to that idea as my 'vote'.

If C++ way is chosen, I'd suggest the following permutation of the 
delimeters, as I think it looks lighter (by virtue of using smaller 
characters):

r'delim"raw string"delim'
r'"raw string"'

-SL

From kevin at sb.org  Sun Sep 22 17:42:17 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sun, 22 Sep 2013 17:42:17 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <523F8AE7.9030201@aim.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<EB1FEBB2-0051-46FC-923F-D60CFE20460D@sb.org>
	<523F721E.50900@aim.com>
	<FCF5BF0F-DC38-4428-8088-A423B5F0EF27@sb.org>
	<523F7CBC.2030608@aim.com>
	<22DD6C89-170C-417B-8522-A117205A26D2@sb.org>
	<523F8AE7.9030201@aim.com>
Message-ID: <7C79F633-65B1-44B6-8CA0-A5FEEE979C3E@sb.org>

On Sep 22, 2013, at 5:27 PM, SiegeLord <slabode at aim.com> wrote:

> On 09/22/2013 07:45 PM, Kevin Ballard wrote:
>> It would require changing the rules for lifetimes, with no benefit (and no clear new rule to use anyway). &'foo"delim" is perfectly legal today, and I see no reason to change that.
> It's not as big a change as you make it out to be, but fair enough.
> 
> Looking at the parser right now, it seems to me that implementing the leading 'R' in C++'s syntax will be just as difficult/easy as doing my delim"stuff"delim proposal so I'm sticking to that idea as my 'vote'.

With C++11 syntax, `R"foo` is very obviously the start of a raw string. With your syntax, what about `add"foo`? Is that obviously the start of a raw string, or did the user just forget to type the ( in their function call? They may look the same to a lexer, but I think that being very clear about what starts the raw string is beneficial for reading.

> If C++ way is chosen, I'd suggest the following permutation of the delimeters, as I think it looks lighter (by virtue of using smaller characters):
> 
> r'delim"raw string"delim'
> r'"raw string"'

I'd really rather not overload the meaning of the ' character, if at all possible. Right now it's used for lifetimes, and character literals. Expanding it to also be used in string literals just feels like unnecessary overloading. We already have a perfectly good " that means string literal. I suppose you could flip that to r"delim'raw string'delim" or r"'raw string'". I just don't see why that's any better than R"delim(raw string)delim" or R"(raw string)". Especially in the r"'raw string'" case, having lots of little tick marks in a row takes more effort to visually distinguish. I suppose r"(raw string)" is an option, but if we're that close to C++11 we may as well just go whole hog and be consistent with their syntax.

-Kevin

From j.e.aten at gmail.com  Mon Sep 23 02:00:31 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 23 Sep 2013 02:00:31 -0700
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAChbWaP3TvqzYQtb8wgNur47JeruLPVca4hfxud0CeLFnHyx6w@mail.gmail.com>
References: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>
	<CADSBmCBMYRjOGsbb-oq7z0FDNYtFG9f+jnGmefbjbNoWCXgGwQ@mail.gmail.com>
	<CAChbWaP3TvqzYQtb8wgNur47JeruLPVca4hfxud0CeLFnHyx6w@mail.gmail.com>
Message-ID: <CAPNEFAbiiUSJOCQNyL_rOvMG81yzajRkjjAqGQf5y9yw6_J5AA@mail.gmail.com>

Since I work in R alot, I value a repl session with state very highly.  Bad
scenario: suppose I'm working at rusti, and then I make one mistake in
syntax, or do an index into a vector that is out-of-bounds and thus cause
an assert!() to fire and my current task to fail. If I'm working at a repl
without transactional rollback and recovery, suddenly rusti deletes all my
data and code and work and starts over? Yikes.  See Alex's comments earlier
in this discussion thread.

To me, casual data loss is simply unacceptable. The repl state must survive
mistakes by the user, or else it isn't usable at all. Period.

Progress update:  we have a name!  Meet Rustxi

Progress update:  and, we have code!

I've implemented transactional code evaluation using three processes and
ping-pong forking.  This was done in a prototype spike of Rust code that I
posted to the repo below, and it works well. It doesn't loose state. It
provides transactions with commit-on-success and rollback-on-failure.  Of
course, nothing is hooked up to rustc yet.

Code, design, and RFC (Request For Comments) here:

https://github.com/glycerine/rustxi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/a0347b22/attachment.html>

From oren at ben-kiki.org  Mon Sep 23 03:17:01 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 23 Sep 2013 13:17:01 +0300
Subject: [rust-dev] If and pattern match
Message-ID: <CADJiDhvNGhQtAXKrwAZJ78wv=ae1_9fvUP_wOha7iYdg3jy5HQ@mail.gmail.com>

A question / proposed syntax... How about allowing writing something like:

    if (Some(foo), Some(bar)) ~~ (get_option("foo"), get_option("bar)) {
        use(foo, bar);
    }

Instead of having to write the more combersome:

    match (get_option("foo"), get_option("bar")) {
        (Some(foo), Some(bar)) => {
            use(foo, bar);
        },
        _otherwise => {},
    }

Not to mention:

    let foo_bar: bool = (Some(_foo), Some(_bar)) ~~ (get_option("foo"),
get_option("bar"));

    match (get_option("foo"), get_option("bar")) {
        (Some(foo), Some(bar)) => {
            use(foo, bar);
        },
        _otherwise => {},
    }

Instead of the very cumbersome:

    let foo_bar: bool =
        match (get_option("foo"), get_option("bar")) {
            (Some(_foo), Some(_bar)) => true,
            _otherwise => false,
        }
    }

So, in general allow `pattern ~~ expression` to be a boolean expression and
if it is used in an "if" statement allow it to introduce the matched
variables to the "then" scope.

The operator doesn't have to be ~~, it could be anything unique (though
using ~ for matching has a lot of precedence in other languages).

Thoughts?

Oren Ben-Kiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/77b8e1da/attachment.html>

From jfager at gmail.com  Mon Sep 23 03:52:59 2013
From: jfager at gmail.com (Jason Fager)
Date: Mon, 23 Sep 2013 06:52:59 -0400
Subject: [rust-dev] If and pattern match
In-Reply-To: <CADJiDhvNGhQtAXKrwAZJ78wv=ae1_9fvUP_wOha7iYdg3jy5HQ@mail.gmail.com>
References: <CADJiDhvNGhQtAXKrwAZJ78wv=ae1_9fvUP_wOha7iYdg3jy5HQ@mail.gmail.com>
Message-ID: <CAFEbTaWEMSF_uo-BimK=JeaqL08gwLdeKj3YrUC6whfpHFneDA@mail.gmail.com>

Doesn't seem like enough bang for the buck to me.  In your first example you
save 3 vertical lines but get a really wide one in return, and lose
some indentation
levels but add more syntax and conceptual overhead to the language.

Might be my lack of imagination, but the feature doesn't seem to expand out
to many other use cases, either.

Your second case you could write as:

let foo = get_option("foo");
let bar = get_option("bar");
if foo.is_some() && bar.is_some() {
    use(foo.unwrap(), bar.unwrap());
}





On Monday, September 23, 2013, Oren Ben-Kiki wrote:

> A question / proposed syntax... How about allowing writing something like:
>
>     if (Some(foo), Some(bar)) ~~ (get_option("foo"), get_option("bar)) {
>         use(foo, bar);
>     }
>
> Instead of having to write the more combersome:
>
>     match (get_option("foo"), get_option("bar")) {
>         (Some(foo), Some(bar)) => {
>             use(foo, bar);
>         },
>         _otherwise => {},
>     }
>
> Not to mention:
>
>     let foo_bar: bool = (Some(_foo), Some(_bar)) ~~ (get_option("foo"),
> get_option("bar"));
>
>     match (get_option("foo"), get_option("bar")) {
>         (Some(foo), Some(bar)) => {
>             use(foo, bar);
>         },
>         _otherwise => {},
>     }
>
> Instead of the very cumbersome:
>
>     let foo_bar: bool =
>         match (get_option("foo"), get_option("bar")) {
>             (Some(_foo), Some(_bar)) => true,
>             _otherwise => false,
>         }
>     }
>
> So, in general allow `pattern ~~ expression` to be a boolean expression
> and if it is used in an "if" statement allow it to introduce the matched
> variables to the "then" scope.
>
> The operator doesn't have to be ~~, it could be anything unique (though
> using ~ for matching has a lot of precedence in other languages).
>
> Thoughts?
>
> Oren Ben-Kiki
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/8905a12e/attachment.html>

From dbau.pp at gmail.com  Mon Sep 23 04:06:20 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 23 Sep 2013 21:06:20 +1000
Subject: [rust-dev] If and pattern match
In-Reply-To: <CAFEbTaWEMSF_uo-BimK=JeaqL08gwLdeKj3YrUC6whfpHFneDA@mail.gmail.com>
References: <CADJiDhvNGhQtAXKrwAZJ78wv=ae1_9fvUP_wOha7iYdg3jy5HQ@mail.gmail.com>
	<CAFEbTaWEMSF_uo-BimK=JeaqL08gwLdeKj3YrUC6whfpHFneDA@mail.gmail.com>
Message-ID: <524020AC.6010803@gmail.com>

On 23/09/13 20:52, Jason Fager wrote:
> Doesn't seem like enough bang for the buck to me. In your 
> first example you save 3 vertical lines but get a really wide one in 
> return, and lose some indentation levels but add more syntax and 
> conceptual overhead to the language.
>
> Might be my lack of imagination, but the feature doesn't seem to 
> expand out to many other use cases, either.
>
> Your second case you could write as:
>
> let foo = get_option("foo");
> let bar = get_option("bar");
> if foo.is_some() && bar.is_some() {
>   use(foo.unwrap(), bar.unwrap());
> }
>

It's also possible to write a `matches` macro:

   macro_rules! matches {
       ($e:expr ~ $($p:pat)|*) => {
           match $e {
               $($p)|* => true,
               _ => false
           }
       }
   }

   fn main() {
       let a = Some(1);
       let b = Some(2);

       if matches!((a,b) ~ (Some(_), Some(_))) {
           println("whatever");
       }
   }

(This has the drawback that accidentally (or otherwise) using a pattern 
that always matches, e.g. `matches!((a,b) ~ (_,_))` gives a error 
message about the `_ => false` arm being unreachable, which isn't 
particularly intuitive.)

Following the use-more-macros line, one could modify the above to give 
something like

   if_matches!(foo ~ (Some(a), Some(b)) => {
       // use a, b
   })

by adding an $expr argument to use instead of `true` and replacing the 
false arm with `{}`. Note: this *may* break when match-var-hygiene is 
implemented (https://github.com/mozilla/rust/issues/9384), I'm not sure.

Huon

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/d5e6136e/attachment-0001.html>

From thadguidry at gmail.com  Mon Sep 23 07:53:02 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 23 Sep 2013 09:53:02 -0500
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAbiiUSJOCQNyL_rOvMG81yzajRkjjAqGQf5y9yw6_J5AA@mail.gmail.com>
References: <CAPNEFAZSCi9LyCq6E=wa2=bjtVjQFBMK1ZWZ1AibSQ9N8xc7OA@mail.gmail.com>
	<CADSBmCBMYRjOGsbb-oq7z0FDNYtFG9f+jnGmefbjbNoWCXgGwQ@mail.gmail.com>
	<CAChbWaP3TvqzYQtb8wgNur47JeruLPVca4hfxud0CeLFnHyx6w@mail.gmail.com>
	<CAPNEFAbiiUSJOCQNyL_rOvMG81yzajRkjjAqGQf5y9yw6_J5AA@mail.gmail.com>
Message-ID: <CAChbWaOziNgg2oGkJ=UB3=VYZxhxTNxS_EW6iC-iDL392cvryw@mail.gmail.com>

Hi Jason,

Nice work.

Curious, this differs in POSIX, I know, but... How long should CUR wait,
what if TRY never finishes and wait cannot retrieve the exit status to
determine normal or abnormal (because of various scenarios) and the
specified process never terminates ?

} else {
       // I am CUR. I wait for TRY to finish. If TRY succeeds I never wake
up. If TRY fails, I goto the
       // top of the steady-state loop and try again
       std::run::waitpid(pid);
       printfln!("%d: CUR saw TRY process exit, must have failed. Going to
top of loop to spawn a new try.",
         getpid() as int);

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/a9727a30/attachment.html>

From paul.stansifer at gmail.com  Mon Sep 23 09:02:32 2013
From: paul.stansifer at gmail.com (Paul Stansifer)
Date: Mon, 23 Sep 2013 12:02:32 -0400
Subject: [rust-dev] Syntax Extensions
In-Reply-To: <CAA5tgF3Ao4aR7wCkAZwY_2avWris0=jvq3fqgVCFn4Sv4zay7Q@mail.gmail.com>
References: <CAA5tgF3Ao4aR7wCkAZwY_2avWris0=jvq3fqgVCFn4Sv4zay7Q@mail.gmail.com>
Message-ID: <CA+VxxZcRnbwgs+eJtGHk=5w_jBfOd51MZYecHe68g5DBed8mHQ@mail.gmail.com>

In libsyntax/ext, `expand.rs` and `base.rs` are the main parts of the
implementation (and `source_utils.rs` is a smaller one), and most of the
rest are implementations of existing syntax extensions. `bytes.rs` and `
env.rs` are simple ones, and `quote.rs` and `fmt.rs` are more complicated.

Note that macros are just a kind of syntax extension, so the way they are
invoked is the same: the user has to do `my_syntax_extension!(...)`; you
can't do, for example, something that walks the whole tree without wrapping
the whole thing in an invocation. I'm not sure what your requirements are
in that area.

Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/eeeb4011/attachment.html>

From j.e.aten at gmail.com  Mon Sep 23 10:42:16 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 23 Sep 2013 10:42:16 -0700
Subject: [rust-dev] rusti - the - repl renovation
Message-ID: <CAPNEFAZVhCvSbKJAYbpT2ah4rZuzcpiCq5HxZzA9iKgm1zRRSA@mail.gmail.com>

On Mon, Sep 23, 2013 at 7:53 AM, Thad Guidry <thadguidry at gmail.com> wrote:

> Hi Jason,
>
> Nice work.
>
> Curious, this differs in POSIX, I know, but... How long should CUR wait,
> what if TRY never finishes and wait cannot retrieve the exit status to
> determine normal or abnormal (because of various scenarios) and the
> specified process never terminates ?
>
> } else {
>        // I am CUR. I wait for TRY to finish. If TRY succeeds I never wake
> up. If TRY fails, I goto the
>        // top of the steady-state loop and try again
>        std::run::waitpid(pid);
>        printfln!("%d: CUR saw TRY process exit, must have failed. Going to
> top of loop to spawn a new try.",
>          getpid() as int);
>

Hi Thad,

Thank you.

The user typing at rustxi can press ctrl-c to interrupt TRY with SIGINT at
any time. This is currently how the prototype rustxi is implemented too
(code updated with ctrl-c handling last night), so you can try it out now
if you'd like. Since TRY doesn't catch SIGINT, by default it dies when the
user presses ctrl-c, then CUR wakes up and forks another TRY.  TRY blocks
on reading from the pipe connected to VISOR, so it waits in turn for the
user input that VISOR is also blocked waiting for.

This seems like typical and expected REPL behavior. It would be quite
surprising to have a repl decide to think on its own that it can time-out
an operation, even after days, unless there was an explicit timer/watchdog
configured by the user. Since I tend to do CPU intensive things, my
preference is to have CUR wait forever.

Did you have a use case or situation in mind where you thought CUR should
timeout?

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/b37de035/attachment.html>

From thadguidry at gmail.com  Mon Sep 23 10:53:42 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 23 Sep 2013 12:53:42 -0500
Subject: [rust-dev] rusti - the - repl renovation
In-Reply-To: <CAPNEFAZVhCvSbKJAYbpT2ah4rZuzcpiCq5HxZzA9iKgm1zRRSA@mail.gmail.com>
References: <CAPNEFAZVhCvSbKJAYbpT2ah4rZuzcpiCq5HxZzA9iKgm1zRRSA@mail.gmail.com>
Message-ID: <CAChbWaMO3HNJ-j_ZzvzjBje==Fwhm3bL1Z0h830tEf5Qw_JT=w@mail.gmail.com>

Did you have a use case or situation in mind where you thought CUR should
> timeout?
>
> Jason
>
>
No situation, I also think CUR should wait forever for the same reasons.
 Just curious, thanks for explaining ctrl-c regarding SIGINT, makes sense.

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/36ae1b12/attachment.html>

From banderson at mozilla.com  Mon Sep 23 11:20:01 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 23 Sep 2013 11:20:01 -0700
Subject: [rust-dev] Rust-dev Digest, Vol 39, Issue 61
In-Reply-To: <CAPNEFAZULhTTn4tqFnDMMTzYoBNhvB2pdoEt6v4SKPB2N_eo1g@mail.gmail.com>
References: <mailman.12499.1379755938.24863.rust-dev@mozilla.org>
	<CAPNEFAZULhTTn4tqFnDMMTzYoBNhvB2pdoEt6v4SKPB2N_eo1g@mail.gmail.com>
Message-ID: <52408651.4050204@mozilla.com>

On 09/21/2013 10:37 PM, Jason E. Aten wrote:
> On Fri, 20 Sep 2013 Brian Anderson  wrote:
> >> On 09/19/2013 11:40 PM, Jason E. Aten wrote:
> >> Perhaps the best thing is just to fork(2), so we get a new (OS level)
> >> process that has copy-on-write (virtual) memory, and if the
> >> compilation + run succeeds in the child, then have the child "take
> >> over". Otherwise the child dies with an fail! + location message, and
> >> we return to the parent exactly before the child was spawned.
> >
> > It seems a shame to be relying on process isolation instead of tasks. If
> > I were to just imagine the architecture of a repl that used task
> > isolation for crash recovery it might have one task for accepting input
> > and another as a sandbox that maintains the repl state and executes
> > commands in a loop.
>
> Yes, it seems a shame. It's even worse than a shame. It adds demands. 
> Using fork(2) demands a single-threaded runtime. Tasks don't require a 
> single threaded runtime. And tasks are more portable. Using fork(2) 
> might mean only supporting Linux or Linux & OSX at first.  Windows 
> support might require cygwin's fork implementation, whereas tasks are 
> everywhere.
>
> So I agree. It seems a shame. I want to do it with tasks only. I just 
> don't see how. How can we do this with tasks and get the desired 
> rollback on fail!()?
>
> I'll detail the problem a little. With only tasks, how do we rollback 
> changes to global state made by pre-compiled library functions that 
> are called from JIT-ed and run code? The task doesn't know what the 
> arbitrary code has done, so the task can't roll it back. Any functions 
> in an arbitrary C library, any unsafe Rust functions, and the 
> JIT-compilation itself will have updated global memory, the llvm 
> module's symbols, etc. Since we've fail!-ed at the end of an 
> arbitrarily long sequence of code, now we want that reverted all that 
> cleanly and completely. How would a task do that?

A task can't do that, but I'd suggest that perhaps rolling back global 
state doesn't need to be a requirement. Most computation in Rust is 
task-local.

>
> I've been down that road for syntax errors before. I've implemented 
> rollback of everything that the LLVM-JIT added to an llvm module. It 
> was a pain, I had to track everything that the llvm jit-compiler did, 
> so I could roll back on syntax error. It was brittle, introducing a 
> myraid of undersirable code-interactions and logging to the current 
> transaction code intertwined with every llvm call. It was a pain, but 
> it worked--for syntax error rollback.

I must defer to your judgement on the issue of JIT rollback, because I 
don't understand it.

>
> But here we're not talking about *just* rolling back on syntax error. 
> We want to roll back not only the effects of a partial 
> JIT-compilation, but to also rollback after *running that code*.  That 
> code can call into *arbitrary global memory modifying code*. All that 
> we know is that an arbitrary set of changes to the process image has 
> ended in a fail!().

What is partial JIT compilation? As to the issue of arbitrary global 
memory modifying code, only unsafe Rust code will do that, and it's 
understood that when running unsafe code there is no safety net.

>
> I'm certainly open to alternatives.  How will that alternative address 
> the rollback on fail!() problem?

All my thoughts on this subject are above. Tasks don't address all the 
problems you want to solve, but I suggest it may be ok not to solve them.

Regards,
Brian

From loebel.marvin at gmail.com  Mon Sep 23 00:58:17 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Mon, 23 Sep 2013 09:58:17 +0200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
Message-ID: <523FF499.8060909@gmail.com>

Hi, I commented under the github Issue for this already, but let me post 
my proposal to the mailing list as well:

My proposal is a `r""` syntax, with the option to pad the string on both 
ends with `#` to allow any string inside:

foo  ==  r"foo"
fo"o ==  r#"fo"o"#
"##  ==  r###""##"###

As far as I know we don't allow `#` in an expression context, it's only 
valid as part of the attribute syntax, so this should work.
Heck, it would even be ok in attributes themselves, I think:

#[foo = r##"test"##];

Alternatively, we could also throw away the `r` token itself and say 
that any number of `#` followed by `"` starts an raw string literal:

let regex = #"[\d]+"#;

Or we make both forms valid: `r""` for short raw strings, and `#""#`, 
`##""##`, ... as alternative to cover every possible string.

It would be similar to Luas syntax, but in my opinion has more advantages:
- It has the same advantage of being able to delimit any text.
- Only being limited to `#` is not a problem, you can still find a 
delimiter sequence for any input, and only need to pad with more `#`s at 
all if your string contains `"`, `"#`, `"##`etc.
- The default case `r""` has very low typing overhead, and looks very 
similar to a regular string literal, no confusion about meaning, or 
annoyance about it not being intuitive.
- Unlike Lua and a few of the other proposals here, r"" doesn't feel out 
of place syntax-wise.

If we look at the uses casesAlex Crichton listed under the github issue:

1. Regular expressions:

r"([^:]*):(\d+):(\d+): (\d+):(\d+) (.*)$".match_groups();

2. Windows paths:

r"C:\Program Files\rust\bin\rust.exe".to_path()

3. `format!` strings:

println!(r"\\");

4. Blobs of text:

static MARKDOWN: &'static str = r###"
## Scope

This is an introductory tutorial for the Rust programming language. It
covers the fundamentals of the language, including the syntax, the
type system and memory model, generics, and modules. [Additional
tutorials](#what-next) cover specific language features in greater
depth.

This tutorial assumes that the reader is already familiar with one or
more languages in the C family. Understanding of pointers and general
memory management techniques will help.
"###;

So, what do you think?

From j.e.aten at gmail.com  Mon Sep 23 14:50:15 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 23 Sep 2013 14:50:15 -0700
Subject: [rust-dev] rusti - the - repl renovation
Message-ID: <CAPNEFAb3h_ef5XJ6snGU_7YmzDaz2_+rFOJbkbR9=Vccj8eWBQ@mail.gmail.com>

On Mon, Sep 23, 2013 at 11:20 AM, Brian Anderson <banderson at mozilla.com>wrote:

> As to the issue of arbitrary global memory modifying code, only unsafe
> Rust code will do that, and it's understood that when running unsafe code
> there is no safety net.


Thanks for your thoughtful comments, Brian.

Even within a task, if I have a ~str that I change and then need to
rollback that change...

Unless there is a way to clone an entire task that I'm not aware of...


>
>  All my thoughts on this subject are above. Tasks don't address all the
> problems you want to solve, but I suggest it may be ok not to solve them.
>

It's nice to feel like there is support for a less ambitious plan.
Nonetheless, I do want aim high at first.

I'd really like a robust and bulletproof repl as much as possible. I
suspect it will entice new users as well. And I think that the choices that
flow from bulletproof are interesting. For instance, how viable is it to
have a (bare-bones if need be) single-threaded rust runtime... which is
also a question of independent interest for those considering Rust for
embedded systems development.

In any case, it might indeed turn out that worse is better or good enough.
But I want to try for better first.

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/47f0cffd/attachment.html>

From corey at octayn.net  Mon Sep 23 15:02:00 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 23 Sep 2013 18:02:00 -0400
Subject: [rust-dev] This Week in Rust
Message-ID: <CA++BO6TPJs-A4ikNpaLMF0F2bKAy0_UDMXgG+BLhFFk5f=c9mA@mail.gmail.com>

Content copied from http://cmr.github.io/blog/2013/09/23/this-week-in-rust/

--

Welcome to another issue of *This Week in Rust*. We're gearing up for a 0.8
release, tentatively planned for Thursday. Additionally, a huge welcome of
Alex Crichton to the Rust team! He's been doing some great work, it's
wonderful to have another full-time Rust dev.


# What's cooking in master?

There were 86 PRs merged this week.

## rustdoc\_ng

rustdoc\_ng was merged into mainline and enabled as the new rustdoc, in time
for 0.8. This makes me incredibly happy, as it marks the conclusion of my
quest to a better rustdoc. Not to say that rustdoc is finished or perfect,
but it's already much better than the old rustdoc. My sincere thanks go to
Jordi Boggiano (Seldaek), who worked unceasingly to create a beautiful,
usable frontend, and to Meret Vollenweider (meretv) for donating her amazing
design skills. Also thanks to Huon Wilson (dbaupp) for moral support and
creating the awesome DocFolder interface that passes over the documentation
use. And, of course, to Alex Crichton, who pushed these past few days to port
the static site generator to Rust and to integrate it into the build system.

The new docs have replaced the old docs. You can view them [on the Rust
website](http://static.rust-lang.org/doc/master/std/index.html). Still to-do
is proper cross-crate doc hyperlinking. To run it on your own crate, build a
recent Rust and do `rustdoc html path/to/your/crate.rs`. It will eventually be
integrated into `rustpkg`.

## Breaking changes

- `extra::par` has been [removed](https://github.com/mozilla/rust/pull/9380).
- Some unsound functional struct updates (FSU, `{a: 5, ..b}`) [are now
  disallowed](https://github.com/mozilla/rust/pull/9350).
- `--cfg debug` is no longer required. If you want to disable debug logging,
  use [`--cfg ndebug`](https://github.com/mozilla/rust/pull/9278).
- The various uses of `NaN` are now [lowercased to
  `nan`](https://github.com/mozilla/rust/pull/9321).
- `std::util::unreachable` has been removed in factor of the
  [`unreachable!`](https://github.com/mozilla/rust/pull/9320) macro.
- `extra::future` has been [cleaned
  up](https://github.com/mozilla/rust/pull/9285) a bit, including some method
  shuffling/renames.
- `extra::getopts` has been [cleaned
  up](https://github.com/mozilla/rust/pull/9267) as well, with most free
  functions now being methods.
- The `from_str` methods in the numeric modules have been
  [removed](https://github.com/mozilla/rust/pull/9275) in favor of the FromStr
  trait and the `from_str` free function in the prelude. Same for
  [`from_str_radix`](https://github.com/mozilla/rust/pull/9209).
- The `Drop` trait now uses [`&mut
  self`](https://github.com/mozilla/rust/pull/9244), as part of the transition
  to by-value drops.
- `extra::json` uses a [different
  encoding](https://github.com/mozilla/rust/pull/9231) when encoding/decoding
  enums, so any Rust-generated JSON before this patch will now be rejected by
  the decoder.

## Other changes

- debuginfo now works for [recursive
  types](https://github.com/mozilla/rust/pull/9168).
- You can now [pass parameters](https://github.com/mozilla/rust/pull/9213) to
  the generated test with `rust test`.
- `extern fn`s from external crates now use the [declared
  ABI](https://github.com/mozilla/rust/pull/9196), rather than assuming cdecl.
- `CString` has gained an
  [`as_str`](https://github.com/mozilla/rust/pull/9220) method.
- Some [overflow bugs](https://github.com/mozilla/rust/pull/9108) in `vec` and
  `str` have been fixed.
- `statics` are now [properly
  inlined](https://github.com/mozilla/rust/pull/9130) cross-crate.
- The `bytes!` macro's error reporting has been [tightened
  up](https://github.com/mozilla/rust/pull/9245) to make it more obvious where
  the error is.
- `rustpkg init` [has been added](https://github.com/mozilla/rust/pull/9236),
  to create a new workspace.
- File IO in newrt has been [massively
  reworked](https://github.com/mozilla/rust/pull/9235) and is much more
  complete than the oldrt.
- The exact meaning of "unsafety" [is now
  documented](https://github.com/mozilla/rust/pull/9258).
- `\0` escapes in strings [is now
  supported](https://github.com/mozilla/rust/pull/9248).
- `rustpkg` now thinks in terms of crates, not packages, to you can now have
  [multiple crates in a single
  package](https://github.com/mozilla/rust/pull/9263) and have things work
  correctly.
- newrt has [pipes and process
  support](https://github.com/mozilla/rust/pull/9260/files) now.
- `format!` now allows [trailing
  commas](https://github.com/mozilla/rust/pull/9299) in its arguments.
- The lexer now throws [vastly better
  errors](https://github.com/mozilla/rust/pull/9308).

# Weekly Meeting

The [weekly
meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-09-17)
discussed quite a bit, most interesting to me was the crypto discussion,
putting `macro_rules!` behind an experimental flag, and the default arguments
discussion.

# Project announcements etc

- [rustymem](https://github.com/williamw520/rustymem) - a pure-rust memcached
  library.
- ["Where to learn more about Rust's concurrency
  model?"](http://www.reddit.com/r/rust/comments/1myesy/where_to_learn_more_about_rusts_concurrency_model/)
- [q3 now has skeletal
  animation!](https://raw.github.com/jeaye/q3/master/pics/016_1_animated_skele.png).

From steven at ashley.net.nz  Mon Sep 23 15:22:55 2013
From: steven at ashley.net.nz (Steven Ashley)
Date: Tue, 24 Sep 2013 10:22:55 +1200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <523FF499.8060909@gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<523FF499.8060909@gmail.com>
Message-ID: <CAH2AfNbc0V=UU1E8oCYZuZsGepSnm5Poav4tp9tVSH+ZUme+Kg@mail.gmail.com>

I'm a fan of always having the r prefix. Its more consistent and it leaves
#foo available for another language feature if required. Otherwise I like
it.

I've tweaked the regex I posted slightly to ensure that the # tokens are
well balanced. See it on regexpal [1].

[rR](#*)([^#"]*|#)\1"(.*?)"\1\2\1

The following match:

r"raw text"
r#"raw text"#
r##"raw text"##
r###"raw text"###
r#eos#"raw text"#eos#
r##eos##"raw text"##eos##
r###eos###"raw text"###eos###

The following don't match:

r# eos #"raw text"# eos  #  -- unbalanced spaces
r#eos"raw text"#eos         -- unbalanced # around eos
r#e#os#"raw text"#e#os#     -- eos contains #

I have mixed feeling regarding the inclusion of spaces in/around the eos
string.

[1]
http://regexpal.com/?flags=gs&regex=%5BrR%5D(%23*)(%5B%5E%23%22%5D*%7C%23)%5C1%22(.*%3F)%22%5C1%5C2%5C1&input=The%20following%20match%3A%0A%0Ar%22raw%20text%22%0Ar%23%22raw%20text%22%23%0Ar%23%23%22raw%20text%22%23%23%0Ar%23%23%23%22raw%20text%22%23%23%23%0Ar%23eos%23%22raw%20text%22%23eos%23%0Ar%23%23eos%23%23%22raw%20text%22%23%23eos%23%23%0Ar%23%23%23eos%23%23%23%22raw%20text%22%23%23%23eos%23%23%23%0A%0AThe%20following%20don't%20match%3A%0A%0Ar%23%20eos%20%23%22raw%20text%22%23%20eos%20%20%23%20%20--%20unbalanced%20spaces%0Ar%23eos%22raw%20text%22%23eos%20%20%20%20%20%20%20%20%20--%20unbalanced%20%23%20around%20eos%0Ar%23e%23os%23%22raw%20text%22%23e%23os%23%20%20%20%20%20--%20eos%20contains%20%23


On Mon, Sep 23, 2013 at 7:58 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> Hi, I commented under the github Issue for this already, but let me post
> my proposal to the mailing list as well:
>
> My proposal is a `r""` syntax, with the option to pad the string on both
> ends with `#` to allow any string inside:
>
> foo  ==  r"foo"
> fo"o ==  r#"fo"o"#
> "##  ==  r###""##"###
>
> As far as I know we don't allow `#` in an expression context, it's only
> valid as part of the attribute syntax, so this should work.
> Heck, it would even be ok in attributes themselves, I think:
>
> #[foo = r##"test"##];
>
> Alternatively, we could also throw away the `r` token itself and say that
> any number of `#` followed by `"` starts an raw string literal:
>
> let regex = #"[\d]+"#;
>
> Or we make both forms valid: `r""` for short raw strings, and `#""#`,
> `##""##`, ... as alternative to cover every possible string.
>
> It would be similar to Luas syntax, but in my opinion has more advantages:
> - It has the same advantage of being able to delimit any text.
> - Only being limited to `#` is not a problem, you can still find a
> delimiter sequence for any input, and only need to pad with more `#`s at
> all if your string contains `"`, `"#`, `"##`etc.
> - The default case `r""` has very low typing overhead, and looks very
> similar to a regular string literal, no confusion about meaning, or
> annoyance about it not being intuitive.
> - Unlike Lua and a few of the other proposals here, r"" doesn't feel out
> of place syntax-wise.
>
> If we look at the uses casesAlex Crichton listed under the github issue:
>
> 1. Regular expressions:
>
> r"([^:]*):(\d+):(\d+): (\d+):(\d+) (.*)$".match_groups();
>
> 2. Windows paths:
>
> r"C:\Program Files\rust\bin\rust.exe".to_**path()
>
> 3. `format!` strings:
>
> println!(r"\\");
>
> 4. Blobs of text:
>
> static MARKDOWN: &'static str = r###"
> ## Scope
>
> This is an introductory tutorial for the Rust programming language. It
> covers the fundamentals of the language, including the syntax, the
> type system and memory model, generics, and modules. [Additional
> tutorials](#what-next) cover specific language features in greater
> depth.
>
> This tutorial assumes that the reader is already familiar with one or
> more languages in the C family. Understanding of pointers and general
> memory management techniques will help.
> "###;
>
> So, what do you think?
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/6acd8066/attachment.html>

From steven at ashley.net.nz  Mon Sep 23 15:25:16 2013
From: steven at ashley.net.nz (Steven Ashley)
Date: Tue, 24 Sep 2013 10:25:16 +1200
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAH2AfNbc0V=UU1E8oCYZuZsGepSnm5Poav4tp9tVSH+ZUme+Kg@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<523FF499.8060909@gmail.com>
	<CAH2AfNbc0V=UU1E8oCYZuZsGepSnm5Poav4tp9tVSH+ZUme+Kg@mail.gmail.com>
Message-ID: <CAH2AfNb4M03CWHL-xicg94tEux7rOa7UVkK9t1eJ9zQ8We0BCg@mail.gmail.com>

I also forgot to mention the possibility of putting a filename as the eos
string. I think its kind of neat.

r##index.html##"
<html>
 ...
</html>
"##index.html##
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/d43fa60d/attachment-0001.html>

From thadguidry at gmail.com  Mon Sep 23 21:48:59 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 23 Sep 2013 23:48:59 -0500
Subject: [rust-dev] Windows Users can build Rust properly again !
In-Reply-To: <CADzE6JPb6Y-Pp+fUgHYw2nVfrM0Ofq2CeoKir1uyQYHcHqw2ew@mail.gmail.com>
References: <CAChbWaPTdE9k5OVR47Z8Pv03AJfz4KNvcOttdcO572WKCNNLGg@mail.gmail.com>
	<CAChbWaOtM3aVe_n2MduhBVWv3B3ZgxcEgR0L2E+GGdD9p-6H4g@mail.gmail.com>
	<52322DCA.8040104@mozilla.com>
	<CADecdiKK5ZoD8LCJtLEOjeyyUOYFvmMVBfchsq2coHMEEhH49g@mail.gmail.com>
	<CAChbWaO5EWXeeq-zqtq6EsVu1ir-51iFB_vqa5CBb=boANFAFg@mail.gmail.com>
	<CADecdiKL1hEu40A1pLn684qEH_RWQk5egQaVoshTpSNAf3o42g@mail.gmail.com>
	<CADzE6JMZEJiiKiGHhja3k2wOA+KVXxYUfg+PS--7UmZ3wBduwQ@mail.gmail.com>
	<465696506198446370@unknownmsgid>
	<CADzE6JNEbOs1Tx=PG3dWmM4bBsZMLYtpg=-EnCVtCrycB_31Tw@mail.gmail.com>
	<CADzE6JN=8yPxatZ+ZWpr+YxpurogHSRWea5Si=fQdE-7goWqrA@mail.gmail.com>
	<CADzE6JP2NTGaR6oh6+7yKWHOWV=iogB15V0VyQyq8r9B5DV6kQ@mail.gmail.com>
	<CADzE6JN=t1TGHX_bEnCfv6QTLySwvsVikqEDG1oY3RHx+sg_Cg@mail.gmail.com>
	<BAY177-W1211328C720010A7E760E088260@phx.gbl>
	<CAChbWaPOBMK1oAvnhdrvSSthhCKO-J0t6trTV4ab-cbvG39Wig@mail.gmail.com>
	<CADecdiK2MifU4SO+c2xaptCzVa3457wu4ritsR4xtFKPNPrEJw@mail.gmail.com>
	<5237A927.30309@mozilla.com>
	<CADecdiJThEL2Rrpeu-B74Q_KBrOT_2bAbnkx8Qcv1w9p93AveQ@mail.gmail.com>
	<D84EE373-2484-4673-A152-27EE9A61445A@mozilla.com>
	<CADecdi+qwsbjGqf1eTT_5rRLpjLmzx+mpSrgTiPQG54rLQ22Uw@mail.gmail.com>
	<CADzE6JPb6Y-Pp+fUgHYw2nVfrM0Ofq2CeoKir1uyQYHcHqw2ew@mail.gmail.com>
Message-ID: <CAChbWaNMarNX3XcLwcuOm7ZJFkprEJfJgTDN==qT9O0QP7v4rw@mail.gmail.com>

So, in my experiments tonight...

I had to have the following copied into stage0/bin in order to build with
mingw32 (gcc 4.8.1)

Older libstdc++-6.dll which I got from here:
http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/gcc-4.6.2-1/libstdc%2B%2B-4.6.2-1-mingw32-dll-6.tar.lzma/download

AND

libpthread-2.dll (which I created by copying & renaming pthreadGC2.dll )
... and now it builds just fine with i686-pc-mingw-32.

I also agree with klutzy that we should bundle them for now.  (and will
enjoy getting a Clang build version to work from stage0 + whenever we can
muster that origami)



On Fri, Sep 20, 2013 at 12:49 AM, klutzy <klutzytheklutzy at gmail.com> wrote:

> > I wonder if we should just bundle runtime libraries with the stage0
> snapshot in the future?
>
> I think we should bundle them: https://github.com/mozilla/rust/issues/9252
>
> On Thu, Sep 19, 2013 at 7:16 AM, Vadim <vadimcn at gmail.com> wrote:
> > Okay, looks like my mingw 4 fix went in last night.
> >
> > Here's my personal recipe for setting up mingw:
> > 1. Download and install mingw-get
> > 2. Install the required packages.  One can do this in GUI, but I prefer
> the
> > command line, as it's less ambiguous:
> >          mingw-get install mingw-developer-toolkit
> >          mingw-get install mingw32-base
> >          mingw-get install mingw32-gcc-g++
> >          mingw-get install mingw32-libpthreadgc
> >          mingw-get install msys-wget
> > 3. Install GIT and Python, make sure they are on the PATH
> > 4. In MSYS shell:  ../configure; make check-fast
> >
> > Until stage0 snapshot compiler has been rebuilt with new mingw, stage0
> > compilation will fail because latest mingw has wrong versions of the
> runtime
> > libraries that rustc depends on.  So:
> > 5.. Get old versions of these dlls:
> >         mingw-get upgrade "g++<4.6"
> >         mingw-get upgrade "libpthread=2.8.0-3"
> > 6.. Copy libgcc_s_dw2-1.dll, libstdc++-6.dll and libpthread-2.dll from
> > %mingw%\bin into %build%\i686-pc-mingw32\stage0\bin.
> > 7. Roll mingw back to the latest:
> >         mingw-get upgrade
> > 8.. make check-fast
> >
> > I wonder if we should just bundle runtime libraries with the stage0
> snapshot
> > in the future?
> >
> > Vadim
> >
> >
> > On Mon, Sep 16, 2013 at 6:33 PM, Alex Crichton <acrichton at mozilla.com>
> > wrote:
> >>
> >> Hey guys, so we're gonna hold off on upgrading the windows builders
> until
> >> we're 100% sure that we won't bork them with a mingw upgrade. What I
> think
> >> that we can do, on the other hand, is:
> >>
> >> 1. Land Vadim's patch onto master
> >> 2. I spin up a clean windows vm (need to do that anyway)
> >> 3. Could you guys send me a list of instructions to build rust on "the
> >> most recent" mingw?
> >> 4. Once verified, and possible bugs fixed, we can go upgrade the
> builders
> >> and documentation about mingw
> >>
> >> Ideally the "build instructions" would be:
> >>
> >> A. Acquire mingw.
> >> B. Acquire relevant gcc version 4.X
> >> C. ./configure && make
> >>
> >> It'd be awesome to keep it that simple, and it seems that your patches
> >> would have eliminated the need for patching system files?
> >>
> >> How does that sound to you guys?
> >>
> >> On Sep 16, 2013, at 6:20 PM, Vadim <vadimcn at gmail.com> wrote:
> >>
> >
>



-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130923/4e79c0c4/attachment.html>

From jon.mb at proinbox.com  Mon Sep 23 23:18:45 2013
From: jon.mb at proinbox.com (John Mija)
Date: Tue, 24 Sep 2013 07:18:45 +0100
Subject: [rust-dev] Minimal raytracer
Message-ID: <52412EC5.30704@proinbox.com>

Since a post in HN about a raytracer into a business card, a guy built 
the implementation in Go:

https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw

The C++ version: https://gist.github.com/kid0m4n/6680629
The Go version: https://github.com/kid0m4n/gorays

Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go 1.1.2):

C++ version: 11.803 s
Go version: 28.883 s

* * *
It would be interesting if somebody with experience in Rust could build 
the version in Rust to compare the speed.

From dbau.pp at gmail.com  Tue Sep 24 06:52:10 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 24 Sep 2013 23:52:10 +1000
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <52412EC5.30704@proinbox.com>
References: <52412EC5.30704@proinbox.com>
Message-ID: <5241990A.4070203@gmail.com>

On 24/09/13 16:18, John Mija wrote:
> Since a post in HN about a raytracer into a business card, a guy built 
> the implementation in Go:
>
> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
>
> The C++ version: https://gist.github.com/kid0m4n/6680629
> The Go version: https://github.com/kid0m4n/gorays
>
> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go 1.1.2):
>
> C++ version: 11.803 s
> Go version: 28.883 s
>
> * * *
> It would be interesting if somebody with experience in Rust could 
> build the version in Rust to compare the speed.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

I bit: https://github.com/huonw/card-trace

Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.

(1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd 
2013-09-23 23:46:05 -0700.)

I just did essentially a transliteration of the C++ into (reasonably 
idiomatic) Rust, I imagine one could make it faster with some effort, 
but that would be cheating (at least, it would then become a test of 
*my* micro-optimisation ability, rather than that of the compilers). It 
appears that clang vectorises/uses SSE directly more eagerly than either 
gcc or rustc from some quick poking with perf.

(I don't have Go on this computer to compare; although I imagine the 
only comparison of interest would be with gccgo, since "normal" go 
doesn't optimise anywhere near as much as LLVM does.)

Huon

From thadguidry at gmail.com  Tue Sep 24 08:43:15 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 24 Sep 2013 10:43:15 -0500
Subject: [rust-dev] Problems with direct download of stage0 tarball
Message-ID: <CAChbWaML=CvfpVmTjtmvE0DUEvxmj2y2-tRB6Mhxnfpqp_AF8w@mail.gmail.com>

I cannot seem to download this tarball, for some reason:

http://static.rust-lang.org/stage0-snapshots/dl/rust-stage0-2013-09-23-348d844-winnt-i386-7988b58a9530a4ac0688ec978e9124c5db56717c.tar.bz2

???

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/a753fa69/attachment.html>

From thadguidry at gmail.com  Tue Sep 24 09:09:24 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 24 Sep 2013 11:09:24 -0500
Subject: [rust-dev] Problems with direct download of stage0 tarball
In-Reply-To: <CAChbWaML=CvfpVmTjtmvE0DUEvxmj2y2-tRB6Mhxnfpqp_AF8w@mail.gmail.com>
References: <CAChbWaML=CvfpVmTjtmvE0DUEvxmj2y2-tRB6Mhxnfpqp_AF8w@mail.gmail.com>
Message-ID: <CAChbWaNAfUYmWTp6kfZ5jRAXXxRBas93FPtVb=OFmj9_YzNJng@mail.gmail.com>

bah !!   found my problem... had the extra /dl/ in the path.

ignore this thread. :)


On Tue, Sep 24, 2013 at 10:43 AM, Thad Guidry <thadguidry at gmail.com> wrote:

> I cannot seem to download this tarball, for some reason:
>
>
> http://static.rust-lang.org/stage0-snapshots/dl/rust-stage0-2013-09-23-348d844-winnt-i386-7988b58a9530a4ac0688ec978e9124c5db56717c.tar.bz2
>
> ???
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>



-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/174f394d/attachment.html>

From oren at ben-kiki.org  Tue Sep 24 09:23:26 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 24 Sep 2013 19:23:26 +0300
Subject: [rust-dev] If and pattern match
In-Reply-To: <524020AC.6010803@gmail.com>
References: <CADJiDhvNGhQtAXKrwAZJ78wv=ae1_9fvUP_wOha7iYdg3jy5HQ@mail.gmail.com>
	<CAFEbTaWEMSF_uo-BimK=JeaqL08gwLdeKj3YrUC6whfpHFneDA@mail.gmail.com>
	<524020AC.6010803@gmail.com>
Message-ID: <CADJiDhvjXWj4Bm0usULZvoi=O+Lmk=0i4yyPwpqMQe2QSKbTWw@mail.gmail.com>

I agree that is a macro like your `if_matches` examples were possible, it
would be a reasonable solution, including conferring the right scope for
`a` and `b`.

It is completely unclear to me how to implement it though. What does
"use_more_macros line" mean?

Thanks,

Oren.



On Mon, Sep 23, 2013 at 2:06 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  On 23/09/13 20:52, Jason Fager wrote:
>
> Doesn't seem like enough bang for the buck to me.  In your first example you
> save 3 vertical lines but get a really wide one in return, and lose some indentation
> levels but add more syntax and conceptual overhead to the language.
>
>  Might be my lack of imagination, but the feature doesn't seem to expand
> out to many other use cases, either.
>
>  Your second case you could write as:
>
>  let foo = get_option("foo");
> let bar = get_option("bar");
> if foo.is_some() && bar.is_some() {
>      use(foo.unwrap(), bar.unwrap());
> }
>
>
> It's also possible to write a `matches` macro:
>
>   macro_rules! matches {
>       ($e:expr ~ $($p:pat)|*) => {
>           match $e {
>               $($p)|* => true,
>               _ => false
>           }
>       }
>   }
>
>   fn main() {
>       let a = Some(1);
>       let b = Some(2);
>
>       if matches!((a,b) ~ (Some(_), Some(_))) {
>           println("whatever");
>       }
>   }
>
> (This has the drawback that accidentally (or otherwise) using a pattern
> that always matches, e.g. `matches!((a,b) ~ (_,_))` gives a error message
> about the `_ => false` arm being unreachable, which isn't particularly
> intuitive.)
>
> Following the use-more-macros line, one could modify the above to give
> something like
>
>   if_matches!(foo ~ (Some(a), Some(b)) => {
>       // use a, b
>   })
>
> by adding an $expr argument to use instead of `true` and replacing the
> false arm with `{}`. Note: this *may* break when match-var-hygiene is
> implemented (https://github.com/mozilla/rust/issues/9384), I'm not sure.
>
> Huon
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/95979dbd/attachment-0001.html>

From jon.mb at proinbox.com  Tue Sep 24 10:08:01 2013
From: jon.mb at proinbox.com (John Mija)
Date: Tue, 24 Sep 2013 18:08:01 +0100
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <5241990A.4070203@gmail.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
Message-ID: <5241C6F1.40102@proinbox.com>

Summary: Rustc 17.7s, Go 13.6s, Clang 11.2s, GCC 10.4s.

Note that the versions in Clang, G++ and Go are rendering the word "Go" 
while that the Rust version is rendering a word bigger "Rust"

System: x86_64 GNU/Linux 3.8.0-30-generic
     Intel(R) Core(TM) i3-2100 CPU @ 3.10GHz
     4 GB RAM

I've used Rust trunk, Go 1.1.2:

$ gcc --version
gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3

$ clang --version
Ubuntu clang version 3.2-1~exp9ubuntu1 (tags/RELEASE_32/final) (based on 
LLVM 3.2)
Target: x86_64-pc-linux-gnu
Thread model: posix

$ go version
go version go1.1.2 linux/amd64

$ rust --version
rust 0.8 (b6fe27c 2013-09-24 07:06:09 -0700)
host: x86_64-unknown-linux-gnu

* * *

$ rustc --opt-level=3 raytracer.rs -o rayt-rust
$ time ./rayt-rust > rayt-rust.ppm

real	0m17.746s
user	0m17.332s
sys	0m0.404s

$ go tool 6g raytracer.go && go tool 6l -o rayt-go raytracer.6 && rm 
raytracer.6

$ time ./rayt-go > rayt-go.ppm

real	0m13.664s
user	0m13.656s
sys	0m0.008s

$ clang -O3 -lm raytracer.cpp -o rayt-clang
$ time ./rayt-clang > rayt-clang.ppm

real	0m11.199s
user	0m11.188s
sys	0m0.004s

$ g++ -O3 -lm raytracer.cpp -o rayt-g++
$ time ./rayt-g++ > rayt-g++.ppm

real	0m10.411s
user	0m10.404s
sys	0m0.000s


El 24/09/13 14:52, Huon Wilson escribi?:
> On 24/09/13 16:18, John Mija wrote:
>> Since a post in HN about a raytracer into a business card, a guy built
>> the implementation in Go:
>>
>> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
>>
>> The C++ version: https://gist.github.com/kid0m4n/6680629
>> The Go version: https://github.com/kid0m4n/gorays
>>
>> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go 1.1.2):
>>
>> C++ version: 11.803 s
>> Go version: 28.883 s
>>
>> * * *
>> It would be interesting if somebody with experience in Rust could
>> build the version in Rust to compare the speed.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> I bit: https://github.com/huonw/card-trace
>
> Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.
>
> (1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd
> 2013-09-23 23:46:05 -0700.)
>
> I just did essentially a transliteration of the C++ into (reasonably
> idiomatic) Rust, I imagine one could make it faster with some effort,
> but that would be cheating (at least, it would then become a test of
> *my* micro-optimisation ability, rather than that of the compilers). It
> appears that clang vectorises/uses SSE directly more eagerly than either
> gcc or rustc from some quick poking with perf.
>
> (I don't have Go on this computer to compare; although I imagine the
> only comparison of interest would be with gccgo, since "normal" go
> doesn't optimise anywhere near as much as LLVM does.)
>
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>

From irving at naml.us  Tue Sep 24 10:59:09 2013
From: irving at naml.us (Geoffrey Irving)
Date: Tue, 24 Sep 2013 10:59:09 -0700
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <5241C6F1.40102@proinbox.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
Message-ID: <650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>

It seems like rust would perform better in this benchmark against languages like Erlang and Haskell, which have even longer names.

Geoffrey

On Sep 24, 2013, at 10:08 AM, John Mija <jon.mb at proinbox.com> wrote:

> Summary: Rustc 17.7s, Go 13.6s, Clang 11.2s, GCC 10.4s.
> 
> Note that the versions in Clang, G++ and Go are rendering the word "Go" while that the Rust version is rendering a word bigger "Rust"
> 
> System: x86_64 GNU/Linux 3.8.0-30-generic
>    Intel(R) Core(TM) i3-2100 CPU @ 3.10GHz
>    4 GB RAM
> 
> I've used Rust trunk, Go 1.1.2:
> 
> $ gcc --version
> gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
> 
> $ clang --version
> Ubuntu clang version 3.2-1~exp9ubuntu1 (tags/RELEASE_32/final) (based on LLVM 3.2)
> Target: x86_64-pc-linux-gnu
> Thread model: posix
> 
> $ go version
> go version go1.1.2 linux/amd64
> 
> $ rust --version
> rust 0.8 (b6fe27c 2013-09-24 07:06:09 -0700)
> host: x86_64-unknown-linux-gnu
> 
> * * *
> 
> $ rustc --opt-level=3 raytracer.rs -o rayt-rust
> $ time ./rayt-rust > rayt-rust.ppm
> 
> real	0m17.746s
> user	0m17.332s
> sys	0m0.404s
> 
> $ go tool 6g raytracer.go && go tool 6l -o rayt-go raytracer.6 && rm raytracer.6
> 
> $ time ./rayt-go > rayt-go.ppm
> 
> real	0m13.664s
> user	0m13.656s
> sys	0m0.008s
> 
> $ clang -O3 -lm raytracer.cpp -o rayt-clang
> $ time ./rayt-clang > rayt-clang.ppm
> 
> real	0m11.199s
> user	0m11.188s
> sys	0m0.004s
> 
> $ g++ -O3 -lm raytracer.cpp -o rayt-g++
> $ time ./rayt-g++ > rayt-g++.ppm
> 
> real	0m10.411s
> user	0m10.404s
> sys	0m0.000s
> 
> 
> El 24/09/13 14:52, Huon Wilson escribi?:
>> On 24/09/13 16:18, John Mija wrote:
>>> Since a post in HN about a raytracer into a business card, a guy built
>>> the implementation in Go:
>>> 
>>> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
>>> 
>>> The C++ version: https://gist.github.com/kid0m4n/6680629
>>> The Go version: https://github.com/kid0m4n/gorays
>>> 
>>> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go 1.1.2):
>>> 
>>> C++ version: 11.803 s
>>> Go version: 28.883 s
>>> 
>>> * * *
>>> It would be interesting if somebody with experience in Rust could
>>> build the version in Rust to compare the speed.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> I bit: https://github.com/huonw/card-trace
>> 
>> Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.
>> 
>> (1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd
>> 2013-09-23 23:46:05 -0700.)
>> 
>> I just did essentially a transliteration of the C++ into (reasonably
>> idiomatic) Rust, I imagine one could make it faster with some effort,
>> but that would be cheating (at least, it would then become a test of
>> *my* micro-optimisation ability, rather than that of the compilers). It
>> appears that clang vectorises/uses SSE directly more eagerly than either
>> gcc or rustc from some quick poking with perf.
>> 
>> (I don't have Go on this computer to compare; although I imagine the
>> only comparison of interest would be with gccgo, since "normal" go
>> doesn't optimise anywhere near as much as LLVM does.)
>> 
>> Huon
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/63151a7c/attachment.sig>

From tkuehn at cmu.edu  Tue Sep 24 11:13:09 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Tue, 24 Sep 2013 14:13:09 -0400
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
Message-ID: <CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>

To make it a "fair" fight, I converted the Go and C++ versions to trace
"Rust" instead. These are my results on my Macbook Pro:

=== RUST ===
$ rustc -O bin.rs
$ time ./bin > rrays.ppm

real 0m14.472s
user 0m14.102s
sys 0m0.365s

=== GO ===
$ go build main.go
$ time ./main > grays.ppm

real 0m13.928s
user 0m13.914s
sys 0m0.020s

=== C++ ===
$ gcc -O crays.cpp
$ time ./a.out > crays.ppm

real 0m10.800s
user 0m10.794s
sys 0m0.005s

=== RANKINGS ===
1) C++ : 10.8s
2) Go   : 13.9s
3) Rust : 14.5s


On Tue, Sep 24, 2013 at 1:59 PM, Geoffrey Irving <irving at naml.us> wrote:

> It seems like rust would perform better in this benchmark against
> languages like Erlang and Haskell, which have even longer names.
>
> Geoffrey
>
> On Sep 24, 2013, at 10:08 AM, John Mija <jon.mb at proinbox.com> wrote:
>
> > Summary: Rustc 17.7s, Go 13.6s, Clang 11.2s, GCC 10.4s.
> >
> > Note that the versions in Clang, G++ and Go are rendering the word "Go"
> while that the Rust version is rendering a word bigger "Rust"
> >
> > System: x86_64 GNU/Linux 3.8.0-30-generic
> >    Intel(R) Core(TM) i3-2100 CPU @ 3.10GHz
> >    4 GB RAM
> >
> > I've used Rust trunk, Go 1.1.2:
> >
> > $ gcc --version
> > gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
> >
> > $ clang --version
> > Ubuntu clang version 3.2-1~exp9ubuntu1 (tags/RELEASE_32/final) (based on
> LLVM 3.2)
> > Target: x86_64-pc-linux-gnu
> > Thread model: posix
> >
> > $ go version
> > go version go1.1.2 linux/amd64
> >
> > $ rust --version
> > rust 0.8 (b6fe27c 2013-09-24 07:06:09 -0700)
> > host: x86_64-unknown-linux-gnu
> >
> > * * *
> >
> > $ rustc --opt-level=3 raytracer.rs -o rayt-rust
> > $ time ./rayt-rust > rayt-rust.ppm
> >
> > real  0m17.746s
> > user  0m17.332s
> > sys   0m0.404s
> >
> > $ go tool 6g raytracer.go && go tool 6l -o rayt-go raytracer.6 && rm
> raytracer.6
> >
> > $ time ./rayt-go > rayt-go.ppm
> >
> > real  0m13.664s
> > user  0m13.656s
> > sys   0m0.008s
> >
> > $ clang -O3 -lm raytracer.cpp -o rayt-clang
> > $ time ./rayt-clang > rayt-clang.ppm
> >
> > real  0m11.199s
> > user  0m11.188s
> > sys   0m0.004s
> >
> > $ g++ -O3 -lm raytracer.cpp -o rayt-g++
> > $ time ./rayt-g++ > rayt-g++.ppm
> >
> > real  0m10.411s
> > user  0m10.404s
> > sys   0m0.000s
> >
> >
> > El 24/09/13 14:52, Huon Wilson escribi?:
> >> On 24/09/13 16:18, John Mija wrote:
> >>> Since a post in HN about a raytracer into a business card, a guy built
> >>> the implementation in Go:
> >>>
> >>> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
> >>>
> >>> The C++ version: https://gist.github.com/kid0m4n/6680629
> >>> The Go version: https://github.com/kid0m4n/gorays
> >>>
> >>> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go 1.1.2):
> >>>
> >>> C++ version: 11.803 s
> >>> Go version: 28.883 s
> >>>
> >>> * * *
> >>> It would be interesting if somebody with experience in Rust could
> >>> build the version in Rust to compare the speed.
> >>> _______________________________________________
> >>> Rust-dev mailing list
> >>> Rust-dev at mozilla.org
> >>> https://mail.mozilla.org/listinfo/rust-dev
> >>
> >> I bit: https://github.com/huonw/card-trace
> >>
> >> Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.
> >>
> >> (1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd
> >> 2013-09-23 23:46:05 -0700.)
> >>
> >> I just did essentially a transliteration of the C++ into (reasonably
> >> idiomatic) Rust, I imagine one could make it faster with some effort,
> >> but that would be cheating (at least, it would then become a test of
> >> *my* micro-optimisation ability, rather than that of the compilers). It
> >> appears that clang vectorises/uses SSE directly more eagerly than either
> >> gcc or rustc from some quick poking with perf.
> >>
> >> (I don't have Go on this computer to compare; although I imagine the
> >> only comparison of interest would be with gccgo, since "normal" go
> >> doesn't optimise anywhere near as much as LLVM does.)
> >>
> >> Huon
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> >>
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/73484cee/attachment.html>

From ben.striegel at gmail.com  Tue Sep 24 12:44:53 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 24 Sep 2013 15:44:53 -0400
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
Message-ID: <CAAvrL-mtma5X5M3adXi3_L8CBq5DGb-3P7rYhNsk-1C6fQkq5A@mail.gmail.com>

> I think string literals should contain exactly what they contain in their
source form, without any additional processing. If you want to express
characters that are inconvenient to type, you can use control sequences and
a (standard) formatting library to produce them.

I'm actually very intrigued by the idea of eliminating escape characters
altogether in the default string literals. Would follow nicely from how we
allow newlines in string literals. We'd have to give up the optional
"whitespace-chomping" behavior around newlines, though, which would make me
pretty sad. And are you really willing to force everyone who wants to
include a quotation mark in a string to go through a syntax extension to do
it?

<facetious>

People, please! Using delimiters on string literals is tantamount to
checking for null to determine when you've reached the end of a string in
memory. We've graduated beyond those barbarous days by explicitly noting
the length of each string in the header, so let's just reuse that idea!
Behold, Rust's new string literals:

    fn main() {
        print(#7"hello");
        print(#2", ");
        print(#5"world");
    }

</facetious>


On Sun, Sep 22, 2013 at 5:32 PM, Sebastian Sylvan <
sebastian.sylvan at gmail.com> wrote:

>
>
>
> On Thu, Sep 19, 2013 at 1:36 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> One feature common to many programming languages that Rust lacks is "raw"
>> string literals.
>
>
> This is one of those things where I feel almost all languages get wrong,
> and probably mostly for historical reasons. IMO there should *only* be raw
> string literals on the syntax level. It seems extremely weird to me that
> languages have this second-level language that gets interpreted within a
> literal. That kind of higher level processing should be part of a
> formatting library (e.g. a macro like fmt), rather than an embedded
> language inside the literal syntax. So, I think string literals should
> contain exactly what they contain in their source form, without any
> additional processing. If you want to express characters that are
> inconvenient to type, you can use control sequences and a (standard)
> formatting library to produce them.
>
> --
> Sebastian Sylvan
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/9b85a67c/attachment.html>

From ben.striegel at gmail.com  Tue Sep 24 12:51:57 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 24 Sep 2013 15:51:57 -0400
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
	<CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
Message-ID: <CAAvrL-k=7c_CeDxMMij+VEv==zcToE2oqua3dFGyCs=6dtAF+Q@mail.gmail.com>

I'd be curious to know if changing "rustc -O" to "rustc --opt-level=3" has
any effect. Which is to say, I'm curious if currently we make any
distinction at all between opt levels 2 and 3.

Also, what version of Rust? I believe our support for
LLVM-SIMD-vectorization-pass voodoo only landed recently.


On Tue, Sep 24, 2013 at 2:13 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:

> To make it a "fair" fight, I converted the Go and C++ versions to trace
> "Rust" instead. These are my results on my Macbook Pro:
>
> === RUST ===
> $ rustc -O bin.rs
> $ time ./bin > rrays.ppm
>
> real 0m14.472s
> user 0m14.102s
> sys 0m0.365s
>
> === GO ===
> $ go build main.go
> $ time ./main > grays.ppm
>
> real 0m13.928s
> user 0m13.914s
> sys 0m0.020s
>
> === C++ ===
> $ gcc -O crays.cpp
> $ time ./a.out > crays.ppm
>
> real 0m10.800s
> user 0m10.794s
> sys 0m0.005s
>
> === RANKINGS ===
> 1) C++ : 10.8s
> 2) Go   : 13.9s
> 3) Rust : 14.5s
>
>
> On Tue, Sep 24, 2013 at 1:59 PM, Geoffrey Irving <irving at naml.us> wrote:
>
>> It seems like rust would perform better in this benchmark against
>> languages like Erlang and Haskell, which have even longer names.
>>
>> Geoffrey
>>
>> On Sep 24, 2013, at 10:08 AM, John Mija <jon.mb at proinbox.com> wrote:
>>
>> > Summary: Rustc 17.7s, Go 13.6s, Clang 11.2s, GCC 10.4s.
>> >
>> > Note that the versions in Clang, G++ and Go are rendering the word "Go"
>> while that the Rust version is rendering a word bigger "Rust"
>> >
>> > System: x86_64 GNU/Linux 3.8.0-30-generic
>> >    Intel(R) Core(TM) i3-2100 CPU @ 3.10GHz
>> >    4 GB RAM
>> >
>> > I've used Rust trunk, Go 1.1.2:
>> >
>> > $ gcc --version
>> > gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
>> >
>> > $ clang --version
>> > Ubuntu clang version 3.2-1~exp9ubuntu1 (tags/RELEASE_32/final) (based
>> on LLVM 3.2)
>> > Target: x86_64-pc-linux-gnu
>> > Thread model: posix
>> >
>> > $ go version
>> > go version go1.1.2 linux/amd64
>> >
>> > $ rust --version
>> > rust 0.8 (b6fe27c 2013-09-24 07:06:09 -0700)
>> > host: x86_64-unknown-linux-gnu
>> >
>> > * * *
>> >
>> > $ rustc --opt-level=3 raytracer.rs -o rayt-rust
>> > $ time ./rayt-rust > rayt-rust.ppm
>> >
>> > real  0m17.746s
>> > user  0m17.332s
>> > sys   0m0.404s
>> >
>> > $ go tool 6g raytracer.go && go tool 6l -o rayt-go raytracer.6 && rm
>> raytracer.6
>> >
>> > $ time ./rayt-go > rayt-go.ppm
>> >
>> > real  0m13.664s
>> > user  0m13.656s
>> > sys   0m0.008s
>> >
>> > $ clang -O3 -lm raytracer.cpp -o rayt-clang
>> > $ time ./rayt-clang > rayt-clang.ppm
>> >
>> > real  0m11.199s
>> > user  0m11.188s
>> > sys   0m0.004s
>> >
>> > $ g++ -O3 -lm raytracer.cpp -o rayt-g++
>> > $ time ./rayt-g++ > rayt-g++.ppm
>> >
>> > real  0m10.411s
>> > user  0m10.404s
>> > sys   0m0.000s
>> >
>> >
>> > El 24/09/13 14:52, Huon Wilson escribi?:
>> >> On 24/09/13 16:18, John Mija wrote:
>> >>> Since a post in HN about a raytracer into a business card, a guy built
>> >>> the implementation in Go:
>> >>>
>> >>> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
>> >>>
>> >>> The C++ version: https://gist.github.com/kid0m4n/6680629
>> >>> The Go version: https://github.com/kid0m4n/gorays
>> >>>
>> >>> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go
>> 1.1.2):
>> >>>
>> >>> C++ version: 11.803 s
>> >>> Go version: 28.883 s
>> >>>
>> >>> * * *
>> >>> It would be interesting if somebody with experience in Rust could
>> >>> build the version in Rust to compare the speed.
>> >>> _______________________________________________
>> >>> Rust-dev mailing list
>> >>> Rust-dev at mozilla.org
>> >>> https://mail.mozilla.org/listinfo/rust-dev
>> >>
>> >> I bit: https://github.com/huonw/card-trace
>> >>
>> >> Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.
>> >>
>> >> (1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd
>> >> 2013-09-23 23:46:05 -0700.)
>> >>
>> >> I just did essentially a transliteration of the C++ into (reasonably
>> >> idiomatic) Rust, I imagine one could make it faster with some effort,
>> >> but that would be cheating (at least, it would then become a test of
>> >> *my* micro-optimisation ability, rather than that of the compilers). It
>> >> appears that clang vectorises/uses SSE directly more eagerly than
>> either
>> >> gcc or rustc from some quick poking with perf.
>> >>
>> >> (I don't have Go on this computer to compare; although I imagine the
>> >> only comparison of interest would be with gccgo, since "normal" go
>> >> doesn't optimise anywhere near as much as LLVM does.)
>> >>
>> >> Huon
>> >> _______________________________________________
>> >> Rust-dev mailing list
>> >> Rust-dev at mozilla.org
>> >> https://mail.mozilla.org/listinfo/rust-dev
>> >>
>> >>
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/e3921e4a/attachment.html>

From tkuehn at cmu.edu  Tue Sep 24 12:59:23 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Tue, 24 Sep 2013 15:59:23 -0400
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <CAAvrL-k=7c_CeDxMMij+VEv==zcToE2oqua3dFGyCs=6dtAF+Q@mail.gmail.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
	<CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
	<CAAvrL-k=7c_CeDxMMij+VEv==zcToE2oqua3dFGyCs=6dtAF+Q@mail.gmail.com>
Message-ID: <CACVDHKndGuwBtSctFGU4Jzs_+t7j7=MXTVuwCgCL1jLPN-KsyA@mail.gmail.com>

>
> I'd be curious to know if changing "rustc -O" to "rustc --opt-level=3" has
> any effect. Which is to say, I'm curious if currently we make any
> distinction at all between opt levels 2 and 3.
>
There was no difference when I ran it with --opt-level=3.

Also, what version of Rust? I believe our support for
> LLVM-SIMD-vectorization-pass voodoo only landed recently.

 My rust is current as of sometime yesterday.


On Tue, Sep 24, 2013 at 3:51 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> I'd be curious to know if changing "rustc -O" to "rustc --opt-level=3" has
> any effect. Which is to say, I'm curious if currently we make any
> distinction at all between opt levels 2 and 3.
>
> Also, what version of Rust? I believe our support for
> LLVM-SIMD-vectorization-pass voodoo only landed recently.
>
>
> On Tue, Sep 24, 2013 at 2:13 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>
>> To make it a "fair" fight, I converted the Go and C++ versions to trace
>> "Rust" instead. These are my results on my Macbook Pro:
>>
>> === RUST ===
>> $ rustc -O bin.rs
>> $ time ./bin > rrays.ppm
>>
>> real 0m14.472s
>> user 0m14.102s
>> sys 0m0.365s
>>
>> === GO ===
>> $ go build main.go
>> $ time ./main > grays.ppm
>>
>> real 0m13.928s
>> user 0m13.914s
>> sys 0m0.020s
>>
>> === C++ ===
>> $ gcc -O crays.cpp
>> $ time ./a.out > crays.ppm
>>
>> real 0m10.800s
>> user 0m10.794s
>> sys 0m0.005s
>>
>> === RANKINGS ===
>> 1) C++ : 10.8s
>> 2) Go   : 13.9s
>> 3) Rust : 14.5s
>>
>>
>> On Tue, Sep 24, 2013 at 1:59 PM, Geoffrey Irving <irving at naml.us> wrote:
>>
>>> It seems like rust would perform better in this benchmark against
>>> languages like Erlang and Haskell, which have even longer names.
>>>
>>> Geoffrey
>>>
>>> On Sep 24, 2013, at 10:08 AM, John Mija <jon.mb at proinbox.com> wrote:
>>>
>>> > Summary: Rustc 17.7s, Go 13.6s, Clang 11.2s, GCC 10.4s.
>>> >
>>> > Note that the versions in Clang, G++ and Go are rendering the word
>>> "Go" while that the Rust version is rendering a word bigger "Rust"
>>> >
>>> > System: x86_64 GNU/Linux 3.8.0-30-generic
>>> >    Intel(R) Core(TM) i3-2100 CPU @ 3.10GHz
>>> >    4 GB RAM
>>> >
>>> > I've used Rust trunk, Go 1.1.2:
>>> >
>>> > $ gcc --version
>>> > gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
>>> >
>>> > $ clang --version
>>> > Ubuntu clang version 3.2-1~exp9ubuntu1 (tags/RELEASE_32/final) (based
>>> on LLVM 3.2)
>>> > Target: x86_64-pc-linux-gnu
>>> > Thread model: posix
>>> >
>>> > $ go version
>>> > go version go1.1.2 linux/amd64
>>> >
>>> > $ rust --version
>>> > rust 0.8 (b6fe27c 2013-09-24 07:06:09 -0700)
>>> > host: x86_64-unknown-linux-gnu
>>> >
>>> > * * *
>>> >
>>> > $ rustc --opt-level=3 raytracer.rs -o rayt-rust
>>> > $ time ./rayt-rust > rayt-rust.ppm
>>> >
>>> > real  0m17.746s
>>> > user  0m17.332s
>>> > sys   0m0.404s
>>> >
>>> > $ go tool 6g raytracer.go && go tool 6l -o rayt-go raytracer.6 && rm
>>> raytracer.6
>>> >
>>> > $ time ./rayt-go > rayt-go.ppm
>>> >
>>> > real  0m13.664s
>>> > user  0m13.656s
>>> > sys   0m0.008s
>>> >
>>> > $ clang -O3 -lm raytracer.cpp -o rayt-clang
>>> > $ time ./rayt-clang > rayt-clang.ppm
>>> >
>>> > real  0m11.199s
>>> > user  0m11.188s
>>> > sys   0m0.004s
>>> >
>>> > $ g++ -O3 -lm raytracer.cpp -o rayt-g++
>>> > $ time ./rayt-g++ > rayt-g++.ppm
>>> >
>>> > real  0m10.411s
>>> > user  0m10.404s
>>> > sys   0m0.000s
>>> >
>>> >
>>> > El 24/09/13 14:52, Huon Wilson escribi?:
>>> >> On 24/09/13 16:18, John Mija wrote:
>>> >>> Since a post in HN about a raytracer into a business card, a guy
>>> built
>>> >>> the implementation in Go:
>>> >>>
>>> >>> https://groups.google.com/forum/#!topic/golang-nuts/mxYzHQSV3rw
>>> >>>
>>> >>> The C++ version: https://gist.github.com/kid0m4n/6680629
>>> >>> The Go version: https://github.com/kid0m4n/gorays
>>> >>>
>>> >>> Performance (2.2 Ghz Quad Core (2675QM), 16 GB RAM, OX 10.9, Go
>>> 1.1.2):
>>> >>>
>>> >>> C++ version: 11.803 s
>>> >>> Go version: 28.883 s
>>> >>>
>>> >>> * * *
>>> >>> It would be interesting if somebody with experience in Rust could
>>> >>> build the version in Rust to compare the speed.
>>> >>> _______________________________________________
>>> >>> Rust-dev mailing list
>>> >>> Rust-dev at mozilla.org
>>> >>> https://mail.mozilla.org/listinfo/rust-dev
>>> >>
>>> >> I bit: https://github.com/huonw/card-trace
>>> >>
>>> >> Summary: Clang 13.8s, GCC 17.9s, Rustc 17.9s.
>>> >>
>>> >> (1.9GHz 3517U, 8 GB, linux. GCC: 4.8.1, Clang: 3.3, rustc: 18e3bcd
>>> >> 2013-09-23 23:46:05 -0700.)
>>> >>
>>> >> I just did essentially a transliteration of the C++ into (reasonably
>>> >> idiomatic) Rust, I imagine one could make it faster with some effort,
>>> >> but that would be cheating (at least, it would then become a test of
>>> >> *my* micro-optimisation ability, rather than that of the compilers).
>>> It
>>> >> appears that clang vectorises/uses SSE directly more eagerly than
>>> either
>>> >> gcc or rustc from some quick poking with perf.
>>> >>
>>> >> (I don't have Go on this computer to compare; although I imagine the
>>> >> only comparison of interest would be with gccgo, since "normal" go
>>> >> doesn't optimise anywhere near as much as LLVM does.)
>>> >>
>>> >> Huon
>>> >> _______________________________________________
>>> >> Rust-dev mailing list
>>> >> Rust-dev at mozilla.org
>>> >> https://mail.mozilla.org/listinfo/rust-dev
>>> >>
>>> >>
>>> > _______________________________________________
>>> > Rust-dev mailing list
>>> > Rust-dev at mozilla.org
>>> > https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/ca27f605/attachment-0001.html>

From sebastian.sylvan at gmail.com  Tue Sep 24 14:11:26 2013
From: sebastian.sylvan at gmail.com (Sebastian Sylvan)
Date: Tue, 24 Sep 2013 14:11:26 -0700
Subject: [rust-dev] RFC: Syntax for "raw" string literals
In-Reply-To: <CAAvrL-mtma5X5M3adXi3_L8CBq5DGb-3P7rYhNsk-1C6fQkq5A@mail.gmail.com>
References: <A82FE9D9-60C0-4FA1-9A42-39F30240DB67@sb.org>
	<CAGZgfT536Da38aab0OUC9V-4_asfxJwWM6_5RsBAkoGNT34HMA@mail.gmail.com>
	<CAAvrL-mtma5X5M3adXi3_L8CBq5DGb-3P7rYhNsk-1C6fQkq5A@mail.gmail.com>
Message-ID: <CAGZgfT5hN-KSE4YyB-Hjm6C2Wu4Lf8Lwt4g_+crurekC4UWsTg@mail.gmail.com>

On Tue, Sep 24, 2013 at 12:44 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> > I think string literals should contain exactly what they contain in
> their source form, without any additional processing. If you want to
> express characters that are inconvenient to type, you can use control
> sequences and a (standard) formatting library to produce them.
>
> I'm actually very intrigued by the idea of eliminating escape characters
> altogether in the default string literals. Would follow nicely from how we
> allow newlines in string literals. We'd have to give up the optional
> "whitespace-chomping" behavior around newlines, though, which would make me
> pretty sad. And are you really willing to force everyone who wants to
> include a quotation mark in a string to go through a syntax extension to do
> it?
>

Yes! It seems to me that many/most string literals are used for in
conjunction with various formatting functions anyway, so I wouldn't think
it would be a big deal in practice. Throwing in a call to fmt isn't a big
burden, imo.


-- 
Sebastian Sylvan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/a6e56d62/attachment.html>

From dbau.pp at gmail.com  Tue Sep 24 14:48:10 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 25 Sep 2013 07:48:10 +1000
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
	<CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
Message-ID: <5242089A.4000403@gmail.com>

On 25/09/13 04:13, Tim Kuehn wrote:
> To make it a "fair" fight, I converted the Go and C++ versions to 
> trace "Rust" instead. These are my results on my Macbook Pro:
>
> === RUST ===
> $ rustc -O bin.rs <http://bin.rs>
> $ time ./bin > rrays.ppm
>
> real0m14.472s
> user0m14.102s
> sys0m0.365s
>
> === GO ===
> $ go build main.go
> $ time ./main > grays.ppm
>
> real0m13.928s
> user0m13.914s
> sys0m0.020s
>
> === C++ ===
> $ gcc -O crays.cpp
> $ time ./a.out > crays.ppm
>
> real0m10.800s
> user0m10.794s
> sys0m0.005s
>
> === RANKINGS ===
> 1) C++ : 10.8s
> 2) Go   : 13.9s
> 3) Rust : 14.5s
>
>

This surprises me a lot (the fact that Go is (1) faster than Rust, (2) 
it's only 20% slower than C++, compared to 150+% originally), so I 
investigated, and found that the Go is "cheating" with an algorithmic 
improvement: 
https://github.com/kid0m4n/gorays/commit/249f229ba8c769c38d7dc018acfdf29cc86d6e43

If it's possible, could we re-run the benchmarks with the commit before 
that?

Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/486fe5f2/attachment.html>

From beza1e1 at web.de  Tue Sep 24 15:03:19 2013
From: beza1e1 at web.de (Andreas Zwinkau)
Date: Wed, 25 Sep 2013 00:03:19 +0200
Subject: [rust-dev] average function
Message-ID: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>

I tried to write an average function, but so far failed to convince
the type checker.

fn average<T:Int>(values:&[T]) -> T {
  let count = values.len();
  let mut sum:T;
  for v in values.iter() {
    sum = sum.add(v);
  }
  return sum / count;
}

error: mismatched types: expected `T` but found `uint` (expected type
parameter but found uint)

The problem is that sum is the generic type T, but count is uint due
to the definition of the len function. Casting "count as T" should
work, i thought, but rustc seems to have another opinion?


-- 
Andreas Zwinkau

work email: zwinkau at kit.edu
private email: qznc at web.de
homepage: http://beza1e1.tuxen.de

From bytbox at gmail.com  Tue Sep 24 15:09:05 2013
From: bytbox at gmail.com (Scott Lawrence)
Date: Tue, 24 Sep 2013 18:09:05 -0400 (EDT)
Subject: [rust-dev] average function
In-Reply-To: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
Message-ID: <alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>

Use NumCast::from(count).

You'll also want to be sure to initialize sum. I'd use the Zero instance.

use std::num::Zero;
fn average<T:Int>(values:&[T]) -> T {
     let count = values.len();
     let mut sum:T = Zero::zero();
     for v in values.iter() {
         sum = sum.add(v);
     }
     return sum / NumCast::from(count);
}
fn main() {
     println(fmt!("%d", average([1,2,3])))
}

On Wed, 25 Sep 2013, Andreas Zwinkau wrote:

> I tried to write an average function, but so far failed to convince
> the type checker.
>
> fn average<T:Int>(values:&[T]) -> T {
>  let count = values.len();
>  let mut sum:T;
>  for v in values.iter() {
>    sum = sum.add(v);
>  }
>  return sum / count;
> }
>
> error: mismatched types: expected `T` but found `uint` (expected type
> parameter but found uint)
>
> The problem is that sum is the generic type T, but count is uint due
> to the definition of the len function. Casting "count as T" should
> work, i thought, but rustc seems to have another opinion?
>
>
> -- 
> Andreas Zwinkau
>
> work email: zwinkau at kit.edu
> private email: qznc at web.de
> homepage: http://beza1e1.tuxen.de
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

-- 
Scott Lawrence

From kevin at sb.org  Tue Sep 24 15:20:57 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 24 Sep 2013 15:20:57 -0700
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <5242089A.4000403@gmail.com>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
	<CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
	<5242089A.4000403@gmail.com>
Message-ID: <1015EEFD-4645-4CB5-8151-13FD2B0DC4FA@sb.org>

I ran them myself. Incidentally, the Rust version is absurdly slow if I don't specify an optimization level. Here's what I got:

Clang (-O3): 7.99s real
Go (improved version): 9.68s real
Go (original version): 16.73s real
Rust (--opt-level=3): 13.03s real

(I ran each case 3 times and took the median)

So if we discard the algorithmically-improved Go, then we get

1) C++: 7.99s
2) Rust: 13.02s
3) Go: 16.73s

I'm curious as to what difference using gccgo would make, but I didn't try (as I don't have GCC).

-Kevin

On Sep 24, 2013, at 2:48 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 25/09/13 04:13, Tim Kuehn wrote:
>> To make it a "fair" fight, I converted the Go and C++ versions to trace "Rust" instead. These are my results on my Macbook Pro:
>> 
>> === RUST ===
>> $ rustc -O bin.rs
>> $ time ./bin > rrays.ppm
>> 
>> real 0m14.472s
>> user 0m14.102s
>> sys 0m0.365s
>> 
>> === GO ===
>> $ go build main.go
>> $ time ./main > grays.ppm
>> 
>> real 0m13.928s
>> user 0m13.914s
>> sys 0m0.020s
>> 
>> === C++ ===
>> $ gcc -O crays.cpp
>> $ time ./a.out > crays.ppm
>> 
>> real 0m10.800s
>> user 0m10.794s
>> sys 0m0.005s
>> 
>> === RANKINGS ===
>> 1) C++ : 10.8s
>> 2) Go   : 13.9s
>> 3) Rust : 14.5s
>> 
>> 
> 
> This surprises me a lot (the fact that Go is (1) faster than Rust, (2) it's only 20% slower than C++, compared to 150+% originally), so I investigated, and found that the Go is "cheating" with an algorithmic improvement: https://github.com/kid0m4n/gorays/commit/249f229ba8c769c38d7dc018acfdf29cc86d6e43
> 
> If it's possible, could we re-run the benchmarks with the commit before that?
> 
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/c16bffd1/attachment-0001.html>

From banderson at mozilla.com  Tue Sep 24 15:49:56 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 24 Sep 2013 15:49:56 -0700
Subject: [rust-dev] New IRC channel for discussion of compiler and standard
 library development, #rust-internals
Message-ID: <52421714.7070803@mozilla.com>

Greetings,

#rust has grown pretty large, regularly over 300 people. This is 
something I'm very happy about, but the discussion there is quite broad. 
We're going to try moving discussion related to engineering the compiler 
itself into #rust-internals.

I'd also like to point out that there is a new channel for game 
programming in Rust, #rust-gamedev.

That is all.

Regards,
Brian

From bjzaba at yahoo.com.au  Tue Sep 24 16:36:39 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Wed, 25 Sep 2013 09:36:39 +1000
Subject: [rust-dev] average function
In-Reply-To: <alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
Message-ID: <6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>

I normally prefer using `std::num::{cast, zero}` as its a tad more readable. So:

    use std::num;

    fn average<T:Int>(values: &[T]) -> T {
        values.iter()
              .fold(num::zero::<T>(), |x, y| x.add(y))
              .div(&num::cast(values.len()))
    }

    fn main() {
       print!("{}", average([1,2,3]))
    }

On 25/09/2013, at 8:09 AM, Scott Lawrence <bytbox at gmail.com> wrote:

> Use NumCast::from(count).
> 
> You'll also want to be sure to initialize sum. I'd use the Zero instance.
> 
> use std::num::Zero;
> fn average<T:Int>(values:&[T]) -> T {
>    let count = values.len();
>    let mut sum:T = Zero::zero();
>    for v in values.iter() {
>        sum = sum.add(v);
>    }
>    return sum / NumCast::from(count);
> }
> fn main() {
>    println(fmt!("%d", average([1,2,3])))
> }
> 
> On Wed, 25 Sep 2013, Andreas Zwinkau wrote:
> 
>> I tried to write an average function, but so far failed to convince
>> the type checker.
>> 
>> fn average<T:Int>(values:&[T]) -> T {
>> let count = values.len();
>> let mut sum:T;
>> for v in values.iter() {
>>   sum = sum.add(v);
>> }
>> return sum / count;
>> }
>> 
>> error: mismatched types: expected `T` but found `uint` (expected type
>> parameter but found uint)
>> 
>> The problem is that sum is the generic type T, but count is uint due
>> to the definition of the len function. Casting "count as T" should
>> work, i thought, but rustc seems to have another opinion?
>> 
>> 
>> -- 
>> Andreas Zwinkau
>> 
>> work email: zwinkau at kit.edu
>> private email: qznc at web.de
>> homepage: http://beza1e1.tuxen.de
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> 
> -- 
> Scott Lawrence
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From tkuehn at cmu.edu  Tue Sep 24 17:37:17 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Tue, 24 Sep 2013 20:37:17 -0400
Subject: [rust-dev] average function
In-Reply-To: <6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
Message-ID: <CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>

There's also std::iter::AdditiveIterator.

fn average<T: Num + NumCast + Clone>(values: &[T]) -> T {
    let sum = values.iter().map(|n| n.clone()).sum();
    sum / num::cast(values.len())
}


On Tue, Sep 24, 2013 at 7:36 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:

> I normally prefer using `std::num::{cast, zero}` as its a tad more
> readable. So:
>
>     use std::num;
>
>     fn average<T:Int>(values: &[T]) -> T {
>         values.iter()
>               .fold(num::zero::<T>(), |x, y| x.add(y))
>               .div(&num::cast(values.len()))
>     }
>
>     fn main() {
>        print!("{}", average([1,2,3]))
>     }
>
> On 25/09/2013, at 8:09 AM, Scott Lawrence <bytbox at gmail.com> wrote:
>
> > Use NumCast::from(count).
> >
> > You'll also want to be sure to initialize sum. I'd use the Zero instance.
> >
> > use std::num::Zero;
> > fn average<T:Int>(values:&[T]) -> T {
> >    let count = values.len();
> >    let mut sum:T = Zero::zero();
> >    for v in values.iter() {
> >        sum = sum.add(v);
> >    }
> >    return sum / NumCast::from(count);
> > }
> > fn main() {
> >    println(fmt!("%d", average([1,2,3])))
> > }
> >
> > On Wed, 25 Sep 2013, Andreas Zwinkau wrote:
> >
> >> I tried to write an average function, but so far failed to convince
> >> the type checker.
> >>
> >> fn average<T:Int>(values:&[T]) -> T {
> >> let count = values.len();
> >> let mut sum:T;
> >> for v in values.iter() {
> >>   sum = sum.add(v);
> >> }
> >> return sum / count;
> >> }
> >>
> >> error: mismatched types: expected `T` but found `uint` (expected type
> >> parameter but found uint)
> >>
> >> The problem is that sum is the generic type T, but count is uint due
> >> to the definition of the len function. Casting "count as T" should
> >> work, i thought, but rustc seems to have another opinion?
> >>
> >>
> >> --
> >> Andreas Zwinkau
> >>
> >> work email: zwinkau at kit.edu
> >> private email: qznc at web.de
> >> homepage: http://beza1e1.tuxen.de
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> >
> > --
> > Scott Lawrence
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/b6a371cf/attachment.html>

From thadguidry at gmail.com  Tue Sep 24 18:01:02 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 24 Sep 2013 20:01:02 -0500
Subject: [rust-dev] Minimal raytracer
In-Reply-To: <1015EEFD-4645-4CB5-8151-13FD2B0DC4FA@sb.org>
References: <52412EC5.30704@proinbox.com> <5241990A.4070203@gmail.com>
	<5241C6F1.40102@proinbox.com>
	<650572A0-BEA5-4009-BB60-9998DDB76233@naml.us>
	<CACVDHKm4qiQLDQxF7-5DHAu-Q3FVk8xZiTWexnJVKRr9PPvhyA@mail.gmail.com>
	<5242089A.4000403@gmail.com>
	<1015EEFD-4645-4CB5-8151-13FD2B0DC4FA@sb.org>
Message-ID: <CAChbWaOh82D5YDR2LjnLzwQy1L9zdh_2PeVyghXwJkOsJzGDfw@mail.gmail.com>

You think Rust (or any of them) is slow ?  Try raytracing by hand. :)


On Tue, Sep 24, 2013 at 5:20 PM, Kevin Ballard <kevin at sb.org> wrote:

> I ran them myself. Incidentally, the Rust version is absurdly slow if I
> don't specify an optimization level. Here's what I got:
>
> Clang (-O3): 7.99s real
> Go (improved version): 9.68s real
> Go (original version): 16.73s real
> Rust (--opt-level=3): 13.03s real
>
> (I ran each case 3 times and took the median)
>
> So if we discard the algorithmically-improved Go, then we get
>
> 1) C++: 7.99s
> 2) Rust: 13.02s
> 3) Go: 16.73s
>
> I'm curious as to what difference using gccgo would make, but I didn't try
> (as I don't have GCC).
>
> -Kevin
>
> On Sep 24, 2013, at 2:48 PM, Huon Wilson <dbau.pp at gmail.com> wrote:
>
>  On 25/09/13 04:13, Tim Kuehn wrote:
>
> To make it a "fair" fight, I converted the Go and C++ versions to trace
> "Rust" instead. These are my results on my Macbook Pro:
>
> === RUST ===
>  $ rustc -O bin.rs
> $ time ./bin > rrays.ppm
>
>  real 0m14.472s
> user 0m14.102s
> sys 0m0.365s
>
>  === GO ===
>  $ go build main.go
> $ time ./main > grays.ppm
>
>  real 0m13.928s
> user 0m13.914s
> sys 0m0.020s
>
>  === C++ ===
>  $ gcc -O crays.cpp
> $ time ./a.out > crays.ppm
>
>  real 0m10.800s
> user 0m10.794s
> sys 0m0.005s
>
>  === RANKINGS ===
> 1) C++ : 10.8s
>  2) Go   : 13.9s
> 3) Rust : 14.5s
>
>
>
> This surprises me a lot (the fact that Go is (1) faster than Rust, (2)
> it's only 20% slower than C++, compared to 150+% originally), so I
> investigated, and found that the Go is "cheating" with an algorithmic
> improvement:
> https://github.com/kid0m4n/gorays/commit/249f229ba8c769c38d7dc018acfdf29cc86d6e43
>
> If it's possible, could we re-run the benchmarks with the commit before
> that?
>
> Huon
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/8a6da250/attachment.html>

From danielmicay at gmail.com  Tue Sep 24 18:19:53 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Sep 2013 21:19:53 -0400
Subject: [rust-dev] average function
In-Reply-To: <CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
Message-ID: <CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>

On Tue, Sep 24, 2013 at 8:37 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:

> There's also std::iter::AdditiveIterator.
>
> fn average<T: Num + NumCast + Clone>(values: &[T]) -> T {
>     let sum = values.iter().map(|n| n.clone()).sum();
>     sum / num::cast(values.len())
> }
>

Using `iter().fold(Zero::zero(), |a, b| a + *b)` would be a lot more
efficient for big integers. I'm not sure if we should really have the
`sum`, `product`, `max` and `min` methods.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/20c0f2ec/attachment-0001.html>

From kevin at sb.org  Tue Sep 24 18:50:05 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 24 Sep 2013 18:50:05 -0700
Subject: [rust-dev] average function
In-Reply-To: <CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
Message-ID: <271332ED-17BD-49E3-B507-35055D54592E@sb.org>

Maybe we should just implement AdditiveIterator on &A as well? That way you can just say `values.iter().sum()`.

-Kevin

On Sep 24, 2013, at 6:19 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Sep 24, 2013 at 8:37 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
> There's also std::iter::AdditiveIterator.
> 
> fn average<T: Num + NumCast + Clone>(values: &[T]) -> T {
>     let sum = values.iter().map(|n| n.clone()).sum();
>     sum / num::cast(values.len())
> }
> 
> Using `iter().fold(Zero::zero(), |a, b| a + *b)` would be a lot more efficient for big integers. I'm not sure if we should really have the `sum`, `product`, `max` and `min` methods.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/32cfd79d/attachment.html>

From danielmicay at gmail.com  Tue Sep 24 18:54:29 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Sep 2013 21:54:29 -0400
Subject: [rust-dev] average function
In-Reply-To: <271332ED-17BD-49E3-B507-35055D54592E@sb.org>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
Message-ID: <CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>

On Tue, Sep 24, 2013 at 9:50 PM, Kevin Ballard <kevin at sb.org> wrote:

> Maybe we should just implement AdditiveIterator on &A as well? That way
> you can just say `values.iter().sum()`.
>
> -Kevin
>
> On Sep 24, 2013, at 6:19 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> On Tue, Sep 24, 2013 at 8:37 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>
>> There's also std::iter::AdditiveIterator.
>>
>> fn average<T: Num + NumCast + Clone>(values: &[T]) -> T {
>>     let sum = values.iter().map(|n| n.clone()).sum();
>>     sum / num::cast(values.len())
>> }
>>
>
> Using `iter().fold(Zero::zero(), |a, b| a + *b)` would be a lot more
> efficient for big integers. I'm not sure if we should really have the
> `sum`, `product`, `max` and `min` methods.
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
It won't easily work, because it expects `Add<T, T>` meaning `+` has to
return the same type as it receives.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130924/0c30d6d7/attachment.html>

From dwrenshaw at gmail.com  Tue Sep 24 18:56:07 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Tue, 24 Sep 2013 21:56:07 -0400
Subject: [rust-dev] 'self in static trait methods (issue 7331)
Message-ID: <CABR6rW9D9OOfKzYxc7ROT=Z=hJYwEEpbn=s7cCoS-G6ACf47bw@mail.gmail.com>

Hello,

I have been thinking about how to fix issue 7331
(https://github.com/mozilla/rust/issues/7331), because I think that
something like the `Constructable` trait is going to be important for
capnproto-rust (https://github.com/dwrensha/capnproto-rust).

I've managed to find a one-line change that prevents the ICE:

index 3f5e1ef..399a769 100644
--- a/src/librustc/middle/typeck/collect.rs
+++ b/src/librustc/middle/typeck/collect.rs
@@ -312,7 +312,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,
         //     Self => D'
         //     D,E,F => E',F',G'
         let substs = substs {
-            regions: ty::NonerasedRegions(opt_vec::Empty),
+            regions:
ty::NonerasedRegions(opt_vec::with(ty::re_bound(ty::br_self))),
             self_ty: Some(self_param),
             tps: non_shifted_trait_tps + shifted_method_tps
         };

However, if I try to use the `Constructable` trait that I can now
define, I run into borrow check errors, as shown in the example below.

--------------------

trait Constructable<'self> {
    fn construct(&'self [u8]) -> Self;
}

struct Reader<'self> {
    v : &'self [u8]
}

impl <'self> Constructable<'self> for Reader<'self> {
    fn construct(v : &'self [u8]) -> Reader<'self> {
        Reader { v : v }
    }
}


// This works fine.
impl <'self> Reader<'self> {
    fn get1(&self) -> Reader<'self> {
        Constructable::construct(self.v)
    }
}


// This gives a borrow check error:
/*
test.rs:19:8: 19:32 error: cannot infer an appropriate lifetime due to
conflicting requirements
test.rs:19         Constructable::construct(self.v)
                   ^~~~~~~~~~~~~~~~~~~~~~~~
note: first, the lifetime must be contained by lifetime re_bound(br_self)...
test.rs:19:8: 19:32 note: ...due to the following expression
test.rs:19         Constructable::construct(self.v)
                   ^~~~~~~~~~~~~~~~~~~~~~~~
test.rs:19:33: 19:39 note: but, the lifetime must also be contained by
the expression at 19:33...
test.rs:19         Constructable::construct(self.v)
                                            ^~~~~~
test.rs:19:33: 19:39 note: ...due to the following expression
test.rs:19         Constructable::construct(self.v)
*/
impl <'self, T : Constructable<'self>> Reader<'self> {
    fn get2(&self) -> T {
        Constructable::construct(self.v)
    }
}

fn main() { }

-------------------

Can anyone help me out here? Am I doing something wrong in my example?
Is my fix wrong? Is something wrong elsewhere in typechecking?

Thanks,
David

From daetalusun at gmail.com  Wed Sep 25 06:32:03 2013
From: daetalusun at gmail.com (Alexander Sun)
Date: Wed, 25 Sep 2013 21:32:03 +0800
Subject: [rust-dev] Some suggestions of Rust language
Message-ID: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>

I am not a language developer, just an user. I like Rust, so could I
please to give some suggestions about improve Rust?

Recently, I try to use Rust to build a GUI library prototype. Just
like wxWidget or SWT, wrap the native API(win32 and gtk+, cocoa in
plan if possible). At the meantime, I am writing a Rust tutorial.
During the developing and writing, I got a some questions.

We all(at least I) hope Rust could get wildly use. I think readability
and learnability take emphatically considered. Rust does these well,
and could do better.

Here are my suggestions about Rust(based on 0.7). Note: Just a user
opinions, not a developer perspective. Forgive me if I was wrong.

Ownership, Owned Box, Managed Box
What about hide the ownership, owned box, managed box to users? Just a
borrowed pointer and a dereferencing pointer, like Go.

Slice?
Provide first class support of array, slice(not borrowed pointer to
vector). And support slice operation, like a[0:5].

Loop
Simplify the for loop:
Hide the complexity of iterator, use "for x in xx", like Python(I
think I saw it in 0.8 Manual).
for int:range(0, 10), for uint:range(0, 10), ... to "for range(0, 10)"
for int:range_step(0,10,2) are the same.

Improve the function declare:
fn foo(x : int, y : int, z: int) to fn foo(x, y, z: int)

And could make the expression valid?
(index = count % 2) == 0, Just like the meaning in C++. Currently
(index = count % 2) == () is valid, but it make no sense.

Multiple return values
if has a function like this:

fn addsub(x : int, y : int) -> (int, int) {
	return (x+y,x-y);
}

them, this is valid:

let (b,c) = addsub(x, y);

but this is invalid;

let b:int =0;
let c:int =0;
(b,c) = addsub(x, y);

also invalid:

let (b,c)  = (0, 0);
(b,c) = addsub(x, y);
	
Module: code module and file module?
I call module declare with mod keyword is "code module", and call rust
source file is "file module".
import a code module in other code module in same source file, we
should use keyword "use", but if we want to import file module, we
need to use keyword "mod". I know mod xxx means find xxx.rs, But could
we unify it?

According the official "Rust tutorial", a mod member is private by
default. But it seems that we can access submod in a accessible mod
directly.

Embedded anonymous structure?
Embedded anonymous structure in Go is good idea, I think.

And at last: could support default parameter in function/method?

English is not my native language, so sorry for the grammar mistake.

Best Regards
Sun

From pwalton at mozilla.com  Wed Sep 25 08:29:17 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Wed, 25 Sep 2013 08:29:17 -0700
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
Message-ID: <5243014D.6030709@mozilla.com>

On 9/25/13 6:32 AM, Alexander Sun wrote:
> Ownership, Owned Box, Managed Box
> What about hide the ownership, owned box, managed box to users? Just a
> borrowed pointer and a dereferencing pointer, like Go.

This is contrary to the design goals of Rust. Go is a fully garbage 
collected language and provides neither optional GC nor explicit control 
over allocation on the heap or stack, both of which are important Rust 
features.

> Slice?
> Provide first class support of array, slice(not borrowed pointer to
> vector). And support slice operation, like a[0:5].

How is a slice different from a borrowed pointer to a vector? Note that 
you can take a borrowed pointer to a subrange of a vector.

>
> Loop
> Simplify the for loop:
> Hide the complexity of iterator, use "for x in xx", like Python(I
> think I saw it in 0.8 Manual).
> for int:range(0, 10), for uint:range(0, 10), ... to "for range(0, 10)"
> for int:range_step(0,10,2) are the same.

This was on the roadmap at least at one point, but I'm not sure it works 
due to some issues regarding method lookup. strcat knows more.

>
> Improve the function declare:
> fn foo(x : int, y : int, z: int) to fn foo(x, y, z: int)

This would be somewhat ad-hoc when we move to arbitrary type ascription 
in patterns (e.g. `fn foo(MyStruct { x: int, y: int }) { ... }`).

> And could make the expression valid?
> (index = count % 2) == 0, Just like the meaning in C++. Currently
> (index = count % 2) == () is valid, but it make no sense.

This would conflict with the warn-unused-result warning I would like to 
add, and would also cause a lot of spurious type errors in match arms.

>
> Multiple return values
> if has a function like this:
>
> fn addsub(x : int, y : int) -> (int, int) {
> 	return (x+y,x-y);
> }
>
> them, this is valid:
>
> let (b,c) = addsub(x, y);
>
> but this is invalid;
>
> let b:int =0;
> let c:int =0;
> (b,c) = addsub(x, y);
>
> also invalid:
>
> let (b,c)  = (0, 0);
> (b,c) = addsub(x, y);

If we did this, we wouldn't know whether to parse a pattern or an 
expression when starting a statement. This isn't fixable without trying 
to define some sort of cover grammar that covers both expressions and 
patterns, like ECMAScript 6 does. I don't know if this would work in Rust.

> Embedded anonymous structure?
> Embedded anonymous structure in Go is good idea, I think.

Not the way Go does it, where you can have method conflicts like C++ 
multiple inheritance and it can be surprising which method gets called 
when two anonymous fields have a method with the same name. I'm not 
necessarily opposed to anonymous fields, but we should tread carefully.

> And at last: could support default parameter in function/method?

This has been discussed and the consensus, at least for now, is that 
statics plus functional record update syntax is enough.

> English is not my native language, so sorry for the grammar mistake.

No problem, thanks for your input!

Patrick


From masklinn at masklinn.net  Wed Sep 25 08:50:14 2013
From: masklinn at masklinn.net (Masklinn)
Date: Wed, 25 Sep 2013 17:50:14 +0200
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <5243014D.6030709@mozilla.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com>
Message-ID: <37E2BDC5-C826-44B8-88E6-7FF407D6DE69@masklinn.net>

On 2013-09-25, at 17:29 , Patrick Walton wrote:
> 
>> Multiple return values
>> if has a function like this:
>> 
>> fn addsub(x : int, y : int) -> (int, int) {
>> 	return (x+y,x-y);
>> }
>> 
>> them, this is valid:
>> 
>> let (b,c) = addsub(x, y);
>> 
>> but this is invalid;
>> 
>> let b:int =0;
>> let c:int =0;
>> (b,c) = addsub(x, y);
>> 
>> also invalid:
>> 
>> let (b,c)  = (0, 0);
>> (b,c) = addsub(x, y);
> 
> If we did this, we wouldn't know whether to parse a pattern or an
> expression when starting a statement. This isn't fixable without trying
> to define some sort of cover grammar that covers both expressions and
> patterns, like ECMAScript 6 does. I don't know if this would work in
> Rust.

There seems to be a bug somewhere though, ignoring that the bindings are
not mut in the example (making them immutable unless that's changed
recently) the compiler freaks out quite a bit:

test.rs:8:4: 8:10 error: internal compiler error: trans_lvalue reached
fall-through case: expr_tup(~[@{id: 38, node: expr_path(@{span: {lo:
{__field__: 121}, hi: {__field__: 122}, expn_info: None}, global: false,
idents: ~[{name: 70, ctxt: 0}], rp: None, types: ~[]}), span: {lo:
{__field__: 121}, hi: {__field__: 122}, expn_info: None}}, @{id: 39,
node: expr_path(@{span: {lo: {__field__: 124}, hi: {__field__: 125},
expn_info: None}, global: false, idents: ~[{name: 71, ctxt: 0}], rp:
None, types: ~[]}), span: {lo: {__field__: 124}, hi: {__field__: 125},
expn_info: None}}])
test.rs:8 (b, c) = addsub(1, 2);


From j.e.aten at gmail.com  Wed Sep 25 09:06:36 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Wed, 25 Sep 2013 09:06:36 -0700
Subject: [rust-dev] Some suggestions of Rust language
Message-ID: <CAPNEFAbhXSEu8UPxc3uiW+o0DQYU_Jfv1nXADB656VVA1LXmyQ@mail.gmail.com>

On Wed, Sep 25, 2013 at 8:29 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Slice?
>> Provide first class support of array, slice(not borrowed pointer to
>> vector). And support slice operation, like a[0:5].
>>
>
> How is a slice different from a borrowed pointer to a vector? Note that
> you can take a borrowed pointer to a subrange of a vector.



And at last: could support default parameter in function/method?

>
> This has been discussed and the consensus, at least for now, is that
> statics plus functional record update syntax is enough.


Hi Patrick,

could you give examples of how the slicing (with borrowed pointer to a
vector) and the default parameter usage would/will look like in actual use?

Thanks!

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/549b147a/attachment.html>

From lists at dhardy.name  Wed Sep 25 09:37:50 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Wed, 25 Sep 2013 18:37:50 +0200
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <5243014D.6030709@mozilla.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com>
Message-ID: <1672711.OWuYzK0Q0I@tph-l10036>

Hi,

On Wednesday 25 September 2013 08:29:17 Patrick Walton wrote:
> On 9/25/13 6:32 AM, Alexander Sun wrote:
> > Multiple return values
> > if has a function like this:
> > 
> > fn addsub(x : int, y : int) -> (int, int) {
> > 
> > 	return (x+y,x-y);
> > 
> > }
> > 
> > them, this is valid:
> > 
> > let (b,c) = addsub(x, y);
> > 
> > but this is invalid;
> > 
> > let b:int =0;
> > let c:int =0;
> > (b,c) = addsub(x, y);
> > 
> > also invalid:
> > 
> > let (b,c)  = (0, 0);
> > (b,c) = addsub(x, y);
> 
> If we did this, we wouldn't know whether to parse a pattern or an
> expression when starting a statement. This isn't fixable without trying
> to define some sort of cover grammar that covers both expressions and
> patterns, like ECMAScript 6 does. I don't know if this would work in Rust.

Are there any plans to support something like:

assign (b,c) = addsub(x,y);

for existing b,c? The best I could come up with is:

    match two_nums(2) {
        (x,y) => {a=x;b=y;}
    }

Not that I need this; just curious.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/4e3c6e8b/attachment.sig>

From loebel.marvin at gmail.com  Wed Sep 25 11:40:49 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Wed, 25 Sep 2013 20:40:49 +0200
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
Message-ID: <52432E31.6040301@gmail.com>

We don't use the symbol in our syntax, but are using functional paradigm 
that sometimes result in a bit hard to read nested calls.

I'd propose that it works similar to `do`, in that it allows to move the 
last expression of an function or method call after the parentheses, 
though they would still remain required for ambiguity reasons:

~~~
    a(b(c(1,d(2,3,4,e()))))
== a() $ b() $ c(1) $ d(2,3,4) $ e()

let v: ~[uint] = from_iter() $ range(0, 100);
~~~

In that sense, it wouldn't really be an operator but syntactic sugar for 
a function call.
It might even be possible to replace `do` with it, though the now 
required parentheses would make it longer:

~~~
do task::spawn { ... }
task::spawn() $ || { ... }
~~~

Downside is of course that it adds another symbol, which could alienate 
more potentiall users, and it could mean a shift-away-from or at least 
an inconsistency-with methods and method chaining in general.

Which would be ironic because I wanted it in some complicated Iterator 
chain. ;)

It could of course always be implemented as a syntax extension, and in 
any case I don't expect this to get any attention before Rust 2.0. :)

From oren at ben-kiki.org  Wed Sep 25 09:42:34 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 25 Sep 2013 19:42:34 +0300
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <5243014D.6030709@mozilla.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com>
Message-ID: <CADJiDhthwh=z5MyA8D2n=X0=dyGEmWg7scmMQmigDBMFdpx7gg@mail.gmail.com>

On Wed, Sep 25, 2013 at 6:29 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> On 9/25/13 6:32 AM, Alexander Sun wrote:
>
>> Embedded anonymous structure?
>>
> Embedded anonymous structure in Go is good idea, I think.
>>
>
> Not the way Go does it, where you can have method conflicts like C++
> multiple inheritance and it can be surprising which method gets called when
> two anonymous fields have a method with the same name. I'm not necessarily
> opposed to anonymous fields, but we should tread carefully.


Can you say a bit more about that? I thought if two anonymous fields
supported a method than it was a conflict and one had to refer to it with
the specific field type (foo.TypeOfFirstField.method or
foo.TypeOfSecondField.method as opposed to foo.method - the latter would be
an error). This sounds pretty reasonable...

Since Rust has no implicit traits anywhere, it seems reasonable to require
an explicit impl Trait for Container, but allow omitting functions that are
obtained from anonymous field(s) - unless one wants to override them, or
when they are in conflict between more than one such field. This ensures
all type checking is done at declaration rather than in code that uses the
traits.

It sounds like something along these lines could work in Rust, and it would
be very useful...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/00e419a6/attachment.html>

From andres.osinski at gmail.com  Wed Sep 25 09:48:50 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Wed, 25 Sep 2013 13:48:50 -0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <CA+xF-Pwq5Rygt47pFxadxvxnDZZepBL+Uxu8bfThgPwEmaFDww@mail.gmail.com>

As a potential user of the language I've been toying with using combinators
to make compile-time checked DSLs, and this would be enourmously useful.

Rust is still lacking a few features for my proposed use case (varargs
and/or kwargs would be fantastic, but I'm already well aware that those are
post-1.0 requests).

However, I disagree with the idea that it would alienate users. Function
composition is useful but not as critical as in a language like Haskell,
and aside from the admittedly difficult memory management concepts Rust
introduces, it is a very clean and easy-to-understand language, and has far
fewer caveats than both C and C++ (at least so far), and much less
complexity than academic functional languages.


On Wed, Sep 25, 2013 at 3:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
>
> I'd propose that it works similar to `do`, in that it allows to move the
> last expression of an function or method call after the parentheses, though
> they would still remain required for ambiguity reasons:
>
> ~~~
>    a(b(c(1,d(2,3,4,e()))))
> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
> let v: ~[uint] = from_iter() $ range(0, 100);
> ~~~
>
> In that sense, it wouldn't really be an operator but syntactic sugar for a
> function call.
> It might even be possible to replace `do` with it, though the now required
> parentheses would make it longer:
>
> ~~~
> do task::spawn { ... }
> task::spawn() $ || { ... }
> ~~~
>
> Downside is of course that it adds another symbol, which could alienate
> more potentiall users, and it could mean a shift-away-from or at least an
> inconsistency-with methods and method chaining in general.
>
> Which would be ironic because I wanted it in some complicated Iterator
> chain. ;)
>
> It could of course always be implemented as a syntax extension, and in any
> case I don't expect this to get any attention before Rust 2.0. :)
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>



-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/6720a90d/attachment.html>

From oren at ben-kiki.org  Wed Sep 25 09:50:15 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 25 Sep 2013 19:50:15 +0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <CADJiDhtp0tsPHXbYkXyf2bMCeunoQ-h17AdPpjjBoHQsiY2Fwg@mail.gmail.com>

Not sure about $ but I sometimes miss the |> operator (which takes the
value from the left and inserts it as the 1st argument of the function call
to the right).

foo(a, b) |> bar(c, d) |> baz(e, f)
== baz(bar(foo(a, b), c, d), e, f)

This allows for easier "functional" decompsition of chains of operations. I
found it to be very useful when writing Elixir; in Rust there's the OO-like
traits which may make it less useful - it still might be worthwhile for
people writing more functional code.


On Wed, Sep 25, 2013 at 9:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
>
> I'd propose that it works similar to `do`, in that it allows to move the
> last expression of an function or method call after the parentheses, though
> they would still remain required for ambiguity reasons:
>
> ~~~
>    a(b(c(1,d(2,3,4,e()))))
> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
> let v: ~[uint] = from_iter() $ range(0, 100);
> ~~~
>
> In that sense, it wouldn't really be an operator but syntactic sugar for a
> function call.
> It might even be possible to replace `do` with it, though the now required
> parentheses would make it longer:
>
> ~~~
> do task::spawn { ... }
> task::spawn() $ || { ... }
> ~~~
>
> Downside is of course that it adds another symbol, which could alienate
> more potentiall users, and it could mean a shift-away-from or at least an
> inconsistency-with methods and method chaining in general.
>
> Which would be ironic because I wanted it in some complicated Iterator
> chain. ;)
>
> It could of course always be implemented as a syntax extension, and in any
> case I don't expect this to get any attention before Rust 2.0. :)
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/859d2d27/attachment-0001.html>

From oren at ben-kiki.org  Wed Sep 25 09:50:17 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 25 Sep 2013 19:50:17 +0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <CADJiDhs+cOPcLW+w8OwNu51FKBJCG2Z5C0YokAfddkscneJaGw@mail.gmail.com>

Not sure about $ but I sometimes miss the |> operator (which takes the
value from the left and inserts it as the 1st argument of the function call
to the right).

foo(a, b) |> bar(c, d) |> baz(e, f)
== baz(bar(foo(a, b), c, d), e, f)

This allows for easier "functional" decompsition of chains of operations. I
found it to be very useful when writing Elixir; in Rust there's the OO-like
traits which may make it less useful - it still might be worthwhile for
people writing more functional code.


On Wed, Sep 25, 2013 at 9:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
>
> I'd propose that it works similar to `do`, in that it allows to move the
> last expression of an function or method call after the parentheses, though
> they would still remain required for ambiguity reasons:
>
> ~~~
>    a(b(c(1,d(2,3,4,e()))))
> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
> let v: ~[uint] = from_iter() $ range(0, 100);
> ~~~
>
> In that sense, it wouldn't really be an operator but syntactic sugar for a
> function call.
> It might even be possible to replace `do` with it, though the now required
> parentheses would make it longer:
>
> ~~~
> do task::spawn { ... }
> task::spawn() $ || { ... }
> ~~~
>
> Downside is of course that it adds another symbol, which could alienate
> more potentiall users, and it could mean a shift-away-from or at least an
> inconsistency-with methods and method chaining in general.
>
> Which would be ironic because I wanted it in some complicated Iterator
> chain. ;)
>
> It could of course always be implemented as a syntax extension, and in any
> case I don't expect this to get any attention before Rust 2.0. :)
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/9a8ea97d/attachment.html>

From loebel.marvin at gmail.com  Wed Sep 25 11:50:37 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Wed, 25 Sep 2013 20:50:37 +0200
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <1672711.OWuYzK0Q0I@tph-l10036>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>	<5243014D.6030709@mozilla.com>
	<1672711.OWuYzK0Q0I@tph-l10036>
Message-ID: <5243307D.4030402@gmail.com>

On 09/25/2013 06:37 PM, Diggory Hardy wrote:
> Hi,
>
> On Wednesday 25 September 2013 08:29:17 Patrick Walton wrote:
>> On 9/25/13 6:32 AM, Alexander Sun wrote:
>>> Multiple return values
>>> if has a function like this:
>>>
>>> fn addsub(x : int, y : int) -> (int, int) {
>>>
>>> 	return (x+y,x-y);
>>>
>>> }
>>>
>>> them, this is valid:
>>>
>>> let (b,c) = addsub(x, y);
>>>
>>> but this is invalid;
>>>
>>> let b:int =0;
>>> let c:int =0;
>>> (b,c) = addsub(x, y);
>>>
>>> also invalid:
>>>
>>> let (b,c)  = (0, 0);
>>> (b,c) = addsub(x, y);
>> If we did this, we wouldn't know whether to parse a pattern or an
>> expression when starting a statement. This isn't fixable without trying
>> to define some sort of cover grammar that covers both expressions and
>> patterns, like ECMAScript 6 does. I don't know if this would work in Rust.
> Are there any plans to support something like:
>
> assign (b,c) = addsub(x,y);
>
> for existing b,c? The best I could come up with is:
>
>      match two_nums(2) {
>          (x,y) => {a=x;b=y;}
>      }
>
> Not that I need this; just curious.
I had the idea once to reuse the `in` keyword for that:

let mut a = 0; let mut b = 1;
in (a, b) = (b, a);

No idea how feasible that would be, though.

From oren at ben-kiki.org  Wed Sep 25 09:52:05 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 25 Sep 2013 19:52:05 +0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <CADJiDhs74Y7NDL7UMNA=qrdWWTOk7fuxbzR95vt_iPZjnQKikA@mail.gmail.com>

Not sure about $ but I sometimes miss the |> operator (which takes the
value from the left and inserts it as the 1st argument of the function call
to the right).

foo(a, b) |> bar(c, d) |> baz(e, f)
== baz(bar(foo(a, b), c, d), e, f)

This allows for easier "functional" decompsition of chains of operations.
I'm not certain it is as useful in an "OO-like" language like Rust - I cer


On Wed, Sep 25, 2013 at 9:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
>
> I'd propose that it works similar to `do`, in that it allows to move the
> last expression of an function or method call after the parentheses, though
> they would still remain required for ambiguity reasons:
>
> ~~~
>    a(b(c(1,d(2,3,4,e()))))
> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
> let v: ~[uint] = from_iter() $ range(0, 100);
> ~~~
>
> In that sense, it wouldn't really be an operator but syntactic sugar for a
> function call.
> It might even be possible to replace `do` with it, though the now required
> parentheses would make it longer:
>
> ~~~
> do task::spawn { ... }
> task::spawn() $ || { ... }
> ~~~
>
> Downside is of course that it adds another symbol, which could alienate
> more potentiall users, and it could mean a shift-away-from or at least an
> inconsistency-with methods and method chaining in general.
>
> Which would be ironic because I wanted it in some complicated Iterator
> chain. ;)
>
> It could of course always be implemented as a syntax extension, and in any
> case I don't expect this to get any attention before Rust 2.0. :)
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/6a195a7f/attachment.html>

From andres.osinski at gmail.com  Wed Sep 25 09:53:36 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Wed, 25 Sep 2013 13:53:36 -0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <CADJiDhs+cOPcLW+w8OwNu51FKBJCG2Z5C0YokAfddkscneJaGw@mail.gmail.com>
References: <52432E31.6040301@gmail.com>
	<CADJiDhs+cOPcLW+w8OwNu51FKBJCG2Z5C0YokAfddkscneJaGw@mail.gmail.com>
Message-ID: <CA+xF-PxppLLGiV16+DDEFPfYohEcS4p5un=s+JRbZLmT7DsOrA@mail.gmail.com>

What is the possibility that Rust allow certain traits for operators such
as these to be implemented as libraries?

I can certainly see the benefits of stuff like that, although I don't think
it might be a good idea to depend on such operators (I *love* overloaded
operators in linear algebra and combinators, but they are questionable
outside of specific niches, thus their introduction as traits would
probably be best)


On Wed, Sep 25, 2013 at 1:50 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Not sure about $ but I sometimes miss the |> operator (which takes the
> value from the left and inserts it as the 1st argument of the function call
> to the right).
>
> foo(a, b) |> bar(c, d) |> baz(e, f)
> == baz(bar(foo(a, b), c, d), e, f)
>
> This allows for easier "functional" decompsition of chains of operations.
> I found it to be very useful when writing Elixir; in Rust there's the
> OO-like traits which may make it less useful - it still might be worthwhile
> for people writing more functional code.
>
>
> On Wed, Sep 25, 2013 at 9:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:
>
>> We don't use the symbol in our syntax, but are using functional paradigm
>> that sometimes result in a bit hard to read nested calls.
>>
>> I'd propose that it works similar to `do`, in that it allows to move the
>> last expression of an function or method call after the parentheses, though
>> they would still remain required for ambiguity reasons:
>>
>> ~~~
>>    a(b(c(1,d(2,3,4,e()))))
>> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>>
>> let v: ~[uint] = from_iter() $ range(0, 100);
>> ~~~
>>
>> In that sense, it wouldn't really be an operator but syntactic sugar for
>> a function call.
>> It might even be possible to replace `do` with it, though the now
>> required parentheses would make it longer:
>>
>> ~~~
>> do task::spawn { ... }
>> task::spawn() $ || { ... }
>> ~~~
>>
>> Downside is of course that it adds another symbol, which could alienate
>> more potentiall users, and it could mean a shift-away-from or at least an
>> inconsistency-with methods and method chaining in general.
>>
>> Which would be ironic because I wanted it in some complicated Iterator
>> chain. ;)
>>
>> It could of course always be implemented as a syntax extension, and in
>> any case I don't expect this to get any attention before Rust 2.0. :)
>> ______________________________**_________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/cde7ae16/attachment.html>

From kenz.gelsoft at gmail.com  Wed Sep 25 10:49:59 2013
From: kenz.gelsoft at gmail.com (KENZ gelsoft)
Date: Thu, 26 Sep 2013 02:49:59 +0900
Subject: [rust-dev] Introducing wxRust
Message-ID: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>

Hello, everyone.

I would like to introduce my experimental project, wxRust.
Which is a wxWidgets binding for Rust.

  https://github.com/kenz-gelsoft/wxRust

This binding is based on the wxHaskell especially its "wxc"*1
C-Language wxWidgets binding part.

Currently, it just converts wxc's header file to `extern fn`s and
export them as a rust library.

Test program has just started working which opens a wxFrame
by calling wxc's C interface from extern fn.

Current state is pre-alpha experimental state, there's no stable API,
hard to use, but announced here for someone planning similar project.

I'm planning for next generating simple OOP style wrapper as rust
traits for each classes from wxc's header.

There is many problems to tackle, for example how it can work
with multitask or, library users can write wx GUI programs easier.
Any helps or feedbacks are welcome.

 *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]


Thanks,
--
KENZ <KENZ.gelsoft at gmail.com>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/8d249d74/attachment-0001.html>

From ben.striegel at gmail.com  Wed Sep 25 11:29:12 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 25 Sep 2013 14:29:12 -0400
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <5243307D.4030402@gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
Message-ID: <CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>

Is there a use case that necessitates such a feature? The following code
works today:

    let a = 1;
    let b = 2;
    let (a, b) = (b, a);

Not sure why that wouldn't be sufficient.


On Wed, Sep 25, 2013 at 2:50 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> On 09/25/2013 06:37 PM, Diggory Hardy wrote:
>
>> Hi,
>>
>> On Wednesday 25 September 2013 08:29:17 Patrick Walton wrote:
>>
>>> On 9/25/13 6:32 AM, Alexander Sun wrote:
>>>
>>>> Multiple return values
>>>> if has a function like this:
>>>>
>>>> fn addsub(x : int, y : int) -> (int, int) {
>>>>
>>>>         return (x+y,x-y);
>>>>
>>>> }
>>>>
>>>> them, this is valid:
>>>>
>>>> let (b,c) = addsub(x, y);
>>>>
>>>> but this is invalid;
>>>>
>>>> let b:int =0;
>>>> let c:int =0;
>>>> (b,c) = addsub(x, y);
>>>>
>>>> also invalid:
>>>>
>>>> let (b,c)  = (0, 0);
>>>> (b,c) = addsub(x, y);
>>>>
>>> If we did this, we wouldn't know whether to parse a pattern or an
>>> expression when starting a statement. This isn't fixable without trying
>>> to define some sort of cover grammar that covers both expressions and
>>> patterns, like ECMAScript 6 does. I don't know if this would work in
>>> Rust.
>>>
>> Are there any plans to support something like:
>>
>> assign (b,c) = addsub(x,y);
>>
>> for existing b,c? The best I could come up with is:
>>
>>      match two_nums(2) {
>>          (x,y) => {a=x;b=y;}
>>      }
>>
>> Not that I need this; just curious.
>>
> I had the idea once to reuse the `in` keyword for that:
>
> let mut a = 0; let mut b = 1;
> in (a, b) = (b, a);
>
> No idea how feasible that would be, though.
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/3073f89b/attachment.html>

From ben.striegel at gmail.com  Wed Sep 25 11:33:27 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 25 Sep 2013 14:33:27 -0400
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <CAAvrL-nbeMEGtZUtmptd14uOtLSuS5YLDw8kOip_7Z6QQ5gTpA@mail.gmail.com>

Note that we reserve the dollar sign ($) for use in macros, so it wouldn't
be able to appear in regular Rust code without some sort of escaping
mechanism. I also don't see anything like this happening before Rust 2.0 at
the earliest.


On Wed, Sep 25, 2013 at 2:40 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
>
> I'd propose that it works similar to `do`, in that it allows to move the
> last expression of an function or method call after the parentheses, though
> they would still remain required for ambiguity reasons:
>
> ~~~
>    a(b(c(1,d(2,3,4,e()))))
> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
> let v: ~[uint] = from_iter() $ range(0, 100);
> ~~~
>
> In that sense, it wouldn't really be an operator but syntactic sugar for a
> function call.
> It might even be possible to replace `do` with it, though the now required
> parentheses would make it longer:
>
> ~~~
> do task::spawn { ... }
> task::spawn() $ || { ... }
> ~~~
>
> Downside is of course that it adds another symbol, which could alienate
> more potentiall users, and it could mean a shift-away-from or at least an
> inconsistency-with methods and method chaining in general.
>
> Which would be ironic because I wanted it in some complicated Iterator
> chain. ;)
>
> It could of course always be implemented as a syntax extension, and in any
> case I don't expect this to get any attention before Rust 2.0. :)
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/c3b2a360/attachment.html>

From mozilla at mcpherrin.ca  Wed Sep 25 12:10:29 2013
From: mozilla at mcpherrin.ca (Matthew McPherrin)
Date: Wed, 25 Sep 2013 12:10:29 -0700
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
Message-ID: <CAMYrfjJSO9YDidDhe2LzJRm-9NX72GK0Odbtiu4cBX-d-BrC6Q@mail.gmail.com>

Maybe if you were writing code like this:

let mut a = 1; let mut b = 2;
loop {
    ...
    (a, b) = F();
   ...
}
(b, a)

On Wed, Sep 25, 2013 at 11:29 AM, Benjamin Striegel
<ben.striegel at gmail.com> wrote:
> Is there a use case that necessitates such a feature? The following code
> works today:
>
>     let a = 1;
>     let b = 2;
>     let (a, b) = (b, a);
>
> Not sure why that wouldn't be sufficient.
>
>
> On Wed, Sep 25, 2013 at 2:50 PM, Marvin L?bel <loebel.marvin at gmail.com>
> wrote:
>>
>> On 09/25/2013 06:37 PM, Diggory Hardy wrote:
>>>
>>> Hi,
>>>
>>> On Wednesday 25 September 2013 08:29:17 Patrick Walton wrote:
>>>>
>>>> On 9/25/13 6:32 AM, Alexander Sun wrote:
>>>>>
>>>>> Multiple return values
>>>>> if has a function like this:
>>>>>
>>>>> fn addsub(x : int, y : int) -> (int, int) {
>>>>>
>>>>>         return (x+y,x-y);
>>>>>
>>>>> }
>>>>>
>>>>> them, this is valid:
>>>>>
>>>>> let (b,c) = addsub(x, y);
>>>>>
>>>>> but this is invalid;
>>>>>
>>>>> let b:int =0;
>>>>> let c:int =0;
>>>>> (b,c) = addsub(x, y);
>>>>>
>>>>> also invalid:
>>>>>
>>>>> let (b,c)  = (0, 0);
>>>>> (b,c) = addsub(x, y);
>>>>
>>>> If we did this, we wouldn't know whether to parse a pattern or an
>>>> expression when starting a statement. This isn't fixable without trying
>>>> to define some sort of cover grammar that covers both expressions and
>>>> patterns, like ECMAScript 6 does. I don't know if this would work in
>>>> Rust.
>>>
>>> Are there any plans to support something like:
>>>
>>> assign (b,c) = addsub(x,y);
>>>
>>> for existing b,c? The best I could come up with is:
>>>
>>>      match two_nums(2) {
>>>          (x,y) => {a=x;b=y;}
>>>      }
>>>
>>> Not that I need this; just curious.
>>
>> I had the idea once to reuse the `in` keyword for that:
>>
>> let mut a = 0; let mut b = 1;
>> in (a, b) = (b, a);
>>
>> No idea how feasible that would be, though.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From corey at octayn.net  Wed Sep 25 12:59:56 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 25 Sep 2013 15:59:56 -0400
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
Message-ID: <CA++BO6TKiUiVAt3GUeqw0ZMg-+kshkaouuYu_5aweZUVPo62cQ@mail.gmail.com>

Very cool! It's nice to actually say we have a binding to *some* GUI library.

On Wed, Sep 25, 2013 at 1:49 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
> Hello, everyone.
>
> I would like to introduce my experimental project, wxRust.
> Which is a wxWidgets binding for Rust.
>
>   https://github.com/kenz-gelsoft/wxRust
>
> This binding is based on the wxHaskell especially its "wxc"*1
> C-Language wxWidgets binding part.
>
> Currently, it just converts wxc's header file to `extern fn`s and
> export them as a rust library.
>
> Test program has just started working which opens a wxFrame
> by calling wxc's C interface from extern fn.
>
> Current state is pre-alpha experimental state, there's no stable API,
> hard to use, but announced here for someone planning similar project.
>
> I'm planning for next generating simple OOP style wrapper as rust
> traits for each classes from wxc's header.
>
> There is many problems to tackle, for example how it can work
> with multitask or, library users can write wx GUI programs easier.
> Any helps or feedbacks are welcome.
>
>  *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>
>
> Thanks,
> --
> KENZ <KENZ.gelsoft at gmail.com>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From beza1e1 at web.de  Wed Sep 25 11:44:12 2013
From: beza1e1 at web.de (Andreas Zwinkau)
Date: Wed, 25 Sep 2013 20:44:12 +0200
Subject: [rust-dev] average function
In-Reply-To: <CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
	<CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
Message-ID: <CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>

Thanks, I used it for a benchmarking mod. Since we have three
different versions of average here, I benchmarked them.

https://gist.github.com/qznc/6704053

Apparently, the version of Scott Lawrence is the fastest one, unless I
made a mistake.

-- 
Andreas Zwinkau

work email: zwinkau at kit.edu
private email: qznc at web.de
homepage: http://beza1e1.tuxen.de

From thadguidry at gmail.com  Wed Sep 25 14:07:14 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Wed, 25 Sep 2013 16:07:14 -0500
Subject: [rust-dev] average function
In-Reply-To: <CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
	<CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
	<CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>
Message-ID: <CAChbWaM3Rf5PnHApUQEv780_LpLsMh74izu5gbdN6VSB+q_r0Q@mail.gmail.com>

>
>
> Apparently, the version of Scott Lawrence is the fastest one, unless I
> made a mistake.
>
>
Longest code (and simplest to understand code)... FTW ! :)  (as usual)

-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/3aff5b37/attachment.html>

From thadguidry at gmail.com  Wed Sep 25 14:11:25 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Wed, 25 Sep 2013 16:11:25 -0500
Subject: [rust-dev] average function
In-Reply-To: <CAChbWaM3Rf5PnHApUQEv780_LpLsMh74izu5gbdN6VSB+q_r0Q@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
	<CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
	<CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>
	<CAChbWaM3Rf5PnHApUQEv780_LpLsMh74izu5gbdN6VSB+q_r0Q@mail.gmail.com>
Message-ID: <CAChbWaOoSwJ-jrSuw7UkFGOUaMji6fRpp-nXU1D9b4Jm0eHVEQ@mail.gmail.com>

wait a sec.. your cheating in the benchmark...

Why did you clone() the array for theirs and not Lawrence's ?

See here: https://gist.github.com/qznc/6704053#file-benchmark-L76



On Wed, Sep 25, 2013 at 4:07 PM, Thad Guidry <thadguidry at gmail.com> wrote:

>
>> Apparently, the version of Scott Lawrence is the fastest one, unless I
>> made a mistake.
>>
>>
> Longest code (and simplest to understand code)... FTW ! :)  (as usual)
>
> --
> -Thad
> Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>



-- 
-Thad
Thad on Freebase.com <http://www.freebase.com/view/en/thad_guidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/9efac39b/attachment.html>

From ben at 0x539.de  Wed Sep 25 14:18:43 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Wed, 25 Sep 2013 23:18:43 +0200
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
Message-ID: <1380143923.29551.1.camel@vigil>

On Wed, 2013-09-25 at 14:29 -0400, Benjamin Striegel wrote:
> Is there a use case that necessitates such a feature? The following
> code works today:
> 
> 
>     let a = 1;
> 
>     let b = 2;
> 
>     let (a, b) = (b, a);
> 
> 
> Not sure why that wouldn't be sufficient.

Motivating toy example then ;)

    fn fib() {
        let mut a = 0;
        let mut b = 1;
    
        loop {
            printfln!(a);
            (a, b) = (b, a + b);
        }
    }


(I miss `let mut (a, b) = ...`!)

-benh



From jack at metajack.im  Wed Sep 25 14:23:47 2013
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 25 Sep 2013 15:23:47 -0600
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <1380143923.29551.1.camel@vigil>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
Message-ID: <CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>

> (I miss `let mut (a, b) = ...`!)

Miss it? Did it ever work? This seems like a bug though. Mutability is
inherited, so without this there's no way to do mutable destructuring
bind right?

jack.

From kmcallister at mozilla.com  Wed Sep 25 14:27:40 2013
From: kmcallister at mozilla.com (Keegan McAllister)
Date: Wed, 25 Sep 2013 14:27:40 -0700 (PDT)
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAMYrfjJSO9YDidDhe2LzJRm-9NX72GK0Odbtiu4cBX-d-BrC6Q@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<CAMYrfjJSO9YDidDhe2LzJRm-9NX72GK0Odbtiu4cBX-d-BrC6Q@mail.gmail.com>
Message-ID: <1832547094.897445.1380144460771.JavaMail.zimbra@mozilla.com>

I was thinking something like

    struct Foo { x: int, y: int }

    fn f(foo: &mut Foo) {
        (foo.x, foo.y) = g();
    }

(I actually get an ICE building this (with with appropriate g() and main()) using rustc 0.8 eb55348.)

I kind of like this idea of letting arbitrary lvalues appear in the "variable" position in pattern syntax.  But I don't know if it would turn out to be a can of worms.

keegan

----- Original Message -----
From: "Matthew McPherrin" <mozilla at mcpherrin.ca>
To: "Benjamin Striegel" <ben.striegel at gmail.com>
Cc: rust-dev at mozilla.org
Sent: Wednesday, September 25, 2013 12:10:29 PM
Subject: Re: [rust-dev] Some suggestions of Rust language

Maybe if you were writing code like this:

let mut a = 1; let mut b = 2;
loop {
    ...
    (a, b) = F();
   ...
}
(b, a)

On Wed, Sep 25, 2013 at 11:29 AM, Benjamin Striegel
<ben.striegel at gmail.com> wrote:
> Is there a use case that necessitates such a feature? The following code
> works today:
>
>     let a = 1;
>     let b = 2;
>     let (a, b) = (b, a);
>
> Not sure why that wouldn't be sufficient.
>
>
> On Wed, Sep 25, 2013 at 2:50 PM, Marvin L?bel <loebel.marvin at gmail.com>
> wrote:
>>
>> On 09/25/2013 06:37 PM, Diggory Hardy wrote:
>>>
>>> Hi,
>>>
>>> On Wednesday 25 September 2013 08:29:17 Patrick Walton wrote:
>>>>
>>>> On 9/25/13 6:32 AM, Alexander Sun wrote:
>>>>>
>>>>> Multiple return values
>>>>> if has a function like this:
>>>>>
>>>>> fn addsub(x : int, y : int) -> (int, int) {
>>>>>
>>>>>         return (x+y,x-y);
>>>>>
>>>>> }
>>>>>
>>>>> them, this is valid:
>>>>>
>>>>> let (b,c) = addsub(x, y);
>>>>>
>>>>> but this is invalid;
>>>>>
>>>>> let b:int =0;
>>>>> let c:int =0;
>>>>> (b,c) = addsub(x, y);
>>>>>
>>>>> also invalid:
>>>>>
>>>>> let (b,c)  = (0, 0);
>>>>> (b,c) = addsub(x, y);
>>>>
>>>> If we did this, we wouldn't know whether to parse a pattern or an
>>>> expression when starting a statement. This isn't fixable without trying
>>>> to define some sort of cover grammar that covers both expressions and
>>>> patterns, like ECMAScript 6 does. I don't know if this would work in
>>>> Rust.
>>>
>>> Are there any plans to support something like:
>>>
>>> assign (b,c) = addsub(x,y);
>>>
>>> for existing b,c? The best I could come up with is:
>>>
>>>      match two_nums(2) {
>>>          (x,y) => {a=x;b=y;}
>>>      }
>>>
>>> Not that I need this; just curious.
>>
>> I had the idea once to reuse the `in` keyword for that:
>>
>> let mut a = 0; let mut b = 1;
>> in (a, b) = (b, a);
>>
>> No idea how feasible that would be, though.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From loebel.marvin at gmail.com  Wed Sep 25 16:39:37 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Thu, 26 Sep 2013 01:39:37 +0200
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <CAAvrL-nbeMEGtZUtmptd14uOtLSuS5YLDw8kOip_7Z6QQ5gTpA@mail.gmail.com>
References: <52432E31.6040301@gmail.com>
	<CAAvrL-nbeMEGtZUtmptd14uOtLSuS5YLDw8kOip_7Z6QQ5gTpA@mail.gmail.com>
Message-ID: <52437439.9070808@gmail.com>

Argh, I forgot about macros! Nevermind then. :P

On 09/25/2013 08:33 PM, Benjamin Striegel wrote:
> Note that we reserve the dollar sign ($) for use in macros, so it 
> wouldn't be able to appear in regular Rust code without some sort of 
> escaping mechanism. I also don't see anything like this happening 
> before Rust 2.0 at the earliest.
>
>
> On Wed, Sep 25, 2013 at 2:40 PM, Marvin L?bel <loebel.marvin at gmail.com 
> <mailto:loebel.marvin at gmail.com>> wrote:
>
>     We don't use the symbol in our syntax, but are using functional
>     paradigm that sometimes result in a bit hard to read nested calls.
>
>     I'd propose that it works similar to `do`, in that it allows to
>     move the last expression of an function or method call after the
>     parentheses, though they would still remain required for ambiguity
>     reasons:
>
>     ~~~
>        a(b(c(1,d(2,3,4,e()))))
>     == a() $ b() $ c(1) $ d(2,3,4) $ e()
>
>     let v: ~[uint] = from_iter() $ range(0, 100);
>     ~~~
>
>     In that sense, it wouldn't really be an operator but syntactic
>     sugar for a function call.
>     It might even be possible to replace `do` with it, though the now
>     required parentheses would make it longer:
>
>     ~~~
>     do task::spawn { ... }
>     task::spawn() $ || { ... }
>     ~~~
>
>     Downside is of course that it adds another symbol, which could
>     alienate more potentiall users, and it could mean a
>     shift-away-from or at least an inconsistency-with methods and
>     method chaining in general.
>
>     Which would be ironic because I wanted it in some complicated
>     Iterator chain. ;)
>
>     It could of course always be implemented as a syntax extension,
>     and in any case I don't expect this to get any attention before
>     Rust 2.0. :)
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/de8ae346/attachment.html>

From ben at 0x539.de  Wed Sep 25 14:42:21 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Wed, 25 Sep 2013 23:42:21 +0200
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
Message-ID: <1380145341.29551.4.camel@vigil>

On Wed, 2013-09-25 at 15:23 -0600, Jack Moffitt wrote:
> > (I miss `let mut (a, b) = ...`!)
> 
> Miss it? Did it ever work? This seems like a bug though. Mutability is
> inherited, so without this there's no way to do mutable destructuring
> bind right?
> 
> jack.

Apparently it went away in commit f9b54541 and the workaround used there
is `let (foo, bar) = ...; let mut foo = foo;` etc.

Seems intentional, but I don't recall the rationale.

-benh


From kevin at sb.org  Wed Sep 25 14:48:05 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 25 Sep 2013 14:48:05 -0700
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <1380145341.29551.4.camel@vigil>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
	<1380145341.29551.4.camel@vigil>
Message-ID: <B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>

On Sep 25, 2013, at 2:42 PM, Benjamin Herr <ben at 0x539.de> wrote:

> On Wed, 2013-09-25 at 15:23 -0600, Jack Moffitt wrote:
>>> (I miss `let mut (a, b) = ...`!)
>> 
>> Miss it? Did it ever work? This seems like a bug though. Mutability is
>> inherited, so without this there's no way to do mutable destructuring
>> bind right?
>> 
>> jack.
> 
> Apparently it went away in commit f9b54541 and the workaround used there
> is `let (foo, bar) = ...; let mut foo = foo;` etc.
> 
> Seems intentional, but I don't recall the rationale.

The eventual plan is to say `let (mut foo, bar) = ...;`. We just don't yet support that.

-Kevin

From jack at metajack.im  Wed Sep 25 14:58:39 2013
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 25 Sep 2013 15:58:39 -0600
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
	<1380145341.29551.4.camel@vigil>
	<B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>
Message-ID: <CAP7VpsXfHCguaRyT3qUdM8kjPhh6nGsqa=m2CYzU5K+JHL80wQ@mail.gmail.com>

>>> Miss it? Did it ever work? This seems like a bug though. Mutability is
>>> inherited, so without this there's no way to do mutable destructuring
>>> bind right?
>> Apparently it went away in commit f9b54541 and the workaround used there
>> is `let (foo, bar) = ...; let mut foo = foo;` etc.
>>
>> Seems intentional, but I don't recall the rationale.
>
> The eventual plan is to say `let (mut foo, bar) = ...;`. We just don't yet support that.

The commit's intention as i recall was to change this `let mut foo,
bar;` which would make bar mutable. I'm not sure the intent was to
affect destructuring bind.

While `let (mut foo, bar)` matches pattern syntax for tuples, it seems
weird for structs, although I guess it probably matches there too.

`let mut Foo { x: x, y: y } = some_foo;` seems better than `let Foo {
mut x: x, mut y: y} = some_foo;`. Seems like both are probably
reasonable to have.

I don't feel super strongly about this, I just thought it weird that
destructuring let doesn't work with mut in the obvious (to me anyway)
way.

jack.

From martindemello at gmail.com  Wed Sep 25 15:18:41 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Wed, 25 Sep 2013 15:18:41 -0700
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
Message-ID: <CAFrFfuGmGifthJ7CEythhD_eQfCrjcvaBn5bRPPJbTbNX7hNTw@mail.gmail.com>

Did you try using bindgen on the wxc header file? If there were bits
it couldn't handle, I'd be interested in helping fix that.

martin

On Wed, Sep 25, 2013 at 10:49 AM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
> Hello, everyone.
>
> I would like to introduce my experimental project, wxRust.
> Which is a wxWidgets binding for Rust.
>
>   https://github.com/kenz-gelsoft/wxRust
>
> This binding is based on the wxHaskell especially its "wxc"*1
> C-Language wxWidgets binding part.
>
> Currently, it just converts wxc's header file to `extern fn`s and
> export them as a rust library.
>
> Test program has just started working which opens a wxFrame
> by calling wxc's C interface from extern fn.
>
> Current state is pre-alpha experimental state, there's no stable API,
> hard to use, but announced here for someone planning similar project.
>
> I'm planning for next generating simple OOP style wrapper as rust
> traits for each classes from wxc's header.
>
> There is many problems to tackle, for example how it can work
> with multitask or, library users can write wx GUI programs easier.
> Any helps or feedbacks are welcome.
>
>  *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>
>
> Thanks,
> --
> KENZ <KENZ.gelsoft at gmail.com>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From kevin at sb.org  Wed Sep 25 15:41:16 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 25 Sep 2013 15:41:16 -0700
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CAP7VpsXfHCguaRyT3qUdM8kjPhh6nGsqa=m2CYzU5K+JHL80wQ@mail.gmail.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
	<1380145341.29551.4.camel@vigil>
	<B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>
	<CAP7VpsXfHCguaRyT3qUdM8kjPhh6nGsqa=m2CYzU5K+JHL80wQ@mail.gmail.com>
Message-ID: <CFC991F4-FC70-4E2A-AD7F-262539B594C4@sb.org>

On Sep 25, 2013, at 2:58 PM, Jack Moffitt <jack at metajack.im> wrote:

>>>> Miss it? Did it ever work? This seems like a bug though. Mutability is
>>>> inherited, so without this there's no way to do mutable destructuring
>>>> bind right?
>>> Apparently it went away in commit f9b54541 and the workaround used there
>>> is `let (foo, bar) = ...; let mut foo = foo;` etc.
>>> 
>>> Seems intentional, but I don't recall the rationale.
>> 
>> The eventual plan is to say `let (mut foo, bar) = ...;`. We just don't yet support that.
> 
> The commit's intention as i recall was to change this `let mut foo,
> bar;` which would make bar mutable. I'm not sure the intent was to
> affect destructuring bind.
> 
> While `let (mut foo, bar)` matches pattern syntax for tuples, it seems
> weird for structs, although I guess it probably matches there too.
> 
> `let mut Foo { x: x, y: y } = some_foo;` seems better than `let Foo {
> mut x: x, mut y: y} = some_foo;`. Seems like both are probably
> reasonable to have.
> 
> I don't feel super strongly about this, I just thought it weird that
> destructuring let doesn't work with mut in the obvious (to me anyway)
> way.

I believe the intention was to allow `mut` in the same places you could put `ref` today in a pattern match.

-Kevin

From micah at micahchalmer.net  Wed Sep 25 16:46:44 2013
From: micah at micahchalmer.net (Micah Chalmer)
Date: Wed, 25 Sep 2013 19:46:44 -0400
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52437439.9070808@gmail.com>
References: <52432E31.6040301@gmail.com>
	<CAAvrL-nbeMEGtZUtmptd14uOtLSuS5YLDw8kOip_7Z6QQ5gTpA@mail.gmail.com>
	<52437439.9070808@gmail.com>
Message-ID: <6D697451-629D-4B30-834A-885B00B25C85@micahchalmer.net>

Speaking of macros and overly nested functional style--I had some code with deeply nested "do" blocks and experimented with a multi_do macro that creates syntax reminiscent of haskell's "do" notation.  It's more syntactically noisy than would be preferable--I couldn't get it to parse unambiguously without the || and the =>, which I really didn't want.  Having to put the final block inside the parentheses of the macro invocation made it not really worth it, because when using it, you're always nested two deep, so it'd only reduce indentation for three or more levels deep.  But in case anyone's interested:

macro_rules! multi_do {
    (|$args:pat| <- $e:expr; $(|$args_rest:pat| <- $e_rest:expr;)+
     => $blk:block) =>
        (do $e |$args| { multi_do!($(|$args_rest| <- $e_rest;)+ => $blk) });
    {|$args:pat| <- $e:expr; => $blk:block} => (do $e |$args| $blk);
}

it's used it like this:

multi_do!(
    |a| <- first_function(x);
    |b| <- second_function(y);
    |c| <- third_function();
    => {
        compute_stuff_with(a,b, c); 
    });

which expands to:

do first_function(x) |a| {
    do second_function(y) |b| {
        do third_function() |c| {
            compute_stuff_with(a, b, c);
        }
    }
}

On Sep 25, 2013, at 7:39 PM, Marvin L?bel wrote:

> Argh, I forgot about macros! Nevermind then. :P
> 
> On 09/25/2013 08:33 PM, Benjamin Striegel wrote:
>> Note that we reserve the dollar sign ($) for use in macros, so it wouldn't be able to appear in regular Rust code without some sort of escaping mechanism. I also don't see anything like this happening before Rust 2.0 at the earliest.
>> 
>> 
>> On Wed, Sep 25, 2013 at 2:40 PM, Marvin L?bel <loebel.marvin at gmail.com> wrote:
>> We don't use the symbol in our syntax, but are using functional paradigm that sometimes result in a bit hard to read nested calls.
>> 
>> I'd propose that it works similar to `do`, in that it allows to move the last expression of an function or method call after the parentheses, though they would still remain required for ambiguity reasons:
>> 
>> ~~~
>>    a(b(c(1,d(2,3,4,e()))))
>> == a() $ b() $ c(1) $ d(2,3,4) $ e()
>> 
>> let v: ~[uint] = from_iter() $ range(0, 100);
>> ~~~
>> 
>> In that sense, it wouldn't really be an operator but syntactic sugar for a function call.
>> It might even be possible to replace `do` with it, though the now required parentheses would make it longer:
>> 
>> ~~~
>> do task::spawn { ... }
>> task::spawn() $ || { ... }
>> ~~~
>> 
>> Downside is of course that it adds another symbol, which could alienate more potentiall users, and it could mean a shift-away-from or at least an inconsistency-with methods and method chaining in general.
>> 
>> Which would be ironic because I wanted it in some complicated Iterator chain. ;)
>> 
>> It could of course always be implemented as a syntax extension, and in any case I don't expect this to get any attention before Rust 2.0. :)
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/2a018419/attachment.html>

From ben.striegel at gmail.com  Wed Sep 25 16:50:27 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 25 Sep 2013 19:50:27 -0400
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CFC991F4-FC70-4E2A-AD7F-262539B594C4@sb.org>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
	<1380145341.29551.4.camel@vigil>
	<B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>
	<CAP7VpsXfHCguaRyT3qUdM8kjPhh6nGsqa=m2CYzU5K+JHL80wQ@mail.gmail.com>
	<CFC991F4-FC70-4E2A-AD7F-262539B594C4@sb.org>
Message-ID: <CAAvrL-nFziJkyH2YVi0iBg5QXT2T9E4S=xaH1NUKv+CKHbsnAQ@mail.gmail.com>

> I believe the intention was to allow `mut` in the same places you could
put `ref` today in a pattern match.

I was also under this impression, though I've never seen it explicitly laid
out anywhere. Would be nice to see if the devs are on board with this
extension to the pattern grammar.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/ce3737da/attachment.html>

From pwalton at mozilla.com  Wed Sep 25 18:43:22 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Wed, 25 Sep 2013 18:43:22 -0700
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <CFC991F4-FC70-4E2A-AD7F-262539B594C4@sb.org>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com> <1672711.OWuYzK0Q0I@tph-l10036>
	<5243307D.4030402@gmail.com>
	<CAAvrL-nHFnK6cLX3rm3XRH8XTqDVUGDM_O5Z5ejh+oR_41meDw@mail.gmail.com>
	<1380143923.29551.1.camel@vigil>
	<CAP7VpsWiG1UEP2SKoBETgLsf6jqAM9X_hfpKQ7Y+OkQKd61f_g@mail.gmail.com>
	<1380145341.29551.4.camel@vigil>
	<B6993A35-3085-47E7-A9B0-6994A28AE061@sb.org>
	<CAP7VpsXfHCguaRyT3qUdM8kjPhh6nGsqa=m2CYzU5K+JHL80wQ@mail.gmail.com>
	<CFC991F4-FC70-4E2A-AD7F-262539B594C4@sb.org>
Message-ID: <5243913A.5000102@mozilla.com>

On 9/25/13 3:41 PM, Kevin Ballard wrote:
> I believe the intention was to allow `mut` in the same places you
> could put `ref` today in a pattern match.

Yes.

Patrick

From davidb at davidb.org  Wed Sep 25 19:36:48 2013
From: davidb at davidb.org (David Brown)
Date: Wed, 25 Sep 2013 19:36:48 -0700
Subject: [rust-dev] "Computed" maps
Message-ID: <20130926023647.GA14641@davidb.org>

Let's say I'm implementing some type of map-like structure that I'd
like to be able to implement the Map trait on.

However, my map doesn't actually store the 'V' directly, but they are
computed/retrieve/cached in some manner.

Is this possible with the existing map trait?  Given that:

  fn find<'a>(&'a self, key: &K) -> Option<&'a V>;

doesn't the V need to be a pointer to something with the same lifetime
as self?

Is there a way of dealing with this, or should I just implement my own
similar find function, not implementing Map, and return an Option<V>
instead?

Thanks,
David

From danielmicay at gmail.com  Wed Sep 25 19:54:12 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 25 Sep 2013 22:54:12 -0400
Subject: [rust-dev] "Computed" maps
In-Reply-To: <20130926023647.GA14641@davidb.org>
References: <20130926023647.GA14641@davidb.org>
Message-ID: <CA+DvKQ+U61w_DZG8929GedxnFeQTFdO2gPHky9K8nyCY+voNyw@mail.gmail.com>

On Wed, Sep 25, 2013 at 10:36 PM, David Brown <davidb at davidb.org> wrote:

> Let's say I'm implementing some type of map-like structure that I'd
> like to be able to implement the Map trait on.
>
> However, my map doesn't actually store the 'V' directly, but they are
> computed/retrieve/cached in some manner.
>
> Is this possible with the existing map trait?  Given that:
>
>  fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
>
> doesn't the V need to be a pointer to something with the same lifetime
> as self?
>
> Is there a way of dealing with this, or should I just implement my own
> similar find function, not implementing Map, and return an Option<V>
> instead?
>

The Map trait represents a map storing the values, so it can't be used for
that use case.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130925/97038804/attachment.html>

From beza1e1 at web.de  Wed Sep 25 22:00:50 2013
From: beza1e1 at web.de (Andreas Zwinkau)
Date: Thu, 26 Sep 2013 07:00:50 +0200
Subject: [rust-dev] average function
In-Reply-To: <CAChbWaOoSwJ-jrSuw7UkFGOUaMji6fRpp-nXU1D9b4Jm0eHVEQ@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
	<CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
	<CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>
	<CAChbWaM3Rf5PnHApUQEv780_LpLsMh74izu5gbdN6VSB+q_r0Q@mail.gmail.com>
	<CAChbWaOoSwJ-jrSuw7UkFGOUaMji6fRpp-nXU1D9b4Jm0eHVEQ@mail.gmail.com>
Message-ID: <CAOqBtcfyf913pin-8HZT+ZL9U3YprXSAfgiiYjuNJ8+oqd2ukw@mail.gmail.com>

I use clone, because the values are moved into the closure. Otherwise
type checker complains about use of moved value.

When I clone for lawrence as well, the numbers do not change.

On Wed, Sep 25, 2013 at 11:11 PM, Thad Guidry <thadguidry at gmail.com> wrote:
> wait a sec.. your cheating in the benchmark...
>
> Why did you clone() the array for theirs and not Lawrence's ?
>
> See here: https://gist.github.com/qznc/6704053#file-benchmark-L76
>
>
>
> On Wed, Sep 25, 2013 at 4:07 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>>>
>>>
>>> Apparently, the version of Scott Lawrence is the fastest one, unless I
>>> made a mistake.
>>>
>>
>> Longest code (and simplest to understand code)... FTW ! :)  (as usual)
>>
>> --
>> -Thad
>> Thad on Freebase.com
>> Thad on LinkedIn
>
>
>
>
> --
> -Thad
> Thad on Freebase.com
> Thad on LinkedIn



-- 
Andreas Zwinkau

work email: zwinkau at kit.edu
private email: qznc at web.de
homepage: http://beza1e1.tuxen.de

From bjzaba at yahoo.com.au  Wed Sep 25 23:18:55 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 26 Sep 2013 16:18:55 +1000
Subject: [rust-dev] average function
In-Reply-To: <CAChbWaOoSwJ-jrSuw7UkFGOUaMji6fRpp-nXU1D9b4Jm0eHVEQ@mail.gmail.com>
References: <CAOqBtcfARX77xzg+Ci6cN07HZoqC8bg8pdMpWErhi-jHiMB1ew@mail.gmail.com>
	<alpine.LNX.2.03.1309241808300.1254@localhost.localdomain>
	<6AF319DC-900F-4100-99B9-208C3A2E0D30@yahoo.com.au>
	<CACVDHK=+c=F1Xc7epZqLoybkOEdiOE5OfGpc_189VyvwTz9YwA@mail.gmail.com>
	<CA+DvKQLWUF3u=4JEYUnjYo+=Kw8DZpY-GjDkMKa2Ci+rNmhDNg@mail.gmail.com>
	<271332ED-17BD-49E3-B507-35055D54592E@sb.org>
	<CA+DvKQKjqW=bQtuoj-6GudNAOUJ_KLrE8c1DdyFhQ3ki_5zSRg@mail.gmail.com>
	<CAOqBtcftLUMzGv2qfeqve7UDwPdz4umPtDGf5JMOoYva8oqZJQ@mail.gmail.com>
	<CAChbWaM3Rf5PnHApUQEv780_LpLsMh74izu5gbdN6VSB+q_r0Q@mail.gmail.com>
	<CAChbWaOoSwJ-jrSuw7UkFGOUaMji6fRpp-nXU1D9b4Jm0eHVEQ@mail.gmail.com>
Message-ID: <E81C1A78-1565-4955-8291-67F77CA0CEAB@yahoo.com.au>

Base numeric types are implicitly clonable. For example, if you were mapping over a `&[int]` vector, for example, you would be able to do `.map(|x| *x)` and `x` would be implicitly cloned. For generic types like `T: Clone`, Rust complains because it thinks you are trying to move the value out of the vector, which is impossible. Therefore you must be explicit by calling `.clone()`.

~B? 

On 26/09/2013, at 7:11 AM, Thad Guidry <thadguidry at gmail.com> wrote:

> wait a sec.. your cheating in the benchmark...
> 
> Why did you clone() the array for theirs and not Lawrence's ?
> 
> See here: https://gist.github.com/qznc/6704053#file-benchmark-L76
> 
> 
> 
> On Wed, Sep 25, 2013 at 4:07 PM, Thad Guidry <thadguidry at gmail.com> wrote:
> 
> Apparently, the version of Scott Lawrence is the fastest one, unless I
> made a mistake.
> 
> 
> Longest code (and simplest to understand code)... FTW ! :)  (as usual)
> 
> -- 
> -Thad
> Thad on Freebase.com
> Thad on LinkedIn
> 
> 
> 
> -- 
> -Thad
> Thad on Freebase.com
> Thad on LinkedIn
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/7f6f0955/attachment.html>

From jens at nockert.se  Thu Sep 26 03:31:01 2013
From: jens at nockert.se (Jens Nockert)
Date: Thu, 26 Sep 2013 12:31:01 +0200
Subject: [rust-dev] =?iso-8859-1?q?Sk=E5ne_Rust_Announcement?=
Message-ID: <4C7D43E1-1DE6-46E5-AABA-DE4E881C3A59@nockert.se>

Hello,

I just wanted to announce that there is now a user group for Rust in Sk?ne, Sweden (http://www.meetup.com/rust-skane/) and that everybody is invited.

We have a few Rust users around, and I hope that with some effort we can get a lot more to join the winning team and make the Rust community as a whole even more amazing.

Hugs for everyone,
Jens Nockert

From steve at steveklabnik.com  Thu Sep 26 04:53:08 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Thu, 26 Sep 2013 04:53:08 -0700
Subject: [rust-dev] =?iso-8859-1?q?Sk=E5ne_Rust_Announcement?=
In-Reply-To: <4C7D43E1-1DE6-46E5-AABA-DE4E881C3A59@nockert.se>
References: <4C7D43E1-1DE6-46E5-AABA-DE4E881C3A59@nockert.se>
Message-ID: <CABL+ZB5Uj0GFGP4R_4VE+O+RJ2_A52zpQRrcCTtJpv3=yamOGQ@mail.gmail.com>

Neat! I will be in Malm? for ?redev. Feel free to get in touch
off-list if you're having a get-together around that time.

From armin.ronacher at active-4.com  Thu Sep 26 08:32:43 2013
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Thu, 26 Sep 2013 16:32:43 +0100
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <52432E31.6040301@gmail.com>
References: <52432E31.6040301@gmail.com>
Message-ID: <5244539B.4080005@active-4.com>

Hi,

On 25/09/2013 19:40, Marvin L?bel wrote:
> We don't use the symbol in our syntax, but are using functional paradigm
> that sometimes result in a bit hard to read nested calls.
Strong -1 on the proposal.  Users are already complaining that the 
syntax is too complicated and pulling in more stuff from Haskell is not 
going to help Rust there.


Regards,
Armin

From catamorphism at gmail.com  Thu Sep 26 08:37:14 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Thu, 26 Sep 2013 08:37:14 -0700
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <5244539B.4080005@active-4.com>
References: <52432E31.6040301@gmail.com>
	<5244539B.4080005@active-4.com>
Message-ID: <CADcg8=mbTWgZvECy0-xGmZ0smyet9kBzAUiDZ7Ef3TuBjdVe5w@mail.gmail.com>

FWIW, Haskellers often complain about the readability of code that
uses the `$` operator a lot. I've heard such complaints both from
people new to Haskell and more experienced Haskell programmers. In
general in Rust, we avoid infix operators (we have a fixed of them and
-- unlike Haskell -- no way for users to define new ones), and given
the history of `$` in Haskell, I don't see a particular reason to make
an exception.

Cheers,
Tim



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From jpet at google.com  Thu Sep 26 09:20:48 2013
From: jpet at google.com (Jeff Petkau)
Date: Thu, 26 Sep 2013 09:20:48 -0700
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <CADcg8=mbTWgZvECy0-xGmZ0smyet9kBzAUiDZ7Ef3TuBjdVe5w@mail.gmail.com>
References: <52432E31.6040301@gmail.com> <5244539B.4080005@active-4.com>
	<CADcg8=mbTWgZvECy0-xGmZ0smyet9kBzAUiDZ7Ef3TuBjdVe5w@mail.gmail.com>
Message-ID: <CAE6JmvM3_DRVeC5U+gcNMcrvPLNPuCPjzCQqXwz-XO+kFFXfsQ@mail.gmail.com>

I don't think the problem with '$' is that it's infix; it's that it makes
the data flow read right-to-left. The '|>' operator from F# is just "swap
($)", but it tends to make code much more readable.

In fact, I think the whole appeal for object oriented style dot.method
notation is that it makes things tend to read more consistently
left-to-right. "I have a foo, and I do baz and blah and bar to it" vs. "I
do bar to the result of doing blah to the result of doing baz to a foo."

Jeff


On Thu, Sep 26, 2013 at 8:37 AM, Tim Chevalier <catamorphism at gmail.com>wrote:

> FWIW, Haskellers often complain about the readability of code that
> uses the `$` operator a lot. I've heard such complaints both from
> people new to Haskell and more experienced Haskell programmers. In
> general in Rust, we avoid infix operators (we have a fixed of them and
> -- unlike Haskell -- no way for users to define new ones), and given
> the history of `$` in Haskell, I don't see a particular reason to make
> an exception.
>
> Cheers,
> Tim
>
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "Being queer is not about a right to privacy; it is about the freedom
> to be public, to just be who we are." -- anonymous, June 1990
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/bb379538/attachment.html>

From oren at ben-kiki.org  Thu Sep 26 11:08:10 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Thu, 26 Sep 2013 21:08:10 +0300
Subject: [rust-dev] Should we add a Haskell-like `$` operator?
In-Reply-To: <CAE6JmvM3_DRVeC5U+gcNMcrvPLNPuCPjzCQqXwz-XO+kFFXfsQ@mail.gmail.com>
References: <52432E31.6040301@gmail.com> <5244539B.4080005@active-4.com>
	<CADcg8=mbTWgZvECy0-xGmZ0smyet9kBzAUiDZ7Ef3TuBjdVe5w@mail.gmail.com>
	<CAE6JmvM3_DRVeC5U+gcNMcrvPLNPuCPjzCQqXwz-XO+kFFXfsQ@mail.gmail.com>
Message-ID: <CADJiDht+ANcc7j1OmmfoBxJrzL0HcdDhqyga-xJ6y641KtQQ=Q@mail.gmail.com>

Right, the simple left-to-right chaining is why I thought that |> might be
a good fit for Rust - foo |> bar means exactly do foo and then bar.
On Sep 26, 2013 7:21 PM, "Jeff Petkau" <jpet at google.com> wrote:

> I don't think the problem with '$' is that it's infix; it's that it makes
> the data flow read right-to-left. The '|>' operator from F# is just "swap
> ($)", but it tends to make code much more readable.
>
> In fact, I think the whole appeal for object oriented style dot.method
> notation is that it makes things tend to read more consistently
> left-to-right. "I have a foo, and I do baz and blah and bar to it" vs. "I
> do bar to the result of doing blah to the result of doing baz to a foo."
>
> Jeff
>
>
> On Thu, Sep 26, 2013 at 8:37 AM, Tim Chevalier <catamorphism at gmail.com>wrote:
>
>> FWIW, Haskellers often complain about the readability of code that
>> uses the `$` operator a lot. I've heard such complaints both from
>> people new to Haskell and more experienced Haskell programmers. In
>> general in Rust, we avoid infix operators (we have a fixed of them and
>> -- unlike Haskell -- no way for users to define new ones), and given
>> the history of `$` in Haskell, I don't see a particular reason to make
>> an exception.
>>
>> Cheers,
>> Tim
>>
>>
>>
>> --
>> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
>> "Being queer is not about a right to privacy; it is about the freedom
>> to be public, to just be who we are." -- anonymous, June 1990
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/c3e6cb20/attachment-0001.html>

From banderson at mozilla.com  Thu Sep 26 11:31:21 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 26 Sep 2013 11:31:21 -0700
Subject: [rust-dev] 0.8 prerelease testing
Message-ID: <52447D79.3070006@mozilla.com>

Greetings,

Here's a release candidate of Rust 0.8, built from commit 
8a4f0fa6c518eb634687abe9659601d9d2a61899:

http://static.rust-lang.org/dist/rust-0.8.tar.gz
sha256: 42f791ab1537357fe0f63d67ffe6bcb64ecf16b2bd3f1484ab589823f591418

http://static.rust-lang.org/dist/rust-0.8-install.exe
sha256: 4d303232144cb4c3a6f34af6ff0cfe9f8eefae114c88c52ac63128c49cdef7f1

This is _not_ a signed release, just a candidate. If you have some spare 
cycles please give this an install and report whether it does what you 
expect. If all goes well we will release 0.8 today or tomorrow.

Regards,
Brian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/fb7c684f/attachment.html>

From singingboyo at gmail.com  Thu Sep 26 12:58:48 2013
From: singingboyo at gmail.com (Brandon Sanderson)
Date: Thu, 26 Sep 2013 12:58:48 -0700
Subject: [rust-dev] "Computed" maps
In-Reply-To: <CA+DvKQ+U61w_DZG8929GedxnFeQTFdO2gPHky9K8nyCY+voNyw@mail.gmail.com>
References: <20130926023647.GA14641@davidb.org>
	<CA+DvKQ+U61w_DZG8929GedxnFeQTFdO2gPHky9K8nyCY+voNyw@mail.gmail.com>
Message-ID: <CAK-XjKWeJXw=amSMMyRrvJS9SB7_=nc6ra-eLz06JdtbeLL16g@mail.gmail.com>

If the values are cached, and the structure implementing the cache has the
same lifetime (or longer? Unsure on that...) as the map then I'd expect it
to work.  For generated/retrieved, non-cached values I don't believe it
would work.
On 2013-09-25 7:54 PM, "Daniel Micay" <danielmicay at gmail.com> wrote:

> On Wed, Sep 25, 2013 at 10:36 PM, David Brown <davidb at davidb.org> wrote:
>
>> Let's say I'm implementing some type of map-like structure that I'd
>> like to be able to implement the Map trait on.
>>
>> However, my map doesn't actually store the 'V' directly, but they are
>> computed/retrieve/cached in some manner.
>>
>> Is this possible with the existing map trait?  Given that:
>>
>>  fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
>>
>> doesn't the V need to be a pointer to something with the same lifetime
>> as self?
>>
>> Is there a way of dealing with this, or should I just implement my own
>> similar find function, not implementing Map, and return an Option<V>
>> instead?
>>
>
> The Map trait represents a map storing the values, so it can't be used for
> that use case.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130926/d6544aab/attachment.html>

From banderson at mozilla.com  Thu Sep 26 17:12:24 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 26 Sep 2013 17:12:24 -0700
Subject: [rust-dev] Rust 0.8 released
Message-ID: <5244CD68.9000800@mozilla.com>

Mozilla and the Rust community are pleased to announce version 0.8 of
the Rust compiler and tools. Rust is a systems programming language
with a focus on safety, performance and concurrency.

This was another very active release cycle that continued the trend
toward refining the standard library while making minor adjustments to
the language. In this release the `for` keyword has been changed to work
with `Iterator` types, the runtime and task scheduler was rewritten, a
new experimental I/O subsystem was added, and we added a new family of
string formatting macros, `format!`, that will eventually replace `fmt!`.

The brief release notes are included in this announcement, and there is
further explanation in the detailed release [notes] on the wiki.
Documentation and all the links in this email are available on the
[website]. As usual, version 0.8 should be considered an alpha release,
suitable for early adopters and language enthusiasts. Please file [bugs]
and join the [fun].

[website]: http://www.rust-lang.org
[notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
[bugs]: https://github.com/mozilla/rust/issues
[fun]: https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors

This release is available as both a tarball and a Windows installer:

* http://static.rust-lang.org/dist/rust-0.8.tar.gz
http://static.rust-lang.org/dist/rust-0.8.tar.gz.asc
SHA256 (of .tar.gz):
42f791ab1537357fe0f63d67ffe6bcb64ecf16b2bd3f1484ab589823f5914182

* http://static.rust-lang.org/dist/rust-0.8-install.exe
http://static.rust-lang.org/dist/rust-0.8-install.exe.asc
SHA256 (of .exe):
4d303232144cb4c3a6f34af6ff0cfe9f8eefae114c88c52ac63128c49cdef7f1

Thanks to everyone who contributed!

Regards,
The Rust Team


Version 0.8 (September 2013)
-----------------------

* ~2200 changes, numerous bugfixes

* Language
* The `for` loop syntax has changed to work with the `Iterator` trait.
* At long last, unwinding works on Windows.
* Default methods are ready for use.
* Many trait inheritance bugs fixed.
* Owned and borrowed trait objects work more reliably.
* `copy` is no longer a keyword. It has been replaced by the `Clone` trait.
* rustc can omit emission of code for the `debug!` macro if it is passed
`--cfg ndebug`
* mod.rs is now "blessed". When loading `mod foo;`, rustc will now look
for foo.rs, then foo/mod.rs, and will generate an error when both are
present.
* Strings no longer contain trailing nulls. The new `std::c_str` module
provides new mechanisms for converting to C strings.
* The type of foreign functions is now `extern "C" fn` instead of `*u8'.
* The FFI has been overhauled such that foreign functions are called 
directly,
instead of through a stack-switching wrapper.
* Calling a foreign function must be done through a Rust function with the
`#[fixed_stack_segment]` attribute.
* The `externfn!` macro can be used to declare both a foreign function and
a `#[fixed_stack_segment]` wrapper at once.
* `pub` and `priv` modifiers on `extern` blocks are no longer parsed.
* `unsafe` is no longer allowed on extern fns - they are all unsafe.
* `priv` is disallowed everywhere except for struct fields and enum 
variants.
* `&T` (besides `&'static T`) is no longer allowed in `@T`.
* `ref` bindings in irrefutable patterns work correctly now.
* `char` is now prevented from containing invalid code points.
* Casting to `bool` is no longer allowed.
* `\0` is now accepted as an escape in chars and strings.
* `yield` is a reserved keyword.
* `typeof` is a reserved keyword.
* Crates may be imported by URL with `extern mod foo = "url";`.
* Explicit enum discriminants may be given as uints as in `enum E { V = 
0u }`
* Static vectors can be initialized with repeating elements,
e.g. `static foo: [u8, .. 100]: [0, .. 100];`.
* Static structs can be initialized with functional record update,
e.g. `static foo: Foo = Foo { a: 5, .. bar };`.
* `cfg!` can be used to conditionally execute code based on the crate
configuration, similarly to `#[cfg(...)]`.
* The `unnecessary_qualification` lint detects unneeded module
prefixes (default: allow).
* Arithmetic operations have been implemented on the SIMD types in
`std::unstable::simd`.
* Exchange allocation headers were removed, reducing memory usage.
* `format!` implements a completely new, extensible, and higher-performance
string formatting system. It will replace `fmt!`.
* `print!` and `println!` write formatted strings (using the `format!`
extension) to stdout.
* `write!` and `writeln!` write formatted strings (using the `format!`
extension) to the new Writers in `std::rt::io`.
* The library section in which a function or static is placed may
be specified with `#[link_section = "..."]`.
* The `proto!` syntax extension for defining bounded message protocols
was removed.
* `macro_rules!` is hygienic for `let` declarations.
* The `#[export_name]` attribute specifies the name of a symbol.
* `unreachable!` can be used to indicate unreachable code, and fails
if executed.

* Libraries
* std: Transitioned to the new runtime, written in Rust.
* std: Added an experimental I/O library, `rt::io`, based on the new
runtime.
* std: A new generic `range` function was added to the prelude, replacing
`uint::range` and friends.
* std: `range_rev` no longer exists. Since range is an iterator it can be
reversed with `range(lo, hi).invert()`.
* std: The `chain` method on option renamed to `and_then`; 
`unwrap_or_default`
renamed to `unwrap_or`.
* std: The `iterator` module was renamed to `iter`.
* std: Integral types now support the `checked_add`, `checked_sub`, and
`checked_mul` operations for detecting overflow.
* std: Many methods in `str`, `vec`, `option, `result` were renamed for
consistency.
* std: Methods are standardizing on conventions for casting methods:
`to_foo` for copying, `into_foo` for moving, `as_foo` for temporary
and cheap casts.
* std: The `CString` type in `c_str` provides new ways to convert to and
from C strings.
* std: `DoubleEndedIterator` can yield elements in two directions.
* std: The `mut_split` method on vectors partitions an `&mut [T]` into
two splices.
* std: `str::from_bytes` renamed to `str::from_utf8`.
* std: `pop_opt` and `shift_opt` methods added to vectors.
* std: The task-local data interface no longer uses @, and keys are
no longer function pointers.
* std: The `swap_unwrap` method of `Option` renamed to `take_unwrap`.
* std: Added `SharedPort` to `comm`.
* std: `Eq` has a default method for `ne`; only `eq` is required
in implementations.
* std: `Ord` has default methods for `le`, `gt` and `ge`; only `lt`
is required in implementations.
* std: `is_utf8` performance is improved, impacting many string functions.
* std: `os::MemoryMap` provides cross-platform mmap.
* std: `ptr::offset` is now unsafe, but also more optimized. Offsets that
are not 'in-bounds' are considered undefined.
* std: Many freestanding functions in `vec` removed in favor of methods.
* std: Many freestanding functions on scalar types removed in favor of
methods.
* std: Many options to task builders were removed since they don't make
sense in the new scheduler design.
* std: More containers implement `FromIterator` so can be created by the
`collect` method.
* std: More complete atomic types in `unstable::atomics`.
* std: `comm::PortSet` removed.
* std: Mutating methods in the `Set` and `Map` traits have been moved into
the `MutableSet` and `MutableMap` traits. `Container::is_empty`,
`Map::contains_key`, `MutableMap::insert`, and `MutableMap::remove` have
default implementations.
* std: Various `from_str` functions were removed in favor of a generic
`from_str` which is available in the prelude.
* std: `util::unreachable` removed in favor of the `unreachable!` macro.
* extra: `dlist`, the doubly-linked list was modernized.
* extra: Added a `hex` module with `ToHex` and `FromHex` traits.
* extra: Added `glob` module, replacing `std::os::glob`.
* extra: `rope` was removed.
* extra: `deque` was renamed to `ringbuf`. `RingBuf` implements `Deque`.
* extra: `net`, and `timer` were removed. The experimental replacements
are `std::rt::io::net` and `std::rt::io::timer`.
* extra: Iterators implemented for `SmallIntMap`.
* extra: Iterators implemented for `Bitv` and `BitvSet`.
* extra: `SmallIntSet` removed. Use `BitvSet`.
* extra: Performance of JSON parsing greatly improved.
* extra: `semver` updated to SemVer 2.0.0.
* extra: `term` handles more terminals correctly.
* extra: `dbg` module removed.
* extra: `par` module removed.
* extra: `future` was cleaned up, with some method renames.
* extra: Most free functions in `getopts` were converted to methods.

* Other
* rustc's debug info generation (`-Z debug-info`) is greatly improved.
* rustc accepts `--target-cpu` to compile to a specific CPU architecture,
similarly to gcc's `--march` flag.
* rustc's performance compiling small crates is much better.
* rustpkg has received many improvements.
* rustpkg supports git tags as package IDs.
* rustpkg builds into target-specific directories so it can be used for
cross-compiling.
* The number of concurrent test tasks is controlled by the environment
variable RUST_TEST_TASKS.
* The test harness can now report metrics for benchmarks.
* All tools have man pages.
* Programs compiled with `--test` now support the `-h` and `--help` flags.
* The runtime uses jemalloc for allocations.
* Segmented stacks are temporarily disabled as part of the transition to
the new runtime. Stack overflows are possible!
* A new documentation backend, rustdoc_ng, is available for use. It is
still invoked through the normal `rustdoc` command.


Contributors to Rust 0.8
------------------------

Aaron Laursen <aaronlaursen at gmail.com>
Aaron Todd <github at opprobrio.us>
adridu59 <adri-from-59 at hotmail.fr>
Adrien T?tar <adri-from-59 at hotmail.fr>
Alex Crichton <alex at alexcrichton.com>
Aljaz? "g5pw" Srebrnic? <a2piratesoft at gmail.com>
Anders Kaseorg <andersk at mit.edu>
Andreas Martens <andreasm at fastmail.fm>
Andrew Dunham <andrew at du.nham.ca>
Andrew Paseltiner <apaseltiner at gmail.com>
Armin Ronacher <armin.ronacher at active-4.com>
Austin King <shout at ozten.com>
Ben Blum <bblum at andrew.cmu.edu>
Benjamin Herr <ben at 0x539.de>
Birunthan Mohanathas <birunthan at mohanathas.com>
Bj?rn Steinbrink <bsteinbr at gmail.com>
blake2-ppc <ulrik.sverdrup at gmail.com>
Bouke van der Bijl <boukevanderbijl at gmail.com>
Brandon Sanderson <singingboyo at hotmail.com>
Brendan Cully <brendan at kublai.com>
Brendan Zabarauskas <bjzaba at yahoo.com.au>
Brian Anderson <banderson at mozilla.com>
Carlos <toqueteos at gmail.com>
Chris Morgan <me at chrismorgan.info>
Corey Richardson <corey at octayn.net>
Daniel Micay <danielmicay at gmail.com>
Daniel Rosenwasser <DanielRosenwasser at gmail.com>
darkf <lw9k123 at gmail.com>
David Creswick <dcrewi at gyrae.net>
David Halperin <halperin.dr at gmail.com>
David Manescu <dman2626 at uni.sydney.edu.au>
Dmitry Ermolov <epdmitry at yandex.ru>
Do Nhat Minh <mrordinaire at gmail.com>
Erick Tryzelaar <erick.tryzelaar at gmail.com>
Eric Martin <e.a.martin1337 at gmail.com>
Eric Reed <ecreed at cs.washington.edu>
Etienne Millon <me at emillon.org>
Evgeny Sologubov
Fedor Indutny <fedor.indutny at gmail.com>
Felix S. Klock II <pnkfelix at pnkfx.org>
Flaper Fesp <flaper87 at gmail.com>
Flavio Percoco <flaper87 at gmail.com>
Florian Hahn <flo at fhahn.com>
Florian Zeitz <florob at babelmonkeys.de>
G?bor Horv?th <xazax.hun at gmail.com>
Gareth Smith <garethdanielsmith at gmail.com>
Gary Linscott <glinscott at gmail.com>
Gavin Baker <gavinb at antonym.org>
Graydon Hoare <graydon at mozilla.com>
Huon Wilson <dbau.pp+github at gmail.com>
Ilyong Cho <ilyoan at gmail.com>
Jack Moffitt <jack at metajack.im>
Jakub <jakub at jakub.cc>
James Miller <james at aatch.net>
Jan Kobler <eng1 at koblersystems.de>
Jason Fager <jfager at gmail.com>
Jed Davis <jld at panix.com>
Jeff Olson <olson.jeffery at gmail.com>
Jens Nockert <jens at nockert.se>
Jimmy Zelinskie <jimmyzelinskie at gmail.com>
jmgrosen <jmgrosen at gmail.com>
John Barker <jebarker at gmail.com>
John Clements <clements at racket-lang.org>
Jordi Boggiano <j.boggiano at seld.be>
Josh Matthews <josh at joshmatthews.net>
Jyun-Yan You <jyyou at cs.nctu.edu.tw>
Keegan McAllister <kmcallister at mozilla.com>
Kevin Ballard <kevin at sb.org>
Kevin Mehall <km at kevinmehall.net>
Kevin Murphy <kemurphy.cmu at gmail.com>
klutzy <klutzytheklutzy at gmail.com>
korenchkin <korenchkin2 at gmail.com>
Lars Bergstrom <lbergstrom at mozilla.com>
Lenny222 <github at kudling.de>
Lindsey Kuper <lindsey at composition.al>
Luca Bruno <lucab at debian.org>
Luqman Aden <me at luqman.ca>
maikklein <maikklein at googlemail.com>
Makoto Nakashima <makoto.nksm+github at gmail.com>
Mark Sinclair <mark.edward.x at gmail.com>
Marvin L?bel <loebel.marvin at gmail.com>
Matthijs Hofstra <thiezz at gmail.com>
Maxim Kolganov <kolganov.mv at gmail.com>
Micah Chalmer <micah at micahchalmer.net>
Michael Sullivan <sully at msully.net>
Michael Woerister <michaelwoerister at gmail>
Mihnea Dobrescu-Balaur <mihnea at linux.com>
Mukilan Thiagarajan <mukilanthiagarajan at gmail.com>
NiccosSystem <niccossystem at gmail.com>
Nick Desaulniers <ndesaulniers at mozilla.com>
Niko Matsakis <niko at alum.mit.edu>
novalis <novalis at novalis.org>
nsf <no.smile.face at gmail.com>
OGINO Masanori <masanori.ogino at gmail.com>
Palmer Cox <p at lmercox.com>
Patrick Walton <pcwalton at mimiga.net>
Paul Collins <paul at ondioline.org>
Philipp Br?schweiler <blei42 at gmail.com>
Robert Knight <robertknight at gmail.com>
Robert Millar <robert.millar at cantab.net>
Sangeun Kim <sammy.kim at samsung.com>
Sankha Narayan Guria <sankha93 at gmail.com>
Seo Sanghyeon <sanxiyn at gmail.com>
SiegeLord <slabode at aim.com>
Simon Sapin <simon.sapin at exyr.org>
sp3d <sp3d at github>
Stepan Koltsov <stepan.koltsov at gmail.com>
Steve Klabnik <steve at steveklabnik.com>
Steven Fackler <sfackler at gmail.com>
Steven Stewart-Gallus <sstewartgallus00 at mylangara.bc.ca>
Ted Horst <ted.horst at earthlink.net>
Tim Chevalier <chevalier at alum.wellesley.edu>
Tim Kuehn <tkuehn at cmu.edu>
Tom Lee <github at tomlee.co>
U-NOV2010\eugals
Vadim Chugunov <vadimcn at gmail.com>
Young-il Choi <duddlf.choi at samsung.com>
Zack Slayton <zack.slayton at gmail.com>

From rexlen at gmail.com  Fri Sep 27 06:09:28 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Fri, 27 Sep 2013 15:09:28 +0200
Subject: [rust-dev] 0.8 release
Message-ID: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>

Strange thing...
after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
doesn't start and Windows complains:

"the application was unable to start correctly (0xc0000005).
The worst thing is that reinstalling rust07 i get the same error...... now
i'm without Rust :-(

ideas?

Regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/8b53a05a/attachment.html>

From j.boggiano at seld.be  Fri Sep 27 07:01:32 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Fri, 27 Sep 2013 16:01:32 +0200
Subject: [rust-dev] 0.8 release
In-Reply-To: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
References: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
Message-ID: <52458FBC.6040804@seld.be>

On 27.09.2013 15:09, Renato Lenzi wrote:
> Strange thing...
> after installing rust 08 on W7 System rustc.exe (or rust.exe or
> rusti.exe) doesn't start and Windows complains:
> 
> "the application was unable to start correctly (0xc0000005).
> The worst thing is that reinstalling rust07 i get the same error......
> now i'm without Rust :-(
> 
> ideas?

Most likely it's because you still have the 0.7 dlls.

Check in "C:\Program Files (x86)\Rust\bin\rustc\i686-pc-mingw32\bin" and
"C:\Program Files (x86)\Rust\bin\" and remove all files ending in
-0.7.dll. Hopefully that fixes it.

The way to avoid this is to uninstall the previous version before
installing a new one I think, but I always forget. It'd be nice if the
installer would clean up older libs.

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From rexlen at gmail.com  Fri Sep 27 07:20:06 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Fri, 27 Sep 2013 16:20:06 +0200
Subject: [rust-dev] Fwd:  0.8 release
In-Reply-To: <52458FBC.6040804@seld.be>
References: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
	<52458FBC.6040804@seld.be>
Message-ID: <CAM0XVgvfEe+EGH6R-f89ewtL5o7HB8ANVuZcC4COZNnR0UQwfw@mail.gmail.com>

I've to try.... i usually install on my D hard drive in dirs named rust05,
rust06, rust07... and, until today, this way has worked fine..... but with
rust08 i was unsuccessful
A fresh install on a Windows 8 station gives error as well, complaining for
some missing DLL....... not a good situation for me........

thx a lot.



On 27.09.2013 15:09, Renato Lenzi wrote:
> Strange thing...
> after installing rust 08 on W7 System rustc.exe (or rust.exe or
> rusti.exe) doesn't start and Windows complains:
>
> "the application was unable to start correctly (0xc0000005).
> The worst thing is that reinstalling rust07 i get the same error......
> now i'm without Rust :-(
>
> ideas?

Most likely it's because you still have the 0.7 dlls.

Check in "C:\Program Files (x86)\Rust\bin\rustc\i686-pc-mingw32\bin" and
"C:\Program Files (x86)\Rust\bin\" and remove all files ending in
-0.7.dll. Hopefully that fixes it.

The way to avoid this is to uninstall the previous version before
installing a new one I think, but I always forget. It'd be nice if the
installer would clean up older libs.

Cheers

--
Jordi Boggiano
@seldaek - http://nelm.io/jordi
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/551efb71/attachment-0001.html>

From aaron.dandy at live.com  Fri Sep 27 07:28:08 2013
From: aaron.dandy at live.com (Aaron Dandy)
Date: Fri, 27 Sep 2013 08:28:08 -0600
Subject: [rust-dev] 0.8 release
Message-ID: <BAY405-EAS2978E99E10AF89A84F7AE1D88290@phx.gbl>

You have mingw installed with required packages installed?

Sent from my Windows Phone
________________________________
From: Renato Lenzi<mailto:rexlen at gmail.com>
Sent: ?9/?27/?2013 7:09
To: Rust-dev at mozilla.org<mailto:Rust-dev at mozilla.org>
Subject: [rust-dev] 0.8 release

Strange thing...
after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
doesn't start and Windows complains:

"the application was unable to start correctly (0xc0000005).
The worst thing is that reinstalling rust07 i get the same error...... now
i'm without Rust :-(

ideas?

Regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/9b707aa4/attachment.html>
-------------- next part --------------
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From vadimcn at gmail.com  Fri Sep 27 11:20:45 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 27 Sep 2013 11:20:45 -0700
Subject: [rust-dev] 0.8 release
In-Reply-To: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
References: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
Message-ID: <CADecdiJJdRnjoJf7qCk=e+bYA_1S4iZnHGY-DEOYTD8AGTHONw@mail.gmail.com>

Known issue: #5878 <https://github.com/mozilla/rust/issues/5878>.

At mingw prompt, run:
        mingw-get upgrade "g++<4.6"
        mingw-get upgrade "libpthread=2.8.0-3"

This will roll some components back to older version that Rust binaries
require.

You can then copy libgcc_s_dw2-1.dll, libstdc++-6.dll and libpthread-2.dll
from %mingw%\bin into Rust installation directory and run "mingw-get
upgrade" to go back to latest versions.

Vadim



On Fri, Sep 27, 2013 at 6:09 AM, Renato Lenzi <rexlen at gmail.com> wrote:

> Strange thing...
> after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
> doesn't start and Windows complains:
>
> "the application was unable to start correctly (0xc0000005).
> The worst thing is that reinstalling rust07 i get the same error...... now
> i'm without Rust :-(
>
> ideas?
>
> Regards.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/bffb4afe/attachment.html>

From ecreed at cs.washington.edu  Fri Sep 27 14:15:21 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Fri, 27 Sep 2013 14:15:21 -0700
Subject: [rust-dev] Rust session at Seattle CodeCamp, Sep 28th 2013
In-Reply-To: <CAEXt_aZHXgWn5rsOLn8K502-muTDp2QB_X9VFJEFgAOVytRfSg@mail.gmail.com>
References: <CAEXt_aYTOSxZ+RWSHg1vMkid1fCH0isWtb7FP6Z4PXGwpuy1cA@mail.gmail.com>
	<CA++BO6Qu1rGscs-XFPpuSBNrz343xGmMMatm0J1sy-WQViCdQg@mail.gmail.com>
	<CAPA4HGVBSo8MunC=paZeS3PXWHMfZ6OMd7Xe-9irMEEyiHDDHg@mail.gmail.com>
	<CAEXt_aZHXgWn5rsOLn8K502-muTDp2QB_X9VFJEFgAOVytRfSg@mail.gmail.com>
Message-ID: <CANbMr6GnguDX411DhcyrxVvC7Yx8cHSX5tUFTw+fzGjpiRomFQ@mail.gmail.com>

Sorry I'm only getting to this now; I've been busy moving.
I won't be able to make the presentation, but I can look over slides or
something today if you like.

Good luck!

Eric


On Wed, Sep 18, 2013 at 10:34 AM, Jeffery Olson <olson.jeffery at gmail.com>wrote:

>
>
>
> On Wed, Sep 18, 2013 at 9:45 AM, Luis de Bethencourt <
> luis at debethencourt.com> wrote:
>
>> I am also interested in watching a recording of this.
>>
>
> As terrified as I am of being recorded for posterity, it would probably be
> for the best.
>
>
>>
>> Having in mind that the website is specific to the 2013 edition of the
>> Codecamp, and there is no mention or links to the replaced 2012 website: I
>> doubt they record and share it on the web.
>> There is only one Seattle Codecamp talk in Youtube, and it is from 2010.
>>
>> Jeffery,
>> Could you try and get some friend to record the talk?
>>
>
> I can do a screen recording. That doesn't really cover audio (very well)
> .. can use the built-in mic on my laptop, if needed. I guess I'll see if I
> can rustle something up.
>
>
>>
>> Anybody that is going wants to help with this?
>>
>
> The only rustafarian that I know of who may be in the Seattle area at that
> time is ecr. He said he might make it, but that was a while back. I guess
> I'll follow up.
>
> If anyone else on the list is from Seattle and could make: now's your
> chance to speak up!
>
>
>
>>
>> Luis
>>
>>
>> On 17 September 2013 03:12, Corey Richardson <corey at octayn.net> wrote:
>>
>>> Awesome! Do you know if it will be recorded?
>>>
>>> On Mon, Sep 16, 2013 at 8:35 PM, Jeffery Olson <olson.jeffery at gmail.com>
>>> wrote:
>>> > Howdy,
>>> >
>>> > I've proposed, and received approval for, a session on Rust (clever
>>> titled
>>> > "The Rust Programming Language") for the upcoming 2013 Seattle
>>> CodeCamp. The
>>> > event is being held in Redmond, WA on the 28th of September at DigiPen.
>>> >
>>> > If you happen to be in the area and have nothing better to do on a
>>> Saturday,
>>> > please drop in and hang out with your fellow rust programmer(s) and
>>> help
>>> > minister to the heathens (joking! great crowd, truly).
>>> >
>>> > Session info at: https://seattle.codecamp.us/Sessions/Details/2366
>>> >
>>> > Registration, schedule, etc also available at the link cited.
>>> >
>>> > Cheers,
>>> > Jeff
>>> >
>>> > _______________________________________________
>>> > Rust-dev mailing list
>>> > Rust-dev at mozilla.org
>>> > https://mail.mozilla.org/listinfo/rust-dev
>>> >
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/695b5454/attachment.html>

From rexlen at gmail.com  Fri Sep 27 14:25:52 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Fri, 27 Sep 2013 23:25:52 +0200
Subject: [rust-dev] Fwd:  0.8 release
In-Reply-To: <CADecdiJJdRnjoJf7qCk=e+bYA_1S4iZnHGY-DEOYTD8AGTHONw@mail.gmail.com>
References: <CAM0XVguy333bF4nMwyr72G_GtxvX8XLKpkHVP81ti_wFL7e6cg@mail.gmail.com>
	<CADecdiJJdRnjoJf7qCk=e+bYA_1S4iZnHGY-DEOYTD8AGTHONw@mail.gmail.com>
Message-ID: <CAM0XVgvQ01MdpUXbBnj_oe7L21EXAw-Jyk-EdosjJeSap_L3kg@mail.gmail.com>

Oh yes.... this works fine.
Thank you.

.......................................

Known issue: #5878 <https://github.com/mozilla/rust/issues/5878>.

At mingw prompt, run:
        mingw-get upgrade "g++<4.6"
        mingw-get upgrade "libpthread=2.8.0-3"

This will roll some components back to older version that Rust binaries
require.

You can then copy libgcc_s_dw2-1.dll, libstdc++-6.dll and libpthread-2.dll
from %mingw%\bin into Rust installation directory and run "mingw-get
upgrade" to go back to latest versions.

Vadim



On Fri, Sep 27, 2013 at 6:09 AM, Renato Lenzi <rexlen at gmail.com> wrote:

> Strange thing...
> after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
> doesn't start and Windows complains:
>
> "the application was unable to start correctly (0xc0000005).
> The worst thing is that reinstalling rust07 i get the same error...... now
> i'm without Rust :-(
>
> ideas?
>
> Regards.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/c0d681f9/attachment.html>

From bjzaba at yahoo.com.au  Fri Sep 27 18:10:02 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 28 Sep 2013 11:10:02 +1000
Subject: [rust-dev] OpenGL: gl-rs updated with command line generation
	options
Message-ID: <2F288328-BD3C-479B-86D8-71C4C833967D@yahoo.com.au>

gl-rs[1] is an OpenGL function loader for Rust. It exposes the full OpenGL API, loading the function pointers at 
runtime to ensure portability between systems with different graphics drivers. This capability is extremely
important for developers who wish to make full use of state-of-the-art graphics hardware.

The recent changes by Corey Richardson allow for the specification of what is generated by the loader. This 
means you don't have to generate the entire spec, like you used to (which resulted in a 1.6mb file) 

    ./generator --version 3.3 --profile core
    ./generator --version 2.1 --extension GL_ARB_robustness --extension GL_EXT_draw_instanced

We have included a 4.3 core profile loader so that you can get up to speed quickly without having to spend time
generating the loader yourself. Hopefully with future updates to rustpkg you will be able to supply the generation
options at the `extern mod` line in your source code.

If you have any issues, questions or suggestions, you can contact me on irc.mozilla.org #rust-gamedev[2]. My 
handle is 'bjz'.

Hopefully this helps to give Rust an extra boost in the realm of high-performance graphics!


Regards,

Brendan Zabarauskas


[1]: https://github.com/bjz/gl-rs
[2]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-gamedev

From kenz.gelsoft at gmail.com  Fri Sep 27 20:51:16 2013
From: kenz.gelsoft at gmail.com (KENZ gelsoft)
Date: Sat, 28 Sep 2013 12:51:16 +0900
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <CAFrFfuF4pC97Y16MPdAMv6v8CEBYY6ROJ-vA=W=BL0AO4_814Q@mail.gmail.com>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
	<CAFrFfuGmGifthJ7CEythhD_eQfCrjcvaBn5bRPPJbTbNX7hNTw@mail.gmail.com>
	<CAKsNy6wBj=znj3XCcis5KX1q=67DcypzTFzmt=pxwPog3t0y7w@mail.gmail.com>
	<CAFrFfuF4pC97Y16MPdAMv6v8CEBYY6ROJ-vA=W=BL0AO4_814Q@mail.gmail.com>
Message-ID: <CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>

I tried rust-bindgen finally, and it worked excellently. Great work!!

Since it requires Clang 3.3 which doesn't exist on OS X 10.8 setup,
I tried commit 3d49dbbbb7bcc0cf63b43a16a6cf52480fa9b752 and some tweak.

And some arguments are needed, for my project:

    $ ./bindgen -x c++ ../wxRust/wxHaskell/wxc/src/include/wxc.h
`wx-config --cflags` --include stdint.h --include time.h >
../wxRust/generated.rs

bindgen is C mode as default like clang or gcc are, so I understand it
requires `-x c++` option,
but I don't know why I have to explicitly include stdint.h and time.h
for size_t and uint8_t.
Do you have another recommended options?

My codegen.py just handles functions, so handling for other
definitions benefits.
So I want adopt rust-bindgen to generate extern fn part of my binding
for long-term plan.

Despite I know its Clang requirement changed for bitwidth support, but
as a Mac developer, I don't want to install the Clang 3.3 only for rust-bindgen,
especially I don't want add a new prerequisite to my library.
Are there a posibility of optional Clang 3.1 support (without bitwidth support)?



2013/9/26 Martin DeMello <martindemello at gmail.com>:
> no, but it might be feasible to add. not sure if it'd fall within the
> scope of bindgen or not, but at least bindgen could emit some sort of
> serialised data structure that would make generating the next level
> binding easier.
>
> martin
>
> On Wed, Sep 25, 2013 at 4:49 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
>> Oh, I didn't know that project, thank you for information. I'll try it.
>> BTW, I chose to make own parser and generator to generate not only extern fn
>> decls but also next-level wrapper such as:
>>
>> trait Frame {
>>   pub fn show(&self) {
>>     unsafe {
>>       wxFrame_Show(self.handle());
>>     }
>>   }
>> }
>>
>> or so, would bindgen helps this use case? (c.f. parsed data accessible or
>> so.)
>>
>> Did you try using bindgen on the wxc header file? If there were bits
>> it couldn't handle, I'd be interested in helping fix that.
>>
>> martin
>>
>> On Wed, Sep 25, 2013 at 10:49 AM, KENZ gelsoft <kenz.gelsoft at gmail.com>
>> wrote:
>>> Hello, everyone.
>>>
>>> I would like to introduce my experimental project, wxRust.
>>> Which is a wxWidgets binding for Rust.
>>>
>>>   https://github.com/kenz-gelsoft/wxRust
>>>
>>> This binding is based on the wxHaskell especially its "wxc"*1
>>> C-Language wxWidgets binding part.
>>>
>>> Currently, it just converts wxc's header file to `extern fn`s and
>>> export them as a rust library.
>>>
>>> Test program has just started working which opens a wxFrame
>>> by calling wxc's C interface from extern fn.
>>>
>>> Current state is pre-alpha experimental state, there's no stable API,
>>> hard to use, but announced here for someone planning similar project.
>>>
>>> I'm planning for next generating simple OOP style wrapper as rust
>>> traits for each classes from wxc's header.
>>>
>>> There is many problems to tackle, for example how it can work
>>> with multitask or, library users can write wx GUI programs easier.
>>> Any helps or feedbacks are welcome.
>>>
>>>  *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>>>
>>>
>>> Thanks,
>>> --
>>> KENZ <KENZ.gelsoft at gmail.com>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>

From slabode at aim.com  Fri Sep 27 21:44:49 2013
From: slabode at aim.com (SiegeLord)
Date: Sat, 28 Sep 2013 00:44:49 -0400 (EDT)
Subject: [rust-dev] Crate-scoped non-trait implementations
Message-ID: <8D08A1C9948B1B4-1FC4-1D421@webmail-d154.sysops.aol.com>

Given the proposed privacy resolution rules ( 
https://github.com/mozilla/rust/issues/8215#issuecomment-24762188 ) 
there exists a concept of crate-scope for items: these can be used 
within the implementation of the crate, but are inaccessible from other 
crates. This is easy to do by introducing a private module:

mod private
{
    pub fn crate_scoped_fn();
    pub trait CrateScopedTrait;
    pub struct CrateScopedStruct;
}

It's not clear to me whether or not this is possible (or whether it 
should be) for non-trait implementations. Right now, if I do this:

pub struct S;
mod private
{
    impl super::S
    {
        pub fn new() -> super::S { super::S }
        pub fn crate_local_api(&self) -> {}
    }
}

I find that the associated function can't be used at all within a crate 
or cross crate (issue #9584), while the method resolves in both cases, 
but does not link cross-crate. What should happen in this case? I'd 
prefer for the function and method to resolve within a crate, but not 
cross crate.

Notably, this is not how trait implementations work today, as those are 
resolved by looking at the location/privacy of the trait and not the 
implementation.  I think crate-scoped methods and associated functions 
are very useful though, and it's worthwhile to have a different rule 
for them.

Or maybe there should be an explicit keyword for the crate scope and 
not bother with these bizarre privacy rules. Or maybe I am missing an 
alternate way to accomplish this?

-SL

From kevin at sb.org  Fri Sep 27 22:43:09 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 27 Sep 2013 22:43:09 -0700
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
	<CAFrFfuGmGifthJ7CEythhD_eQfCrjcvaBn5bRPPJbTbNX7hNTw@mail.gmail.com>
	<CAKsNy6wBj=znj3XCcis5KX1q=67DcypzTFzmt=pxwPog3t0y7w@mail.gmail.com>
	<CAFrFfuF4pC97Y16MPdAMv6v8CEBYY6ROJ-vA=W=BL0AO4_814Q@mail.gmail.com>
	<CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>
Message-ID: <567F095A-88BA-4AD9-A2C1-34C7793ECEB1@sb.org>

As a Mac developer, you should have Xcode 5.0 installed, which comes with Clang 5.0 (based on LLVM 3.3svn), which is roughly equivalent to open-source Clang 3.3.

-Kevin

On Sep 27, 2013, at 8:51 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:

> I tried rust-bindgen finally, and it worked excellently. Great work!!
> 
> Since it requires Clang 3.3 which doesn't exist on OS X 10.8 setup,
> I tried commit 3d49dbbbb7bcc0cf63b43a16a6cf52480fa9b752 and some tweak.
> 
> And some arguments are needed, for my project:
> 
>    $ ./bindgen -x c++ ../wxRust/wxHaskell/wxc/src/include/wxc.h
> `wx-config --cflags` --include stdint.h --include time.h >
> ../wxRust/generated.rs
> 
> bindgen is C mode as default like clang or gcc are, so I understand it
> requires `-x c++` option,
> but I don't know why I have to explicitly include stdint.h and time.h
> for size_t and uint8_t.
> Do you have another recommended options?
> 
> My codegen.py just handles functions, so handling for other
> definitions benefits.
> So I want adopt rust-bindgen to generate extern fn part of my binding
> for long-term plan.
> 
> Despite I know its Clang requirement changed for bitwidth support, but
> as a Mac developer, I don't want to install the Clang 3.3 only for rust-bindgen,
> especially I don't want add a new prerequisite to my library.
> Are there a posibility of optional Clang 3.1 support (without bitwidth support)?
> 
> 
> 
> 2013/9/26 Martin DeMello <martindemello at gmail.com>:
>> no, but it might be feasible to add. not sure if it'd fall within the
>> scope of bindgen or not, but at least bindgen could emit some sort of
>> serialised data structure that would make generating the next level
>> binding easier.
>> 
>> martin
>> 
>> On Wed, Sep 25, 2013 at 4:49 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
>>> Oh, I didn't know that project, thank you for information. I'll try it.
>>> BTW, I chose to make own parser and generator to generate not only extern fn
>>> decls but also next-level wrapper such as:
>>> 
>>> trait Frame {
>>>  pub fn show(&self) {
>>>    unsafe {
>>>      wxFrame_Show(self.handle());
>>>    }
>>>  }
>>> }
>>> 
>>> or so, would bindgen helps this use case? (c.f. parsed data accessible or
>>> so.)
>>> 
>>> Did you try using bindgen on the wxc header file? If there were bits
>>> it couldn't handle, I'd be interested in helping fix that.
>>> 
>>> martin
>>> 
>>> On Wed, Sep 25, 2013 at 10:49 AM, KENZ gelsoft <kenz.gelsoft at gmail.com>
>>> wrote:
>>>> Hello, everyone.
>>>> 
>>>> I would like to introduce my experimental project, wxRust.
>>>> Which is a wxWidgets binding for Rust.
>>>> 
>>>>  https://github.com/kenz-gelsoft/wxRust
>>>> 
>>>> This binding is based on the wxHaskell especially its "wxc"*1
>>>> C-Language wxWidgets binding part.
>>>> 
>>>> Currently, it just converts wxc's header file to `extern fn`s and
>>>> export them as a rust library.
>>>> 
>>>> Test program has just started working which opens a wxFrame
>>>> by calling wxc's C interface from extern fn.
>>>> 
>>>> Current state is pre-alpha experimental state, there's no stable API,
>>>> hard to use, but announced here for someone planning similar project.
>>>> 
>>>> I'm planning for next generating simple OOP style wrapper as rust
>>>> traits for each classes from wxc's header.
>>>> 
>>>> There is many problems to tackle, for example how it can work
>>>> with multitask or, library users can write wx GUI programs easier.
>>>> Any helps or feedbacks are welcome.
>>>> 
>>>> *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>>>> 
>>>> 
>>>> Thanks,
>>>> --
>>>> KENZ <KENZ.gelsoft at gmail.com>
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From kenz.gelsoft at gmail.com  Fri Sep 27 23:07:23 2013
From: kenz.gelsoft at gmail.com (KENZ gelsoft)
Date: Sat, 28 Sep 2013 15:07:23 +0900
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <567F095A-88BA-4AD9-A2C1-34C7793ECEB1@sb.org>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
	<CAFrFfuGmGifthJ7CEythhD_eQfCrjcvaBn5bRPPJbTbNX7hNTw@mail.gmail.com>
	<CAKsNy6wBj=znj3XCcis5KX1q=67DcypzTFzmt=pxwPog3t0y7w@mail.gmail.com>
	<CAFrFfuF4pC97Y16MPdAMv6v8CEBYY6ROJ-vA=W=BL0AO4_814Q@mail.gmail.com>
	<CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>
	<567F095A-88BA-4AD9-A2C1-34C7793ECEB1@sb.org>
Message-ID: <CAKsNy6yQF7F8k9M4gMg8jTeVEC2vnN-B8ZQ0womoMmiNF6a7gw@mail.gmail.com>

Oh, I didn't know Xcode 5.0 comes with LLVM 3.3 based clang. Thanks a lot.
If so, indeed depending on Clang 3.3 is reasonable enough!

2013/9/28 Kevin Ballard <kevin at sb.org>:
> As a Mac developer, you should have Xcode 5.0 installed, which comes with Clang 5.0 (based on LLVM 3.3svn), which is roughly equivalent to open-source Clang 3.3.
>
> -Kevin
>
> On Sep 27, 2013, at 8:51 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
>
>> I tried rust-bindgen finally, and it worked excellently. Great work!!
>>
>> Since it requires Clang 3.3 which doesn't exist on OS X 10.8 setup,
>> I tried commit 3d49dbbbb7bcc0cf63b43a16a6cf52480fa9b752 and some tweak.
>>
>> And some arguments are needed, for my project:
>>
>>    $ ./bindgen -x c++ ../wxRust/wxHaskell/wxc/src/include/wxc.h
>> `wx-config --cflags` --include stdint.h --include time.h >
>> ../wxRust/generated.rs
>>
>> bindgen is C mode as default like clang or gcc are, so I understand it
>> requires `-x c++` option,
>> but I don't know why I have to explicitly include stdint.h and time.h
>> for size_t and uint8_t.
>> Do you have another recommended options?
>>
>> My codegen.py just handles functions, so handling for other
>> definitions benefits.
>> So I want adopt rust-bindgen to generate extern fn part of my binding
>> for long-term plan.
>>
>> Despite I know its Clang requirement changed for bitwidth support, but
>> as a Mac developer, I don't want to install the Clang 3.3 only for rust-bindgen,
>> especially I don't want add a new prerequisite to my library.
>> Are there a posibility of optional Clang 3.1 support (without bitwidth support)?
>>
>>
>>
>> 2013/9/26 Martin DeMello <martindemello at gmail.com>:
>>> no, but it might be feasible to add. not sure if it'd fall within the
>>> scope of bindgen or not, but at least bindgen could emit some sort of
>>> serialised data structure that would make generating the next level
>>> binding easier.
>>>
>>> martin
>>>
>>> On Wed, Sep 25, 2013 at 4:49 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
>>>> Oh, I didn't know that project, thank you for information. I'll try it.
>>>> BTW, I chose to make own parser and generator to generate not only extern fn
>>>> decls but also next-level wrapper such as:
>>>>
>>>> trait Frame {
>>>>  pub fn show(&self) {
>>>>    unsafe {
>>>>      wxFrame_Show(self.handle());
>>>>    }
>>>>  }
>>>> }
>>>>
>>>> or so, would bindgen helps this use case? (c.f. parsed data accessible or
>>>> so.)
>>>>
>>>> Did you try using bindgen on the wxc header file? If there were bits
>>>> it couldn't handle, I'd be interested in helping fix that.
>>>>
>>>> martin
>>>>
>>>> On Wed, Sep 25, 2013 at 10:49 AM, KENZ gelsoft <kenz.gelsoft at gmail.com>
>>>> wrote:
>>>>> Hello, everyone.
>>>>>
>>>>> I would like to introduce my experimental project, wxRust.
>>>>> Which is a wxWidgets binding for Rust.
>>>>>
>>>>>  https://github.com/kenz-gelsoft/wxRust
>>>>>
>>>>> This binding is based on the wxHaskell especially its "wxc"*1
>>>>> C-Language wxWidgets binding part.
>>>>>
>>>>> Currently, it just converts wxc's header file to `extern fn`s and
>>>>> export them as a rust library.
>>>>>
>>>>> Test program has just started working which opens a wxFrame
>>>>> by calling wxc's C interface from extern fn.
>>>>>
>>>>> Current state is pre-alpha experimental state, there's no stable API,
>>>>> hard to use, but announced here for someone planning similar project.
>>>>>
>>>>> I'm planning for next generating simple OOP style wrapper as rust
>>>>> traits for each classes from wxc's header.
>>>>>
>>>>> There is many problems to tackle, for example how it can work
>>>>> with multitask or, library users can write wx GUI programs easier.
>>>>> Any helps or feedbacks are welcome.
>>>>>
>>>>> *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>>>>>
>>>>>
>>>>> Thanks,
>>>>> --
>>>>> KENZ <KENZ.gelsoft at gmail.com>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>

From dbau.pp at gmail.com  Sat Sep 28 07:52:21 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 29 Sep 2013 00:52:21 +1000
Subject: [rust-dev] IRFY lives!
Message-ID: <5246ED25.1030409@gmail.com>

Hi all,

The memory benchmarks on IsRustFastYet 
(http://huonw.github.io/isrustfastyet/mem/) have been on a bit of a 
hiatus, but they're back thanks to cmr's hard-working hardware (as well 
as a little Rust program that we collaborated on to allow him to build 
600+ of bors' merges automagically: https://github.com/huonw/multibuilder)

Since the beginning of August when IRFY dropped out, there have been 4 
regressions (in the commits benchmarked so far), in chronological order:
- #8235 (500 MB!), which introduced the trait based visitor as a start 
for replacing the @fn one (this is actually filed as 
https://github.com/mozilla/rust/issues/8589)
- #8527 (60 MB), "Visitor trait rewrite, step 1." continuing the 
(necessary) work above
- #9278 (60 MB), "Invert --cfg debug to --cfg ndebug"
- #9261 (130 MB), "Refactor the logging system for fewer allocations" (I 
believe acrichto may be investigating this one already)

Highlighted: 
http://huonw.github.io/isrustfastyet/mem/#2fd3c07,77739a7,1434b4b,2a7be1c

Due to the large backlog, we're not taking accurate time measurements, 
just memory recordings, so the red dashed line is missing for most of 
the new ones.

Huon


https://github.com/mozilla/rust/pull/8235
https://github.com/mozilla/rust/pull/8527
https://github.com/mozilla/rust/pull/9278
https://github.com/mozilla/rust/pull/9261

From googletoday009 at 163.com  Sat Sep 28 09:27:04 2013
From: googletoday009 at 163.com (lambda)
Date: Sun, 29 Sep 2013 00:27:04 +0800 (CST)
Subject: [rust-dev] Rust-dev Digest, Vol 39, Issue 86
In-Reply-To: <mailman.27.1380308402.19261.rust-dev@mozilla.org>
References: <mailman.27.1380308402.19261.rust-dev@mozilla.org>
Message-ID: <356fa6a1.13e13.14165651040.Coremail.googletoday009@163.com>

On my Windows XP,I got this error,which i compile the code:
warning: got 1 RUST_LOG specs but only matched 0 of them.
You may have mistyped a RUST_LOG spec.
Use RUST_LOG=::help to see the list of crates and modules.

task &lt;unnamed&gt; failed at 'failure in CreateProcess: The system cannot find the file specified.
', C:\bot\slave\dist2-win\build\src\libstd\run.rs:532
error: internal compiler error: unexpected failure
note: the compiler hit an unexpected failure path. this is a bug
note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
task &lt;unnamed&gt; failed at 'explicit failure', c:\bot\slave\dist2-win\build\src\librustc\rustc.rs:391
At 2013-09-28 03:00:02,rust-dev-request at mozilla.org wrote:
>Send Rust-dev mailing list submissions to
>	rust-dev at mozilla.org
>
>To subscribe or unsubscribe via the World Wide Web, visit
>	https://mail.mozilla.org/listinfo/rust-dev
>or, via email, send a message with subject or body 'help' to
>	rust-dev-request at mozilla.org
>
>You can reach the person managing the list at
>	rust-dev-owner at mozilla.org
>
>When replying, please edit your Subject line so it is more specific
>than "Re: Contents of Rust-dev digest..."
>
>
>Today's Topics:
>
>   1. Re:  0.8 release (Aaron Dandy)
>   2. Re:  0.8 release (Vadim)
>
>
>----------------------------------------------------------------------
>
>Message: 1
>Date: Fri, 27 Sep 2013 08:28:08 -0600
>From: Aaron Dandy <aaron.dandy at live.com>
>To: Renato Lenzi <rexlen at gmail.com>, "Rust-dev at mozilla.org"
>	<Rust-dev at mozilla.org>
>Subject: Re: [rust-dev] 0.8 release
>Message-ID: <BAY405-EAS2978E99E10AF89A84F7AE1D88290 at phx.gbl>
>Content-Type: text/plain; charset="utf-8"
>
>You have mingw installed with required packages installed?
>
>Sent from my Windows Phone
>________________________________
>From: Renato Lenzi<mailto:rexlen at gmail.com>
>Sent: ?9/?27/?2013 7:09
>To: Rust-dev at mozilla.org<mailto:Rust-dev at mozilla.org>
>Subject: [rust-dev] 0.8 release
>
>Strange thing...
>after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
>doesn't start and Windows complains:
>
>"the application was unable to start correctly (0xc0000005).
>The worst thing is that reinstalling rust07 i get the same error...... now
>i'm without Rust :-(
>
>ideas?
>
>Regards.
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/9b707aa4/attachment-0001.html>
>-------------- next part --------------
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev
>
>------------------------------
>
>Message: 2
>Date: Fri, 27 Sep 2013 11:20:45 -0700
>From: Vadim <vadimcn at gmail.com>
>To: Renato Lenzi <rexlen at gmail.com>
>Cc: "rust-dev at mozilla.org" <Rust-dev at mozilla.org>
>Subject: Re: [rust-dev] 0.8 release
>Message-ID:
>	<CADecdiJJdRnjoJf7qCk=e+bYA_1S4iZnHGY-DEOYTD8AGTHONw at mail.gmail.com>
>Content-Type: text/plain; charset="iso-8859-1"
>
>Known issue: #5878 <https://github.com/mozilla/rust/issues/5878>.
>
>At mingw prompt, run:
>        mingw-get upgrade "g++<4.6"
>        mingw-get upgrade "libpthread=2.8.0-3"
>
>This will roll some components back to older version that Rust binaries
>require.
>
>You can then copy libgcc_s_dw2-1.dll, libstdc++-6.dll and libpthread-2.dll
>from %mingw%\bin into Rust installation directory and run "mingw-get
>upgrade" to go back to latest versions.
>
>Vadim
>
>
>
>On Fri, Sep 27, 2013 at 6:09 AM, Renato Lenzi <rexlen at gmail.com> wrote:
>
>> Strange thing...
>> after installing rust 08 on W7 System rustc.exe (or rust.exe or rusti.exe)
>> doesn't start and Windows complains:
>>
>> "the application was unable to start correctly (0xc0000005).
>> The worst thing is that reinstalling rust07 i get the same error...... now
>> i'm without Rust :-(
>>
>> ideas?
>>
>> Regards.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>-------------- next part --------------
>An HTML attachment was scrubbed...
>URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/bffb4afe/attachment-0001.html>
>
>------------------------------
>
>Subject: Digest Footer
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev
>
>
>------------------------------
>
>End of Rust-dev Digest, Vol 39, Issue 86
>****************************************


From dpx.infinity at gmail.com  Sat Sep 28 13:42:02 2013
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 29 Sep 2013 00:42:02 +0400
Subject: [rust-dev] Trait method self parameter type clashes with lifetime
 annotation required by the implementation
Message-ID: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>

Hi all,

The problem I'm writing about in this message follows from the one I
have described in my other message:
https://mail.mozilla.org/pipermail/rust-dev/2013-August/005281.html .
I believe I'm now able to formulate it more clearly.

Consider the following example code:

trait Walker {  // Some business-logic trait
    fn walk(&mut self);
}

// A struct which is intended to be an implementor of Walker trait
// Note that it has lifetime parameter in order to work for any kind
// of pointer to a Reader
struct ReaderContainer<'self> {
    priv reader: &'self Reader,
    priv counter: int
}

// Some auxiliary structure for ReaderContainer
// It may be anything but it should have a reference to ReaderContainer
// We have to use lifetime parameter because this structure is 'attached'
// to ReaderContainer, hence it must be of the same lifetime
struct ReaderContainerIterator<'self> {
    priv container: &'self mut ReaderContainer<'self>
}

// Some made-up implementation of iterator protocol for our
// auxiliary structure, it does not really matter
impl<'self> Iterator<u8> for ReaderContainerIterator<'self> {
    fn next(&mut self) -> Option<u8> {
        if self.container.counter < 10 {
            self.container.counter += 1;
            Some(self.container.reader.read_byte() as u8)
        } else {
            None
        }
    }
}

impl<'self> ReaderContainer<'self> {
    // A constructor for ReaderContainer, nothing special
    fn new<'a>(reader: &'a Reader) -> ReaderContainer<'a> {
        ReaderContainer { reader: reader, counter: 0 }
    }

    // A method which returns our auxiliary structure, i.e. iterator
    // Note that self parameter has lifetime 'self, otherwise this naturally
    // does not compile
    fn iter(&'self mut self) -> ReaderContainerIterator<'self> {
        ReaderContainerIterator { container: self }
    }
}

// Here is the problem: we cannot implement Walker trait!
impl<'self> Walker for ReaderContainer<'self> {
    // See below for concrete errors description
    fn walk(&mut self) {  // <<<
        for b in self.iter() {
            println(fmt!("byte %?", b));
        }
    }
}

fn main() {
    use std::io;

    let r = io::stdin();
    let mut c = ReaderContainer::new(r);

    c.walk();
}


This program does not compile with the following error:

temp.rs:52:17: 52:30 error: cannot infer an appropriate lifetime due
to conflicting requirements
temp.rs:52         for b in self.iter() {
                            ^~~~~~~~~~~~~
temp.rs:52:17: 52:22 note: first, the lifetime cannot outlive the
expression at 52:17...
temp.rs:52         for b in self.iter() {
                            ^~~~~
temp.rs:52:17: 52:22 note: ...due to the following expression
temp.rs:52         for b in self.iter() {
                            ^~~~~
temp.rs:52:17: 52:30 note: but, the lifetime must be valid for the
method call at 52:17...
temp.rs:52         for b in self.iter() {
                            ^~~~~~~~~~~~~
temp.rs:52:17: 52:22 note: ...due to the following expression
temp.rs:52         for b in self.iter() {
                            ^~~~~
error: aborting due to previous error

This is somewhat expected, because `self` in `walk()` method
implementation does not have 'self lifetime, so it is impossible to
call `iter()` method which needs concrete 'self lifetime. But I cannot
mark it with 'self lifetime either! If I do mark it with 'self:

    fn walk(&'self mut self) {  // <<<
        for b in self.iter() {
            println(fmt!("byte %?", b));
        }
    }

Then the program fails to compile with another message:

temp.rs:51:4: 55:5 error: method `walk` has an incompatible type:
expected concrete lifetime, but found bound lifetime parameter &
temp.rs:51     fn walk(&'self mut self) {  // <<<
temp.rs:52         for b in self.iter() {
temp.rs:53             println(fmt!("byte %?", b));
temp.rs:54         }
temp.rs:55     }
temp.rs:51:29: 55:5 note: expected concrete lifetime is the lifetime
&'self  as defined on the block at 51:29
temp.rs:51     fn walk(&'self mut self) {  // <<<
temp.rs:52         for b in self.iter() {
temp.rs:53             println(fmt!("byte %?", b));
temp.rs:54         }
temp.rs:55     }
error: aborting due to previous error

This is also expected: adding 'self lifetime violates `Walker` trait
signature, in which `walk()` method has plain `&mut self` parameter.

So, this is kind of dead end. I think this problem may be formulated
in short as follows: how to implement generic traits for structures
which have lifetime parameters which are used for `self` parameter in
structure methods implementations?

How to do what I want to do? Is it possible at all?

Regards,
Vladimir.

From dwrenshaw at gmail.com  Sat Sep 28 14:16:21 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Sat, 28 Sep 2013 17:16:21 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
Message-ID: <CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>

If I add an unused parameter of type Option<&'self ()> to the walk()
method, I can get your example to compile:
https://gist.github.com/dwrensha/29ed998566e2f9218c18

On Sat, Sep 28, 2013 at 4:42 PM, Vladimir Matveev
<dpx.infinity at gmail.com> wrote:
> Hi all,
>
> The problem I'm writing about in this message follows from the one I
> have described in my other message:
> https://mail.mozilla.org/pipermail/rust-dev/2013-August/005281.html .
> I believe I'm now able to formulate it more clearly.
>
> Consider the following example code:
>
> trait Walker {  // Some business-logic trait
>     fn walk(&mut self);
> }
>
> // A struct which is intended to be an implementor of Walker trait
> // Note that it has lifetime parameter in order to work for any kind
> // of pointer to a Reader
> struct ReaderContainer<'self> {
>     priv reader: &'self Reader,
>     priv counter: int
> }
>
> // Some auxiliary structure for ReaderContainer
> // It may be anything but it should have a reference to ReaderContainer
> // We have to use lifetime parameter because this structure is 'attached'
> // to ReaderContainer, hence it must be of the same lifetime
> struct ReaderContainerIterator<'self> {
>     priv container: &'self mut ReaderContainer<'self>
> }
>
> // Some made-up implementation of iterator protocol for our
> // auxiliary structure, it does not really matter
> impl<'self> Iterator<u8> for ReaderContainerIterator<'self> {
>     fn next(&mut self) -> Option<u8> {
>         if self.container.counter < 10 {
>             self.container.counter += 1;
>             Some(self.container.reader.read_byte() as u8)
>         } else {
>             None
>         }
>     }
> }
>
> impl<'self> ReaderContainer<'self> {
>     // A constructor for ReaderContainer, nothing special
>     fn new<'a>(reader: &'a Reader) -> ReaderContainer<'a> {
>         ReaderContainer { reader: reader, counter: 0 }
>     }
>
>     // A method which returns our auxiliary structure, i.e. iterator
>     // Note that self parameter has lifetime 'self, otherwise this naturally
>     // does not compile
>     fn iter(&'self mut self) -> ReaderContainerIterator<'self> {
>         ReaderContainerIterator { container: self }
>     }
> }
>
> // Here is the problem: we cannot implement Walker trait!
> impl<'self> Walker for ReaderContainer<'self> {
>     // See below for concrete errors description
>     fn walk(&mut self) {  // <<<
>         for b in self.iter() {
>             println(fmt!("byte %?", b));
>         }
>     }
> }
>
> fn main() {
>     use std::io;
>
>     let r = io::stdin();
>     let mut c = ReaderContainer::new(r);
>
>     c.walk();
> }
>
>
> This program does not compile with the following error:
>
> temp.rs:52:17: 52:30 error: cannot infer an appropriate lifetime due
> to conflicting requirements
> temp.rs:52         for b in self.iter() {
>                             ^~~~~~~~~~~~~
> temp.rs:52:17: 52:22 note: first, the lifetime cannot outlive the
> expression at 52:17...
> temp.rs:52         for b in self.iter() {
>                             ^~~~~
> temp.rs:52:17: 52:22 note: ...due to the following expression
> temp.rs:52         for b in self.iter() {
>                             ^~~~~
> temp.rs:52:17: 52:30 note: but, the lifetime must be valid for the
> method call at 52:17...
> temp.rs:52         for b in self.iter() {
>                             ^~~~~~~~~~~~~
> temp.rs:52:17: 52:22 note: ...due to the following expression
> temp.rs:52         for b in self.iter() {
>                             ^~~~~
> error: aborting due to previous error
>
> This is somewhat expected, because `self` in `walk()` method
> implementation does not have 'self lifetime, so it is impossible to
> call `iter()` method which needs concrete 'self lifetime. But I cannot
> mark it with 'self lifetime either! If I do mark it with 'self:
>
>     fn walk(&'self mut self) {  // <<<
>         for b in self.iter() {
>             println(fmt!("byte %?", b));
>         }
>     }
>
> Then the program fails to compile with another message:
>
> temp.rs:51:4: 55:5 error: method `walk` has an incompatible type:
> expected concrete lifetime, but found bound lifetime parameter &
> temp.rs:51     fn walk(&'self mut self) {  // <<<
> temp.rs:52         for b in self.iter() {
> temp.rs:53             println(fmt!("byte %?", b));
> temp.rs:54         }
> temp.rs:55     }
> temp.rs:51:29: 55:5 note: expected concrete lifetime is the lifetime
> &'self  as defined on the block at 51:29
> temp.rs:51     fn walk(&'self mut self) {  // <<<
> temp.rs:52         for b in self.iter() {
> temp.rs:53             println(fmt!("byte %?", b));
> temp.rs:54         }
> temp.rs:55     }
> error: aborting due to previous error
>
> This is also expected: adding 'self lifetime violates `Walker` trait
> signature, in which `walk()` method has plain `&mut self` parameter.
>
> So, this is kind of dead end. I think this problem may be formulated
> in short as follows: how to implement generic traits for structures
> which have lifetime parameters which are used for `self` parameter in
> structure methods implementations?
>
> How to do what I want to do? Is it possible at all?
>
> Regards,
> Vladimir.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From dwrenshaw at gmail.com  Sat Sep 28 14:20:15 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Sat, 28 Sep 2013 17:20:15 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
Message-ID: <CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>

If I drop the unused parameter, I get an internal compiler error:
'assertion failed: self.variance.is_some()'

From svfuerst at gmail.com  Fri Sep 27 18:53:18 2013
From: svfuerst at gmail.com (Steven Fuerst)
Date: Fri, 27 Sep 2013 18:53:18 -0700
Subject: [rust-dev] Nedit syntax highlighting for Rust
Message-ID: <CAOqL70=d684WVeB8BbvYofxXhDg1tvznC8Fv8W8M+=jO4Q6u4g@mail.gmail.com>

In case anyone is interested... here are some syntax highlighting regexes
for the nedit editor for rust.  Just add to your .nedit
"nedit.highlightPatterns:" section.

Rust:1:0{\n\
Macro:"[\\l_]\\w*!":::Preprocessor1::D\n\
Function:"fn ([\\l_]\\w*)":::Keyword::D\n\
Function name:"\\1":""::Subroutine:Function:DC\n\
Module:"(?:[\\l_]\\w*::|::)":::Identifier2::\n\
Keyword:"<(?:as|fn|break|copy|if|else|drop|in|do|for|while|loop|return|trait|type|unsafe|use|let|match|print|println|mod|self|super|priv|pub|use|impl|false|true)>":::Keyword::D\n\
Storage Type:"<(?:mut|static|extern|struct|enum|ref)>":::Storage Type1::\n\
Numeric:"(?<!\\Y)(?:(?:0(?:x|X)[\\da-fA-F_]*)|(?:(?:\\d+\\.?\\d*)|(?:\\.\\d+)|_)(?:(?:e|E)(?:\\+|-)?\\d+)?(?:f32|f64)?)(?:L|l|u|U|F|f|u8|u16|u32|u64|i8|i16|i32|i64)?(?!\\Y)":::Numeric
Const::D\n\
String:"""":""""::String::\n\
String escape chars:"\\\\(?:.|\\n)":::String2:String:\n\
Storage:"<(?:float|f32|f64|int|i8|i16|i32|i64|uint|u8|u16|u32|u64|bool)>":::Storage
Type::\n\
Braces:"[{}]":::Keyword::D\n\
C99comment:"//":"$"::Comment::\n\
Comment:"/\\*":"\\*/"::Comment::\n\
Operators:"(?:-\\>|=\\>|\\(\\*\\))":::Operator::\n\
Generic:"\\<(?!\\s)":"\\>(?! *\\>)(?!,)":"[|;""=$-]":Pointer::\n\
Module Generic:"(?:[\\l_]\\w*::|::)":::Identifier1:Generic:\n\
Character:"'[\\\\\\w]*'":::Character Const::\n\
Pragma:"#\\[":"\\]"::Preprocessor::\n\
Pragma String:"""":"""":"\\n":String1:Pragma:\n\
Definition:"[a-z_]+[a-z\\d_]*[ ]*:":::Bold::\n\
String fmt:"\\{":"\\}":"""":Text Arg1:String:\n\
String fmt2:"\\{":"\\}":"(?:\\{|"")":Text Escape:String fmt:\n\
Lambda Params:"(?:(?<=[\\(,=])
*\\|[^\\n|]*\\||\\|[^\\n|]*\\|(?=\\s*\\{))":::Chocolate::\n\
}

I've used some hacks to get generics looking okay... but it mostly works.

Steven
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130927/5bf648ff/attachment.html>

From martindemello at gmail.com  Sat Sep 28 21:42:59 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Sat, 28 Sep 2013 21:42:59 -0700
Subject: [rust-dev] Introducing wxRust
In-Reply-To: <CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>
References: <CAKsNy6z=4LTm4Hvk7BoaWL5B8qScTOyADTLPaZYG-WSy7ginCg@mail.gmail.com>
	<CAFrFfuGmGifthJ7CEythhD_eQfCrjcvaBn5bRPPJbTbNX7hNTw@mail.gmail.com>
	<CAKsNy6wBj=znj3XCcis5KX1q=67DcypzTFzmt=pxwPog3t0y7w@mail.gmail.com>
	<CAFrFfuF4pC97Y16MPdAMv6v8CEBYY6ROJ-vA=W=BL0AO4_814Q@mail.gmail.com>
	<CAKsNy6zrkvejLVYsvTjZTWZt0getLhvL5AxTBRDt22XK-9CWVQ@mail.gmail.com>
Message-ID: <CAFrFfuEoMaaYveAuj7+o1gvDj7h-7bDYzTLuR_F61KPYZz1p0w@mail.gmail.com>

I can't take any credit for rust-bindgen :) I can't even answer your
questions right now, since I just started contributing to the project.
But it is indeed a great piece of work, and the author is responsive
to patches, so I'd be happy to work on it to make it meet your needs.

martin

On Fri, Sep 27, 2013 at 8:51 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
> I tried rust-bindgen finally, and it worked excellently. Great work!!
>
> Since it requires Clang 3.3 which doesn't exist on OS X 10.8 setup,
> I tried commit 3d49dbbbb7bcc0cf63b43a16a6cf52480fa9b752 and some tweak.
>
> And some arguments are needed, for my project:
>
>     $ ./bindgen -x c++ ../wxRust/wxHaskell/wxc/src/include/wxc.h
> `wx-config --cflags` --include stdint.h --include time.h >
> ../wxRust/generated.rs
>
> bindgen is C mode as default like clang or gcc are, so I understand it
> requires `-x c++` option,
> but I don't know why I have to explicitly include stdint.h and time.h
> for size_t and uint8_t.
> Do you have another recommended options?
>
> My codegen.py just handles functions, so handling for other
> definitions benefits.
> So I want adopt rust-bindgen to generate extern fn part of my binding
> for long-term plan.
>
> Despite I know its Clang requirement changed for bitwidth support, but
> as a Mac developer, I don't want to install the Clang 3.3 only for rust-bindgen,
> especially I don't want add a new prerequisite to my library.
> Are there a posibility of optional Clang 3.1 support (without bitwidth support)?
>
>
>
> 2013/9/26 Martin DeMello <martindemello at gmail.com>:
>> no, but it might be feasible to add. not sure if it'd fall within the
>> scope of bindgen or not, but at least bindgen could emit some sort of
>> serialised data structure that would make generating the next level
>> binding easier.
>>
>> martin
>>
>> On Wed, Sep 25, 2013 at 4:49 PM, KENZ gelsoft <kenz.gelsoft at gmail.com> wrote:
>>> Oh, I didn't know that project, thank you for information. I'll try it.
>>> BTW, I chose to make own parser and generator to generate not only extern fn
>>> decls but also next-level wrapper such as:
>>>
>>> trait Frame {
>>>   pub fn show(&self) {
>>>     unsafe {
>>>       wxFrame_Show(self.handle());
>>>     }
>>>   }
>>> }
>>>
>>> or so, would bindgen helps this use case? (c.f. parsed data accessible or
>>> so.)
>>>
>>> Did you try using bindgen on the wxc header file? If there were bits
>>> it couldn't handle, I'd be interested in helping fix that.
>>>
>>> martin
>>>
>>> On Wed, Sep 25, 2013 at 10:49 AM, KENZ gelsoft <kenz.gelsoft at gmail.com>
>>> wrote:
>>>> Hello, everyone.
>>>>
>>>> I would like to introduce my experimental project, wxRust.
>>>> Which is a wxWidgets binding for Rust.
>>>>
>>>>   https://github.com/kenz-gelsoft/wxRust
>>>>
>>>> This binding is based on the wxHaskell especially its "wxc"*1
>>>> C-Language wxWidgets binding part.
>>>>
>>>> Currently, it just converts wxc's header file to `extern fn`s and
>>>> export them as a rust library.
>>>>
>>>> Test program has just started working which opens a wxFrame
>>>> by calling wxc's C interface from extern fn.
>>>>
>>>> Current state is pre-alpha experimental state, there's no stable API,
>>>> hard to use, but announced here for someone planning similar project.
>>>>
>>>> I'm planning for next generating simple OOP style wrapper as rust
>>>> traits for each classes from wxc's header.
>>>>
>>>> There is many problems to tackle, for example how it can work
>>>> with multitask or, library users can write wx GUI programs easier.
>>>> Any helps or feedbacks are welcome.
>>>>
>>>>  *1: [http://www.haskell.org/haskellwiki/WxHaskell#Status]
>>>>
>>>>
>>>> Thanks,
>>>> --
>>>> KENZ <KENZ.gelsoft at gmail.com>
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>

From dpx.infinity at gmail.com  Sun Sep 29 04:49:46 2013
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 29 Sep 2013 15:49:46 +0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
Message-ID: <CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>

Yes, this is what I have observed too, see issue
https://github.com/mozilla/rust/issues/9597. I didn't know that using
extra parameter with lifetime will help though. It indeed works. But I
think that polluting traits-interfaces with lifetime annotation is
wrong. Why the trait should have lifetime annotation? It is
implementation detail.

I just managed to do what I wanted with some kind of hack. The
following code compiles and works:

// Some business-logic trait
trait Walker {
    fn walk(self);  // Just self, without pointers
}

// ReaderContainer implementation remains the same

// A struct which is intended to be an implementor of Walker trait
// Note that it has lifetime parameter in order to work for any kind
// of pointer to a Reader
struct ReaderContainer<'self> {
    priv reader: &'self Reader,
    priv counter: int
}

// Some auxiliary structure for ReaderContainer
// It may be anything but it should have a reference to ReaderContainer
// We have to use lifetime parameter because this structure is 'attached'
// to ReaderContainer, hence it must be of the same lifetime
struct ReaderContainerIterator<'self> {
    priv container: &'self mut ReaderContainer<'self>
}

// Some made-up implementation of iterator protocol for our
// auxiliary structure, it does not really matter
impl<'self> Iterator<u8> for ReaderContainerIterator<'self> {
    fn next(&mut self) -> Option<u8> {
        if self.container.counter < 10 {
            self.container.counter += 1;
            Some(self.container.reader.read_byte() as u8)
        } else {
            None
        }
    }
}

impl<'self> ReaderContainer<'self> {
    // A constructor for ReaderContainer, nothing special
    fn new<'a>(reader: &'a Reader) -> ReaderContainer<'a> {
        ReaderContainer { reader: reader, counter: 0 }
    }

    // A method which returns our auxiliary structure, i.e. iterator
    // Note that self parameter has lifetime 'self, otherwise this naturally
    // does not compile
    fn iter(&'self mut self) -> ReaderContainerIterator<'self> {
        ReaderContainerIterator { container: self }
    }
}

// And here are the changes

// We implement Walker for a reference of the specific type!
impl<'self> Walker for &'self mut ReaderContainer<'self> {
    // Here self automatically is &'self mut reference, so we can safely
    // use iter() method
    fn walk(self) {
        for b in self.iter() {
            println(fmt!("byte %?", b));
        }
    }
}

fn main() {
    use std::io;

    let r = io::stdin();
    let mut c = ReaderContainer::new(r);

    c.walk();  // No extra parameters
}


In short, I'm implementing `Walker` trait not for
`ReaderContainer<'self>` but for `&'self mut ReaderContainer<'self>`.

This does not feel right, but I do not see immediate problems with
this solution. Maybe someone who knows more about lifetimes could
comment on this.

2013/9/29 David Renshaw <dwrenshaw at gmail.com>:
> If I drop the unused parameter, I get an internal compiler error:
> 'assertion failed: self.variance.is_some()'

From dpx.infinity at gmail.com  Sun Sep 29 04:54:52 2013
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 29 Sep 2013 15:54:52 +0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
Message-ID: <CA+jWdBjB_+xGOKU1kRv-KT61SDpDcx9og8dMKzD8MyJT4nboww@mail.gmail.com>

I think I should have put my code to gist to track changes easily.
Amending: https://gist.github.com/dpx-infinity/6751843

2013/9/29 Vladimir Matveev <dpx.infinity at gmail.com>:
> Yes, this is what I have observed too, see issue
> https://github.com/mozilla/rust/issues/9597. I didn't know that using
> extra parameter with lifetime will help though. It indeed works. But I
> think that polluting traits-interfaces with lifetime annotation is
> wrong. Why the trait should have lifetime annotation? It is
> implementation detail.
>
> I just managed to do what I wanted with some kind of hack. The
> following code compiles and works:
>
> // Some business-logic trait
> trait Walker {
>     fn walk(self);  // Just self, without pointers
> }
>
> // ReaderContainer implementation remains the same
>
> // A struct which is intended to be an implementor of Walker trait
> // Note that it has lifetime parameter in order to work for any kind
> // of pointer to a Reader
> struct ReaderContainer<'self> {
>     priv reader: &'self Reader,
>     priv counter: int
> }
>
> // Some auxiliary structure for ReaderContainer
> // It may be anything but it should have a reference to ReaderContainer
> // We have to use lifetime parameter because this structure is 'attached'
> // to ReaderContainer, hence it must be of the same lifetime
> struct ReaderContainerIterator<'self> {
>     priv container: &'self mut ReaderContainer<'self>
> }
>
> // Some made-up implementation of iterator protocol for our
> // auxiliary structure, it does not really matter
> impl<'self> Iterator<u8> for ReaderContainerIterator<'self> {
>     fn next(&mut self) -> Option<u8> {
>         if self.container.counter < 10 {
>             self.container.counter += 1;
>             Some(self.container.reader.read_byte() as u8)
>         } else {
>             None
>         }
>     }
> }
>
> impl<'self> ReaderContainer<'self> {
>     // A constructor for ReaderContainer, nothing special
>     fn new<'a>(reader: &'a Reader) -> ReaderContainer<'a> {
>         ReaderContainer { reader: reader, counter: 0 }
>     }
>
>     // A method which returns our auxiliary structure, i.e. iterator
>     // Note that self parameter has lifetime 'self, otherwise this naturally
>     // does not compile
>     fn iter(&'self mut self) -> ReaderContainerIterator<'self> {
>         ReaderContainerIterator { container: self }
>     }
> }
>
> // And here are the changes
>
> // We implement Walker for a reference of the specific type!
> impl<'self> Walker for &'self mut ReaderContainer<'self> {
>     // Here self automatically is &'self mut reference, so we can safely
>     // use iter() method
>     fn walk(self) {
>         for b in self.iter() {
>             println(fmt!("byte %?", b));
>         }
>     }
> }
>
> fn main() {
>     use std::io;
>
>     let r = io::stdin();
>     let mut c = ReaderContainer::new(r);
>
>     c.walk();  // No extra parameters
> }
>
>
> In short, I'm implementing `Walker` trait not for
> `ReaderContainer<'self>` but for `&'self mut ReaderContainer<'self>`.
>
> This does not feel right, but I do not see immediate problems with
> this solution. Maybe someone who knows more about lifetimes could
> comment on this.
>
> 2013/9/29 David Renshaw <dwrenshaw at gmail.com>:
>> If I drop the unused parameter, I get an internal compiler error:
>> 'assertion failed: self.variance.is_some()'

From dwrenshaw at gmail.com  Sun Sep 29 07:42:29 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Sun, 29 Sep 2013 10:42:29 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
Message-ID: <CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>

Cool! I think that solution is much better than mine.

> But I
> think that polluting traits-interfaces with lifetime annotation is
> wrong. Why the trait should have lifetime annotation? It is
> implementation detail.

Just in case you want to see a case where it *does* make sense to put
a 'self lifetime in a trait definition, here is an example:

https://gist.github.com/dwrensha/db919b8e130e9eb72f0f

From oren at ben-kiki.org  Sun Sep 29 08:23:14 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sun, 29 Sep 2013 18:23:14 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
Message-ID: <CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>

Ok, color me confused... perhaps there's somewhere that explains 'self on
more detail? For example, _why_ does the example below not work without the
explicit <'self>? It seems like it should.

I have yet to truly understand the whole 'self thing. When I first read
about lifetimes, my naive expectations were that:

- Every struct has a 'self lifetime, which is basically "as long as this
struct exists". It doesn't matter if I have a @ of the struct or a ~ of the
struct or just a local variable with the struct... when the struct is
dropped, the lifetime ends.

- It follows there's no need to ever annotate structs as generic with a
<'self> parameter - it always exists.

- Any & in a struct is either &'self or &'static. A simple & should be
&'self as that makes more sense (but if Rust wants me to be explicit, fine).

This were my "least surprise" expectations, but things don't work this
way... the problem is I don't have a simple mental model to replace the
above with, so I struggle. What _is_ 'self, exactly?

Isn't a function fn foo(&self) -> &T the same as returning a &'self T? Why
would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
definition" the same as 'self? How come David's Foo example fails the
borrow check?

Besides failing (my) "least surprise" expectations, the current rules also
seem to be a "leaky abstraction". If I have a struct that holds a ComplexT
member, it needs no <'self> parameter. If I then add a private member to my
struct to hold some &'self PartOfT (say, cached access to an internal
member), then boom, all uses of my struct now have to say <'self>, I can no
longer put it in thread-local-storage, etc. I'd expect keeping these sort
of cached borrowed pointers should be an internal implementation detail
which does not affect the users of the struct at all.

I suppose there's a good reason for all this, and a reasonable mental model
I need to put in my head, but digging around the docs I didn't find one...
Any hints would be appreciated :-)


On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com> wrote:

> Cool! I think that solution is much better than mine.
>
> > But I
> > think that polluting traits-interfaces with lifetime annotation is
> > wrong. Why the trait should have lifetime annotation? It is
> > implementation detail.
>
> Just in case you want to see a case where it *does* make sense to put
> a 'self lifetime in a trait definition, here is an example:
>
> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/9a770046/attachment.html>

From steve at steveklabnik.com  Sun Sep 29 08:30:24 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Sun, 29 Sep 2013 08:30:24 -0700
Subject: [rust-dev] Nedit syntax highlighting for Rust
In-Reply-To: <CAOqL70=d684WVeB8BbvYofxXhDg1tvznC8Fv8W8M+=jO4Q6u4g@mail.gmail.com>
References: <CAOqL70=d684WVeB8BbvYofxXhDg1tvznC8Fv8W8M+=jO4Q6u4g@mail.gmail.com>
Message-ID: <CABL+ZB5K77SNKincfVhrahu_fNxRkdO1pE-UxJmszmH8HfsNdg@mail.gmail.com>

We actually keep these kinds of things in the source tree:
https://github.com/mozilla/rust/tree/master/src/etc

You should submit this as a PR!

On Fri, Sep 27, 2013 at 6:53 PM, Steven Fuerst <svfuerst at gmail.com> wrote:
> In case anyone is interested... here are some syntax highlighting regexes
> for the nedit editor for rust.  Just add to your .nedit
> "nedit.highlightPatterns:" section.
>
> Rust:1:0{\n\
> Macro:"[\\l_]\\w*!":::Preprocessor1::D\n\
> Function:"fn ([\\l_]\\w*)":::Keyword::D\n\
> Function name:"\\1":""::Subroutine:Function:DC\n\
> Module:"(?:[\\l_]\\w*::|::)":::Identifier2::\n\
> Keyword:"<(?:as|fn|break|copy|if|else|drop|in|do|for|while|loop|return|trait|type|unsafe|use|let|match|print|println|mod|self|super|priv|pub|use|impl|false|true)>":::Keyword::D\n\
> Storage Type:"<(?:mut|static|extern|struct|enum|ref)>":::Storage Type1::\n\
> Numeric:"(?<!\\Y)(?:(?:0(?:x|X)[\\da-fA-F_]*)|(?:(?:\\d+\\.?\\d*)|(?:\\.\\d+)|_)(?:(?:e|E)(?:\\+|-)?\\d+)?(?:f32|f64)?)(?:L|l|u|U|F|f|u8|u16|u32|u64|i8|i16|i32|i64)?(?!\\Y)":::Numeric
> Const::D\n\
> String:"""":""""::String::\n\
> String escape chars:"\\\\(?:.|\\n)":::String2:String:\n\
> Storage:"<(?:float|f32|f64|int|i8|i16|i32|i64|uint|u8|u16|u32|u64|bool)>":::Storage
> Type::\n\
> Braces:"[{}]":::Keyword::D\n\
> C99comment:"//":"$"::Comment::\n\
> Comment:"/\\*":"\\*/"::Comment::\n\
> Operators:"(?:-\\>|=\\>|\\(\\*\\))":::Operator::\n\
> Generic:"\\<(?!\\s)":"\\>(?! *\\>)(?!,)":"[|;""=$-]":Pointer::\n\
> Module Generic:"(?:[\\l_]\\w*::|::)":::Identifier1:Generic:\n\
> Character:"'[\\\\\\w]*'":::Character Const::\n\
> Pragma:"#\\[":"\\]"::Preprocessor::\n\
> Pragma String:"""":"""":"\\n":String1:Pragma:\n\
> Definition:"[a-z_]+[a-z\\d_]*[ ]*:":::Bold::\n\
> String fmt:"\\{":"\\}":"""":Text Arg1:String:\n\
> String fmt2:"\\{":"\\}":"(?:\\{|"")":Text Escape:String fmt:\n\
> Lambda Params:"(?:(?<=[\\(,=])
> *\\|[^\\n|]*\\||\\|[^\\n|]*\\|(?=\\s*\\{))":::Chocolate::\n\
> }
>
> I've used some hacks to get generics looking okay... but it mostly works.
>
> Steven
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From illissius at gmail.com  Sun Sep 29 10:24:32 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 29 Sep 2013 19:24:32 +0200
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
Message-ID: <CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>

'self is not special in any way, except that the compiler has historical
baggage such that 'self is the only name it lets you use for a lifetime
parameter on a struct. But that's a bug. In the ideal platonic Rust in the
sky, you can have any number of lifetime parameters on a struct with
whatever names you prefer.

The way I've found to think about lifetimes is that if you have:

r_int: &'a int

then 'a refers to a span of time (a scope, a lifetime) such that
lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
metaphorically to refer to the original object r_int was created from, not
the result of the *r_int expression itself.) So 'a is a kind of stand
between to ensure that r_int does not outlive the object it refers to.

If you have

fn foo<'a>(r_int: &'a int) -> &'a int

then just like any other generics argument, the lifetime 'a is chosen by
the caller of `foo` (as inferred by the compiler). Typically the caller
will have an int object (i: int), then borrow a reference to it (r_int: &'a
int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
int. `foo` will then have to return a reference to (an int that lives at
least as long). In practice this could either be the r_int it got as
argument, or a static int.

`fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
`fn foo<'a>(arg: &'a int)`

In the return type position `fn foo() -> &int` is short for `fn foo<'a>()
-> &'a int`, meaning `foo` has to return a reference to (an int that lives
as long as any lifetime the caller could choose), which in practice means
that it has to be 'static. I believe you are or will be required to write
&'static explicitly in these cases to avoid confusion.

With a struct it's not much different.

s: MyStruct<'a> means lifetime_of(s) <= 'a
s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b

If you have

struct MyStruct<'self> {
    r_int: &'self int
}

s: MyStruct<'a>

then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is trivial
because lifetime_of(s) == lifetime_of(s.r_int).)

Basically, every object has a lifetime - from its creation to its
destruction - but a lifetime parameter or argument typically refers to the
lifetime of something else, which the object itself must not or does not
outlive.

(Please yell at me if I got any of this wrong.)



On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Ok, color me confused... perhaps there's somewhere that explains 'self on
> more detail? For example, _why_ does the example below not work without the
> explicit <'self>? It seems like it should.
>
> I have yet to truly understand the whole 'self thing. When I first read
> about lifetimes, my naive expectations were that:
>
> - Every struct has a 'self lifetime, which is basically "as long as this
> struct exists". It doesn't matter if I have a @ of the struct or a ~ of the
> struct or just a local variable with the struct... when the struct is
> dropped, the lifetime ends.
>
> - It follows there's no need to ever annotate structs as generic with a
> <'self> parameter - it always exists.
>
> - Any & in a struct is either &'self or &'static. A simple & should be
> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>
> This were my "least surprise" expectations, but things don't work this
> way... the problem is I don't have a simple mental model to replace the
> above with, so I struggle. What _is_ 'self, exactly?
>
> Isn't a function fn foo(&self) -> &T the same as returning a &'self T? Why
> would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
> definition" the same as 'self? How come David's Foo example fails the
> borrow check?
>
> Besides failing (my) "least surprise" expectations, the current rules also
> seem to be a "leaky abstraction". If I have a struct that holds a ComplexT
> member, it needs no <'self> parameter. If I then add a private member to my
> struct to hold some &'self PartOfT (say, cached access to an internal
> member), then boom, all uses of my struct now have to say <'self>, I can no
> longer put it in thread-local-storage, etc. I'd expect keeping these sort
> of cached borrowed pointers should be an internal implementation detail
> which does not affect the users of the struct at all.
>
> I suppose there's a good reason for all this, and a reasonable mental
> model I need to put in my head, but digging around the docs I didn't find
> one... Any hints would be appreciated :-)
>
>
> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>
>> Cool! I think that solution is much better than mine.
>>
>> > But I
>> > think that polluting traits-interfaces with lifetime annotation is
>> > wrong. Why the trait should have lifetime annotation? It is
>> > implementation detail.
>>
>> Just in case you want to see a case where it *does* make sense to put
>> a 'self lifetime in a trait definition, here is an example:
>>
>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/0845ee56/attachment.html>

From dpx.infinity at gmail.com  Sun Sep 29 11:16:18 2013
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 29 Sep 2013 22:16:18 +0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
Message-ID: <CA+jWdBhNtBQZ=sZ9MGGJ-4DV61+kT=zYA4UsEqjPA1Tyv1oxDw@mail.gmail.com>

As far as I understand, you're mostly right, except the structures bit.

Disregarding that it is not possible to use several lifetime
parameters yet, I see only one slight mistake: `s: MyStruct<'a>` does
not imply that `s` variable has any specific lifetime. If it is a
local variable, then it has 'lexical' lifetime; if it is a field in a
structure, it has lifetime of the structure instance.

 I guess what you meant is this:

s: &'a MyStruct<'a>

Here `s` pointer have lifetime 'a, as well as `s.r_int`.

BTW, you came up with very nice math-like analogy, it helped me
understand this thing even more. Thanks :)

2013/9/29 G?bor Lehel <illissius at gmail.com>:
> 'self is not special in any way, except that the compiler has historical
> baggage such that 'self is the only name it lets you use for a lifetime
> parameter on a struct. But that's a bug. In the ideal platonic Rust in the
> sky, you can have any number of lifetime parameters on a struct with
> whatever names you prefer.
>
> The way I've found to think about lifetimes is that if you have:
>
> r_int: &'a int
>
> then 'a refers to a span of time (a scope, a lifetime) such that
> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
> metaphorically to refer to the original object r_int was created from, not
> the result of the *r_int expression itself.) So 'a is a kind of stand
> between to ensure that r_int does not outlive the object it refers to.
>
> If you have
>
> fn foo<'a>(r_int: &'a int) -> &'a int
>
> then just like any other generics argument, the lifetime 'a is chosen by the
> caller of `foo` (as inferred by the compiler). Typically the caller will
> have an int object (i: int), then borrow a reference to it (r_int: &'a int =
> &i) which it passes to `foo`, and then 'a will be the lifetime of the int.
> `foo` will then have to return a reference to (an int that lives at least as
> long). In practice this could either be the r_int it got as argument, or a
> static int.
>
> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter: `fn
> foo<'a>(arg: &'a int)`
>
> In the return type position `fn foo() -> &int` is short for `fn foo<'a>() ->
> &'a int`, meaning `foo` has to return a reference to (an int that lives as
> long as any lifetime the caller could choose), which in practice means that
> it has to be 'static. I believe you are or will be required to write
> &'static explicitly in these cases to avoid confusion.
>
> With a struct it's not much different.
>
> s: MyStruct<'a> means lifetime_of(s) <= 'a
> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>
> If you have
>
> struct MyStruct<'self> {
>     r_int: &'self int
> }
>
> s: MyStruct<'a>
>
> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is trivial
> because lifetime_of(s) == lifetime_of(s.r_int).)
>
> Basically, every object has a lifetime - from its creation to its
> destruction - but a lifetime parameter or argument typically refers to the
> lifetime of something else, which the object itself must not or does not
> outlive.
>
> (Please yell at me if I got any of this wrong.)
>
>
>
> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>> Ok, color me confused... perhaps there's somewhere that explains 'self on
>> more detail? For example, _why_ does the example below not work without the
>> explicit <'self>? It seems like it should.
>>
>> I have yet to truly understand the whole 'self thing. When I first read
>> about lifetimes, my naive expectations were that:
>>
>> - Every struct has a 'self lifetime, which is basically "as long as this
>> struct exists". It doesn't matter if I have a @ of the struct or a ~ of the
>> struct or just a local variable with the struct... when the struct is
>> dropped, the lifetime ends.
>>
>> - It follows there's no need to ever annotate structs as generic with a
>> <'self> parameter - it always exists.
>>
>> - Any & in a struct is either &'self or &'static. A simple & should be
>> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>>
>> This were my "least surprise" expectations, but things don't work this
>> way... the problem is I don't have a simple mental model to replace the
>> above with, so I struggle. What _is_ 'self, exactly?
>>
>> Isn't a function fn foo(&self) -> &T the same as returning a &'self T? Why
>> would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
>> definition" the same as 'self? How come David's Foo example fails the borrow
>> check?
>>
>> Besides failing (my) "least surprise" expectations, the current rules also
>> seem to be a "leaky abstraction". If I have a struct that holds a ComplexT
>> member, it needs no <'self> parameter. If I then add a private member to my
>> struct to hold some &'self PartOfT (say, cached access to an internal
>> member), then boom, all uses of my struct now have to say <'self>, I can no
>> longer put it in thread-local-storage, etc. I'd expect keeping these sort of
>> cached borrowed pointers should be an internal implementation detail which
>> does not affect the users of the struct at all.
>>
>> I suppose there's a good reason for all this, and a reasonable mental
>> model I need to put in my head, but digging around the docs I didn't find
>> one... Any hints would be appreciated :-)
>>
>>
>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>
>> wrote:
>>>
>>> Cool! I think that solution is much better than mine.
>>>
>>> > But I
>>> > think that polluting traits-interfaces with lifetime annotation is
>>> > wrong. Why the trait should have lifetime annotation? It is
>>> > implementation detail.
>>>
>>> Just in case you want to see a case where it *does* make sense to put
>>> a 'self lifetime in a trait definition, here is an example:
>>>
>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From oren at ben-kiki.org  Sun Sep 29 12:21:22 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sun, 29 Sep 2013 22:21:22 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
Message-ID: <CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>

Thanks for the explanation. You said two key points:
- Basically, every object has a lifetime - from its creation to its
destruction - but a lifetime parameter or argument typically refers to the
lifetime of something else, which the object itself must not or does not
outlive.
And:
- 'self is not special in any way, except that the compiler has historical
baggage such that 'self is the only name it lets you use for a lifetime
parameter on a struct.

So, 'self is indeed very far from what I thought (hoped) it would be.

Taking these together, do I read this right as saying there is no way
whatsoever to say:

struct Foo {
    bar: Bar,
    baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
}

When writing a non-trivial container, I found several user cases to be
extremely problematic. One was the above; a container held a "spine" or
"master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
borrowed pointers that only live as long as the container and allow quick
access to specific parts of it.

Is this impossible in Rust (barring use of @ or unsafe pointers)?


On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com> wrote:

> 'self is not special in any way, except that the compiler has historical
> baggage such that 'self is the only name it lets you use for a lifetime
> parameter on a struct. But that's a bug. In the ideal platonic Rust in the
> sky, you can have any number of lifetime parameters on a struct with
> whatever names you prefer.
>
> The way I've found to think about lifetimes is that if you have:
>
> r_int: &'a int
>
> then 'a refers to a span of time (a scope, a lifetime) such that
> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
> metaphorically to refer to the original object r_int was created from, not
> the result of the *r_int expression itself.) So 'a is a kind of stand
> between to ensure that r_int does not outlive the object it refers to.
>
> If you have
>
> fn foo<'a>(r_int: &'a int) -> &'a int
>
> then just like any other generics argument, the lifetime 'a is chosen by
> the caller of `foo` (as inferred by the compiler). Typically the caller
> will have an int object (i: int), then borrow a reference to it (r_int: &'a
> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
> int. `foo` will then have to return a reference to (an int that lives at
> least as long). In practice this could either be the r_int it got as
> argument, or a static int.
>
> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
> `fn foo<'a>(arg: &'a int)`
>
> In the return type position `fn foo() -> &int` is short for `fn foo<'a>()
> -> &'a int`, meaning `foo` has to return a reference to (an int that lives
> as long as any lifetime the caller could choose), which in practice means
> that it has to be 'static. I believe you are or will be required to write
> &'static explicitly in these cases to avoid confusion.
>
> With a struct it's not much different.
>
> s: MyStruct<'a> means lifetime_of(s) <= 'a
> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>
> If you have
>
> struct MyStruct<'self> {
>     r_int: &'self int
> }
>
> s: MyStruct<'a>
>
> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is trivial
> because lifetime_of(s) == lifetime_of(s.r_int).)
>
> Basically, every object has a lifetime - from its creation to its
> destruction - but a lifetime parameter or argument typically refers to the
> lifetime of something else, which the object itself must not or does not
> outlive.
>
> (Please yell at me if I got any of this wrong.)
>
>
>
> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Ok, color me confused... perhaps there's somewhere that explains 'self on
>> more detail? For example, _why_ does the example below not work without the
>> explicit <'self>? It seems like it should.
>>
>> I have yet to truly understand the whole 'self thing. When I first read
>> about lifetimes, my naive expectations were that:
>>
>> - Every struct has a 'self lifetime, which is basically "as long as this
>> struct exists". It doesn't matter if I have a @ of the struct or a ~ of the
>> struct or just a local variable with the struct... when the struct is
>> dropped, the lifetime ends.
>>
>> - It follows there's no need to ever annotate structs as generic with a
>> <'self> parameter - it always exists.
>>
>> - Any & in a struct is either &'self or &'static. A simple & should be
>> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>>
>> This were my "least surprise" expectations, but things don't work this
>> way... the problem is I don't have a simple mental model to replace the
>> above with, so I struggle. What _is_ 'self, exactly?
>>
>> Isn't a function fn foo(&self) -> &T the same as returning a &'self T?
>> Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
>> definition" the same as 'self? How come David's Foo example fails the
>> borrow check?
>>
>> Besides failing (my) "least surprise" expectations, the current rules
>> also seem to be a "leaky abstraction". If I have a struct that holds a
>> ComplexT member, it needs no <'self> parameter. If I then add a private
>> member to my struct to hold some &'self PartOfT (say, cached access to an
>> internal member), then boom, all uses of my struct now have to say <'self>,
>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>> these sort of cached borrowed pointers should be an internal implementation
>> detail which does not affect the users of the struct at all.
>>
>> I suppose there's a good reason for all this, and a reasonable mental
>> model I need to put in my head, but digging around the docs I didn't find
>> one... Any hints would be appreciated :-)
>>
>>
>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>
>>> Cool! I think that solution is much better than mine.
>>>
>>> > But I
>>> > think that polluting traits-interfaces with lifetime annotation is
>>> > wrong. Why the trait should have lifetime annotation? It is
>>> > implementation detail.
>>>
>>> Just in case you want to see a case where it *does* make sense to put
>>> a 'self lifetime in a trait definition, here is an example:
>>>
>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/8c796c2e/attachment.html>

From nejucomo at gmail.com  Sun Sep 29 12:26:05 2013
From: nejucomo at gmail.com (Callme Whatiwant)
Date: Sun, 29 Sep 2013 12:26:05 -0700
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CAJnHWXvk0VHx09REVpj22Pf_CcSSchZ=kvR3txaSH9x105XiUQ@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAJnHWXvk0VHx09REVpj22Pf_CcSSchZ=kvR3txaSH9x105XiUQ@mail.gmail.com>
Message-ID: <CA+4_Dk7=SPHWWsHas1D-LUyhrDEo821Px+5RtJm5UGD-bxG1Hw@mail.gmail.com>

On Tue, Sep 10, 2013 at 12:39 AM, Marijn Haverbeke <marijnh at gmail.com> wrote:
> The Rust team is aware of this possibility, and is guarding against it
> by keeping a log of checksums and source git revisions for the various
> versions of the compiler, so that compilers downloaded from the net
> can be checked, and we could, if something dodgy is found, back-track
> to a known trusted version of the compiler (or even all the way back
> to the OCaml bootstrap compiler, though that'd be a lot of work).
>
> It is theoretically possible that someone manages to sneak in a commit
> that adds an exploit to the compiler, but since patches are reviewed,
> that is not terribly likely to succeed. Also, Rust is a small target
> still, and it would be a marvelous feat of engineering to install a
> functioning exploit in a compiler that is being overhauled and changed
> all the time.


It's great that the team considers this and has a plan.  This kind of
attention to detail (including security detail) really attracts me to
rust!  Keep it up.


There is a parallel issue around the security of builds.  Doesn't it
seem easier to hack into the server shipping rustc binaries then
insert backdoors into those, rather than trying to "sneak patches"
past many watchful code reviewers?

Are rustc compilations deterministic?  If not, can I humbly suggest a
"soft goal" which is where devs do not switch tasks or priorities, but
instead keep in the back of their mind potential sources for
non-determinism in builds, as they modify rustc (or llvm)?


The goal of deterministic builds is that given the same source
snapshot on two different systems, and the "same version" of the build
tools, the built artifacts are bytewise identical.  I put "same
version" in qualifying quotes because the two build tools
installations may be compiled for different architectures, and they
may be different versions, and they might even be different
implementations if the entire compilation process is well-specified
enough.  Even with those differences in build tool installations, it's
possible and desirable to generate bytewise identical build results
(modulo all of the configuration such as target architecture).

If N volunteers are using deterministic builds, they can
cross-reference their builds and they can publish hashes which users
can verify.  Note, this is useful even if only a tiny fraction of
users verify the distribution they've received, and more useful the
more often more people do this verification.


I'm out of my element here with the actual details, but I assume LLVM
has a huge role to play here.  Are there LLVM development discussions
around deterministic builds?

Some simple heuristics for noticing non-determinism are places where
there's no defined ordering (for example, does the textual order of
rust items map in a well defined way to the order of the linking
symbol table?), places where time and random are used, places where
local build system specific details are used (source path metadata,
...).


If rust devs consider this important enough, it might be useful to
talk to people at the Tor Project such as Mike Perry who introduces
the need for deterministic builds here:

https://blog.torproject.org/blog/deterministic-builds-part-one-cyberwar-and-global-compromise


Regards,
nejucomo


> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From cadencemarseille at gmail.com  Sun Sep 29 13:54:37 2013
From: cadencemarseille at gmail.com (Cadence Marseille)
Date: Sun, 29 Sep 2013 16:54:37 -0400
Subject: [rust-dev] Announce: rust-pcre
Message-ID: <CAH+UCjPoaNCHTYkaPbgTrGbAk8j7gHGnL_23ffLLck5vVV4hFQ@mail.gmail.com>

Hello,

I spent some time putting together a simple wrapper for
libpcre<http://pcre.org/>,
available at:
https://github.com/cadencemarseille/rust-pcre

As I am just learning Rust, any comments/thoughts about the wrapper's API,
coding style, etc., are welcome.

-- 
Cadence
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/269baa68/attachment-0001.html>

From illissius at gmail.com  Sun Sep 29 14:13:21 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 29 Sep 2013 23:13:21 +0200
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
Message-ID: <CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>

`On Sun, Sep 29, 2013 at 9:21 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Thanks for the explanation. You said two key points:
> - Basically, every object has a lifetime - from its creation to its
> destruction - but a lifetime parameter or argument typically refers to the
> lifetime of something else, which the object itself must not or does not
> outlive.
> And:
> - 'self is not special in any way, except that the compiler has historical
> baggage such that 'self is the only name it lets you use for a lifetime
> parameter on a struct.
>
> So, 'self is indeed very far from what I thought (hoped) it would be.
>
> Taking these together, do I read this right as saying there is no way
> whatsoever to say:
>
> struct Foo {
>     bar: Bar,
>     baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
> }
>

Per my understanding, this is correct. Because there is a constraint on the
lifetime of a part of `Foo`, there must a constraint on the lifetime of
`Foo`. It has to propagate outwards to make sure the lifetime of the whole
structure is properly constrained. You basically want to "propagate
inwards". I don't think that's possible, but maybe someone will correct me.


>
> When writing a non-trivial container, I found several user cases to be
> extremely problematic. One was the above; a container held a "spine" or
> "master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
> borrowed pointers that only live as long as the container and allow quick
> access to specific parts of it.
>
> Is this impossible in Rust (barring use of @ or unsafe pointers)?
>

This sounds similar to the case of a doubly linked list (with forward
pointers being the "spine" and backwards the "quick access"), which is  not
possible as an 'owned' structure as far as I know without unsafe pointers.


>
>
> On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com> wrote:
>
>> 'self is not special in any way, except that the compiler has historical
>> baggage such that 'self is the only name it lets you use for a lifetime
>> parameter on a struct. But that's a bug. In the ideal platonic Rust in the
>> sky, you can have any number of lifetime parameters on a struct with
>> whatever names you prefer.
>>
>> The way I've found to think about lifetimes is that if you have:
>>
>> r_int: &'a int
>>
>> then 'a refers to a span of time (a scope, a lifetime) such that
>> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
>> metaphorically to refer to the original object r_int was created from, not
>> the result of the *r_int expression itself.) So 'a is a kind of stand
>> between to ensure that r_int does not outlive the object it refers to.
>>
>> If you have
>>
>> fn foo<'a>(r_int: &'a int) -> &'a int
>>
>> then just like any other generics argument, the lifetime 'a is chosen by
>> the caller of `foo` (as inferred by the compiler). Typically the caller
>> will have an int object (i: int), then borrow a reference to it (r_int: &'a
>> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
>> int. `foo` will then have to return a reference to (an int that lives at
>> least as long). In practice this could either be the r_int it got as
>> argument, or a static int.
>>
>> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
>> `fn foo<'a>(arg: &'a int)`
>>
>> In the return type position `fn foo() -> &int` is short for `fn foo<'a>()
>> -> &'a int`, meaning `foo` has to return a reference to (an int that lives
>> as long as any lifetime the caller could choose), which in practice means
>> that it has to be 'static. I believe you are or will be required to write
>> &'static explicitly in these cases to avoid confusion.
>>
>> With a struct it's not much different.
>>
>> s: MyStruct<'a> means lifetime_of(s) <= 'a
>> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>>
>> If you have
>>
>> struct MyStruct<'self> {
>>     r_int: &'self int
>> }
>>
>> s: MyStruct<'a>
>>
>> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is
>> trivial because lifetime_of(s) == lifetime_of(s.r_int).)
>>
>> Basically, every object has a lifetime - from its creation to its
>> destruction - but a lifetime parameter or argument typically refers to the
>> lifetime of something else, which the object itself must not or does not
>> outlive.
>>
>> (Please yell at me if I got any of this wrong.)
>>
>>
>>
>> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>>> Ok, color me confused... perhaps there's somewhere that explains 'self
>>> on more detail? For example, _why_ does the example below not work without
>>> the explicit <'self>? It seems like it should.
>>>
>>> I have yet to truly understand the whole 'self thing. When I first read
>>> about lifetimes, my naive expectations were that:
>>>
>>> - Every struct has a 'self lifetime, which is basically "as long as this
>>> struct exists". It doesn't matter if I have a @ of the struct or a ~ of the
>>> struct or just a local variable with the struct... when the struct is
>>> dropped, the lifetime ends.
>>>
>>> - It follows there's no need to ever annotate structs as generic with a
>>> <'self> parameter - it always exists.
>>>
>>> - Any & in a struct is either &'self or &'static. A simple & should be
>>> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>>>
>>> This were my "least surprise" expectations, but things don't work this
>>> way... the problem is I don't have a simple mental model to replace the
>>> above with, so I struggle. What _is_ 'self, exactly?
>>>
>>> Isn't a function fn foo(&self) -> &T the same as returning a &'self T?
>>> Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
>>> definition" the same as 'self? How come David's Foo example fails the
>>> borrow check?
>>>
>>> Besides failing (my) "least surprise" expectations, the current rules
>>> also seem to be a "leaky abstraction". If I have a struct that holds a
>>> ComplexT member, it needs no <'self> parameter. If I then add a private
>>> member to my struct to hold some &'self PartOfT (say, cached access to an
>>> internal member), then boom, all uses of my struct now have to say <'self>,
>>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>>> these sort of cached borrowed pointers should be an internal implementation
>>> detail which does not affect the users of the struct at all.
>>>
>>> I suppose there's a good reason for all this, and a reasonable mental
>>> model I need to put in my head, but digging around the docs I didn't find
>>> one... Any hints would be appreciated :-)
>>>
>>>
>>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>>
>>>> Cool! I think that solution is much better than mine.
>>>>
>>>> > But I
>>>> > think that polluting traits-interfaces with lifetime annotation is
>>>> > wrong. Why the trait should have lifetime annotation? It is
>>>> > implementation detail.
>>>>
>>>> Just in case you want to see a case where it *does* make sense to put
>>>> a 'self lifetime in a trait definition, here is an example:
>>>>
>>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>>
>> --
>> Your ship was destroyed in a monadic eruption.
>>
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/0cb48c5d/attachment.html>

From oren at ben-kiki.org  Sun Sep 29 14:32:29 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 30 Sep 2013 00:32:29 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
Message-ID: <CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>

That's... surprising. Even ignoring the fact the name "self" means exactly
the opposite (d?j? vu from "const" here)...

I don't suppose there's a chance that something like what I expected 'self
to be like would be supported at some point? Its lack rules out a lot of
reasonable, safe, useful code.



On Mon, Sep 30, 2013 at 12:13 AM, G?bor Lehel <illissius at gmail.com> wrote:

>
> `On Sun, Sep 29, 2013 at 9:21 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Thanks for the explanation. You said two key points:
>> - Basically, every object has a lifetime - from its creation to its
>> destruction - but a lifetime parameter or argument typically refers to the
>> lifetime of something else, which the object itself must not or does not
>> outlive.
>> And:
>> - 'self is not special in any way, except that the compiler has
>> historical baggage such that 'self is the only name it lets you use for a
>> lifetime parameter on a struct.
>>
>> So, 'self is indeed very far from what I thought (hoped) it would be.
>>
>> Taking these together, do I read this right as saying there is no way
>> whatsoever to say:
>>
>> struct Foo {
>>     bar: Bar,
>>     baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
>> }
>>
>
> Per my understanding, this is correct. Because there is a constraint on
> the lifetime of a part of `Foo`, there must a constraint on the lifetime of
> `Foo`. It has to propagate outwards to make sure the lifetime of the whole
> structure is properly constrained. You basically want to "propagate
> inwards". I don't think that's possible, but maybe someone will correct me.
>
>
>>
>> When writing a non-trivial container, I found several user cases to be
>> extremely problematic. One was the above; a container held a "spine" or
>> "master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
>> borrowed pointers that only live as long as the container and allow quick
>> access to specific parts of it.
>>
>> Is this impossible in Rust (barring use of @ or unsafe pointers)?
>>
>
> This sounds similar to the case of a doubly linked list (with forward
> pointers being the "spine" and backwards the "quick access"), which is  not
> possible as an 'owned' structure as far as I know without unsafe pointers.
>
>
>>
>>
>> On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com> wrote:
>>
>>> 'self is not special in any way, except that the compiler has historical
>>> baggage such that 'self is the only name it lets you use for a lifetime
>>> parameter on a struct. But that's a bug. In the ideal platonic Rust in the
>>> sky, you can have any number of lifetime parameters on a struct with
>>> whatever names you prefer.
>>>
>>> The way I've found to think about lifetimes is that if you have:
>>>
>>> r_int: &'a int
>>>
>>> then 'a refers to a span of time (a scope, a lifetime) such that
>>> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
>>> metaphorically to refer to the original object r_int was created from, not
>>> the result of the *r_int expression itself.) So 'a is a kind of stand
>>> between to ensure that r_int does not outlive the object it refers to.
>>>
>>> If you have
>>>
>>> fn foo<'a>(r_int: &'a int) -> &'a int
>>>
>>> then just like any other generics argument, the lifetime 'a is chosen by
>>> the caller of `foo` (as inferred by the compiler). Typically the caller
>>> will have an int object (i: int), then borrow a reference to it (r_int: &'a
>>> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
>>> int. `foo` will then have to return a reference to (an int that lives at
>>> least as long). In practice this could either be the r_int it got as
>>> argument, or a static int.
>>>
>>> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
>>> `fn foo<'a>(arg: &'a int)`
>>>
>>> In the return type position `fn foo() -> &int` is short for
>>> `fn foo<'a>() -> &'a int`, meaning `foo` has to return a reference to (an
>>> int that lives as long as any lifetime the caller could choose), which in
>>> practice means that it has to be 'static. I believe you are or will be
>>> required to write &'static explicitly in these cases to avoid confusion.
>>>
>>> With a struct it's not much different.
>>>
>>> s: MyStruct<'a> means lifetime_of(s) <= 'a
>>> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>>>
>>> If you have
>>>
>>> struct MyStruct<'self> {
>>>     r_int: &'self int
>>> }
>>>
>>> s: MyStruct<'a>
>>>
>>> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is
>>> trivial because lifetime_of(s) == lifetime_of(s.r_int).)
>>>
>>> Basically, every object has a lifetime - from its creation to its
>>> destruction - but a lifetime parameter or argument typically refers to the
>>> lifetime of something else, which the object itself must not or does not
>>> outlive.
>>>
>>> (Please yell at me if I got any of this wrong.)
>>>
>>>
>>>
>>> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>
>>>> Ok, color me confused... perhaps there's somewhere that explains 'self
>>>> on more detail? For example, _why_ does the example below not work without
>>>> the explicit <'self>? It seems like it should.
>>>>
>>>> I have yet to truly understand the whole 'self thing. When I first read
>>>> about lifetimes, my naive expectations were that:
>>>>
>>>> - Every struct has a 'self lifetime, which is basically "as long as
>>>> this struct exists". It doesn't matter if I have a @ of the struct or a ~
>>>> of the struct or just a local variable with the struct... when the struct
>>>> is dropped, the lifetime ends.
>>>>
>>>> - It follows there's no need to ever annotate structs as generic with a
>>>> <'self> parameter - it always exists.
>>>>
>>>> - Any & in a struct is either &'self or &'static. A simple & should be
>>>> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>>>>
>>>> This were my "least surprise" expectations, but things don't work this
>>>> way... the problem is I don't have a simple mental model to replace the
>>>> above with, so I struggle. What _is_ 'self, exactly?
>>>>
>>>> Isn't a function fn foo(&self) -> &T the same as returning a &'self T?
>>>> Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
>>>> definition" the same as 'self? How come David's Foo example fails the
>>>> borrow check?
>>>>
>>>> Besides failing (my) "least surprise" expectations, the current rules
>>>> also seem to be a "leaky abstraction". If I have a struct that holds a
>>>> ComplexT member, it needs no <'self> parameter. If I then add a private
>>>> member to my struct to hold some &'self PartOfT (say, cached access to an
>>>> internal member), then boom, all uses of my struct now have to say <'self>,
>>>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>>>> these sort of cached borrowed pointers should be an internal implementation
>>>> detail which does not affect the users of the struct at all.
>>>>
>>>> I suppose there's a good reason for all this, and a reasonable mental
>>>> model I need to put in my head, but digging around the docs I didn't find
>>>> one... Any hints would be appreciated :-)
>>>>
>>>>
>>>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>>>
>>>>> Cool! I think that solution is much better than mine.
>>>>>
>>>>> > But I
>>>>> > think that polluting traits-interfaces with lifetime annotation is
>>>>> > wrong. Why the trait should have lifetime annotation? It is
>>>>> > implementation detail.
>>>>>
>>>>> Just in case you want to see a case where it *does* make sense to put
>>>>> a 'self lifetime in a trait definition, here is an example:
>>>>>
>>>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>>
>>> --
>>> Your ship was destroyed in a monadic eruption.
>>>
>>
>>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/bb6232f8/attachment-0001.html>

From tkuehn at cmu.edu  Sun Sep 29 15:15:59 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Sun, 29 Sep 2013 18:15:59 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
Message-ID: <CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>

Could you use struct methods for "quick access"? Or is there a reason this
wouldn't fit your use case? Sorry, I haven't followed the whole thread
closely.

struct Owner {
    owned: ~[int],
}

impl Owner {
    fn quick_access<'a>(&'a mut self) -> &'a mut int {
        &mut self.owned[0]
    }
}


On Sun, Sep 29, 2013 at 5:32 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> That's... surprising. Even ignoring the fact the name "self" means exactly
> the opposite (d?j? vu from "const" here)...
>
> I don't suppose there's a chance that something like what I expected 'self
> to be like would be supported at some point? Its lack rules out a lot of
> reasonable, safe, useful code.
>
>
>
> On Mon, Sep 30, 2013 at 12:13 AM, G?bor Lehel <illissius at gmail.com> wrote:
>
>>
>> `On Sun, Sep 29, 2013 at 9:21 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>
>>> Thanks for the explanation. You said two key points:
>>> - Basically, every object has a lifetime - from its creation to its
>>> destruction - but a lifetime parameter or argument typically refers to the
>>> lifetime of something else, which the object itself must not or does not
>>> outlive.
>>> And:
>>> - 'self is not special in any way, except that the compiler has
>>> historical baggage such that 'self is the only name it lets you use for a
>>> lifetime parameter on a struct.
>>>
>>> So, 'self is indeed very far from what I thought (hoped) it would be.
>>>
>>> Taking these together, do I read this right as saying there is no way
>>> whatsoever to say:
>>>
>>> struct Foo {
>>>     bar: Bar,
>>>     baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
>>> }
>>>
>>
>> Per my understanding, this is correct. Because there is a constraint on
>> the lifetime of a part of `Foo`, there must a constraint on the lifetime of
>> `Foo`. It has to propagate outwards to make sure the lifetime of the whole
>> structure is properly constrained. You basically want to "propagate
>> inwards". I don't think that's possible, but maybe someone will correct me.
>>
>>
>>>
>>> When writing a non-trivial container, I found several user cases to be
>>> extremely problematic. One was the above; a container held a "spine" or
>>> "master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
>>> borrowed pointers that only live as long as the container and allow quick
>>> access to specific parts of it.
>>>
>>> Is this impossible in Rust (barring use of @ or unsafe pointers)?
>>>
>>
>> This sounds similar to the case of a doubly linked list (with forward
>> pointers being the "spine" and backwards the "quick access"), which is  not
>> possible as an 'owned' structure as far as I know without unsafe pointers.
>>
>>
>>>
>>>
>>> On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com>wrote:
>>>
>>>> 'self is not special in any way, except that the compiler has
>>>> historical baggage such that 'self is the only name it lets you use for a
>>>> lifetime parameter on a struct. But that's a bug. In the ideal platonic
>>>> Rust in the sky, you can have any number of lifetime parameters on a struct
>>>> with whatever names you prefer.
>>>>
>>>> The way I've found to think about lifetimes is that if you have:
>>>>
>>>> r_int: &'a int
>>>>
>>>> then 'a refers to a span of time (a scope, a lifetime) such that
>>>> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
>>>> metaphorically to refer to the original object r_int was created from, not
>>>> the result of the *r_int expression itself.) So 'a is a kind of stand
>>>> between to ensure that r_int does not outlive the object it refers to.
>>>>
>>>> If you have
>>>>
>>>> fn foo<'a>(r_int: &'a int) -> &'a int
>>>>
>>>> then just like any other generics argument, the lifetime 'a is chosen
>>>> by the caller of `foo` (as inferred by the compiler). Typically the caller
>>>> will have an int object (i: int), then borrow a reference to it (r_int: &'a
>>>> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
>>>> int. `foo` will then have to return a reference to (an int that lives at
>>>> least as long). In practice this could either be the r_int it got as
>>>> argument, or a static int.
>>>>
>>>> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
>>>> `fn foo<'a>(arg: &'a int)`
>>>>
>>>> In the return type position `fn foo() -> &int` is short for
>>>> `fn foo<'a>() -> &'a int`, meaning `foo` has to return a reference to (an
>>>> int that lives as long as any lifetime the caller could choose), which in
>>>> practice means that it has to be 'static. I believe you are or will be
>>>> required to write &'static explicitly in these cases to avoid confusion.
>>>>
>>>> With a struct it's not much different.
>>>>
>>>> s: MyStruct<'a> means lifetime_of(s) <= 'a
>>>> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>>>>
>>>> If you have
>>>>
>>>> struct MyStruct<'self> {
>>>>     r_int: &'self int
>>>> }
>>>>
>>>> s: MyStruct<'a>
>>>>
>>>> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is
>>>> trivial because lifetime_of(s) == lifetime_of(s.r_int).)
>>>>
>>>> Basically, every object has a lifetime - from its creation to its
>>>> destruction - but a lifetime parameter or argument typically refers to the
>>>> lifetime of something else, which the object itself must not or does not
>>>> outlive.
>>>>
>>>> (Please yell at me if I got any of this wrong.)
>>>>
>>>>
>>>>
>>>> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>>
>>>>> Ok, color me confused... perhaps there's somewhere that explains 'self
>>>>> on more detail? For example, _why_ does the example below not work without
>>>>> the explicit <'self>? It seems like it should.
>>>>>
>>>>> I have yet to truly understand the whole 'self thing. When I first
>>>>> read about lifetimes, my naive expectations were that:
>>>>>
>>>>> - Every struct has a 'self lifetime, which is basically "as long as
>>>>> this struct exists". It doesn't matter if I have a @ of the struct or a ~
>>>>> of the struct or just a local variable with the struct... when the struct
>>>>> is dropped, the lifetime ends.
>>>>>
>>>>> - It follows there's no need to ever annotate structs as generic with
>>>>> a <'self> parameter - it always exists.
>>>>>
>>>>> - Any & in a struct is either &'self or &'static. A simple & should be
>>>>> &'self as that makes more sense (but if Rust wants me to be explicit, fine).
>>>>>
>>>>> This were my "least surprise" expectations, but things don't work this
>>>>> way... the problem is I don't have a simple mental model to replace the
>>>>> above with, so I struggle. What _is_ 'self, exactly?
>>>>>
>>>>> Isn't a function fn foo(&self) -> &T the same as returning a &'self T?
>>>>> Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is "by
>>>>> definition" the same as 'self? How come David's Foo example fails the
>>>>> borrow check?
>>>>>
>>>>> Besides failing (my) "least surprise" expectations, the current rules
>>>>> also seem to be a "leaky abstraction". If I have a struct that holds a
>>>>> ComplexT member, it needs no <'self> parameter. If I then add a private
>>>>> member to my struct to hold some &'self PartOfT (say, cached access to an
>>>>> internal member), then boom, all uses of my struct now have to say <'self>,
>>>>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>>>>> these sort of cached borrowed pointers should be an internal implementation
>>>>> detail which does not affect the users of the struct at all.
>>>>>
>>>>> I suppose there's a good reason for all this, and a reasonable mental
>>>>> model I need to put in my head, but digging around the docs I didn't find
>>>>> one... Any hints would be appreciated :-)
>>>>>
>>>>>
>>>>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>>>>
>>>>>> Cool! I think that solution is much better than mine.
>>>>>>
>>>>>> > But I
>>>>>> > think that polluting traits-interfaces with lifetime annotation is
>>>>>> > wrong. Why the trait should have lifetime annotation? It is
>>>>>> > implementation detail.
>>>>>>
>>>>>> Just in case you want to see a case where it *does* make sense to put
>>>>>> a 'self lifetime in a trait definition, here is an example:
>>>>>>
>>>>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> Your ship was destroyed in a monadic eruption.
>>>>
>>>
>>>
>>
>>
>> --
>> Your ship was destroyed in a monadic eruption.
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/ef8a9a38/attachment.html>

From sfackler at andrew.cmu.edu  Sun Sep 29 16:28:01 2013
From: sfackler at andrew.cmu.edu (Steven Fackler)
Date: Sun, 29 Sep 2013 16:28:01 -0700
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
Message-ID: <CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>

Foo can't really be used safely. Say that we have

struct Bar {
    baz: BazPartOfBar
}

struct Foo {
    bar: Bar,
    baz: &'magic BazPartOfBar
}

And let's say we add a `self` syntax to allow field initializers to refer
to other fields:

let foo = Foo {
    bar: Bar {
        baz: BazPartOfBar
    },
    baz: &self.bar.baz
};

We can't really do much with Foo. If we move it, foo.baz is no longer a
valid reference, so that can't happen. We could modify foo.bar in this
case, but not if Bar were defined as

struct Bar {
    baz: ~BazPartOfBar
}

since foo.baz would point to deallocated memory if we replace self.bar or
self.bar.baz.

Steven Fackler


On Sun, Sep 29, 2013 at 3:15 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:

> Could you use struct methods for "quick access"? Or is there a reason this
> wouldn't fit your use case? Sorry, I haven't followed the whole thread
> closely.
>
> struct Owner {
>     owned: ~[int],
> }
>
> impl Owner {
>     fn quick_access<'a>(&'a mut self) -> &'a mut int {
>         &mut self.owned[0]
>     }
> }
>
>
> On Sun, Sep 29, 2013 at 5:32 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> That's... surprising. Even ignoring the fact the name "self" means
>> exactly the opposite (d?j? vu from "const" here)...
>>
>> I don't suppose there's a chance that something like what I expected
>> 'self to be like would be supported at some point? Its lack rules out a lot
>> of reasonable, safe, useful code.
>>
>>
>>
>> On Mon, Sep 30, 2013 at 12:13 AM, G?bor Lehel <illissius at gmail.com>wrote:
>>
>>>
>>> `On Sun, Sep 29, 2013 at 9:21 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>
>>>> Thanks for the explanation. You said two key points:
>>>> - Basically, every object has a lifetime - from its creation to its
>>>> destruction - but a lifetime parameter or argument typically refers to the
>>>> lifetime of something else, which the object itself must not or does not
>>>> outlive.
>>>> And:
>>>> - 'self is not special in any way, except that the compiler has
>>>> historical baggage such that 'self is the only name it lets you use for a
>>>> lifetime parameter on a struct.
>>>>
>>>> So, 'self is indeed very far from what I thought (hoped) it would be.
>>>>
>>>> Taking these together, do I read this right as saying there is no way
>>>> whatsoever to say:
>>>>
>>>> struct Foo {
>>>>     bar: Bar,
>>>>     baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
>>>> }
>>>>
>>>
>>> Per my understanding, this is correct. Because there is a constraint on
>>> the lifetime of a part of `Foo`, there must a constraint on the lifetime of
>>> `Foo`. It has to propagate outwards to make sure the lifetime of the whole
>>> structure is properly constrained. You basically want to "propagate
>>> inwards". I don't think that's possible, but maybe someone will correct me.
>>>
>>>
>>>>
>>>> When writing a non-trivial container, I found several user cases to be
>>>> extremely problematic. One was the above; a container held a "spine" or
>>>> "master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
>>>> borrowed pointers that only live as long as the container and allow quick
>>>> access to specific parts of it.
>>>>
>>>> Is this impossible in Rust (barring use of @ or unsafe pointers)?
>>>>
>>>
>>> This sounds similar to the case of a doubly linked list (with forward
>>> pointers being the "spine" and backwards the "quick access"), which is  not
>>> possible as an 'owned' structure as far as I know without unsafe pointers.
>>>
>>>
>>>>
>>>>
>>>> On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com>wrote:
>>>>
>>>>> 'self is not special in any way, except that the compiler has
>>>>> historical baggage such that 'self is the only name it lets you use for a
>>>>> lifetime parameter on a struct. But that's a bug. In the ideal platonic
>>>>> Rust in the sky, you can have any number of lifetime parameters on a struct
>>>>> with whatever names you prefer.
>>>>>
>>>>> The way I've found to think about lifetimes is that if you have:
>>>>>
>>>>> r_int: &'a int
>>>>>
>>>>> then 'a refers to a span of time (a scope, a lifetime) such that
>>>>> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
>>>>> metaphorically to refer to the original object r_int was created from, not
>>>>> the result of the *r_int expression itself.) So 'a is a kind of stand
>>>>> between to ensure that r_int does not outlive the object it refers to.
>>>>>
>>>>> If you have
>>>>>
>>>>> fn foo<'a>(r_int: &'a int) -> &'a int
>>>>>
>>>>> then just like any other generics argument, the lifetime 'a is chosen
>>>>> by the caller of `foo` (as inferred by the compiler). Typically the caller
>>>>> will have an int object (i: int), then borrow a reference to it (r_int: &'a
>>>>> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
>>>>> int. `foo` will then have to return a reference to (an int that lives at
>>>>> least as long). In practice this could either be the r_int it got as
>>>>> argument, or a static int.
>>>>>
>>>>> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
>>>>> `fn foo<'a>(arg: &'a int)`
>>>>>
>>>>> In the return type position `fn foo() -> &int` is short for
>>>>> `fn foo<'a>() -> &'a int`, meaning `foo` has to return a reference to (an
>>>>> int that lives as long as any lifetime the caller could choose), which in
>>>>> practice means that it has to be 'static. I believe you are or will be
>>>>> required to write &'static explicitly in these cases to avoid confusion.
>>>>>
>>>>> With a struct it's not much different.
>>>>>
>>>>> s: MyStruct<'a> means lifetime_of(s) <= 'a
>>>>> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>>>>>
>>>>> If you have
>>>>>
>>>>> struct MyStruct<'self> {
>>>>>     r_int: &'self int
>>>>> }
>>>>>
>>>>> s: MyStruct<'a>
>>>>>
>>>>> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is
>>>>> trivial because lifetime_of(s) == lifetime_of(s.r_int).)
>>>>>
>>>>> Basically, every object has a lifetime - from its creation to its
>>>>> destruction - but a lifetime parameter or argument typically refers to the
>>>>> lifetime of something else, which the object itself must not or does not
>>>>> outlive.
>>>>>
>>>>> (Please yell at me if I got any of this wrong.)
>>>>>
>>>>>
>>>>>
>>>>> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>>>
>>>>>> Ok, color me confused... perhaps there's somewhere that explains
>>>>>> 'self on more detail? For example, _why_ does the example below not work
>>>>>> without the explicit <'self>? It seems like it should.
>>>>>>
>>>>>> I have yet to truly understand the whole 'self thing. When I first
>>>>>> read about lifetimes, my naive expectations were that:
>>>>>>
>>>>>> - Every struct has a 'self lifetime, which is basically "as long as
>>>>>> this struct exists". It doesn't matter if I have a @ of the struct or a ~
>>>>>> of the struct or just a local variable with the struct... when the struct
>>>>>> is dropped, the lifetime ends.
>>>>>>
>>>>>> - It follows there's no need to ever annotate structs as generic with
>>>>>> a <'self> parameter - it always exists.
>>>>>>
>>>>>> - Any & in a struct is either &'self or &'static. A simple & should
>>>>>> be &'self as that makes more sense (but if Rust wants me to be explicit,
>>>>>> fine).
>>>>>>
>>>>>> This were my "least surprise" expectations, but things don't work
>>>>>> this way... the problem is I don't have a simple mental model to replace
>>>>>> the above with, so I struggle. What _is_ 'self, exactly?
>>>>>>
>>>>>> Isn't a function fn foo(&self) -> &T the same as returning a &'self
>>>>>> T? Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is
>>>>>> "by definition" the same as 'self? How come David's Foo example fails the
>>>>>> borrow check?
>>>>>>
>>>>>> Besides failing (my) "least surprise" expectations, the current rules
>>>>>> also seem to be a "leaky abstraction". If I have a struct that holds a
>>>>>> ComplexT member, it needs no <'self> parameter. If I then add a private
>>>>>> member to my struct to hold some &'self PartOfT (say, cached access to an
>>>>>> internal member), then boom, all uses of my struct now have to say <'self>,
>>>>>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>>>>>> these sort of cached borrowed pointers should be an internal implementation
>>>>>> detail which does not affect the users of the struct at all.
>>>>>>
>>>>>> I suppose there's a good reason for all this, and a reasonable mental
>>>>>> model I need to put in my head, but digging around the docs I didn't find
>>>>>> one... Any hints would be appreciated :-)
>>>>>>
>>>>>>
>>>>>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>>>>>
>>>>>>> Cool! I think that solution is much better than mine.
>>>>>>>
>>>>>>> > But I
>>>>>>> > think that polluting traits-interfaces with lifetime annotation is
>>>>>>> > wrong. Why the trait should have lifetime annotation? It is
>>>>>>> > implementation detail.
>>>>>>>
>>>>>>> Just in case you want to see a case where it *does* make sense to put
>>>>>>> a 'self lifetime in a trait definition, here is an example:
>>>>>>>
>>>>>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>>>>>> _______________________________________________
>>>>>>> Rust-dev mailing list
>>>>>>> Rust-dev at mozilla.org
>>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Your ship was destroyed in a monadic eruption.
>>>>>
>>>>
>>>>
>>>
>>>
>>> --
>>> Your ship was destroyed in a monadic eruption.
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/b3e333f4/attachment-0001.html>

From steven099 at gmail.com  Sun Sep 29 18:26:51 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Sun, 29 Sep 2013 21:26:51 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
Message-ID: <CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>

Yeah, I was trying to come up with a design a while ago to allow
intrastructural borrowed pointers, and basically the effect this had was
that you could never move anything out of the datastructure since that
would leave dangling pointers. Which means you could grow the structure but
never shrink it, which is sort of not good.

Now my thought is about whether it would be possible to make a macro which
allows you to define a safely encapsulated smart node which ensures that
any intrastructural references meet certain invariants about where they
point within the structure, but I haven't developed the idea enough to say
whether you could make something truly general this way.


On Sun, Sep 29, 2013 at 7:28 PM, Steven Fackler <sfackler at andrew.cmu.edu>wrote:

> Foo can't really be used safely. Say that we have
>
> struct Bar {
>     baz: BazPartOfBar
> }
>
> struct Foo {
>     bar: Bar,
>     baz: &'magic BazPartOfBar
> }
>
> And let's say we add a `self` syntax to allow field initializers to refer
> to other fields:
>
> let foo = Foo {
>     bar: Bar {
>         baz: BazPartOfBar
>     },
>     baz: &self.bar.baz
> };
>
> We can't really do much with Foo. If we move it, foo.baz is no longer a
> valid reference, so that can't happen. We could modify foo.bar in this
> case, but not if Bar were defined as
>
> struct Bar {
>     baz: ~BazPartOfBar
> }
>
> since foo.baz would point to deallocated memory if we replace self.bar or
> self.bar.baz.
>
> Steven Fackler
>
>
> On Sun, Sep 29, 2013 at 3:15 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>
>> Could you use struct methods for "quick access"? Or is there a reason
>> this wouldn't fit your use case? Sorry, I haven't followed the whole thread
>> closely.
>>
>> struct Owner {
>>     owned: ~[int],
>> }
>>
>> impl Owner {
>>     fn quick_access<'a>(&'a mut self) -> &'a mut int {
>>         &mut self.owned[0]
>>     }
>> }
>>
>>
>> On Sun, Sep 29, 2013 at 5:32 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>>> That's... surprising. Even ignoring the fact the name "self" means
>>> exactly the opposite (d?j? vu from "const" here)...
>>>
>>> I don't suppose there's a chance that something like what I expected
>>> 'self to be like would be supported at some point? Its lack rules out a lot
>>> of reasonable, safe, useful code.
>>>
>>>
>>>
>>> On Mon, Sep 30, 2013 at 12:13 AM, G?bor Lehel <illissius at gmail.com>wrote:
>>>
>>>>
>>>> `On Sun, Sep 29, 2013 at 9:21 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>>
>>>>> Thanks for the explanation. You said two key points:
>>>>> - Basically, every object has a lifetime - from its creation to its
>>>>> destruction - but a lifetime parameter or argument typically refers to the
>>>>> lifetime of something else, which the object itself must not or does not
>>>>> outlive.
>>>>> And:
>>>>> - 'self is not special in any way, except that the compiler has
>>>>> historical baggage such that 'self is the only name it lets you use for a
>>>>> lifetime parameter on a struct.
>>>>>
>>>>> So, 'self is indeed very far from what I thought (hoped) it would be.
>>>>>
>>>>> Taking these together, do I read this right as saying there is no way
>>>>> whatsoever to say:
>>>>>
>>>>> struct Foo {
>>>>>     bar: Bar,
>>>>>     baz: &'i-live-as-long-as-the-foo-struct-and-no-more BazPartOfBar,
>>>>> }
>>>>>
>>>>
>>>> Per my understanding, this is correct. Because there is a constraint on
>>>> the lifetime of a part of `Foo`, there must a constraint on the lifetime of
>>>> `Foo`. It has to propagate outwards to make sure the lifetime of the whole
>>>> structure is properly constrained. You basically want to "propagate
>>>> inwards". I don't think that's possible, but maybe someone will correct me.
>>>>
>>>>
>>>>>
>>>>> When writing a non-trivial container, I found several user cases to be
>>>>> extremely problematic. One was the above; a container held a "spine" or
>>>>> "master" or "owned" or whatever-you-want-to-call-it data structure(s), plus
>>>>> borrowed pointers that only live as long as the container and allow quick
>>>>> access to specific parts of it.
>>>>>
>>>>> Is this impossible in Rust (barring use of @ or unsafe pointers)?
>>>>>
>>>>
>>>> This sounds similar to the case of a doubly linked list (with forward
>>>> pointers being the "spine" and backwards the "quick access"), which is  not
>>>> possible as an 'owned' structure as far as I know without unsafe pointers.
>>>>
>>>>
>>>>>
>>>>>
>>>>> On Sun, Sep 29, 2013 at 8:24 PM, G?bor Lehel <illissius at gmail.com>wrote:
>>>>>
>>>>>> 'self is not special in any way, except that the compiler has
>>>>>> historical baggage such that 'self is the only name it lets you use for a
>>>>>> lifetime parameter on a struct. But that's a bug. In the ideal platonic
>>>>>> Rust in the sky, you can have any number of lifetime parameters on a struct
>>>>>> with whatever names you prefer.
>>>>>>
>>>>>> The way I've found to think about lifetimes is that if you have:
>>>>>>
>>>>>> r_int: &'a int
>>>>>>
>>>>>> then 'a refers to a span of time (a scope, a lifetime) such that
>>>>>> lifetime_of(r_int) <= 'a <= lifetime_of(*r_int). (Where *r_int is intended
>>>>>> metaphorically to refer to the original object r_int was created from, not
>>>>>> the result of the *r_int expression itself.) So 'a is a kind of stand
>>>>>> between to ensure that r_int does not outlive the object it refers to.
>>>>>>
>>>>>> If you have
>>>>>>
>>>>>> fn foo<'a>(r_int: &'a int) -> &'a int
>>>>>>
>>>>>> then just like any other generics argument, the lifetime 'a is chosen
>>>>>> by the caller of `foo` (as inferred by the compiler). Typically the caller
>>>>>> will have an int object (i: int), then borrow a reference to it (r_int: &'a
>>>>>> int = &i) which it passes to `foo`, and then 'a will be the lifetime of the
>>>>>> int. `foo` will then have to return a reference to (an int that lives at
>>>>>> least as long). In practice this could either be the r_int it got as
>>>>>> argument, or a static int.
>>>>>>
>>>>>> `fn foo(arg: &int)` is shorthand for an anonymous lifetime parameter:
>>>>>> `fn foo<'a>(arg: &'a int)`
>>>>>>
>>>>>> In the return type position `fn foo() -> &int` is short for
>>>>>> `fn foo<'a>() -> &'a int`, meaning `foo` has to return a reference to (an
>>>>>> int that lives as long as any lifetime the caller could choose), which in
>>>>>> practice means that it has to be 'static. I believe you are or will be
>>>>>> required to write &'static explicitly in these cases to avoid confusion.
>>>>>>
>>>>>> With a struct it's not much different.
>>>>>>
>>>>>> s: MyStruct<'a> means lifetime_of(s) <= 'a
>>>>>> s: MyStruct<'a, 'b> means lifetime_of(s) <= 'a && lifetime_of(s) <= 'b
>>>>>>
>>>>>> If you have
>>>>>>
>>>>>> struct MyStruct<'self> {
>>>>>>     r_int: &'self int
>>>>>> }
>>>>>>
>>>>>> s: MyStruct<'a>
>>>>>>
>>>>>> then lifetime_of(s) <= 'a && lifetime_of(s.r_int) <= 'a. (Which is
>>>>>> trivial because lifetime_of(s) == lifetime_of(s.r_int).)
>>>>>>
>>>>>> Basically, every object has a lifetime - from its creation to its
>>>>>> destruction - but a lifetime parameter or argument typically refers to the
>>>>>> lifetime of something else, which the object itself must not or does not
>>>>>> outlive.
>>>>>>
>>>>>> (Please yell at me if I got any of this wrong.)
>>>>>>
>>>>>>
>>>>>>
>>>>>> On Sun, Sep 29, 2013 at 5:23 PM, Oren Ben-Kiki <oren at ben-kiki.org>wrote:
>>>>>>
>>>>>>> Ok, color me confused... perhaps there's somewhere that explains
>>>>>>> 'self on more detail? For example, _why_ does the example below not work
>>>>>>> without the explicit <'self>? It seems like it should.
>>>>>>>
>>>>>>> I have yet to truly understand the whole 'self thing. When I first
>>>>>>> read about lifetimes, my naive expectations were that:
>>>>>>>
>>>>>>> - Every struct has a 'self lifetime, which is basically "as long as
>>>>>>> this struct exists". It doesn't matter if I have a @ of the struct or a ~
>>>>>>> of the struct or just a local variable with the struct... when the struct
>>>>>>> is dropped, the lifetime ends.
>>>>>>>
>>>>>>> - It follows there's no need to ever annotate structs as generic
>>>>>>> with a <'self> parameter - it always exists.
>>>>>>>
>>>>>>> - Any & in a struct is either &'self or &'static. A simple & should
>>>>>>> be &'self as that makes more sense (but if Rust wants me to be explicit,
>>>>>>> fine).
>>>>>>>
>>>>>>> This were my "least surprise" expectations, but things don't work
>>>>>>> this way... the problem is I don't have a simple mental model to replace
>>>>>>> the above with, so I struggle. What _is_ 'self, exactly?
>>>>>>>
>>>>>>> Isn't a function fn foo(&self) -> &T the same as returning a &'self
>>>>>>> T? Why would I want to say fn foo<'a>(&'a self) in the 1st place - 'a is
>>>>>>> "by definition" the same as 'self? How come David's Foo example fails the
>>>>>>> borrow check?
>>>>>>>
>>>>>>> Besides failing (my) "least surprise" expectations, the current
>>>>>>> rules also seem to be a "leaky abstraction". If I have a struct that holds
>>>>>>> a ComplexT member, it needs no <'self> parameter. If I then add a private
>>>>>>> member to my struct to hold some &'self PartOfT (say, cached access to an
>>>>>>> internal member), then boom, all uses of my struct now have to say <'self>,
>>>>>>> I can no longer put it in thread-local-storage, etc. I'd expect keeping
>>>>>>> these sort of cached borrowed pointers should be an internal implementation
>>>>>>> detail which does not affect the users of the struct at all.
>>>>>>>
>>>>>>> I suppose there's a good reason for all this, and a reasonable
>>>>>>> mental model I need to put in my head, but digging around the docs I didn't
>>>>>>> find one... Any hints would be appreciated :-)
>>>>>>>
>>>>>>>
>>>>>>> On Sun, Sep 29, 2013 at 5:42 PM, David Renshaw <dwrenshaw at gmail.com>wrote:
>>>>>>>
>>>>>>>> Cool! I think that solution is much better than mine.
>>>>>>>>
>>>>>>>> > But I
>>>>>>>> > think that polluting traits-interfaces with lifetime annotation is
>>>>>>>> > wrong. Why the trait should have lifetime annotation? It is
>>>>>>>> > implementation detail.
>>>>>>>>
>>>>>>>> Just in case you want to see a case where it *does* make sense to
>>>>>>>> put
>>>>>>>> a 'self lifetime in a trait definition, here is an example:
>>>>>>>>
>>>>>>>> https://gist.github.com/dwrensha/db919b8e130e9eb72f0f
>>>>>>>> _______________________________________________
>>>>>>>> Rust-dev mailing list
>>>>>>>> Rust-dev at mozilla.org
>>>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Rust-dev mailing list
>>>>>>> Rust-dev at mozilla.org
>>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> --
>>>>>> Your ship was destroyed in a monadic eruption.
>>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> Your ship was destroyed in a monadic eruption.
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130929/3569fc2f/attachment-0001.html>

From oren at ben-kiki.org  Sun Sep 29 23:31:33 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 30 Sep 2013 09:31:33 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
Message-ID: <CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>

Huh, this is _exactly_ my use case. I have data structures which I grow but
never shrink, and I never move anything out of them. This idiom isn't that
uncommon when writing in functional style...

I incrementally build a complex structure that allows quick access to the
same pieces using different criteria (e.g., access a piece by a unique id,
or look it up by a path, or via a direct pointer held by a related piece,
etc.). All accesses are of (possibly mutable) borrowed pointers that live
as long as the whole thing exist. Then when done I can discard the whole
thing.

Sometimes I have a less-complex structure to which I attach a related
"view" structure. The view holds borrowed pointers to pieces of the
original immutable structure, allowing efficient access in new and
interesting ways. When done I can then discard the view and keep the
original.

So basically, I want something that gives me the freedoms granted to
&'static, but only for as long as the "main" structure provably exists.
Something like &'shadow :-)

I found Rust doesn't like these idioms at all. I some cases, where I was
too tired, performance wasn't an issue, and there was no need to send the
whole thing between tasks, I just used @ pointers. Otherwise, I used RcMut,
though this incurs boilerplate access code and hurts performance for no
"real" reason. In critical cases I may end up using unsafe pointers...

Using a macro - hmm. Interesting and if possible, would be a great
solution. I'm not certain what such a macro would expand to, though. It
would need to be something that would express the concept of "I live only
as long as my container structure" _somehow_, and I thought we established
that can't be done...

Thanks,

Oren.

On Mon, Sep 30, 2013 at 4:26 AM, Steven Blenkinsop <steven099 at gmail.com>wrote:

> Yeah, I was trying to come up with a design a while ago to allow
> intrastructural borrowed pointers, and basically the effect this had was
> that you could never move anything out of the datastructure since that
> would leave dangling pointers. Which means you could grow the structure but
> never shrink it, which is sort of not good.
>
> Now my thought is about whether it would be possible to make a macro which
> allows you to define a safely encapsulated smart node which ensures that
> any intrastructural references meet certain invariants about where they
> point within the structure, but I haven't developed the idea enough to say
> whether you could make something truly general this way.
>
>
> On Sun, Sep 29, 2013 at 7:28 PM, Steven Fackler <sfackler at andrew.cmu.edu>wrote:
>
>> Foo can't really be used safely. Say that we have
>>
>> struct Bar {
>>     baz: BazPartOfBar
>> }
>>
>> struct Foo {
>>     bar: Bar,
>>     baz: &'magic BazPartOfBar
>> }
>>
>> And let's say we add a `self` syntax to allow field initializers to refer
>> to other fields:
>>
>> let foo = Foo {
>>     bar: Bar {
>>         baz: BazPartOfBar
>>     },
>>     baz: &self.bar.baz
>> };
>>
>> We can't really do much with Foo. If we move it, foo.baz is no longer a
>> valid reference, so that can't happen. We could modify foo.bar in this
>> case, but not if Bar were defined as
>>
>> struct Bar {
>>     baz: ~BazPartOfBar
>> }
>>
>> since foo.baz would point to deallocated memory if we replace self.bar or
>> self.bar.baz.
>>
>> Steven Fackler
>>
>>
>> On Sun, Sep 29, 2013 at 3:15 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>>
>>> Could you use struct methods for "quick access"? Or is there a reason
>>> this wouldn't fit your use case? Sorry, I haven't followed the whole thread
>>> closely.
>>>
>>> struct Owner {
>>>     owned: ~[int],
>>> }
>>>
>>> impl Owner {
>>>     fn quick_access<'a>(&'a mut self) -> &'a mut int {
>>>         &mut self.owned[0]
>>>     }
>>> }
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/ea282e27/attachment.html>

From vadimcn at gmail.com  Mon Sep 30 00:06:51 2013
From: vadimcn at gmail.com (Vadim)
Date: Mon, 30 Sep 2013 00:06:51 -0700
Subject: [rust-dev] How to express "T : Foo<X1> implies T : Foo<X2>" ?
Message-ID: <CADecdiLRSGhDdx63VOcdrHoyETaxTKZ--H8b38QPb3x17y5npA@mail.gmail.com>

Hi,
I don't understand why the following produces an error:

>cat test.rs

trait Foo<T> {}
struct X1;
struct X2;

impl<T: Foo<X1>> Foo<X2> for T {}

fn main() {}

>rustc test.rs
test.rs:6:0: 6:33 error: expected Foo<X2>, but found Foo<X1> (expected
struct X2 but found struct X1)
test.rs:6 impl<T: Foo<X1>> Foo<X2> for T {}
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error


I'm trying to say "Any type that implements Foo<X1> also implements
Foo<X2>"...   What's wrong here?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/f41c13b2/attachment.html>

From lists at dhardy.name  Mon Sep 30 02:05:47 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Mon, 30 Sep 2013 11:05:47 +0200
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CA+4_Dk7=SPHWWsHas1D-LUyhrDEo821Px+5RtJm5UGD-bxG1Hw@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAJnHWXvk0VHx09REVpj22Pf_CcSSchZ=kvR3txaSH9x105XiUQ@mail.gmail.com>
	<CA+4_Dk7=SPHWWsHas1D-LUyhrDEo821Px+5RtJm5UGD-bxG1Hw@mail.gmail.com>
Message-ID: <138056182.oJi1GHLfag@tph-l10036>

On Sunday 29 September 2013 12:26:05 Callme Whatiwant wrote:
> On Tue, Sep 10, 2013 at 12:39 AM, Marijn Haverbeke <marijnh at gmail.com> 
wrote:
> > The Rust team is aware of this possibility, and is guarding against it
> > by keeping a log of checksums and source git revisions for the various
> > versions of the compiler, so that compilers downloaded from the net
> > can be checked, and we could, if something dodgy is found, back-track
> > to a known trusted version of the compiler (or even all the way back
> > to the OCaml bootstrap compiler, though that'd be a lot of work).
> > 
> > It is theoretically possible that someone manages to sneak in a commit
> > that adds an exploit to the compiler, but since patches are reviewed,
> > that is not terribly likely to succeed. Also, Rust is a small target
> > still, and it would be a marvelous feat of engineering to install a
> > functioning exploit in a compiler that is being overhauled and changed
> > all the time.
> 
> It's great that the team considers this and has a plan.  This kind of
> attention to detail (including security detail) really attracts me to
> rust!  Keep it up.
> 

Another tack on (way of addressing) the problem would be a Rust-to-C++ (or 
other) code converter, thus allowing the Rust compiler to be built with GCC or 
another compiler using (hopefully reasonably) readable C++ (or other) code.

Obviously converting Rust to C++ would lose out a lot of the compile-time 
safety and result in less readable code, but is it feasible? Such a converter 
would have other benefits too (such as making it easier to migrate away from 
Rust should the need arise and use some existing code analysis tools), hence 
my asking.

I guess the standard library could be an issue, but there it would probably be 
easier to convert the library as a whole instead of porting code to a different 
library. Maybe tasks and a few other features would also present difficulties. 
Traits don't quite map to classes and generics don't quite map to templates. 
Has anybody thought more about this?
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/18b7d9b0/attachment.sig>

From j.e.aten at gmail.com  Mon Sep 30 02:52:29 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 02:52:29 -0700
Subject: [rust-dev] rust-msgpack now works with rust 0.8
Message-ID: <CAPNEFAZeVmK71JsdiA0zNd5s5Q5CpBLh8Y8VOH+o1njUSTv=jQ@mail.gmail.com>

The rust-msgpack bindings now work with Rust 0.8:

https://github.com/glycerine/rust-msgpack

and a pull request (along with a request to supply a license compatible
with Rust) has been submitted to the originator here

https://github.com/mneumann/rust-msgpack

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/9690c3c6/attachment.html>

From armin.ronacher at active-4.com  Mon Sep 30 03:07:14 2013
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Mon, 30 Sep 2013 11:07:14 +0100
Subject: [rust-dev] Rust compiler bootstrapped
In-Reply-To: <CAJGrnh3s9fVASihhzs34=SHd7RNzoYfXcGm1fXxvCc+aq64RDw@mail.gmail.com>
References: <522EC3B7.4040304@proinbox.com>
	<CAAS2fgS3HfH9Tgu6g_ogXtW-+xD+yMcGGThsc9BhQ8p9KwhpJg@mail.gmail.com>
	<CA++BO6R3EgEAadC1gOGFfJ+ds7bLM0YL598zkhGz0a7ceTmqMA@mail.gmail.com>
	<20130913095113.GE6242@Mr-Bennet>
	<CAJGrnh3s9fVASihhzs34=SHd7RNzoYfXcGm1fXxvCc+aq64RDw@mail.gmail.com>
Message-ID: <52494D52.7020902@active-4.com>

Hi,

On 13/09/2013 11:27, Robert Knight wrote:
> Realistically though, how many implementations are libre and complete
> enough to actually build a C++ compiler?
What is libre?

There are tons of C++ compilers out there and they are surprisingly 
compatible.  Both the ones from traditional vendors like Microsoft as 
well as Open Source efforts such as Clang.


Regards,
Armin

From illissius at gmail.com  Mon Sep 30 03:17:26 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 30 Sep 2013 12:17:26 +0200
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
Message-ID: <CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>

On Mon, Sep 30, 2013 at 8:31 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Huh, this is _exactly_ my use case. I have data structures which I grow
> but never shrink, and I never move anything out of them. This idiom isn't
> that uncommon when writing in functional style...
>
> I incrementally build a complex structure that allows quick access to the
> same pieces using different criteria (e.g., access a piece by a unique id,
> or look it up by a path, or via a direct pointer held by a related piece,
> etc.). All accesses are of (possibly mutable) borrowed pointers that live
> as long as the whole thing exist. Then when done I can discard the whole
> thing.
>

Just a thought, but when you write "incrementally build a complex structure
... discard the whole thing", I think "arena allocation". That /might/
solve your borrowed pointer woes by letting you pervasively use borrowed
pointers which all live at-most-as-long-as the arena (and hence the
structure) itself. The borrow checker in my head is not advanced enough to
let me really think it through though. And I don't think the compiler will
let you send anything if there are borrowed pointers involved. There's an
`arena` module[1] in libextra, but I've never tried it, and it uses `@`
pointers internally which also precludes sending.

(I wonder if there's any way to safely encode the idea that if all pointers
are internal to the arena (there's nothing pointing in or out), then
sending an ~arena should be safe, because its location in memory doesn't
change. Presumably you would also need to move-send a pointer to the
beginning of the structure inside of the arena alongside it. Maybe borrowed
pointers are not the best fit here, or maybe they are, I dunno.)

[1]: http://static.rust-lang.org/doc/master/extra/arena/struct.Arena.html



>
> Sometimes I have a less-complex structure to which I attach a related
> "view" structure. The view holds borrowed pointers to pieces of the
> original immutable structure, allowing efficient access in new and
> interesting ways. When done I can then discard the view and keep the
> original.
>
> So basically, I want something that gives me the freedoms granted to
> &'static, but only for as long as the "main" structure provably exists.
> Something like &'shadow :-)
>
> I found Rust doesn't like these idioms at all. I some cases, where I was
> too tired, performance wasn't an issue, and there was no need to send the
> whole thing between tasks, I just used @ pointers. Otherwise, I used RcMut,
> though this incurs boilerplate access code and hurts performance for no
> "real" reason. In critical cases I may end up using unsafe pointers...
>
> Using a macro - hmm. Interesting and if possible, would be a great
> solution. I'm not certain what such a macro would expand to, though. It
> would need to be something that would express the concept of "I live only
> as long as my container structure" _somehow_, and I thought we established
> that can't be done...
>
> Thanks,
>
> Oren.
>
> On Mon, Sep 30, 2013 at 4:26 AM, Steven Blenkinsop <steven099 at gmail.com>wrote:
>
>> Yeah, I was trying to come up with a design a while ago to allow
>> intrastructural borrowed pointers, and basically the effect this had was
>> that you could never move anything out of the datastructure since that
>> would leave dangling pointers. Which means you could grow the structure but
>> never shrink it, which is sort of not good.
>>
>> Now my thought is about whether it would be possible to make a macro
>> which allows you to define a safely encapsulated smart node which ensures
>> that any intrastructural references meet certain invariants about where
>> they point within the structure, but I haven't developed the idea enough to
>> say whether you could make something truly general this way.
>>
>>
>> On Sun, Sep 29, 2013 at 7:28 PM, Steven Fackler <sfackler at andrew.cmu.edu>wrote:
>>
>>> Foo can't really be used safely. Say that we have
>>>
>>> struct Bar {
>>>     baz: BazPartOfBar
>>> }
>>>
>>> struct Foo {
>>>     bar: Bar,
>>>     baz: &'magic BazPartOfBar
>>> }
>>>
>>> And let's say we add a `self` syntax to allow field initializers to
>>> refer to other fields:
>>>
>>> let foo = Foo {
>>>     bar: Bar {
>>>         baz: BazPartOfBar
>>>     },
>>>     baz: &self.bar.baz
>>> };
>>>
>>> We can't really do much with Foo. If we move it, foo.baz is no longer a
>>> valid reference, so that can't happen. We could modify foo.bar in this
>>> case, but not if Bar were defined as
>>>
>>> struct Bar {
>>>     baz: ~BazPartOfBar
>>> }
>>>
>>> since foo.baz would point to deallocated memory if we replace self.bar
>>> or self.bar.baz.
>>>
>>> Steven Fackler
>>>
>>>
>>> On Sun, Sep 29, 2013 at 3:15 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>>>
>>>> Could you use struct methods for "quick access"? Or is there a reason
>>>> this wouldn't fit your use case? Sorry, I haven't followed the whole thread
>>>> closely.
>>>>
>>>> struct Owner {
>>>>     owned: ~[int],
>>>> }
>>>>
>>>> impl Owner {
>>>>     fn quick_access<'a>(&'a mut self) -> &'a mut int {
>>>>         &mut self.owned[0]
>>>>     }
>>>> }
>>>>
>>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/e0d54f87/attachment-0001.html>

From oren at ben-kiki.org  Mon Sep 30 03:56:08 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 30 Sep 2013 13:56:08 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
	<CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
Message-ID: <CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>

Yes, it is very much like an arena... And yes, the idea is that all the
pointers are contained in it, so the ~arena as a whole should be safe to
send, but that contradicts using @ - maybe it could be re-written using
Rc... hmmm. At any rate, thanks for the pointer - I wasn't aware of arenas
before.

Another hmmm... An arena sounds a lot like a weak version of a GC-ed
heap... So here's a thought: What if @ pointers had a heap associated with
them, just like & pointers have a lifetime? We have the task-global @ heap,
and we have the static & lifetime... but we can explicitly manage &
lifetimes - how about if we could explicitly create a new Gc-heap use it to
happily muck about with @'my-heap pointers (which would be statically
prevented from being mixed with @'other-heap pointers), and be able to send
the whole heap between tasks, etc.? (Not that I necessarily suggest @'heap
as a syntax, but you get the idea)

Gc would still run in the context of one heap at a time... but this would
remove the restriction of one task <=> one heap.



On Mon, Sep 30, 2013 at 1:17 PM, G?bor Lehel <illissius at gmail.com> wrote:

> On Mon, Sep 30, 2013 at 8:31 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Huh, this is _exactly_ my use case. I have data structures which I grow
>> but never shrink, and I never move anything out of them. This idiom isn't
>> that uncommon when writing in functional style...
>>
>> I incrementally build a complex structure that allows quick access to the
>> same pieces using different criteria (e.g., access a piece by a unique id,
>> or look it up by a path, or via a direct pointer held by a related piece,
>> etc.). All accesses are of (possibly mutable) borrowed pointers that live
>> as long as the whole thing exist. Then when done I can discard the whole
>> thing.
>>
>
> Just a thought, but when you write "incrementally build a complex
> structure ... discard the whole thing", I think "arena allocation". That
> /might/ solve your borrowed pointer woes by letting you pervasively use
> borrowed pointers which all live at-most-as-long-as the arena (and hence
> the structure) itself. The borrow checker in my head is not advanced enough
> to let me really think it through though. And I don't think the compiler
> will let you send anything if there are borrowed pointers involved. There's
> an `arena` module[1] in libextra, but I've never tried it, and it uses `@`
> pointers internally which also precludes sending.
>
> (I wonder if there's any way to safely encode the idea that if all
> pointers are internal to the arena (there's nothing pointing in or out),
> then sending an ~arena should be safe, because its location in memory
> doesn't change. Presumably you would also need to move-send a pointer to
> the beginning of the structure inside of the arena alongside it. Maybe
> borrowed pointers are not the best fit here, or maybe they are, I dunno.)
>
> [1]: http://static.rust-lang.org/doc/master/extra/arena/struct.Arena.html
>
>
>
>>
>> Sometimes I have a less-complex structure to which I attach a related
>> "view" structure. The view holds borrowed pointers to pieces of the
>> original immutable structure, allowing efficient access in new and
>> interesting ways. When done I can then discard the view and keep the
>> original.
>>
>> So basically, I want something that gives me the freedoms granted to
>> &'static, but only for as long as the "main" structure provably exists.
>> Something like &'shadow :-)
>>
>> I found Rust doesn't like these idioms at all. I some cases, where I was
>> too tired, performance wasn't an issue, and there was no need to send the
>> whole thing between tasks, I just used @ pointers. Otherwise, I used RcMut,
>> though this incurs boilerplate access code and hurts performance for no
>> "real" reason. In critical cases I may end up using unsafe pointers...
>>
>> Using a macro - hmm. Interesting and if possible, would be a great
>> solution. I'm not certain what such a macro would expand to, though. It
>> would need to be something that would express the concept of "I live only
>> as long as my container structure" _somehow_, and I thought we established
>> that can't be done...
>>
>> Thanks,
>>
>> Oren.
>>
>> On Mon, Sep 30, 2013 at 4:26 AM, Steven Blenkinsop <steven099 at gmail.com>wrote:
>>
>>> Yeah, I was trying to come up with a design a while ago to allow
>>> intrastructural borrowed pointers, and basically the effect this had was
>>> that you could never move anything out of the datastructure since that
>>> would leave dangling pointers. Which means you could grow the structure but
>>> never shrink it, which is sort of not good.
>>>
>>> Now my thought is about whether it would be possible to make a macro
>>> which allows you to define a safely encapsulated smart node which ensures
>>> that any intrastructural references meet certain invariants about where
>>> they point within the structure, but I haven't developed the idea enough to
>>> say whether you could make something truly general this way.
>>>
>>>
>>> On Sun, Sep 29, 2013 at 7:28 PM, Steven Fackler <sfackler at andrew.cmu.edu
>>> > wrote:
>>>
>>>> Foo can't really be used safely. Say that we have
>>>>
>>>> struct Bar {
>>>>     baz: BazPartOfBar
>>>> }
>>>>
>>>> struct Foo {
>>>>     bar: Bar,
>>>>     baz: &'magic BazPartOfBar
>>>> }
>>>>
>>>> And let's say we add a `self` syntax to allow field initializers to
>>>> refer to other fields:
>>>>
>>>> let foo = Foo {
>>>>     bar: Bar {
>>>>         baz: BazPartOfBar
>>>>     },
>>>>     baz: &self.bar.baz
>>>> };
>>>>
>>>> We can't really do much with Foo. If we move it, foo.baz is no longer a
>>>> valid reference, so that can't happen. We could modify foo.bar in this
>>>> case, but not if Bar were defined as
>>>>
>>>> struct Bar {
>>>>     baz: ~BazPartOfBar
>>>> }
>>>>
>>>> since foo.baz would point to deallocated memory if we replace self.bar
>>>> or self.bar.baz.
>>>>
>>>> Steven Fackler
>>>>
>>>>
>>>> On Sun, Sep 29, 2013 at 3:15 PM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>>>>
>>>>> Could you use struct methods for "quick access"? Or is there a reason
>>>>> this wouldn't fit your use case? Sorry, I haven't followed the whole thread
>>>>> closely.
>>>>>
>>>>> struct Owner {
>>>>>     owned: ~[int],
>>>>> }
>>>>>
>>>>> impl Owner {
>>>>>     fn quick_access<'a>(&'a mut self) -> &'a mut int {
>>>>>         &mut self.owned[0]
>>>>>     }
>>>>> }
>>>>>
>>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/b2a87654/attachment.html>

From steven099 at gmail.com  Mon Sep 30 07:34:33 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Mon, 30 Sep 2013 10:34:33 -0400
Subject: [rust-dev] Trait method self parameter type clashes with lifetime
 annotation required by the implementation
In-Reply-To: <CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
	<CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
	<CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>
Message-ID: <CANjmGJtp29FE-y2L+Qj7JOUn__J9LCV-JARBiDDk-LrgA-5EXA@mail.gmail.com>

On Monday, 30 September 2013, Oren Ben-Kiki wrote:

> Yes, it is very much like an arena... And yes, the idea is that all the
> pointers are contained in it, so the ~arena as a whole should be safe to
> send, but that contradicts using @ - maybe it could be re-written using
> Rc... hmmm. At any rate, thanks for the pointer - I wasn't aware of arenas
> before.
>
> Another hmmm... An arena sounds a lot like a weak version of a GC-ed
> heap... So here's a thought: What if @ pointers had a heap associated with
> them, just like & pointers have a lifetime? We have the task-global @ heap,
> and we have the static & lifetime... but we can explicitly manage &
> lifetimes - how about if we could explicitly create a new Gc-heap use it to
> happily muck about with @'my-heap pointers (which would be statically
> prevented from being mixed with @'other-heap pointers), and be able to send
> the whole heap between tasks, etc.? (Not that I necessarily suggest @'heap
> as a syntax, but you get the idea)
>
> Gc would still run in the context of one heap at a time... but this would
> remove the restriction of one task <=> one heap.
>

This would be neat, yes. In this case, accessing such a heap would be
conceptually identical to temporarily joining a task, except without the
overhead of having to schedule it, since it would have no independently
executing code. Figuring out how to hook it into the GC would be a neat
trick...

As for what a macro would expand to, I was thinking more that it would
expand to the containing structure and some smart references that use
lifetimes to ensure that the containing structure is pinned during their
existence and that they don't outlive it. You'd have to interact with it
using methods which make sure you can't break any of the invariants, such
as aliasing something and then trying to freeze it. To what extent you
could do this statically rather than dynamically, I'm not sure, but
lifetimes are a fairly powerful concept, so it's plausible one could work
something out. Doing it dynamically would basically mean using Cells
modified to have lifetimes as the smart references into the structure. It
would be nice to have a version of the smart references that ensured you
didn't externally alias something which is also externally mutable, though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/532a6ed5/attachment-0001.html>

From oren at ben-kiki.org  Mon Sep 30 07:48:38 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 30 Sep 2013 17:48:38 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CANjmGJtp29FE-y2L+Qj7JOUn__J9LCV-JARBiDDk-LrgA-5EXA@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
	<CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
	<CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>
	<CANjmGJtp29FE-y2L+Qj7JOUn__J9LCV-JARBiDDk-LrgA-5EXA@mail.gmail.com>
Message-ID: <CADJiDhu+SkigokLN1D49X5OragaYUwmh8_5ZyZgG+08e507KKg@mail.gmail.com>

I see what you mean about the macro - it would get quite complex though.

Regardless of macros, neat extensions with GC heaps and arenas and so on...

I still find it surprising that it is flat-out impossible to explicitly
name the "default" lifetime of a struct, and also that the natural name for
this lifetime ('self) is used for an entirely different purpose.

It would be nice if we could rename the existing 'self to something
(anything :-) else, and allow 'self to be used in struct field types and
elsewhere for the more natural (and currently unavailable) "lifetime of the
current struct". Yes, this comes with some limitations, but it is useful
for some interesting cases and its lack of an explicit name seems arbitrary
(it is the default in many cases, after all).

At any rate, I now have a better grasp of what is going on, so I have a
better chance of writing code that actually works :-)

Thanks for the explanations!


On Mon, Sep 30, 2013 at 5:34 PM, Steven Blenkinsop <steven099 at gmail.com>wrote:

> On Monday, 30 September 2013, Oren Ben-Kiki wrote:
>
>> Yes, it is very much like an arena... And yes, the idea is that all the
>> pointers are contained in it, so the ~arena as a whole should be safe to
>> send, but that contradicts using @ - maybe it could be re-written using
>> Rc... hmmm. At any rate, thanks for the pointer - I wasn't aware of arenas
>> before.
>>
>> Another hmmm... An arena sounds a lot like a weak version of a GC-ed
>> heap... So here's a thought: What if @ pointers had a heap associated with
>> them, just like & pointers have a lifetime? We have the task-global @ heap,
>> and we have the static & lifetime... but we can explicitly manage &
>> lifetimes - how about if we could explicitly create a new Gc-heap use it to
>> happily muck about with @'my-heap pointers (which would be statically
>> prevented from being mixed with @'other-heap pointers), and be able to send
>> the whole heap between tasks, etc.? (Not that I necessarily suggest @'heap
>> as a syntax, but you get the idea)
>>
>> Gc would still run in the context of one heap at a time... but this would
>> remove the restriction of one task <=> one heap.
>>
>
> This would be neat, yes. In this case, accessing such a heap would be
> conceptually identical to temporarily joining a task, except without the
> overhead of having to schedule it, since it would have no independently
> executing code. Figuring out how to hook it into the GC would be a neat
> trick...
>
> As for what a macro would expand to, I was thinking more that it would
> expand to the containing structure and some smart references that use
> lifetimes to ensure that the containing structure is pinned during their
> existence and that they don't outlive it. You'd have to interact with it
> using methods which make sure you can't break any of the invariants, such
> as aliasing something and then trying to freeze it. To what extent you
> could do this statically rather than dynamically, I'm not sure, but
> lifetimes are a fairly powerful concept, so it's plausible one could work
> something out. Doing it dynamically would basically mean using Cells
> modified to have lifetimes as the smart references into the structure. It
> would be nice to have a version of the smart references that ensured you
> didn't externally alias something which is also externally mutable, though.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/8cc6fe3e/attachment.html>

From ben.striegel at gmail.com  Mon Sep 30 09:01:42 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 30 Sep 2013 12:01:42 -0400
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CADJiDhu+SkigokLN1D49X5OragaYUwmh8_5ZyZgG+08e507KKg@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
	<CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
	<CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>
	<CANjmGJtp29FE-y2L+Qj7JOUn__J9LCV-JARBiDDk-LrgA-5EXA@mail.gmail.com>
	<CADJiDhu+SkigokLN1D49X5OragaYUwmh8_5ZyZgG+08e507KKg@mail.gmail.com>
Message-ID: <CAAvrL-=FiuFAstpvySvaRww-vJPwr7qZC+hrqdoTMHAzkXmVAQ@mail.gmail.com>

I've only skimmed this conversation, but note that the "specialness" of the
'self lifetime will be going away in the future.


On Mon, Sep 30, 2013 at 10:48 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I see what you mean about the macro - it would get quite complex though.
>
> Regardless of macros, neat extensions with GC heaps and arenas and so on...
>
> I still find it surprising that it is flat-out impossible to explicitly
> name the "default" lifetime of a struct, and also that the natural name for
> this lifetime ('self) is used for an entirely different purpose.
>
> It would be nice if we could rename the existing 'self to something
> (anything :-) else, and allow 'self to be used in struct field types and
> elsewhere for the more natural (and currently unavailable) "lifetime of the
> current struct". Yes, this comes with some limitations, but it is useful
> for some interesting cases and its lack of an explicit name seems arbitrary
> (it is the default in many cases, after all).
>
> At any rate, I now have a better grasp of what is going on, so I have a
> better chance of writing code that actually works :-)
>
> Thanks for the explanations!
>
>
> On Mon, Sep 30, 2013 at 5:34 PM, Steven Blenkinsop <steven099 at gmail.com>wrote:
>
>> On Monday, 30 September 2013, Oren Ben-Kiki wrote:
>>
>>> Yes, it is very much like an arena... And yes, the idea is that all the
>>> pointers are contained in it, so the ~arena as a whole should be safe to
>>> send, but that contradicts using @ - maybe it could be re-written using
>>> Rc... hmmm. At any rate, thanks for the pointer - I wasn't aware of arenas
>>> before.
>>>
>>> Another hmmm... An arena sounds a lot like a weak version of a GC-ed
>>> heap... So here's a thought: What if @ pointers had a heap associated with
>>> them, just like & pointers have a lifetime? We have the task-global @ heap,
>>> and we have the static & lifetime... but we can explicitly manage &
>>> lifetimes - how about if we could explicitly create a new Gc-heap use it to
>>> happily muck about with @'my-heap pointers (which would be statically
>>> prevented from being mixed with @'other-heap pointers), and be able to send
>>> the whole heap between tasks, etc.? (Not that I necessarily suggest @'heap
>>> as a syntax, but you get the idea)
>>>
>>> Gc would still run in the context of one heap at a time... but this
>>> would remove the restriction of one task <=> one heap.
>>>
>>
>> This would be neat, yes. In this case, accessing such a heap would be
>> conceptually identical to temporarily joining a task, except without the
>> overhead of having to schedule it, since it would have no independently
>> executing code. Figuring out how to hook it into the GC would be a neat
>> trick...
>>
>> As for what a macro would expand to, I was thinking more that it would
>> expand to the containing structure and some smart references that use
>> lifetimes to ensure that the containing structure is pinned during their
>> existence and that they don't outlive it. You'd have to interact with it
>> using methods which make sure you can't break any of the invariants, such
>> as aliasing something and then trying to freeze it. To what extent you
>> could do this statically rather than dynamically, I'm not sure, but
>> lifetimes are a fairly powerful concept, so it's plausible one could work
>> something out. Doing it dynamically would basically mean using Cells
>> modified to have lifetimes as the smart references into the structure. It
>> would be nice to have a version of the smart references that ensured you
>> didn't externally alias something which is also externally mutable, though.
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/cfb36ee3/attachment.html>

From ben at 0x539.de  Mon Sep 30 09:35:55 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Mon, 30 Sep 2013 18:35:55 +0200
Subject: [rust-dev] How to express "T : Foo<X1> implies T : Foo<X2>" ?
In-Reply-To: <CADecdiLRSGhDdx63VOcdrHoyETaxTKZ--H8b38QPb3x17y5npA@mail.gmail.com>
References: <CADecdiLRSGhDdx63VOcdrHoyETaxTKZ--H8b38QPb3x17y5npA@mail.gmail.com>
Message-ID: <1380558955.29551.17.camel@vigil>

Hi,

I think traits with type parameters just don't work very 'as expected'
yet. Relevant to your example you can't yet do

    impl Foo<X1> for int {}
    impl Foo<X2> for int {}

because the type parameter isn't taken into account for coherence checks
and so those are conflicting implementations. I don't have a good
solution for you, but this issue has been mentioned here:
https://github.com/mozilla/rust/issues/5527#issuecomment-17809177

Also I think that `impl<T...> ... for T` isn't yet well-supported
either: https://github.com/mozilla/rust/issues/3429#issuecomment-8405280

-benh

On Mon, 2013-09-30 at 00:06 -0700, Vadim wrote:
> Hi,
> I don't understand why the following produces an error:
> 
> >cat test.rs
> 
> trait Foo<T> {}
> struct X1;
> struct X2;
> 
> impl<T: Foo<X1>> Foo<X2> for T {}
> 
> fn main() {}
> 
> >rustc test.rs
> test.rs:6:0: 6:33 error: expected Foo<X2>, but found Foo<X1> (expected
> struct X2 but found struct X1)
> test.rs:6 impl<T: Foo<X1>> Foo<X2> for T {}
>           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> error: aborting due to previous error
> 
> 
> 
> I'm trying to say "Any type that implements Foo<X1> also implements
> Foo<X2>"...   What's wrong here?
> 
> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



From oren at ben-kiki.org  Mon Sep 30 10:10:45 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 30 Sep 2013 20:10:45 +0300
Subject: [rust-dev] Trait method self parameter type clashes with
 lifetime annotation required by the implementation
In-Reply-To: <CAAvrL-=FiuFAstpvySvaRww-vJPwr7qZC+hrqdoTMHAzkXmVAQ@mail.gmail.com>
References: <CA+jWdBhhQv6uuT4NtUX-jtvbj6aD7HhPSyLvvYaNMyXC7v+csA@mail.gmail.com>
	<CABR6rW-g6i22sb9ve6q0Prb25+q_+MrgE9cjPNs8a2V7AL4K9A@mail.gmail.com>
	<CABR6rW_YwR15URn_32bdLVJi3tht-2ifEghTr5p98hr7YZHigg@mail.gmail.com>
	<CA+jWdBiOY7vK5B7xbnWuyT7-_Zwq0M-DCUtnXUo-yZ9DRmjdQw@mail.gmail.com>
	<CABR6rW9DJJZkRhoyAQdEr9RK+khjaNY8rA85m9=6OGbG0g-ncQ@mail.gmail.com>
	<CADJiDhs_znfGqm7B1tgiquHZhpGksdZnHEmRWUv2-gH=_gd-4Q@mail.gmail.com>
	<CAPNUp09V-7CEc_nXt4N-8N+_XPjxU1cCCXy_NS=LMs=Eq5f5eA@mail.gmail.com>
	<CADJiDhsn7jy9j8T1vGr7ULV43dnkuS4VsiQD2H=XYxq4Wi64bA@mail.gmail.com>
	<CAPNUp0-VSqH3EEBRAsUFtMtx7iF3ERtXs6=O_1nsE_uKGCbFnA@mail.gmail.com>
	<CADJiDhtsvyRpERSfPcsBobs_21i6xyXzf75FpVPmSBUGjHW8+A@mail.gmail.com>
	<CACVDHKnHwWamATWPSYsiRJU=UY-T=ngtzFM3KZAWX_A-4VVv9A@mail.gmail.com>
	<CANb7cF4CYtjSMrZ-K3A14vEKDgG4taiJ73mQEBHO2m-oWY5e6w@mail.gmail.com>
	<CANjmGJtU3JMnne1oz=PPD7R6BgeZbNm8HcDh9fQkRJLCuz-0Xw@mail.gmail.com>
	<CADJiDhtGdhQhw6y1+y+bb6wO6dfuWBJMqpJsm3ZfMcJR566O+A@mail.gmail.com>
	<CAPNUp0-UjZE38f1Ww1ayqGWO_w=hac-VUYmVQ6505ZWpqJcJvQ@mail.gmail.com>
	<CADJiDhv-_0B3WPcX4csJ_Xz-J2-dMa_zEKFvTKSK-9U6TBGsXQ@mail.gmail.com>
	<CANjmGJtp29FE-y2L+Qj7JOUn__J9LCV-JARBiDDk-LrgA-5EXA@mail.gmail.com>
	<CADJiDhu+SkigokLN1D49X5OragaYUwmh8_5ZyZgG+08e507KKg@mail.gmail.com>
	<CAAvrL-=FiuFAstpvySvaRww-vJPwr7qZC+hrqdoTMHAzkXmVAQ@mail.gmail.com>
Message-ID: <CADJiDhvWaZ+CT5Nmg8016cJjMYEiu9NPJ_uqF=UUzn=Y2f1oWA@mail.gmail.com>

That's good! But there remains the fact that there's no way to say "my
lifetime is the same as the struct that contains me". If 'self specialness
goes away, perhaps it can be re-introduced to mean that (or a different
name can be given to it).


On Mon, Sep 30, 2013 at 7:01 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> I've only skimmed this conversation, but note that the "specialness" of
> the 'self lifetime will be going away in the future.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/84a941b8/attachment-0001.html>

From banderson at mozilla.com  Mon Sep 30 10:44:28 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 30 Sep 2013 10:44:28 -0700
Subject: [rust-dev] IRFY lives!
In-Reply-To: <5246ED25.1030409@gmail.com>
References: <5246ED25.1030409@gmail.com>
Message-ID: <5249B87C.9030809@mozilla.com>

On 09/28/2013 07:52 AM, Huon Wilson wrote:
> Hi all,
>
> The memory benchmarks on IsRustFastYet 
> (http://huonw.github.io/isrustfastyet/mem/) have been on a bit of a 
> hiatus, but they're back thanks to cmr's hard-working hardware (as 
> well as a little Rust program that we collaborated on to allow him to 
> build 600+ of bors' merges automagically: 
> https://github.com/huonw/multibuilder)

Thanks, Huon. This is a great service.

From banderson at mozilla.com  Mon Sep 30 10:47:42 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 30 Sep 2013 10:47:42 -0700
Subject: [rust-dev] Rust-dev Digest, Vol 39, Issue 86
In-Reply-To: <356fa6a1.13e13.14165651040.Coremail.googletoday009@163.com>
References: <mailman.27.1380308402.19261.rust-dev@mozilla.org>
	<356fa6a1.13e13.14165651040.Coremail.googletoday009@163.com>
Message-ID: <5249B93E.7060800@mozilla.com>

On 09/28/2013 09:27 AM, lambda wrote:
> On my Windows XP,I got this error,which i compile the code:
> warning: got 1 RUST_LOG specs but only matched 0 of them.
> You may have mistyped a RUST_LOG spec.
> Use RUST_LOG=::help to see the list of crates and modules.
>
> task &lt;unnamed&gt; failed at 'failure in CreateProcess: The system cannot find the file specified.
> ', C:\bot\slave\dist2-win\build\src\libstd\run.rs:532
> error: internal compiler error: unexpected failure
> note: the compiler hit an unexpected failure path. this is a bug
> note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
> task &lt;unnamed&gt; failed at 'explicit failure', c:\bot\slave\dist2-win\build\src\librustc\rustc.rs:391

I would guess that this is due to not being able to find gcc, which Rust 
uses for linking.

Using Rust on Windows is not easy. There are a lot of instructions here 
though: 
https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#windows

From niko at alum.mit.edu  Mon Sep 30 10:48:06 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 30 Sep 2013 13:48:06 -0400
Subject: [rust-dev] How to express "T : Foo<X1> implies T : Foo<X2>" ?
In-Reply-To: <CADecdiLRSGhDdx63VOcdrHoyETaxTKZ--H8b38QPb3x17y5npA@mail.gmail.com>
References: <CADecdiLRSGhDdx63VOcdrHoyETaxTKZ--H8b38QPb3x17y5npA@mail.gmail.com>
Message-ID: <20130930174806.GA3892@Mr-Bennet>

I believe this is due to invalid assumptions in the compiler's trait
implementation (related to issue #7590). In particular some code
assumes that a trait will only be implemented for a single set of type
parameters, and it may be that this code is causing incorrect type
unifications. In general the vtable matching code is due to be
restructured and rewritten.


Niko

On Mon, Sep 30, 2013 at 12:06:51AM -0700, Vadim wrote:
> Hi,
> I don't understand why the following produces an error:
> 
> >cat test.rs
> 
> trait Foo<T> {}
> struct X1;
> struct X2;
> 
> impl<T: Foo<X1>> Foo<X2> for T {}
> 
> fn main() {}
> 
> >rustc test.rs
> test.rs:6:0: 6:33 error: expected Foo<X2>, but found Foo<X1> (expected
> struct X2 but found struct X1)
> test.rs:6 impl<T: Foo<X1>> Foo<X2> for T {}
>           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> error: aborting due to previous error
> 
> 
> I'm trying to say "Any type that implements Foo<X1> also implements
> Foo<X2>"...   What's wrong here?

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From aaron.dandy at live.com  Mon Sep 30 10:53:51 2013
From: aaron.dandy at live.com (Aaron Dandy)
Date: Mon, 30 Sep 2013 11:53:51 -0600
Subject: [rust-dev] Rust-dev Digest, Vol 39, Issue 86
In-Reply-To: <5249B93E.7060800@mozilla.com>
References: <mailman.27.1380308402.19261.rust-dev@mozilla.org>,
	<356fa6a1.13e13.14165651040.Coremail.googletoday009@163.com>,
	<5249B93E.7060800@mozilla.com>
Message-ID: <BAY177-W37C9A229C3A80FB457BF6F88140@phx.gbl>

This note also has been evolving with the 0.8 release and still is what I use for 0.9-pre builds on Windows:
https://github.com/mozilla/rust/wiki/Note-Building-Rust-Before-0.8-on-Windows-Systems

> Date: Mon, 30 Sep 2013 10:47:42 -0700
> From: banderson at mozilla.com
> To: rust-dev at mozilla.org
> Subject: Re: [rust-dev] Rust-dev Digest, Vol 39, Issue 86
> 
> On 09/28/2013 09:27 AM, lambda wrote:
> > On my Windows XP,I got this error,which i compile the code:
> > warning: got 1 RUST_LOG specs but only matched 0 of them.
> > You may have mistyped a RUST_LOG spec.
> > Use RUST_LOG=::help to see the list of crates and modules.
> >
> > task &lt;unnamed&gt; failed at 'failure in CreateProcess: The system cannot find the file specified.
> > ', C:\bot\slave\dist2-win\build\src\libstd\run.rs:532
> > error: internal compiler error: unexpected failure
> > note: the compiler hit an unexpected failure path. this is a bug
> > note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
> > task &lt;unnamed&gt; failed at 'explicit failure', c:\bot\slave\dist2-win\build\src\librustc\rustc.rs:391
> 
> I would guess that this is due to not being able to find gcc, which Rust 
> uses for linking.
> 
> Using Rust on Windows is not easy. There are a lot of instructions here 
> though: 
> https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#windows
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/33907b33/attachment.html>

From j.e.aten at gmail.com  Mon Sep 30 11:00:10 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 11:00:10 -0700
Subject: [rust-dev] autotrace
Message-ID: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>

I was very frustrated by the lack of debug-info at the gdb prompt during
rust coding recently. I note too that people on #rust complain about the
lack of visibility into debugging rustc itself.

I think there is a lightweight, quick to implement, solution to these
problems.

I have in mind a simple facility provided by a compiler flag that injects
(logging-controlled) printf or tracing-log statement at the top and bottom
of every function. Something like:

// example:
fn fun1(a:int, b:str, c:HashMap<~str, int>) -> HashMap<~str,int> {
   c.insert(a,b)
}

// would effectively become, with rustc --autotrace enabled:

fn fun1(a:int, b:str, c:HashMap<~str, int>) {
   // intro
   if (global_tracking_flag) {
      stack_depth = stack_depth + 1;
      trace!("%s call fun1(%?, %?, %?)",
indent_spaces_according_to_stack_depth(), a, b, c);
   }

   c.insert(a,b);

   // outro : would have to be like a destructor, that is called on every
return path...
   if (global_tracking_flag) {
      trace!("%s return from fun1 -> %?",
indent_spaces_according_to_stack_depth(), c);
      stack_depth = stack_depth - 1;
   }
}


Although not without cost, the --autotrace facility could even be highly
useful for runtime monitoring (and therefore better/faster/cheaper than
comprehensive debug-info). The idea being that it would be cheap enough
(surely global_tracking_flag could be persuaded to live in a register, no?)
that it could be left compiled into most non-inlined function, and
activated at runtime without bringing a production system down.

Related experience.... Justin Sheehy at Basho talks about how Erlang's
runtime monitoring facilities were under-appreciated when they started.

"Many other features that we didn?t understand the full importance of at
the time (such as the ability to inspect and modify a live system at
run-time with almost no planning or cost) have also helped us greatly in
making systems that our users and customers trust with their most critical
data."  http://basho.com/erlang-at-basho-five-years-later/

Thoughts? Is --autotrace a viable idea at all?

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/bfe1deee/attachment.html>

From nejucomo at gmail.com  Mon Sep 30 11:57:48 2013
From: nejucomo at gmail.com (Callme Whatiwant)
Date: Mon, 30 Sep 2013 11:57:48 -0700
Subject: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup
 and/or hackathon?
In-Reply-To: <CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>
References: <CALdfqQJmU4c=TgFM5AcC9XZsmDWmGvySGdd-140PfmsVbpA=Cg@mail.gmail.com>
	<519FDA2A.70007@mozilla.com>
	<CALdfqQ+2dqBGSN_xFHdDHkwVUrG4Q+zhJQQzyLW6RDOYz9W5mA@mail.gmail.com>
	<519FEE4A.8040104@mozilla.com>
	<CABq6+aci1Vx0XxvVggfSE2beAcC4F_weLzJK0GRyhpgwM=Sp3A@mail.gmail.com>
	<CALdfqQJtGtYzVir2Y52XNKa7Sxv904pUsA7SW312NDvRyZ9d+w@mail.gmail.com>
	<CALdfqQK0SMyau1X0ZRErcy-5jB3D3gfOKZXnQUNDe41Z2ZiJXA@mail.gmail.com>
	<CALdfqQKRHFdRNyx_XNtMizX0Big8cqwekbKz_yWKWMW8Mp-nDQ@mail.gmail.com>
	<CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>
Message-ID: <CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>

Hi,

I'm late to the party.  Are there (semi-) regular meetings in the Bay
Area?  Does it make sense to have a wiki for meetings in different
areas?  Is there a public wiki for rust?



On Wed, Jun 12, 2013 at 10:23 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com> wrote:
> Thanks everyone who could make it! It was great meeting you all.
>
> I'm planning on the next SF Bay Area meetup some time in July. Would anyone
> want to give a presentation? If so, let me know your availability and how
> much time you will need to put one together.
>
>
> On Monday, June 10, 2013, Erick Tryzelaar wrote:
>>
>> Is there anyone else coming to the meetup this Wednesday that hasn't told
>> me they are coming? I've got 15 people confirmed right now, which fits
>> nicely into my reservation for 20, but if there's a lot more that is
>> planning on coming I'll need to up my reservation.
>>
>>
>> On Wed, Jun 5, 2013 at 5:37 PM, Erick Tryzelaar
>> <erick.tryzelaar at gmail.com> wrote:
>>>
>>> Hey folks!
>>>
>>> I've made a reservation for 20 people at Tied House in Mountain View next
>>> Wednesday, June 12th, at 7pm:
>>>
>>> Tied House
>>> 954 Villa St, Mountain View, CA 94041
>>> http://tiedhouse.com/
>>> map: http://goo.gl/maps/p9dK0.
>>>
>>> It's right near Caltrain, so it should hopefully be pretty easy for
>>> people to commute to the restaurant. Please let me know if you are coming so
>>> I can grow/shrink the reservation.
>>>
>>> Finally, please bring some cash because we'll all be sharing one check,
>>> and it'll be easier to split the bill.
>>>
>>> Looking forward to meeting you all!
>>> -Erick
>>>
>>>
>>>
>>> On Mon, Jun 3, 2013 at 1:23 PM, Erick Tryzelaar
>>> <erick.tryzelaar at gmail.com> wrote:
>>>>
>>>> Hey all! I think we have critical mass for a presentation or two. Would
>>>> anyone be interested in giving a presentation? If so, how much time would
>>>> you need to put one together?
>>>>
>>>>
>>>> On Mon, May 27, 2013 at 4:27 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>>>>
>>>>> Count me in.  :)
>>>>>
>>>>>
>>>>> Kevin
>>>>>
>>>>>
>>>>> --
>>>>> Kevin Cantu
>>>>>
>>>>>
>>>>> On Fri, May 24, 2013 at 3:48 PM, Brian Anderson <banderson at mozilla.com>
>>>>> wrote:
>>>>>>
>>>>>> On 05/24/2013 03:31 PM, Erick Tryzelaar wrote:
>>>>>>>
>>>>>>> Glad to help.
>>>>>>>
>>>>>>> So far I've heard from 10 others so far, which I think is pretty good
>>>>>>> for our first one in the bay area. When do the interns start? This could be
>>>>>>> a good way to introduce them into the community / convince them work on my
>>>>>>> feature requests :)
>>>>>>>
>>>>>>
>>>>>> All the rust interns will be here by 6/10.
>>>>>>
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From banderson at mozilla.com  Mon Sep 30 12:01:33 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 30 Sep 2013 12:01:33 -0700
Subject: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup
 and/or hackathon?
In-Reply-To: <CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>
References: <CALdfqQJmU4c=TgFM5AcC9XZsmDWmGvySGdd-140PfmsVbpA=Cg@mail.gmail.com>
	<519FDA2A.70007@mozilla.com>
	<CALdfqQ+2dqBGSN_xFHdDHkwVUrG4Q+zhJQQzyLW6RDOYz9W5mA@mail.gmail.com>
	<519FEE4A.8040104@mozilla.com>
	<CABq6+aci1Vx0XxvVggfSE2beAcC4F_weLzJK0GRyhpgwM=Sp3A@mail.gmail.com>
	<CALdfqQJtGtYzVir2Y52XNKa7Sxv904pUsA7SW312NDvRyZ9d+w@mail.gmail.com>
	<CALdfqQK0SMyau1X0ZRErcy-5jB3D3gfOKZXnQUNDe41Z2ZiJXA@mail.gmail.com>
	<CALdfqQKRHFdRNyx_XNtMizX0Big8cqwekbKz_yWKWMW8Mp-nDQ@mail.gmail.com>
	<CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>
	<CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>
Message-ID: <5249CA8D.8030904@mozilla.com>

On 09/30/2013 11:57 AM, Callme Whatiwant wrote:
> Hi,
>
> I'm late to the party.  Are there (semi-) regular meetings in the Bay
> Area?  Does it make sense to have a wiki for meetings in different
> areas?  Is there a public wiki for rust?
>

There are not regular meetings, though I think it would be a good idea 
to start them soon. If somebody wants to put this type of information on 
the wiki on github that's fine.

From me at kevincantu.org  Mon Sep 30 12:04:19 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Mon, 30 Sep 2013 12:04:19 -0700
Subject: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup
 and/or hackathon?
In-Reply-To: <5249CA8D.8030904@mozilla.com>
References: <CALdfqQJmU4c=TgFM5AcC9XZsmDWmGvySGdd-140PfmsVbpA=Cg@mail.gmail.com>
	<519FDA2A.70007@mozilla.com>
	<CALdfqQ+2dqBGSN_xFHdDHkwVUrG4Q+zhJQQzyLW6RDOYz9W5mA@mail.gmail.com>
	<519FEE4A.8040104@mozilla.com>
	<CABq6+aci1Vx0XxvVggfSE2beAcC4F_weLzJK0GRyhpgwM=Sp3A@mail.gmail.com>
	<CALdfqQJtGtYzVir2Y52XNKa7Sxv904pUsA7SW312NDvRyZ9d+w@mail.gmail.com>
	<CALdfqQK0SMyau1X0ZRErcy-5jB3D3gfOKZXnQUNDe41Z2ZiJXA@mail.gmail.com>
	<CALdfqQKRHFdRNyx_XNtMizX0Big8cqwekbKz_yWKWMW8Mp-nDQ@mail.gmail.com>
	<CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>
	<CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>
	<5249CA8D.8030904@mozilla.com>
Message-ID: <CABq6+af1_3H-a0vfdB-t9kCfcJZEFi0DSCcSAUwATOKbZJiBnw@mail.gmail.com>

Hmm, yes, it has been a while.  Let's get together again soon!


Kevin


On Mon, Sep 30, 2013 at 12:01 PM, Brian Anderson <banderson at mozilla.com> wrote:
> On 09/30/2013 11:57 AM, Callme Whatiwant wrote:
>>
>> Hi,
>>
>> I'm late to the party.  Are there (semi-) regular meetings in the Bay
>> Area?  Does it make sense to have a wiki for meetings in different
>> areas?  Is there a public wiki for rust?
>>
>
> There are not regular meetings, though I think it would be a good idea to
> start them soon. If somebody wants to put this type of information on the
> wiki on github that's fine.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From josh at joshmatthews.net  Mon Sep 30 12:05:00 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Mon, 30 Sep 2013 15:05:00 -0400
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
Message-ID: <CAOvJiVUDb0tebsAXryU+GOFG-i12ksrZAy0_BS+YM8EXovB_Qw@mail.gmail.com>

Please note that Michael Woerister's work this summer on debug symbols has
been wildly successful, and it's worth giving it another shot before
looking into further compiler hacking:
http://michaelwoerister.github.io/2013/09/27/what-you-call-the-present.html

Cheers,
Josh


On 30 September 2013 14:00, Jason E. Aten <j.e.aten at gmail.com> wrote:

> I was very frustrated by the lack of debug-info at the gdb prompt during
> rust coding recently. I note too that people on #rust complain about the
> lack of visibility into debugging rustc itself.
>
> I think there is a lightweight, quick to implement, solution to these
> problems.
>
> I have in mind a simple facility provided by a compiler flag that injects
> (logging-controlled) printf or tracing-log statement at the top and bottom
> of every function. Something like:
>
> // example:
> fn fun1(a:int, b:str, c:HashMap<~str, int>) -> HashMap<~str,int> {
>    c.insert(a,b)
> }
>
> // would effectively become, with rustc --autotrace enabled:
>
> fn fun1(a:int, b:str, c:HashMap<~str, int>) {
>    // intro
>    if (global_tracking_flag) {
>       stack_depth = stack_depth + 1;
>       trace!("%s call fun1(%?, %?, %?)",
> indent_spaces_according_to_stack_depth(), a, b, c);
>    }
>
>    c.insert(a,b);
>
>    // outro : would have to be like a destructor, that is called on every
> return path...
>    if (global_tracking_flag) {
>       trace!("%s return from fun1 -> %?",
> indent_spaces_according_to_stack_depth(), c);
>       stack_depth = stack_depth - 1;
>    }
> }
>
>
> Although not without cost, the --autotrace facility could even be highly
> useful for runtime monitoring (and therefore better/faster/cheaper than
> comprehensive debug-info). The idea being that it would be cheap enough
> (surely global_tracking_flag could be persuaded to live in a register, no?)
> that it could be left compiled into most non-inlined function, and
> activated at runtime without bringing a production system down.
>
> Related experience.... Justin Sheehy at Basho talks about how Erlang's
> runtime monitoring facilities were under-appreciated when they started.
>
> "Many other features that we didn?t understand the full importance of at
> the time (such as the ability to inspect and modify a live system at
> run-time with almost no planning or cost) have also helped us greatly in
> making systems that our users and customers trust with their most critical
> data."  http://basho.com/erlang-at-basho-five-years-later/
>
> Thoughts? Is --autotrace a viable idea at all?
>
> Jason
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/886b5426/attachment.html>

From aaron.dandy at live.com  Mon Sep 30 12:06:47 2013
From: aaron.dandy at live.com (Aaron Dandy)
Date: Mon, 30 Sep 2013 13:06:47 -0600
Subject: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup
 and/or hackathon?
In-Reply-To: <5249CA8D.8030904@mozilla.com>
References: <CALdfqQJmU4c=TgFM5AcC9XZsmDWmGvySGdd-140PfmsVbpA=Cg@mail.gmail.com>,
	<519FDA2A.70007@mozilla.com>,
	<CALdfqQ+2dqBGSN_xFHdDHkwVUrG4Q+zhJQQzyLW6RDOYz9W5mA@mail.gmail.com>,
	<519FEE4A.8040104@mozilla.com>,
	<CABq6+aci1Vx0XxvVggfSE2beAcC4F_weLzJK0GRyhpgwM=Sp3A@mail.gmail.com>,
	<CALdfqQJtGtYzVir2Y52XNKa7Sxv904pUsA7SW312NDvRyZ9d+w@mail.gmail.com>,
	<CALdfqQK0SMyau1X0ZRErcy-5jB3D3gfOKZXnQUNDe41Z2ZiJXA@mail.gmail.com>,
	<CALdfqQKRHFdRNyx_XNtMizX0Big8cqwekbKz_yWKWMW8Mp-nDQ@mail.gmail.com>,
	<CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>,
	<CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>,
	<5249CA8D.8030904@mozilla.com>
Message-ID: <BAY177-W5073B95131CAD0BDBEE2DF88140@phx.gbl>

> Date: Mon, 30 Sep 2013 12:01:33 -0700
> From: banderson at mozilla.com
> To: rust-dev at mozilla.org
> Subject: Re: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup and/or hackathon?
> 
> On 09/30/2013 11:57 AM, Callme Whatiwant wrote:
> > Hi,
> >
> > I'm late to the party.  Are there (semi-) regular meetings in the Bay
> > Area?  Does it make sense to have a wiki for meetings in different
> > areas?  Is there a public wiki for rust?
> >
> 
> There are not regular meetings, though I think it would be a good idea 
> to start them soon. If somebody wants to put this type of information on 
> the wiki on github that's fine.

It would be pretty cool to have a general meetup page on the wiki as well for other meetups to list themselves as they form. 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/1f0eef50/attachment.html>

From j.e.aten at gmail.com  Mon Sep 30 12:18:24 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 12:18:24 -0700
Subject: [rust-dev] autotrace
In-Reply-To: <CAOvJiVUDb0tebsAXryU+GOFG-i12ksrZAy0_BS+YM8EXovB_Qw@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<CAOvJiVUDb0tebsAXryU+GOFG-i12ksrZAy0_BS+YM8EXovB_Qw@mail.gmail.com>
Message-ID: <CAPNEFAZK-dFPKchQUZSUpAp5oTnoQ4O1qb8dkpL8Xpxex1jNtQ@mail.gmail.com>

Hi Josh,

Could you be more specific about what you would like me to try?  When I
iniquire on #rust I'm told that debug-info is still in bad shape.

Specifically: I do rustc -Z debug-info -Z extra-debug-info -Z no-opt, and I
consistently get no local variables showing up in gdb on any stack frame.
The frame pointer jumps to random places in the source code when stepping.

And moreover,  --autotrace would so much more useful in that it would also
allow monitoring of an in-production system without stopping it or
re-deploying as a debug-build.

Jason

On Mon, Sep 30, 2013 at 12:05 PM, Josh Matthews <josh at joshmatthews.net>wrote:

> Please note that Michael Woerister's work this summer on debug symbols has
> been wildly successful, and it's worth giving it another shot before
> looking into further compiler hacking:
> http://michaelwoerister.github.io/2013/09/27/what-you-call-the-present.html
>
> Cheers,
> Josh
>
>
> On 30 September 2013 14:00, Jason E. Aten <j.e.aten at gmail.com> wrote:
>
>> I was very frustrated by the lack of debug-info at the gdb prompt during
>> rust coding recently. I note too that people on #rust complain about the
>> lack of visibility into debugging rustc itself.
>>
>> I think there is a lightweight, quick to implement, solution to these
>> problems.
>>
>> I have in mind a simple facility provided by a compiler flag that injects
>> (logging-controlled) printf or tracing-log statement at the top and bottom
>> of every function. Something like:
>>
>> // example:
>> fn fun1(a:int, b:str, c:HashMap<~str, int>) -> HashMap<~str,int> {
>>    c.insert(a,b)
>> }
>>
>> // would effectively become, with rustc --autotrace enabled:
>>
>> fn fun1(a:int, b:str, c:HashMap<~str, int>) {
>>    // intro
>>    if (global_tracking_flag) {
>>       stack_depth = stack_depth + 1;
>>       trace!("%s call fun1(%?, %?, %?)",
>> indent_spaces_according_to_stack_depth(), a, b, c);
>>    }
>>
>>    c.insert(a,b);
>>
>>    // outro : would have to be like a destructor, that is called on every
>> return path...
>>    if (global_tracking_flag) {
>>       trace!("%s return from fun1 -> %?",
>> indent_spaces_according_to_stack_depth(), c);
>>       stack_depth = stack_depth - 1;
>>    }
>> }
>>
>>
>> Although not without cost, the --autotrace facility could even be highly
>> useful for runtime monitoring (and therefore better/faster/cheaper than
>> comprehensive debug-info). The idea being that it would be cheap enough
>> (surely global_tracking_flag could be persuaded to live in a register, no?)
>> that it could be left compiled into most non-inlined function, and
>> activated at runtime without bringing a production system down.
>>
>> Related experience.... Justin Sheehy at Basho talks about how Erlang's
>> runtime monitoring facilities were under-appreciated when they started.
>>
>> "Many other features that we didn?t understand the full importance of at
>> the time (such as the ability to inspect and modify a live system at
>> run-time with almost no planning or cost) have also helped us greatly in
>> making systems that our users and customers trust with their most critical
>> data."  http://basho.com/erlang-at-basho-five-years-later/
>>
>> Thoughts? Is --autotrace a viable idea at all?
>>
>> Jason
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/c5e3d2d7/attachment-0001.html>

From niko at alum.mit.edu  Mon Sep 30 12:59:07 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 30 Sep 2013 15:59:07 -0400
Subject: [rust-dev] Some suggestions of Rust language
In-Reply-To: <5243014D.6030709@mozilla.com>
References: <CAJYHJk8e-TvGaL8MKYnLNWt5QJio0x-h5+bRjkyJvQ8aOnVv8g@mail.gmail.com>
	<5243014D.6030709@mozilla.com>
Message-ID: <20130930195907.GB22328@Mr-Bennet>

On Wed, Sep 25, 2013 at 08:29:17AM -0700, Patrick Walton wrote:
> If we did this, we wouldn't know whether to parse a pattern or an
> expression when starting a statement. This isn't fixable without
> trying to define some sort of cover grammar that covers both
> expressions and patterns, like ECMAScript 6 does. I don't know if
> this would work in Rust.

I've been wondering about this. To accommodate a use case like

    (a, b) = ...

we don't actually need to have a grammar that covers *all* expressions
and patterns, but rather just a grammar for *lvalues and irrefutable
patterns*. I feel like this is do-able, but I confess I haven't
thought too hard about it.

Anyway, seems like a nice-to-have, but not a high priority.


Niko

From erick.tryzelaar at gmail.com  Mon Sep 30 13:03:45 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 30 Sep 2013 13:03:45 -0700
Subject: [rust-dev] Announce: rust-pcre
In-Reply-To: <CAH+UCjPoaNCHTYkaPbgTrGbAk8j7gHGnL_23ffLLck5vVV4hFQ@mail.gmail.com>
References: <CAH+UCjPoaNCHTYkaPbgTrGbAk8j7gHGnL_23ffLLck5vVV4hFQ@mail.gmail.com>
Message-ID: <CALdfqQ+=wiR9zF9xWsDgw1r9+RFzKbwijnNCuFX-BxYvWR-pFg@mail.gmail.com>

Hey Cadence!

Nice work. I also have a pcre binding, although I haven't updated it for a
while: https://github.com/erickt/rustpcre. We should merge :)


On Sun, Sep 29, 2013 at 1:54 PM, Cadence Marseille <
cadencemarseille at gmail.com> wrote:

> Hello,
>
> I spent some time putting together a simple wrapper for libpcre<http://pcre.org/>,
> available at:
> https://github.com/cadencemarseille/rust-pcre
>
> As I am just learning Rust, any comments/thoughts about the wrapper's API,
> coding style, etc., are welcome.
>
> --
> Cadence
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/540a3b90/attachment.html>

From kmcallister at mozilla.com  Mon Sep 30 13:06:14 2013
From: kmcallister at mozilla.com (Keegan McAllister)
Date: Mon, 30 Sep 2013 13:06:14 -0700 (PDT)
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
Message-ID: <2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>

> surely global_tracking_flag could be persuaded to live in a register, no?

Reserving a register will slow down the whole program.  I'd expect a serious hit on 32-bit x86, and modest but measurable slowdown elsewhere.  It might be worth doing a quick experiment, if there's a way to convince LLVM to just set aside a register.

The Linux kernel uses self-modifying code for this sort of thing.  Functions are compiled with logging / tracing code, which is then NOP'd out until it's needed.  This is tricky to get right, especially in a concurrent setting, but it might be worth considering if we want Rust to have really good production-compatible monitoring (which I agree is a worthwhile goal).

keegan

From j.e.aten at gmail.com  Mon Sep 30 13:13:22 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 13:13:22 -0700
Subject: [rust-dev] autotrace
In-Reply-To: <2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>
Message-ID: <CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>

Interesting idea, the self-modifying code.  Is that codable in rust
currently?


On Mon, Sep 30, 2013 at 1:06 PM, Keegan McAllister
<kmcallister at mozilla.com>wrote:

> > surely global_tracking_flag could be persuaded to live in a register, no?
>
> Reserving a register will slow down the whole program.  I'd expect a
> serious hit on 32-bit x86, and modest but measurable slowdown elsewhere.
>  It might be worth doing a quick experiment, if there's a way to convince
> LLVM to just set aside a register.
>
> The Linux kernel uses self-modifying code for this sort of thing.
>  Functions are compiled with logging / tracing code, which is then NOP'd
> out until it's needed.  This is tricky to get right, especially in a
> concurrent setting, but it might be worth considering if we want Rust to
> have really good production-compatible monitoring (which I agree is a
> worthwhile goal).
>
> keegan
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/c288fcad/attachment.html>

From micah at micahchalmer.net  Mon Sep 30 13:16:31 2013
From: micah at micahchalmer.net (Micah Chalmer)
Date: Mon, 30 Sep 2013 16:16:31 -0400
Subject: [rust-dev] Announce: rust-fuse
Message-ID: <746AC807-ED3B-42DE-AB91-636DDE1B8D40@micahchalmer.net>

Hi rust folks,

I've been tinkering with a rust binding for creating filesystems in userspace (FUSE) for a while now.  It's not at all done, but has now reached the point where I think it's worth showing around for feedback if anyone's interested.  Even if you're not interested in FUSE itself, the project shows some issues/workarounds that may be interesting to those who wrap other C APIs.  They're listed under "problems" in the README (the ones I know of--I'm sure there are additional problems as well.)

https://github.com/MicahChalmer/rust-fuse

I'd love to hear what anyone thinks.

-Micah


From erick.tryzelaar at gmail.com  Mon Sep 30 13:18:48 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 30 Sep 2013 13:18:48 -0700
Subject: [rust-dev] Any interest in a San Francisco Bay Area Rust meetup
 and/or hackathon?
In-Reply-To: <BAY177-W5073B95131CAD0BDBEE2DF88140@phx.gbl>
References: <CALdfqQJmU4c=TgFM5AcC9XZsmDWmGvySGdd-140PfmsVbpA=Cg@mail.gmail.com>
	<519FDA2A.70007@mozilla.com>
	<CALdfqQ+2dqBGSN_xFHdDHkwVUrG4Q+zhJQQzyLW6RDOYz9W5mA@mail.gmail.com>
	<519FEE4A.8040104@mozilla.com>
	<CABq6+aci1Vx0XxvVggfSE2beAcC4F_weLzJK0GRyhpgwM=Sp3A@mail.gmail.com>
	<CALdfqQJtGtYzVir2Y52XNKa7Sxv904pUsA7SW312NDvRyZ9d+w@mail.gmail.com>
	<CALdfqQK0SMyau1X0ZRErcy-5jB3D3gfOKZXnQUNDe41Z2ZiJXA@mail.gmail.com>
	<CALdfqQKRHFdRNyx_XNtMizX0Big8cqwekbKz_yWKWMW8Mp-nDQ@mail.gmail.com>
	<CALdfqQKawNmJ3ug9pJHf_c797Q4GT9Fo0UzOzGkgLLccTRXC0Q@mail.gmail.com>
	<CA+4_Dk7a62Obfk_Vp6JZLHkK7fUVd6K9aX5ZUb+1+CK6bFGW_Q@mail.gmail.com>
	<5249CA8D.8030904@mozilla.com>
	<BAY177-W5073B95131CAD0BDBEE2DF88140@phx.gbl>
Message-ID: <CALdfqQL7hNmeA-MG3DkZVyP_Hb35vy2uy5nmxuNJzwR+dvYB8Q@mail.gmail.com>

I've been putting off registering a Bay Area Rust meetup group for far too
long. I'll do that now :)


On Mon, Sep 30, 2013 at 12:06 PM, Aaron Dandy <aaron.dandy at live.com> wrote:

> > Date: Mon, 30 Sep 2013 12:01:33 -0700
> > From: banderson at mozilla.com
> > To: rust-dev at mozilla.org
> > Subject: Re: [rust-dev] Any interest in a San Francisco Bay Area Rust
> meetup and/or hackathon?
>
> >
> > On 09/30/2013 11:57 AM, Callme Whatiwant wrote:
> > > Hi,
> > >
> > > I'm late to the party. Are there (semi-) regular meetings in the Bay
> > > Area? Does it make sense to have a wiki for meetings in different
> > > areas? Is there a public wiki for rust?
> > >
> >
> > There are not regular meetings, though I think it would be a good idea
> > to start them soon. If somebody wants to put this type of information on
> > the wiki on github that's fine.
>
> It would be pretty cool to have a general meetup page on the wiki as well
> for other meetups to list themselves as they form.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/6f348342/attachment.html>

From davidb at davidb.org  Mon Sep 30 13:30:51 2013
From: davidb at davidb.org (David Brown)
Date: Mon, 30 Sep 2013 13:30:51 -0700
Subject: [rust-dev] "Computed" maps
In-Reply-To: <CAK-XjKWeJXw=amSMMyRrvJS9SB7_=nc6ra-eLz06JdtbeLL16g@mail.gmail.com>
References: <20130926023647.GA14641@davidb.org>
	<CA+DvKQ+U61w_DZG8929GedxnFeQTFdO2gPHky9K8nyCY+voNyw@mail.gmail.com>
	<CAK-XjKWeJXw=amSMMyRrvJS9SB7_=nc6ra-eLz06JdtbeLL16g@mail.gmail.com>
Message-ID: <20130930203050.GA22884@davidb.org>

On Thu, Sep 26, 2013 at 12:58:48PM -0700, Brandon Sanderson wrote:

>If the values are cached, and the structure implementing the cache has
>the same lifetime (or longer? Unsure on that...) as the map then I'd
>expect it to work.? For generated/retrieved, non-cached values I don't
>believe it would work.

I'm still not sure this would quite be right.  How long would we keep
things in the cache, since the compiler only knows the lifetime is the
same as the structure holding it, that would suggest nothing could be
removed from the cache.

For now, I'm just going to return similar operations that return
cloneable values rather than references.  My use cases are small types
(such as uint), so this doesn't really hurt anything.

Thanks,
David

>On 2013-09-25 7:54 PM, "Daniel Micay" <[1]danielmicay at gmail.com>
>wrote:
>
>  On Wed, Sep 25, 2013 at 10:36 PM, David Brown <[2]davidb at davidb.org>
>  wrote:
>
>    Let's say I'm implementing some type of map-like structure that
>    I'd
>    like to be able to implement the Map trait on.
>
>    However, my map doesn't actually store the 'V' directly, but they
>    are
>    computed/retrieve/cached in some manner.
>
>    Is this possible with the existing map trait? ?Given that:
>
>    ?fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
>
>    doesn't the V need to be a pointer to something with the same
>    lifetime
>    as self?
>
>    Is there a way of dealing with this, or should I just implement my
>    own
>    similar find function, not implementing Map, and return an
>    Option<V>
>    instead?
>
>  The Map trait represents a map storing the values, so it can't be
>  used for that use case.
>  _______________________________________________
>  Rust-dev mailing list
>  [3]Rust-dev at mozilla.org
>  [4]https://mail.mozilla.org/listinfo/rust-dev
>
>References
>
>   Visible links
>   1. mailto:danielmicay at gmail.com
>   2. mailto:davidb at davidb.org
>   3. mailto:Rust-dev at mozilla.org
>   4. https://mail.mozilla.org/listinfo/rust-dev

>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev


From j.e.aten at gmail.com  Mon Sep 30 13:35:20 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 13:35:20 -0700
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>
	<CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>
Message-ID: <CAPNEFAZC46ensvy-A_JhoA2LJygVenhdMeJQ5LPepRLJ7_AEAQ@mail.gmail.com>

I'm wondering if much of this couldn't be prototyped with macros.  Is there
a way for a macro to refer to the return value of a function?


On Mon, Sep 30, 2013 at 1:13 PM, Jason E. Aten <j.e.aten at gmail.com> wrote:

> Interesting idea, the self-modifying code.  Is that codable in rust
> currently?
>
>
> On Mon, Sep 30, 2013 at 1:06 PM, Keegan McAllister <
> kmcallister at mozilla.com> wrote:
>
>> > surely global_tracking_flag could be persuaded to live in a register,
>> no?
>>
>> Reserving a register will slow down the whole program.  I'd expect a
>> serious hit on 32-bit x86, and modest but measurable slowdown elsewhere.
>>  It might be worth doing a quick experiment, if there's a way to convince
>> LLVM to just set aside a register.
>>
>> The Linux kernel uses self-modifying code for this sort of thing.
>>  Functions are compiled with logging / tracing code, which is then NOP'd
>> out until it's needed.  This is tricky to get right, especially in a
>> concurrent setting, but it might be worth considering if we want Rust to
>> have really good production-compatible monitoring (which I agree is a
>> worthwhile goal).
>>
>> keegan
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/ed08d158/attachment.html>

From alex at crichton.co  Mon Sep 30 13:44:01 2013
From: alex at crichton.co (Alex Crichton)
Date: Mon, 30 Sep 2013 13:44:01 -0700
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAZC46ensvy-A_JhoA2LJygVenhdMeJQ5LPepRLJ7_AEAQ@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>
	<CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>
	<CAPNEFAZC46ensvy-A_JhoA2LJygVenhdMeJQ5LPepRLJ7_AEAQ@mail.gmail.com>
Message-ID: <CAFnh-mdsJZQ4EWyxLEDnrNNd0k68ww7E8-4ajWPh5P+BnbW0-g@mail.gmail.com>

Currently you can't do that with macros, but in theory you could crate
a wrapper macro to declare all your functions which works similarly to
the externfn! macro. It could debug entry/exit and otherwise just be a
wrapper around an internally declared function.

On Mon, Sep 30, 2013 at 1:35 PM, Jason E. Aten <j.e.aten at gmail.com> wrote:
>
> I'm wondering if much of this couldn't be prototyped with macros.  Is there
> a way for a macro to refer to the return value of a function?
>
>
> On Mon, Sep 30, 2013 at 1:13 PM, Jason E. Aten <j.e.aten at gmail.com> wrote:
>>
>> Interesting idea, the self-modifying code.  Is that codable in rust
>> currently?
>>
>>
>> On Mon, Sep 30, 2013 at 1:06 PM, Keegan McAllister
>> <kmcallister at mozilla.com> wrote:
>>>
>>> > surely global_tracking_flag could be persuaded to live in a register,
>>> > no?
>>>
>>> Reserving a register will slow down the whole program.  I'd expect a
>>> serious hit on 32-bit x86, and modest but measurable slowdown elsewhere.  It
>>> might be worth doing a quick experiment, if there's a way to convince LLVM
>>> to just set aside a register.
>>>
>>> The Linux kernel uses self-modifying code for this sort of thing.
>>> Functions are compiled with logging / tracing code, which is then NOP'd out
>>> until it's needed.  This is tricky to get right, especially in a concurrent
>>> setting, but it might be worth considering if we want Rust to have really
>>> good production-compatible monitoring (which I agree is a worthwhile goal).
>>>
>>> keegan
>>
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From erick.tryzelaar at gmail.com  Mon Sep 30 13:44:43 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 30 Sep 2013 13:44:43 -0700
Subject: [rust-dev] Bay Area Rust meetup
Message-ID: <CALdfqQKFwYrAW=YYf2pXH72_Q=OJ=-MUba0bWLCj6ZydyZ-Z6w@mail.gmail.com>

Hey all!

I finally got around to setting up the Bay Area Rust meetup group:

http://www.meetup.com/Rust-Bay-Area

Everyone is welcome to join. I haven't organized the first meeting yet, so
please feel free to propose a venue or topic. I look forward to getting
together with you all.

-e
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/e7b773a3/attachment.html>

From me at kevincantu.org  Mon Sep 30 13:58:05 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Mon, 30 Sep 2013 13:58:05 -0700
Subject: [rust-dev] Announce: rust-pcre
In-Reply-To: <CALdfqQ+=wiR9zF9xWsDgw1r9+RFzKbwijnNCuFX-BxYvWR-pFg@mail.gmail.com>
References: <CAH+UCjPoaNCHTYkaPbgTrGbAk8j7gHGnL_23ffLLck5vVV4hFQ@mail.gmail.com>
	<CALdfqQ+=wiR9zF9xWsDgw1r9+RFzKbwijnNCuFX-BxYvWR-pFg@mail.gmail.com>
Message-ID: <CABq6+acMVKSn77Lx9j2mrN_sdjdgJ9+4t4yWzK18mo3TPKtLng@mail.gmail.com>

I like knowing that this is straightforward enough to do that it is
being done many times.


Kevin

On Mon, Sep 30, 2013 at 1:03 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com> wrote:
> Hey Cadence!
>
> Nice work. I also have a pcre binding, although I haven't updated it for a
> while: https://github.com/erickt/rustpcre. We should merge :)
>
>
> On Sun, Sep 29, 2013 at 1:54 PM, Cadence Marseille
> <cadencemarseille at gmail.com> wrote:
>>
>> Hello,
>>
>> I spent some time putting together a simple wrapper for libpcre, available
>> at:
>> https://github.com/cadencemarseille/rust-pcre
>>
>> As I am just learning Rust, any comments/thoughts about the wrapper's API,
>> coding style, etc., are welcome.
>>
>> --
>> Cadence
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From kmcallister at mozilla.com  Mon Sep 30 14:00:31 2013
From: kmcallister at mozilla.com (Keegan McAllister)
Date: Mon, 30 Sep 2013 14:00:31 -0700 (PDT)
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<2120171063.1421015.1380571574149.JavaMail.zimbra@mozilla.com>
	<CAPNEFAa3nGX5Kf3pqu1SF6m2gDS9onQsV_bBLmFGdKSj8=thRA@mail.gmail.com>
Message-ID: <1884747289.1439163.1380574831145.JavaMail.zimbra@mozilla.com>

> Is that codable in rust currently?

Well, there are two parts to this: the automatic insertion of logging calls, and the runtime feature to enable/disable them.  The former would be part of the compiler and can directly emit appropriate LLVM along with table entries to say what should be NOP'd out.  The runtime component can probably be written in (unsafe) Rust since it's ultimately just writing known sequences of bytes to known addresses.  It will need to know some details about memory protection, architectures where a system call is required to flush the i-cache, etc.  It may also need support from the Rust scheduler to avoid modifying code directly under the instruction pointer.

Linux uses GCC extended asm and some linker features to implement their self-modifying debug/trace macros.  For automatically hooking every function call, they repurpose GCC's profiling support, which inserts a call to mcount() at the beginning of each function.

A while back I wrote up a small demonstration of techniques based on what Linux does:

    http://mainisusuallyafunction.blogspot.com/2011/11/self-modifying-code-for-debug-tracing.html

keegan

From alex at crichton.co  Mon Sep 30 14:36:01 2013
From: alex at crichton.co (Alex Crichton)
Date: Mon, 30 Sep 2013 14:36:01 -0700
Subject: [rust-dev] Crate-scoped non-trait implementations
In-Reply-To: <8D08A1C9948B1B4-1FC4-1D421@webmail-d154.sysops.aol.com>
References: <8D08A1C9948B1B4-1FC4-1D421@webmail-d154.sysops.aol.com>
Message-ID: <CAFnh-meu8ZsweOd3qhdzqFVq33AsgCe8P=kSWGgWSmNmMFYEdQ@mail.gmail.com>

>From what I've seen, privacy is tricky enough as-is, so I think we
should try to avoid new rules and new keywords. That being said, this
may be possible by just actually applying the rules to implementations
as-is.

Currently, I believe the privacy of a method is calculated by: "is the
method itself private or not?" and that's it. Arguably we should be
looking at the ancestry of methods as well. If we look at all
ancestors, then you could have pub fns inside priv modules which would
only be usable to your own crate (because they're in your ancestry).

I'm not sure if the privacy of functions and methods is a relic of a
buggy implementation or performed on purpose, though, so I'd want to
talk it over a bit more before we decide to do something like this. I
do agree, though, that it would be nice to have private functions
scoped to a chunk of the module hierarchy instead of perhaps just one
module.

On Fri, Sep 27, 2013 at 9:44 PM, SiegeLord <slabode at aim.com> wrote:
> Given the proposed privacy resolution rules (
> https://github.com/mozilla/rust/issues/8215#issuecomment-24762188 ) there
> exists a concept of crate-scope for items: these can be used within the
> implementation of the crate, but are inaccessible from other crates. This is
> easy to do by introducing a private module:
>
> mod private
> {
>    pub fn crate_scoped_fn();
>    pub trait CrateScopedTrait;
>    pub struct CrateScopedStruct;
> }
>
> It's not clear to me whether or not this is possible (or whether it should
> be) for non-trait implementations. Right now, if I do this:
>
> pub struct S;
> mod private
> {
>    impl super::S
>    {
>        pub fn new() -> super::S { super::S }
>        pub fn crate_local_api(&self) -> {}
>    }
> }
>
> I find that the associated function can't be used at all within a crate or
> cross crate (issue #9584), while the method resolves in both cases, but does
> not link cross-crate. What should happen in this case? I'd prefer for the
> function and method to resolve within a crate, but not cross crate.
>
> Notably, this is not how trait implementations work today, as those are
> resolved by looking at the location/privacy of the trait and not the
> implementation.  I think crate-scoped methods and associated functions are
> very useful though, and it's worthwhile to have a different rule for them.
>
> Or maybe there should be an explicit keyword for the crate scope and not
> bother with these bizarre privacy rules. Or maybe I am missing an alternate
> way to accomplish this?
>
> -SL
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From josh at joshmatthews.net  Mon Sep 30 14:53:41 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Mon, 30 Sep 2013 17:53:41 -0400
Subject: [rust-dev] autotrace
In-Reply-To: <CAPNEFAZK-dFPKchQUZSUpAp5oTnoQ4O1qb8dkpL8Xpxex1jNtQ@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<CAOvJiVUDb0tebsAXryU+GOFG-i12ksrZAy0_BS+YM8EXovB_Qw@mail.gmail.com>
	<CAPNEFAZK-dFPKchQUZSUpAp5oTnoQ4O1qb8dkpL8Xpxex1jNtQ@mail.gmail.com>
Message-ID: <CAOvJiVXo53VdoVKnJrNP9HPRqsf=Dq76Jdhenfg0-qTvndngTA@mail.gmail.com>

That's very curious, because we have tests exercising all of the
functionality like local variables that show that it should be working.
Stepping could definitely be jumpy, but in general I've found it to be
quite usable. Try building without -Z debug-info, since -Z extra-debug-info
implies it. I'd also be interested in seeing the code that demonstrates
this problem for you.

Cheers,
Josh


On 30 September 2013 15:18, Jason E. Aten <j.e.aten at gmail.com> wrote:

> Hi Josh,
>
> Could you be more specific about what you would like me to try?  When I
> iniquire on #rust I'm told that debug-info is still in bad shape.
>
> Specifically: I do rustc -Z debug-info -Z extra-debug-info -Z no-opt, and
> I consistently get no local variables showing up in gdb on any stack frame.
> The frame pointer jumps to random places in the source code when stepping.
>
> And moreover,  --autotrace would so much more useful in that it would also
> allow monitoring of an in-production system without stopping it or
> re-deploying as a debug-build.
>
> Jason
>
> On Mon, Sep 30, 2013 at 12:05 PM, Josh Matthews <josh at joshmatthews.net>wrote:
>
>> Please note that Michael Woerister's work this summer on debug symbols
>> has been wildly successful, and it's worth giving it another shot before
>> looking into further compiler hacking:
>> http://michaelwoerister.github.io/2013/09/27/what-you-call-the-present.html
>>
>> Cheers,
>> Josh
>>
>>
>> On 30 September 2013 14:00, Jason E. Aten <j.e.aten at gmail.com> wrote:
>>
>>> I was very frustrated by the lack of debug-info at the gdb prompt during
>>> rust coding recently. I note too that people on #rust complain about the
>>> lack of visibility into debugging rustc itself.
>>>
>>> I think there is a lightweight, quick to implement, solution to these
>>> problems.
>>>
>>> I have in mind a simple facility provided by a compiler flag that
>>> injects (logging-controlled) printf or tracing-log statement at the top and
>>> bottom of every function. Something like:
>>>
>>> // example:
>>> fn fun1(a:int, b:str, c:HashMap<~str, int>) -> HashMap<~str,int> {
>>>    c.insert(a,b)
>>> }
>>>
>>> // would effectively become, with rustc --autotrace enabled:
>>>
>>> fn fun1(a:int, b:str, c:HashMap<~str, int>) {
>>>    // intro
>>>    if (global_tracking_flag) {
>>>       stack_depth = stack_depth + 1;
>>>       trace!("%s call fun1(%?, %?, %?)",
>>> indent_spaces_according_to_stack_depth(), a, b, c);
>>>    }
>>>
>>>    c.insert(a,b);
>>>
>>>    // outro : would have to be like a destructor, that is called on
>>> every return path...
>>>    if (global_tracking_flag) {
>>>       trace!("%s return from fun1 -> %?",
>>> indent_spaces_according_to_stack_depth(), c);
>>>       stack_depth = stack_depth - 1;
>>>    }
>>> }
>>>
>>>
>>> Although not without cost, the --autotrace facility could even be highly
>>> useful for runtime monitoring (and therefore better/faster/cheaper than
>>> comprehensive debug-info). The idea being that it would be cheap enough
>>> (surely global_tracking_flag could be persuaded to live in a register, no?)
>>> that it could be left compiled into most non-inlined function, and
>>> activated at runtime without bringing a production system down.
>>>
>>> Related experience.... Justin Sheehy at Basho talks about how Erlang's
>>> runtime monitoring facilities were under-appreciated when they started.
>>>
>>> "Many other features that we didn?t understand the full importance of at
>>> the time (such as the ability to inspect and modify a live system at
>>> run-time with almost no planning or cost) have also helped us greatly in
>>> making systems that our users and customers trust with their most critical
>>> data."  http://basho.com/erlang-at-basho-five-years-later/
>>>
>>> Thoughts? Is --autotrace a viable idea at all?
>>>
>>> Jason
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/366d7f9d/attachment-0001.html>

From kmcallister at mozilla.com  Mon Sep 30 14:59:02 2013
From: kmcallister at mozilla.com (Keegan McAllister)
Date: Mon, 30 Sep 2013 14:59:02 -0700 (PDT)
Subject: [rust-dev] Crate-scoped non-trait implementations
In-Reply-To: <CAFnh-meu8ZsweOd3qhdzqFVq33AsgCe8P=kSWGgWSmNmMFYEdQ@mail.gmail.com>
References: <8D08A1C9948B1B4-1FC4-1D421@webmail-d154.sysops.aol.com>
	<CAFnh-meu8ZsweOd3qhdzqFVq33AsgCe8P=kSWGgWSmNmMFYEdQ@mail.gmail.com>
Message-ID: <1188821555.1450337.1380578342645.JavaMail.zimbra@mozilla.com>

I'd be interested to hear some of the use cases for crate scope.

I like the clear separation of responsibilities between modules (namespace & visibility) and crates (compilation & packaging).  So in principle I like the idea of scoping to an arbitrary chunk of the module hierarchy better than scoping to crates specifically.  But there's a complexity tradeoff.  And in practice, it does seem useful to be able to say "all the code I (the library author) write can touch this".

keegan

----- Original Message -----
From: "Alex Crichton" <alex at crichton.co>
To: "SiegeLord" <slabode at aim.com>
Cc: rust-dev at mozilla.org
Sent: Monday, September 30, 2013 2:36:01 PM
Subject: Re: [rust-dev] Crate-scoped non-trait implementations

>From what I've seen, privacy is tricky enough as-is, so I think we
should try to avoid new rules and new keywords. That being said, this
may be possible by just actually applying the rules to implementations
as-is.

Currently, I believe the privacy of a method is calculated by: "is the
method itself private or not?" and that's it. Arguably we should be
looking at the ancestry of methods as well. If we look at all
ancestors, then you could have pub fns inside priv modules which would
only be usable to your own crate (because they're in your ancestry).

I'm not sure if the privacy of functions and methods is a relic of a
buggy implementation or performed on purpose, though, so I'd want to
talk it over a bit more before we decide to do something like this. I
do agree, though, that it would be nice to have private functions
scoped to a chunk of the module hierarchy instead of perhaps just one
module.

On Fri, Sep 27, 2013 at 9:44 PM, SiegeLord <slabode at aim.com> wrote:
> Given the proposed privacy resolution rules (
> https://github.com/mozilla/rust/issues/8215#issuecomment-24762188 ) there
> exists a concept of crate-scope for items: these can be used within the
> implementation of the crate, but are inaccessible from other crates. This is
> easy to do by introducing a private module:
>
> mod private
> {
>    pub fn crate_scoped_fn();
>    pub trait CrateScopedTrait;
>    pub struct CrateScopedStruct;
> }
>
> It's not clear to me whether or not this is possible (or whether it should
> be) for non-trait implementations. Right now, if I do this:
>
> pub struct S;
> mod private
> {
>    impl super::S
>    {
>        pub fn new() -> super::S { super::S }
>        pub fn crate_local_api(&self) -> {}
>    }
> }
>
> I find that the associated function can't be used at all within a crate or
> cross crate (issue #9584), while the method resolves in both cases, but does
> not link cross-crate. What should happen in this case? I'd prefer for the
> function and method to resolve within a crate, but not cross crate.
>
> Notably, this is not how trait implementations work today, as those are
> resolved by looking at the location/privacy of the trait and not the
> implementation.  I think crate-scoped methods and associated functions are
> very useful though, and it's worthwhile to have a different rule for them.
>
> Or maybe there should be an explicit keyword for the crate scope and not
> bother with these bizarre privacy rules. Or maybe I am missing an alternate
> way to accomplish this?
>
> -SL
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From eric.holk at gmail.com  Mon Sep 30 15:18:12 2013
From: eric.holk at gmail.com (Eric Holk)
Date: Mon, 30 Sep 2013 18:18:12 -0400
Subject: [rust-dev] "Computed" maps
In-Reply-To: <20130930203050.GA22884@davidb.org>
References: <20130926023647.GA14641@davidb.org>
	<CA+DvKQ+U61w_DZG8929GedxnFeQTFdO2gPHky9K8nyCY+voNyw@mail.gmail.com>
	<CAK-XjKWeJXw=amSMMyRrvJS9SB7_=nc6ra-eLz06JdtbeLL16g@mail.gmail.com>
	<20130930203050.GA22884@davidb.org>
Message-ID: <CAPYfifi2J4_kVbx1TtBfn3v7Qo7_+tQB9daBpnQ6xKznXPSHAQ@mail.gmail.com>

This still isn't the map trait, but I think you could try passing a block
to the find function, like this (the syntax is likely a bit out of date...
):

    fn find<'a>(&'a self, key: &K, block: &fn(Option<&'a V>) -> T) -> T;

Then, instead of doing something like,

   let x = m.find(y);
   ... do stuff with x ...


you'd do something like this:

   m.find(y, |x| {
       ... do stuff with x ...
   })




On Mon, Sep 30, 2013 at 4:30 PM, David Brown <davidb at davidb.org> wrote:

> On Thu, Sep 26, 2013 at 12:58:48PM -0700, Brandon Sanderson wrote:
>
>  If the values are cached, and the structure implementing the cache has
>> the same lifetime (or longer? Unsure on that...) as the map then I'd
>> expect it to work.? For generated/retrieved, non-cached values I don't
>> believe it would work.
>>
>
> I'm still not sure this would quite be right.  How long would we keep
> things in the cache, since the compiler only knows the lifetime is the
> same as the structure holding it, that would suggest nothing could be
> removed from the cache.
>
> For now, I'm just going to return similar operations that return
> cloneable values rather than references.  My use cases are small types
> (such as uint), so this doesn't really hurt anything.
>
> Thanks,
> David
>
>  On 2013-09-25 7:54 PM, "Daniel Micay" <[1]danielmicay at gmail.com>
>> wrote:
>>
>>  On Wed, Sep 25, 2013 at 10:36 PM, David Brown <[2]davidb at davidb.org>
>>
>>  wrote:
>>
>>    Let's say I'm implementing some type of map-like structure that
>>    I'd
>>    like to be able to implement the Map trait on.
>>
>>    However, my map doesn't actually store the 'V' directly, but they
>>    are
>>    computed/retrieve/cached in some manner.
>>
>>    Is this possible with the existing map trait? ?Given that:
>>
>>    ?fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
>>
>>    doesn't the V need to be a pointer to something with the same
>>    lifetime
>>    as self?
>>
>>    Is there a way of dealing with this, or should I just implement my
>>    own
>>    similar find function, not implementing Map, and return an
>>    Option<V>
>>    instead?
>>
>>  The Map trait represents a map storing the values, so it can't be
>>  used for that use case.
>>  ______________________________**_________________
>>  Rust-dev mailing list
>>  [3]Rust-dev at mozilla.org
>>  [4]https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>>
>> References
>>
>>   Visible links
>>   1. mailto:danielmicay at gmail.com
>>   2. mailto:davidb at davidb.org
>>   3. mailto:Rust-dev at mozilla.org
>>   4. https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>>
>
>  ______________________________**_________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>>
>
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/009c0669/attachment.html>

From erick.tryzelaar at gmail.com  Mon Sep 30 16:46:58 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 30 Sep 2013 16:46:58 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
Message-ID: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>

Good afternoon all,

We've got a bunch of the Rust community going to the Mozilla Summit events
this weekend. It'd be great if we could meet for dinner one of the
evenings. If you are going, which city will you be in? Would one day work
better than another? I'll be in Santa Clara, CA, and I'm free all the
evenings.

-e
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/bacd7fe5/attachment.html>

From catamorphism at gmail.com  Mon Sep 30 16:48:24 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 30 Sep 2013 16:48:24 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
Message-ID: <CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>

On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com> wrote:
> Good afternoon all,
>
> We've got a bunch of the Rust community going to the Mozilla Summit events
> this weekend. It'd be great if we could meet for dinner one of the evenings.
> If you are going, which city will you be in? Would one day work better than
> another? I'll be in Santa Clara, CA, and I'm free all the evenings.

I'll be in Toronto; will anyone from the community be there?

Cheers,
Tim


-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From josh at joshmatthews.net  Mon Sep 30 17:01:42 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Mon, 30 Sep 2013 20:01:42 -0400
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
	<CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>
Message-ID: <CAOvJiVWXqc1pssr_m1kf1CBe7xVZXVUYxoOeTG4c6q83=+w15A@mail.gmail.com>

I'll be in Brussels.

Cheers,
Josh


On 30 September 2013 19:48, Tim Chevalier <catamorphism at gmail.com> wrote:

> On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
> <erick.tryzelaar at gmail.com> wrote:
> > Good afternoon all,
> >
> > We've got a bunch of the Rust community going to the Mozilla Summit
> events
> > this weekend. It'd be great if we could meet for dinner one of the
> evenings.
> > If you are going, which city will you be in? Would one day work better
> than
> > another? I'll be in Santa Clara, CA, and I'm free all the evenings.
>
> I'll be in Toronto; will anyone from the community be there?
>
> Cheers,
> Tim
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "Being queer is not about a right to privacy; it is about the freedom
> to be public, to just be who we are." -- anonymous, June 1990
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/2ed92665/attachment-0001.html>

From banderson at mozilla.com  Mon Sep 30 17:21:14 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 30 Sep 2013 17:21:14 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
Message-ID: <524A157A.3030105@mozilla.com>

On 09/30/2013 04:46 PM, Erick Tryzelaar wrote:
> Good afternoon all,
>
> We've got a bunch of the Rust community going to the Mozilla Summit 
> events this weekend. It'd be great if we could meet for dinner one of 
> the evenings. If you are going, which city will you be in? Would one 
> day work better than another? I'll be in Santa Clara, CA, and I'm free 
> all the evenings.

I'm in Brussels.

From acrichton at mozilla.com  Mon Sep 30 17:21:40 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Mon, 30 Sep 2013 17:21:40 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
Message-ID: <076E086D-46E1-4672-A70D-F32ABF987A56@mozilla.com>

Santa Clara, yay!

On Sep 30, 2013, at 4:46 PM, Erick Tryzelaar <erick.tryzelaar at gmail.com> wrote:

> Good afternoon all,
> 
> We've got a bunch of the Rust community going to the Mozilla Summit events this weekend. It'd be great if we could meet for dinner one of the evenings. If you are going, which city will you be in? Would one day work better than another? I'll be in Santa Clara, CA, and I'm free all the evenings.
> 
> -e
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From tellrob at gmail.com  Mon Sep 30 17:26:06 2013
From: tellrob at gmail.com (Rob Arnold)
Date: Mon, 30 Sep 2013 17:26:06 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
Message-ID: <-6703926419614902154@unknownmsgid>

I am a much older contributor but I'll be Toronto as well. Looking
forward to meeting more Rust folks!

-Rob From: Tim Chevalier
Sent: 9/30/2013 4:48 PM
To: Erick Tryzelaar
Cc: rust-dev at mozilla.org
Subject: Re: [rust-dev] Connecting at the Mozilla Summit
On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com> wrote:
> Good afternoon all,
>
> We've got a bunch of the Rust community going to the Mozilla Summit events
> this weekend. It'd be great if we could meet for dinner one of the evenings.
> If you are going, which city will you be in? Would one day work better than
> another? I'll be in Santa Clara, CA, and I'm free all the evenings.

I'll be in Toronto; will anyone from the community be there?

Cheers,
Tim


-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990
_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From laden at csclub.uwaterloo.ca  Mon Sep 30 17:39:54 2013
From: laden at csclub.uwaterloo.ca (Luqman Aden)
Date: Mon, 30 Sep 2013 17:39:54 -0700
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
Message-ID: <CADRTvECEwdJzfe0Z7dXarUHi5sM7wOmmOkcmekZykrGpudO5Fw@mail.gmail.com>

Brussels!

On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com> wrote:
> Good afternoon all,
>
> We've got a bunch of the Rust community going to the Mozilla Summit events
> this weekend. It'd be great if we could meet for dinner one of the evenings.
> If you are going, which city will you be in? Would one day work better than
> another? I'll be in Santa Clara, CA, and I'm free all the evenings.
>
> -e
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From catamorphism at gmail.com  Mon Sep 30 18:11:36 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 30 Sep 2013 18:11:36 -0700
Subject: [rust-dev] rustpkg behavior
In-Reply-To: <DUB122-W43DA207FC413434FCEAD4CB0210@phx.gbl>
References: <DUB122-W43DA207FC413434FCEAD4CB0210@phx.gbl>
Message-ID: <CADcg8=mzGq7PVbj4mqjMU2StgTV9dCfhSx+3pcUSqLw1bqrM0Q@mail.gmail.com>

On Thu, Sep 19, 2013 at 3:19 PM, Madhu Srinivasan
<smadhueagle at outlook.com> wrote:
> hi fellow rusters,
>
> I understand that rustpkg is under heavy development and not complete.
> Having said that, I'd like to know if the following error (w.r.t. rustpkg
> finding external crates and linking correctly with them) is within it's
> normal operating parameters :).
>
> The rust code in question: https://github.com/smadhueagle/rustlings
> (It is a series of example rust programs)
> The external crate that it refers to: https://github.com/smadhueagle/rustils
>
> Following the steps in Readme.md on the rustlings repo and building the
> simplespawn crate results in the following error:
>
> kl-13572:rustlings smadhueagle$ rustpkg build simplespawn
> WARNING: The Rust package manager is experimental and may be unstable
> task <unnamed> failed at 'Unhandled condition: nonexistent_package:
> (package_id::PkgId{path: std::path::PosixPath{is_absolute: false,
> components: ~[~"rustils"]}, short_name: ~"rustils", version: NoVersion},
> ~"supplied path for package dir does not exist, and couldn't interpret it as
> a URL fragment")', /private/tmp/rust-nVcw/src/libstd/condition.rs:43
> task <unnamed> failed at 'killed by linked failure',
> /private/tmp/rust-nVcw/src/libstd/rt/kill.rs:627

Sorry for overlooking this email until now. The issue here is that you
need to either write:

extern mod rustils = "github.com/smadhueagle/rustils";

instead of `extern mod rustils;`, in the code that uses it (and in
this case you don't need the `rustpkg install` step), or set your
RUST_PATH to:

$TOP/rustlings/.rust/github.com/smadhueagle/rustils-0.1

where $TOP is the directory that contains the `rustlings` directory.

I tested the latter option with rustpkg as built  from 7ddcd2, and it worked.

Feel free to ask again here if you have more questions (and I'll try
to answer them sooner :-)

Cheers,
Tim





-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"Being queer is not about a right to privacy; it is about the freedom
to be public, to just be who we are." -- anonymous, June 1990

From saneyuki.s.snyk at gmail.com  Mon Sep 30 18:15:18 2013
From: saneyuki.s.snyk at gmail.com (Tetsuharu OHZEKI)
Date: Tue, 1 Oct 2013 10:15:18 +0900
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CADRTvECEwdJzfe0Z7dXarUHi5sM7wOmmOkcmekZykrGpudO5Fw@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
	<CADRTvECEwdJzfe0Z7dXarUHi5sM7wOmmOkcmekZykrGpudO5Fw@mail.gmail.com>
Message-ID: <CACyPx=mv0+VKTYXXrqG7YbOe=EmkCUDntBbSPDCKb5F0Vtf2HA@mail.gmail.com>

Santa Clara! Santa Clara!

2013/10/1 Luqman Aden <laden at csclub.uwaterloo.ca>:
> Brussels!
>
> On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
> <erick.tryzelaar at gmail.com> wrote:
>> Good afternoon all,
>>
>> We've got a bunch of the Rust community going to the Mozilla Summit events
>> this weekend. It'd be great if we could meet for dinner one of the evenings.
>> If you are going, which city will you be in? Would one day work better than
>> another? I'll be in Santa Clara, CA, and I'm free all the evenings.
>>
>> -e
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
saneyuki_s
saneyuki.s.snyk at gmail.com

From j.e.aten at gmail.com  Mon Sep 30 18:29:15 2013
From: j.e.aten at gmail.com (Jason E. Aten)
Date: Mon, 30 Sep 2013 18:29:15 -0700
Subject: [rust-dev] autotrace
In-Reply-To: <CAOvJiVXo53VdoVKnJrNP9HPRqsf=Dq76Jdhenfg0-qTvndngTA@mail.gmail.com>
References: <CAPNEFAZqknr2dd8sft7Y7Xkt-dwFeKeqtTrNjDTOfcAB-2rD-w@mail.gmail.com>
	<CAOvJiVUDb0tebsAXryU+GOFG-i12ksrZAy0_BS+YM8EXovB_Qw@mail.gmail.com>
	<CAPNEFAZK-dFPKchQUZSUpAp5oTnoQ4O1qb8dkpL8Xpxex1jNtQ@mail.gmail.com>
	<CAOvJiVXo53VdoVKnJrNP9HPRqsf=Dq76Jdhenfg0-qTvndngTA@mail.gmail.com>
Message-ID: <CAPNEFAbhnMGbC33TorKwDkOvto6CySoXULt18aEX6+XxE3otmg@mail.gmail.com>

Hi Josh,

I'm told that rustc itself is a prime example. People on #rust were
complaining about how opaque it is, and telling me printfs were the only
recourse. Are you saying you *are* able to step through rustc?

I filed a ticket for the stuff that was frustrating me--stepping through
the msgpack bindings; full repro steps here:

https://github.com/mozilla/rust/issues/9641

Jason



On Mon, Sep 30, 2013 at 2:53 PM, Josh Matthews <josh at joshmatthews.net>wrote:

> That's very curious, because we have tests exercising all of the
> functionality like local variables that show that it should be working.
> Stepping could definitely be jumpy, but in general I've found it to be
> quite usable. Try building without -Z debug-info, since -Z extra-debug-info
> implies it. I'd also be interested in seeing the code that demonstrates
> this problem for you.
>
> Cheers,
> Josh
>
>
> On 30 September 2013 15:18, Jason E. Aten <j.e.aten at gmail.com> wrote:
>
>> Hi Josh,
>>
>> Could you be more specific about what you would like me to try?  When I
>> iniquire on #rust I'm told that debug-info is still in bad shape.
>>
>> Specifically: I do rustc -Z debug-info -Z extra-debug-info -Z no-opt, and
>> I consistently get no local variables showing up in gdb on any stack frame.
>> The frame pointer jumps to random places in the source code when stepping.
>>
>> And moreover,  --autotrace would so much more useful in that it would
>> also allow monitoring of an in-production system without stopping it or
>> re-deploying as a debug-build.
>>
>> Jason
>>
>> On Mon, Sep 30, 2013 at 12:05 PM, Josh Matthews <josh at joshmatthews.net>wrote:
>>
>>> Please note that Michael Woerister's work this summer on debug symbols
>>> has been wildly successful, and it's worth giving it another shot before
>>> looking into further compiler hacking:
>>> http://michaelwoerister.github.io/2013/09/27/what-you-call-the-present.html
>>>
>>> Cheers,
>>> Josh
>>>
>>>
>>> On 30 September 2013 14:00, Jason E. Aten <j.e.aten at gmail.com> wrote:
>>>
>>>> I was very frustrated by the lack of debug-info at the gdb prompt
>>>> during rust coding recently. I note too that people on #rust complain about
>>>> the lack of visibility into debugging rustc itself.
>>>>
>>>> I think there is a lightweight, quick to implement, solution to these
>>>> problems.
>>>>
>>>> I have in mind a simple facility provided by a compiler flag that
>>>> injects (logging-controlled) printf or tracing-log statement at the top and
>>>> bottom of every function. Something like:
>>>>
>>>> // example:
>>>> fn fun1(a:int, b:str, c:HashMap<~str, int>) -> HashMap<~str,int> {
>>>>    c.insert(a,b)
>>>> }
>>>>
>>>> // would effectively become, with rustc --autotrace enabled:
>>>>
>>>> fn fun1(a:int, b:str, c:HashMap<~str, int>) {
>>>>    // intro
>>>>    if (global_tracking_flag) {
>>>>       stack_depth = stack_depth + 1;
>>>>       trace!("%s call fun1(%?, %?, %?)",
>>>> indent_spaces_according_to_stack_depth(), a, b, c);
>>>>    }
>>>>
>>>>    c.insert(a,b);
>>>>
>>>>    // outro : would have to be like a destructor, that is called on
>>>> every return path...
>>>>    if (global_tracking_flag) {
>>>>       trace!("%s return from fun1 -> %?",
>>>> indent_spaces_according_to_stack_depth(), c);
>>>>       stack_depth = stack_depth - 1;
>>>>    }
>>>> }
>>>>
>>>>
>>>> Although not without cost, the --autotrace facility could even be
>>>> highly useful for runtime monitoring (and therefore better/faster/cheaper
>>>> than comprehensive debug-info). The idea being that it would be cheap
>>>> enough (surely global_tracking_flag could be persuaded to live in a
>>>> register, no?) that it could be left compiled into most non-inlined
>>>> function, and activated at runtime without bringing a production system
>>>> down.
>>>>
>>>> Related experience.... Justin Sheehy at Basho talks about how Erlang's
>>>> runtime monitoring facilities were under-appreciated when they started.
>>>>
>>>> "Many other features that we didn?t understand the full importance of
>>>> at the time (such as the ability to inspect and modify a live system at
>>>> run-time with almost no planning or cost) have also helped us greatly in
>>>> making systems that our users and customers trust with their most critical
>>>> data."  http://basho.com/erlang-at-basho-five-years-later/
>>>>
>>>> Thoughts? Is --autotrace a viable idea at all?
>>>>
>>>> Jason
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20130930/56019bc3/attachment-0001.html>

From sh4.seo at samsung.com  Mon Sep 30 22:30:10 2013
From: sh4.seo at samsung.com (Sanghyeon Seo)
Date: Tue, 01 Oct 2013 05:30:10 +0000 (GMT)
Subject: [rust-dev] autotrace
Message-ID: <2020612.105731380605410366.JavaMail.weblogic@epml11>

> surely global_tracking_flag could be persuaded to live in a register, no?

No. Although this is implemented in GCC, this is unimplemented in LLVM and
upstream is not keen on implementing it.

See "Global Register Variables" note at http://nondot.org/sabre/LLVMNotes/
and LLVM bug 16877.

From danielmicay at gmail.com  Mon Sep 30 23:00:54 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 1 Oct 2013 02:00:54 -0400
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
	<CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>
Message-ID: <CA+DvKQKsyMEfqPiS0i76272JVa=OG4uDioP-X6nU-6=X39-5NA@mail.gmail.com>

On Mon, Sep 30, 2013 at 7:48 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> On Mon, Sep 30, 2013 at 4:46 PM, Erick Tryzelaar
> <erick.tryzelaar at gmail.com> wrote:
> > Good afternoon all,
> >
> > We've got a bunch of the Rust community going to the Mozilla Summit
> events
> > this weekend. It'd be great if we could meet for dinner one of the
> evenings.
> > If you are going, which city will you be in? Would one day work better
> than
> > another? I'll be in Santa Clara, CA, and I'm free all the evenings.
>
> I'll be in Toronto; will anyone from the community be there?
>
> Cheers,
> Tim
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "Being queer is not about a right to privacy; it is about the freedom
> to be public, to just be who we are." -- anonymous, June 1990
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

I'll be at the summit in Toronto too.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131001/3a69e64c/attachment.html>

From oren at ben-kiki.org  Mon Sep 30 23:13:19 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 1 Oct 2013 09:13:19 +0300
Subject: [rust-dev] The new format!
Message-ID: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>

I just transitioned my code to use the new format! macros. I was happy to
get rid of all the .to_str() I had all over the place, but this turned out
not quite as I had expected.

I was hoping I'd be able to simply base on the ToStr trait to print
anything with {:s}. It turns out that actually there's a String trait with
an fmt function - Ok, that makes sense, as one can emit stuff piecewise
without having to pay the costs of creating an intermediate complete string.

But it turns out that the standard library hard-wires the implementation of
the String trait to use the Str trait, which has two functions - to_owned
and as_slice. I understand the motivation of as_slice for more efficient
formatting (though I don't see why it needs to provide to_owned, but
anyway). Ok, just a bit more boilerplate, I thought - but then I hit a wall.

The as_slice function requires returning a borrowed pointer whose lifetime
is specified by the caller. If my type has to_str which returns a ~str, I
can't really return a borrowed pointer to it (as the ~str will live too
short).

This problem is unique to the String trait. All the other traits (Bool,
Pointer, ...) just allow specifying the trait directly without getting too
clever with string slices. So... I cheated and added a LowerHex instance my
types instead of String (which conflicts with libstd) or Str (which I can't
implement). I now print my types with {:x} (I think of it as "user eXtended
format").

I know, this is pretty horrible... what is the "right thing" here? Using
{:s} and keep calling .to_str() everywhere?

A second, related problem, is formatting simple enums. It is easy to derive
ToStr for such enums, but this means I still need to say {:s} and
my_enum.to_str() - exactly what I hoped to avoid. And I really don't want
to manually specify a LowerHex or Str instance to each and every enum (it
is bad enough I need to do it for each of the relevant small-struct types).

If there was a, say, {:S} that was automatically available for everything
that had ToStr, then both problems would have been solved. {:s} would
remain a more efficient way to format things that were "actually" strings,
while {:S} would allow formatting things that could be "viewed as" strings.

Does that make sense?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131001/d0b48d54/attachment.html>

From dbau.pp at gmail.com  Mon Sep 30 23:12:38 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 01 Oct 2013 16:12:38 +1000
Subject: [rust-dev] The new format!
In-Reply-To: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
References: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
Message-ID: <524A67D6.5090709@gmail.com>

On 01/10/13 16:13, Oren Ben-Kiki wrote:
>
> This problem is unique to the String trait. All the other traits 
> (Bool, Pointer, ...) just allow specifying the trait directly without 
> getting too clever with string slices. So... I cheated and added a 
> LowerHex instance my types instead of String (which conflicts with 
> libstd) or Str (which I can't implement). I now print my types with 
> {:x} (I think of it as "user eXtended format").
>
> I know, this is pretty horrible... what is the "right thing" here? 
> Using {:s} and keep calling .to_str() everywhere?
>

There's std::fmt::Default, which corresponds to having no format 
specifier (e.g. {} or {:10} or {a}, etc).


Huon

From jack at metajack.im  Mon Sep 30 23:21:58 2013
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 1 Oct 2013 00:21:58 -0600
Subject: [rust-dev] Connecting at the Mozilla Summit
In-Reply-To: <CA+DvKQKsyMEfqPiS0i76272JVa=OG4uDioP-X6nU-6=X39-5NA@mail.gmail.com>
References: <CALdfqQ+xGFqztmVQXg9tef5ECUvjuKxGCyFAUUd5Tvs6BWA_Og@mail.gmail.com>
	<CADcg8=ncPNjTau_BjVd-K8eOqRTQ-5SCrwtxEdOhzLXORq6yVA@mail.gmail.com>
	<CA+DvKQKsyMEfqPiS0i76272JVa=OG4uDioP-X6nU-6=X39-5NA@mail.gmail.com>
Message-ID: <CAP7VpsVkCZbsZ+AixdXhU2W3qOqTXnAj3TgMEd1eEdmjMyiZyQ@mail.gmail.com>

I'm at the Toronto summit as well, and I highly recommend any Rust
community members visit our Servo supporting session, especially if
you've ever had thoughts about helping out :)

The Mozilla employee members are bringing Rust stickers to give out as
well, so if you haven't got one, come find us!

jack.

From oren at ben-kiki.org  Mon Sep 30 23:24:04 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 1 Oct 2013 09:24:04 +0300
Subject: [rust-dev] The new format!
In-Reply-To: <524A67D6.5090709@gmail.com>
References: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
	<524A67D6.5090709@gmail.com>
Message-ID: <CADJiDhs7CvE-ug1N=huxNTLo-ome8w1-9fB8JPcgUYg8x69_HA@mail.gmail.com>

Ah, so simple. I missed it because it is not listed in the "formatting
traits" list in the documentation.

This would solve half my problem - I'd no longer need to use {:x} but use
the simpler {}, which is great. Thanks!

But it wouldn't solve the problem for printing enums, though. I guess I'd
still have to litter my code with lots of .to_str() when printing them :-(


On Tue, Oct 1, 2013 at 9:12 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 01/10/13 16:13, Oren Ben-Kiki wrote:
>
>>
>> This problem is unique to the String trait. All the other traits (Bool,
>> Pointer, ...) just allow specifying the trait directly without getting too
>> clever with string slices. So... I cheated and added a LowerHex instance my
>> types instead of String (which conflicts with libstd) or Str (which I can't
>> implement). I now print my types with {:x} (I think of it as "user eXtended
>> format").
>>
>> I know, this is pretty horrible... what is the "right thing" here? Using
>> {:s} and keep calling .to_str() everywhere?
>>
>>
> There's std::fmt::Default, which corresponds to having no format specifier
> (e.g. {} or {:10} or {a}, etc).
>
>
> Huon
> ______________________________**_________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131001/b96a1cc4/attachment-0001.html>

From alex at crichton.co  Mon Sep 30 23:25:52 2013
From: alex at crichton.co (Alex Crichton)
Date: Mon, 30 Sep 2013 23:25:52 -0700
Subject: [rust-dev] The new format!
In-Reply-To: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
References: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
Message-ID: <CAFnh-meOWiLH=VCr1RXtNdPTapikP1eO2sRK6D2ns8dRNOjEtQ@mail.gmail.com>

Huon's suggestion of using fmt::Default is what I would suggest as
well. The behavior you're running into is actually a known "feature"
of rust today. You'll find in the fmt module "impl<T: Str> String for
T", and because of this the compiler will not allow you to implement
String for any type specifically. It was not the intention of the
String trait to force you to implement Str (because as you've
discovered, it's very difficult).

That being said, I've been using fmt::Default extensively inside of
rustdoc, so it's certainly very "usable". I'm still unsure if the
trait implementation behavior for String is a bug or a feature, but
perhaps we'll relax the rules soon to allow implementations of String
for other types as well.



On Mon, Sep 30, 2013 at 11:13 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> I just transitioned my code to use the new format! macros. I was happy to
> get rid of all the .to_str() I had all over the place, but this turned out
> not quite as I had expected.
>
> I was hoping I'd be able to simply base on the ToStr trait to print anything
> with {:s}. It turns out that actually there's a String trait with an fmt
> function - Ok, that makes sense, as one can emit stuff piecewise without
> having to pay the costs of creating an intermediate complete string.
>
> But it turns out that the standard library hard-wires the implementation of
> the String trait to use the Str trait, which has two functions - to_owned
> and as_slice. I understand the motivation of as_slice for more efficient
> formatting (though I don't see why it needs to provide to_owned, but
> anyway). Ok, just a bit more boilerplate, I thought - but then I hit a wall.
>
> The as_slice function requires returning a borrowed pointer whose lifetime
> is specified by the caller. If my type has to_str which returns a ~str, I
> can't really return a borrowed pointer to it (as the ~str will live too
> short).
>
> This problem is unique to the String trait. All the other traits (Bool,
> Pointer, ...) just allow specifying the trait directly without getting too
> clever with string slices. So... I cheated and added a LowerHex instance my
> types instead of String (which conflicts with libstd) or Str (which I can't
> implement). I now print my types with {:x} (I think of it as "user eXtended
> format").
>
> I know, this is pretty horrible... what is the "right thing" here? Using
> {:s} and keep calling .to_str() everywhere?
>
> A second, related problem, is formatting simple enums. It is easy to derive
> ToStr for such enums, but this means I still need to say {:s} and
> my_enum.to_str() - exactly what I hoped to avoid. And I really don't want to
> manually specify a LowerHex or Str instance to each and every enum (it is
> bad enough I need to do it for each of the relevant small-struct types).
>
> If there was a, say, {:S} that was automatically available for everything
> that had ToStr, then both problems would have been solved. {:s} would remain
> a more efficient way to format things that were "actually" strings, while
> {:S} would allow formatting things that could be "viewed as" strings.
>
> Does that make sense?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From oren at ben-kiki.org  Mon Sep 30 23:26:09 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 1 Oct 2013 09:26:09 +0300
Subject: [rust-dev] The new format!
In-Reply-To: <CADJiDhs7CvE-ug1N=huxNTLo-ome8w1-9fB8JPcgUYg8x69_HA@mail.gmail.com>
References: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
	<524A67D6.5090709@gmail.com>
	<CADJiDhs7CvE-ug1N=huxNTLo-ome8w1-9fB8JPcgUYg8x69_HA@mail.gmail.com>
Message-ID: <CADJiDhsHMKLporKjYDeTyjbG8XuSHvgoPAEigjT9j9Y6-yO=_A@mail.gmail.com>

Perhaps if the type system was smart enough to provide a default
implementation of the Default trait for everything that had the ToStr
trait, and allowing overrides for specific types?

I know that currently this sort of inference is not supported, but it is
intended that it would be possible in the future, right?


On Tue, Oct 1, 2013 at 9:24 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Ah, so simple. I missed it because it is not listed in the "formatting
> traits" list in the documentation.
>
> This would solve half my problem - I'd no longer need to use {:x} but use
> the simpler {}, which is great. Thanks!
>
> But it wouldn't solve the problem for printing enums, though. I guess I'd
> still have to litter my code with lots of .to_str() when printing them :-(
>
>
> On Tue, Oct 1, 2013 at 9:12 AM, Huon Wilson <dbau.pp at gmail.com> wrote:
>
>> On 01/10/13 16:13, Oren Ben-Kiki wrote:
>>
>>>
>>> This problem is unique to the String trait. All the other traits (Bool,
>>> Pointer, ...) just allow specifying the trait directly without getting too
>>> clever with string slices. So... I cheated and added a LowerHex instance my
>>> types instead of String (which conflicts with libstd) or Str (which I can't
>>> implement). I now print my types with {:x} (I think of it as "user eXtended
>>> format").
>>>
>>> I know, this is pretty horrible... what is the "right thing" here? Using
>>> {:s} and keep calling .to_str() everywhere?
>>>
>>>
>> There's std::fmt::Default, which corresponds to having no format
>> specifier (e.g. {} or {:10} or {a}, etc).
>>
>>
>> Huon
>> ______________________________**_________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/**listinfo/rust-dev<https://mail.mozilla.org/listinfo/rust-dev>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131001/5f240d82/attachment.html>

From dbau.pp at gmail.com  Mon Sep 30 23:30:34 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 01 Oct 2013 16:30:34 +1000
Subject: [rust-dev] The new format!
In-Reply-To: <CADJiDhsHMKLporKjYDeTyjbG8XuSHvgoPAEigjT9j9Y6-yO=_A@mail.gmail.com>
References: <CADJiDhvYoNptefXbVnEYswG9vUuh0BF7D=6cczLG1GfcpzNd=w@mail.gmail.com>
	<524A67D6.5090709@gmail.com>
	<CADJiDhs7CvE-ug1N=huxNTLo-ome8w1-9fB8JPcgUYg8x69_HA@mail.gmail.com>
	<CADJiDhsHMKLporKjYDeTyjbG8XuSHvgoPAEigjT9j9Y6-yO=_A@mail.gmail.com>
Message-ID: <524A6C0A.3060707@gmail.com>

On 01/10/13 16:26, Oren Ben-Kiki wrote:
> Perhaps if the type system was smart enough to provide a default 
> implementation of the Default trait for everything that had the ToStr 
> trait, and allowing overrides for specific types?
>
> I know that currently this sort of inference is not supported, but it 
> is intended that it would be possible in the future, right?
>
I think we should just replace ToStr and the #[deriving] with Default 
and a default method .to_str() on that trait, since ToStr's current 
design makes it very allocation-heavy (it has to allocate a new ~str for 
each subfield, rather than just appending to a common buffer as using 
the new format infrastructure would allow).


Also, not directly related to this exact discussion, but we could 
probably cope with having fewer format specifiers, e.g. format!("{:b}", 
true) could just be format!("{}", true), and similarly for `c`. (and 
even `s` itself!)


