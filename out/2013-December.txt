From loebel.marvin at gmail.com  Sun Dec  1 03:06:01 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Sun, 01 Dec 2013 12:06:01 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529ACC40.2020705@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
	<529ACC40.2020705@mozilla.com>
Message-ID: <529B1819.7040601@gmail.com>

On 12/01/2013 06:42 AM, Patrick Walton wrote:
> On 11/30/13 6:49 PM, Corey Richardson wrote:
>> I'll admit, I don't find the "confusing" argument very convincing. I
>> just think `box` looks better than `~`.
>
> I'm warming up to this idea -- `box 10` does make more sense than `new 
> 10`.
>
> Patrick
Thinking about it, `box` indeed seems like a good compromise to me:

- It is as short as `new`, and more verbose than `~`, which is good.
- It is a infrequently used word in source code.
- It is syntactically used like `new` of other languages, which makes it 
better recognizable as such.
- But it has a completely different semantic than, say, `C++`s `new`, 
justifying the different name.
- The box metaphor might also make documentation about custom smart 
pointers, and the deref operator easier.

From dteller at mozilla.com  Sun Dec  1 03:11:46 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Sun, 01 Dec 2013 12:11:46 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529ACC40.2020705@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
	<529ACC40.2020705@mozilla.com>
Message-ID: <529B1972.8050902@mozilla.com>

I like it.

Cheers,
 David

On 12/1/13 6:42 AM, Patrick Walton wrote:

> I'm warming up to this idea -- `box 10` does make more sense than `new 10`.
> 
> Patrick
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From asb at asbradbury.org  Sun Dec  1 03:19:46 2013
From: asb at asbradbury.org (Alex Bradbury)
Date: Sun, 1 Dec 2013 11:19:46 +0000
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAAvrL-=mU8n12Pbb9QppjJJtRkx=X52eaP5f7jkZ46fWpAJa_A@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
	<529ACC40.2020705@mozilla.com>
	<CAAvrL-=mU8n12Pbb9QppjJJtRkx=X52eaP5f7jkZ46fWpAJa_A@mail.gmail.com>
Message-ID: <CA+wH295_qCUes3xzZw4KnSCx-Tct=gL_JUk0CNia-oBbWQ=dJA@mail.gmail.com>

On 1 December 2013 06:01, Benjamin Striegel <ben.striegel at gmail.com> wrote:
> Eh, I'm as fine with `box` as I am with `new`. Does seem a bit like jargon,
> though. Though maybe it will herald a return to the days when we really
> played up the "shipping container" flavor. Crates and cargo, anyone? :)

I think it's reasonable to expect people new to Rust (being an
advanced systems-level language) to spend 15-20 minutes reading a
tutorial. Given that, I think the target for syntax or keywords is
that they're meaningful to people who have learnt the basic principles
of Rust. I think that 'box' is much more meaningful than 'new' in that
context, and rather more descriptive of the purpose.

Alex

From gaetan at xeberon.net  Sun Dec  1 03:43:29 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sun, 1 Dec 2013 12:43:29 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529B1972.8050902@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
	<529ACC40.2020705@mozilla.com> <529B1972.8050902@mozilla.com>
Message-ID: <CANK7tAFrnHraZL0yasUb1R=tCBfa3j3k+=xG1cx6FkY6Tivkgw@mail.gmail.com>

"box" as a keyword/reserved word is great, semantically speaking. And it is
logically linked to the box concept introduced by the language.
Le 1 d?c. 2013 12:11, "David Rajchenbach-Teller" <dteller at mozilla.com> a
?crit :

> I like it.
>
> Cheers,
>  David
>
> On 12/1/13 6:42 AM, Patrick Walton wrote:
>
> > I'm warming up to this idea -- `box 10` does make more sense than `new
> 10`.
> >
> > Patrick
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
> --
> David Rajchenbach-Teller, PhD
>  Performance Team, Mozilla
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/81bbb97a/attachment.html>

From denis.spir at gmail.com  Sun Dec  1 05:04:45 2013
From: denis.spir at gmail.com (spir)
Date: Sun, 01 Dec 2013 14:04:45 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A963E.5030101@babelmonkeys.de>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
Message-ID: <529B33ED.6080807@gmail.com>

On 12/01/2013 02:51 AM, Florian Zeitz wrote:
> If I may chime in here.
> I agree with Kevin that the different semantics of `new` are more likely
> to create confusion, than alleviate it.
>
> Personally I would suggest calling this operator `box`, since it "boxes"
> its argument into a newly allocated memory box.
>
> After all, these are different semantics from C++'s `new` (and also Go's
> `make` AFAICT), therefore, presuming that a sigil is not a sufficient
> indicator of a non-stack allocation, using an unprecedented keyword
> seems the way to go to me.

+++ to all 3 points

Denis

From denis.spir at gmail.com  Sun Dec  1 05:54:16 2013
From: denis.spir at gmail.com (spir)
Date: Sun, 01 Dec 2013 14:54:16 +0100
Subject: [rust-dev] do
In-Reply-To: <D9774DFE-77C7-49A7-BB7E-4C69E206235A@yahoo.com.au>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<D9774DFE-77C7-49A7-BB7E-4C69E206235A@yahoo.com.au>
Message-ID: <529B3F88.9010204@gmail.com>

On 12/01/2013 04:35 AM, Brendan Zabarauskas wrote:
> On 30 Nov 2013, at 5:34 pm, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> I find `do` syntax form is vital for DSL-ish code. Getting rid of it makes a lot of code look downright ugly. I'd rather it used a more Ruby-ish notation though, I find that putting the `do` far away from the `{ ... }` doesn't read well. `foo(....) do |...| { ... }` would have made more sense for me (think of `do` as a macro-ish binary operation injecting the proc into the function on the left). But the current form is acceptable
>
> This really is an important point. I would recommend folks look at Shoes (http://shoesrb.com/) for an example of how Ruby?s block syntax can help create beautiful APIs.

Ruby has no macros, has it?

Denis

From tkuehn at cmu.edu  Sun Dec  1 06:06:26 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Sun, 1 Dec 2013 09:06:26 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529B33ED.6080807@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
Message-ID: <CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>

On Sun, Dec 1, 2013 at 8:04 AM, spir <denis.spir at gmail.com> wrote:

> On 12/01/2013 02:51 AM, Florian Zeitz wrote:
>
>> If I may chime in here.
>> I agree with Kevin that the different semantics of `new` are more likely
>> to create confusion, than alleviate it.
>>
>> Personally I would suggest calling this operator `box`, since it "boxes"
>> its argument into a newly allocated memory box.
>>
>> After all, these are different semantics from C++'s `new` (and also Go's
>> `make` AFAICT), therefore, presuming that a sigil is not a sufficient
>> indicator of a non-stack allocation, using an unprecedented keyword
>> seems the way to go to me.
>>
>
> +++ to all 3 points
>
> Denis
>


I, too, am in favor of the `box` proposal. Short, intuitive, not
already commonly used. What's not to like?

Cheers,
Tim






_______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/9e92edcd/attachment-0001.html>

From tiffany at stormbit.net  Sun Dec  1 06:31:01 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Sun, 1 Dec 2013 09:31:01 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
Message-ID: <CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>

I agree with the `box` name, it's far less jarring than `new (1+1)`.


On Sun, Dec 1, 2013 at 9:06 AM, Tim Kuehn <tkuehn at cmu.edu> wrote:

> On Sun, Dec 1, 2013 at 8:04 AM, spir <denis.spir at gmail.com> wrote:
>
>> On 12/01/2013 02:51 AM, Florian Zeitz wrote:
>>
>>> If I may chime in here.
>>> I agree with Kevin that the different semantics of `new` are more likely
>>> to create confusion, than alleviate it.
>>>
>>> Personally I would suggest calling this operator `box`, since it "boxes"
>>> its argument into a newly allocated memory box.
>>>
>>> After all, these are different semantics from C++'s `new` (and also Go's
>>> `make` AFAICT), therefore, presuming that a sigil is not a sufficient
>>> indicator of a non-stack allocation, using an unprecedented keyword
>>> seems the way to go to me.
>>>
>>
>> +++ to all 3 points
>>
>> Denis
>>
>
>
> I, too, am in favor of the `box` proposal. Short, intuitive, not
> already commonly used. What's not to like?
>
> Cheers,
> Tim
>
>
>
>
>
>
> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/86680e3b/attachment.html>

From vadimcn at gmail.com  Sun Dec  1 07:42:35 2013
From: vadimcn at gmail.com (Vadim)
Date: Sun, 1 Dec 2013 09:42:35 -0600
Subject: [rust-dev] do
In-Reply-To: <3f2ecdb6-e0f5-43b0-85bf-81a1d4c2cb5f@email.android.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
	<CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
	<529A5D94.6090901@mozilla.com>
	<3f2ecdb6-e0f5-43b0-85bf-81a1d4c2cb5f@email.android.com>
Message-ID: <-8934270828636593044@unknownmsgid>

Once fn()'s should consume their environment, perhaps it should be simply
"self", where Self is non-copyable, so it gets moved out?


On Nov 30, 2013, at 4:21 PM, Patrick Walton <pwalton at mozilla.com> wrote:

It's also not clear to me how "&once fn" can decompose into a trait in the
future. The goal in the future is to make "fn()" a type of trait, to allow
for C++-like zero-indirection closures. The different types of functions
that we have today correspond to different "self" parameters: "|A|->B"
corresponds to "&mut self" and "proc()" corresponds to "~self". But I don't
see where "&once fn" fits in.

Perhaps the right thing is to gate "&once fn" on by-value anonymous
closures. I think once functions may be able to be made to work as function
trait bounds. But implementing "&once fn" right now seems to close off our
ability to have closures with the same efficiency as C++11 in the future,
unless there's something I'm missing.

Patrick

Patrick Walton <pcwalton at mozilla.com> wrote:
>
> On 11/30/13 12:04 PM, Oren Ben-Kiki wrote:
>
>> Just to mention in passing - there's a related principle that converting
>> a block to a closure shouldn't change its semantics. This obviously
>> doesn't fully work because of return/break/continue; that said, if a
>> block without such flow control constructs is wrapped into a closure,
>> you'd expect it to just work. It doesn't, because to work it would have
>> to be a once-called-stack-allocated lambda, which Rust doesn't have (I
>> don't get the reason for that either :-)
>
>
> If you decompose into a lambda plus the tupled set of upvars which it's
> moving out of, then this respects TCP.
>
> Patrick
>
> ------------------------------
>
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.

_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/1a0aa864/attachment.html>

From philippe.delrieu at free.fr  Sun Dec  1 09:28:52 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Sun, 01 Dec 2013 18:28:52 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <5298916A.8040105@gmail.com>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>	<529880BA.2090006@free.fr>	<52988F48.6010407@free.fr>
	<5298916A.8040105@gmail.com>
Message-ID: <529B71D4.9000603@free.fr>

I see the PR has been approved to I try to implements the method 'pub fn 
buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]'
and I have this error : "error: wrong number of lifetime parameters: 
expected 1 but found 0" and  indicate the Encoder type.

I have another question. I try to understand the modification on json.rs 
and function declaration has changed from :
impl serialize::Encoder for Encoder
to:
impl<'self> serialize::Encoder for Encoder<'self>
or
pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a>
instead of
pub fn new(wr: &mut io::Writer) -> Encoder

Could you explain me the difference if you don't mind.

Philippe

Le 29/11/2013 14:06, Huon Wilson a ?crit :
> Yes; wait for Erick to submit the PR that fixes extra::json to use 
> &mut Writer rather than @mut Writer, so that one can write something like
>
>   pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
> ~[u8]  {
>       let mut m = MemWriter::new();
>       { // I think this scope is necessary to restrict the borrows
>           let mut encoder = Encoder(&mut m as &mut Writer);
>           to_encode_object.encode(&mut encoder);
>       }
>       m.inner()
>   }
>
> One is then just moving the `~[u8]` around without copying all the 
> elements.
>
> Also, `str_encode` shouldn't need to do any additional copies, even 
> right now, since the `std::str::from_utf8_owned` function exists. 
> (`from_utf8` is bad with its implicit and normally unnecessary copy, 
> I've got https://github.com/mozilla/rust/pull/10701 open that removes 
> that function for that reason.)
>
>
> (Tangentially (and a genuine question), do we really need these 
> functions in extra::json (assuming this is part of the plan)? How 
> often does one need to encode to a buffer or string, rather than to 
> stdout, a file or network socket, which can be done by writing 
> directly to the corresponding writers.)
>
> Huon
>
>
> On 29/11/13 23:57, Philippe Delrieu wrote:
>> I try to implement the two methods and I have a problem with the copy 
>> of memory.
>> The first attempt :
>>
>>  pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
>> ~[u8]  {
>>    //Serialize the object in a string using a writer
>>     let m = @mut MemWriter::new();
>>     let mut encoder = Encoder(m as @mut Writer);
>>     to_encode_object.encode(&mut encoder);
>>     let buff:&~[u8] = m.inner_ref();
>>     (buff.clone())
>> }
>>
>> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>>     let buff:~[u8] = buffer_encode(to_encode_object);
>>     str::from_utf8(*buff)
>> }
>>
>> When I call str_encode I copy at least two times the content of the 
>> MemWriter buffer (one inside clone and one inside from_utf8).
>> If I implements str_encode like that
>>
>> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>>     let m = @mut MemWriter::new();
>>     let mut encoder = Encoder(m as @mut Writer);
>>     to_encode_object.encode(&mut encoder);
>>     let buff:&~[u8] = m.inner_ref();
>>     str::from_utf8(*buff)
>> }
>>
>> I'll do at least one copy (one less than the other impl) but the code 
>> is copied.
>>
>> Is there a better way to manage pointer of memory across function calls?
>>
>> Philippe
>>
>> Le 29/11/2013 12:55, Philippe Delrieu a ?crit :
>>> I made a remark about that on the GitHub pull request where the idea 
>>> was proposed. I'm agree with you. It's simplier  to return a str or 
>>> perhaps a [u8] if it's use in a stream purpose.
>>> I'm not very fan of creating a MemWriter and return it.
>>>
>>> I'll modify to add two functions:
>>> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str
>>> pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
>>> ~[u8]
>>>
>>> and remove the other.
>>>
>>> Any remaqs?
>>>
>>> Philippe
>>>
>>>
>>> Le 29/11/2013 10:44, Gaetan a ?crit :
>>>>
>>>> I would prefere this function returns a str.
>>>>
>>>> Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr 
>>>> <mailto:philippe.delrieu at free.fr>> a ?crit :
>>>>
>>>>     Thank you for the help. I've try this signature and I had an
>>>>     compile error. I thought it came from the signature but the
>>>>     problem when from the call.
>>>>     It works now.
>>>>
>>>>     For the return type @mut MemWriter I work on the json doc and
>>>>     some example of use. I can make the change. I didn't find the
>>>>     issue about it. Did you create it?
>>>>
>>>>     Philippe
>>>>
>>>>     Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>>>>>     Good afternoon Phillippe,
>>>>>
>>>>>     Here's how to do it, assuming you're using rust 0.8 and the
>>>>>     json library:
>>>>>
>>>>>     ```
>>>>>     #[feature(managed_boxes)];
>>>>>
>>>>>     extern mod extra;
>>>>>
>>>>>     use std::io::mem::MemWriter;
>>>>>     use extra::serialize::{Encoder, Encodable};
>>>>>     use extra::json;
>>>>>
>>>>>     pub fn memory_encode<
>>>>>         T: Encodable<json::Encoder>
>>>>>     >(to_encode_object: &T) -> @mut MemWriter {
>>>>>         //Serialize the object in a string using a writer
>>>>>         let m = @mut MemWriter::new();
>>>>>         let mut encoder = json::Encoder(m as @mut Writer);
>>>>>         to_encode_object.encode(&mut encoder);
>>>>>         m
>>>>>     }
>>>>>
>>>>>     fn main() {
>>>>>     }
>>>>>     ```
>>>>>
>>>>>     Regarding the trouble returning a `MemWriter` instead of a
>>>>>     `@mut MemWriter`, the easiest thing would be to fix library to
>>>>>     use `&mut ...` instead of `@mut ...`. I'll put in a PR to do that.
>>>>>
>>>>>
>>>>>
>>>>>     On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu
>>>>>     <philippe.delrieu at free.fr <mailto:philippe.delrieu at free.fr>>
>>>>>     wrote:
>>>>>
>>>>>         I try to develop a function that take a Encodable
>>>>>         parameter but I have the error wrong number of type
>>>>>         arguments: expected 1 but found 0
>>>>>
>>>>>         pub fn memory_encode(to_encode_object:
>>>>>         &serialize::Encodable) -> @mut MemWriter  {
>>>>>            //Serialize the object in a string using a writer
>>>>>             let m = @mut MemWriter::new();
>>>>>             let mut encoder = Encoder(m as @mut Writer);
>>>>>             to_encode_object.encode(&mut encoder);
>>>>>             m
>>>>>         }
>>>>>
>>>>>         The encodable trait is :
>>>>>         pub trait Encodable<S:Encoder> {
>>>>>             fn encode(&self, s: &mut S);
>>>>>         }
>>>>>
>>>>>         I try this definition
>>>>>         memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object:
>>>>>         &T) -> @mut MemWriter
>>>>>
>>>>>         But I can't use the method with a struct that implement
>>>>>         Encodable. The error : mismatched types: expected `&<V31>`
>>>>>         but found ..
>>>>>
>>>>>         I have another question :
>>>>>         I would like to return a MemWriter and not a @mut
>>>>>         MemWriter . I didn't find a way to convert the @mut to ~
>>>>>
>>>>>         Philippe Delrieu
>>>>>         _______________________________________________
>>>>>         Rust-dev mailing list
>>>>>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>>>         https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>
>>>>
>>>>     _______________________________________________
>>>>     Rust-dev mailing list
>>>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>>     https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/cfb9a7b2/attachment-0001.html>

From pcwalton at mozilla.com  Sun Dec  1 11:22:14 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 01 Dec 2013 11:22:14 -0800
Subject: [rust-dev] do
In-Reply-To: <-8934270828636593044@unknownmsgid>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
	<CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
	<529A5D94.6090901@mozilla.com>
	<3f2ecdb6-e0f5-43b0-85bf-81a1d4c2cb5f@email.android.com>
	<-8934270828636593044@unknownmsgid>
Message-ID: <529B8C66.1010804@mozilla.com>

On 12/1/13 7:42 AM, Vadim wrote:
> Once fn()'s should consume their environment, perhaps it should be
> simply "self", where Self is non-copyable, so it gets moved out?

Doesn't work unless we have unboxed closures, as you can't call a method 
that takes `self` on `&T`.

Patrick


From ptalbot at hyc.io  Sun Dec  1 12:14:22 2013
From: ptalbot at hyc.io (Pierre Talbot)
Date: Sun, 01 Dec 2013 21:14:22 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>
References: <529A3174.8060701@hyc.io>
	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>
Message-ID: <529B989E.9080509@hyc.io>

The for-loop and the nested function declaration are both interesting 
and I'll let you know which one I choose after further investigation in 
the Rust compiler.

If some of you have other ideas, please do not hesitate.

Best regards,
Pierre Talbot

On 11/30/2013 08:24 PM, Benjamin Striegel wrote:
> Currently our `for` loops are implemented strangely. In essence, right 
> now a `for` loop is just syntax sugar that gets expanded during the 
> parsing stage. This was easy to implement, but it means that our error 
> messages around `for` loops are strange and it limits our ability to 
> do more intelligent things, like so:
>
>     for i in [1,2,3] {  // currently we can't do this, you need to 
> write out `[1,2,3].iter()`
>
> If you could implement `for` loops in the "proper" way, it would be a 
> great boon to us. However, I'm not the one who really knows exactly 
> what the "proper" way is. :) And I wasn't able to find an issue in the 
> bug tracker for this with any details. Perhaps Daniel Micay (strcat) 
> could elaborate.
>
>
> On Sat, Nov 30, 2013 at 1:41 PM, Pierre Talbot <ptalbot at hyc.io 
> <mailto:ptalbot at hyc.io>> wrote:
>
>     Hello folks,
>
>     I'm a French student finishing his study this year and a teacher
>     gave us a project to finish by the end of the year which is to
>     modify (or add) a small feature to an existing interpreter (or
>     compiler, language,...) such as a primitive or a control structure.
>     I'm pretty new to Rust and I wonder if you have some ideas, some
>     works that could possibly be useful to Rust, even if extremely
>     small. My objective is to get into Rust with this homework and
>     then work further on Rust later.
>     I can guess how much is hard to understand a compiler and start
>     working on it, and that's basically why I'm asking you for an
>     idea. I already worked on open-source projects (mainly in C++) so
>     I don't have much "outside lessons" to take (such as learning git).
>
>     Do you have suggestions that could fit well for this kind of project?
>
>     Best regards,
>     Pierre Talbot.
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From hatahet at gmail.com  Sun Dec  1 13:02:43 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sun, 1 Dec 2013 13:02:43 -0800
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529B989E.9080509@hyc.io>
References: <529A3174.8060701@hyc.io>
	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>
	<529B989E.9080509@hyc.io>
Message-ID: <CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>

Isn't there a possibility that vector syntax is going to change at some
point?

--
Ziad


On Sun, Dec 1, 2013 at 12:14 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> The for-loop and the nested function declaration are both interesting and
> I'll let you know which one I choose after further investigation in the
> Rust compiler.
>
> If some of you have other ideas, please do not hesitate.
>
> Best regards,
> Pierre Talbot
>
>
> On 11/30/2013 08:24 PM, Benjamin Striegel wrote:
>
>> Currently our `for` loops are implemented strangely. In essence, right
>> now a `for` loop is just syntax sugar that gets expanded during the parsing
>> stage. This was easy to implement, but it means that our error messages
>> around `for` loops are strange and it limits our ability to do more
>> intelligent things, like so:
>>
>>     for i in [1,2,3] {  // currently we can't do this, you need to write
>> out `[1,2,3].iter()`
>>
>> If you could implement `for` loops in the "proper" way, it would be a
>> great boon to us. However, I'm not the one who really knows exactly what
>> the "proper" way is. :) And I wasn't able to find an issue in the bug
>> tracker for this with any details. Perhaps Daniel Micay (strcat) could
>> elaborate.
>>
>>
>> On Sat, Nov 30, 2013 at 1:41 PM, Pierre Talbot <ptalbot at hyc.io <mailto:
>> ptalbot at hyc.io>> wrote:
>>
>>     Hello folks,
>>
>>     I'm a French student finishing his study this year and a teacher
>>     gave us a project to finish by the end of the year which is to
>>     modify (or add) a small feature to an existing interpreter (or
>>     compiler, language,...) such as a primitive or a control structure.
>>     I'm pretty new to Rust and I wonder if you have some ideas, some
>>     works that could possibly be useful to Rust, even if extremely
>>     small. My objective is to get into Rust with this homework and
>>     then work further on Rust later.
>>     I can guess how much is hard to understand a compiler and start
>>     working on it, and that's basically why I'm asking you for an
>>     idea. I already worked on open-source projects (mainly in C++) so
>>     I don't have much "outside lessons" to take (such as learning git).
>>
>>     Do you have suggestions that could fit well for this kind of project?
>>
>>     Best regards,
>>     Pierre Talbot.
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/5dfbf791/attachment.html>

From jurily at gmail.com  Sun Dec  1 13:23:52 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sun, 01 Dec 2013 22:23:52 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>
References: <529A3174.8060701@hyc.io>	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>	<529B989E.9080509@hyc.io>
	<CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>
Message-ID: <529BA8E8.2060503@gmail.com>

On 12/01/2013 10:02 PM, Ziad Hatahet wrote:
> Isn't there a possibility that vector syntax is going to change at some
> point?

I believe the plan is to turn [] into a generic container syntax, and 
expose Vec<T> as the vector type. No idea where I read that though.

From ptalbot at hyc.io  Sun Dec  1 13:33:34 2013
From: ptalbot at hyc.io (Pierre Talbot)
Date: Sun, 01 Dec 2013 22:33:34 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529BA8E8.2060503@gmail.com>
References: <529A3174.8060701@hyc.io>	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>	<529B989E.9080509@hyc.io>	<CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>
	<529BA8E8.2060503@gmail.com>
Message-ID: <529BAB2E.6010603@hyc.io>

This doesn't seem to be a small project :-) By the way, I'm not sure if 
this is a good idea in Rust, but we might provide two free functions 
begin and end taking sequence and returning iterators. Anything that can 
be understood in term of sequence would just need to have an overload of 
these functions and the for-based loop transformation would be easy to 
change. This idea just come from my experience in C++ and I'd be happy 
to know why it wouldn't apply in Rust.

On 12/01/2013 10:23 PM, Gy?rgy Andrasek wrote:
> On 12/01/2013 10:02 PM, Ziad Hatahet wrote:
>> Isn't there a possibility that vector syntax is going to change at some
>> point?
>
> I believe the plan is to turn [] into a generic container syntax, and 
> expose Vec<T> as the vector type. No idea where I read that though.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Sun Dec  1 13:43:15 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 1 Dec 2013 16:43:15 -0500
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529BAB2E.6010603@hyc.io>
References: <529A3174.8060701@hyc.io>
	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>
	<529B989E.9080509@hyc.io>
	<CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>
	<529BA8E8.2060503@gmail.com> <529BAB2E.6010603@hyc.io>
Message-ID: <CA+DvKQKwoTKa=fijLTmtKL-Vk-pZOo1sJ+gBJDWevCEKEqX10w@mail.gmail.com>

On Sun, Dec 1, 2013 at 4:33 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
> This doesn't seem to be a small project :-) By the way, I'm not sure if this
> is a good idea in Rust, but we might provide two free functions begin and
> end taking sequence and returning iterators. Anything that can be understood
> in term of sequence would just need to have an overload of these functions
> and the for-based loop transformation would be easy to change. This idea
> just come from my experience in C++ and I'd be happy to know why it wouldn't
> apply in Rust.

I don't understand why this would be a good thing. Ranges are a more
modern implementation of iterators and are much more easily composed.
Ranges are also trivially memory safe, and I doubt that split
current/end iterators can provide memory safety with only references.

From vadimcn at gmail.com  Sun Dec  1 14:43:00 2013
From: vadimcn at gmail.com (Vadim)
Date: Sun, 1 Dec 2013 16:43:00 -0600
Subject: [rust-dev] do
In-Reply-To: <529B8C66.1010804@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
	<CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
	<529A5D94.6090901@mozilla.com>
	<3f2ecdb6-e0f5-43b0-85bf-81a1d4c2cb5f@email.android.com>
	<-8934270828636593044@unknownmsgid> <529B8C66.1010804@mozilla.com>
Message-ID: <5914291575612352126@unknownmsgid>

Not sure what you mean by "`self` on `&T`".   I thought traits can
take self by-value?


On Dec 1, 2013, at 1:22 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 12/1/13 7:42 AM, Vadim wrote:
>> Once fn()'s should consume their environment, perhaps it should be
>> simply "self", where Self is non-copyable, so it gets moved out?
>
> Doesn't work unless we have unboxed closures, as you can't call a method that takes `self` on `&T`.
>
> Patrick
>

From ecreed at cs.washington.edu  Mon Dec  2 00:43:52 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 00:43:52 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
Message-ID: <CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>

I think the 'new(place) expr' or 'box(place) expr' is pretty confusing
syntax. To me, it's not at all clear that "new(varA) varB" means "eval varB
and put it into varA" instead of "eval varA and put it into varB".
I'd much prefer syntax that makes it very clear which is the expression and
which is the place. Personally, I like ~ so I'd like "~expr in place", but
if people absolutely insist on scrapping ~ then I'd suggest "put expr in
place".
In either case, I think keeping ~ as sugar for allocating on the exchange
heap would be nice (i.e. "~expr" is sugar for "~expr in Unique" or "put
expr in Unique").
I guess we could use "new" or "box" instead of "put", but I like "put" over
either.



On Sun, Dec 1, 2013 at 6:31 AM, Tiffany Bennett <tiffany at stormbit.net>wrote:

> I agree with the `box` name, it's far less jarring than `new (1+1)`.
>
>
> On Sun, Dec 1, 2013 at 9:06 AM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>
>> On Sun, Dec 1, 2013 at 8:04 AM, spir <denis.spir at gmail.com> wrote:
>>
>>>  On 12/01/2013 02:51 AM, Florian Zeitz wrote:
>>>
>>>> If I may chime in here.
>>>> I agree with Kevin that the different semantics of `new` are more likely
>>>> to create confusion, than alleviate it.
>>>>
>>>> Personally I would suggest calling this operator `box`, since it "boxes"
>>>> its argument into a newly allocated memory box.
>>>>
>>>> After all, these are different semantics from C++'s `new` (and also Go's
>>>> `make` AFAICT), therefore, presuming that a sigil is not a sufficient
>>>> indicator of a non-stack allocation, using an unprecedented keyword
>>>> seems the way to go to me.
>>>>
>>>
>>> +++ to all 3 points
>>>
>>> Denis
>>>
>>
>>
>> I, too, am in favor of the `box` proposal. Short, intuitive, not
>> already commonly used. What's not to like?
>>
>> Cheers,
>> Tim
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/306287fe/attachment-0001.html>

From hatahet at gmail.com  Mon Dec  2 00:56:48 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Mon, 2 Dec 2013 00:56:48 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
Message-ID: <CAN1rdEy+grYEapM4D2mbNt3G2vqfquNoojMQ1YuFePZwVfbwPA@mail.gmail.com>

On Mon, Dec 2, 2013 at 12:43 AM, Eric Reed <ecreed at cs.washington.edu> wrote:

> In either case, I think keeping ~ as sugar for allocating on the exchange
> heap would be nice (i.e. "~expr" is sugar for "~expr in Unique" or "put
> expr in Unique").
>

`box expr in place` reads nicely too. I don't know about any ambiguity in
the syntax though.

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/ed5b2585/attachment.html>

From asb at asbradbury.org  Mon Dec  2 01:00:35 2013
From: asb at asbradbury.org (Alex Bradbury)
Date: Mon, 2 Dec 2013 09:00:35 +0000
Subject: [rust-dev] do
In-Reply-To: <CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
	<CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>
Message-ID: <CA+wH294REuC7gu7Jmd4XyGVAFkXBCuLdhPQmZJtx=sq3Yjebug@mail.gmail.com>

On 1 December 2013 03:54, Daniel Micay <danielmicay at gmail.com> wrote:
> I don't understand the point of `do` beyond making zero-parameter
> closures look a bit better. If it doesn't even do that, why bother? If
> an editor isn't indenting it properly, that's an editor issue. As far
> as I can tell, the vim indent file now handles it fine.

I agree, I feel do should be considered for removal - I feel the
amount of sugar it provides is minimal yet it complicates the language
unnecessarily. Supposing that Rust did not have the `do` syntax
already, I tend to think there would be resistance to adding it for
these reasons. Is there currently an issue open regarding the future
of `do`?

Alex

From gaetan at xeberon.net  Mon Dec  2 01:16:08 2013
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 2 Dec 2013 10:16:08 +0100
Subject: [rust-dev] do
In-Reply-To: <CA+wH294REuC7gu7Jmd4XyGVAFkXBCuLdhPQmZJtx=sq3Yjebug@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
	<CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>
	<CA+wH294REuC7gu7Jmd4XyGVAFkXBCuLdhPQmZJtx=sq3Yjebug@mail.gmail.com>
Message-ID: <CANK7tAF2od1aGxtR=qAP=UKUea2w0i1GYWrXoN3uk2hhri2tGw@mail.gmail.com>

if "do" makes the code more readable or more "beautiful", I higly recommend
keeping this sugar syntax. If there are corner cases where do doesn't do
the job, the developer should not use it in these cases.

It's still the same debat, when GIMP had this ugly multi panels system,
developers was saying it is a window manager issue to handle them
correctly. Yet, the GIMP software was a nightmare to use on almost
everybody's desktop. Now they solved with a single window application, it
is much more acceptable.

It will be the same here. If you rely on special feature of the editor to
indent properly. if is was only curly brace, most editor would do
indentation properly, but here you have || and other exotic syntax most
editor doesn't understand until a proper extension is written (which can
take year for some editors).

I personnally will always find much more readable (and maintainable):

    do function { someotherFunction() };

than

    function(|| someotherFunction());


-----
Gaetan



2013/12/2 Alex Bradbury <asb at asbradbury.org>

> On 1 December 2013 03:54, Daniel Micay <danielmicay at gmail.com> wrote:
> > I don't understand the point of `do` beyond making zero-parameter
> > closures look a bit better. If it doesn't even do that, why bother? If
> > an editor isn't indenting it properly, that's an editor issue. As far
> > as I can tell, the vim indent file now handles it fine.
>
> I agree, I feel do should be considered for removal - I feel the
> amount of sugar it provides is minimal yet it complicates the language
> unnecessarily. Supposing that Rust did not have the `do` syntax
> already, I tend to think there would be resistance to adding it for
> these reasons. Is there currently an issue open regarding the future
> of `do`?
>
> Alex
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/db904bdc/attachment.html>

From ecreed at cs.washington.edu  Mon Dec  2 01:25:32 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 01:25:32 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAN1rdEy+grYEapM4D2mbNt3G2vqfquNoojMQ1YuFePZwVfbwPA@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<CAN1rdEy+grYEapM4D2mbNt3G2vqfquNoojMQ1YuFePZwVfbwPA@mail.gmail.com>
Message-ID: <CANbMr6EoTMfeYs9fR=-crorkY9u06eDXZQXpFp16WpWCU2DYkg@mail.gmail.com>

I don't think it introduces any ambiguity. The optional "in" is similar to
the optional "else" in "if".
I'm pretty sure this grammar would suffice:

alloc_expr : "~" expr in_tail ? ;
in_tail : "in" expr ;

The expr of in_tail would need to be considered a 'place' (some sort of
trait I assume) by the typechecker.
Ending in_tail with an expr shouldn't be a problem (lambda_expr does it).
The parser can unambiguously tell if there is an in_tail present by simply
checking for the "in" keyword.


On Mon, Dec 2, 2013 at 12:56 AM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Mon, Dec 2, 2013 at 12:43 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> In either case, I think keeping ~ as sugar for allocating on the exchange
>> heap would be nice (i.e. "~expr" is sugar for "~expr in Unique" or "put
>> expr in Unique").
>>
>
> `box expr in place` reads nicely too. I don't know about any ambiguity in
> the syntax though.
>
> --
> Ziad
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/2817e084/attachment.html>

From com.liigo at gmail.com  Mon Dec  2 02:06:07 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Mon, 2 Dec 2013 18:06:07 +0800
Subject: [rust-dev] This Week in Rust
In-Reply-To: <CA++BO6RApVJfB6Md12obxnyQSAbOnz_P4hdUKuxGF06MymuDCw@mail.gmail.com>
References: <CA++BO6RApVJfB6Md12obxnyQSAbOnz_P4hdUKuxGF06MymuDCw@mail.gmail.com>
Message-ID: <CAH8Jz7gS7gZvhGkD2Yfpe0=AbAyVAWQ7_7RHoLbyU0x+Yw7ByQ@mail.gmail.com>

great work


2013/12/1 Corey Richardson <corey at octayn.net>

> Welcome to another issue of *This Week in Rust*, a weekly newsletter
> summarizing Rust's progress and community activity. As always, if you have
> something you'd like to be featured, just [send me an
> email](mailto:corey at octayn.net?subject=This Week in Rust Suggestion).
>
> Last week was very slow, but this week more than makes up for it I think!
> Static linking landed, and there's been some nice cleanup of error messages
> and various APIs.
>
> # What's cooking on master?
>
> 59 PRs were merged this week.
>
> ## Breaking Changes
>
> - Names of methods creating iterators have [changed
>   drastically](https://github.com/mozilla/rust/pull/10622) to remove the
>   `_iter` suffix. This reflects that iterators are a primary focus of APIs.
>   The PR description has all of the changes summarized.
> - We now have [static linking
>   support](https://github.com/mozilla/rust/pull/10528)! It does, however,
>   involve some changes with how the `link` attribute works. The error
> messages
>   should guide you to the fixes.
> - In preparation for the placement new changes, the `Path` constructor has
>   been [renamed from `new` to
>   `init`](https://github.com/mozilla/rust/pull/10697),.
> - Some overly-permissive borrow checking for `&mut &mut` [has been
>   fixed](https://github.com/mozilla/rust/pull/10519). This is fairly
> obscure,
>   most code shouldn't have hit it.
> - The parser is [more strict](https://github.com/mozilla/rust/pull/10642)
>   about what it accepts as a doc comment. Now, only `///` and `/**`  are
>   counted as introducing doc comments (previously, `////` and `/***` would
>   also introduce a doc comment).
> - `std::{uint, int}::{min, max}` [have been
>   removed](https://github.com/mozilla/rust/pull/10719). They were
> identical to
>   the functions in `std::cmp`, so use those instead.
> - `extra::json` [has been rid of @
>   boxes](https://github.com/mozilla/rust/pull/10727), and now uses
> idiomatic
>   constructor names.
> - The `type_id` intrinsic [now uses a language item as its return
>   value](https://github.com/mozilla/rust/pull/10722).
> - Some [cleanup](https://github.com/mozilla/rust/pull/10662) has been
> done to
>   `std::rt::thread`, which is an interface to native threads (rather than
>   tasks).
> - `do` blocks are [no longer
>   allowed](https://github.com/mozilla/rust/pull/10581) in non-`proc`
> contexts.
>   This means that `do` can not be used with a function whose last argument
> is
>   not a `proc`. A fairly large [thread on the mailing
>   list](
> https://mail.mozilla.org/pipermail/rust-dev/2013-November/006999.html)
>   is ongoing about this change.
> - `LittleLock` now [uses RAII](https://github.com/mozilla/rust/pull/10660
> ).
> - C-like enums are [now represented as an
>   integer](https://github.com/mozilla/rust/pull/10652) rather than a
> struct,
>   at the LLVM level. This affects ABI.
> - Linked failure [has been
>   removed](https://github.com/mozilla/rust/pull/10603) from the runtime.
> - `extra::term` [no longer uses `@mut
>   Writer`](https://github.com/mozilla/rust/pull/10637), instead taking the
>   writer to use by value.
>
> ## Other changes
>
> - `RefCell<T>`, previously known as `Mut<T>`, [has finally
>   landed](https://github.com/mozilla/rust/pull/10514), for all your
> dynamic
>   borrow checking needs.
> - A lint for unknown attributes [has finally been
>   added](https://github.com/mozilla/rust/pull/10316). The compiler will
> now
>   warn when it sees an attribute it doesn't recognize.
> - A lock-free [Chase-Lev
>   deque](
> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf
> )
>   has [been added to the runtime](
> https://github.com/mozilla/rust/pull/10678).
> - The shootout-spectralnorm benchmark [has been
>   resurrected](https://github.com/mozilla/rust/pull/10704).
> - Unknown feature gates [are now
>   linted](https://github.com/mozilla/rust/pull/10680), rather than being a
>   hard failure.
> - The AST is [now frozen](https://github.com/mozilla/rust/pull/10693)!
> - `GenericPort` [now has an
>   iterator](https://github.com/mozilla/rust/pull/10688) over the messages
> it
>   receives.
> - `NodeId`, `CrateNum`, `Name`, and `Mrk` (types in libsyntax) [have been
>   shrunk to 32 bits](https://github.com/mozilla/rust/pull/10670).
> - The restriction on macros expanding to a single item [has been
>   lifted](https://github.com/mozilla/rust/pull/10649). This obviates the
> need
>   for macros hackily expanding to a module containing the desired items. Do
>   note that this only works when the macro is in "item position", or where
> an
>   item is expected. There is an
>   [issue](https://github.com/mozilla/rust/issues/10681) open for lifting
> this
>   restriction.
> - A `thread_local` attribute [has been
>   added](https://github.com/mozilla/rust/pull/10312), which exposes a
>   platform's native TLS, a la C11/C++11 `thread_local`.
> - Cross compilation to win64 (via mingw-w64) [is now
>   supported](https://github.com/mozilla/rust/pull/10578). There were also
> a
>   [bunch of fixes](https://github.com/mozilla/rust/pull/10631) on real
> win64.
> - The parser gives a [better error
>   message](https://github.com/mozilla/rust/pull/10641) when it encounters
> an
>   unclosed delimiter it didn't expect.
> - There is a [better error
>   message](https://github.com/mozilla/rust/pull/10475) when a module name
> is
>   used as a type (the motivating example being `impl SomeTrait for
> some_module`).
> - JSON decoding [now gives better
>   errors](https://github.com/mozilla/rust/pull/10625).
> - Linker optimizations are [now
>   used](https://github.com/mozilla/rust/pull/10620) on Linux.
>
> ## New contributors
>
> Our first-time contributors this week are:
>
> - Andreas Ots
> - Eric Biggers
> - Jannis Harder
> - Kiet Tran
>
> # Weekly Meeting
>
> The [weekly
> meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-26)
> discussed bootstrap times, the `thread_local` PR, mutexes, and the GC. In
> particular, it was decided that we should have nightlies.
>
> # This Week in Servo
>
> Servo is a web browser engine written in Rust and is one of the primary
> test
> cases for the Rust language.
>
> This was a short week due to the US Thanksgiving holiday, but there were
> still
> 17 landed PRs this week.
>
> ## Notable additions
> - Hyunjune Kim and Sammy Kim landed some border style extensions in
>   [#1276](http://github.com/mozilla/servo/pull/1322).
> - Youngmin Yoo, Seonghyun Kim, and Jaemin Moon landed overflow:hidden in
>   [#1298](http://github.com/mozilla/servo/pull/1298).
> - Isabelle Carter landed changing the unrendered portion of content to use
> the
>   doc's background color in [#1210](
> http://github.com/mozilla/servo/pull/1210).
> - Patrick Walton has been experimenting with some very promising parallel
>   layout work, which he described in a
>   [message](
> https://groups.google.com/forum/#!topic/mozilla.dev.servo/1nKmBvFewIs)
>   to the mailing list.
>
> ## Meetings
>
> This week's [meeting](
> https://github.com/mozilla/servo/wiki/Meeting-2013-11-25)
> covered the poor situation with Nvidia support on Linux, fleshed out the
> string
> interning plan during CSS selector parsing/matching, and went into some
> Servo
> and Rust-related build issues.
>
> # Announcements etc
>
> Do note that all the links are pulled directly from the
> [subreddit](https://reddit.com/r/rust).
>
> - [Matrix Multiply Performance in
> Rust](
> http://www.reddit.com/r/rust/comments/1rf8rz/matrix_multiply_performance_in_rust/
> )
> - [nrays](https://github.com/sebcrozet/nrays) - a 3d/4d raytracer
> - [SprocketNES: Practical Systems Programming in
>   Rust](
> https://air.mozilla.org/sprocketnes-practical-systems-programming-in-rust/
> ).
>   Contrary to the title, this is actually a recording of the presentations
> at
>   the Bay Area meetup.
> - [uutils](https://github.com/uutils/coreutils) - an attempt at writing
>   universal (as in cross-platform) CLI utils in Rust
> - [lbac](https://github.com/cmr/lets-build-a-compiler) - a Rust port of
> Jack
>   Crenshaw's "Let's Build a Compiler"
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/8d6bfe32/attachment-0001.html>

From jeti789 at web.de  Mon Dec  2 02:12:39 2013
From: jeti789 at web.de (jeti789 at web.de)
Date: Mon, 2 Dec 2013 11:12:39 +0100 (CET)
Subject: [rust-dev] Can traits define instance vars?
Message-ID: <trinity-9224a22a-5a53-4521-ada7-c71e98bce76b-1385979158958@3capp-webde-bs23>

An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/26a40034/attachment.html>

From ecreed at cs.washington.edu  Mon Dec  2 02:31:55 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 02:31:55 -0800
Subject: [rust-dev] Can traits define instance vars?
In-Reply-To: <trinity-9224a22a-5a53-4521-ada7-c71e98bce76b-1385979158958@3capp-webde-bs23>
References: <trinity-9224a22a-5a53-4521-ada7-c71e98bce76b-1385979158958@3capp-webde-bs23>
Message-ID: <CANbMr6G-g7_+w_V8myhfW=Z8oZj3oqKO8g7d1YS55M0+qecmMA@mail.gmail.com>

Hi Oliver,

Glad you're liking Rust so far :)

Currently traits can only have methods (functions that have a self
parameter) and associated functions (functions without a self parameter).
There's a proposal to add inheritance on structs to Rust, which would allow
a trait to extend a struct and gain access to its fields.
This (very) long mailing list
thread<https://mail.mozilla.org/pipermail/rust-dev/2013-November/006465.html>is
the most recent discussion I'm aware of. There are a couple ideas in
there about how to get similar behavior using just existing Rust constructs
(I'm still biased towards the solution I gave in there).

I'm not aware of any plans for a rust-users forum. Maybe spinning a
rust-users mailing list off from rust-dev would make sense? We already did
a similar thing with our IRC channels.

Eric




On Mon, Dec 2, 2013 at 2:12 AM, <jeti789 at web.de> wrote:

> Hello,
>
> I lately had a look at Rust and really liked it in many ways. Rust has
> really everything I'm missing in Go ;-). There is something about traits I
> would like to ask I can't see from the manual. Question is whether you
> define instance variables in traits or abstract variables like Ceylon and
> Kotlin have them. Abstract traits vars in Kotlin look like this (sample
> code taken from here:
> http://blog.jetbrains.com/kotlin/2011/08/multiple-inheritance-part-2-possible-directions
> ):
>
>  trait Trait {
>   val property : Int // abstract
>   fun foo() {
>     print(property)
>   }
> }
> class C() : Trait {
>   override val property : Int = 239
> }
>
> Can something like this be done for traits in Rust as well?
>
> Then I would like to ask whether you are planning to have some Rust forum
> for users. The question I was asking in this mail on rust-dev really
> doesn't belong into the dev mailing list. So something like a google
> Rust-users newsgroup would be a good thing to have. I know several people
> that are interested in Rush. Think it would give Rust a little push if a
> Rust-user forum would exist.
>
> Regards, Oliver
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/ea64e5ab/attachment.html>

From kevin at sb.org  Mon Dec  2 02:32:50 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 2 Dec 2013 02:32:50 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
Message-ID: <A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>

I think `box expr in place` is unnecessarily verbose. I also don't think `box(place) expr` will be confusing in practice, because it will presumably look something like `box(Gc) expr`, which should be pretty obvious that Gc is how it's being boxed, not what's being boxed.

-Kevin

> On Dec 2, 2013, at 12:43 AM, Eric Reed <ecreed at cs.washington.edu> wrote:
> 
> I think the 'new(place) expr' or 'box(place) expr' is pretty confusing syntax. To me, it's not at all clear that "new(varA) varB" means "eval varB and put it into varA" instead of "eval varA and put it into varB".
> I'd much prefer syntax that makes it very clear which is the expression and which is the place. Personally, I like ~ so I'd like "~expr in place", but if people absolutely insist on scrapping ~ then I'd suggest "put expr in place".
> In either case, I think keeping ~ as sugar for allocating on the exchange heap would be nice (i.e. "~expr" is sugar for "~expr in Unique" or "put expr in Unique").
> I guess we could use "new" or "box" instead of "put", but I like "put" over either.
> 
> 
> 
>> On Sun, Dec 1, 2013 at 6:31 AM, Tiffany Bennett <tiffany at stormbit.net> wrote:
>> I agree with the `box` name, it's far less jarring than `new (1+1)`.
>> 
>> 
>>> On Sun, Dec 1, 2013 at 9:06 AM, Tim Kuehn <tkuehn at cmu.edu> wrote:
>>>> On Sun, Dec 1, 2013 at 8:04 AM, spir <denis.spir at gmail.com> wrote:
>>> 
>>>>> On 12/01/2013 02:51 AM, Florian Zeitz wrote:
>>>>> If I may chime in here.
>>>>> I agree with Kevin that the different semantics of `new` are more likely
>>>>> to create confusion, than alleviate it.
>>>>> 
>>>>> Personally I would suggest calling this operator `box`, since it "boxes"
>>>>> its argument into a newly allocated memory box.
>>>>> 
>>>>> After all, these are different semantics from C++'s `new` (and also Go's
>>>>> `make` AFAICT), therefore, presuming that a sigil is not a sufficient
>>>>> indicator of a non-stack allocation, using an unprecedented keyword
>>>>> seems the way to go to me.
>>>> 
>>>> +++ to all 3 points
>>>> 
>>>> Denis
>>>  
>>>  
>>> I, too, am in favor of the `box` proposal. Short, intuitive, not
>>> already commonly used. What's not to like?
>>>  
>>> Cheers,
>>> Tim 
>>>  
>>> 
>>> 
>>> 
>>>>  
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> 
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/c2f719e4/attachment.html>

From kevin at sb.org  Mon Dec  2 02:57:02 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 2 Dec 2013 02:57:02 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
Message-ID: <B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>

With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`

-Kevin Ballard

From ecreed at cs.washington.edu  Mon Dec  2 03:09:42 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 03:09:42 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
Message-ID: <CANbMr6EBWG2Mhv1wYfWNtMzYSxZMmROXraNBCsO+Ey0Med=VEA@mail.gmail.com>

This is my new favorite idea, especially expr at place. It's concise. It reads
"expr at place", which is exactly what it does. It goes along with Rust's
putting the type after the value. "expr in place" could be good too.


On Mon, Dec 2, 2013 at 2:57 AM, Kevin Ballard <kevin at sb.org> wrote:

> With @ going away another possibility is to leave ~ as the normal
> allocation operator and to use @ as the placement operator. So ~expr stays
> the same and placement looks either like `@place expr` or `expr at place`
>
> -Kevin Ballard
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/23e68e2b/attachment-0001.html>

From denis.spir at gmail.com  Mon Dec  2 04:57:56 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 02 Dec 2013 13:57:56 +0100
Subject: [rust-dev] Can traits define instance vars?
In-Reply-To: <trinity-9224a22a-5a53-4521-ada7-c71e98bce76b-1385979158958@3capp-webde-bs23>
References: <trinity-9224a22a-5a53-4521-ada7-c71e98bce76b-1385979158958@3capp-webde-bs23>
Message-ID: <529C83D4.4000200@gmail.com>

On 12/02/2013 11:12 AM, jeti789 at web.de wrote:
> Hello,
> I lately had a look at Rust and really liked it in many ways. Rust has really
> everything I'm missing in Go ;-). There is something about traits I would like
> to ask I can't see from the manual. Question is whether you define instance
> variables in traits or abstract variables like Ceylon and Kotlin have them.
> Abstract traits vars in Kotlin look like this (sample code taken from here:
> http://blog.jetbrains.com/kotlin/2011/08/multiple-inheritance-part-2-possible-directions):
> trait Trait {
>    val property : Int // abstract
>    fun foo() {
>      print(property)
>    }
> }
> class C() : Trait {
>    override val property : Int = 239
> }
> Can something like this be done for traits in Rust as well?
> Then I would like to ask whether you are planning to have some Rust forum for
> users. The question I was asking in this mail on rust-dev really doesn't belong
> into the dev mailing list. So something like a google Rust-users newsgroup would
> be a good thing to have. I know several people that are interested in Rush.
> Think it would give Rust a little push if a Rust-user forum would exist.
> Regards, Oliver

I would love it. Of the 2 cases of custom traits I have defined do far in Rust, 
one is only about 3 instance vars (thus ends up empty), the other about 1 vars 
and 1 method (thus holds only the latter). I find traits weird without vars, and 
annoying since the compiler does not know that the conforming types _do_ have 
such vars (thus one is forced to down-cast for no other reason that vars are 
absent from the trait def, or do i miss a point?). This, in addition to control 
of actual conformity of types to declared traits.

Denis

From denis.spir at gmail.com  Mon Dec  2 05:01:41 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 02 Dec 2013 14:01:41 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>
	<529B33ED.6080807@gmail.com>	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
Message-ID: <529C84B5.20405@gmail.com>

On 12/02/2013 09:43 AM, Eric Reed wrote:
> I think the 'new(place) expr' or 'box(place) expr' is pretty confusing
> syntax. To me, it's not at all clear that "new(varA) varB" means "eval varB
> and put it into varA" instead of "eval varA and put it into varB".
> I'd much prefer syntax that makes it very clear which is the expression and
> which is the place. Personally, I like ~ so I'd like "~expr in place", but
> if people absolutely insist on scrapping ~ then I'd suggest "put expr in
> place".
> In either case, I think keeping ~ as sugar for allocating on the exchange
> heap would be nice (i.e. "~expr" is sugar for "~expr in Unique" or "put
> expr in Unique").
> I guess we could use "new" or "box" instead of "put", but I like "put" over
> either.

What about:
	box(place, expr)
	box(expr, place)	# better for me
	box expr in/to place	# pure syntactic magic
? The latter may seem weird, but anyway box or new or whatever aren't functions 
in the ordinary sense.

Denis

From denis.spir at gmail.com  Mon Dec  2 05:07:13 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 02 Dec 2013 14:07:13 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>
	<529B33ED.6080807@gmail.com>	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
Message-ID: <529C8601.1060004@gmail.com>

On 12/02/2013 11:57 AM, Kevin Ballard wrote:
> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`

I like that, with expr at place. Does this give:
	let foo = ~ bar;
	let placed_foo = bar @ place;
?

Yet another solution, just for fun, using the fact that pointers are supposed to 
"point to":

	let foo = -> bar;
	let placed_foo = bar -> place;

Denis

From pnkfelix at mozilla.com  Mon Dec  2 05:49:55 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Mon, 02 Dec 2013 14:49:55 +0100
Subject: [rust-dev] Error casting to trait: "value may contain borrowed
 pointers"
In-Reply-To: <CAPzKZDw5YXTxTYkJNvVHrdb4norENAEObPBxtdOx=N8MCw+HKA@mail.gmail.com>
References: <CAPzKZDw5YXTxTYkJNvVHrdb4norENAEObPBxtdOx=N8MCw+HKA@mail.gmail.com>
Message-ID: <529C9003.10302@mozilla.com>

rust-dev-

In general, we need to ensure that for an expression `<source> as 
<target>` that any borrowed pointers in the type of <source> are not 
obscured [1] by the cast.

A collection of conditions sufficient to enforce this are listed in a 
comment in librustc/middle/kind.rs that I think is apropos here:

https://github.com/mozilla/rust/blob/master/src/librustc/middle/kind.rs#L488

However, there are probably other conditions that would also suffice 
that we might add to that set.

In particular, I do not see anything immediately wrong with your 
example; the type-expression  `&'a V` should ensure that `V` does not 
contain any lifetimes that are shorter than 'a, and therefore it should 
be safe to cast `v: &'a V` to a `&'a T`.

I have filed this as issue #10766 [2].

Cheers,
-Felix

[1] https://github.com/mozilla/rust/issues/5723

[2] https://github.com/mozilla/rust/issues/10766

On 30/11/2013 23:22, Christian Ohler wrote:
> Hi all,
>
> I'm trying to learn rust and ran into an error message I don't
> understand, and would appreciate some help.  This code:
>
> trait T {}
>
> fn f<'a, V: T>(v: &'a V) -> &'a T {
>      v as &'a T
> }
>
>
> is rejected with this error message:
>
> trait-cast.rs:4:4: 4:5 error: value may contain borrowed pointers; add
> `'static` bound
> trait-cast.rs:4     v as &'a T
>
>
> I'm trying to upcast from V to T so that I can put v in a container of
> element type T (in code not shown here).  The suggestion to add a
> 'static bound doesn't sound like what I'm looking for.
>
> What is the concern about borrowed pointers here?  What would an
> implementation of T and a caller of f look like to lead to a safety
> problem?
>
> I'm using a version of rust that is a few days old.
>
> Thanks,
> Christian.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com


From qwertie256 at gmail.com  Mon Dec  2 08:21:19 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Mon, 2 Dec 2013 09:21:19 -0700
Subject: [rust-dev] Rust forum
Message-ID: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>

Hey, why not set up a Discourse forum? That would be so. much. better. than
a mailing list. As an OSS dev I've been itching to get one myself, but
don't have time or much money to set it up. For Mozilla, though? No problem
I'm sure.

http://www.discourse.org/
Google: discourse hosting.
http://www.google.com/search?q=discourse+hosting


From: Eric Reed <ecreed at cs.washington.edu>
> ...
> I'm not aware of any plans for a rust-users forum. Maybe spinning a
> rust-users mailing list off from rust-dev would make sense? We already did
> a similar thing with our IRC channels.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/5a197640/attachment.html>

From simon.sapin at exyr.org  Mon Dec  2 08:26:51 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 02 Dec 2013 16:26:51 +0000
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
References: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
Message-ID: <529CB4CB.6010903@exyr.org>

On 02/12/2013 16:21, David Piepgrass wrote:
> That would be so. much. better. than a mailing list.

Hi. Could you expand on this? I don?t necessarily disagree, but as the 
one proposing change it?s up to you to convince everyone else :)

-- 
Simon Sapin

From pnathan at vandals.uidaho.edu  Mon Dec  2 08:29:56 2013
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Mon, 2 Dec 2013 08:29:56 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
References: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
Message-ID: <529CB584.9000009@vandals.uidaho.edu>

On 12/2/13 8:21 AM, David Piepgrass wrote:
> Hey, why not set up a Discourse forum? That would be so. much. better.
> than a mailing list. As an OSS dev I've been itching to get one myself,
> but don't have time or much money to set it up. For Mozilla, though? No
> problem I'm sure.
> 
> http://www.discourse.org/
> Google: discourse hosting.
> http://www.google.com/search?q=discourse+hosting
> 
> 
>     From: Eric Reed <ecreed at cs.washington.edu
>     <mailto:ecreed at cs.washington.edu>>
>     ...
>     I'm not aware of any plans for a rust-users forum. Maybe spinning a
>     rust-users mailing list off from rust-dev would make sense? We
>     already did
>     a similar thing with our IRC channels.
> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 

FYI, I've used a Discourse forum, and I've found it rather obnoxious.
Much prefer the PHPBB or OSQA approach.

Mailing lists are, IMO, better (e.g., gpg works, attachments work,
direct messaging comes built in).

A rust-users mailing list would be nice.

-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/ac1c1402/attachment-0001.sig>

From pcwalton at mozilla.com  Mon Dec  2 09:06:23 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 09:06:23 -0800
Subject: [rust-dev] do
In-Reply-To: <CANK7tAF2od1aGxtR=qAP=UKUea2w0i1GYWrXoN3uk2hhri2tGw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>	<529AACCB.9060101@mozilla.com>	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>	<CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>	<CA+wH294REuC7gu7Jmd4XyGVAFkXBCuLdhPQmZJtx=sq3Yjebug@mail.gmail.com>
	<CANK7tAF2od1aGxtR=qAP=UKUea2w0i1GYWrXoN3uk2hhri2tGw@mail.gmail.com>
Message-ID: <529CBE0F.1080507@mozilla.com>

On 12/2/13 1:16 AM, Gaetan wrote:
> if "do" makes the code more readable or more "beautiful", I higly
> recommend keeping this sugar syntax. If there are corner cases where do
> doesn't do the job, the developer should not use it in these cases.

The problem here is the closure inference, especially when custom smart 
pointers are concerned. Do you want the "do" syntax to start invoking 
arbitrary custom smart pointer constructors based on the type?

Patrick


From kevin at sb.org  Mon Dec  2 10:15:31 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 2 Dec 2013 10:15:31 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <529CB584.9000009@vandals.uidaho.edu>
References: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
	<529CB584.9000009@vandals.uidaho.edu>
Message-ID: <A6830D1F-AA24-4341-B399-0934AA2EEB69@sb.org>

On Dec 2, 2013, at 8:29 AM, Paul Nathan <pnathan at vandals.uidaho.edu> wrote:

> On 12/2/13 8:21 AM, David Piepgrass wrote:
>> Hey, why not set up a Discourse forum? That would be so. much. better.
>> than a mailing list. As an OSS dev I've been itching to get one myself,
>> but don't have time or much money to set it up. For Mozilla, though? No
>> problem I'm sure.
>> 
>> http://www.discourse.org/
>> Google: discourse hosting.
>> http://www.google.com/search?q=discourse+hosting
>> 
>> 
>>    From: Eric Reed <ecreed at cs.washington.edu
>>    <mailto:ecreed at cs.washington.edu>>
>>    ...
>>    I'm not aware of any plans for a rust-users forum. Maybe spinning a
>>    rust-users mailing list off from rust-dev would make sense? We
>>    already did
>>    a similar thing with our IRC channels.
>> 
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> 
> FYI, I've used a Discourse forum, and I've found it rather obnoxious.
> Much prefer the PHPBB or OSQA approach.
> 
> Mailing lists are, IMO, better (e.g., gpg works, attachments work,
> direct messaging comes built in).
> 
> A rust-users mailing list would be nice.

Personally, I?ve never met a forum that I cared for. Mailing lists are nice.

I second the idea of a rust-users ML.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/568229d3/attachment.html>

From niko at alum.mit.edu  Mon Dec  2 10:18:25 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 2 Dec 2013 13:18:25 -0500
Subject: [rust-dev] Type system thoughts
In-Reply-To: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
Message-ID: <20131202181825.GG21938@Mr-Bennet>

On Fri, Nov 15, 2013 at 05:05:28PM +0100, G?bor Lehel wrote:
> The next few are going to be about higher- (or just different-) kinded
> generics. To avoid confusion, I'm going to use "built-in trait" to mean
> things like `Freeze` and `Send`, and "kind" to mean what it does everywhere
> else in the non-Rustic world.

OK, I read a bit more. I've been working on a blog post about "HKR"
(higher-kinded Rust) and you've been elaborating on some of the same
themes as I was thinking about (naturally enough). All makes sense.

> One question with regards to higher-kinded traits is what to do about
> methods and `self`. What syntax to use? Does it even make sense? For
> syntax, I see two possibilities (snipping from the `fmap` signature):
>  - `self: &Self<A>`
>  - `&self<A>`

I was leaning towards the former, but the latter does make sense too
and would help to guide users into a more limited set of available
options, which might be helpful.

>     trait Foldable for type<type> Self {
>         fn fold<T>(&self<T>, init: &T, folder: |&T, &T| -> T) -> T;
>     }
> 
> Then `&Foldable<int>` is a trait object hiding any foldable container of
> ints (for example `~[int]`).

In the absence of an erased keyword, I think that higher-kinded traits
and objects are simply incompatible. The situation is not as simple as
you made it out, as the trait may itself have generic parameters of
higher-kind. I think the thing to do, if you wanted an object type,
would be to have an "adapter" trait:

>     trait Foldable1<T> {
>         fn fold(&self, init: &T, folder: |&T, &T| -> T) -> T;
>     }
>
>     impl<T:Foldable,U> Foldable1<U> for T<U> {
>         fn fold(&self, init: &T, folder: |&T, &T| -> T) -> T {
>             Foldable::fold(self, init, folder)
>         }
>     }

> The other is the potential to abstract over traits. GHC does this with the
> `ConstraintKinds` extension. (According to people who have implemented
> Haskell compilers, it's actually easier to implement it than not to![1]
> Which is pretty crazy.)

I'm not sure this would be true for Rust, but perhaps.

> There's two further issues that higher-kinded generics raise...

This is as far as I got in this round. More later. :)


Niko

From niko at alum.mit.edu  Mon Dec  2 10:19:31 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 2 Dec 2013 13:19:31 -0500
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <528EE360.5070504@mozilla.com>
References: <528EE360.5070504@mozilla.com>
Message-ID: <20131202181931.GH21938@Mr-Bennet>

I'm fine with this, but I wonder: will we ever have more opinion or
information than we have now? Can we just survey what e.g. ES6
does and copy them?


On Thu, Nov 21, 2013 at 08:53:52PM -0800, Patrick Walton wrote:
> There are several issues in the backwards-compatible milestone
> related to Unicode identifiers:
> 
> #4928: XID_Start/XID_Continue might not be correct
> #2253: Do NKFC normalization in lexer
> 
> Given the extreme lack of use of Unicode identifiers and the fact
> that we have much more pressing issues for 1.0, I propose putting
> support for identifiers that don't match
> /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ behind a feature gate.
> 
> Thoughts?
> 
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From pwalton at mozilla.com  Mon Dec  2 10:23:55 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 10:23:55 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529C8601.1060004@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
Message-ID: <36397828-7a84-4f51-acd2-81c02d985659@email.android.com>

Anything with @ feels like it goes too close to pointer sigils for my taste.

Patrick 

spir <denis.spir at gmail.com> wrote:
>On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>> With @ going away another possibility is to leave ~ as the normal
>allocation operator and to use @ as the placement operator. So ~expr
>stays the same and placement looks either like `@place expr` or
>`expr at place`
>
>I like that, with expr at place. Does this give:
>	let foo = ~ bar;
>	let placed_foo = bar @ place;
>?
>
>Yet another solution, just for fun, using the fact that pointers are
>supposed to 
>"point to":
>
>	let foo = -> bar;
>	let placed_foo = bar -> place;
>
>Denis
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/e7c669d4/attachment.html>

From kevin at sb.org  Mon Dec  2 10:45:01 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 2 Dec 2013 10:45:01 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
Message-ID: <0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>

What do you mean? This suggestion uses @ as an operator, not as a sigil.

-Kevin

On Dec 2, 2013, at 10:23 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Anything with @ feels like it goes too close to pointer sigils for my taste.
> 
> Patrick 
> 
> spir <denis.spir at gmail.com> wrote:
> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
> 
> I like that, with expr at place. Does this give:
>  let foo = ~ bar;
>  let placed_foo = bar @ place;
> ?
> 
> Yet another solution, just for fun, using the fact that pointers are supposed to 
> "point to":
> 
>  let foo = -> bar;
>  let placed_foo = bar -> place;
> 
> Denis
> 
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/741558c1/attachment-0001.html>

From erick.tryzelaar at gmail.com  Mon Dec  2 10:46:32 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 2 Dec 2013 10:46:32 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
Message-ID: <CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>

Is there any way we can use a method and move semantics for this? This
feels pretty natural to me:

let foo = gc_allocator.box(bar);


On Mon, Dec 2, 2013 at 10:23 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Anything with @ feels like it goes too close to pointer sigils for my
> taste.
>
> Patrick
>
> spir <denis.spir at gmail.com> wrote:
>>
>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>
>>> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>>
>>
>> I like that, with expr at place. Does this give:
>>  let foo = ~ bar;
>>  let placed_foo = bar @ place;
>> ?
>>
>> Yet another solution, just for fun, using the fact that pointers are supposed to
>> "point to":
>>
>>  let foo = -> bar;
>>  let placed_foo = bar -> place;
>>
>> Denis
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/00b9a429/attachment.html>

From ecreed at cs.washington.edu  Mon Dec  2 10:49:50 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 10:49:50 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
Message-ID: <CANbMr6HYzTzoExeyzEa58Y1sJnXAab2ttCjO3QEweH6xEdQNjA@mail.gmail.com>

But it's nothing like a pointer sigil. @ doesn't appear in the types at
all. It's just the placement allocation operator.


On Mon, Dec 2, 2013 at 10:23 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Anything with @ feels like it goes too close to pointer sigils for my
> taste.
>
> Patrick
>
> spir <denis.spir at gmail.com> wrote:
>>
>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>
>>> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>>
>>
>> I like that, with expr at place. Does this give:
>>  let foo = ~ bar;
>>  let placed_foo = bar @ place;
>> ?
>>
>> Yet another solution, just for fun, using the fact that pointers are supposed to
>> "point to":
>>
>>  let foo = -> bar;
>>  let placed_foo = bar -> place;
>>
>> Denis
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/7f5cc333/attachment.html>

From denis.spir at gmail.com  Mon Dec  2 10:52:24 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 02 Dec 2013 19:52:24 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <A6830D1F-AA24-4341-B399-0934AA2EEB69@sb.org>
References: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>	<529CB584.9000009@vandals.uidaho.edu>
	<A6830D1F-AA24-4341-B399-0934AA2EEB69@sb.org>
Message-ID: <529CD6E8.2030707@gmail.com>

On 12/02/2013 07:15 PM, Kevin Ballard wrote:
> Personally, I?ve never met a forum that I cared for. Mailing lists are nice.
>
> I second the idea of a rust-users ML.

Same for me.

denis

From ecreed at cs.washington.edu  Mon Dec  2 11:01:08 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 11:01:08 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
Message-ID: <CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>

I think the idea was to have the syntax desugar into method calls just like
other existing operators.
There'd be a trait like:

trait Box<T> {
    fn box(val: T) -> Self
}

and something like "box expr in place" would desugar into
"place::box(expr)".

One question this poses is why are we requiring the "place" to be specified
all the time?
Why not let type inference handle deciding the "place" most of the time?


On Mon, Dec 2, 2013 at 10:46 AM, Erick Tryzelaar
<erick.tryzelaar at gmail.com>wrote:

> Is there any way we can use a method and move semantics for this? This
> feels pretty natural to me:
>
> let foo = gc_allocator.box(bar);
>
>
> On Mon, Dec 2, 2013 at 10:23 AM, Patrick Walton <pwalton at mozilla.com>wrote:
>
>> Anything with @ feels like it goes too close to pointer sigils for my
>> taste.
>>
>> Patrick
>>
>> spir <denis.spir at gmail.com> wrote:
>>>
>>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>>
>>>> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>>>
>>>
>>>
>>> I like that, with expr at place. Does this give:
>>>  let foo = ~ bar;
>>>  let placed_foo = bar @ place;
>>> ?
>>>
>>> Yet another solution, just for fun, using the fact that pointers are supposed to
>>> "point to":
>>>
>>>
>>>  let foo = -> bar;
>>>  let placed_foo = bar -> place;
>>>
>>> Denis
>>> ------------------------------
>>>
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>> --
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>
>> _______________________________________________
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/6c60878c/attachment.html>

From pwalton at mozilla.com  Mon Dec  2 11:32:01 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 11:32:01 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com> <3639
	7828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>
Message-ID: <464f8221-341a-490f-84d0-229c33c21e7f@email.android.com>

Still too punctuation heavy.

Kevin Ballard <kevin at sb.org> wrote:
>What do you mean? This suggestion uses @ as an operator, not as a
>sigil.
>
>-Kevin
>
>On Dec 2, 2013, at 10:23 AM, Patrick Walton <pwalton at mozilla.com>
>wrote:
>
>> Anything with @ feels like it goes too close to pointer sigils for my
>taste.
>> 
>> Patrick 
>> 
>> spir <denis.spir at gmail.com> wrote:
>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>> With @ going away another possibility is to leave ~ as the normal
>allocation operator and to use @ as the placement operator. So ~expr
>stays the same and placement looks either like `@place expr` or
>`expr at place`
>> 
>> I like that, with expr at place. Does this give:
>>  let foo = ~ bar;
>>  let placed_foo = bar @ place;
>> ?
>> 
>> Yet another solution, just for fun, using the fact that pointers are
>supposed to 
>> "point to":
>> 
>>  let foo = -> bar;
>>  let placed_foo = bar -> place;
>> 
>> Denis
>> 
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/9609c248/attachment-0001.html>

From pwalton at mozilla.com  Mon Dec  2 11:33:31 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 11:33:31 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
Message-ID: <5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>

That would require an unnecessary move. It needs to be built into the language. 

Eric Reed <ecreed at cs.washington.edu> wrote:
>I think the idea was to have the syntax desugar into method calls just
>like
>other existing operators.
>There'd be a trait like:
>
>trait Box<T> {
>    fn box(val: T) -> Self
>}
>
>and something like "box expr in place" would desugar into
>"place::box(expr)".
>
>One question this poses is why are we requiring the "place" to be
>specified
>all the time?
>Why not let type inference handle deciding the "place" most of the
>time?
>
>
>On Mon, Dec 2, 2013 at 10:46 AM, Erick Tryzelaar
><erick.tryzelaar at gmail.com>wrote:
>
>> Is there any way we can use a method and move semantics for this?
>This
>> feels pretty natural to me:
>>
>> let foo = gc_allocator.box(bar);
>>
>>
>> On Mon, Dec 2, 2013 at 10:23 AM, Patrick Walton
><pwalton at mozilla.com>wrote:
>>
>>> Anything with @ feels like it goes too close to pointer sigils for
>my
>>> taste.
>>>
>>> Patrick
>>>
>>> spir <denis.spir at gmail.com> wrote:
>>>>
>>>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>>>
>>>>> With @ going away another possibility is to leave ~ as the normal
>allocation operator and to use @ as the placement operator. So ~expr
>stays the same and placement looks either like `@place expr` or
>`expr at place`
>>>>
>>>>
>>>>
>>>> I like that, with expr at place. Does this give:
>>>>  let foo = ~ bar;
>>>>  let placed_foo = bar @ place;
>>>> ?
>>>>
>>>> Yet another solution, just for fun, using the fact that pointers
>are supposed to
>>>> "point to":
>>>>
>>>>
>>>>  let foo = -> bar;
>>>>  let placed_foo = bar -> place;
>>>>
>>>> Denis
>>>> ------------------------------
>>>>
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>> --
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>>
>>> _______________________________________________
>>>
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/7d60d628/attachment.html>

From comexk at gmail.com  Mon Dec  2 11:37:12 2013
From: comexk at gmail.com (comex)
Date: Mon, 2 Dec 2013 14:37:12 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
	<5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>
Message-ID: <CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>

On Mon, Dec 2, 2013 at 2:33 PM, Patrick Walton <pwalton at mozilla.com> wrote:
> That would require an unnecessary move. It needs to be built into the
> language.

Devil's advocate - aren't such unnecessary moves really easy for LLVM
to optimize?

From pwalton at mozilla.com  Mon Dec  2 11:38:06 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 11:38:06 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <464f8221-341a-490f-84d0-229c33c21e7f@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com> <3639
	7828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>
	<464f8221-341a-490f-84d0-229c33c21e7f@email.android.com>
Message-ID: <89af42c8-754a-4643-bc53-637e026bd87d@email.android.com>

Besides, unless you remove the unique default (which I think would be too verbose) the default allocator reduces to a pointer sigil.

Patrick Walton <pwalton at mozilla.com> wrote:
>Still too punctuation heavy.
>
>Kevin Ballard <kevin at sb.org> wrote:
>>What do you mean? This suggestion uses @ as an operator, not as a
>>sigil.
>>
>>-Kevin
>>
>>On Dec 2, 2013, at 10:23 AM, Patrick Walton <pwalton at mozilla.com>
>>wrote:
>>
>>> Anything with @ feels like it goes too close to pointer sigils for
>my
>>taste.
>>> 
>>> Patrick 
>>> 
>>> spir <denis.spir at gmail.com> wrote:
>>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>> With @ going away another possibility is to leave ~ as the normal
>>allocation operator and to use @ as the placement operator. So ~expr
>>stays the same and placement looks either like `@place expr` or
>>`expr at place`
>>> 
>>> I like that, with expr at place. Does this give:
>>>  let foo = ~ bar;
>>>  let placed_foo = bar @ place;
>>> ?
>>> 
>>> Yet another solution, just for fun, using the fact that pointers are
>>supposed to 
>>> "point to":
>>> 
>>>  let foo = -> bar;
>>>  let placed_foo = bar -> place;
>>> 
>>> Denis
>>> 
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> -- 
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>
>-- 
>Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/0aa83539/attachment.html>

From pwalton at mozilla.com  Mon Dec  2 11:39:04 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 02 Dec 2013 11:39:04 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
	<5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>
	<CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>
Message-ID: <c6fab4a6-a3ba-4d9b-8b7c-e32ad6d47186@email.android.com>

Only if you SROA and inline the constructor, I think.

comex <comexk at gmail.com> wrote:
>On Mon, Dec 2, 2013 at 2:33 PM, Patrick Walton <pwalton at mozilla.com>
>wrote:
>> That would require an unnecessary move. It needs to be built into the
>> language.
>
>Devil's advocate - aren't such unnecessary moves really easy for LLVM
>to optimize?

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/1082dea3/attachment.html>

From ben.striegel at gmail.com  Mon Dec  2 11:40:51 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 2 Dec 2013 14:40:51 -0500
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
References: <CAHuo6ZCX_OBtKtuhKUfcPYpEzvj2NCk20rBdoi_5T7DRZ1oaHA@mail.gmail.com>
Message-ID: <CAAvrL-=Q7f-+uJBpsF3H0fhcA4EmFvYiWXKVXJuEC2OHkBfJrQ@mail.gmail.com>

I'm not sure that discussion forums are the best alternative to the typical
"foo-users" mailing list. Topics are generally less about discussion and
more about getting a quick answer to a problem; IRC is okay for this at the
moment, but once Rust stabilizes I'd much prefer just using StackOverflow
to host these sorts of questions.

(For the moment, however, asking questions on SO just makes more work for
us once the language actually does stabilize, since we'll need to go
through and make sure all the answers are still relevant.)

It's also not like this is an exclusive choice. We could have a rust-users
list as well as a discussion forum. It's just that we'd need to figure out
what to actually use the forum for that other outlets don't already do well
(e.g. reddit.com/r/rust is a pretty good link aggregator).


On Mon, Dec 2, 2013 at 11:21 AM, David Piepgrass <qwertie256 at gmail.com>wrote:

> Hey, why not set up a Discourse forum? That would be so. much. better.
> than a mailing list. As an OSS dev I've been itching to get one myself, but
> don't have time or much money to set it up. For Mozilla, though? No problem
> I'm sure.
>
> http://www.discourse.org/
> Google: discourse hosting.
> http://www.google.com/search?q=discourse+hosting
>
>
> From: Eric Reed <ecreed at cs.washington.edu>
>> ...
>> I'm not aware of any plans for a rust-users forum. Maybe spinning a
>> rust-users mailing list off from rust-dev would make sense? We already did
>> a similar thing with our IRC channels.
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/7784dc6c/attachment-0001.html>

From kevin at sb.org  Mon Dec  2 12:04:04 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 2 Dec 2013 12:04:04 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <89af42c8-754a-4643-bc53-637e026bd87d@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com> <3639
	7828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>
	<464f8221-341a-490f-84d0-229c33c21e7f@email.android.com>
	<89af42c8-754a-4643-bc53-637e026bd87d@email.android.com>
Message-ID: <BBBBC14B-93D4-4C08-99C8-7D037B258A5E@sb.org>

~ would still be the unique default. @ would require a place (because there's no placement without a place). Just because C++ uses the same operator for regular allocation and for placement doesn't mean we have to do the same. As it's been pointed out already, C++'s use of `new` for placement is kind of quite strange, since it doesn't actually allocate anything.

As for "too punctuation heavy", why the hate on punctuation? Operators have a long history of use in programming languages to great effect. I don't get why operators are now suddenly bad. User-overloadable operators are contentious, certainly, but this isn't an overloadable operator.

-Kevin

On Dec 2, 2013, at 11:38 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Besides, unless you remove the unique default (which I think would be too verbose) the default allocator reduces to a pointer sigil.
> 
> Patrick Walton <pwalton at mozilla.com> wrote:
> Still too punctuation heavy.
> 
> Kevin Ballard <kevin at sb.org> wrote:
> What do you mean? This suggestion uses @ as an operator, not as a sigil.
> 
> -Kevin
> 
> On Dec 2, 2013, at 10:23 AM, Patrick Walton <pwalton at mozilla.com> wrote:
> 
>> Anything with @ feels like it goes too close to pointer sigils for my taste.
>> 
>> Patrick 
>> 
>> spir <denis.spir at gmail.com> wrote:
>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>> 
>> I like that, with expr at place. Does this give:
>>  let foo = ~ bar;
>>  let placed_foo = bar @ place;
>> ?
>> 
>> Yet another solution, just for fun, using the fact that pointers are supposed to 
>> "point to":
>> 
>>  let foo = -> bar;
>>  let placed_foo = bar -> place;
>> 
>> Denis
>> 
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/cf0edfe9/attachment.html>

From ecreed at cs.washington.edu  Mon Dec  2 13:31:24 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 13:31:24 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <BBBBC14B-93D4-4C08-99C8-7D037B258A5E@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<0C0089F8-C528-4056-9926-06BFEB15C49D@sb.org>
	<464f8221-341a-490f-84d0-229c33c21e7f@email.android.com>
	<89af42c8-754a-4643-bc53-637e026bd87d@email.android.com>
	<BBBBC14B-93D4-4C08-99C8-7D037B258A5E@sb.org>
Message-ID: <CANbMr6HDXkBkBbzAZ=fQbMu0AbF=buH=_afRSv_4WvG-2SvhCw@mail.gmail.com>

And @ even makes sense for what it's doing (placing something at somewhere)
when compared with most operators.


On Mon, Dec 2, 2013 at 12:04 PM, Kevin Ballard <kevin at sb.org> wrote:

> ~ would still be the unique default. @ would require a place (because
> there's no placement without a place). Just because C++ uses the same
> operator for regular allocation and for placement doesn't mean we have to
> do the same. As it's been pointed out already, C++'s use of `new` for
> placement is kind of quite strange, since it doesn't actually allocate
> anything.
>
> As for "too punctuation heavy", why the hate on punctuation? Operators
> have a long history of use in programming languages to great effect. I
> don't get why operators are now suddenly bad. User-overloadable operators
> are contentious, certainly, but this isn't an overloadable operator.
>
> -Kevin
>
> On Dec 2, 2013, at 11:38 AM, Patrick Walton <pwalton at mozilla.com> wrote:
>
> Besides, unless you remove the unique default (which I think would be too
> verbose) the default allocator reduces to a pointer sigil.
>
> Patrick Walton <pwalton at mozilla.com> wrote:
>>
>> Still too punctuation heavy.
>>
>> Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> What do you mean? This suggestion uses @ as an operator, not as a sigil.
>>>
>>> -Kevin
>>>
>>> On Dec 2, 2013, at 10:23 AM, Patrick Walton <pwalton at mozilla.com> wrote:
>>>
>>> Anything with @ feels like it goes too close to pointer sigils for my
>>> taste.
>>>
>>> Patrick
>>>
>>> spir <denis.spir at gmail.com> wrote:
>>>>
>>>> On 12/02/2013 11:57 AM, Kevin Ballard wrote:
>>>>
>>>>> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>>>>
>>>>
>>>> I like that, with expr at place. Does this give:
>>>>  let foo = ~ bar;
>>>>  let placed_foo = bar @ place;
>>>> ?
>>>>
>>>> Yet another solution, just for fun, using the fact that pointers are supposed to
>>>> "point to":
>>>>
>>>>  let foo = -> bar;
>>>>  let placed_foo = bar -> place;
>>>>
>>>> Denis
>>>> ------------------------------
>>>>
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>> --
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/4f1a3907/attachment.html>

From me at kevincantu.org  Mon Dec  2 20:31:39 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Mon, 2 Dec 2013 20:31:39 -0800
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <20131202181931.GH21938@Mr-Bennet>
References: <528EE360.5070504@mozilla.com> <20131202181931.GH21938@Mr-Bennet>
Message-ID: <CABq6+adsy0ARdU2bUj3TANmsay-FD8i5asG3B6GmFM_4W3+U9Q@mail.gmail.com>

When I started my old Rust PPA (now superseded), the first user to
email me was an engineer from China who was getting ready to give a
talk introducing Rust to a programming user group in Gu?ngzh?u bigger
than any of the Rust-specific meetups we've ever had yet in the San
Francisco Bay area.

There are a ton of people who don't do their best work in English: our
ASCII world is quite small, despite how loud people like me happen to
talk.  Excluding foreign language users when we don't have to would be
a huge mistake.

Gating this for now only works if we aren't later going to try to
sacrifice this awesome feature to the elder gods of backwards
compatibility...


Kevin

From corey at octayn.net  Mon Dec  2 21:05:20 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 3 Dec 2013 00:05:20 -0500
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <CABq6+adsy0ARdU2bUj3TANmsay-FD8i5asG3B6GmFM_4W3+U9Q@mail.gmail.com>
References: <528EE360.5070504@mozilla.com> <20131202181931.GH21938@Mr-Bennet>
	<CABq6+adsy0ARdU2bUj3TANmsay-FD8i5asG3B6GmFM_4W3+U9Q@mail.gmail.com>
Message-ID: <CA++BO6R4LK=r5VrCY2kgYcmxyVdC70pzOn_6FAoB3=Utvr0KFA@mail.gmail.com>

 The compiler still handles it, and there are still tests for it. I
think it's more of a "not 1.0 priority", than anything else.

On Mon, Dec 2, 2013 at 11:31 PM, Kevin Cantu <me at kevincantu.org> wrote:
> When I started my old Rust PPA (now superseded), the first user to
> email me was an engineer from China who was getting ready to give a
> talk introducing Rust to a programming user group in Gu?ngzh?u bigger
> than any of the Rust-specific meetups we've ever had yet in the San
> Francisco Bay area.
>
> There are a ton of people who don't do their best work in English: our
> ASCII world is quite small, despite how loud people like me happen to
> talk.  Excluding foreign language users when we don't have to would be
> a huge mistake.
>
> Gating this for now only works if we aren't later going to try to
> sacrifice this awesome feature to the elder gods of backwards
> compatibility...
>
>
> Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From qwertie256 at gmail.com  Mon Dec  2 21:45:37 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Mon, 2 Dec 2013 22:45:37 -0700
Subject: [rust-dev] Rust forum
Message-ID: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>

On 02/12/2013 16:21, David Piepgrass wrote:

> > That would be so. much. better. than a mailing list.
>
> Hi. Could you expand on this? I don?t necessarily disagree, but as the
> one proposing change it?s up to you to convince everyone else :)
>
> --
> Simon Sapin
>

Okay, well, I've never liked mailing lists at all, because:

1. In non-digest mode, My inbox gets flooded.
2. In digest mode, it's quite inconvenient to write a reply, having to cut
out all the messages that I don't want to reply to and manually edit the
subject line. Also, unrelated messages are grouped together while threads
are broken apart, making discussions harder to follow.
3. In email I don't get a threaded view. If I go to mailing list archives
to see a threaded view, I can't reply.
4. I have to manually watch for replies to my messages or to threads I'm
following. If someone mentions my name (not that they would), I won't be
notified.

In contrast, Discourse has a variety of email notification options. I don't
know if those options are enough to please everybody, but you can probably
configure it to notify you about all posts, which makes it essentially
equivalent to a mailing list. It supports reply by email, so those that
prefer a mailing list can still pretend it's a mailing list. Currently I'm
getting an shrunk digest of Discourse Meta--by email I only get a subset of
all messages, auto-selected by Discourse, whatever it thinks is
interesting. That's good for me: I really don't want to see every message.

Plus, a mailing list offers less privacy as it mandates publishing your
email address. That's not a big deal for me personally, but do you really
want to require that from every Rust user?

(btw, if I'm wrong about any of the above points, I promise there are lots
of other netizens out there who have the same misconception(s), so many of
them will avoid mailing lists. The fact that y'all are talking to me on a
mailing list suggests that the disadvantages of a mailing list are not a
big deal *to you*, but as for those who aren't participating, you can't
conclude *they* prefer mailing lists.)

And like mailing lists, Discourse also supports private messages.

I don't understand why Paul mentioned GPG. You want to encrypt messages to
a public mailing list? You can sign messages, but surely almost no one
actually checks the signature, and I'd be surprised if Discourse didn't
offer some built-in evidence of identity (surely it's not like email in
letting you spoof the sender name easily?).

I heard discourse supports attachments, just that you may have to go to the
forum to attach or download them (rather than by email).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/d2b0f436/attachment.html>

From ecreed at cs.washington.edu  Mon Dec  2 22:35:34 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Mon, 2 Dec 2013 22:35:34 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
Message-ID: <CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>

Well there's always r/rust/ <http://www.reddit.com/r/rust/>. It usually
works pretty well.


On Mon, Dec 2, 2013 at 9:45 PM, David Piepgrass <qwertie256 at gmail.com>wrote:

> On 02/12/2013 16:21, David Piepgrass wrote:
>
>> > That would be so. much. better. than a mailing list.
>>
>> Hi. Could you expand on this? I don?t necessarily disagree, but as the
>> one proposing change it?s up to you to convince everyone else :)
>>
>> --
>> Simon Sapin
>>
>
> Okay, well, I've never liked mailing lists at all, because:
>
> 1. In non-digest mode, My inbox gets flooded.
> 2. In digest mode, it's quite inconvenient to write a reply, having to cut
> out all the messages that I don't want to reply to and manually edit the
> subject line. Also, unrelated messages are grouped together while threads
> are broken apart, making discussions harder to follow.
> 3. In email I don't get a threaded view. If I go to mailing list archives
> to see a threaded view, I can't reply.
> 4. I have to manually watch for replies to my messages or to threads I'm
> following. If someone mentions my name (not that they would), I won't be
> notified.
>
> In contrast, Discourse has a variety of email notification options. I
> don't know if those options are enough to please everybody, but you can
> probably configure it to notify you about all posts, which makes it
> essentially equivalent to a mailing list. It supports reply by email, so
> those that prefer a mailing list can still pretend it's a mailing list.
> Currently I'm getting an shrunk digest of Discourse Meta--by email I only
> get a subset of all messages, auto-selected by Discourse, whatever it
> thinks is interesting. That's good for me: I really don't want to see every
> message.
>
> Plus, a mailing list offers less privacy as it mandates publishing your
> email address. That's not a big deal for me personally, but do you really
> want to require that from every Rust user?
>
> (btw, if I'm wrong about any of the above points, I promise there are lots
> of other netizens out there who have the same misconception(s), so many of
> them will avoid mailing lists. The fact that y'all are talking to me on a
> mailing list suggests that the disadvantages of a mailing list are not a
> big deal *to you*, but as for those who aren't participating, you can't
> conclude *they* prefer mailing lists.)
>
> And like mailing lists, Discourse also supports private messages.
>
> I don't understand why Paul mentioned GPG. You want to encrypt messages to
> a public mailing list? You can sign messages, but surely almost no one
> actually checks the signature, and I'd be surprised if Discourse didn't
> offer some built-in evidence of identity (surely it's not like email in
> letting you spoof the sender name easily?).
>
> I heard discourse supports attachments, just that you may have to go to
> the forum to attach or download them (rather than by email).
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131202/7ccf6cdd/attachment.html>

From val at markovic.io  Tue Dec  3 00:34:37 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 3 Dec 2013 00:34:37 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <c6fab4a6-a3ba-4d9b-8b7c-e32ad6d47186@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
	<5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>
	<CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>
	<c6fab4a6-a3ba-4d9b-8b7c-e32ad6d47186@email.android.com>
Message-ID: <CAK9U+m0EMHGzaaFw7dZuMEeLQ8zyKdvAUw_MOW1NytF7TOT5Cg@mail.gmail.com>

This is an interesting thread. A few points:

- "box" makes a lot more sense than "new"; as others have pointed out, the
latter maps to a different concept in C++ which makes it familiar in the
worst way.
- "Foo::init" is terrible, agreed, but "Foo::new" is less than ideal as
well. "Foo::create" might be better. Just read this aloud: "this function
news a value." What? That makes no sense. "This function creates a value."
Much better, isn't it? Point being, it should be a verb. JavaScript does it
with Object.create, so there's precedent.
- placement new might be common in Servo and browser engines, but it's not
that common in most C++. After 10 years and 200k+ LOC of C++ across many,
many different programs and paradigms I've yet to use it once. Sure, that's
just one person's experience but others seem to be echoing the same
sentiment. I'm not saying let's not have placement new, just that we
shouldn't put on an undeserved pedestal.

On Dec 2, 2013 11:39 AM, "Patrick Walton" <pwalton at mozilla.com> wrote:
>
> Only if you SROA and inline the constructor, I think.
>
>
> comex <comexk at gmail.com> wrote:
>>
>> On Mon, Dec 2, 2013 at 2:33 PM, Patrick Walton <pwalton at mozilla.com>
wrote:
>>>
>>> That would require an unnecessary move. It needs to be built into the
>>> language.
>>
>>
>> Devil's advocate - aren't such unnecessary moves really easy for LLVM
>> to optimize?
>
>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/b4ad6803/attachment.html>

From pcwalton at mozilla.com  Tue Dec  3 00:41:17 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 03 Dec 2013 00:41:17 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAK9U+m0EMHGzaaFw7dZuMEeLQ8zyKdvAUw_MOW1NytF7TOT5Cg@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>	<529B33ED.6080807@gmail.com>	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>	<529C8601.1060004@gmail.com>	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>	<5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>	<CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>	<c6fab4a6-a3ba-4d9b-8b7c-e32ad6d47186@email.android.com>
	<CAK9U+m0EMHGzaaFw7dZuMEeLQ8zyKdvAUw_MOW1NytF7TOT5Cg@mail.gmail.com>
Message-ID: <529D992D.4070803@mozilla.com>

On 12/3/13 12:34 AM, Val Markovic wrote:
> This is an interesting thread. A few points:
>
> - "box" makes a lot more sense than "new"; as others have pointed out,
> the latter maps to a different concept in C++ which makes it familiar in
> the worst way.
> - "Foo::init" is terrible, agreed, but "Foo::new" is less than ideal as
> well. "Foo::create" might be better. Just read this aloud: "this
> function news a value." What? That makes no sense. "This function
> creates a value." Much better, isn't it? Point being, it should be a
> verb. JavaScript does it with Object.create, so there's precedent.
> - placement new might be common in Servo and browser engines, but it's
> not that common in most C++. After 10 years and 200k+ LOC of C++ across
> many, many different programs and paradigms I've yet to use it once.
> Sure, that's just one person's experience but others seem to be echoing
> the same sentiment. I'm not saying let's not have placement new, just
> that we shouldn't put on an undeserved pedestal.

Rust and C++ are different. You don't use placement `new` for 
`shared_ptr` in C++; however, you will use placement `new` (or `box`) 
for `RC` in Rust (the equivalent). For this reason I suspect that 
placement `new` will be much commoner in Rust than in C++.

Patrick


From jeti789 at web.de  Tue Dec  3 00:43:14 2013
From: jeti789 at web.de (jeti789 at web.de)
Date: Tue, 3 Dec 2013 09:43:14 +0100 (CET)
Subject: [rust-dev] Rust forum
In-Reply-To: <CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>,
	<CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>
Message-ID: <trinity-b87da21b-8125-4ca2-b855-255df23622bf-1386060194138@3capp-webde-bs20>

An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/05b2b084/attachment.html>

From remifontan at yahoo.fr  Tue Dec  3 01:09:10 2013
From: remifontan at yahoo.fr (=?UTF-8?B?UsOpbWkgRm9udGFu?=)
Date: Tue, 3 Dec 2013 22:09:10 +1300
Subject: [rust-dev] method overloading and generic
Message-ID: <CAFKqbfQm7tD7tP19oF7ooYnfAXO2-fim-tt5hc3y2HPm7caN3w@mail.gmail.com>

Hi,

I think I already asked this question in the past and I'm not very sure
what was the answer and whether it is still applicable wirh rust 0.8.

I'm implementing the double dispatch method overloading such that I can add
2 struct together and a float to a struct.

        let data = SomeData{a:1.0} + 2.0;
        let data2 = SomeData{a:100.0} + data;

I would like to implement the add for every type of float. I asked whether
I could write something like this:

impl<T:Float> SomeDataRhs for T {
    fn add_to(&self, lhs:&SomeData) -> SomeData {
        SomeData{a:lhs.a + cast(*self)}
    }
}

it does not compile right now with rust 0.8
I get error messages as follow

test2.rs:39:0: 43:1 error: conflicting implementations for trait
`SomeDataRhs`

test2.rs:39 impl SomeDataRhs for SomeData {

test2.rs:40     fn add_to(&self, lhs:&SomeData) -> SomeData {

test2.rs:41         SomeData{a:lhs.a + self.a}

test2.rs:42     }

test2.rs:43 }

test2.rs:33:0: 37:1 note: note conflicting implementation here

test2.rs:33 impl<T:Float> SomeDataRhs for T {

test2.rs:34     fn add_to(&self, lhs:&SomeData) -> SomeData {

test2.rs:35         SomeData{a:lhs.a + cast(*self)}

test2.rs:36     }

Would you know whether what I try to do is possible. I was recommended to
use macro for that, I don't mind to eventually go this way but I would
rather do it the proper way if there is one.

here's the full code of my test:
extern mod std;
use std::num::cast;


struct SomeData { a:float }

trait SomeDataRhs {
    fn add_to(&self, lhs:&SomeData) -> SomeData;
}

impl<T:SomeDataRhs> Add<T, SomeData> for SomeData {

    fn add(&self, rhs:&T) -> SomeData {
        rhs.add_to(self)
    }
}

// ---------------
// implementations

// impl SomeDataRhs for float {
//     fn add_to(&self, lhs:&SomeData) -> SomeData {
//         SomeData{a:lhs.a + *self}
//     }
// }

// impl SomeDataRhs for f64 {
//     fn add_to(&self, lhs:&SomeData) -> SomeData {
//         SomeData{a:lhs.a + cast(*self)}
//     }
// }

impl<T:Float> SomeDataRhs for T {
    fn add_to(&self, lhs:&SomeData) -> SomeData {
        SomeData{a:lhs.a + cast(*self)}
    }
}

impl SomeDataRhs for SomeData {
    fn add_to(&self, lhs:&SomeData) -> SomeData {
        SomeData{a:lhs.a + self.a}
    }
}


#[test]
fn test_sandbox() {

    let mut data = SomeData{a:1.0} + 2.0;
    println!("result: {}", data.a);

    let mut data2 = SomeData{a:100.0} + data;
    data = data + data2;
    println!("result: {}", data.a);

}



cheers,

R?mi


-- 
R?mi Fontan : remifontan at yahoo.fr
mobile: +64 21 855 351
93 Otaki Street, Miramar 6022
Wellington, New Zealand
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/9fa88e5a/attachment.html>

From ecreed at cs.washington.edu  Tue Dec  3 02:50:39 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 3 Dec 2013 02:50:39 -0800
Subject: [rust-dev] method overloading and generic
In-Reply-To: <CAFKqbfQm7tD7tP19oF7ooYnfAXO2-fim-tt5hc3y2HPm7caN3w@mail.gmail.com>
References: <CAFKqbfQm7tD7tP19oF7ooYnfAXO2-fim-tt5hc3y2HPm7caN3w@mail.gmail.com>
Message-ID: <CANbMr6H9VC56wekdEN1UNJOGg7BknU=sF-Lw_qCeR7x0jjH6ZA@mail.gmail.com>

I think you're running into issue
#8075<https://github.com/mozilla/rust/issues/8075>which has to do with
generic impls conflicting with all the other impls
present.
The typechecker tries to ensure that impls are coherent, i.e. that impls do
not overlap (otherwise the compiler wouldn't know which one to use).
Unfortunately, the coherence check isn't very smart right now and if
there's a generic impl around then it assumes it could conflict with
everything (and consequently forbids any other impls).

The specific problem here is that the coherence checker doesn't realize
that SomeData does not impl Float. Without knowing that, the checker sees
two possible impls for SomeData and rejects the code.
If you replace "impl<T: Float> SomeDataRhs for T" with "impl SomeDataRhs
for f64", then it'll work fine. You can add an impl for f32 as well (FYI
"float" is already removed in HEAD).
Unfortunately, I don't know of a good general solution that will support
all types implementing Float (i.e. what the generic impl is doing).


On Tue, Dec 3, 2013 at 1:09 AM, R?mi Fontan <remifontan at yahoo.fr> wrote:

> Hi,
>
> I think I already asked this question in the past and I'm not very sure
> what was the answer and whether it is still applicable wirh rust 0.8.
>
> I'm implementing the double dispatch method overloading such that I can
> add 2 struct together and a float to a struct.
>
>         let data = SomeData{a:1.0} + 2.0;
>         let data2 = SomeData{a:100.0} + data;
>
> I would like to implement the add for every type of float. I asked whether
> I could write something like this:
>
> impl<T:Float> SomeDataRhs for T {
>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>         SomeData{a:lhs.a + cast(*self)}
>     }
> }
>
> it does not compile right now with rust 0.8
> I get error messages as follow
>
> test2.rs:39:0: 43:1 error: conflicting implementations for trait
> `SomeDataRhs`
>
> test2.rs:39 impl SomeDataRhs for SomeData {
>
> test2.rs:40     fn add_to(&self, lhs:&SomeData) -> SomeData {
>
> test2.rs:41         SomeData{a:lhs.a + self.a}
>
> test2.rs:42     }
>
> test2.rs:43 }
>
> test2.rs:33:0: 37:1 note: note conflicting implementation here
>
> test2.rs:33 impl<T:Float> SomeDataRhs for T {
>
> test2.rs:34     fn add_to(&self, lhs:&SomeData) -> SomeData {
>
> test2.rs:35         SomeData{a:lhs.a + cast(*self)}
>
> test2.rs:36     }
>
> Would you know whether what I try to do is possible. I was recommended to
> use macro for that, I don't mind to eventually go this way but I would
> rather do it the proper way if there is one.
>
> here's the full code of my test:
> extern mod std;
> use std::num::cast;
>
>
> struct SomeData { a:float }
>
> trait SomeDataRhs {
>     fn add_to(&self, lhs:&SomeData) -> SomeData;
> }
>
> impl<T:SomeDataRhs> Add<T, SomeData> for SomeData {
>
>     fn add(&self, rhs:&T) -> SomeData {
>         rhs.add_to(self)
>     }
> }
>
> // ---------------
> // implementations
>
> // impl SomeDataRhs for float {
> //     fn add_to(&self, lhs:&SomeData) -> SomeData {
> //         SomeData{a:lhs.a + *self}
> //     }
> // }
>
> // impl SomeDataRhs for f64 {
> //     fn add_to(&self, lhs:&SomeData) -> SomeData {
> //         SomeData{a:lhs.a + cast(*self)}
> //     }
> // }
>
> impl<T:Float> SomeDataRhs for T {
>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>         SomeData{a:lhs.a + cast(*self)}
>     }
> }
>
> impl SomeDataRhs for SomeData {
>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>         SomeData{a:lhs.a + self.a}
>     }
> }
>
>
> #[test]
> fn test_sandbox() {
>
>     let mut data = SomeData{a:1.0} + 2.0;
>     println!("result: {}", data.a);
>
>     let mut data2 = SomeData{a:100.0} + data;
>     data = data + data2;
>     println!("result: {}", data.a);
>
> }
>
>
>
> cheers,
>
> R?mi
>
>
> --
> R?mi Fontan : remifontan at yahoo.fr
> mobile: +64 21 855 351
> 93 Otaki Street, Miramar 6022
> Wellington, New Zealand
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/e2485b9c/attachment-0001.html>

From troplin at bluewin.ch  Tue Dec  3 04:03:36 2013
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Tue, 3 Dec 2013 12:03:36 +0000 (UTC)
Subject: [rust-dev] Rust forum
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
Message-ID: <658484505407764383.648605troplin-bluewin.ch@news.gmane.org>

David Piepgrass <qwertie256 at gmail.com> wrote:
> Okay, well, I've never liked mailing lists at all, because:
> 
> 1. In non-digest mode, My inbox gets flooded.
> 2. In digest mode, it's quite inconvenient to write a reply, having to
> cut out all the messages that I don't want to reply to and manually edit
> the subject line. Also, unrelated messages are grouped together while
> threads are broken apart, making discussions harder to follow.
> 3. In email I don't get a threaded view. If I go to mailing list archives
> to see a threaded view, I can't reply.

Just use NNTP (gmane.comp.lang.rust.devel on news.gmane.org). Most
newsreader support threaded view (Thunderbird does). You can configure the
mailing list s.t. mails are not actually delivered to your email address
even if you are registered.

But looking at your email address you are already using gmane.

Tobi


From gaetan at xeberon.net  Tue Dec  3 05:46:00 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 3 Dec 2013 14:46:00 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <658484505407764383.648605troplin-bluewin.ch@news.gmane.org>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
	<658484505407764383.648605troplin-bluewin.ch@news.gmane.org>
Message-ID: <CANK7tAG6cURcAT3drujCqz7nr1QmGs6AnxVSRjx3DS=6zEa2kA@mail.gmail.com>

I'm in favor of a properly managed stackoverflow section.

stackoverflow does a marvelous job for finding issue someone else has
already been confronted before.  I never liked forums, search features are
always buggy, category are too restrictives, ...

mailing list is good for what it does: emails. That's all.

-----
Gaetan



2013/12/3 Tobias M?ller <troplin at bluewin.ch>

> David Piepgrass <qwertie256 at gmail.com> wrote:
> > Okay, well, I've never liked mailing lists at all, because:
> >
> > 1. In non-digest mode, My inbox gets flooded.
> > 2. In digest mode, it's quite inconvenient to write a reply, having to
> > cut out all the messages that I don't want to reply to and manually edit
> > the subject line. Also, unrelated messages are grouped together while
> > threads are broken apart, making discussions harder to follow.
> > 3. In email I don't get a threaded view. If I go to mailing list archives
> > to see a threaded view, I can't reply.
>
> Just use NNTP (gmane.comp.lang.rust.devel on news.gmane.org). Most
> newsreader support threaded view (Thunderbird does). You can configure the
> mailing list s.t. mails are not actually delivered to your email address
> even if you are registered.
>
> But looking at your email address you are already using gmane.
>
> Tobi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/88fbbeae/attachment.html>

From ben.striegel at gmail.com  Tue Dec  3 06:02:59 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 3 Dec 2013 09:02:59 -0500
Subject: [rust-dev] Rust forum
In-Reply-To: <trinity-b87da21b-8125-4ca2-b855-255df23622bf-1386060194138@3capp-webde-bs20>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
	<CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>
	<trinity-b87da21b-8125-4ca2-b855-255df23622bf-1386060194138@3capp-webde-bs20>
Message-ID: <CAAvrL-mnz2uCuVF+NARnWCmcoTUZWxHtJ-oAR5HbXkPYjwx5ng@mail.gmail.com>

> The idea of an online user forum would be that people with an interest in
Rust can read in the user forum which is easier to peruse than some mail
list archive. Asking and getting answers seems to work more fluently.

I agree with the principle, but we have yet to identify what users would
actually want to peruse in a discussion forum. For questions, we have
StackOverflow. For keeping up with the cool projects that the community is
working on, we have reddit. Piggybacking on established platforms will lead
to easier discoverability and broader readership.

Which isn't to say that a discussion forum won't be warranted sometime in
the future, but for now we're getting along quite well with the free
alternatives provided by the broader web.


On Tue, Dec 3, 2013 at 3:43 AM, <jeti789 at web.de> wrote:

>  The idea of an online user forum would be that people with an interest
> in Rust can read in the user forum which is easier to peruse than some mail
> list archive. Asking and getting answers seems to work more fluently.
>
> There is really hell going on on the Go users forum:
> https://groups.google.com/forum/?hl=de#!forum/golang-nuts An online forum
> seems to intensivy people's interest in some language. But it's certainly
> your language and your decision what you want to do.
>
> Regards, Oliver
>
> *Gesendet:* Dienstag, 03. Dezember 2013 um 07:35 Uhr
> *Von:* "Eric Reed" <ecreed at cs.washington.edu>
> *An:* "David Piepgrass" <qwertie256 at gmail.com>
> *Cc:* "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> *Betreff:* Re: [rust-dev] Rust forum
>  Well there's always r/rust/ <http://www.reddit.com/r/rust/>. It usually
> works pretty well.
>
> On Mon, Dec 2, 2013 at 9:45 PM, David Piepgrass <qwertie256 at gmail.com>wrote:
>>
>>  On 02/12/2013 16:21, David Piepgrass wrote:
>>
>>> > That would be so. much. better. than a mailing list.
>>>
>>> Hi. Could you expand on this? I don?t necessarily disagree, but as the
>>> one proposing change it?s up to you to convince everyone else :)
>>>
>>> --
>>> Simon Sapin
>>
>>
>> Okay, well, I've never liked mailing lists at all, because:
>>
>> 1. In non-digest mode, My inbox gets flooded.
>> 2. In digest mode, it's quite inconvenient to write a reply, having to
>> cut out all the messages that I don't want to reply to and manually edit
>> the subject line. Also, unrelated messages are grouped together while
>> threads are broken apart, making discussions harder to follow.
>> 3. In email I don't get a threaded view. If I go to mailing list archives
>> to see a threaded view, I can't reply.
>> 4. I have to manually watch for replies to my messages or to threads I'm
>> following. If someone mentions my name (not that they would), I won't be
>> notified.
>>
>>  In contrast, Discourse has a variety of email notification options. I
>> don't know if those options are enough to please everybody, but you can
>> probably configure it to notify you about all posts, which makes it
>> essentially equivalent to a mailing list. It supports reply by email, so
>> those that prefer a mailing list can still pretend it's a mailing list.
>> Currently I'm getting an shrunk digest of Discourse Meta--by email I only
>> get a subset of all messages, auto-selected by Discourse, whatever it
>> thinks is interesting. That's good for me: I really don't want to see every
>> message.
>>
>> Plus, a mailing list offers less privacy as it mandates publishing your
>> email address. That's not a big deal for me personally, but do you really
>> want to require that from every Rust user?
>>
>>  (btw, if I'm wrong about any of the above points, I promise there are
>> lots of other netizens out there who have the same misconception(s), so
>> many of them will avoid mailing lists. The fact that y'all are talking to
>> me on a mailing list suggests that the disadvantages of a mailing list are
>> not a big deal *to you*, but as for those who aren't participating, you
>> can't conclude *they* prefer mailing lists.)
>>
>>  And like mailing lists, Discourse also supports private messages.
>>
>> I don't understand why Paul mentioned GPG. You want to encrypt messages
>> to a public mailing list? You can sign messages, but surely almost no one
>> actually checks the signature, and I'd be surprised if Discourse didn't
>> offer some built-in evidence of identity (surely it's not like email in
>> letting you spoof the sender name easily?).
>>
>> I heard discourse supports attachments, just that you may have to go to
>> the forum to attach or download them (rather than by email).
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/320ad93a/attachment.html>

From tiffany at stormbit.net  Tue Dec  3 06:27:28 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Tue, 3 Dec 2013 09:27:28 -0500
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
Message-ID: <CAKBOV9n1iZsnP3jVq_Uc0Rva9mZ+m=fycngWJHg=XGXGUw5N7Q@mail.gmail.com>

On Tue, Dec 3, 2013 at 12:45 AM, David Piepgrass <qwertie256 at gmail.com>wrote:

> 1. In non-digest mode, My inbox gets flooded.
> 3. In email I don't get a threaded view. If I go to mailing list archives
> to see a threaded view, I can't reply.
> 4. I have to manually watch for replies to my messages or to threads I'm
> following. If someone mentions my name (not that they would), I won't be
> notified.
>

You should consider getting a better email client. GMail handles mailing
lists pretty poorly, and even it does better than that.


> In contrast, Discourse has a variety of email notification options. I
> don't know if those options are enough to please everybody, but you can
> probably configure it to notify you about all posts, which makes it
> essentially equivalent to a mailing list. It supports reply by email, so
> those that prefer a mailing list can still pretend it's a mailing list.
> Currently I'm getting an shrunk digest of Discourse Meta--by email I only
> get a subset of all messages, auto-selected by Discourse, whatever it
> thinks is interesting. That's good for me: I really don't want to see every
> message.
>

Do you think it allows you to reply via email like github does?

You've made a number of good points, I must say.


> Plus, a mailing list offers less privacy as it mandates publishing your
> email address. That's not a big deal for me personally, but do you really
> want to require that from every Rust user?
>
> (btw, if I'm wrong about any of the above points, I promise there are lots
> of other netizens out there who have the same misconception(s), so many of
> them will avoid mailing lists. The fact that y'all are talking to me on a
> mailing list suggests that the disadvantages of a mailing list are not a
> big deal *to you*, but as for those who aren't participating, you can't
> conclude *they* prefer mailing lists.)
>
> And like mailing lists, Discourse also supports private messages.
>
> I don't understand why Paul mentioned GPG. You want to encrypt messages to
> a public mailing list? You can sign messages, but surely almost no one
> actually checks the signature, and I'd be surprised if Discourse didn't
> offer some built-in evidence of identity (surely it's not like email in
> letting you spoof the sender name easily?).
>
> I heard discourse supports attachments, just that you may have to go to
> the forum to attach or download them (rather than by email).
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/57d41b64/attachment-0001.html>

From michaelwoerister at posteo.de  Mon Dec  2 03:11:24 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Mon, 02 Dec 2013 12:11:24 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>
	<529B33ED.6080807@gmail.com>	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
Message-ID: <529C6ADC.1090402@posteo.de>

+1 for `expr @ place`

On 02.12.2013 11:57, Kevin Ballard wrote:
> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
>
> -Kevin Ballard
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Tue Dec  3 09:13:43 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 3 Dec 2013 12:13:43 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529D992D.4070803@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C8601.1060004@gmail.com>
	<36397828-7a84-4f51-acd2-81c02d985659@email.android.com>
	<CALdfqQL8AbM7R-BqMP4Ab0=OCjzfc_2hFZ0Zvt4=f_WUtJKFsg@mail.gmail.com>
	<CANbMr6EPpgBZN9_qKrpNT=WLB+WqisSOoZ1bBMkD69E9Y-GnWQ@mail.gmail.com>
	<5019bcae-0463-4d30-8734-6dd851939aa4@email.android.com>
	<CAPM5UJ2ewWDrYiyYktvcpz8S6LL7uN0xhV1FuXmM-CRHVPEh8w@mail.gmail.com>
	<c6fab4a6-a3ba-4d9b-8b7c-e32ad6d47186@email.android.com>
	<CAK9U+m0EMHGzaaFw7dZuMEeLQ8zyKdvAUw_MOW1NytF7TOT5Cg@mail.gmail.com>
	<529D992D.4070803@mozilla.com>
Message-ID: <CA+DvKQ+9mTXj1KirxfLOfmhNrFTwBYQ90a5YpQgqB-RN7VG2Hg@mail.gmail.com>

On Tue, Dec 3, 2013 at 3:41 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 12/3/13 12:34 AM, Val Markovic wrote:
>>
>> This is an interesting thread. A few points:
>>
>> - "box" makes a lot more sense than "new"; as others have pointed out,
>> the latter maps to a different concept in C++ which makes it familiar in
>> the worst way.
>> - "Foo::init" is terrible, agreed, but "Foo::new" is less than ideal as
>> well. "Foo::create" might be better. Just read this aloud: "this
>> function news a value." What? That makes no sense. "This function
>> creates a value." Much better, isn't it? Point being, it should be a
>> verb. JavaScript does it with Object.create, so there's precedent.
>> - placement new might be common in Servo and browser engines, but it's
>> not that common in most C++. After 10 years and 200k+ LOC of C++ across
>> many, many different programs and paradigms I've yet to use it once.
>> Sure, that's just one person's experience but others seem to be echoing
>> the same sentiment. I'm not saying let's not have placement new, just
>> that we shouldn't put on an undeserved pedestal.
>
>
> Rust and C++ are different. You don't use placement `new` for `shared_ptr`
> in C++; however, you will use placement `new` (or `box`) for `RC` in Rust
> (the equivalent). For this reason I suspect that placement `new` will be
> much commoner in Rust than in C++.
>
> Patrick

To expand on this, C++ has functions like `make_shared` (C++11),
`make_unique` (C++14) and even container methods to build an object
in-place without a move (`emplace`, `emplace_back`, etc.).

From ben.striegel at gmail.com  Tue Dec  3 09:16:21 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 3 Dec 2013 12:16:21 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529C6ADC.1090402@posteo.de>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C6ADC.1090402@posteo.de>
Message-ID: <CAAvrL-n5M+kmJWk8R-oHpkAKBz6TSBb5aroVvqUqis0mHZ1Oew@mail.gmail.com>

If `expr @ place` suffices then you'd think that re-using `in` keyword as
per `expr in place` would also work, but I believe we rejected that for
technical reasons in past discussions. And if those technical reasons no
longer apply, I'd like to motion that `in` looks way better than `@` there.
:)


On Mon, Dec 2, 2013 at 6:11 AM, Michael Woerister <
michaelwoerister at posteo.de> wrote:

> +1 for `expr @ place`
>
>
> On 02.12.2013 11:57, Kevin Ballard wrote:
>
>> With @ going away another possibility is to leave ~ as the normal
>> allocation operator and to use @ as the placement operator. So ~expr stays
>> the same and placement looks either like `@place expr` or `expr at place`
>>
>> -Kevin Ballard
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/aae8214a/attachment.html>

From redbrain at gcc.gnu.org  Tue Dec  3 09:22:07 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Tue, 3 Dec 2013 17:22:07 +0000
Subject: [rust-dev] Rust front-end to GCC
Message-ID: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>

Hey all

Some of you may have noticed the gccrs branch on the git mirror. Since
PyCon IE 2013 i gave a talk on my Python Front-end pet project and heard
about rust by a few people and i never really looked at it before until
then but i've kind of been hooked since.

So to learn the language i've been writing this front-end to GCC. Only
really a a month or  so on and off work in between work. Currently it
compiles alot of rust already in fairly little effort on my side GCC is
doing loads of the heavy lifting.

Currently it compiles most of the basic stuff such as a struct an impl
block while loop, functions expressions calling methods passing arguments
etc. Currently focusing on getting the typing working correctly to support
& and ~ and look at how templates might work as well as need to implement
break and return.

There is still a lot of work but i would really like to share it and see
what people think. Personally i think rust will target GCC very well and be
a good addition (if / when it works). I really want to try and give back to
this community who have been very good to me in learning over the last few
years with GSOC.

To get a jist of what i am compiling in my tests are something like:

fn fib1 (n:int) -> int {
    if (n <= 1) { 1 }
    else { n * fib1 (n - 1) }
}

fn fib2 (n:int) -> int {
    let mut i = 1;
    let mut result = 1;
    while (i <= n) {
        result = result * i;
        i = i + 1;
    }
    result
}

fn main () {
    fib1 (10);
    fib2 (10);
}

Or

struct mytype {
    x : int
}

impl mytype {
    fn test (self) -> int {
        println ("yyoyoyo");
        test2 (1)
    }
}

fn main () {
    let x = mytype { x : 1 };
    let z = x.x;
    let y = x.test ();
    let a = test2 (y);
}

fn test2 (x : int) -> int {
    let z = x;
    1 + z
}

Theses are both pretty abstract test cases but were the ones i just made
work a while ago. Lots more work to do on it but i feel these 2 test cases
working is kind of a mile stone for me.

I will start a wiki page on the project and the code i work on is at
http://gcc.gnu.org/git/?p=gcc.git;a=shortlog;h=refs/heads/gccrs and i have
it on github first mostly for travis CI and so i can do a bunch of commits
and rebase etc http://github.com/redbrain/gccrs

Thanks

--Phil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/e3b87dd9/attachment.html>

From banderson at mozilla.com  Tue Dec  3 09:45:43 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 03 Dec 2013 09:45:43 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAAvrL-mnz2uCuVF+NARnWCmcoTUZWxHtJ-oAR5HbXkPYjwx5ng@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>	<CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>	<trinity-b87da21b-8125-4ca2-b855-255df23622bf-1386060194138@3capp-webde-bs20>
	<CAAvrL-mnz2uCuVF+NARnWCmcoTUZWxHtJ-oAR5HbXkPYjwx5ng@mail.gmail.com>
Message-ID: <529E18C7.40403@mozilla.com>

On 12/03/2013 06:02 AM, Benjamin Striegel wrote:
> > The idea of an online user forum would be that people with an 
> interest in Rust can read in the user forum which is easier to peruse 
> than some mail list archive. Asking and getting answers seems to work 
> more fluently.
>
> I agree with the principle, but we have yet to identify what users 
> would actually want to peruse in a discussion forum. For questions, we 
> have StackOverflow. For keeping up with the cool projects that the 
> community is working on, we have reddit. Piggybacking on established 
> platforms will lead to easier discoverability and broader readership.

I also believe that we should lean heavily on external resources 
wherever possible. Maintaining our own infrastructure is very time 
consuming and we've already got a lot. We could put more focus on 
stackoverflow by linking it from the wiki and encouraging community 
members to curate it better (I know I haven't looked at it in a long time).

Currently, I'm more in favor of adding a rust-users mailing list than 
setting up a web forum, but there are pros and cons to each approach:

* creating another *type* of venue for general discussion runs the risk 
of dividing the user base
* mailing lists are easy to create and administer at Mozilla
* web forums can be much easier to moderate, and we've had a few 
incidents on the mailing list recently
* mailing lists are simple to archive and maintaining a record of Rust's 
development is imortant to me
* if we did set up a forum, it seems like we should shut down the 
mailing list to avoid dividing the user base, which feels kind of 
unfortunate simply because having a mailing list is a matter of pride

>
> Which isn't to say that a discussion forum won't be warranted sometime 
> in the future, but for now we're getting along quite well with the 
> free alternatives provided by the broader web.
>
>
> On Tue, Dec 3, 2013 at 3:43 AM, <jeti789 at web.de 
> <mailto:jeti789 at web.de>> wrote:
>
>     The idea of an online user forum would be that people with an
>     interest in Rust can read in the user forum which is easier to
>     peruse than some mail list archive. Asking and getting answers
>     seems to work more fluently.
>     There is really hell going on on the Go users forum:
>     https://groups.google.com/forum/?hl=de#!forum/golang-nuts
>     <https://groups.google.com/forum/?hl=de#%21forum/golang-nuts> An
>     online forum seems to intensivy people's interest in some
>     language. But it's certainly your language and your decision what
>     you want to do.
>
>     Regards, Oliver
>     *Gesendet:* Dienstag, 03. Dezember 2013 um 07:35 Uhr
>     *Von:* "Eric Reed" <ecreed at cs.washington.edu
>     <mailto:ecreed at cs.washington.edu>>
>     *An:* "David Piepgrass" <qwertie256 at gmail.com
>     <mailto:qwertie256 at gmail.com>>
>     *Cc:* "rust-dev at mozilla.org <mailto:rust-dev at mozilla.org>"
>     <rust-dev at mozilla.org <mailto:rust-dev at mozilla.org>>
>     *Betreff:* Re: [rust-dev] Rust forum
>     Well there's always r/rust/ <http://www.reddit.com/r/rust/>. It
>     usually works pretty well.
>     On Mon, Dec 2, 2013 at 9:45 PM, David Piepgrass
>     <qwertie256 at gmail.com <http://qwertie256 at gmail.com>> wrote:
>
>         On 02/12/2013 16:21, David Piepgrass wrote:
>
>             > That would be so. much. better. than a mailing list.
>             Hi. Could you expand on this? I don?t necessarily
>             disagree, but as the
>             one proposing change it?s up to you to convince everyone
>             else :)
>
>             --
>             Simon Sapin
>
>         Okay, well, I've never liked mailing lists at all, because:
>         1. In non-digest mode, My inbox gets flooded.
>         2. In digest mode, it's quite inconvenient to write a reply,
>         having to cut out all the messages that I don't want to reply
>         to and manually edit the subject line. Also, unrelated
>         messages are grouped together while threads are broken apart,
>         making discussions harder to follow.
>         3. In email I don't get a threaded view. If I go to mailing
>         list archives to see a threaded view, I can't reply.
>         4. I have to manually watch for replies to my messages or to
>         threads I'm following. If someone mentions my name (not that
>         they would), I won't be notified.
>         In contrast, Discourse has a variety of email notification
>         options. I don't know if those options are enough to please
>         everybody, but you can probably configure it to notify you
>         about all posts, which makes it essentially equivalent to a
>         mailing list. It supports reply by email, so those that prefer
>         a mailing list can still pretend it's a mailing list.
>         Currently I'm getting an shrunk digest of Discourse Meta--by
>         email I only get a subset of all messages, auto-selected by
>         Discourse, whatever it thinks is interesting. That's good for
>         me: I really don't want to see every message.
>         Plus, a mailing list offers less privacy as it mandates
>         publishing your email address. That's not a big deal for me
>         personally, but do you really want to require that from every
>         Rust user?
>         (btw, if I'm wrong about any of the above points, I promise
>         there are lots of other netizens out there who have the same
>         misconception(s), so many of them will avoid mailing lists.
>         The fact that y'all are talking to me on a mailing list
>         suggests that the disadvantages of a mailing list are not a
>         big deal *to you*, but as for those who aren't participating,
>         you can't conclude *they* prefer mailing lists.)
>         And like mailing lists, Discourse also supports private messages.
>         I don't understand why Paul mentioned GPG. You want to encrypt
>         messages to a public mailing list? You can sign messages, but
>         surely almost no one actually checks the signature, and I'd be
>         surprised if Discourse didn't offer some built-in evidence of
>         identity (surely it's not like email in letting you spoof the
>         sender name easily?).
>         I heard discourse supports attachments, just that you may have
>         to go to the forum to attach or download them (rather than by
>         email).
>
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <http://Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/cd9b3ae2/attachment-0001.html>

From danielmicay at gmail.com  Tue Dec  3 09:54:05 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 3 Dec 2013 12:54:05 -0500
Subject: [rust-dev] Rust front-end to GCC
In-Reply-To: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
Message-ID: <CA+DvKQKLEuDG_C880fWR3YgCb1fkVS-L42eXeGpNFxK3zS8FJw@mail.gmail.com>

On Tue, Dec 3, 2013 at 12:22 PM, Philip Herron <redbrain at gcc.gnu.org> wrote:
> Hey all
>
> Some of you may have noticed the gccrs branch on the git mirror. Since PyCon
> IE 2013 i gave a talk on my Python Front-end pet project and heard about
> rust by a few people and i never really looked at it before until then but
> i've kind of been hooked since.
>
> So to learn the language i've been writing this front-end to GCC. Only
> really a a month or  so on and off work in between work. Currently it
> compiles alot of rust already in fairly little effort on my side GCC is
> doing loads of the heavy lifting.
>
> Currently it compiles most of the basic stuff such as a struct an impl block
> while loop, functions expressions calling methods passing arguments etc.
> Currently focusing on getting the typing working correctly to support & and
> ~ and look at how templates might work as well as need to implement break
> and return.
>
> There is still a lot of work but i would really like to share it and see
> what people think. Personally i think rust will target GCC very well and be
> a good addition (if / when it works). I really want to try and give back to
> this community who have been very good to me in learning over the last few
> years with GSOC.
>
> To get a jist of what i am compiling in my tests are something like:
>
> fn fib1 (n:int) -> int {
>     if (n <= 1) { 1 }
>     else { n * fib1 (n - 1) }
> }
>
> fn fib2 (n:int) -> int {
>     let mut i = 1;
>     let mut result = 1;
>     while (i <= n) {
>         result = result * i;
>         i = i + 1;
>     }
>     result
> }
>
> fn main () {
>     fib1 (10);
>     fib2 (10);
> }
>
> Or
>
> struct mytype {
>     x : int
> }
>
> impl mytype {
>     fn test (self) -> int {
>         println ("yyoyoyo");
>         test2 (1)
>     }
> }
>
> fn main () {
>     let x = mytype { x : 1 };
>     let z = x.x;
>     let y = x.test ();
>     let a = test2 (y);
> }
>
> fn test2 (x : int) -> int {
>     let z = x;
>     1 + z
> }
>
> Theses are both pretty abstract test cases but were the ones i just made
> work a while ago. Lots more work to do on it but i feel these 2 test cases
> working is kind of a mile stone for me.
>
> I will start a wiki page on the project and the code i work on is at
> http://gcc.gnu.org/git/?p=gcc.git;a=shortlog;h=refs/heads/gccrs and i have
> it on github first mostly for travis CI and so i can do a bunch of commits
> and rebase etc http://github.com/redbrain/gccrs
>
> Thanks
>
> --Phil

I think another backend would be very valuable, but not another
implementation of the rest of the compiler. I would expect a gcc
backend to be based on libsyntax/librustc with an alternate backend
for `trans` and `back`.

Implementing a fully compatible compiler with a full parser/macros,
metadata, type-checking, borrow checking, liveness checking, type
inference, privacy/reachability, etc. doesn't seem feasible. The
upstream compiler already has hundreds of issues to fix in these
areas.

From ben.striegel at gmail.com  Tue Dec  3 09:58:13 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 3 Dec 2013 12:58:13 -0500
Subject: [rust-dev] Rust front-end to GCC
In-Reply-To: <CA+DvKQKLEuDG_C880fWR3YgCb1fkVS-L42eXeGpNFxK3zS8FJw@mail.gmail.com>
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
	<CA+DvKQKLEuDG_C880fWR3YgCb1fkVS-L42eXeGpNFxK3zS8FJw@mail.gmail.com>
Message-ID: <CAAvrL-=_R7-rmGhuzAegJfWYjpO10emNWAOWZe2T8hT3pKyCmg@mail.gmail.com>

This is very cool! But, I agree with Daniel. If there's any way that we can
reduce the duplication of effort, we should. This is especially true given
that we don't have anything close to an accurate written specification to
help keep two implementations in sync.


On Tue, Dec 3, 2013 at 12:54 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Dec 3, 2013 at 12:22 PM, Philip Herron <redbrain at gcc.gnu.org>
> wrote:
> > Hey all
> >
> > Some of you may have noticed the gccrs branch on the git mirror. Since
> PyCon
> > IE 2013 i gave a talk on my Python Front-end pet project and heard about
> > rust by a few people and i never really looked at it before until then
> but
> > i've kind of been hooked since.
> >
> > So to learn the language i've been writing this front-end to GCC. Only
> > really a a month or  so on and off work in between work. Currently it
> > compiles alot of rust already in fairly little effort on my side GCC is
> > doing loads of the heavy lifting.
> >
> > Currently it compiles most of the basic stuff such as a struct an impl
> block
> > while loop, functions expressions calling methods passing arguments etc.
> > Currently focusing on getting the typing working correctly to support &
> and
> > ~ and look at how templates might work as well as need to implement break
> > and return.
> >
> > There is still a lot of work but i would really like to share it and see
> > what people think. Personally i think rust will target GCC very well and
> be
> > a good addition (if / when it works). I really want to try and give back
> to
> > this community who have been very good to me in learning over the last
> few
> > years with GSOC.
> >
> > To get a jist of what i am compiling in my tests are something like:
> >
> > fn fib1 (n:int) -> int {
> >     if (n <= 1) { 1 }
> >     else { n * fib1 (n - 1) }
> > }
> >
> > fn fib2 (n:int) -> int {
> >     let mut i = 1;
> >     let mut result = 1;
> >     while (i <= n) {
> >         result = result * i;
> >         i = i + 1;
> >     }
> >     result
> > }
> >
> > fn main () {
> >     fib1 (10);
> >     fib2 (10);
> > }
> >
> > Or
> >
> > struct mytype {
> >     x : int
> > }
> >
> > impl mytype {
> >     fn test (self) -> int {
> >         println ("yyoyoyo");
> >         test2 (1)
> >     }
> > }
> >
> > fn main () {
> >     let x = mytype { x : 1 };
> >     let z = x.x;
> >     let y = x.test ();
> >     let a = test2 (y);
> > }
> >
> > fn test2 (x : int) -> int {
> >     let z = x;
> >     1 + z
> > }
> >
> > Theses are both pretty abstract test cases but were the ones i just made
> > work a while ago. Lots more work to do on it but i feel these 2 test
> cases
> > working is kind of a mile stone for me.
> >
> > I will start a wiki page on the project and the code i work on is at
> > http://gcc.gnu.org/git/?p=gcc.git;a=shortlog;h=refs/heads/gccrs and i
> have
> > it on github first mostly for travis CI and so i can do a bunch of
> commits
> > and rebase etc http://github.com/redbrain/gccrs
> >
> > Thanks
> >
> > --Phil
>
> I think another backend would be very valuable, but not another
> implementation of the rest of the compiler. I would expect a gcc
> backend to be based on libsyntax/librustc with an alternate backend
> for `trans` and `back`.
>
> Implementing a fully compatible compiler with a full parser/macros,
> metadata, type-checking, borrow checking, liveness checking, type
> inference, privacy/reachability, etc. doesn't seem feasible. The
> upstream compiler already has hundreds of issues to fix in these
> areas.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/070e3b69/attachment.html>

From spam at scientician.net  Tue Dec  3 10:01:34 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Tue, 03 Dec 2013 19:01:34 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <529E18C7.40403@mozilla.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>	<CANbMr6H8iXypJACDmm8CmMJ_D6F=iBgPKEYN2WejPhNB1YHAjw@mail.gmail.com>	<trinity-b87da21b-8125-4ca2-b855-255df23622bf-1386060194138@3capp-webde-bs20>	<CAAvrL-mnz2uCuVF+NARnWCmcoTUZWxHtJ-oAR5HbXkPYjwx5ng@mail.gmail.com>
	<529E18C7.40403@mozilla.com>
Message-ID: <l7l69j$597$1@ger.gmane.org>

On 2013-12-03 18:45, Brian Anderson wrote:
> On 12/03/2013 06:02 AM, Benjamin Striegel wrote:
>> > The idea of an online user forum would be that people with an
>> interest in Rust can read in the user forum which is easier to peruse
>> than some mail list archive. Asking and getting answers seems to work
>> more fluently.
>>
>> I agree with the principle, but we have yet to identify what users
>> would actually want to peruse in a discussion forum. For questions, we
>> have StackOverflow. For keeping up with the cool projects that the
>> community is working on, we have reddit. Piggybacking on established
>> platforms will lead to easier discoverability and broader readership.
> 
> I also believe that we should lean heavily on external resources
> wherever possible. Maintaining our own infrastructure is very time
> consuming and we've already got a lot. We could put more focus on
> stackoverflow by linking it from the wiki and encouraging community
> members to curate it better (I know I haven't looked at it in a long time).
> 
> Currently, I'm more in favor of adding a rust-users mailing list than
> setting up a web forum, but there are pros and cons to each approach:
> 
> * creating another *type* of venue for general discussion runs the risk
> of dividing the user base
> * mailing lists are easy to create and administer at Mozilla
> * web forums can be much easier to moderate, and we've had a few
> incidents on the mailing list recently
> * mailing lists are simple to archive and maintaining a record of Rust's
> development is imortant to me
> * if we did set up a forum, it seems like we should shut down the
> mailing list to avoid dividing the user base, which feels kind of
> unfortunate simply because having a mailing list is a matter of pride
> 

An additional point in favor of mailing lists is that web forums cannot
be accessed through a standard API (such as NNTP) which means that they
cannot be accessed through the incredibly useful GMANE.org
NNTP<->mailing list two-way gateway.

Regards,



From kevin at sb.org  Tue Dec  3 10:11:51 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 3 Dec 2013 10:11:51 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAAvrL-n5M+kmJWk8R-oHpkAKBz6TSBb5aroVvqUqis0mHZ1Oew@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C6ADC.1090402@posteo.de>
	<CAAvrL-n5M+kmJWk8R-oHpkAKBz6TSBb5aroVvqUqis0mHZ1Oew@mail.gmail.com>
Message-ID: <93D56D6C-F2BB-4F10-9029-5151D317C9DF@sb.org>

I?m curious what the technical reasons are, because I?m not sure why it wouldn?t work (it?s just an operator, after all).

In any case, I prefer @ for aesthetic reasons. Also, this operator should probably bind pretty tightly (e.g. 1 * 2 at Gc would place the 2 not the 1*2), but it?s often confusing to have word operators bind tightly. For example, I think `as` binds reasonably tightly, but I still can?t remember its exact precedence.

-Kevin

On Dec 3, 2013, at 9:16 AM, Benjamin Striegel <ben.striegel at gmail.com> wrote:

> If `expr @ place` suffices then you'd think that re-using `in` keyword as per `expr in place` would also work, but I believe we rejected that for technical reasons in past discussions. And if those technical reasons no longer apply, I'd like to motion that `in` looks way better than `@` there. :)
> 
> 
> On Mon, Dec 2, 2013 at 6:11 AM, Michael Woerister <michaelwoerister at posteo.de> wrote:
> +1 for `expr @ place`
> 
> 
> On 02.12.2013 11:57, Kevin Ballard wrote:
> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
> 
> -Kevin Ballard
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/998193be/attachment-0001.html>

From kevin at sb.org  Tue Dec  3 10:11:51 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 3 Dec 2013 10:11:51 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAAvrL-n5M+kmJWk8R-oHpkAKBz6TSBb5aroVvqUqis0mHZ1Oew@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de> <529B33ED.6080807@gmail.com>
	<CACVDHKm76J7BuQ55c=TjMgWMp-dYkYAF44ZuSSTO+po9B4Z5Vw@mail.gmail.com>
	<CAKBOV9ktXn7nThqkoLQPnR8iHnSeqFn6npSf-DCqmCn4KkH7-A@mail.gmail.com>
	<CANbMr6G7nmJhb7-KSm1gK3r_uAceXOk__vCUqAOMmuGkXd+ddQ@mail.gmail.com>
	<A74099E1-D109-4929-A8FF-B93ED22239CF@sb.org>
	<B6BB4996-7EEF-4ECE-91B2-E24F4D933D46@sb.org>
	<529C6ADC.1090402@posteo.de>
	<CAAvrL-n5M+kmJWk8R-oHpkAKBz6TSBb5aroVvqUqis0mHZ1Oew@mail.gmail.com>
Message-ID: <93D56D6C-F2BB-4F10-9029-5151D317C9DF@sb.org>

I?m curious what the technical reasons are, because I?m not sure why it wouldn?t work (it?s just an operator, after all).

In any case, I prefer @ for aesthetic reasons. Also, this operator should probably bind pretty tightly (e.g. 1 * 2 at Gc would place the 2 not the 1*2), but it?s often confusing to have word operators bind tightly. For example, I think `as` binds reasonably tightly, but I still can?t remember its exact precedence.

-Kevin

On Dec 3, 2013, at 9:16 AM, Benjamin Striegel <ben.striegel at gmail.com> wrote:

> If `expr @ place` suffices then you'd think that re-using `in` keyword as per `expr in place` would also work, but I believe we rejected that for technical reasons in past discussions. And if those technical reasons no longer apply, I'd like to motion that `in` looks way better than `@` there. :)
> 
> 
> On Mon, Dec 2, 2013 at 6:11 AM, Michael Woerister <michaelwoerister at posteo.de> wrote:
> +1 for `expr @ place`
> 
> 
> On 02.12.2013 11:57, Kevin Ballard wrote:
> With @ going away another possibility is to leave ~ as the normal allocation operator and to use @ as the placement operator. So ~expr stays the same and placement looks either like `@place expr` or `expr at place`
> 
> -Kevin Ballard
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/998193be/attachment-0002.html>

From val at markovic.io  Tue Dec  3 11:02:50 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 3 Dec 2013 11:02:50 -0800
Subject: [rust-dev] Rust front-end to GCC
In-Reply-To: <CAAvrL-=_R7-rmGhuzAegJfWYjpO10emNWAOWZe2T8hT3pKyCmg@mail.gmail.com>
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
	<CA+DvKQKLEuDG_C880fWR3YgCb1fkVS-L42eXeGpNFxK3zS8FJw@mail.gmail.com>
	<CAAvrL-=_R7-rmGhuzAegJfWYjpO10emNWAOWZe2T8hT3pKyCmg@mail.gmail.com>
Message-ID: <CAK9U+m01-uOs+dViNBXwgGthPwkoWNFiXnDCkJ5P+Qs_1oVjRg@mail.gmail.com>

Agreed with Daniel. The D approach would be best. They one frontend and
then dmd (frontend + proprietary backend), ldc (frontend + llvm) and gdc
(frontend + gcc backends) use that. This would be the best for the Rust
ecosystem, users and developers of the various compilers; there's no
duplication of efforts and critically, very few compiler-specific bugs. One
can reasonably assume that any code written for dmd will work with ldc and
gdc.

Multiple independent compilers would require a common, detailed spec to
reach any level of interoperability. That comes with its own costs and
complexities and IMO I don't think they're worth it.


On Tue, Dec 3, 2013 at 9:58 AM, Benjamin Striegel <ben.striegel at gmail.com>wrote:

> This is very cool! But, I agree with Daniel. If there's any way that we
> can reduce the duplication of effort, we should. This is especially true
> given that we don't have anything close to an accurate written
> specification to help keep two implementations in sync.
>
>
> On Tue, Dec 3, 2013 at 12:54 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> On Tue, Dec 3, 2013 at 12:22 PM, Philip Herron <redbrain at gcc.gnu.org>
>> wrote:
>> > Hey all
>> >
>> > Some of you may have noticed the gccrs branch on the git mirror. Since
>> PyCon
>> > IE 2013 i gave a talk on my Python Front-end pet project and heard about
>> > rust by a few people and i never really looked at it before until then
>> but
>> > i've kind of been hooked since.
>> >
>> > So to learn the language i've been writing this front-end to GCC. Only
>> > really a a month or  so on and off work in between work. Currently it
>> > compiles alot of rust already in fairly little effort on my side GCC is
>> > doing loads of the heavy lifting.
>> >
>> > Currently it compiles most of the basic stuff such as a struct an impl
>> block
>> > while loop, functions expressions calling methods passing arguments etc.
>> > Currently focusing on getting the typing working correctly to support &
>> and
>> > ~ and look at how templates might work as well as need to implement
>> break
>> > and return.
>> >
>> > There is still a lot of work but i would really like to share it and see
>> > what people think. Personally i think rust will target GCC very well
>> and be
>> > a good addition (if / when it works). I really want to try and give
>> back to
>> > this community who have been very good to me in learning over the last
>> few
>> > years with GSOC.
>> >
>> > To get a jist of what i am compiling in my tests are something like:
>> >
>> > fn fib1 (n:int) -> int {
>> >     if (n <= 1) { 1 }
>> >     else { n * fib1 (n - 1) }
>> > }
>> >
>> > fn fib2 (n:int) -> int {
>> >     let mut i = 1;
>> >     let mut result = 1;
>> >     while (i <= n) {
>> >         result = result * i;
>> >         i = i + 1;
>> >     }
>> >     result
>> > }
>> >
>> > fn main () {
>> >     fib1 (10);
>> >     fib2 (10);
>> > }
>> >
>> > Or
>> >
>> > struct mytype {
>> >     x : int
>> > }
>> >
>> > impl mytype {
>> >     fn test (self) -> int {
>> >         println ("yyoyoyo");
>> >         test2 (1)
>> >     }
>> > }
>> >
>> > fn main () {
>> >     let x = mytype { x : 1 };
>> >     let z = x.x;
>> >     let y = x.test ();
>> >     let a = test2 (y);
>> > }
>> >
>> > fn test2 (x : int) -> int {
>> >     let z = x;
>> >     1 + z
>> > }
>> >
>> > Theses are both pretty abstract test cases but were the ones i just made
>> > work a while ago. Lots more work to do on it but i feel these 2 test
>> cases
>> > working is kind of a mile stone for me.
>> >
>> > I will start a wiki page on the project and the code i work on is at
>> > http://gcc.gnu.org/git/?p=gcc.git;a=shortlog;h=refs/heads/gccrs and i
>> have
>> > it on github first mostly for travis CI and so i can do a bunch of
>> commits
>> > and rebase etc http://github.com/redbrain/gccrs
>> >
>> > Thanks
>> >
>> > --Phil
>>
>> I think another backend would be very valuable, but not another
>> implementation of the rest of the compiler. I would expect a gcc
>> backend to be based on libsyntax/librustc with an alternate backend
>> for `trans` and `back`.
>>
>> Implementing a fully compatible compiler with a full parser/macros,
>> metadata, type-checking, borrow checking, liveness checking, type
>> inference, privacy/reachability, etc. doesn't seem feasible. The
>> upstream compiler already has hundreds of issues to fix in these
>> areas.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/0a17430a/attachment.html>

From slabode at aim.com  Tue Dec  3 11:44:37 2013
From: slabode at aim.com (SiegeLord)
Date: Tue, 03 Dec 2013 14:44:37 -0500
Subject: [rust-dev] Practical usage of rustpkg
Message-ID: <529E34A5.2070700@aim.com>

So I've been thinking for awhile about how one would actually use 
rustpkg. Let me first outline my use case. I have a library and a 
program that uses that library, both of which I host on GitHub. One of 
the features of the rustpkg system is that I should be able to write 
this to refer to the library in my program:

extern mod lib = "package_id";

Unfortunately, there is no obvious thing to put into the 'package_id' 
slot. There are two options:

First, I could use "github.com/SiegeLord/library" as my package_id. This 
is problematic, as it would require one of these sub-optimal courses of 
action:

- Stick the source of the library into workspace/src/library where I 
would actually develop and then use a duplicate package in the 
workspace/src/github.com/SiegeLord/library that would be created by 
rustpkg (the program is located in workspace/src/program). Somehow this 
duplicate package will be synced to the actual package: either through 
pushing to GitHub and then pulling somehow via rustpkg (this is less 
than ideal, as I may want to test WIP changes without committing them 
elsewhere/I may have no internet connection e.g. when traveling), or 
some manual, local git operation.

- Stick the source of the library into 
workspace/src/github.com/SiegeLord/library and develop the library 
there. There is no duplication, but it really seems bizarre to me to 
locate a project in a directory named like that. Also, I'd be a bit 
paranoid about rustpkg not realizing that I never want to communicate 
with GitHub and having it accidentally overwriting my local changes.

The second option is to use "library" as the package id. This allows me 
to locate my library in a logical location (workspace/src/library), but 
it prevents other users of my program from building it automatically. 
Essentially what they'll have to do is to manually check out the library 
repository inside their workspaces so as to create the 
workspace/src/library directory on their system: the `extern mod` syntax 
will not work otherwise.

I don't think any of these options are ideal. I don't want to suggest 
solutions to these issues because I'm not sure how things are supposed 
to be used/what the planned design is. Does anybody use rustpkg 
seriously today? Is everybody making workspaces with a github.com/<user> 
directory where they develop their software?

-SL

From jurily at gmail.com  Tue Dec  3 11:52:20 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Tue, 03 Dec 2013 20:52:20 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <CANK7tAG6cURcAT3drujCqz7nr1QmGs6AnxVSRjx3DS=6zEa2kA@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>	<658484505407764383.648605troplin-bluewin.ch@news.gmane.org>
	<CANK7tAG6cURcAT3drujCqz7nr1QmGs6AnxVSRjx3DS=6zEa2kA@mail.gmail.com>
Message-ID: <529E3674.2070103@gmail.com>

On 12/03/2013 02:46 PM, Gaetan wrote:
> I'm in favor of a properly managed stackoverflow section.
>
> stackoverflow does a marvelous job for finding issue someone else has
> already been confronted before.  I never liked forums, search features
> are always buggy, category are too restrictives, ...
>
> mailing list is good for what it does: emails. That's all.

SO can be awesome iff we update the questions and answers regularly as 
the language changes. Finding an answer for 0.3 is not helpful. Provided 
we can do that, it should also solve our need for better tutorials.

Maintaining it needs to be a full project though, unless you want to end 
up like http://stackoverflow.com/tags/go, where most questions haven't 
been updated since the day after the Google announcement.

From qwertie256 at gmail.com  Tue Dec  3 12:07:48 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Tue, 3 Dec 2013 13:07:48 -0700
Subject: [rust-dev] Rust forum
Message-ID: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>

> > David Piepgrass <qwertie256 at gmail.com> wrote:
> > > Okay, well, I've never liked mailing lists at all, because:
> > >
> > > 1. In non-digest mode, My inbox gets flooded.
> > > 2. In digest mode, it's quite inconvenient to write a reply, having to
> > > cut out all the messages that I don't want to reply to and manually
> edit
> > > the subject line. Also, unrelated messages are grouped together while
> > > threads are broken apart, making discussions harder to follow.
> > > 3. In email I don't get a threaded view. If I go to mailing list
> archives
> > > to see a threaded view, I can't reply.
> >
> > Just use NNTP (gmane.comp.lang.rust.devel on news.gmane.org). Most
> > newsreader support threaded view (Thunderbird does). You can configure
> the
> > mailing list s.t. mails are not actually delivered to your email address
> > even if you are registered.
> >
> > But looking at your email address you are already using gmane.
>
> I'm using gmail; I have never used gmane and know nothing about it. I also
don't have or use an email client or a newsreader. And there are lots of
people like me.

If gmane is the preferred way to interact with this mailing list, users
clicking on the mailing list link:

https://mail.mozilla.org/listinfo/rust-dev

should be pointed at gmane specifically.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/7a541a29/attachment.html>

From kevin at sb.org  Tue Dec  3 12:11:36 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 3 Dec 2013 12:11:36 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
Message-ID: <0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>

On Dec 3, 2013, at 12:07 PM, David Piepgrass <qwertie256 at gmail.com> wrote:

> > David Piepgrass <qwertie256 at gmail.com> wrote:
> > > Okay, well, I've never liked mailing lists at all, because:
> > >
> > > 1. In non-digest mode, My inbox gets flooded.
> > > 2. In digest mode, it's quite inconvenient to write a reply, having to
> > > cut out all the messages that I don't want to reply to and manually edit
> > > the subject line. Also, unrelated messages are grouped together while
> > > threads are broken apart, making discussions harder to follow.
> > > 3. In email I don't get a threaded view. If I go to mailing list archives
> > > to see a threaded view, I can't reply.
> >
> > Just use NNTP (gmane.comp.lang.rust.devel on news.gmane.org). Most
> > newsreader support threaded view (Thunderbird does). You can configure the
> > mailing list s.t. mails are not actually delivered to your email address
> > even if you are registered.
> >
> > But looking at your email address you are already using gmane.
> 
> I'm using gmail; I have never used gmane and know nothing about it. I also don't have or use an email client or a newsreader. And there are lots of people like me.

Gmail has the ability to file mailing list messages into a label and out of the inbox. I recommend doing this for any mailing list that has more than one post per day. You can then click on the label to peruse the list.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/bb6d8a27/attachment.html>

From slabode at aim.com  Tue Dec  3 12:21:45 2013
From: slabode at aim.com (SiegeLord)
Date: Tue, 03 Dec 2013 15:21:45 -0500
Subject: [rust-dev] Rust front-end to GCC
In-Reply-To: <CAK9U+m01-uOs+dViNBXwgGthPwkoWNFiXnDCkJ5P+Qs_1oVjRg@mail.gmail.com>
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
	<CA+DvKQKLEuDG_C880fWR3YgCb1fkVS-L42eXeGpNFxK3zS8FJw@mail.gmail.com>
	<CAAvrL-=_R7-rmGhuzAegJfWYjpO10emNWAOWZe2T8hT3pKyCmg@mail.gmail.com>
	<CAK9U+m01-uOs+dViNBXwgGthPwkoWNFiXnDCkJ5P+Qs_1oVjRg@mail.gmail.com>
Message-ID: <529E3D59.9060707@aim.com>

On 12/03/2013 02:02 PM, Val Markovic wrote:
> Agreed with Daniel. The D approach would be best. They one frontend and
> then dmd (frontend + proprietary backend), ldc (frontend + llvm) and gdc
> (frontend + gcc backends) use that. This would be the best for the Rust
> ecosystem, users and developers of the various compilers; there's no
> duplication of efforts and critically, very few compiler-specific bugs.
> One can reasonably assume that any code written for dmd will work with
> ldc and gdc.

LDC and GDC do not use the same frontend by choice, but because 
historically every attempt to create a new D frontend has failed to bear 
fruit (SDC and DIL) in part because of a lack of a concrete 
specification and the resultant lack of clarity of how exactly some code 
should work. The reliance (over-reliance in my opinion) on the DMD 
frontend resulted in a lack of focus on creating a good language 
specification which to this day results in debates about what exactly 
constitutes a language change and what constitutes a bug fix.

> Multiple independent compilers would require a common, detailed spec to
> reach any level of interoperability. That comes with its own costs and
> complexities and IMO I don't think they're worth it.

A new frontend implementation can motivate and help the writing of the 
spec to begin with, assuming Philip is willing to keep implementation 
notes as he goes along.

-SL

From thadguidry at gmail.com  Tue Dec  3 12:32:23 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 3 Dec 2013 14:32:23 -0600
Subject: [rust-dev] Rust forum
In-Reply-To: <0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
Message-ID: <CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>

Kevin is correct.

Where the real issue is that of knowing the capabilities of your particular
mail client and maximizing it to gain forum-like features.

Many folks use or prefer an online mail client that offers threading,
labels, archival search, etc.  Which are all the same features of a forum
that is proposed.

My suggestion would be instead of jumping to a forum... simply learn about
or find a more full featured mail client if you can.
If you cannot, then perhaps Gmane could benefit you in the same way.

Users benefit from the developers list and vice-versa... splitting us apart
would not be a wise choice.
-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/635ef909/attachment.html>

From martindemello at gmail.com  Tue Dec  3 12:41:55 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Tue, 3 Dec 2013 12:41:55 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
Message-ID: <CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>

On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com> wrote:

> Users benefit from the developers list and vice-versa... splitting us
> apart would not be a wise choice.
>

the only downside is that people are reluctant to ask newbie user questions
on a list where people are talking about hacking on the compiler.

martin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/4cea6499/attachment.html>

From denis.spir at gmail.com  Tue Dec  3 13:14:16 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 03 Dec 2013 22:14:16 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
Message-ID: <529E49A8.80901@gmail.com>

On 12/03/2013 09:41 PM, Martin DeMello wrote:
> On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>
>> Users benefit from the developers list and vice-versa... splitting us
>> apart would not be a wise choice.
>>
>
> the only downside is that people are reluctant to ask newbie user questions
> on a list where people are talking about hacking on the compiler.

Very true.

Denis

From gaetan at xeberon.net  Tue Dec  3 13:58:19 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 3 Dec 2013 22:58:19 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
Message-ID: <CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>

Sorry but that is a pretty bad answer. You cannot tell people to change
their favorite email client just for rust-dev.

You cannot do the same with you client, just because each one will have to
set its own set of rules to tag, ...

Gmail is a pretty good client, but you have to remember the golden rules of
email: email is forgotten once it is read. And you cannot search on emails
you havent received...

Self hosted forum is good, a good rust management in stack overflow is much
better. If you know better sites, why not making some experiment and then
vote for the better one.

G.
Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com> a ?crit :

> Kevin is correct.
>
> Where the real issue is that of knowing the capabilities of your
> particular mail client and maximizing it to gain forum-like features.
>
> Many folks use or prefer an online mail client that offers threading,
> labels, archival search, etc.  Which are all the same features of a forum
> that is proposed.
>
> My suggestion would be instead of jumping to a forum... simply learn about
> or find a more full featured mail client if you can.
> If you cannot, then perhaps Gmane could benefit you in the same way.
>
> Users benefit from the developers list and vice-versa... splitting us
> apart would not be a wise choice.
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/596f452f/attachment.html>

From martindemello at gmail.com  Tue Dec  3 14:01:05 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Tue, 3 Dec 2013 14:01:05 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
Message-ID: <CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>

keeping up with email is a lot easier than pretty much everything else,
though. the solution to keeping old messages around is mirroring the
mailing list to a searchable archive, not moving to a forum en masse and
sacrificing ease-of-conversation for ease-of-recall.

martin


On Tue, Dec 3, 2013 at 1:58 PM, Gaetan <gaetan at xeberon.net> wrote:

> Sorry but that is a pretty bad answer. You cannot tell people to change
> their favorite email client just for rust-dev.
>
> You cannot do the same with you client, just because each one will have to
> set its own set of rules to tag, ...
>
> Gmail is a pretty good client, but you have to remember the golden rules
> of email: email is forgotten once it is read. And you cannot search on
> emails you havent received...
>
> Self hosted forum is good, a good rust management in stack overflow is
> much better. If you know better sites, why not making some experiment and
> then vote for the better one.
>
> G.
> Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com> a ?crit :
>
>> Kevin is correct.
>>
>> Where the real issue is that of knowing the capabilities of your
>> particular mail client and maximizing it to gain forum-like features.
>>
>> Many folks use or prefer an online mail client that offers threading,
>> labels, archival search, etc.  Which are all the same features of a forum
>> that is proposed.
>>
>> My suggestion would be instead of jumping to a forum... simply learn
>> about or find a more full featured mail client if you can.
>> If you cannot, then perhaps Gmane could benefit you in the same way.
>>
>> Users benefit from the developers list and vice-versa... splitting us
>> apart would not be a wise choice.
>> --
>> -Thad
>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/cd4d1fc3/attachment.html>

From gaetan at xeberon.net  Tue Dec  3 14:20:27 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 3 Dec 2013 23:20:27 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
Message-ID: <CANK7tAHkfZJ3564M=OpMbrD7X1SLgq3Sj0mXej=Kobirig_m0g@mail.gmail.com>

I also agree to split in rust-user for newbee question, but i hope good
programmers will go a bit on this ml...
Le 3 d?c. 2013 21:42, "Martin DeMello" <martindemello at gmail.com> a ?crit :

> On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com> wrote:
>
>> Users benefit from the developers list and vice-versa... splitting us
>> apart would not be a wise choice.
>>
>
> the only downside is that people are reluctant to ask newbie user
> questions on a list where people are talking about hacking on the compiler.
>
> martin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/da4affc3/attachment.html>

From thadguidry at gmail.com  Tue Dec  3 14:22:10 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 3 Dec 2013 16:22:10 -0600
Subject: [rust-dev] Rust forum
In-Reply-To: <CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
	<CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
Message-ID: <CAChbWaMkGGdDM1Ro8QJURfGw8VGOkgOBh2LCSjHR2KLbzPdRAA@mail.gmail.com>

Agreed with Martin.

It is my Opinion, but it might not be a good answer for you.

If the problem space is having a searchable mailing list archive... I think
we already have that in place,  Right Brian ?



On Tue, Dec 3, 2013 at 4:01 PM, Martin DeMello <martindemello at gmail.com>wrote:

> keeping up with email is a lot easier than pretty much everything else,
> though. the solution to keeping old messages around is mirroring the
> mailing list to a searchable archive, not moving to a forum en masse and
> sacrificing ease-of-conversation for ease-of-recall.
>
> martin
>
>
> On Tue, Dec 3, 2013 at 1:58 PM, Gaetan <gaetan at xeberon.net> wrote:
>
>> Sorry but that is a pretty bad answer. You cannot tell people to change
>> their favorite email client just for rust-dev.
>>
>> You cannot do the same with you client, just because each one will have
>> to set its own set of rules to tag, ...
>>
>> Gmail is a pretty good client, but you have to remember the golden rules
>> of email: email is forgotten once it is read. And you cannot search on
>> emails you havent received...
>>
>> Self hosted forum is good, a good rust management in stack overflow is
>> much better. If you know better sites, why not making some experiment and
>> then vote for the better one.
>>
>> G.
>> Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com> a ?crit :
>>
>>>  Kevin is correct.
>>>
>>> Where the real issue is that of knowing the capabilities of your
>>> particular mail client and maximizing it to gain forum-like features.
>>>
>>> Many folks use or prefer an online mail client that offers threading,
>>> labels, archival search, etc.  Which are all the same features of a forum
>>> that is proposed.
>>>
>>> My suggestion would be instead of jumping to a forum... simply learn
>>> about or find a more full featured mail client if you can.
>>> If you cannot, then perhaps Gmane could benefit you in the same way.
>>>
>>> Users benefit from the developers list and vice-versa... splitting us
>>> apart would not be a wise choice.
>>> --
>>> -Thad
>>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>


-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/f08d789b/attachment-0001.html>

From martindemello at gmail.com  Tue Dec  3 14:32:21 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Tue, 3 Dec 2013 14:32:21 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CANK7tAHkfZJ3564M=OpMbrD7X1SLgq3Sj0mXej=Kobirig_m0g@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
	<CANK7tAHkfZJ3564M=OpMbrD7X1SLgq3Sj0mXej=Kobirig_m0g@mail.gmail.com>
Message-ID: <CAFrFfuE1TUCKRs8Y82oFy-VdKrJtYrLo8PiAH0pTUADHC450Vg@mail.gmail.com>

In practice this has worked out well for the ocaml community - there's an
ocaml-beginners mailing list that gets a small amount of traffic, but very
quick responses from a lot of the more experienced people on the list.

martin


On Tue, Dec 3, 2013 at 2:20 PM, Gaetan <gaetan at xeberon.net> wrote:

> I also agree to split in rust-user for newbee question, but i hope good
> programmers will go a bit on this ml...
> Le 3 d?c. 2013 21:42, "Martin DeMello" <martindemello at gmail.com> a ?crit :
>
>> On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com>wrote:
>>
>>> Users benefit from the developers list and vice-versa... splitting us
>>> apart would not be a wise choice.
>>>
>>
>> the only downside is that people are reluctant to ask newbie user
>> questions on a list where people are talking about hacking on the compiler.
>>
>> martin
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/ee561288/attachment.html>

From corey at octayn.net  Tue Dec  3 16:19:34 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 3 Dec 2013 19:19:34 -0500
Subject: [rust-dev] Rust forum
In-Reply-To: <CAFrFfuE1TUCKRs8Y82oFy-VdKrJtYrLo8PiAH0pTUADHC450Vg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
	<CANK7tAHkfZJ3564M=OpMbrD7X1SLgq3Sj0mXej=Kobirig_m0g@mail.gmail.com>
	<CAFrFfuE1TUCKRs8Y82oFy-VdKrJtYrLo8PiAH0pTUADHC450Vg@mail.gmail.com>
Message-ID: <CA++BO6TYWahPF3211Kk-pN88iUWRJvgwG4ixTojpSoyUxEgCjg@mail.gmail.com>

Very well for the Python community, too; there's a python-tutor list
whose sole focus is helping newbies effectively.

On Tue, Dec 3, 2013 at 5:32 PM, Martin DeMello <martindemello at gmail.com> wrote:
> In practice this has worked out well for the ocaml community - there's an
> ocaml-beginners mailing list that gets a small amount of traffic, but very
> quick responses from a lot of the more experienced people on the list.
>
> martin
>
>
> On Tue, Dec 3, 2013 at 2:20 PM, Gaetan <gaetan at xeberon.net> wrote:
>>
>> I also agree to split in rust-user for newbee question, but i hope good
>> programmers will go a bit on this ml...
>>
>> Le 3 d?c. 2013 21:42, "Martin DeMello" <martindemello at gmail.com> a ?crit :
>>>
>>> On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com>
>>> wrote:
>>>>
>>>> Users benefit from the developers list and vice-versa... splitting us
>>>> apart would not be a wise choice.
>>>
>>>
>>> the only downside is that people are reluctant to ask newbie user
>>> questions on a list where people are talking about hacking on the compiler.
>>>
>>> martin
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From val at markovic.io  Tue Dec  3 16:20:01 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 3 Dec 2013 16:20:01 -0800
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CA+DvKQKwoTKa=fijLTmtKL-Vk-pZOo1sJ+gBJDWevCEKEqX10w@mail.gmail.com>
References: <529A3174.8060701@hyc.io>
	<CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>
	<529B989E.9080509@hyc.io>
	<CAN1rdExraX=NJcsJhAKePoUYWo13XZf_0_Fe20PKw5eUoyd77g@mail.gmail.com>
	<529BA8E8.2060503@gmail.com> <529BAB2E.6010603@hyc.io>
	<CA+DvKQKwoTKa=fijLTmtKL-Vk-pZOo1sJ+gBJDWevCEKEqX10w@mail.gmail.com>
Message-ID: <CAK9U+m29=P5EnQdSjupRMoL=LTeBHszoDcyczgBAiycRosbprQ@mail.gmail.com>

On Sun, Dec 1, 2013 at 1:43 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> Ranges are a more
> modern implementation of iterators and are much more easily composed.
> Ranges are also trivially memory safe, and I doubt that split
> current/end iterators can provide memory safety with only references.
>

Agreed with Daniel. The C++ community has by and large reached the
conclusion that ranges are a much better idea than iterators. Boost.Range
is commonly recommended. There's also talk about getting ranges into the
C++ standard; see
N3350<http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html>for
an example.

Let's not make the same mistake in Rust that C++ is now struggling to fix.


> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/0d100366/attachment.html>

From com.liigo at gmail.com  Tue Dec  3 16:23:15 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 4 Dec 2013 08:23:15 +0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
Message-ID: <CAH8Jz7iffBAjfWrKCr72TaQCTPpLK5teA=aSRyLH2TCaZfrjQg@mail.gmail.com>

+1
? 2013?12?4? ??5:58?"Gaetan" <gaetan at xeberon.net>???

> Sorry but that is a pretty bad answer. You cannot tell people to change
> their favorite email client just for rust-dev.
>
> You cannot do the same with you client, just because each one will have to
> set its own set of rules to tag, ...
>
> Gmail is a pretty good client, but you have to remember the golden rules
> of email: email is forgotten once it is read. And you cannot search on
> emails you havent received...
>
> Self hosted forum is good, a good rust management in stack overflow is
> much better. If you know better sites, why not making some experiment and
> then vote for the better one.
>
> G.
> Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com> a ?crit :
>
>> Kevin is correct.
>>
>> Where the real issue is that of knowing the capabilities of your
>> particular mail client and maximizing it to gain forum-like features.
>>
>> Many folks use or prefer an online mail client that offers threading,
>> labels, archival search, etc.  Which are all the same features of a forum
>> that is proposed.
>>
>> My suggestion would be instead of jumping to a forum... simply learn
>> about or find a more full featured mail client if you can.
>> If you cannot, then perhaps Gmane could benefit you in the same way.
>>
>> Users benefit from the developers list and vice-versa... splitting us
>> apart would not be a wise choice.
>> --
>> -Thad
>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/1c1d8a0a/attachment.html>

From bob at redivi.com  Tue Dec  3 16:38:46 2013
From: bob at redivi.com (Bob Ippolito)
Date: Tue, 3 Dec 2013 16:38:46 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CA++BO6TYWahPF3211Kk-pN88iUWRJvgwG4ixTojpSoyUxEgCjg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CAFrFfuF9fWjNcAAvxoEeAOYe99Afmd6YbQBW+ya6cQ==a1h5rg@mail.gmail.com>
	<CANK7tAHkfZJ3564M=OpMbrD7X1SLgq3Sj0mXej=Kobirig_m0g@mail.gmail.com>
	<CAFrFfuE1TUCKRs8Y82oFy-VdKrJtYrLo8PiAH0pTUADHC450Vg@mail.gmail.com>
	<CA++BO6TYWahPF3211Kk-pN88iUWRJvgwG4ixTojpSoyUxEgCjg@mail.gmail.com>
Message-ID: <CACwMPm_4Oo-hHCjG-DG-cGSKvjGgdKaMZpFZ=zpJasaF9yxvrQ@mail.gmail.com>

Haskell has haskell-beginners, which also seems to be working.


On Tue, Dec 3, 2013 at 4:19 PM, Corey Richardson <corey at octayn.net> wrote:

> Very well for the Python community, too; there's a python-tutor list
> whose sole focus is helping newbies effectively.
>
> On Tue, Dec 3, 2013 at 5:32 PM, Martin DeMello <martindemello at gmail.com>
> wrote:
> > In practice this has worked out well for the ocaml community - there's an
> > ocaml-beginners mailing list that gets a small amount of traffic, but
> very
> > quick responses from a lot of the more experienced people on the list.
> >
> > martin
> >
> >
> > On Tue, Dec 3, 2013 at 2:20 PM, Gaetan <gaetan at xeberon.net> wrote:
> >>
> >> I also agree to split in rust-user for newbee question, but i hope good
> >> programmers will go a bit on this ml...
> >>
> >> Le 3 d?c. 2013 21:42, "Martin DeMello" <martindemello at gmail.com> a
> ?crit :
> >>>
> >>> On Tue, Dec 3, 2013 at 12:32 PM, Thad Guidry <thadguidry at gmail.com>
> >>> wrote:
> >>>>
> >>>> Users benefit from the developers list and vice-versa... splitting us
> >>>> apart would not be a wise choice.
> >>>
> >>>
> >>> the only downside is that people are reluctant to ask newbie user
> >>> questions on a list where people are talking about hacking on the
> compiler.
> >>>
> >>> martin
> >>>
> >>> _______________________________________________
> >>> Rust-dev mailing list
> >>> Rust-dev at mozilla.org
> >>> https://mail.mozilla.org/listinfo/rust-dev
> >>>
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/1151df25/attachment-0001.html>

From comexk at gmail.com  Tue Dec  3 17:23:21 2013
From: comexk at gmail.com (comex)
Date: Tue, 3 Dec 2013 20:23:21 -0500
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
Message-ID: <CAPM5UJ1VbzPUvfB5u7rC8-fSw8Y4badeTCtO0ODZ16xbqryG7w@mail.gmail.com>

On Tue, Dec 3, 2013 at 3:07 PM, David Piepgrass <qwertie256 at gmail.com> wrote:
> I'm using gmail

In Gmail, putting messages from the list in their own label and
skipping the inbox is just a matter of 'More -> Filter messages like
these' and a few clicks; Gmail displays messages in a flat
conversation view rather than true nested threading, but Discourse
does the same.  So I don't really understand your points...

From banderson at mozilla.com  Tue Dec  3 17:36:49 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 03 Dec 2013 17:36:49 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAChbWaMkGGdDM1Ro8QJURfGw8VGOkgOBh2LCSjHR2KLbzPdRAA@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>	<CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
	<CAChbWaMkGGdDM1Ro8QJURfGw8VGOkgOBh2LCSjHR2KLbzPdRAA@mail.gmail.com>
Message-ID: <529E8731.5000004@mozilla.com>

On 12/03/2013 02:22 PM, Thad Guidry wrote:
> Agreed with Martin.
>
> It is my Opinion, but it might not be a good answer for you.
>
> If the problem space is having a searchable mailing list archive... I 
> think we already have that in place,  Right Brian ?

I actually don't know how to search the rust-dev archives without 
Google's help...


>
>
>
> On Tue, Dec 3, 2013 at 4:01 PM, Martin DeMello 
> <martindemello at gmail.com <mailto:martindemello at gmail.com>> wrote:
>
>     keeping up with email is a lot easier than pretty much everything
>     else, though. the solution to keeping old messages around is
>     mirroring the mailing list to a searchable archive, not moving to
>     a forum en masse and sacrificing ease-of-conversation for
>     ease-of-recall.
>
>     martin
>
>
>     On Tue, Dec 3, 2013 at 1:58 PM, Gaetan <gaetan at xeberon.net
>     <mailto:gaetan at xeberon.net>> wrote:
>
>         Sorry but that is a pretty bad answer. You cannot tell people
>         to change their favorite email client just for rust-dev.
>
>         You cannot do the same with you client, just because each one
>         will have to set its own set of rules to tag, ...
>
>         Gmail is a pretty good client, but you have to remember the
>         golden rules of email: email is forgotten once it is read. And
>         you cannot search on emails you havent received...
>
>         Self hosted forum is good, a good rust management in stack
>         overflow is much better. If you know better sites, why not
>         making some experiment and then vote for the better one.
>
>         G.
>
>         Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com
>         <mailto:thadguidry at gmail.com>> a ?crit :
>
>             Kevin is correct.
>
>             Where the real issue is that of knowing the capabilities
>             of your particular mail client and maximizing it to gain
>             forum-like features.
>
>             Many folks use or prefer an online mail client that offers
>             threading, labels, archival search, etc.  Which are all
>             the same features of a forum that is proposed.
>
>             My suggestion would be instead of jumping to a forum...
>             simply learn about or find a more full featured mail
>             client if you can.
>             If you cannot, then perhaps Gmane could benefit you in the
>             same way.
>
>             Users benefit from the developers list and vice-versa...
>             splitting us apart would not be a wise choice.
>             -- 
>             -Thad
>             +ThadGuidry <https://www.google.com/+ThadGuidry>
>             Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
>             _______________________________________________
>             Rust-dev mailing list
>             Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>             https://mail.mozilla.org/listinfo/rust-dev
>
>
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
>
> -- 
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/6aac31c6/attachment.html>

From me at kevincantu.org  Tue Dec  3 17:57:23 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Tue, 3 Dec 2013 17:57:23 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <529E8731.5000004@mozilla.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>
	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>
	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>
	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
	<CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
	<CAChbWaMkGGdDM1Ro8QJURfGw8VGOkgOBh2LCSjHR2KLbzPdRAA@mail.gmail.com>
	<529E8731.5000004@mozilla.com>
Message-ID: <CABq6+afY3eCma=kY4hum6LRO25UO3D=bDY9vZBrFWUaRvzNDeQ@mail.gmail.com>

I've never used a message board which I could search without Google's
help, either.  ArsTechnica's search was chronically broken for like a
decade, for example.  :D


Kevin

On Tue, Dec 3, 2013 at 5:36 PM, Brian Anderson <banderson at mozilla.com> wrote:
> On 12/03/2013 02:22 PM, Thad Guidry wrote:
>
> Agreed with Martin.
>
> It is my Opinion, but it might not be a good answer for you.
>
> If the problem space is having a searchable mailing list archive... I think
> we already have that in place,  Right Brian ?
>
>
> I actually don't know how to search the rust-dev archives without Google's
> help...
>
>
>
>
>
>
> On Tue, Dec 3, 2013 at 4:01 PM, Martin DeMello <martindemello at gmail.com>
> wrote:
>>
>> keeping up with email is a lot easier than pretty much everything else,
>> though. the solution to keeping old messages around is mirroring the mailing
>> list to a searchable archive, not moving to a forum en masse and sacrificing
>> ease-of-conversation for ease-of-recall.
>>
>> martin
>>
>>
>> On Tue, Dec 3, 2013 at 1:58 PM, Gaetan <gaetan at xeberon.net> wrote:
>>>
>>> Sorry but that is a pretty bad answer. You cannot tell people to change
>>> their favorite email client just for rust-dev.
>>>
>>> You cannot do the same with you client, just because each one will have
>>> to set its own set of rules to tag, ...
>>>
>>> Gmail is a pretty good client, but you have to remember the golden rules
>>> of email: email is forgotten once it is read. And you cannot search on
>>> emails you havent received...
>>>
>>> Self hosted forum is good, a good rust management in stack overflow is
>>> much better. If you know better sites, why not making some experiment and
>>> then vote for the better one.
>>>
>>> G.
>>>
>>> Le 3 d?c. 2013 21:32, "Thad Guidry" <thadguidry at gmail.com> a ?crit :
>>>>
>>>> Kevin is correct.
>>>>
>>>> Where the real issue is that of knowing the capabilities of your
>>>> particular mail client and maximizing it to gain forum-like features.
>>>>
>>>> Many folks use or prefer an online mail client that offers threading,
>>>> labels, archival search, etc.  Which are all the same features of a forum
>>>> that is proposed.
>>>>
>>>> My suggestion would be instead of jumping to a forum... simply learn
>>>> about or find a more full featured mail client if you can.
>>>> If you cannot, then perhaps Gmane could benefit you in the same way.
>>>>
>>>> Users benefit from the developers list and vice-versa... splitting us
>>>> apart would not be a wise choice.
>>>> --
>>>> -Thad
>>>> +ThadGuidry
>>>> Thad on LinkedIn
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>
>
>
> --
> -Thad
> +ThadGuidry
> Thad on LinkedIn
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From ben.striegel at gmail.com  Tue Dec  3 19:11:51 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 3 Dec 2013 22:11:51 -0500
Subject: [rust-dev] How to search the mailing list archives
Message-ID: <CAAvrL-kUke_UXx4w3BxMSwQRpM=btwLVJZB5F5-+yZVQ=h852A@mail.gmail.com>

Apparently even Brian doesn't know how to do this, so I figured I'd share
this tip.

The rust-dev mailing list is archived here:

http://thread.gmane.org/gmane.comp.lang.rust.devel/

Use the search box at the bottom to search through the mailing list's
archives since the beginning of time.

When you click on a result, you will end up on a page like this:

http://article.gmane.org/gmane.comp.lang.rust.devel/6778/match=dst

...which is pretty terrible from a navigation standpoint. But in that URL
you can manually change the "article" bit on the front to "thread", to
yield this:

http://thread.gmane.org/gmane.comp.lang.rust.devel/6778/match=dst

...which will let you easily browse a full conversation.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/d723fa82/attachment.html>

From illissius at gmail.com  Tue Dec  3 20:01:56 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 4 Dec 2013 05:01:56 +0100
Subject: [rust-dev] Distilled essence of placement new
Message-ID: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>

Prompted by the recent discussion about the syntax to use for placement
new, I took a few steps back to think about the bigger picture. I'm glad I
did, because I now think that the important part of the feature has been
misidentified so far, and correctly identifying it opens the door to a much
more general and powerful mechanism, with a smaller conceptual "surface
area", and whose implementation burden doesn't appear any larger than that
of the placement new feature as up-to-now envisioned (in particular, the
magic sauce is the same in both).


## What is placement new?

The C++ syntax for "placement new" is: `new (place) MyType(args...)`, where
place is a memory address. This constructs a new instance of `MyType` into
`place`. This is useful because it lets you avoid the overhead of first
constructing the `MyType` elsewhere and then copying or moving it into
`place`.

I used to think that placement new is not commonly used in C++, but I have
revised my opinion. As Daniel Micay reminded me of in the other thread, C++
now has things like `emplace_back` in many places which use placement new
under the hood to avoid the cost of a move. The reason C++ didn't
*previously* use placement new very often is that the lack of perfect
forwarding and variadic templates made doing so in a generic way way too
painful.

This is also one of the things that got me thinking: restricting our
version of placement new to smart pointers seems artificial and not very
well-motivated, except if by the fact that smart pointers are an important
use case and the built-in ones already have the feature. But we also want
`emplace_back`, don't we?


## What is placement new, *really*?

The C++ signature of `emplace_back` is:

    template<typename T> // I'm ignoring the allocator
    template<typename... Args>
    void vector<T>::emplace_back(Args&&... args);

What it does is reserve some memory at the end of the vector, then use
placement new to invoke the constructor of `T`, with `args`, into that
memory. How could we translate this to Rust? First of all, Rust doesn't
have constructors as a distinguished language feature. But a constructor is
not anything more than a function statically known based on a type: in
Rust, a (self-less) trait method. Rust doesn't have variadic templates
either, but we could use tuples. (As for perfect forwarding, I suspect it
solves a problem Rust doesn't have.) So then we have:

    trait Construct<Args> {
        fn construct(Args) -> Self;
    }

    fn emplace_back<Args, T: Construct<Args>>(self: &mut Vec<T>, args:
Args);

So in reality, placement new is nothing more than a statically dispatched
trait method call. The only reason C++ needs special syntax for it is
because C++ distinguishes constructors from other functions. In particular,
it's worth noticing that if C++'s functions use a hidden out-pointer
argument like Rust's functions do, then the C++ version of `emplace_back`
could just as well take a function pointer returning `T` as a non-type
template parameter, and call that instead of T's constructor. (Except C++
doesn't let you make a function pointer to a constructor either, so you
would still want both versions. C++'s complications are of its own design.)

(It's also worth noticing that C++ is using the same
pass-the-environment-explicitly encoding of closures here that Rust
occasionally does.)


## Magic sauce

All of that begs a question: if placement new is not much more than calling
a trait method, then why are we in the process of adding placement new? If
what we're adding isn't placement new, then what *is* it? Well: we *could*
use something like the above Rust version of `emplace_back`, but it would
be super-tedious. Right now if you write `~(this thing)` or `@(that
thing)`, this thing and that thing are constructed (placement newed)
directly into the allocated memory -- where this thing and that thing can
be any expression. That's really nice. We want other smart pointers to be
able to do that.

How does it work? If this thing or that thing is a function call, then the
out-pointer is set to the allocated memory. If it's an expression, then the
compiler emits code to put the result of the expression directly into the
memory. Without having direct knowledge, I imagine that's the same way it's
planned to work for other smart pointers. (I can't imagine any other way to
do it.) What this implies is that the function that allocates the memory is
monomorphized (has a separate version generated) not only on the type of
the object being constructed, but also on the specific expression
constructing it. This is no different from what happens with the current
built-in smart pointers, where the compiler has built-in special-cased code
generation for them. It's also no different from C++'s `emplace_back`,
except there the possible "expressions" are limited to the constructors
available for the type. (If you consider the hypothetical version passing a
function pointer as a template argument, then the number of possibilities
is again much larger.)

So what we're adding is this ability to monomorphize user-provided
functions (smart pointer constructors) on the expression provided as their
argument.


## Proposal

Given that we're adding this magic one way or another, I propose to make it
more generally available. Rather than restrict it to smart pointer
constructors, tied in to the compiler with some kind of built-in trait,
let's let *any* function use it: let them declare that any particular
argument is to be passed "by-expression" in this way, by monomorphizing the
function over it. To avoid duplicating side effects and such, in the body
of the function, this argument may only be used once (which already holds
in the case of things like smart pointer constructors and `emplace_back`).
(So it's kind of like call-by-name, except it happens statically and can
only be called once.)

With regards to syntax, I don't have any ideas yet that I'm particularly
satisfied with. Here are some ideas:

    fn new_gc<T>(x: expr T) -> Gc<T>;

    fn new_gc<T, Exp: expr T>(x: Exp) -> Gc<T>;

    fn new_gc<T, static x: expr T>(x) -> Gc<T>;

It's difficult because the expression parameter wants to be passed both
between `<>`, because it's passed at compile time and leads to
monomorphization, and also between `()`, because that's where the
programmer actually writes the argument when calling it. I think I like the
second possibility best so far: in that case you can interpret it as
working with inference like type parameters do. (But I don't even know
whether or not there might be other good possibilities besides an `expr`
keyword, as in all three of these.)


Anyways, upshot:

 * Instead of being a restricted subset of C++, our "placement new" ability
becomes much broader and more convenient than C++

 * We no longer need special "placement new" syntax, and can keep writing
`Gc::new(some thing)`, because the magic is moved to the callee

 * In exchange, we do need special syntax in the callee, so bikeshed
painters will not have their employment prospects diminished.


Thanks for reading:
G?bor

-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/920ae2f7/attachment-0001.html>

From danielmicay at gmail.com  Tue Dec  3 20:05:45 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 3 Dec 2013 23:05:45 -0500
Subject: [rust-dev] Distilled essence of placement new
In-Reply-To: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
References: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
Message-ID: <CA+DvKQLO2JjjPsjHqvNaEv-gSEBMGYE8GadxpCg0N_71PCaTsA@mail.gmail.com>

This looks a lot like what stack once functions would provide.

From illissius at gmail.com  Tue Dec  3 20:10:32 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 4 Dec 2013 05:10:32 +0100
Subject: [rust-dev] Distilled essence of placement new
In-Reply-To: <CA+DvKQLO2JjjPsjHqvNaEv-gSEBMGYE8GadxpCg0N_71PCaTsA@mail.gmail.com>
References: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
	<CA+DvKQLO2JjjPsjHqvNaEv-gSEBMGYE8GadxpCg0N_71PCaTsA@mail.gmail.com>
Message-ID: <CAPNUp0-a0optb4bpp5=AsFq690mm2NfPKrW5G+Ktyme6p=KZVg@mail.gmail.com>

Yes, that was one of the things that passed through my mind as well. One
difference is that those are passed at runtime, whereas here everything
happens at compile time. I remember LLVM had difficulty reliably optimizing
runtime closure passing code, like with the old iterators.


On Wed, Dec 4, 2013 at 5:05 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> This looks a lot like what stack once functions would provide.
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/cc86d5c6/attachment.html>

From pwalton at mozilla.com  Tue Dec  3 20:13:26 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Tue, 03 Dec 2013 20:13:26 -0800
Subject: [rust-dev] Distilled essence of placement new
In-Reply-To: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
References: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
Message-ID: <8f5caf0b-6970-4190-9993-d030e9fd64d2@email.android.com>

Placement new does support "emplace_back". You'd write "box(my_array.in_back()) value", where "in_back" returns a special allocator value that implements the placement new trait.

Having functions that can change the evaluation order of their arguments feels too magical to me. Almost fexpr-ish.

Patrick

"G?bor Lehel" <illissius at gmail.com> wrote:
>Prompted by the recent discussion about the syntax to use for placement
>new, I took a few steps back to think about the bigger picture. I'm
>glad I
>did, because I now think that the important part of the feature has
>been
>misidentified so far, and correctly identifying it opens the door to a
>much
>more general and powerful mechanism, with a smaller conceptual "surface
>area", and whose implementation burden doesn't appear any larger than
>that
>of the placement new feature as up-to-now envisioned (in particular,
>the
>magic sauce is the same in both).
>
>
>## What is placement new?
>
>The C++ syntax for "placement new" is: `new (place) MyType(args...)`,
>where
>place is a memory address. This constructs a new instance of `MyType`
>into
>`place`. This is useful because it lets you avoid the overhead of first
>constructing the `MyType` elsewhere and then copying or moving it into
>`place`.
>
>I used to think that placement new is not commonly used in C++, but I
>have
>revised my opinion. As Daniel Micay reminded me of in the other thread,
>C++
>now has things like `emplace_back` in many places which use placement
>new
>under the hood to avoid the cost of a move. The reason C++ didn't
>*previously* use placement new very often is that the lack of perfect
>forwarding and variadic templates made doing so in a generic way way
>too
>painful.
>
>This is also one of the things that got me thinking: restricting our
>version of placement new to smart pointers seems artificial and not
>very
>well-motivated, except if by the fact that smart pointers are an
>important
>use case and the built-in ones already have the feature. But we also
>want
>`emplace_back`, don't we?
>
>
>## What is placement new, *really*?
>
>The C++ signature of `emplace_back` is:
>
>    template<typename T> // I'm ignoring the allocator
>    template<typename... Args>
>    void vector<T>::emplace_back(Args&&... args);
>
>What it does is reserve some memory at the end of the vector, then use
>placement new to invoke the constructor of `T`, with `args`, into that
>memory. How could we translate this to Rust? First of all, Rust doesn't
>have constructors as a distinguished language feature. But a
>constructor is
>not anything more than a function statically known based on a type: in
>Rust, a (self-less) trait method. Rust doesn't have variadic templates
>either, but we could use tuples. (As for perfect forwarding, I suspect
>it
>solves a problem Rust doesn't have.) So then we have:
>
>    trait Construct<Args> {
>        fn construct(Args) -> Self;
>    }
>
>    fn emplace_back<Args, T: Construct<Args>>(self: &mut Vec<T>, args:
>Args);
>
>So in reality, placement new is nothing more than a statically
>dispatched
>trait method call. The only reason C++ needs special syntax for it is
>because C++ distinguishes constructors from other functions. In
>particular,
>it's worth noticing that if C++'s functions use a hidden out-pointer
>argument like Rust's functions do, then the C++ version of
>`emplace_back`
>could just as well take a function pointer returning `T` as a non-type
>template parameter, and call that instead of T's constructor. (Except
>C++
>doesn't let you make a function pointer to a constructor either, so you
>would still want both versions. C++'s complications are of its own
>design.)
>
>(It's also worth noticing that C++ is using the same
>pass-the-environment-explicitly encoding of closures here that Rust
>occasionally does.)
>
>
>## Magic sauce
>
>All of that begs a question: if placement new is not much more than
>calling
>a trait method, then why are we in the process of adding placement new?
>If
>what we're adding isn't placement new, then what *is* it? Well: we
>*could*
>use something like the above Rust version of `emplace_back`, but it
>would
>be super-tedious. Right now if you write `~(this thing)` or `@(that
>thing)`, this thing and that thing are constructed (placement newed)
>directly into the allocated memory -- where this thing and that thing
>can
>be any expression. That's really nice. We want other smart pointers to
>be
>able to do that.
>
>How does it work? If this thing or that thing is a function call, then
>the
>out-pointer is set to the allocated memory. If it's an expression, then
>the
>compiler emits code to put the result of the expression directly into
>the
>memory. Without having direct knowledge, I imagine that's the same way
>it's
>planned to work for other smart pointers. (I can't imagine any other
>way to
>do it.) What this implies is that the function that allocates the
>memory is
>monomorphized (has a separate version generated) not only on the type
>of
>the object being constructed, but also on the specific expression
>constructing it. This is no different from what happens with the
>current
>built-in smart pointers, where the compiler has built-in special-cased
>code
>generation for them. It's also no different from C++'s `emplace_back`,
>except there the possible "expressions" are limited to the constructors
>available for the type. (If you consider the hypothetical version
>passing a
>function pointer as a template argument, then the number of
>possibilities
>is again much larger.)
>
>So what we're adding is this ability to monomorphize user-provided
>functions (smart pointer constructors) on the expression provided as
>their
>argument.
>
>
>## Proposal
>
>Given that we're adding this magic one way or another, I propose to
>make it
>more generally available. Rather than restrict it to smart pointer
>constructors, tied in to the compiler with some kind of built-in trait,
>let's let *any* function use it: let them declare that any particular
>argument is to be passed "by-expression" in this way, by monomorphizing
>the
>function over it. To avoid duplicating side effects and such, in the
>body
>of the function, this argument may only be used once (which already
>holds
>in the case of things like smart pointer constructors and
>`emplace_back`).
>(So it's kind of like call-by-name, except it happens statically and
>can
>only be called once.)
>
>With regards to syntax, I don't have any ideas yet that I'm
>particularly
>satisfied with. Here are some ideas:
>
>    fn new_gc<T>(x: expr T) -> Gc<T>;
>
>    fn new_gc<T, Exp: expr T>(x: Exp) -> Gc<T>;
>
>    fn new_gc<T, static x: expr T>(x) -> Gc<T>;
>
>It's difficult because the expression parameter wants to be passed both
>between `<>`, because it's passed at compile time and leads to
>monomorphization, and also between `()`, because that's where the
>programmer actually writes the argument when calling it. I think I like
>the
>second possibility best so far: in that case you can interpret it as
>working with inference like type parameters do. (But I don't even know
>whether or not there might be other good possibilities besides an
>`expr`
>keyword, as in all three of these.)
>
>
>Anyways, upshot:
>
>* Instead of being a restricted subset of C++, our "placement new"
>ability
>becomes much broader and more convenient than C++
>
>* We no longer need special "placement new" syntax, and can keep
>writing
>`Gc::new(some thing)`, because the magic is moved to the callee
>
> * In exchange, we do need special syntax in the callee, so bikeshed
>painters will not have their employment prospects diminished.
>
>
>Thanks for reading:
>G?bor
>
>-- 
>Your ship was destroyed in a monadic eruption.
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/8ee81db2/attachment.html>

From pwalton at mozilla.com  Tue Dec  3 20:57:24 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Tue, 03 Dec 2013 20:57:24 -0800
Subject: [rust-dev] Distilled essence of placement new
In-Reply-To: <CAPNUp0-a0optb4bpp5=AsFq690mm2NfPKrW5G+Ktyme6p=KZVg@mail.gmail.com>
References: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
	<CA+DvKQLO2JjjPsjHqvNaEv-gSEBMGYE8GadxpCg0N_71PCaTsA@mail.gmail.com>
	<CAPNUp0-a0optb4bpp5=AsFq690mm2NfPKrW5G+Ktyme6p=KZVg@mail.gmail.com>
Message-ID: <acf1c1a2-e531-4432-bf5d-6fe8253996f5@email.android.com>

I should elaborate: I think you've successfully formulated placement new in terms of unboxed closures as monomorphized traits whose "call" method takes self by value. That is, something like (in Rust of the future):

    fn GC<T,F:OnceFunc<T>>(f: F) -> GC<T>

The difference, though, is that the construction of the closure is implicit at the call site in this proposal. This is what I'm uncomfortable with. Rust is a strict language, not a lazy one, and the order of evaluation of function arguments is one of the things that one has heretofore been unable to change. I would prefer that a different argument evaluation order would necessitate some sort of annotation at the call site (e.g. ocaml's "lazy"). But once you've done that you've essentially recreated something equivalent to placement new, but more verbose since you have to name a method when you allocate into an object (e.g. instead of "box(my_arena) foo" you'd have to write "my_arena.alloc(lazy foo)". I think we would end up wanting the sugar.

Patrick

"G?bor Lehel" <illissius at gmail.com> wrote:
>Yes, that was one of the things that passed through my mind as well.
>One
>difference is that those are passed at runtime, whereas here everything
>happens at compile time. I remember LLVM had difficulty reliably
>optimizing
>runtime closure passing code, like with the old iterators.
>
>
>On Wed, Dec 4, 2013 at 5:05 AM, Daniel Micay <danielmicay at gmail.com>
>wrote:
>
>> This looks a lot like what stack once functions would provide.
>>
>
>
>
>-- 
>Your ship was destroyed in a monadic eruption.
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/9cab3af5/attachment-0001.html>

From pnathan at vandals.uidaho.edu  Tue Dec  3 21:31:28 2013
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Tue, 3 Dec 2013 21:31:28 -0800
Subject: [rust-dev] Rust forum
In-Reply-To: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
References: <CAHuo6ZAhWaT_DvPmPJ8eCUJDfdPNDbOGFOz_AS2HuShsHz9fPg@mail.gmail.com>
Message-ID: <529EBE30.9090107@vandals.uidaho.edu>

Apologies for getting this reply late, but I had to run before I
finished this email. Replies inline and bottom-posted. ;-)

On 12/2/13 9:45 PM, David Piepgrass wrote:
> On 02/12/2013 16:21, David Piepgrass wrote:
> 
>     > That would be so. much. better. than a mailing list.
> 
>     Hi. Could you expand on this? I don?t necessarily disagree, but as the
>     one proposing change it?s up to you to convince everyone else :)
> 
>     --
>     Simon Sapin
> 
>  
> Okay, well, I've never liked mailing lists at all, because:
> 
> 1. In non-digest mode, My inbox gets flooded.
> 2. In digest mode, it's quite inconvenient to write a reply, having to
> cut out all the messages that I don't want to reply to and manually edit
> the subject line. Also, unrelated messages are grouped together while
> threads are broken apart, making discussions harder to follow.
> 3. In email I don't get a threaded view. If I go to mailing list
> archives to see a threaded view, I can't reply.
> 4. I have to manually watch for replies to my messages or to threads I'm
> following. If someone mentions my name (not that they would), I won't be
> notified.
> 

I respectfully suggest that you consider finding a new email client.
These are solved problems.

> In contrast, Discourse has a variety of email notification options. I
> don't know if those options are enough to please everybody, but you can
> probably configure it to notify you about all posts, which makes it
> essentially equivalent to a mailing list. It supports reply by email, so
> those that prefer a mailing list can still pretend it's a mailing list.
> Currently I'm getting an shrunk digest of Discourse Meta--by email I
> only get a subset of all messages, auto-selected by Discourse, whatever
> it thinks is interesting. That's good for me: I really don't want to see
> every message.
> 

Filters in a mail client address this.

> Plus, a mailing list offers less privacy as it mandates publishing your
> email address. That's not a big deal for me personally, but do you
> really want to require that from every Rust user?

A quite reasonable point, no doubt about it. I have chosen to use my
alumni email with my real name, but I recognize that others might choose
otherwise.

> 
> (btw, if I'm wrong about any of the above points, I promise there are
> lots of other netizens out there who have the same misconception(s), so
> many of them will avoid mailing lists. The fact that y'all are talking
> to me on a mailing list suggests that the disadvantages of a mailing
> list are not a big deal *to you*, but as for those who aren't
> participating, you can't conclude *they* prefer mailing lists.)

This is a classic "everyone else wants vs techie wants" argument. I
vastly prefer the techie approaches, as a rule of thumb. I personally
think that the techie desires should win for a while. Of course, many
other people (most, probably) disagree.

> 
> And like mailing lists, Discourse also supports private messages.

Unfortunately, these private messages are tied to the discourse system,
which, for all we know, might die. Email is a known medium with
(somewhat) portable archiving - both on the archive server and on the
personal computer(s).

> 
> I don't understand why Paul mentioned GPG. You want to encrypt messages
> to a public mailing list? You can sign messages, but surely almost no
> one actually checks the signature, and I'd be surprised if Discourse
> didn't offer some built-in evidence of identity (surely it's not like
> email in letting you spoof the sender name easily?).
> 

Again, this ties the communications into a third party system. Why *not*
let GPG sigs provide authentication?

> I heard discourse supports attachments, just that you may have to go to
> the forum to attach or download them (rather than by email).
> 

More grief I really don't want to deal with - figuring out how to attach
stuff in yet another interface. I am very happy with my Mozilla
Thunderbird!

Then the rust team have to consider how to store the attachments, manage
the discourse server, etc... Me, I'd rather see the Mozilla team focus
on Rust rather than server admin work.

> 
> 

Just for discussion -  example Discourse site: http://try.discourse.org/


I have generally been happy with Discourse search, overall - I don't
have any complaints with it.

Further problems with discourse in my experience:

Infinite scroll doesn't let you jump to page n of the board. I really
like being able to do that on mailing lists. I've used it to browse
archives from a decade ago by date n stuff. Perhaps I'm not expert at
the UI however.

Space inefficiency in heading sizes (maybe just out of the box, dunno).

User list avatar images on the posts scales sideways - not a good thing
when lots of people are contributing.


The discourse UI is very web 2.0 & 2010s-ish. That makes it visually
more attractive; but I still favor my email client Thunderbird & mailing
lists because they work & are the standard open source interface for
long-form discussion, without the downsides of web sites. I have search,
authentication (via gpg), threaded archives, separation of email.

I appreciate that in the long term, when the goal is wide adoption, the
humble open source mailing list so beloved by the techies will not be
the optimal approach to draw all people in.  But I think I will stick
with the mailing lists even then.


-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/2ef65e30/attachment.sig>

From ml at isaac.cedarswampstudios.org  Tue Dec  3 23:28:36 2013
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Wed, 04 Dec 2013 02:28:36 -0500
Subject: [rust-dev] Persistent data structures
Message-ID: <529ED9A4.4080901@isaac.cedarswampstudios.org>

I'm interested in having persistent data structures[1] in Rust.  To 
start, I implemented the simplest one, the cons/nil list (it looks like 
extra::list::List has another implementation of it).  Am I using Rust 
conventions properly?

My persistent list code:
https://github.com/idupree/rust-code/blob/master/persistent.rs

My next goal is a persistent tree-map, probably cribbing from Haskell's 
Data.Map.


Is Rc the best smart pointer for persistent data structures?  Is it 
possible for the structure to be parametrized on smart pointer?

Rc requires the contained data to be Freeze or Send or risk reference 
cycles.  Gc requires T:'static (which means no borrowed pointers besides 
&'static ones within the type).  Every Send type is 'static, but not 
every Freeze type is 'static, so neither Rc nor Gc is strictly more 
flexible.  Arc is Send, unlike either Rc or Gc, but has more overhead 
and can only contain Freeze+Send data; someone wanting to share 
persistence between tasks (conceivably for the sake of memory-use or 
asymptotic time) would want it.


Is it possible to implement FromIterator<T> for List<T> without using 
O(n) temporary space or "unsafe" code?  The problem is that the list 
comes out reversed in an obvious implementation. (O(n) stack space via 
recursion, or an O(n) intermediate data structure, or unsafely 
constructing a cons cell before constructing its tail.)


[1] https://en.wikipedia.org/wiki/Persistent_data_structure , like every 
data structure in Haskell

-Isaac

From bascule at gmail.com  Tue Dec  3 23:30:36 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 3 Dec 2013 23:30:36 -0800
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529ED9A4.4080901@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
Message-ID: <CAHOTMV+U7QwSy-j+bGVm0XLaChA5myFYDZNhfDnGN_E6_k02cA@mail.gmail.com>

On Tue, Dec 3, 2013 at 11:28 PM, Isaac Dupree <
ml at isaac.cedarswampstudios.org> wrote:

> I'm interested in having persistent data structures[1] in Rust.


Nice!

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131203/0601323b/attachment.html>

From pcwalton at mozilla.com  Wed Dec  4 00:23:35 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 04 Dec 2013 00:23:35 -0800
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529ED9A4.4080901@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
Message-ID: <529EE687.2060004@mozilla.com>

On 12/3/13 11:28 PM, Isaac Dupree wrote:
> Is Rc the best smart pointer for persistent data structures?

I would think so, for non-thread safe ones.

> Is it
> possible for the structure to be parametrized on smart pointer?

Not without higher kinded types (which eventually we do want--so the 
answer is "not yet").

> Rc requires the contained data to be Freeze or Send or risk reference
> cycles.

I want to lift this restriction, BTW. Trying to prevent cycles through 
the type system has never really worked for us.

   Gc requires T:'static (which means no borrowed pointers besides
> &'static ones within the type).

Yes, but I wouldn't worry about this restriction biting users of your 
structure too much. Rust data structures rarely ever store non-static 
references in them, as the stack discipline that references must follow 
is fairly limited. (I can probably count the number of times I've put a 
non-static `&` reference into a dynamic vector on one hand, and I don't 
think I've ever put references into a hash map.)

   Every Send type is 'static, but not
> every Freeze type is 'static, so neither Rc nor Gc is strictly more
> flexible.  Arc is Send, unlike either Rc or Gc, but has more overhead
> and can only contain Freeze+Send data; someone wanting to share
> persistence between tasks (conceivably for the sake of memory-use or
> asymptotic time) would want it.

Really what you want here for maximum flexibility is higher-kinded types 
and an implementation parameterized over Rc<T> or Arc<T>. That doesn't 
work in today's Rust, so you'll have to implement the data structure 
separately for non-thread-safe and thread-safe applications, unless you 
use macros. (Though often times you may want separate logic either way, 
necessitating a separate implementation. I'm not sure about the 
particular data structure you had in mind though.)

> Is it possible to implement FromIterator<T> for List<T> without using
> O(n) temporary space or "unsafe" code?  The problem is that the list
> comes out reversed in an obvious implementation. (O(n) stack space via
> recursion, or an O(n) intermediate data structure, or unsafely
> constructing a cons cell before constructing its tail.)

I think it should be possible to reverse the list after it's 
constructed, but then of course it has to be mutable (at least 
temporarily). Or you could carry around a pointer to the end of the list 
(which, again, requires mutation). I don't think this is solvable 
without mutation in a strict (non-lazy) language, unless I'm missing 
something.

Patrick


From remifontan at yahoo.fr  Wed Dec  4 00:24:35 2013
From: remifontan at yahoo.fr (=?UTF-8?B?UsOpbWkgRm9udGFu?=)
Date: Wed, 4 Dec 2013 21:24:35 +1300
Subject: [rust-dev] method overloading and generic
In-Reply-To: <CANbMr6H9VC56wekdEN1UNJOGg7BknU=sF-Lw_qCeR7x0jjH6ZA@mail.gmail.com>
References: <CAFKqbfQm7tD7tP19oF7ooYnfAXO2-fim-tt5hc3y2HPm7caN3w@mail.gmail.com>
	<CANbMr6H9VC56wekdEN1UNJOGg7BknU=sF-Lw_qCeR7x0jjH6ZA@mail.gmail.com>
Message-ID: <CAFKqbfSxB-tBXi6iPXmkqkAMNOn=WLYsNu-cxPGmNLH1CkHPhQ@mail.gmail.com>

thanks for explanation, it all makes sense now. so I will stick to manually
implement the overloading for every float type until #8075 is fixed, which
is fine for now.

cheers,

R?mi


On Tue, Dec 3, 2013 at 11:50 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> I think you're running into issue #8075<https://github.com/mozilla/rust/issues/8075>which has to do with generic impls conflicting with all the other impls
> present.
> The typechecker tries to ensure that impls are coherent, i.e. that impls
> do not overlap (otherwise the compiler wouldn't know which one to use).
> Unfortunately, the coherence check isn't very smart right now and if
> there's a generic impl around then it assumes it could conflict with
> everything (and consequently forbids any other impls).
>
> The specific problem here is that the coherence checker doesn't realize
> that SomeData does not impl Float. Without knowing that, the checker sees
> two possible impls for SomeData and rejects the code.
> If you replace "impl<T: Float> SomeDataRhs for T" with "impl SomeDataRhs
> for f64", then it'll work fine. You can add an impl for f32 as well (FYI
> "float" is already removed in HEAD).
> Unfortunately, I don't know of a good general solution that will support
> all types implementing Float (i.e. what the generic impl is doing).
>
>
> On Tue, Dec 3, 2013 at 1:09 AM, R?mi Fontan <remifontan at yahoo.fr> wrote:
>
>> Hi,
>>
>> I think I already asked this question in the past and I'm not very sure
>> what was the answer and whether it is still applicable wirh rust 0.8.
>>
>> I'm implementing the double dispatch method overloading such that I can
>> add 2 struct together and a float to a struct.
>>
>>         let data = SomeData{a:1.0} + 2.0;
>>         let data2 = SomeData{a:100.0} + data;
>>
>> I would like to implement the add for every type of float. I asked
>> whether I could write something like this:
>>
>> impl<T:Float> SomeDataRhs for T {
>>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>>         SomeData{a:lhs.a + cast(*self)}
>>     }
>> }
>>
>> it does not compile right now with rust 0.8
>> I get error messages as follow
>>
>> test2.rs:39:0: 43:1 error: conflicting implementations for trait
>> `SomeDataRhs`
>>
>> test2.rs:39 impl SomeDataRhs for SomeData {
>>
>> test2.rs:40     fn add_to(&self, lhs:&SomeData) -> SomeData {
>>
>> test2.rs:41         SomeData{a:lhs.a + self.a}
>>
>> test2.rs:42     }
>>
>> test2.rs:43 }
>>
>> test2.rs:33:0: 37:1 note: note conflicting implementation here
>>
>> test2.rs:33 impl<T:Float> SomeDataRhs for T {
>>
>> test2.rs:34     fn add_to(&self, lhs:&SomeData) -> SomeData {
>>
>> test2.rs:35         SomeData{a:lhs.a + cast(*self)}
>>
>> test2.rs:36     }
>>
>> Would you know whether what I try to do is possible. I was recommended to
>> use macro for that, I don't mind to eventually go this way but I would
>> rather do it the proper way if there is one.
>>
>> here's the full code of my test:
>> extern mod std;
>> use std::num::cast;
>>
>>
>> struct SomeData { a:float }
>>
>> trait SomeDataRhs {
>>     fn add_to(&self, lhs:&SomeData) -> SomeData;
>> }
>>
>> impl<T:SomeDataRhs> Add<T, SomeData> for SomeData {
>>
>>     fn add(&self, rhs:&T) -> SomeData {
>>         rhs.add_to(self)
>>     }
>> }
>>
>> // ---------------
>> // implementations
>>
>> // impl SomeDataRhs for float {
>> //     fn add_to(&self, lhs:&SomeData) -> SomeData {
>> //         SomeData{a:lhs.a + *self}
>> //     }
>> // }
>>
>> // impl SomeDataRhs for f64 {
>> //     fn add_to(&self, lhs:&SomeData) -> SomeData {
>> //         SomeData{a:lhs.a + cast(*self)}
>> //     }
>> // }
>>
>> impl<T:Float> SomeDataRhs for T {
>>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>>         SomeData{a:lhs.a + cast(*self)}
>>     }
>> }
>>
>> impl SomeDataRhs for SomeData {
>>     fn add_to(&self, lhs:&SomeData) -> SomeData {
>>         SomeData{a:lhs.a + self.a}
>>     }
>> }
>>
>>
>>  #[test]
>> fn test_sandbox() {
>>
>>     let mut data = SomeData{a:1.0} + 2.0;
>>     println!("result: {}", data.a);
>>
>>     let mut data2 = SomeData{a:100.0} + data;
>>     data = data + data2;
>>     println!("result: {}", data.a);
>>
>> }
>>
>>
>>
>> cheers,
>>
>> R?mi
>>
>>
>> --
>> R?mi Fontan : remifontan at yahoo.fr
>> mobile: +64 21 855 351
>> 93 Otaki Street, Miramar 6022
>> Wellington, New Zealand
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>


-- 
R?mi Fontan : remifontan at yahoo.fr
mobile: +64 21 855 351
93 Otaki Street, Miramar 6022
Wellington, New Zealand
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/a6e1c8e8/attachment-0001.html>

From j.boggiano at seld.be  Wed Dec  4 00:36:42 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Wed, 4 Dec 2013 09:36:42 +0100
Subject: [rust-dev] Practical usage of rustpkg
In-Reply-To: <529E34A5.2070700@aim.com>
References: <529E34A5.2070700@aim.com>
Message-ID: <CA+GmM=wusfpHp5AmH1q1P9B1cmpGZcx7jniuq6OQ+8zwYjF48g@mail.gmail.com>

On Tue, Dec 3, 2013 at 8:44 PM, SiegeLord <slabode at aim.com> wrote:
> I don't think any of these options are ideal. I don't want to suggest
> solutions to these issues because I'm not sure how things are supposed to be
> used/what the planned design is. Does anybody use rustpkg seriously today?
> Is everybody making workspaces with a github.com/<user> directory where they
> develop their software?

I usually (i.e. in other languages I work with) develop dependencies
"in-line" as they were cloned by the package manager, at least if they
need deep integration with the surrounding project and can not be
easily tested/developed in isolation. It's not such a horrible
situation as long as the package manager is smart enough to avoid
wiping your stuff on its own.

That said, a pretty good option I think is to have a command like npm
link [1] that would allow you to tell rustpkg to set up a symlink to
another dir on the disk, yet without interfering/polluting the
project's source itself.

[1] https://npmjs.org/doc/cli/npm-link.html

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From kevin at sb.org  Wed Dec  4 00:42:32 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 4 Dec 2013 00:42:32 -0800
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529EE687.2060004@mozilla.com>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<529EE687.2060004@mozilla.com>
Message-ID: <3B21214F-C07F-4A63-AB8F-0CEEA31305DB@sb.org>

On Dec 4, 2013, at 12:23 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> Yes, but I wouldn't worry about this restriction biting users of your structure too much. Rust data structures rarely ever store non-static references in them, as the stack discipline that references must follow is fairly limited. (I can probably count the number of times I've put a non-static `&` reference into a dynamic vector on one hand, and I don't think I've ever put references into a hash map.)

I've put non-static &[u8]s into a map. Specifically, I have a function in one of my sources that looks vaguely like

pub fn process_input<'a>(input: &'a [u8]) -> int {
    let mut map: HashMap<&'a [u8], int> = HashMap::new();
    
    // .. process the input using the map, then throw away the map
    
    return result;
}

-Kevin

From philippe.delrieu at free.fr  Wed Dec  4 01:21:27 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 04 Dec 2013 10:21:27 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <529B71D4.9000603@free.fr>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>	<529880BA.2090006@free.fr>	<52988F48.6010407@free.fr>	<5298916A.8040105@gmail.com>
	<529B71D4.9000603@free.fr>
Message-ID: <529EF417.3040103@free.fr>

I reply to my questions. It can be helpful to somebody.
First the error: wrong number of lifetime parameters
The struct encoder is declared pub struct Encoder<'self> so the <'self> 
lifetime is part of the type and must be keep.
The good declaration is pub fn 
buffer_encode<T:Encodable<Encoder<'self>>>(to_encode_object: &T) -> ~[u8]

The call to the function is : Encoder::buffer_encode(&to_encode_object)

For the other questions.
The lifetime has been added to init (pub fn init<'a>(wr: &'a mut 
io::Writer) -> Encoder<'a>) because the borrowed specified parameter 
(wr) is returning in the Encoder and must be keep borrower after the 
call and during all the Encoder use. Fn Init borrow the wr and give it 
to the Encoder. After the 'init' call, returned Encoder is use to encode 
object and wr must still be borrowed. The call to init and encode are 
put inside a scoped block to manage the Encoder lifetime:
ex:
         let mut m = MemWriter::new();
         {
             let mut encoder = Encoder::init(&mut m as &mut Writer);
             to_encode_object.encode(&mut encoder);
         }
         m.inner()

Why the type is declared with a <'self> lifetime (pub struct 
Encoder<'self>). It's not so clear. What I think, It's because the 
struct contains an attribute (priv wr: &'self mut io::Writer) that have 
a variable lifetime (depend on the use) , so to be configurable the 
lifetime must be declared as a generic in the struct. The variable 
lifetime is needed because, it allow the Encoder to borrow the writer 
during a lifetime longer that the function call (lifetime of normal 
borrowing) needed in the init function.

For more informations:
http://static.rust-lang.org/doc/master/tutorial-borrowed-ptr.html : to 
understand borrowing mechanism
https://www.mail-archive.com/rust-dev at mozilla.org/msg05811.html : for 
the <'self>

Hope my explication is clear.

I have remark about the list and the thread 'Rust Forum', I think it 
become important to have a user mailing list or forum. It's the second 
time I answer to my trivial questions and I fell that I'm annoying 
everybody with these.

Philippe Delrieu


Le 01/12/2013 18:28, Philippe Delrieu a ?crit :
> I see the PR has been approved to I try to implements the method 'pub 
> fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]'
> and I have this error : "error: wrong number of lifetime parameters: 
> expected 1 but found 0" and  indicate the Encoder type.
>
> I have another question. I try to understand the modification on 
> json.rs and function declaration has changed from :
> impl serialize::Encoder for Encoder
> to:
> impl<'self> serialize::Encoder for Encoder<'self>
> or
> pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a>
> instead of
> pub fn new(wr: &mut io::Writer) -> Encoder
>
> Could you explain me the difference if you don't mind.
>
> Philippe
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/5a8eed69/attachment.html>

From gaetan at xeberon.net  Wed Dec  4 01:22:37 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 4 Dec 2013 10:22:37 +0100
Subject: [rust-dev] Practical usage of rustpkg
In-Reply-To: <CA+GmM=wusfpHp5AmH1q1P9B1cmpGZcx7jniuq6OQ+8zwYjF48g@mail.gmail.com>
References: <529E34A5.2070700@aim.com>
	<CA+GmM=wusfpHp5AmH1q1P9B1cmpGZcx7jniuq6OQ+8zwYjF48g@mail.gmail.com>
Message-ID: <CANK7tAHN_pq_2hL+kyab4M83PzmeF1uVJng=nGPp_6mnS5zT2w@mail.gmail.com>

dependencies management is really a not so trivial solution...

There are several solution:
- javaish : use reverse url notation like:
org.server.organisation.product.libraryname. If we expect not to use the
URL from another company, conflict should be avoided most of the time. But
while this is good for compagny, this is not really usable for personal
development. org.compagnie doesn't change often, while you may want to
switch from github to another server, breaking this rule. Given that, you
simple push your artifact inside a repository manager (like artifactory),
and simply request the package name and version, it will easily find out
which one to use and install it in your development environement.
- central repository: much simpler, just the name of the library should be
unique. pip use this and it's much easier to use (just push the tarball and
that's all, pip will see and install it when needed).

I don't know if there are plan to do something about rustpkg, but I think
dependencies management is something really important to have to ease the
wide adoption of rust.

I like the python way, simple is better. Just the name of the package
should be unique, and the package should be validated.

I would imagine something like: defining in mod.rs the depencendies import
directives with something like "#[import mylibrary]" which would direct
rust pbk to try importing the library "mylibrary" from a know local path
(if you develop both library and the application that use it) or from a
central repository (www.rust-lang.com/pkg/ ?), download it and install it
inside the directory structure (eventually not versionnned, to avoid
copying it), and configuring the proper "use pkg::mylibrary" to work
directly, for example. Of course for local development, copying it would
not be necessary.
I also think that proposing a random URL to be set (for instance to specify
the URL of a personal Github project) would also allow the use of package
that is not entered yet inside the managed central repository.

But this doesn't cover dependencies between packages and versionning...

G.

-----
Gaetan



2013/12/4 Jordi Boggiano <j.boggiano at seld.be>

> On Tue, Dec 3, 2013 at 8:44 PM, SiegeLord <slabode at aim.com> wrote:
> > I don't think any of these options are ideal. I don't want to suggest
> > solutions to these issues because I'm not sure how things are supposed
> to be
> > used/what the planned design is. Does anybody use rustpkg seriously
> today?
> > Is everybody making workspaces with a github.com/<user> directory where
> they
> > develop their software?
>
> I usually (i.e. in other languages I work with) develop dependencies
> "in-line" as they were cloned by the package manager, at least if they
> need deep integration with the surrounding project and can not be
> easily tested/developed in isolation. It's not such a horrible
> situation as long as the package manager is smart enough to avoid
> wiping your stuff on its own.
>
> That said, a pretty good option I think is to have a command like npm
> link [1] that would allow you to tell rustpkg to set up a symlink to
> another dir on the disk, yet without interfering/polluting the
> project's source itself.
>
> [1] https://npmjs.org/doc/cli/npm-link.html
>
> Cheers
>
> --
> Jordi Boggiano
> @seldaek - http://nelm.io/jordi
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/30fcf52a/attachment.html>

From gaetan at xeberon.net  Wed Dec  4 01:25:32 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 4 Dec 2013 10:25:32 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <529EF417.3040103@free.fr>
References: <52972F3D.6010901@free.fr>
	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>
	<52984FE1.80505@free.fr>
	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>
	<529880BA.2090006@free.fr> <52988F48.6010407@free.fr>
	<5298916A.8040105@gmail.com>
	<529B71D4.9000603@free.fr> <529EF417.3040103@free.fr>
Message-ID: <CANK7tAE8J0edgHcgZqsVCB8DUTwCqYw=+2Xqyf_RpZququ27AQ@mail.gmail.com>

is it possible to have the <'self> explained inside the tutorial?

-----
Gaetan



2013/12/4 Philippe Delrieu <philippe.delrieu at free.fr>

>  I reply to my questions. It can be helpful to somebody.
> First the error: wrong number of lifetime parameters
> The struct encoder is declared pub struct Encoder<'self> so the <'self>
> lifetime is part of the type and must be keep.
> The good declaration is pub fn
> buffer_encode<T:Encodable<Encoder<'self>>>(to_encode_object: &T) -> ~[u8]
>
> The call to the function is : Encoder::buffer_encode(&to_encode_object)
>
> For the other questions.
> The lifetime has been added to init (pub fn init<'a>(wr: &'a mut
> io::Writer) -> Encoder<'a>) because the borrowed specified parameter (wr)
> is returning in the Encoder and  must be keep borrower after the call and
> during all the Encoder use. Fn Init borrow the wr and give it to the
> Encoder. After the 'init' call, returned Encoder is use to encode object
> and wr must still be borrowed. The call to init and encode are put inside a
> scoped block to manage the Encoder lifetime:
> ex:
>
>         let mut m = MemWriter::new();
>         {
>             let mut encoder = Encoder::init(&mut m as &mut Writer);
>             to_encode_object.encode(&mut encoder);
>         }
>         m.inner()
>
> Why the type is declared with a <'self> lifetime (pub struct
> Encoder<'self>). It's not so clear. What I think, It's because the struct
> contains an attribute (priv wr: &'self mut io::Writer) that have a variable
> lifetime (depend on the use) , so to be configurable the lifetime must be
> declared as a generic in the struct. The variable lifetime is needed
> because, it allow the Encoder to borrow the writer during a lifetime longer
> that the function call (lifetime of normal borrowing) needed in the init
> function.
>
> For more informations:
> http://static.rust-lang.org/doc/master/tutorial-borrowed-ptr.html : to
> understand borrowing mechanism
> https://www.mail-archive.com/rust-dev at mozilla.org/msg05811.html : for the
> <'self>
>
> Hope my explication is clear.
>
> I have remark about the list and the thread 'Rust Forum', I think it
> become important to have a user mailing list or forum. It's the second time
> I answer to my trivial questions and I fell that I'm annoying everybody
> with these.
>
> Philippe Delrieu
>
>
> Le 01/12/2013 18:28, Philippe Delrieu a ?crit :
>
> I see the PR has been approved to I try to implements the method 'pub fn
> buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]'
> and I have this error : "error: wrong number of lifetime parameters:
> expected 1 but found 0" and  indicate the Encoder type.
>
> I have another question. I try to understand the modification on json.rsand function declaration has changed from :
> impl serialize::Encoder for Encoder
> to:
> impl<'self> serialize::Encoder for Encoder<'self>
> or
> pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a>
> instead of
> pub fn new(wr: &mut io::Writer) -> Encoder
>
> Could you explain me the difference if you don't mind.
>
> Philippe
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/0e7bb9e4/attachment-0001.html>

From michaelwoerister at posteo.de  Wed Dec  4 01:51:43 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Wed, 04 Dec 2013 10:51:43 +0100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529ED9A4.4080901@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
Message-ID: <529EFB2F.5090506@posteo.de>

I've implemented a persistent HAMT [1] a while back:
https://github.com/michaelwoerister/rs-persistent-datastructures/blob/master/hamt.rs

It's the data structure used for persistent maps in Clojure (and Scala, 
I think). It's not too hard to implement and it's pretty nifty. I'm not 
sure about the performance with atomic reference counting being used for 
memory management. It will definitely be worse than with a  
stop-the-world garbage collector. Although, it's noteworthy that look 
ups in the data structure only have to copy one `Arc` for returning the 
result, so the high fan-out of the data structure should not hurt if you 
mostly read from it. I'd be very interested in a performance comparison 
to other persistent map implementations in Rust (e.g. a red-black tree 
or splay tree).

Here are some things I came across during implementing this:
* I too discovered that I couldn't parametrize on the type of reference 
being used without higher kinded types. I did the implementation with 
regular @ pointers at first and later switched to `Arc`, since 
concurrent contexts are where persistent data structures really shine. 
Switching the implementation from @ to Arc was pretty straight forward.
* I found there is no standardized trait for persistent maps in libstd 
or libextra. It would be nice to have one!
* It's probably a very good idea to provide a non-persistent "builder" 
that avoids the excessive copying during the insertion phase. In Clojure 
one can switch between "transient" and persistent mode for a data 
structure instance which also allows for optimized batch modifications. 
An `insert_from(iterator)` method might also do the trick. There's quite 
a bit of design space here.
* I would have liked to avoid some allocations and pointer chasing by 
using fixed size vectors directly within nodes but I could not get that 
to work without a lot of unsafe code that I was not sure would be 
correct in all cases. So I just used owned vectors in the end.

Looking forward to seeing more in this area :)

-Michael

[1] https://en.wikipedia.org/wiki/Hash_array_mapped_trie

On 04.12.2013 08:28, Isaac Dupree wrote:
> I'm interested in having persistent data structures[1] in Rust.  To 
> start, I implemented the simplest one, the cons/nil list (it looks 
> like extra::list::List has another implementation of it).  Am I using 
> Rust conventions properly?
>
> My persistent list code:
> https://github.com/idupree/rust-code/blob/master/persistent.rs
>
> My next goal is a persistent tree-map, probably cribbing from 
> Haskell's Data.Map.
>
>
> Is Rc the best smart pointer for persistent data structures?  Is it 
> possible for the structure to be parametrized on smart pointer?
>
> Rc requires the contained data to be Freeze or Send or risk reference 
> cycles.  Gc requires T:'static (which means no borrowed pointers 
> besides &'static ones within the type).  Every Send type is 'static, 
> but not every Freeze type is 'static, so neither Rc nor Gc is strictly 
> more flexible.  Arc is Send, unlike either Rc or Gc, but has more 
> overhead and can only contain Freeze+Send data; someone wanting to 
> share persistence between tasks (conceivably for the sake of 
> memory-use or asymptotic time) would want it.
>
>
> Is it possible to implement FromIterator<T> for List<T> without using 
> O(n) temporary space or "unsafe" code?  The problem is that the list 
> comes out reversed in an obvious implementation. (O(n) stack space via 
> recursion, or an O(n) intermediate data structure, or unsafely 
> constructing a cons cell before constructing its tail.)
>
>
> [1] https://en.wikipedia.org/wiki/Persistent_data_structure , like 
> every data structure in Haskell
>
> -Isaac
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From steve at steveklabnik.com  Wed Dec  4 02:24:14 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Wed, 4 Dec 2013 11:24:14 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529A3174.8060701@hyc.io>
References: <529A3174.8060701@hyc.io>
Message-ID: <CABL+ZB4AuteVWZeME2P3Q=hMx_sY2kh322=PSV8dcQVSdHEMtA@mail.gmail.com>

There is a tag on GitHub specifically for easy issues:
https://github.com/mozilla/rust/issues?labels=E-easy&milestone=13&state=open

From dbau.pp at gmail.com  Wed Dec  4 02:33:56 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 04 Dec 2013 21:33:56 +1100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529EFB2F.5090506@posteo.de>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<529EFB2F.5090506@posteo.de>
Message-ID: <529F0514.1050503@gmail.com>

On 04/12/13 20:51, Michael Woerister wrote:
> I've implemented a persistent HAMT [1] a while back:
> https://github.com/michaelwoerister/rs-persistent-datastructures/blob/master/hamt.rs 
>
>
> It's the data structure used for persistent maps in Clojure (and 
> Scala, I think). It's not too hard to implement and it's pretty nifty. 
> I'm not sure about the performance with atomic reference counting 
> being used for memory management. It will definitely be worse than 
> with a  stop-the-world garbage collector. Although, it's noteworthy 
> that look ups in the data structure only have to copy one `Arc` for 
> returning the result, so the high fan-out of the data structure should 
> not hurt if you mostly read from it. I'd be very interested in a 
> performance comparison to other persistent map implementations in Rust 
> (e.g. a red-black tree or splay tree).
>
> Here are some things I came across during implementing this:
> * I too discovered that I couldn't parametrize on the type of 
> reference being used without higher kinded types. I did the 
> implementation with regular @ pointers at first and later switched to 
> `Arc`, since concurrent contexts are where persistent data structures 
> really shine. Switching the implementation from @ to Arc was pretty 
> straight forward.
> * I found there is no standardized trait for persistent maps in libstd 
> or libextra. It would be nice to have one!
> * It's probably a very good idea to provide a non-persistent "builder" 
> that avoids the excessive copying during the insertion phase. In 
> Clojure one can switch between "transient" and persistent mode for a 
> data structure instance which also allows for optimized batch 
> modifications. An `insert_from(iterator)` method might also do the 
> trick. There's quite a bit of design space here.


For reference, the FromIterator & Extendable traits are the things to 
implement if one has a structure that can be constructed from/extended 
with an iterator and wishes to share the behaviour.


http://static.rust-lang.org/doc/master/std/iter/trait.FromIterator.html
http://static.rust-lang.org/doc/master/std/iter/trait.Extendable.html


Huon

> * I would have liked to avoid some allocations and pointer chasing by 
> using fixed size vectors directly within nodes but I could not get 
> that to work without a lot of unsafe code that I was not sure would be 
> correct in all cases. So I just used owned vectors in the end.
>
> Looking forward to seeing more in this area :)
>
> -Michael
>
> [1] https://en.wikipedia.org/wiki/Hash_array_mapped_trie


From illissius at gmail.com  Wed Dec  4 02:38:22 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 4 Dec 2013 11:38:22 +0100
Subject: [rust-dev] Distilled essence of placement new
In-Reply-To: <acf1c1a2-e531-4432-bf5d-6fe8253996f5@email.android.com>
References: <CAPNUp0-hPTDgQCU8pF0x0RH=-Bt+=bp2E6K-EvJG8VU+=MYR5w@mail.gmail.com>
	<CA+DvKQLO2JjjPsjHqvNaEv-gSEBMGYE8GadxpCg0N_71PCaTsA@mail.gmail.com>
	<CAPNUp0-a0optb4bpp5=AsFq690mm2NfPKrW5G+Ktyme6p=KZVg@mail.gmail.com>
	<acf1c1a2-e531-4432-bf5d-6fe8253996f5@email.android.com>
Message-ID: <CAPNUp0_F6o6b4ok_8bJoA+pbBhXjt6t1TJprgvVpUvXCUAsq2g@mail.gmail.com>

What's the current plan for the implementation of placement new as you
envision it? In particular what would the trait used by Gc etc. to hook
into it look like? How does it do the thing where expressions are
constructed directly into place? I agree with many parts of your analysis
(different argument evaluation orders implicitly would indeed be
unfortunate), but I want to have a clearer picture of the other alternative
before discussing it further.


On Wed, Dec 4, 2013 at 5:57 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> I should elaborate: I think you've successfully formulated placement new
> in terms of unboxed closures as monomorphized traits whose "call" method
> takes self by value. That is, something like (in Rust of the future):
>
> fn GC<T,F:OnceFunc<T>>(f: F) -> GC<T>
>
> The difference, though, is that the construction of the closure is
> implicit at the call site in this proposal. This is what I'm uncomfortable
> with. Rust is a strict language, not a lazy one, and the order of
> evaluation of function arguments is one of the things that one has
> heretofore been unable to change. I would prefer that a different argument
> evaluation order would necessitate some sort of annotation at the call site
> (e.g. ocaml's "lazy"). But once you've done that you've essentially
> recreated something equivalent to placement new, but more verbose since you
> have to name a method when you allocate into an object (e.g. instead of
> "box(my_arena) foo" you'd have to write "my_arena.alloc(lazy foo)". I think
> we would end up wanting the sugar.
>
> Patrick
>
> "G?bor Lehel" <illissius at gmail.com> wrote:
>>
>> Yes, that was one of the things that passed through my mind as well. One
>> difference is that those are passed at runtime, whereas here everything
>> happens at compile time. I remember LLVM had difficulty reliably optimizing
>> runtime closure passing code, like with the old iterators.
>>
>>
>> On Wed, Dec 4, 2013 at 5:05 AM, Daniel Micay <danielmicay at gmail.com>wrote:
>>
>>> This looks a lot like what stack once functions would provide.
>>>
>>
>>
>>
>> --
>> Your ship was destroyed in a monadic eruption.
>>
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/f9dd6ce2/attachment.html>

From michaelwoerister at posteo.de  Wed Dec  4 03:18:47 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Wed, 04 Dec 2013 12:18:47 +0100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529F0514.1050503@gmail.com>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>	<529EFB2F.5090506@posteo.de>
	<529F0514.1050503@gmail.com>
Message-ID: <529F0F97.4050607@posteo.de>


> For reference, the FromIterator & Extendable traits are the things to 
> implement if one has a structure that can be constructed from/extended 
> with an iterator and wishes to share the behaviour.
>
>
> http://static.rust-lang.org/doc/master/std/iter/trait.FromIterator.html
> http://static.rust-lang.org/doc/master/std/iter/trait.Extendable.html

Thanks for pointing that out :)
Implementing FromIterator should work out fine. Extendable would need a 
persistent version returning the newly created instance, something like:

mod persistent {
     pub trait Extendable<A>: FromIterator 
<http://static.rust-lang.org/doc/master/std/iter/trait.FromIterator.html><A> 
{
         fn extend 
<http://static.rust-lang.org/doc/master/std/iter/trait.Extendable.html#tymethod.extend><T: 
Iterator 
<http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html><A>>(&self, 
iterator: &mut T) -> Self;
     }
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/66e54245/attachment-0001.html>

From illissius at gmail.com  Wed Dec  4 03:41:16 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 4 Dec 2013 12:41:16 +0100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <20131202181825.GG21938@Mr-Bennet>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
	<20131202181825.GG21938@Mr-Bennet>
Message-ID: <CAPNUp0_GnWabm6YJ2EMZSTwb7wcAXg-7rN0HC1As1=dew9v3mQ@mail.gmail.com>

On Mon, Dec 2, 2013 at 7:18 PM, Niko Matsakis <niko at alum.mit.edu> wrote:

>
> OK, I read a bit more. I've been working on a blog post about "HKR"
> (higher-kinded Rust) and you've been elaborating on some of the same
> themes as I was thinking about (naturally enough). All makes sense.
>

...which was part of the impetus for finally getting my thoughts down on
"paper". :)


>  In the absence of an erased keyword, I think that higher-kinded traits
> and objects are simply incompatible. The situation is not as simple as
> you made it out, as the trait may itself have generic parameters of
> higher-kind.


Without having thought about very deeply about whether it's true (can you
provide an example?), wouldn't this be more accurately phrased as:
"(higher-kinded?) traits with higher-kinded generic parameters and objects
are simply incompatible"? In other words, if the problem is with the
higher-kinded generic parameters, then why not forbid objects only in that
case, and support them in their absence?


> > The other is the potential to abstract over traits. GHC does this with
> the
> > `ConstraintKinds` extension. (According to people who have implemented
> > Haskell compilers, it's actually easier to implement it than not to![1]
> > Which is pretty crazy.)
>
> I'm not sure this would be true for Rust, but perhaps.
>

I have no idea either - it's astonishing enough that it's true for Haskell.
:)


>
> > There's two further issues that higher-kinded generics raise...
>
> This is as far as I got in this round. More later. :)
>

OK. :)

(I also still have yet to find serious time for DST parts [2..4]...)


>
>
> Niko
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/e8e6763b/attachment.html>

From niko at alum.mit.edu  Wed Dec  4 04:14:22 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 4 Dec 2013 07:14:22 -0500
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
Message-ID: <20131204121422.GC2409@Mr-Bennet>

This is a great idea.


Niko


On Tue, Nov 26, 2013 at 03:58:58AM -0500, Corey Richardson wrote:
> Hey fellow Rusties,
> 
> We have a fair number of new contributors, and my devious mind wonders
> how we can get more. My first thought was a new tag, E-mentored, where
> someone can volunteer to mentor someone through an E-easy issue. It's
> a very lightweight, non-formal process, and can hopefully give some
> more guidance to people who come into #rust asking for a good issue to
> get started with.
> 
> This is intended for brand-new contributors, whereas I feel E-easy is
> a teeny bit misused.
> 
> I also propose that, when tagging an issue as E-easy, a comment
> describing the nature of the fix and where (file + function ideal) one
> would look to start the fix.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From denis.spir at gmail.com  Wed Dec  4 05:31:06 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 04 Dec 2013 14:31:06 +0100
Subject: [rust-dev] Rust forum
In-Reply-To: <CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
References: <CAHuo6ZATrBWk7zy6tY7Uz2KZnCh9MzugjJQv7G8W=+StmyU9zg@mail.gmail.com>	<0DA6C2F8-3190-4601-ADE5-848048564FED@sb.org>	<CAChbWaP+oemseZGuaBHd0Yjj1HJN_ivHA+8P5OtGGMVWo-sLHA@mail.gmail.com>	<CANK7tAGrrgjHFMx8EbXj0BNVFpARJQ2qpdBBW4tzcx5+_i84Og@mail.gmail.com>
	<CAFrFfuGttRcy-crb+aS+D_f4jk0t+4izPt9r7c6QuTBXywMM3A@mail.gmail.com>
Message-ID: <529F2E9A.2000307@gmail.com>

On 12/03/2013 11:01 PM, Martin DeMello wrote:
> keeping up with email is a lot easier than pretty much everything else,
> though. the solution to keeping old messages around is mirroring the
> mailing list to a searchable archive, not moving to a forum en masse and
> sacrificing ease-of-conversation for ease-of-recall.

Agreed. Plus, with emails everyone can *also* filter / categorise / search 
according to their own preferred rules on their preferret email client. [I have 
always hated forums for such reasons, plus they force one to explore, search, 
navigate, online, without any control.]

Denis

From simon.sapin at exyr.org  Wed Dec  4 06:01:38 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Wed, 04 Dec 2013 14:01:38 +0000
Subject: [rust-dev] Meeting-weekly-2013-12-03,  str.from_utf8
Message-ID: <529F35C2.1060606@exyr.org>

Hi,

In response to:
https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-03#strfrom_utf8

Yes, error handling other than strict/fail requires allocation. I 
suggest taking the pull request for the special case of non-allocating 
strict UTF-8, and keeping error handling for a future, larger API that 
also handles other encodings (and incremental processing):

https://github.com/mozilla/rust/pull/10701
https://github.com/mozilla/rust/wiki/Proposal-for-character-encoding-API


[On invalid UTF-8 bytes]
> brson: One has a condition that lets you replace a bad character

I believe this is not implemented. The current not_utf8 condition lets 
you do the entire decoding yourself.

> acrichto: We could truncate by default.

I am very much opposed to this. Truncating silently loses data 
(potentially lots of it!) It should not be implemented, let alone be the 
default.

> jack: In python, you have to specify how you want it transformed.
> Truncate vs. replace with '?', etc. Maybe there should be an
> alternate version that takes the transform.
> pnkfelix: But doesn't work with slices...
> jack: There's truncate, replace, and fail.

Python does not have truncate. It has ignore (skip invalid byte 
sequences but continue with the rest of the input), strict (fail), and 
replace (with ? U+FFFD REPLACEMENT CHARACTER). You don?t have to specify 
an error handling, strict is the default.

Ignore is bad IMO as it silently loses data (although it?s not as bad as 
truncate) though it could have uses I?m not thinking of right now.


Side note:

Regarding failing vs. returning an Option or Result: I?d be in favor of 
only having the latter. Having two versions of the same API (foo() and 
foo_opt()) is ugly, and it?s easy to get "value or fail" from an Option 
with .unwrap()

-- 
Simon Sapin

From thadguidry at gmail.com  Wed Dec  4 06:58:47 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Wed, 4 Dec 2013 08:58:47 -0600
Subject: [rust-dev] How to search the mailing list archives
In-Reply-To: <CAAvrL-kUke_UXx4w3BxMSwQRpM=btwLVJZB5F5-+yZVQ=h852A@mail.gmail.com>
References: <CAAvrL-kUke_UXx4w3BxMSwQRpM=btwLVJZB5F5-+yZVQ=h852A@mail.gmail.com>
Message-ID: <CAChbWaMH7kV2um5YEfNE_E14jakxouDi_EPhCefi8f=fokynGg@mail.gmail.com>

Actually, you do not have to change the "article" to "thread"...instead,
just CLICK on the Subject and you get the full thread discussion view.

Thanks for the tip Benjamin !  (search at the bottom ?  whatever.  everyone
is copying Firefox these days. :-)  )


On Tue, Dec 3, 2013 at 9:11 PM, Benjamin Striegel <ben.striegel at gmail.com>wrote:

> Apparently even Brian doesn't know how to do this, so I figured I'd share
> this tip.
>
> The rust-dev mailing list is archived here:
>
> http://thread.gmane.org/gmane.comp.lang.rust.devel/
>
> Use the search box at the bottom to search through the mailing list's
> archives since the beginning of time.
>
> When you click on a result, you will end up on a page like this:
>
> http://article.gmane.org/gmane.comp.lang.rust.devel/6778/match=dst
>
> ...which is pretty terrible from a navigation standpoint. But in that URL
> you can manually change the "article" bit on the front to "thread", to
> yield this:
>
> http://thread.gmane.org/gmane.comp.lang.rust.devel/6778/match=dst
>
> ...which will let you easily browse a full conversation.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/0dd061af/attachment.html>

From catamorphism at gmail.com  Wed Dec  4 08:18:50 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Wed, 4 Dec 2013 08:18:50 -0800
Subject: [rust-dev] Please welcome the Rust and Servo GNOME/OPW interns for
 December 2013-March 2014
Message-ID: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>

Hello,

I'm pleased to announce that the winter/spring Rust and Servo interns
through the GNOME Outreach Program for Women (
https://wiki.gnome.org/OutreachProgramForWomen ) have been chosen. The
program starts December 10 and runs until March 10.

Nif Ward (IRC nick: nif) will be interning on Rust, working to develop
a full-fledged B-tree library. Nif is a senior graduating this fall in
computer science from Oberlin College in Ohio, USA. I will be her
mentor.

Isabelle Carter (IRC nick: ibnc) will be interning on Servo, working
to add support for fixed positioning. Isabelle is on leave from her
undergraduate degree in mathematics, and will be working from
Springfield, Missouri, USA. Lars Bergstrom will be her mentor.

We had many qualified applicants for Rust and Servo's first foray into
OPW, so it's an honor to be chosen for this program. Please be
friendly to nif and ibnc if you see them on #rust!

Depending how this round of OPW goes, Rust and/or Servo may
participate in a future iteration, so if you're interested in
applying, then keep watching for more announcements. In addition,
internships at Mozilla working on Rust and Servo (look for the
"Research Engineering" listing; paid, on-site in the Bay Area) are
open to all graduate students (undergraduate students with research
experience have been considered in the past):
http://careers.mozilla.org/ .

Thanks are due to the Rust and Servo teams -- particularly Lars
Bergstrom, Brian Anderson, and Jack Moffitt -- for helping many people
apply for the program, and to the Mozilla coordinator for OPW, Larissa
Shapiro, for their efforts.

Cheers,
Tim

-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From catamorphism at gmail.com  Wed Dec  4 08:37:14 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Wed, 4 Dec 2013 08:37:14 -0800
Subject: [rust-dev] Practical usage of rustpkg
In-Reply-To: <529E34A5.2070700@aim.com>
References: <529E34A5.2070700@aim.com>
Message-ID: <CADcg8==CvAOzdVJzdYkycWf+j_QA+RTjv1wJ+K+7K7bQrNK7Qg@mail.gmail.com>

FYI, there's a related bug open:

https://github.com/mozilla/rust/issues/8673 (this is about the problem
of repeating the same package ID#revision string in different files
and not having a way to abstract it out)

The preferred way to work on a dependency and the package that depends
on it at the same time is to make a local copy and put it in your
RUST_PATH; this copy will be found before rustpkg looks for the
upstream copy and/or for an automatically-cached copy of that. The
local copy has to have the same package ID, of course, so for a
package like github.com/foo/bar, you would have to have a
github.com/foo/bar directory in your RUST_PATH.

Hope that helps!
Cheers,
Tim


On Tue, Dec 3, 2013 at 11:44 AM, SiegeLord <slabode at aim.com> wrote:
> So I've been thinking for awhile about how one would actually use rustpkg.
> Let me first outline my use case. I have a library and a program that uses
> that library, both of which I host on GitHub. One of the features of the
> rustpkg system is that I should be able to write this to refer to the
> library in my program:
>
> extern mod lib = "package_id";
>
> Unfortunately, there is no obvious thing to put into the 'package_id' slot.
> There are two options:
>
> First, I could use "github.com/SiegeLord/library" as my package_id. This is
> problematic, as it would require one of these sub-optimal courses of action:
>
> - Stick the source of the library into workspace/src/library where I would
> actually develop and then use a duplicate package in the
> workspace/src/github.com/SiegeLord/library that would be created by rustpkg
> (the program is located in workspace/src/program). Somehow this duplicate
> package will be synced to the actual package: either through pushing to
> GitHub and then pulling somehow via rustpkg (this is less than ideal, as I
> may want to test WIP changes without committing them elsewhere/I may have no
> internet connection e.g. when traveling), or some manual, local git
> operation.
>
> - Stick the source of the library into
> workspace/src/github.com/SiegeLord/library and develop the library there.
> There is no duplication, but it really seems bizarre to me to locate a
> project in a directory named like that. Also, I'd be a bit paranoid about
> rustpkg not realizing that I never want to communicate with GitHub and
> having it accidentally overwriting my local changes.
>
> The second option is to use "library" as the package id. This allows me to
> locate my library in a logical location (workspace/src/library), but it
> prevents other users of my program from building it automatically.
> Essentially what they'll have to do is to manually check out the library
> repository inside their workspaces so as to create the workspace/src/library
> directory on their system: the `extern mod` syntax will not work otherwise.
>
> I don't think any of these options are ideal. I don't want to suggest
> solutions to these issues because I'm not sure how things are supposed to be
> used/what the planned design is. Does anybody use rustpkg seriously today?
> Is everybody making workspaces with a github.com/<user> directory where they
> develop their software?
>
> -SL
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From niko at alum.mit.edu  Wed Dec  4 09:01:21 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 4 Dec 2013 12:01:21 -0500
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529EE687.2060004@mozilla.com>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<529EE687.2060004@mozilla.com>
Message-ID: <20131204170121.GD2409@Mr-Bennet>

On Wed, Dec 04, 2013 at 12:23:35AM -0800, Patrick Walton wrote:
> Not without higher kinded types (which eventually we do want--so the
> answer is "not yet").

This. That said, I imagine that if we do it right, it'll be possible
to write one persistent map implementation that can be used with GC,
ARC, and also an arena. The latter would -- at least in principle --
make it possible to store references. I haven't thought hard about
this though and it may be that complications arise.


Niko

From michaelwoerister at posteo.de  Wed Dec  4 11:09:56 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Wed, 04 Dec 2013 20:09:56 +0100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529EE687.2060004@mozilla.com>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<529EE687.2060004@mozilla.com>
Message-ID: <529F7E04.3000809@posteo.de>


>> Is it
>> possible for the structure to be parametrized on smart pointer?
>
> Not without higher kinded types (which eventually we do want--so the 
> answer is "not yet").
I've been thinking about that a bit more and I think it might be 
possible to support different reference types without higher-kinded 
types. We can define a `Reference` trait that is then implemented for 
`Rc`, `Arc` and what have you. Something like:

trait Reference<T> : Clone {
     fn borrow<'a>(&'a self) -> &'a T;
}

If we also want to create references without knowing their concrete 
type, we also need a trait for creating them:

trait ReferenceFactory<T, TRef: Reference<T>> {
     fn create_reference(&self, val: T) -> TRef;
}

And then we can define a container type, using the generic reference type:

struct Container<T, TRef, TRefFactory> {
     items: ~[TRef],
     reference_factory: TRefFactory
}

It contains a `ReferenceFactory` value that is used to create 
`Reference` instances when the container needs one (see the `add` method 
below):

impl<
     T,
     TRef: Reference<T>,
     TRefFactory: ReferenceFactory<T, TRef>
 >
Container<T, TRef, TRefFactory> {

     pub fn create(factory: TRefFactory) -> Container<T, TRef, 
TRefFactory> {
         Container {
             reference_factory: factory,
             items: ~[]
         }
     }

     pub fn add(&mut self, val: T) {
self.items.push(self.reference_factory.create_reference(val));
     }
}

This setup is a bit roundabout but it should get the job done. Of 
course, I may have overlooked something but at least rustc swallows the 
above code without complaint ;)
If we could call static methods on type parameters, the factory 
functionality could be moved to the `Reference` trait:

trait Reference<T> : Clone {
     fn borrow<'a>(&'a self) -> &'a T;
     fn new(value: T) -> Self;
}

// Now using the static `new` method instead of the `ReferenceFactory` trait
pub fn add(&mut self, val: T) {
self.items.push(TRef::new(val));
}

With this, the code would actually be of acceptable complexity in my eyes.

-Michael


From banderson at mozilla.com  Wed Dec  4 11:10:03 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 04 Dec 2013 11:10:03 -0800
Subject: [rust-dev] Meeting-weekly-2013-12-03,  str.from_utf8
In-Reply-To: <529F35C2.1060606@exyr.org>
References: <529F35C2.1060606@exyr.org>
Message-ID: <529F7E0B.1090104@mozilla.com>

On 12/04/2013 06:01 AM, Simon Sapin wrote:
> Hi,
>
> In response to:
> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-03#strfrom_utf8 
>
>
> Yes, error handling other than strict/fail requires allocation. I 
> suggest taking the pull request for the special case of non-allocating 
> strict UTF-8, and keeping error handling for a future, larger API that 
> also handles other encodings (and incremental processing):

OK.

>
> https://github.com/mozilla/rust/pull/10701
> https://github.com/mozilla/rust/wiki/Proposal-for-character-encoding-API
>
>
> [On invalid UTF-8 bytes]
>> brson: One has a condition that lets you replace a bad character
>
> I believe this is not implemented. The current not_utf8 condition lets 
> you do the entire decoding yourself.

You're right! I guess I was forshadowing.

>
>> acrichto: We could truncate by default.
>
> I am very much opposed to this. Truncating silently loses data 
> (potentially lots of it!) It should not be implemented, let alone be 
> the default.

I agree.

>
>> jack: In python, you have to specify how you want it transformed.
>> Truncate vs. replace with '?', etc. Maybe there should be an
>> alternate version that takes the transform.
>> pnkfelix: But doesn't work with slices...
>> jack: There's truncate, replace, and fail.
>
> Python does not have truncate. It has ignore (skip invalid byte 
> sequences but continue with the rest of the input), strict (fail), and 
> replace (with ? U+FFFD REPLACEMENT CHARACTER). You don?t have to 
> specify an error handling, strict is the default.
>
> Ignore is bad IMO as it silently loses data (although it?s not as bad 
> as truncate) though it could have uses I?m not thinking of right now.
>
>
> Side note:
>
> Regarding failing vs. returning an Option or Result: I?d be in favor 
> of only having the latter. Having two versions of the same API (foo() 
> and foo_opt()) is ugly, and it?s easy to get "value or fail" from an 
> Option with .unwrap()
>

Thanks for your always valuable feedback, Simon!

From matthias at urlichs.de  Wed Dec  4 00:04:45 2013
From: matthias at urlichs.de (Matthias Urlichs)
Date: Wed, 4 Dec 2013 08:04:45 +0000 (UTC)
Subject: [rust-dev] Rust front-end to GCC
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
Message-ID: <loom.20131204T090259-73@post.gmane.org>

Hi,
> 
> fn fib1 (n:int) -> int {
> ? ? if (n <= 1) { 1 }
> ? ? else { n * fib1 (n - 1) }
> }
Wrong function name. That's "fac". ;-)

"fib" is 
     ...
 ? ? else { fib1 (n - 1) + fib1 (n - 2) }

-- Matthias Urlichs


From banderson at mozilla.com  Wed Dec  4 11:16:11 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 04 Dec 2013 11:16:11 -0800
Subject: [rust-dev] Rust front-end to GCC
In-Reply-To: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
References: <CAEvRbeoL2NiJ+sfVEtWFMTdP8aWk2jOzmbRbLspj7GSynWQLhQ@mail.gmail.com>
Message-ID: <529F7F7B.2020301@mozilla.com>

On 12/03/2013 09:22 AM, Philip Herron wrote:
> Hey all
>
> Some of you may have noticed the gccrs branch on the git mirror. Since 
> PyCon IE 2013 i gave a talk on my Python Front-end pet project and 
> heard about rust by a few people and i never really looked at it 
> before until then but i've kind of been hooked since.
>
> So to learn the language i've been writing this front-end to GCC. Only 
> really a a month or  so on and off work in between work. Currently it 
> compiles alot of rust already in fairly little effort on my side GCC 
> is doing loads of the heavy lifting.
>
> Currently it compiles most of the basic stuff such as a struct an impl 
> block while loop, functions expressions calling methods passing 
> arguments etc. Currently focusing on getting the typing working 
> correctly to support & and ~ and look at how templates might work as 
> well as need to implement break and return.
>
> There is still a lot of work but i would really like to share it and 
> see what people think. Personally i think rust will target GCC very 
> well and be a good addition (if / when it works). I really want to try 
> and give back to this community who have been very good to me in 
> learning over the last few years with GSOC.
>

This is very exciting work. I'm looking forward to following your progress.

From banderson at mozilla.com  Wed Dec  4 11:43:10 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 04 Dec 2013 11:43:10 -0800
Subject: [rust-dev] Please welcome the Rust and Servo GNOME/OPW interns
 for December 2013-March 2014
In-Reply-To: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>
References: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>
Message-ID: <529F85CE.1070805@mozilla.com>

Welcome aboard, Nif and Isabelle. I'm looking forward to working with 
you. And thanks for setting this up, Tim and Lars.

On 12/04/2013 08:18 AM, Tim Chevalier wrote:
> Hello,
>
> I'm pleased to announce that the winter/spring Rust and Servo interns
> through the GNOME Outreach Program for Women (
> https://wiki.gnome.org/OutreachProgramForWomen ) have been chosen. The
> program starts December 10 and runs until March 10.
>
> Nif Ward (IRC nick: nif) will be interning on Rust, working to develop
> a full-fledged B-tree library. Nif is a senior graduating this fall in
> computer science from Oberlin College in Ohio, USA. I will be her
> mentor.
>
> Isabelle Carter (IRC nick: ibnc) will be interning on Servo, working
> to add support for fixed positioning. Isabelle is on leave from her
> undergraduate degree in mathematics, and will be working from
> Springfield, Missouri, USA. Lars Bergstrom will be her mentor.
>
> We had many qualified applicants for Rust and Servo's first foray into
> OPW, so it's an honor to be chosen for this program. Please be
> friendly to nif and ibnc if you see them on #rust!
>
> Depending how this round of OPW goes, Rust and/or Servo may
> participate in a future iteration, so if you're interested in
> applying, then keep watching for more announcements. In addition,
> internships at Mozilla working on Rust and Servo (look for the
> "Research Engineering" listing; paid, on-site in the Bay Area) are
> open to all graduate students (undergraduate students with research
> experience have been considered in the past):
> http://careers.mozilla.org/ .
>
> Thanks are due to the Rust and Servo teams -- particularly Lars
> Bergstrom, Brian Anderson, and Jack Moffitt -- for helping many people
> apply for the program, and to the Mozilla coordinator for OPW, Larissa
> Shapiro, for their efforts.
>
> Cheers,
> Tim
>


From michael.letterle+rust at gmail.com  Wed Dec  4 11:50:07 2013
From: michael.letterle+rust at gmail.com (Michael Letterle)
Date: Wed, 4 Dec 2013 14:50:07 -0500
Subject: [rust-dev] Please welcome the Rust and Servo GNOME/OPW interns
 for December 2013-March 2014
In-Reply-To: <529F85CE.1070805@mozilla.com>
References: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>
	<529F85CE.1070805@mozilla.com>
Message-ID: <CA+UdSrvMGV7bT_ARZcJZwEbwsH82L_9wLHPpexb+D-pXx1+bmw@mail.gmail.com>

So much awesome!


On Wed, Dec 4, 2013 at 2:43 PM, Brian Anderson <banderson at mozilla.com>wrote:

> Welcome aboard, Nif and Isabelle. I'm looking forward to working with you.
> And thanks for setting this up, Tim and Lars.
>
>
> On 12/04/2013 08:18 AM, Tim Chevalier wrote:
>
>> Hello,
>>
>> I'm pleased to announce that the winter/spring Rust and Servo interns
>> through the GNOME Outreach Program for Women (
>> https://wiki.gnome.org/OutreachProgramForWomen ) have been chosen. The
>> program starts December 10 and runs until March 10.
>>
>> Nif Ward (IRC nick: nif) will be interning on Rust, working to develop
>> a full-fledged B-tree library. Nif is a senior graduating this fall in
>> computer science from Oberlin College in Ohio, USA. I will be her
>> mentor.
>>
>> Isabelle Carter (IRC nick: ibnc) will be interning on Servo, working
>> to add support for fixed positioning. Isabelle is on leave from her
>> undergraduate degree in mathematics, and will be working from
>> Springfield, Missouri, USA. Lars Bergstrom will be her mentor.
>>
>> We had many qualified applicants for Rust and Servo's first foray into
>> OPW, so it's an honor to be chosen for this program. Please be
>> friendly to nif and ibnc if you see them on #rust!
>>
>> Depending how this round of OPW goes, Rust and/or Servo may
>> participate in a future iteration, so if you're interested in
>> applying, then keep watching for more announcements. In addition,
>> internships at Mozilla working on Rust and Servo (look for the
>> "Research Engineering" listing; paid, on-site in the Bay Area) are
>> open to all graduate students (undergraduate students with research
>> experience have been considered in the past):
>> http://careers.mozilla.org/ .
>>
>> Thanks are due to the Rust and Servo teams -- particularly Lars
>> Bergstrom, Brian Anderson, and Jack Moffitt -- for helping many people
>> apply for the program, and to the Mozilla coordinator for OPW, Larissa
>> Shapiro, for their efforts.
>>
>> Cheers,
>> Tim
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/b5d501ee/attachment-0001.html>

From catamorphism at gmail.com  Wed Dec  4 11:54:26 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Wed, 4 Dec 2013 11:54:26 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298CA4A.7000106@mozilla.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298CA4A.7000106@mozilla.com>
Message-ID: <CADcg8=mPfJB0y8nwDWpBkEGcBxdanGoC9bmUueGSK9B69qa-Pg@mail.gmail.com>

On Fri, Nov 29, 2013 at 9:09 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> I shouldn't say that Rust has no problems with build times--it could always
> be faster, and in particular the memory representations are inefficient,
> particularly around ASTs--but when you actually run with `-Z time-passes`,
> you'll see that the vast majority of the time for any reasonably-sized crate
> is spent in LLVM. There isn't much we can do to make that faster by an order
> of magnitude, other than to try to push on the parallel per-function
> optimization and codegen work that is happening in some upstream branches.
> Mergefunc, disabling exceptions, and the no-zeroing-out stuff that Niko is
> doing would be nice, but they won't improve build times by an order of
> magnitude.

What about caching LLVM bitcode for individual Rust functions / items
(using workcache, for example) and only recompiling those items whose
dependencies have changed? Obviously this would be a lot of design and
implementation work, and one would want to do the math to make sure
it's likely to improve build performance, but offhand I can't see why
it's not feasible.

The scenario I'm thinking of is "add a debug! statement to one
function, and only recompile the code for that function since its
interface hasn't changed". In that case, only regenerating code for
the changed function and not the entire crate should make a big
difference.

Cheers,
Tim

>
> Patrick
>
> [1]:
> https://groups.google.com/forum/#!topic/mozilla.dev.platform/WjcCfckml4A
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From banderson at mozilla.com  Wed Dec  4 12:06:07 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 04 Dec 2013 12:06:07 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
Message-ID: <529F8B2F.9020404@mozilla.com>

On 11/29/2013 03:01 AM, L?o Testard wrote:
>
> Hello,
>
> I think everyone here will agree to say that compilation times in Rust 
> are problematic. Recently, there was an argument on IRC about reducing 
> compilation times by reducing the use of GC and failures. Although I 
> agree it's good to reduce Rustc's overhead, I think there are more 
> important problems. The total duration of a build matters only because 
> you have to recompile the whole crate on each modification. In C++, 
> the duration of the complete build of a project matters less because 
> when you compile incrementally, you only have to rebuild a couple of 
> files - those you modified. I know the "1 crate = 1 compilation unit" 
> is the model chosen by Rust, but this is a major issue for production. 
> Nobody will ever use Rust in production if they have to recompile 
> thousands of lines of code on each modification.
>
> On some of my personal projects, I "solved" this problem by splitting 
> the codebase into several crates, that I compile statically, and then 
> link together using extern mod. This is not really a solution, because 
> this implies that there is no cyclic dependency between each of the 
> small crates, or I end up with issues trying to compile it, because 
> using extern mod requires that the library corresponding to that mod 
> exists before compiling the crate that depends on it.
>
> But strictly speaking, a compiled crate is nothing more than a module 
> hierarchy, and so is a single Rust source file, so we should be able 
> to compile a single file to some sort of .o and then link all together 
> to form a crate. References to modules outside of this file just 
> require the first passes of the build, not the code generation, so it 
> should be ok regarding to cyclic dependencies, and if not, we could 
> still introduce some kind of auto-generated interface file, like Caml 
> does. I know it's quite a big work, and that the current system is 
> quite good, but having this is very important if we want Rust to be 
> used in production.
>

I agree that incremental recompilation would be a good thing to pursue, 
and I'd be happy to see someone work on it, but as you say it is a very 
difficult problem, and it's frankly a low priority. Some other 
compilition performance wins to pursue are removing metadata compression 
(causes dynamic linker crashes on linux), improving llvm perf, and 
improving linker perf.

From banderson at mozilla.com  Wed Dec  4 12:11:46 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 04 Dec 2013 12:11:46 -0800
Subject: [rust-dev] Plz separate mail threads for separated compilation
 [was Re: Separated/Incremential compilation]
In-Reply-To: <52989A9F.2000504@mozilla.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>	<5298790B.3090709@gmail.com>
	<52989A9F.2000504@mozilla.com>
Message-ID: <529F8C82.7050901@mozilla.com>

Thanks Felix. I added this to https://github.com/mozilla/rust/issues/4047

On 11/29/2013 05:46 AM, Felix S. Klock II wrote:
> First off, the topic of rustc slowness and long bootstrap times has 
> indeed been discussed many times.  If you have not yet tried skimming 
> the archives, I recommend doing so, e.g. via
>
> http://lmgtfy.com/?q=+site%3Amail.mozilla.org+rust+crate+compilation+speed
>
> (I provide a (surely incomplete) list of previous-post links below.)
>
> ----
>
> Now, a request: when discussing this topic, please try to avoid 
> conflating:
>
>    1. librustc+libstd bootstrap time,
>
> from the somewhat separate issues of
>
>    2. models for incremental compilation, and
>
>    3. compilation times when running rustc on projects other than 
> rustc itself.
>
>
> In particular, incremental compilation alone is not going to solve 
> (1).  (At least, not as long as one is using the default make rule 
> that rebuilds all of librustc+libstd atop the newly built rustc, and 
> rustc itself draws upon a (large) libstd. Under the latter two 
> constraints, you *have* to redo the build for all of librustc+libstd: 
> the compiler itself was changed. Incremental compilation does not 
> solve this.)
>
> I am concerned that we will waste time debating tasks/designs related 
> to (2) and then people will be disappointed when it does not provide 
> the gains that they were expecting for issues like (1).
>
> ----
>
> In case its not clear from the comments above: the team is well aware 
> that rustc itself runs more slowly than it should; it is a common 
> topic of discussion.
>
> The team is also well aware that the time to bootstrap librustc+libstd 
> is longer than many developers can cope with.
>
> I am not sure I agree with the assertion that the approach of breaking 
> a project into multiple crates is not a solution.  Yes, we may need 
> better tools here (though I don't know how much rustpkg could help 
> with this problem).
>
> ----
>
> As promised, here are some relevant links to previous posts.  In *all* 
> of the cases below, the *whole thread* is often worth review.
>
>   * A great overview from pcwalton
>     Thread subject: " Why does Rust compile slowly?"
> https://mail.mozilla.org/pipermail/rust-dev/2012-October/002462.html
>
>   * In early 2013 there was discussion of easing crate decomposition:
>     Thread subject: " Plans for improving compiler performance"
> https://mail.mozilla.org/pipermail/rust-dev/2013-January/002878.html
>
>   * strcat and graydon each had good points in this discussion:
>     Thread subject: "Please tell me about making rustc faster"
> https://mail.mozilla.org/pipermail/rust-dev/2013-May/004326.html
> https://mail.mozilla.org/pipermail/rust-dev/2013-May/004328.html
>
>   * The team internally discussed whether to break lubrustc into 
> multiple subcrates here:
>     Thread subject: " code generation and rustc speed"
> https://mail.mozilla.org/pipermail/rust-dev/2013-June/004493.html
>
>
> Cheers,
> -Felix
>
> On 29/11/2013 12:22, Guillaume HERVIER wrote:
>> +1 for this issue. I think that compilation time is really important 
>> if we want Rust to be used as production language.
>>
>> For example, I think that if we can reduce significantly the Rust 
>> compiler's compilation time, it could allow more developers to 
>> contribute to the Rust language (as they won't have to wait 30min for 
>> each small modifications in the compiler).
>> Personally, it's the only thing which blocks me when I want to 
>> contribute to Rust, because I like to often compile code when I do 
>> small modifications to test each of these small modifications, partly 
>> because I don't know the language very well.
>>
>> On 11/29/2013 12:01 PM, L?o Testard wrote:
>>>
>>> Hello,
>>>
>>> I think everyone here will agree to say that compilation times in 
>>> Rust are problematic. Recently, there was an argument on IRC about 
>>> reducing compilation times by reducing the use of GC and failures. 
>>> Although I agree it's good to reduce Rustc's overhead, I think there 
>>> are more important problems. The total duration of a build matters 
>>> only because you have to recompile the whole crate on each 
>>> modification. In C++, the duration of the complete build of a 
>>> project matters less because when you compile incrementally, you 
>>> only have to rebuild a couple of files - those you modified. I know 
>>> the "1 crate = 1 compilation unit" is the model chosen by Rust, but 
>>> this is a major issue for production. Nobody will ever use Rust in 
>>> production if they have to recompile thousands of lines of code on 
>>> each modification.
>>>
>>> On some of my personal projects, I "solved" this problem by 
>>> splitting the codebase into several crates, that I compile 
>>> statically, and then link together using extern mod. This is not 
>>> really a solution, because this implies that there is no cyclic 
>>> dependency between each of the small crates, or I end up with issues 
>>> trying to compile it, because using extern mod requires that the 
>>> library corresponding to that mod exists before compiling the crate 
>>> that depends on it.
>>>
>>> But strictly speaking, a compiled crate is nothing more than a 
>>> module hierarchy, and so is a single Rust source file, so we should 
>>> be able to compile a single file to some sort of .o and then link 
>>> all together to form a crate. References to modules outside of this 
>>> file just require the first passes of the build, not the code 
>>> generation, so it should be ok regarding to cyclic dependencies, and 
>>> if not, we could still introduce some kind of auto-generated 
>>> interface file, like Caml does. I know it's quite a big work, and 
>>> that the current system is quite good, but having this is very 
>>> important if we want Rust to be used in production.
>>>
>>> Sorry if this topic has already been posted several times, but I 
>>> feel this is important, and the related issues seem to date (#2369). 
>>> I think it's a real mistake to report this to post-1.0.
>>>
>>> Leo
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> -- 
> irc: pnkfelix on irc.mozilla.org
> email: {fklock,pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/cbae9c46/attachment.html>

From pwalton at mozilla.com  Wed Dec  4 12:26:09 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Wed, 04 Dec 2013 12:26:09 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CADcg8=mPfJB0y8nwDWpBkEGcBxdanGoC9bmUueGSK9B69qa-Pg@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298CA4A.7000106@mozilla.com>
	<CADcg8=mPfJB0y8nwDWpBkEGcBxdanGoC9bmUueGSK9B69qa-Pg@mail.gmail.com>
Message-ID: <3f11298d-eafa-4410-896b-13d0f662c2d2@email.android.com>

Maybe this should be done upstream in LLVM, actually. Seems like work that would be applicable to e.g. clang with LTO as well.

Tim Chevalier <catamorphism at gmail.com> wrote:
>On Fri, Nov 29, 2013 at 9:09 AM, Patrick Walton <pcwalton at mozilla.com>
>wrote:
>> I shouldn't say that Rust has no problems with build times--it could
>always
>> be faster, and in particular the memory representations are
>inefficient,
>> particularly around ASTs--but when you actually run with `-Z
>time-passes`,
>> you'll see that the vast majority of the time for any
>reasonably-sized crate
>> is spent in LLVM. There isn't much we can do to make that faster by
>an order
>> of magnitude, other than to try to push on the parallel per-function
>> optimization and codegen work that is happening in some upstream
>branches.
>> Mergefunc, disabling exceptions, and the no-zeroing-out stuff that
>Niko is
>> doing would be nice, but they won't improve build times by an order
>of
>> magnitude.
>
>What about caching LLVM bitcode for individual Rust functions / items
>(using workcache, for example) and only recompiling those items whose
>dependencies have changed? Obviously this would be a lot of design and
>implementation work, and one would want to do the math to make sure
>it's likely to improve build performance, but offhand I can't see why
>it's not feasible.
>
>The scenario I'm thinking of is "add a debug! statement to one
>function, and only recompile the code for that function since its
>interface hasn't changed". In that case, only regenerating code for
>the changed function and not the entire crate should make a big
>difference.
>
>Cheers,
>Tim
>
>>
>> Patrick
>>
>> [1]:
>>
>https://groups.google.com/forum/#!topic/mozilla.dev.platform/WjcCfckml4A
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>-- 
>Tim Chevalier * http://catamorphism.org/ * Often in error, never in
>doubt
>"If you are silent about your pain, they'll kill you and say you
>enjoyed it."
>-- Zora Neale Hurston

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/0b4e0cb4/attachment-0001.html>

From bill_myers at outlook.com  Wed Dec  4 12:36:00 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 4 Dec 2013 20:36:00 +0000
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529ED9A4.4080901@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
Message-ID: <BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>




Hello, I already implemented a persistent tree-map called SnapMap: you can find the source code at https://github.com/mozilla/rust/pull/9816

I stopped working on it before I made a serious effort to push it into the Rust codebase and don't have time to work further on it, so it would be awesome if you were interested in continuing that effort.

It's pretty much finished, but pretty much completely untested (however, it was derived from the existing treemap, so the amount of bugs should not be as high as something written from scratch and untested).

The first thing that needs to be done is to run the existing tests inherited from treemap, fix any bug that shows up, and then write more tests to test SnapMap specific usage patterns and features.

Then, one should look at the mutable/handle-based iterators in the code and decide whether they should be removed, kept as is, or improved, possibly after changing the iterator interface to return an object with the lifetime of the function call instead of the iterator.

The rest of the code should be fine (except for bugs due to no testing), but there might be places where unnecessary copy-on-write is performed.

My code used an improved version of Rc that supports copy-on-write by cloning only when reference count > 1.


 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/739f329f/attachment.html>

From ben.striegel at gmail.com  Wed Dec  4 12:54:55 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 4 Dec 2013 15:54:55 -0500
Subject: [rust-dev] Please welcome the Rust and Servo GNOME/OPW interns
 for December 2013-March 2014
In-Reply-To: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>
References: <CADcg8=nEGCO_tGVM33v05ZLM+vDsoEBw1OMQgOFgVq3ji42Jww@mail.gmail.com>
Message-ID: <CAAvrL-mxjnx5=7MbuopD1ja-S9iSzb4s-pdJkFZ6RRC4=wXAhA@mail.gmail.com>

Hooray, welcome to our new contributors! :) And thanks to our mentors and
coordinators as well!


On Wed, Dec 4, 2013 at 11:18 AM, Tim Chevalier <catamorphism at gmail.com>wrote:

> Hello,
>
> I'm pleased to announce that the winter/spring Rust and Servo interns
> through the GNOME Outreach Program for Women (
> https://wiki.gnome.org/OutreachProgramForWomen ) have been chosen. The
> program starts December 10 and runs until March 10.
>
> Nif Ward (IRC nick: nif) will be interning on Rust, working to develop
> a full-fledged B-tree library. Nif is a senior graduating this fall in
> computer science from Oberlin College in Ohio, USA. I will be her
> mentor.
>
> Isabelle Carter (IRC nick: ibnc) will be interning on Servo, working
> to add support for fixed positioning. Isabelle is on leave from her
> undergraduate degree in mathematics, and will be working from
> Springfield, Missouri, USA. Lars Bergstrom will be her mentor.
>
> We had many qualified applicants for Rust and Servo's first foray into
> OPW, so it's an honor to be chosen for this program. Please be
> friendly to nif and ibnc if you see them on #rust!
>
> Depending how this round of OPW goes, Rust and/or Servo may
> participate in a future iteration, so if you're interested in
> applying, then keep watching for more announcements. In addition,
> internships at Mozilla working on Rust and Servo (look for the
> "Research Engineering" listing; paid, on-site in the Bay Area) are
> open to all graduate students (undergraduate students with research
> experience have been considered in the past):
> http://careers.mozilla.org/ .
>
> Thanks are due to the Rust and Servo teams -- particularly Lars
> Bergstrom, Brian Anderson, and Jack Moffitt -- for helping many people
> apply for the program, and to the Mozilla coordinator for OPW, Larissa
> Shapiro, for their efforts.
>
> Cheers,
> Tim
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed
> it."
> -- Zora Neale Hurston
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/b32460e5/attachment.html>

From ml at isaac.cedarswampstudios.org  Wed Dec  4 13:17:58 2013
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Wed, 04 Dec 2013 16:17:58 -0500
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529F7E04.3000809@posteo.de>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>	<529EE687.2060004@mozilla.com>
	<529F7E04.3000809@posteo.de>
Message-ID: <529F9C06.7080801@isaac.cedarswampstudios.org>

On 12/04/2013 02:09 PM, Michael Woerister wrote:
>>> Is it
>>> possible for the structure to be parametrized on smart pointer?
>>
>> Not without higher kinded types (which eventually we do want--so the
>> answer is "not yet").
>
> And then we can define a container type, using the generic reference type:
>
> struct Container<T, TRef, TRefFactory> {
>      items: ~[TRef],
>      reference_factory: TRefFactory
> }

Clever solution!  In the cons list, it needs to be a reference to 
Node<T>, not to T.  Every persistent container library would have to 
expose its node type and take as a parameter an allocator for its 
Node<T>.  Simplified example:

enum Node<T, TNodeRef> {
   Nil,
   Cons(T, TNodeRef)
}

type IntList = Rc<Node<int, IntList>>;

But that is an infinite type and, as such, does not compile.  Instead using

struct IntList(Rc<Node<int, IntList>>);

works and could implement the necessary traits.  Or better,

struct RcList<T>(Rc<Node<T, RcList<T>>>);

Ooh, this is within the realm of maybe being reasonable.  A persistent 
data structure module could provide RcList and ArcList versions.  Is 
performance affected by the use of traits for this strategy, or does the 
way Rust generics are compiled make that a non-issue?  Are there other 
reasons this is a terrible idea? :)

-Isaac


From danielmicay at gmail.com  Wed Dec  4 13:28:18 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 4 Dec 2013 16:28:18 -0500
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529F9C06.7080801@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<529EE687.2060004@mozilla.com> <529F7E04.3000809@posteo.de>
	<529F9C06.7080801@isaac.cedarswampstudios.org>
Message-ID: <CA+DvKQLw0+kY=MejFeYeJF+Q4ea3SfF_J3D9==_x95acA_aNYw@mail.gmail.com>

On Wed, Dec 4, 2013 at 4:17 PM, Isaac Dupree
<ml at isaac.cedarswampstudios.org> wrote:
> On 12/04/2013 02:09 PM, Michael Woerister wrote:
>>>>
>>>> Is it
>>>> possible for the structure to be parametrized on smart pointer?
>>>
>>>
>>> Not without higher kinded types (which eventually we do want--so the
>>> answer is "not yet").
>>
>>
>> And then we can define a container type, using the generic reference type:
>>
>> struct Container<T, TRef, TRefFactory> {
>>      items: ~[TRef],
>>      reference_factory: TRefFactory
>> }
>
>
> Clever solution!  In the cons list, it needs to be a reference to Node<T>,
> not to T.  Every persistent container library would have to expose its node
> type and take as a parameter an allocator for its Node<T>.  Simplified
> example:
>
> enum Node<T, TNodeRef> {
>   Nil,
>   Cons(T, TNodeRef)
> }
>
> type IntList = Rc<Node<int, IntList>>;
>
> But that is an infinite type and, as such, does not compile.  Instead using
>
> struct IntList(Rc<Node<int, IntList>>);
>
> works and could implement the necessary traits.  Or better,
>
> struct RcList<T>(Rc<Node<T, RcList<T>>>);
>
> Ooh, this is within the realm of maybe being reasonable.  A persistent data
> structure module could provide RcList and ArcList versions.  Is performance
> affected by the use of traits for this strategy, or does the way Rust
> generics are compiled make that a non-issue?  Are there other reasons this
> is a terrible idea? :)
>
> -Isaac

Generics are equivalent to substituting all of the type parameters
with the concrete type by hand. Specialized code is generated for each
set of type parameters with removing the duplication left up to LLVM
(`mergefunc` is close to being completely stable).

From ml at isaac.cedarswampstudios.org  Wed Dec  4 13:42:51 2013
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Wed, 04 Dec 2013 16:42:51 -0500
Subject: [rust-dev] Persistent data structures
In-Reply-To: <BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>
	<BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>
Message-ID: <529FA1DB.9030000@isaac.cedarswampstudios.org>

On 12/04/2013 03:36 PM, Bill Myers wrote:
> Hello, I already implemented a persistent tree-map called SnapMap: you
> can find the source code at https://github.com/mozilla/rust/pull/9816
>
> I stopped working on it before I made a serious effort to push it into
> the Rust codebase and don't have time to work further on it, so it would
> be awesome if you were interested in continuing that effort.
>
> It's pretty much finished, but pretty much completely untested (however,
> it was derived from the existing treemap, so the amount of bugs should
> not be as high as something written from scratch and untested).
>
> The first thing that needs to be done is to run the existing tests
> inherited from treemap, fix any bug that shows up, and then write more
> tests to test SnapMap specific usage patterns and features.

Yay!  Looks like I should start by collecting the various existing 
persistent structures (your SnapMap, Michael's HAMT, extra::list) and 
polishing them up.

> Then, one should look at the mutable/handle-based iterators in the code
> and decide whether they should be removed, kept as is, or improved,
> possibly after changing the iterator interface to return an object with
> the lifetime of the function call instead of the iterator.
>
> The rest of the code should be fine (except for bugs due to no testing),
> but there might be places where unnecessary copy-on-write is performed.
>
> My code used an improved version of Rc that supports copy-on-write by
> cloning only when reference count > 1.

Did COW improve performance?  What's a good way to do performance 
testing of Rust code?

Should I try to get your patches to Rc and Arc merged?  They look 
generally useful, if folks think they fit the design of Rc.  You also 
have a patch that adds Own<T> to std which is equivalent to ~T but has 
methods that look like Rc's.  You use this, and putting most of your 
treemap.rs inside macro definitions, to get a sort of 
reference-type-polymorphism in your treemap.  Shall I continue with this 
approach and try to get Own<T> merged too?  (Opinions from anybody are 
welcome.)

(I used https://github.com/mozilla/rust/pull/9816/files + click "Show 
Diff Stats" to look through the changes)

-Isaac


From hatahet at gmail.com  Wed Dec  4 17:07:10 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 4 Dec 2013 17:07:10 -0800
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
Message-ID: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>

To be taken with a grain of salt, naturally:
https://www.youtube.com/watch?v=TS1lpKBMkgg


--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/671ab39e/attachment-0001.html>

From bill_myers at outlook.com  Wed Dec  4 18:15:06 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Thu, 5 Dec 2013 02:15:06 +0000
Subject: [rust-dev] Persistent data structures
In-Reply-To: <529FA1DB.9030000@isaac.cedarswampstudios.org>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>,
	<BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>,
	<529FA1DB.9030000@isaac.cedarswampstudios.org>
Message-ID: <BAY170-W706439C41008F2FA575F12F8D70@phx.gbl>

> Did COW improve performance?  What's a good way to do performance 
> testing of Rust code?

The reason I introduced COW when RC > 1 is that it allows persistent data structures to be mutated in place if there aren't extra references, just like non-persistent data structures.

Lots of languages with persistent data structures can't do that because they use garbage collection (and thus they can't tell whether there are other references due to lack of a reference count), but it seems an essential feature to have if one is using reference counting in a language like Rust that is supposed to be a systems language producing optimal code.

> Should I try to get your patches to Rc and Arc merged?  They look 
> generally useful, if folks think they fit the design of Rc.  You also 
> have a patch that adds Own<T> to std which is equivalent to ~T but has 
> methods that look like Rc's.  You use this, and putting most of your 
> treemap.rs inside macro definitions, to get a sort of 
> reference-type-polymorphism in your treemap.  Shall I continue with this 
> approach and try to get Own<T> merged too?  (Opinions from anybody are 
> welcome.)

I did it because I realized that having two different balanced tree implementations would have imposed a significant maintenance burden, and thus the macro and Own<T> approach would have allowed to avoid that by replacing the current treemap code completely with the new optionally-persistent version.

Also, having both Rc and Arc versions seems quite useful anyway, and currently I think macros are the best way to have both, until Rust starts supporting higher-kinded types (which would allow to pass Rc as a parameter), or at least recursive types (which would allow to express Rc<TreeNode<T, Rc<TreeNode, T, ... and pass it as a parameter).

I don't have much more input on what the best names for the methods are, whether to have Own<T> instead of ~T and so on; I guess someone on the Rust core team will have to decide on that, and there's already some discussion on that on https://github.com/mozilla/rust/pull/9786

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/d7a07383/attachment.html>

From me at kevincantu.org  Wed Dec  4 19:36:24 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Wed, 4 Dec 2013 19:36:24 -0800
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
Message-ID: <CABq6+af-KQbxKu6XVK8DYPho9Z=83_FR3pd7kd7gQbA1+O0uHw@mail.gmail.com>

There are a couple parts of the Rust compiler about which I've heard
people say "if I knew how that worked, I'd fix it so that we could do
..."  So I definitely thought of Rust when watching that.

I think it is very encouraging to see so how many components Rust has
pushed out of the core and into libraries in the last year or so,
though.  Rust seems a long way from ossification.

Considering Scala, count me pre-emptively as a fan of rustz.
Hopefully we can avoid that kind of apparent community split,
though...


Kevin



On Wed, Dec 4, 2013 at 5:07 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
> To be taken with a grain of salt, naturally:
> https://www.youtube.com/watch?v=TS1lpKBMkgg
>
>
> --
> Ziad
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From pcwalton at mozilla.com  Wed Dec  4 19:46:41 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 04 Dec 2013 19:46:41 -0800
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CABq6+af-KQbxKu6XVK8DYPho9Z=83_FR3pd7kd7gQbA1+O0uHw@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<CABq6+af-KQbxKu6XVK8DYPho9Z=83_FR3pd7kd7gQbA1+O0uHw@mail.gmail.com>
Message-ID: <529FF721.6010908@mozilla.com>

On 12/4/13 7:36 PM, Kevin Cantu wrote:
> There are a couple parts of the Rust compiler about which I've heard
> people say "if I knew how that worked, I'd fix it so that we could do
> ..."  So I definitely thought of Rust when watching that.

The Rust compiler is not that bad. Niko and I, as well as several others 
I'm sure, know how basically all of it works, at least at a high level. 
I think it's true that in any large piece of software, it's never true 
that everyone knows precisely how all of it works. The biggest problem 
with the Rust compiler, I think, is much of it is written in an old Rust 
style, and modernizing its style would not take too long. (Unfortunately 
we're all racing to 1.0 and on the core team such modernization will 
have to take a back seat to the 1.0-incompatible language changes... but 
that said we should not allow our technical debt to garner too much 
interest.)

The particular criticisms of the Scala compiler, that the front-end does 
too much desugaring and that code is a string, are definitely not true 
for the Rust compiler. (Well, OK, `for` is desugared too early, but that 
has to be fixed before 1.0 anyway because this desugaring is actually 
incorrect.)

Niko and Jed, just to name two, have done a lot of work to improve the 
state of the Rust compiler, for example by rewriting type unification, 
rewriting ad-hoc passes to use the CFG produced by liveness analysis, 
introducing `Datum`, and creating a universal ADT type to represent data 
types. There is more work to be done, of course, and I think we should 
very much hold the line against additional cruft being added to the 
compiler at this point, but I think we're OK as long as we keep moving 
in the right direction.

Patrick


From pcwalton at mozilla.com  Wed Dec  4 19:53:10 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 04 Dec 2013 19:53:10 -0800
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
Message-ID: <529FF8A6.2050008@mozilla.com>

On 12/4/13 5:07 PM, Ziad Hatahet wrote:
> To be taken with a grain of salt, naturally:
> https://www.youtube.com/watch?v=TS1lpKBMkgg

I watched some of this. Some notes on specific criticisms follow. (Many 
of the criticisms are too abstract to really confront head-on 
though--for example, "correctness versus performance".)

1. *The compiler is too hard to modify.* See my other message in the thread.

2. *Universal equality is bad.* Rust doesn't do it.

3. *Using inheritance for collection mutability is bad.* Rust doesn't do it.

4. *The argument to functions such as "filter" should be pure to allow 
for stream fusion.* Purity is hard in Rust. We tried it and the 
annotation burden was too high. At least our iterators allow for more 
stream fusion than creating intermediate data structures would.

5. *Forbid reference equality.* Incompatible with the systems language 
nature of Rust.

6. *Silent coercion between primitives is bad.* Rust doesn't do it.

7. *Don't try to be too general purpose.* Rust is explicitly not 
designed to be a language for all use cases.

8. *Unnecessary expressiveness is the enemy.* I think we've been holding 
the line on language complexity quite well, even for features that are 
popular like `&once fn`.

Patrick


From qwertie256 at gmail.com  Wed Dec  4 20:03:42 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Wed, 4 Dec 2013 21:03:42 -0700
Subject: [rust-dev] Persistent data structures
Message-ID: <CAHuo6ZDPjOsuahE7SH1YJNWbKhRY5sPg2b+ada7Qxzw77kmi9w@mail.gmail.com>

>My next goal is a persistent tree-map, probably cribbing from Haskell's
>Data.Map.

I look forward to hearing how that goes!

I've been meaning to make a data structure in Rust too, but it's hard to
find the time, so how's about I tell you guys about it instead.

I call my data structure an "optionally-persistent" hashtable or hashset.
In C# I implemented this "optionally-persistent" hashtable and hashset with
mutable and immutable variants of each (the term "semi-persistent" was
already taken and means something else). I've been meaning to write an
article about this, but didn't get around to it yet.

Optionally-persistent means that it's structured as if it were persistent,
but each node can be either mutable (locally) or immutable (recursively).
Each node has a "frozen" flag which implicitly applies recursively to all
children. Converting the tree from immutable to mutable, or mutable to
immutable takes O(1) time. Immutable to mutable is essentially a no-op (the
mutable copy has copy-on-write behavior), while mutable-to-immutable simply
requires marking the root node as frozen.

The "hashtable" is really a tree that is up to 8 levels deep, with each
level representing 4 bits of the hashcode (not sure if this is the best
approach). Lots more details in the doc comment:

https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Collections/Sets/InternalSet.cs

My benchmarks show that mutating such a set/map is dramatically faster than
immutable editing (which requires copying multiple nodes for each change),
and not that much slower than a traditional hashtable, so I think it's
"hands down" superior to a traditional persistent hash tree.

In my version, from the end-user's perspective, there's a separate data
type for immutable and mutable versions of the data structure (MMap<T> and
MSet<T> are mutable, Map<T> and Set<T> are immutable). Both data types
encapsulate an instance of InternalSet<T> which is the "real" data
structure. InternalSet<T> manages a tree of nodes, where each node has 16
entries and represents 4 bits of the hashcode. There's also an interesting
variation called InvertibleSet<T>; an invertible set can represent a
negative set such as "all integers except 0 and 1".

-- 
- David
http://loyc-etc.blogspot.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/5cc506cc/attachment.html>

From bjzaba at yahoo.com.au  Wed Dec  4 20:18:03 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 5 Dec 2013 14:18:03 +1000
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <529FF721.6010908@mozilla.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<CABq6+af-KQbxKu6XVK8DYPho9Z=83_FR3pd7kd7gQbA1+O0uHw@mail.gmail.com>
	<529FF721.6010908@mozilla.com>
Message-ID: <CFD835C1-CF89-4156-9BA9-12FD9A32CF98@yahoo.com.au>

On 5 Dec 2013, at 1:46 pm, Patrick Walton <pcwalton at mozilla.com> wrote:

> The particular criticisms of the Scala compiler, that the front-end does too much desugaring and that code is a string, are definitely not true for the Rust compiler. (Well, OK, `for` is desugared too early, but that has to be fixed before 1.0 anyway because this desugaring is actually incorrect.)

Whilst desugaring too early is indeed an issue for creating a robust compiler, would it still make sense to think of how these language features desugar on a design/theoretical level? Then once these are set in stone for 1.0, document these transformations?

~Brendan

From ben.striegel at gmail.com  Wed Dec  4 21:29:03 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 5 Dec 2013 00:29:03 -0500
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <529FF8A6.2050008@mozilla.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<529FF8A6.2050008@mozilla.com>
Message-ID: <CAAvrL-nT0r8=ObSKzeHfAbX50fUD6k86_cKzLAiQwGzAPOyBfw@mail.gmail.com>

> 3. *Using inheritance for collection mutability is bad.* Rust doesn't do
it.

Is this an argument against generalizing over mutability at all (as I
believe has been proposed in the past)?


On Wed, Dec 4, 2013 at 10:53 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/4/13 5:07 PM, Ziad Hatahet wrote:
>
>> To be taken with a grain of salt, naturally:
>> https://www.youtube.com/watch?v=TS1lpKBMkgg
>>
>
> I watched some of this. Some notes on specific criticisms follow. (Many of
> the criticisms are too abstract to really confront head-on though--for
> example, "correctness versus performance".)
>
> 1. *The compiler is too hard to modify.* See my other message in the
> thread.
>
> 2. *Universal equality is bad.* Rust doesn't do it.
>
> 3. *Using inheritance for collection mutability is bad.* Rust doesn't do
> it.
>
> 4. *The argument to functions such as "filter" should be pure to allow for
> stream fusion.* Purity is hard in Rust. We tried it and the annotation
> burden was too high. At least our iterators allow for more stream fusion
> than creating intermediate data structures would.
>
> 5. *Forbid reference equality.* Incompatible with the systems language
> nature of Rust.
>
> 6. *Silent coercion between primitives is bad.* Rust doesn't do it.
>
> 7. *Don't try to be too general purpose.* Rust is explicitly not designed
> to be a language for all use cases.
>
> 8. *Unnecessary expressiveness is the enemy.* I think we've been holding
> the line on language complexity quite well, even for features that are
> popular like `&once fn`.
>
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/f3b1d90a/attachment.html>

From pcwalton at mozilla.com  Wed Dec  4 21:31:51 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 04 Dec 2013 21:31:51 -0800
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CAAvrL-nT0r8=ObSKzeHfAbX50fUD6k86_cKzLAiQwGzAPOyBfw@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>	<529FF8A6.2050008@mozilla.com>
	<CAAvrL-nT0r8=ObSKzeHfAbX50fUD6k86_cKzLAiQwGzAPOyBfw@mail.gmail.com>
Message-ID: <52A00FC7.90908@mozilla.com>

On 12/4/13 9:29 PM, Benjamin Striegel wrote:
>  > 3. *Using inheritance for collection mutability is bad.* Rust doesn't
> do it.
>
> Is this an argument against generalizing over mutability at all (as I
> believe has been proposed in the past)?

According to the talk it's more of a problem specific to OO-style 
*inheritance* (which we do have an equivalent to via default methods, 
but stylistically we don't use it unless it really fits the problem).

Patrick


From ohler at gnu.org  Wed Dec  4 22:17:18 2013
From: ohler at gnu.org (Christian Ohler)
Date: Wed, 4 Dec 2013 22:17:18 -0800
Subject: [rust-dev] Error casting to trait: "value may contain borrowed
	pointers"
In-Reply-To: <529C9003.10302@mozilla.com>
References: <CAPzKZDw5YXTxTYkJNvVHrdb4norENAEObPBxtdOx=N8MCw+HKA@mail.gmail.com>
	<529C9003.10302@mozilla.com>
Message-ID: <CAPzKZDzvNpd6a1zb6kE-wnjmVNU_9dCD8n1VtkEpKYLpZx==Mw@mail.gmail.com>

I see, thanks for the explanation.  Looks like a compiler bug, then.
I'll work around it with an unsafe transmute for now.

Thanks,
Christian.


On Mon, Dec 2, 2013 at 5:49 AM, Felix S. Klock II <pnkfelix at mozilla.com> wrote:
> rust-dev-
>
> In general, we need to ensure that for an expression `<source> as <target>`
> that any borrowed pointers in the type of <source> are not obscured [1] by
> the cast.
>
> A  collection of conditions sufficient to enforce this are listed in a
> comment in librustc/middle/kind.rs that I think is apropos here:
>
> https://github.com/mozilla/rust/blob/master/src/librustc/middle/kind.rs#L488
>
> However, there are probably other conditions that would also suffice that we
> might add to that set.
>
> In particular, I do not see anything immediately wrong with your example;
> the type-expression  `&'a V` should ensure that `V` does not contain any
> lifetimes that are shorter than 'a, and therefore it should be safe to cast
> `v: &'a V` to a `&'a T`.
>
> I have filed this as issue #10766 [2].
>
> Cheers,
> -Felix
>
> [1] https://github.com/mozilla/rust/issues/5723
>
> [2] https://github.com/mozilla/rust/issues/10766
>
>
> On 30/11/2013 23:22, Christian Ohler wrote:
>>
>> Hi all,
>>
>> I'm trying to learn rust and ran into an error message I don't
>> understand, and would appreciate some help.  This code:
>>
>> trait T {}
>>
>> fn f<'a, V: T>(v: &'a V) -> &'a T {
>>      v as &'a T
>> }
>>
>>
>> is rejected with this error message:
>>
>> trait-cast.rs:4:4: 4:5 error: value may contain borrowed pointers; add
>> `'static` bound
>> trait-cast.rs:4     v as &'a T
>>
>>
>> I'm trying to upcast from V to T so that I can put v in a container of
>> element type T (in code not shown here).  The suggestion to add a
>> 'static bound doesn't sound like what I'm looking for.
>>
>> What is the concern about borrowed pointers here?  What would an
>> implementation of T and a caller of f look like to lead to a safety
>> problem?
>>
>> I'm using a version of rust that is a few days old.
>>
>> Thanks,
>> Christian.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From qwertie256 at gmail.com  Wed Dec  4 22:23:02 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Wed, 4 Dec 2013 23:23:02 -0700
Subject: [rust-dev] Persistent data structures
In-Reply-To: <CAHuo6ZDPjOsuahE7SH1YJNWbKhRY5sPg2b+ada7Qxzw77kmi9w@mail.gmail.com>
References: <CAHuo6ZDPjOsuahE7SH1YJNWbKhRY5sPg2b+ada7Qxzw77kmi9w@mail.gmail.com>
Message-ID: <CAHuo6ZCiMFofNyrW47NAG8WEgRqmtnMDLrA8uU5wWNr8FMROTA@mail.gmail.com>

Please disregard this message; I hadn't seen Bill Myers' solution
("copy-on-write
by cloning only when reference count > 1"), which sounds like it's probably
perfect for Rust.


On Wed, Dec 4, 2013 at 9:03 PM, David Piepgrass <qwertie256 at gmail.com>wrote:

> >My next goal is a persistent tree-map, probably cribbing from Haskell's
> >Data.Map.
>
> I look forward to hearing how that goes!
>
> I've been meaning to make a data structure in Rust too, but it's hard to
> find the time, so how's about I tell you guys about it instead.
>
> I call my data structure an "optionally-persistent" hashtable or hashset.
> In C# I implemented this "optionally-persistent" hashtable and hashset with
> mutable and immutable variants of each (the term "semi-persistent" was
> already taken and means something else). I've been meaning to write an
> article about this, but didn't get around to it yet.
>
> Optionally-persistent means that it's structured as if it were persistent,
> but each node can be either mutable (locally) or immutable (recursively).
> Each node has a "frozen" flag which implicitly applies recursively to all
> children. Converting the tree from immutable to mutable, or mutable to
> immutable takes O(1) time. Immutable to mutable is essentially a no-op (the
> mutable copy has copy-on-write behavior), while mutable-to-immutable simply
> requires marking the root node as frozen.
>
> The "hashtable" is really a tree that is up to 8 levels deep, with each
> level representing 4 bits of the hashcode (not sure if this is the best
> approach). Lots more details in the doc comment:
>
>
> https://sourceforge.net/p/loyc/code/HEAD/tree/Src/Loyc.Collections/Sets/InternalSet.cs
>
> My benchmarks show that mutating such a set/map is dramatically faster
> than immutable editing (which requires copying multiple nodes for each
> change), and not that much slower than a traditional hashtable, so I think
> it's "hands down" superior to a traditional persistent hash tree.
>
> In my version, from the end-user's perspective, there's a separate data
> type for immutable and mutable versions of the data structure (MMap<T> and
> MSet<T> are mutable, Map<T> and Set<T> are immutable). Both data types
> encapsulate an instance of InternalSet<T> which is the "real" data
> structure. InternalSet<T> manages a tree of nodes, where each node has 16
> entries and represents 4 bits of the hashcode. There's also an interesting
> variation called InvertibleSet<T>; an invertible set can represent a
> negative set such as "all integers except 0 and 1".
>
> --
> - David
> http://loyc-etc.blogspot.com
>
>


-- 
- David
http://qism.blogspot.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131204/d736dbdd/attachment.html>

From philippe.delrieu at free.fr  Thu Dec  5 00:43:49 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 05 Dec 2013 09:43:49 +0100
Subject: [rust-dev] new compile errors in the master since a few days
Message-ID: <52A03CC5.7070500@free.fr>

Hello,

since a few days, I have a lot of new errors in the master compiler. For 
example in the rust_zmq lib that I use. When I compile it I have these 
errors :
321:9 error: last argument in `do` call has non-procedure type: |*i8| -> 
<V3>
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319 
let rc = do endpoint.with_c_str |cstr| {
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320 
unsafe {zmq_bind(self.sock, cstr)}
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321 
};
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29: 
330:9 error: last argument in `do` call has non-procedure type: |*i8| -> 
<V3>
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328 
let rc = do endpoint.with_c_str |cstr| {
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329 
unsafe {zmq_connect(self.sock, cstr)}
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330 
};
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16: 
352:9 error: last argument in `do` call has non-procedure type: |*u8, 
uint| -> <V3>
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337 
do data.as_imm_buf |base_ptr, len| {
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338 
let msg = [0, ..32];
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340 
unsafe {
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341 
// Copy the data into the message.
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 
zmq_msg_init_size(&msg, len as size_t);
...
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40: 
342:43 error: the type of this value must be known in this context
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 
zmq_msg_init_size(&msg, len as size_t);
^~~
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16: 
344:32 error: cannot determine a type for this bounded type parameter: 
unconstrained type
/home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344 
ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
^~~~~~~~~~~~~~~~
I have the same type of errors in my code plus other error when the 
trait can't be found like type `MyType` does not implement any method in 
scope named `encode` and the function is implemented just above.
This code where compiling last week.

Philippe Delrieu


From kevin at sb.org  Thu Dec  5 00:56:14 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 5 Dec 2013 00:56:14 -0800
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <52A03CC5.7070500@free.fr>
References: <52A03CC5.7070500@free.fr>
Message-ID: <DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>

`do` no longer works with stack closures. It now only works with the new proc() type, which basically means you're only going to see it used with spawn().

You need to now say something like

    let rc = endpoint.with_c_str(|cstr| {
        unsafe {smq_bind(self.sock, cstr)}
    });

I can't speculate on your encode error without seeing it.

-Kevin

On Dec 5, 2013, at 12:43 AM, Philippe Delrieu <philippe.delrieu at free.fr> wrote:

> Hello,
> 
> since a few days, I have a lot of new errors in the master compiler. For example in the rust_zmq lib that I use. When I compile it I have these errors :
> 321:9 error: last argument in `do` call has non-procedure type: |*i8| -> <V3>
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319 let rc = do endpoint.with_c_str |cstr| {
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320 unsafe {zmq_bind(self.sock, cstr)}
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321 };
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29: 330:9 error: last argument in `do` call has non-procedure type: |*i8| -> <V3>
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328 let rc = do endpoint.with_c_str |cstr| {
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329 unsafe {zmq_connect(self.sock, cstr)}
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330 };
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16: 352:9 error: last argument in `do` call has non-procedure type: |*u8, uint| -> <V3>
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337 do data.as_imm_buf |base_ptr, len| {
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338 let msg = [0, ..32];
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340 unsafe {
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341 // Copy the data into the message.
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 zmq_msg_init_size(&msg, len as size_t);
> ...
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40: 342:43 error: the type of this value must be known in this context
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 zmq_msg_init_size(&msg, len as size_t);
> ^~~
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16: 344:32 error: cannot determine a type for this bounded type parameter: unconstrained type
> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344 ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
> ^~~~~~~~~~~~~~~~
> I have the same type of errors in my code plus other error when the trait can't be found like type `MyType` does not implement any method in scope named `encode` and the function is implemented just above.
> This code where compiling last week.
> 
> Philippe Delrieu
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From philippe.delrieu at free.fr  Thu Dec  5 01:53:35 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 05 Dec 2013 10:53:35 +0100
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>
References: <52A03CC5.7070500@free.fr>
	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>
Message-ID: <52A04D1F.3040102@free.fr>

Thank you it correct my first problems.

I didn't send code because I thought it has the same cause. For the last 
problems the code is :

use extra::serialize;
use extra::json::{Json, Decoder, ToJson, Object, Encoder, Decoder};
use extra::treemap::TreeMap;
use std::io::Decorator;

//second struct with manually implemented  Decodable, Encodable
#[deriving(Decodable, Encodable, Eq)]
pub struct TestStruct2    {
     dataInt: u8,
     dataStr:~str,
     dataArray:~[u8],
}

     let test3 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto", 
dataArray:~[2,3,4,5]}; 
//{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
     let mut m3 = MemWriter::new();
     {
         let mut encoder3 =Encoder::init(&mut m3 as &mut Writer);
         test3.encode(&mut encoder3);
     }

Rustc result :
test_json.rs:292:8: 292:36 error: type `TestStruct2` does not implement 
any method in scope named `encode`
test/test_json.rs:292         test3.encode(&mut encoder3);

Philippe



Le 05/12/2013 09:56, Kevin Ballard a ?crit :
> `do` no longer works with stack closures. It now only works with the new proc() type, which basically means you're only going to see it used with spawn().
>
> You need to now say something like
>
>      let rc = endpoint.with_c_str(|cstr| {
>          unsafe {smq_bind(self.sock, cstr)}
>      });
>
> I can't speculate on your encode error without seeing it.
>
> -Kevin
>
> On Dec 5, 2013, at 12:43 AM, Philippe Delrieu <philippe.delrieu at free.fr> wrote:
>
>> Hello,
>>
>> since a few days, I have a lot of new errors in the master compiler. For example in the rust_zmq lib that I use. When I compile it I have these errors :
>> 321:9 error: last argument in `do` call has non-procedure type: |*i8| -> <V3>
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319 let rc = do endpoint.with_c_str |cstr| {
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320 unsafe {zmq_bind(self.sock, cstr)}
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321 };
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29: 330:9 error: last argument in `do` call has non-procedure type: |*i8| -> <V3>
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328 let rc = do endpoint.with_c_str |cstr| {
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329 unsafe {zmq_connect(self.sock, cstr)}
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330 };
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16: 352:9 error: last argument in `do` call has non-procedure type: |*u8, uint| -> <V3>
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337 do data.as_imm_buf |base_ptr, len| {
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338 let msg = [0, ..32];
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340 unsafe {
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341 // Copy the data into the message.
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 zmq_msg_init_size(&msg, len as size_t);
>> ...
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40: 342:43 error: the type of this value must be known in this context
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 zmq_msg_init_size(&msg, len as size_t);
>> ^~~
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16: 344:32 error: cannot determine a type for this bounded type parameter: unconstrained type
>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344 ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
>> ^~~~~~~~~~~~~~~~
>> I have the same type of errors in my code plus other error when the trait can't be found like type `MyType` does not implement any method in scope named `encode` and the function is implemented just above.
>> This code where compiling last week.
>>
>> Philippe Delrieu
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>


From jurily at gmail.com  Thu Dec  5 03:40:40 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Thu, 05 Dec 2013 12:40:40 +0100
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <529FF8A6.2050008@mozilla.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<529FF8A6.2050008@mozilla.com>
Message-ID: <52A06638.8000808@gmail.com>

On 12/05/2013 04:53 AM, Patrick Walton wrote:
> 4. *The argument to functions such as "filter" should be pure to allow
> for stream fusion.* Purity is hard in Rust. We tried it and the
> annotation burden was too high. At least our iterators allow for more
> stream fusion than creating intermediate data structures would.

Could you elaborate a bit for those of us who weren't around? I've been 
thinking about how purity would work in Rust, but a quick search says 
the verdict was apparently "kill it with fire" (#5384). If there's a 
List of Things We've Already Tried So Stop Asking, this really needs to 
be on it.

From asb at asbradbury.org  Thu Dec  5 04:26:53 2013
From: asb at asbradbury.org (Alex Bradbury)
Date: Thu, 5 Dec 2013 12:26:53 +0000
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <52A06638.8000808@gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<529FF8A6.2050008@mozilla.com> <52A06638.8000808@gmail.com>
Message-ID: <CA+wH297NR+WizY0BaK-zmBXbsNymPTF_fgyZkoCEzFEHHOBjLQ@mail.gmail.com>

On 5 December 2013 11:40, Gy?rgy Andrasek <jurily at gmail.com> wrote:
> On 12/05/2013 04:53 AM, Patrick Walton wrote:
>>
>> 4. *The argument to functions such as "filter" should be pure to allow
>> for stream fusion.* Purity is hard in Rust. We tried it and the
>> annotation burden was too high. At least our iterators allow for more
>> stream fusion than creating intermediate data structures would.
>
>
> Could you elaborate a bit for those of us who weren't around? I've been
> thinking about how purity would work in Rust, but a quick search says the
> verdict was apparently "kill it with fire" (#5384). If there's a List of
> Things We've Already Tried So Stop Asking, this really needs to be on it.

Graydon's response here
<https://mail.mozilla.org/pipermail/rust-dev/2013-April/003926.html>
and other posts in that thread gives one starting point.

Alex

From gokcehankara at gmail.com  Thu Dec  5 05:20:12 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Thu, 5 Dec 2013 15:20:12 +0200
Subject: [rust-dev] How to reply properly in digest mode?
Message-ID: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>

Hello,

I don't have much experience with email lists but I would like to gain
some. I have been using digest mode for 'rust-dev' and I'm not sure how to
reply properly to a specific thread. Things I'm looking for are:

- Having the specific thread subject instead of 'Rust-dev Digest..'. There
is a note in digest emails about doing this manually so I'm guessing there
is no easier way to do it?

- Having responses archived in the appropriate thread. I have read
something about in-reply headers and I'm not sure how manually adjusting
the subject line would work regarding this.

- Replying to all people participating in the thread while also cc'in the
mail to the mail list so people can use reply all functionality to easily
reply back.

There are message-id's in each mail which looks like this:

Message-ID:
        <CAAvrL-nT0r8=ObSKzeHfAbX50fUD6k86_cKzLAiQwGzAPOyBfw at mail.gmail.com>

It seems interesting but I don't know what they are for. I have searched
through internet and the best advice was to disable digest mode if you
intend to reply. Is that the only option?

On a side note, digest mode doesn't work like I expected either. I was
thinking of having a collection of emails at the end of the day but I
usually get multiple digests per day. There seems to be an upper limit of 6
per digest so my first thought was that it sends the digest if the buffer
is full but I also get digests with fewer emails like 1 or 2.

(Note: I'm using gmail if that matters)

Thanks,
Gokcehan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/2b2838f2/attachment.html>

From michaelwoerister at posteo.de  Thu Dec  5 06:08:10 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Thu, 05 Dec 2013 15:08:10 +0100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <BAY170-W706439C41008F2FA575F12F8D70@phx.gbl>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>,
	<BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>,
	<529FA1DB.9030000@isaac.cedarswampstudios.org>
	<BAY170-W706439C41008F2FA575F12F8D70@phx.gbl>
Message-ID: <52A088CA.1020902@posteo.de>

On 05.12.2013 03:15, Bill Myers wrote:
> The reason I introduced COW when RC > 1 is that it allows persistent 
> data structures to be mutated in place if there aren't extra 
> references, just like non-persistent data structures.
That's a great idea that an might obviate the need to have a separate 
`Builder` type (as in .Net [1]) or explicit `transients` (as in Clojure 
[2]).

However, one has to be careful to "lock" the whole path when working in 
a graph structure in a concurrent setting, so no other task/thread 
changes a node further up, while the first task does changes to the some 
node further down. This can happen, when relying on the reference count 
alone because there can be N Arc-references + M borrowed references to 
some memory box---and the reference count will only be N. Conceptually, 
the `get()` method in Arc also should increase the reference count for 
the lifetime of the borrowed reference. For safe memory management, this 
is not necessary because the compiler will ensure that no borrowed 
reference outlives all memory owners, but for counting who has access to 
the memory contents, the reference count alone is inadequate.

This should not be hard to mitigate manually but it's a potential source 
for some nasty race conditions ;)

-Michael

[1] https://msdn.microsoft.com/en-us/library/dn385366(v=vs.110).aspx
[2] http://clojure.org/transients
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/21996cb2/attachment.html>

From illissius at gmail.com  Thu Dec  5 07:43:46 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Thu, 5 Dec 2013 16:43:46 +0100
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
Message-ID: <CAPNUp0-Pq-D2hOR7u_v_toQ5zyKFL9G9m5h_oAUu5E8Kz1_dZg@mail.gmail.com>

In a similar vein, see this list of complaints against Scala by Edward
Kmett, possibly the most brilliant and prolific Haskell programmer on Earth:

http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu

I'll try to comment with my understanding of where Rust stands on each
point:


>    -
>
>    If you take any two of the random extensions that have been thrown
>    into scala and try to use them together, they typically don't play nice.
>    e.g. Implicits and subtyping don't play nice together.
>
>
We have to stay careful, but I think the various parts of Rust's type
system fit together amazingly well right now.



>    -
>
>    Type inference works right up until you write anything that needs it.
>    If you go to write any sort of tricky recursive function, you know, where
>    inference would be useful, then it stops working.
>
> Not completely sure about this, but hopeful. Can anyone else make a
better-informed comment?



>
>    -
>
>    Due to type erasure, its easy to refine a type in a case expression /
>    pattern match to get something that is a lie.
>
>
I don't think Rust has this problem.



>
>    -
>
>    Free theorems aren't.
>
>
This is referring to the idea that if type variables are completely opaque
to a generic function parameterized over them, then you can formulate some
equational theorems for the function "for free", which you know will always
be true, because they can't not be. For example, for the Haskell function
fmap :: forall a b. (a -> b) -> (f a -> fb):

    fmap f . fmap g = fmap (f . g)
    fmap id = id

Due to unrestricted (non-mutation) side effects Rust flunks this, but it
would be nice if, for functions which can be assumed to be pure, it didn't.
For that we have to be vigilant about never allowing things like
dynamic_cast or various built-in intrinsics on completely generic types, at
least outside of unsafe code. This seems more hopeful, but Rust still
flunks it right now: because of, for one instance, size_of::<T>(). I'm not
sure whether there are other instances. It would be nice if this could be
addressed.



>    -
>
>    Since you can pass any dictionary anywhere to any implicit you can't
>    rely on the canonicity of anything. If you make a Map or Set using an
>    ordering, you can't be sure you'll get the same ordering back when you come
>    to do a lookup later. This means you can't safely do hedge unions/merges in
>    their containers. It also means that much of scalaz is lying to itself and
>    hoping you'll pass back the same dictionary every time.
>
> Rust smartly avoids this problem.



>
>    -
>
>    The container types they do have have weird ad hoc overloadings. e.g.
>    Map is treated as an iterable container of pairs, but this means you can't
>    write code that is parametric in the Traversable container type that can do
>    anything sensible. It is one of those solutions that seems like it might be
>    a nice idea unless you've had experience programming with more principled
>    classes like Foldable/Traversable.
>
> Not quite sure what sort of overloadings this is referring to, but if/when
we add an Iterable trait, this means that perhaps the impl for maps should
iterate only over values, rather than key-value pairs, so that it makes
more sense to use the same generic code for both e.g. maps and arrays. (Of
course a (key, value) iterator should still be provided separately.)

When we gain higher-kinded types, we should also be able to add the actual
Foldable and Traversable traits themselves.



>
>    -
>
>    You wind up with code that looks like myMap.map(...).toMap all over
>    the place due to CanBuildFrom inference woes.
>
> No idea what this is about.



>
>    -
>
>    Monads have to pay for an extra map at the end of any comprehension,
>    because of the way the for { } sugar works.
>
> We have neither monads nor sugar at the moment, but if we ever do (not
quite as crazy as it sounds, given that C# also has a version of it in
LINQ), we should presumably try to remember this problem and avoid it.



>
>    -
>
>    You have type lambdas. Yay, right? But now you can't just talk about Functor
>    (StateT s IO). Its Functor[({type F[X] = StateT[S,IO,X]})#F], and you
>    have to hand plumb it to something like return, because it basically
>    can't infer any of that, once you start dealing with transformers ever. The
>    instance isn't directly in scope. 12.pure[({type F[X] =
>    StateT[S,IO,X]})#F] isn't terribly concise. It can't figure out it
>    should use the inference rule to define the implicit for StateT[S,M,_]from the one for
>    M[_] because of the increased flexibility that nobody uses.
>
>
Rust doesn't have type lambdas and almost certainly never will.



>
>    -
>
>    In this mindset and in the same vein as the CanBuildFrom issue, things
>    like Either don't have the biased flatMap you'd expect, somehow
>    encouraging you to use other tools, just in case you wanted to bind on the
>    Left. So you don't write generic monadic code over the Either monad,
>    but rather are constantly chaining foo.right.flatMap(...
>    .right.flatMap(....)) ensuring you can't use the sugar without turning
>    to something like scalaz to fill it in. Basically almost the entire
>    original motivation for all the type lambda craziness came down to being
>    able to write classes like Functor have have several instances for
>    different arguments, but because they are so hard to use nobody does it,
>    making the feature hardly pay its way, as it makes things like unification,
>    and path dependent type checking harder and sometimes impossible, but the
>    language specification requires them to do it!
>
> See above.


>    -
>
>    You don't have any notion of a kind system and can only talk about
>    fully saturated types, monad transformers are hell to write. It is easier
>    for me to use the fact that every Comonad gives rise to a monad
>    transformer to intuitively describe how to manually plumb a semimonoidal
>    Comonad through my parser to carry extra state than to work with a
>    monad transformer!
>
> Rust doesn't have a kind system either, but hopefully it will!


>
>    -
>
>    I've been able to get the compiler to build classes that it thinks are
>    fully instantiated, but which still have abstract methods in them.
>
> I don't believe Rust has this problem.



>
>    -
>
>    Tail-call optimization is only performed for self-tail calls, where
>    you do not do polymorphic recursion.
>
> Rust is a little bit better here (LLVM does "sibling call" optimization,
which is somewhat more general than just self calls), but not by much.



>    -
>
>    Monads are toys due to the aforementioned restriction. (>>=) is called
>    flatMap. Any chain of monadic binds is going to be a series of
>    non-self tailcalls. A function calls flatMap which calls a function, which
>    calls flatMap... This means that non-trivial operations in even the
>    identity monad, like using a Haskell style traverse for a monad over
>    an arbitrary container blows the stack after a few thousand entries.
>
>
Rust is not any better on this front. While we still had segmented stacks
we could've handled this, if not in constant space but at least on the
stack, but we no longer do.

I'm wondering whether the fact that we're going to have moves and drops
statically tracked by the compiler might make it more realistic to think
about TCE again. I think the biggest remaining obstacle would be the
calling convention.



>
>    -
>
>    We can fix this, and have in scalaz by adapting apfelmus' operational
>    monad to get a trampoline that moves us off the stack to the heap, hiding
>    the problem, but at a 50x slowdown, as the JIT no longer knows how to help.
>    -
>
>    We can also fix it by passing imperative state around, and maybe
>    getting scala to pass the state for me using implicits and hoping I don't
>    accidentally use a lazy val. Guess which one is the only viable
>    solution I know at scale? The code winds up less than 1/2 the size and 3x
>    faster than the identity monad version. If scala was the only language I
>    had to think in, I'd think functional programming was a bad idea that
>    didn't scale, too.
>    -
>
>    for yield sugar is a very simple expansion, but that means it has all
>    sorts of rules about what you can't define locally inside of it, e.g. you
>    can't stop and def a function, lazy val, etc. without nesting another
>    for yield block.
>
> Not sure what this is about, but if we ever add a `yield` construct we
should presumably try to take this into consideration.



>    -
>
>    You wind up with issues like SI-3295<https://issues.scala-lang.org/browse/SI-3295>where out of a desire to not "confuse the computation model", it was
>    decided that it was better to you know, just crash when someone folded a
>    reasonably large list than fix the issue.. until it finally affected
>    scalac itself. I've been told this has been relatively recently fixed.
>    -
>
>    No first-class universal quantification means that quantifier tricks
>    like ST s, or automatic differentiation without infinitesimal
>    confusion are basically impossible.
>
>    def test = diff(new FF[Id,Id,Double] {
>       def apply[S[_]](x: AD[S, Double])(implicit mode: Mode[S, Double]): AD[S, Double]
>          = cos(x)
>    })
>
>    is a poor substitute for
>
>    test = diff cos
>
>
> Rust doesn't have this right now either, but in part of my earlier "Type
system thoughts" e-mail I was thinking about how it could potentially be
added.



> ... but it runs on the JVM.
>

Rust doesn't have this excuse. :-)



On Thu, Dec 5, 2013 at 2:07 AM, Ziad Hatahet <hatahet at gmail.com> wrote:

> To be taken with a grain of salt, naturally:
> https://www.youtube.com/watch?v=TS1lpKBMkgg
>
>
> --
> Ziad
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/c3e61738/attachment-0001.html>

From bill_myers at outlook.com  Thu Dec  5 07:59:08 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Thu, 5 Dec 2013 15:59:08 +0000
Subject: [rust-dev] Persistent data structures
In-Reply-To: <52A088CA.1020902@posteo.de>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>, ,
	<BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>, ,
	<529FA1DB.9030000@isaac.cedarswampstudios.org>,
	<BAY170-W706439C41008F2FA575F12F8D70@phx.gbl>,
	<52A088CA.1020902@posteo.de>
Message-ID: <BAY170-W413DA4E9AB072162B65290F8D70@phx.gbl>

No, the problem you describe does not exist in my implementation because it requires an &mut to the smart pointer.

In particular, if the reference count is 1, then there is no other Rc and Arc pointing to the same data, and because we have an &mut there is also no other borrowed reference to the Rc or Arc we are manipulating.

Hence, if the reference count is 1 and we have an &mut to the Rc or Arc, it's safe to return an &mut pointing to the contents and thus mutate its contents in place using it.

If the reference count is more than 1, then it uses read-only access to clone the contents, giving a new allocation with reference count 1 that can then be mutated in place as above.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/03aa54f7/attachment.html>

From danielmicay at gmail.com  Thu Dec  5 08:07:32 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 5 Dec 2013 11:07:32 -0500
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CAPNUp0-Pq-D2hOR7u_v_toQ5zyKFL9G9m5h_oAUu5E8Kz1_dZg@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<CAPNUp0-Pq-D2hOR7u_v_toQ5zyKFL9G9m5h_oAUu5E8Kz1_dZg@mail.gmail.com>
Message-ID: <CA+DvKQKOnZANhDxkKhzrT6RoOythHTEF52JGX260xpL8kqA_7w@mail.gmail.com>

On Thu, Dec 5, 2013 at 10:43 AM, G?bor Lehel <illissius at gmail.com> wrote:
>
>> Free theorems aren't.
>
>
> This is referring to the idea that if type variables are completely opaque
> to a generic function parameterized over them, then you can formulate some
> equational theorems for the function "for free", which you know will always
> be true, because they can't not be. For example, for the Haskell function
> fmap :: forall a b. (a -> b) -> (f a -> fb):
>
>     fmap f . fmap g = fmap (f . g)
>     fmap id = id
>
> Due to unrestricted (non-mutation) side effects Rust flunks this, but it
> would be nice if, for functions which can be assumed to be pure, it didn't.
> For that we have to be vigilant about never allowing things like
> dynamic_cast or various built-in intrinsics on completely generic types, at
> least outside of unsafe code. This seems more hopeful, but Rust still flunks
> it right now: because of, for one instance, size_of::<T>(). I'm not sure
> whether there are other instances. It would be nice if this could be
> addressed.

There are worse cases than `size_of` like `type_id`, `get_tydesc` and
`visit_tydesc`. The `visit_tydesc` intrinsic is by far the worst since
it allows walking the entire type, even cross-crate private fields.
This is used by `std::repr` for "%?" in format strings.

>> The container types they do have have weird ad hoc overloadings. e.g. Map
>> is treated as an iterable container of pairs, but this means you can't write
>> code that is parametric in the Traversable container type that can do
>> anything sensible. It is one of those solutions that seems like it might be
>> a nice idea unless you've had experience programming with more principled
>> classes like Foldable/Traversable.
>
> Not quite sure what sort of overloadings this is referring to, but if/when
> we add an Iterable trait, this means that perhaps the impl for maps should
> iterate only over values, rather than key-value pairs, so that it makes more
> sense to use the same generic code for both e.g. maps and arrays. (Of course
> a (key, value) iterator should still be provided separately.)
>
> When we gain higher-kinded types, we should also be able to add the actual
> Foldable and Traversable traits themselves.

I think it makes sense to treat a map as a sequence of tuples. There
is a corresponding array type and you can always extract only the keys
or only the values with `map`. I expect there isn't going to be an
`Iterable` type for a while though. There's not a single obvious way
to implement it.

>> You wind up with code that looks like myMap.map(...).toMap all over the
>> place due to CanBuildFrom inference woes.
>
> No idea what this is about.

I think this is similar to `collect` in Rust, where a container type
needs to be provided and usually can't be inferred. I'm not sure how
it could be done differently.

>> Tail-call optimization is only performed for self-tail calls, where you do
>> not do polymorphic recursion.
>
> Rust is a little bit better here (LLVM does "sibling call" optimization,
> which is somewhat more general than just self calls), but not by much.

It's worse too, because you have to understand the obscure rules used
by LLVM, it only works for internal functions unless you use link-time
optimization and doesn't happen at all for non-optimized builds.

An example of those obscure rules is a function returning a large
value (returned via an out pointer) not ever being a candidate for
tail call elimination on most architectures. You also have to
understand which cases Rust will use an out pointer for, and that's
likely to keep changing.

>> Monads are toys due to the aforementioned restriction. (>>=) is called
>> flatMap. Any chain of monadic binds is going to be a series of non-self
>> tailcalls. A function calls flatMap which calls a function, which calls
>> flatMap... This means that non-trivial operations in even the identity
>> monad, like using a Haskell style traverse for a monad over an arbitrary
>> container blows the stack after a few thousand entries.
>
> Rust is not any better on this front. While we still had segmented stacks we
> could've handled this, if not in constant space but at least on the stack,
> but we no longer do.
>
> I'm wondering whether the fact that we're going to have moves and drops
> statically tracked by the compiler might make it more realistic to think
> about TCE again. I think the biggest remaining obstacle would be the calling
> convention.

I don't think it's a good idea to add any frontend support for
tail-call elimination. It's not something that's ever going to be
acceptable with optimizations disabled because it drastically changes
debugging.

>> We can fix this, and have in scalaz by adapting apfelmus' operational
>> monad to get a trampoline that moves us off the stack to the heap, hiding
>> the problem, but at a 50x slowdown, as the JIT no longer knows how to help.
>>
>> We can also fix it by passing imperative state around, and maybe getting
>> scala to pass the state for me using implicits and hoping I don't
>> accidentally use a lazy val. Guess which one is the only viable solution I
>> know at scale? The code winds up less than 1/2 the size and 3x faster than
>> the identity monad version. If scala was the only language I had to think
>> in, I'd think functional programming was a bad idea that didn't scale, too.
>>
>> for yield sugar is a very simple expansion, but that means it has all
>> sorts of rules about what you can't define locally inside of it, e.g. you
>> can't stop and def a function, lazy val, etc. without nesting another for
>> yield block.
>
> Not sure what this is about, but if we ever add a `yield` construct we
> should presumably try to take this into consideration.

If we have `yield` sugar, it's going to be more restrictive than a
regular function in order to maintain memory safety. Move semantics
are very relevant here.

From comexk at gmail.com  Thu Dec  5 09:58:37 2013
From: comexk at gmail.com (comex)
Date: Thu, 5 Dec 2013 12:58:37 -0500
Subject: [rust-dev] How to reply properly in digest mode?
In-Reply-To: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>
References: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>
Message-ID: <CAPM5UJ2YnQH7iGiJz-mByKCTtCKnhpadfaift_1e2aH59fDngA@mail.gmail.com>

On Thu, Dec 5, 2013 at 8:20 AM, Gokcehan Kara <gokcehankara at gmail.com> wrote:
> It seems interesting but I don't know what they are for. I have searched
> through internet and the best advice was to disable digest mode if you
> intend to reply. Is that the only option?

If you ask Gmail to filter messages to the list into their own label,
there's not really much advantage to using a digest (which is an
inferior reading experience) rather than just periodically checking
the label.  HTH.

From bill_myers at outlook.com  Thu Dec  5 10:04:19 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Thu, 5 Dec 2013 18:04:19 +0000
Subject: [rust-dev] How to reply properly in digest mode?
In-Reply-To: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>
References: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>
Message-ID: <BAY170-W895D5DD51FCAE06F632976F8D70@phx.gbl>

Never use digest mode.

Instead, use normal mode and if necessary add a filter in your e-mail website or application to separate all mailing list messages in a specific folder or label.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/6940c003/attachment.html>

From gokcehankara at gmail.com  Thu Dec  5 10:19:19 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Thu, 5 Dec 2013 20:19:19 +0200
Subject: [rust-dev] How to reply properly in digest mode?
In-Reply-To: <BAY170-W895D5DD51FCAE06F632976F8D70@phx.gbl>
References: <CAEWroOgbXLAmu_+1KxjXm4OK0qxVW2EA-=EvnWnA9YmCVf9qaw@mail.gmail.com>
	<BAY170-W895D5DD51FCAE06F632976F8D70@phx.gbl>
Message-ID: <CAEWroOiA9835u8PMq0YqnRx3RCkhzT7ScTVNGz=4NX0deN1=_g@mail.gmail.com>

I have turned of digest mode and did the label thing and it seems alright,
thanks..


On Thu, Dec 5, 2013 at 8:04 PM, Bill Myers <bill_myers at outlook.com> wrote:

> Never use digest mode.
>
> Instead, use normal mode and if necessary add a filter in your e-mail
> website or application to separate all mailing list messages in a specific
> folder or label.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/9522d020/attachment.html>

From illissius at gmail.com  Thu Dec  5 12:05:04 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Thu, 5 Dec 2013 21:05:04 +0100
Subject: [rust-dev] Interesting talk about (scala) language/compiler
	complexity
In-Reply-To: <CA+DvKQKOnZANhDxkKhzrT6RoOythHTEF52JGX260xpL8kqA_7w@mail.gmail.com>
References: <CAN1rdEyxuLVBt64nYAbuZtRJ349vb9iRzfqvB=ycQqnokLvDTw@mail.gmail.com>
	<CAPNUp0-Pq-D2hOR7u_v_toQ5zyKFL9G9m5h_oAUu5E8Kz1_dZg@mail.gmail.com>
	<CA+DvKQKOnZANhDxkKhzrT6RoOythHTEF52JGX260xpL8kqA_7w@mail.gmail.com>
Message-ID: <CAPNUp0_cCtnK2sD7hJLdBqoR-hBwZ4QddmuXqeQB4nOKGQxmqw@mail.gmail.com>

On Thu, Dec 5, 2013 at 5:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Thu, Dec 5, 2013 at 10:43 AM, G?bor Lehel <illissius at gmail.com> wrote:
>
>> The container types they do have have weird ad hoc overloadings. e.g. Map
> >> is treated as an iterable container of pairs, but this means you can't
> write
> >> code that is parametric in the Traversable container type that can do
> >> anything sensible. It is one of those solutions that seems like it
> might be
> >> a nice idea unless you've had experience programming with more
> principled
> >> classes like Foldable/Traversable.
> >
> > Not quite sure what sort of overloadings this is referring to, but
> if/when
> > we add an Iterable trait, this means that perhaps the impl for maps
> should
> > iterate only over values, rather than key-value pairs, so that it makes
> more
> > sense to use the same generic code for both e.g. maps and arrays. (Of
> course
> > a (key, value) iterator should still be provided separately.)
> >
> > When we gain higher-kinded types, we should also be able to add the
> actual
> > Foldable and Traversable traits themselves.
>
> I think it makes sense to treat a map as a sequence of tuples.


When iterating over a map, sure thing. When writing generic code over any
kind of container, not so sure. In that case a `Map<K, V>` can be viewed as
V values indexed over K keys, while `[T]` can be viewed as T values indexed
over `uint` keys -- and so perhaps there should be a separate
`IterableWithKey` trait for this kind of thing, where arrays would also be
iterated as (index, value) pairs.

That said, maybe you wouldn't ever want to write generic code over
`Iterable`, only `Iterator`, and so this concern wouldn't actually end up
applying.



>
> >> You wind up with code that looks like myMap.map(...).toMap all over the
> >> place due to CanBuildFrom inference woes.
> >
> > No idea what this is about.
>
> I think this is similar to `collect` in Rust, where a container type
> needs to be provided and usually can't be inferred. I'm not sure how
> it could be done differently.
>

Hmm. Seems like the sort of thing that HKT might help with.



>
> >> Monads are toys due to the aforementioned restriction. (>>=) is called
> >> flatMap. Any chain of monadic binds is going to be a series of non-self
> >> tailcalls. A function calls flatMap which calls a function, which calls
> >> flatMap... This means that non-trivial operations in even the identity
> >> monad, like using a Haskell style traverse for a monad over an arbitrary
> >> container blows the stack after a few thousand entries.
> >
> > Rust is not any better on this front. While we still had segmented
> stacks we
> > could've handled this, if not in constant space but at least on the
> stack,
> > but we no longer do.
> >
> > I'm wondering whether the fact that we're going to have moves and drops
> > statically tracked by the compiler might make it more realistic to think
> > about TCE again. I think the biggest remaining obstacle would be the
> calling
> > convention.
>
> I don't think it's a good idea to add any frontend support for
> tail-call elimination. It's not something that's ever going to be
> acceptable with optimizations disabled because it drastically changes
> debugging.
>

That seems like something the programmer would be in a good position to
make an informed choice about. The other obstacles seem more significant
than this one.

(I'm assuming that *if* we ever add TCE, it would be have to be invoked
explicitly (there's currently the `be` keyword reserved for this, which
seems a bit strange, but not as if I have a better idea). So it's not like
the compiler would always unconditionally eliminate tail calls and the
unsuspecting programmer would be foiled in her debugging. She would be able
to pick her poison.)


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/5b4b18e9/attachment.html>

From philippe.delrieu at free.fr  Thu Dec  5 12:26:14 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 05 Dec 2013 21:26:14 +0100
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <52A04D1F.3040102@free.fr>
References: <52A03CC5.7070500@free.fr>	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>
	<52A04D1F.3040102@free.fr>
Message-ID: <52A0E166.9060207@free.fr>

I found my error. It's a classical problem.
TestStruct2 implement the trait `extra::serialize::Encodable` using the 
generated impl by the compiler.
I didn't declare : use extra::serialize::Encodable;
So the compiler doesn't find it and declare the problem at the 
implementation.
It's the same problem when you work with different file and the trait is 
implemented in one file and use in another.
Usually I found the error but I was confused with other errors and the 
message wasn't clear.
Is it possible to change the message by for example in this case trait 
`extra::serialize::Encodable` not found for encode,
or to add all `use` needed when using a type and its implementation.

Philippe

Le 05/12/2013 10:53, Philippe Delrieu a ?crit :
> Thank you it correct my first problems.
>
> I didn't send code because I thought it has the same cause. For the 
> last problems the code is :
>
> use extra::serialize;
> use extra::json::{Json, Decoder, ToJson, Object, Encoder, Decoder};
> use extra::treemap::TreeMap;
> use std::io::Decorator;
>
> //second struct with manually implemented  Decodable, Encodable
> #[deriving(Decodable, Encodable, Eq)]
> pub struct TestStruct2    {
>     dataInt: u8,
>     dataStr:~str,
>     dataArray:~[u8],
> }
>
>     let test3 : TestStruct2 = TestStruct2 {dataInt: 1, 
> dataStr:~"toto", dataArray:~[2,3,4,5]}; 
> //{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
>     let mut m3 = MemWriter::new();
>     {
>         let mut encoder3 =Encoder::init(&mut m3 as &mut Writer);
>         test3.encode(&mut encoder3);
>     }
>
> Rustc result :
> test_json.rs:292:8: 292:36 error: type `TestStruct2` does not 
> implement any method in scope named `encode`
> test/test_json.rs:292         test3.encode(&mut encoder3);
>
> Philippe
>
>
>
> Le 05/12/2013 09:56, Kevin Ballard a ?crit :
>> `do` no longer works with stack closures. It now only works with the 
>> new proc() type, which basically means you're only going to see it 
>> used with spawn().
>>
>> You need to now say something like
>>
>>      let rc = endpoint.with_c_str(|cstr| {
>>          unsafe {smq_bind(self.sock, cstr)}
>>      });
>>
>> I can't speculate on your encode error without seeing it.
>>
>> -Kevin
>>
>> On Dec 5, 2013, at 12:43 AM, Philippe Delrieu 
>> <philippe.delrieu at free.fr> wrote:
>>
>>> Hello,
>>>
>>> since a few days, I have a lot of new errors in the master compiler. 
>>> For example in the rust_zmq lib that I use. When I compile it I have 
>>> these errors :
>>> 321:9 error: last argument in `do` call has non-procedure type: 
>>> |*i8| -> <V3>
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319 
>>> let rc = do endpoint.with_c_str |cstr| {
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320 
>>> unsafe {zmq_bind(self.sock, cstr)}
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321 
>>> };
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29: 
>>> 330:9 error: last argument in `do` call has non-procedure type: 
>>> |*i8| -> <V3>
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328 
>>> let rc = do endpoint.with_c_str |cstr| {
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329 
>>> unsafe {zmq_connect(self.sock, cstr)}
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330 
>>> };
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16: 
>>> 352:9 error: last argument in `do` call has non-procedure type: 
>>> |*u8, uint| -> <V3>
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337 
>>> do data.as_imm_buf |base_ptr, len| {
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338 
>>> let msg = [0, ..32];
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339 
>>>
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340 
>>> unsafe {
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341 
>>> // Copy the data into the message.
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 
>>> zmq_msg_init_size(&msg, len as size_t);
>>> ...
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40: 
>>> 342:43 error: the type of this value must be known in this context
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342 
>>> zmq_msg_init_size(&msg, len as size_t);
>>> ^~~
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16: 
>>> 344:32 error: cannot determine a type for this bounded type 
>>> parameter: unconstrained type
>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344 
>>> ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
>>> ^~~~~~~~~~~~~~~~
>>> I have the same type of errors in my code plus other error when the 
>>> trait can't be found like type `MyType` does not implement any 
>>> method in scope named `encode` and the function is implemented just 
>>> above.
>>> This code where compiling last week.
>>>
>>> Philippe Delrieu
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From corey at octayn.net  Thu Dec  5 12:57:39 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 5 Dec 2013 15:57:39 -0500
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <52A0E166.9060207@free.fr>
References: <52A03CC5.7070500@free.fr>
	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>
	<52A04D1F.3040102@free.fr> <52A0E166.9060207@free.fr>
Message-ID: <CA++BO6R+cYNXXpsBD_G0tBajWiUnN-4xOGEGZHgz8v7fF9Qp3g@mail.gmail.com>

No, since it isn't known which trait the method should come from. It
could list *all* the traits that provide that method with that
signature, but even that wouldn't be great if you had the signature
off.

On Thu, Dec 5, 2013 at 3:26 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> I found my error. It's a classical problem.
> TestStruct2 implement the trait `extra::serialize::Encodable` using the
> generated impl by the compiler.
> I didn't declare : use extra::serialize::Encodable;
> So the compiler doesn't find it and declare the problem at the
> implementation.
> It's the same problem when you work with different file and the trait is
> implemented in one file and use in another.
> Usually I found the error but I was confused with other errors and the
> message wasn't clear.
> Is it possible to change the message by for example in this case trait
> `extra::serialize::Encodable` not found for encode,
> or to add all `use` needed when using a type and its implementation.
>
> Philippe
>
> Le 05/12/2013 10:53, Philippe Delrieu a ?crit :
>
>> Thank you it correct my first problems.
>>
>> I didn't send code because I thought it has the same cause. For the last
>> problems the code is :
>>
>> use extra::serialize;
>> use extra::json::{Json, Decoder, ToJson, Object, Encoder, Decoder};
>> use extra::treemap::TreeMap;
>> use std::io::Decorator;
>>
>> //second struct with manually implemented  Decodable, Encodable
>> #[deriving(Decodable, Encodable, Eq)]
>> pub struct TestStruct2    {
>>     dataInt: u8,
>>     dataStr:~str,
>>     dataArray:~[u8],
>> }
>>
>>     let test3 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto",
>> dataArray:~[2,3,4,5]};
>> //{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
>>     let mut m3 = MemWriter::new();
>>     {
>>         let mut encoder3 =Encoder::init(&mut m3 as &mut Writer);
>>         test3.encode(&mut encoder3);
>>     }
>>
>> Rustc result :
>> test_json.rs:292:8: 292:36 error: type `TestStruct2` does not implement
>> any method in scope named `encode`
>> test/test_json.rs:292         test3.encode(&mut encoder3);
>>
>> Philippe
>>
>>
>>
>> Le 05/12/2013 09:56, Kevin Ballard a ?crit :
>>>
>>> `do` no longer works with stack closures. It now only works with the new
>>> proc() type, which basically means you're only going to see it used with
>>> spawn().
>>>
>>> You need to now say something like
>>>
>>>      let rc = endpoint.with_c_str(|cstr| {
>>>          unsafe {smq_bind(self.sock, cstr)}
>>>      });
>>>
>>> I can't speculate on your encode error without seeing it.
>>>
>>> -Kevin
>>>
>>> On Dec 5, 2013, at 12:43 AM, Philippe Delrieu <philippe.delrieu at free.fr>
>>> wrote:
>>>
>>>> Hello,
>>>>
>>>> since a few days, I have a lot of new errors in the master compiler. For
>>>> example in the rust_zmq lib that I use. When I compile it I have these
>>>> errors :
>>>> 321:9 error: last argument in `do` call has non-procedure type: |*i8| ->
>>>> <V3>
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319
>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320
>>>> unsafe {zmq_bind(self.sock, cstr)}
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321
>>>> };
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29:
>>>> 330:9 error: last argument in `do` call has non-procedure type: |*i8| ->
>>>> <V3>
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328
>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329
>>>> unsafe {zmq_connect(self.sock, cstr)}
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330
>>>> };
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16:
>>>> 352:9 error: last argument in `do` call has non-procedure type: |*u8, uint|
>>>> -> <V3>
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337
>>>> do data.as_imm_buf |base_ptr, len| {
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338
>>>> let msg = [0, ..32];
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340
>>>> unsafe {
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341
>>>> // Copy the data into the message.
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>> zmq_msg_init_size(&msg, len as size_t);
>>>> ...
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40:
>>>> 342:43 error: the type of this value must be known in this context
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>> zmq_msg_init_size(&msg, len as size_t);
>>>> ^~~
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16:
>>>> 344:32 error: cannot determine a type for this bounded type parameter:
>>>> unconstrained type
>>>>
>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344
>>>> ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
>>>> ^~~~~~~~~~~~~~~~
>>>> I have the same type of errors in my code plus other error when the
>>>> trait can't be found like type `MyType` does not implement any method in
>>>> scope named `encode` and the function is implemented just above.
>>>> This code where compiling last week.
>>>>
>>>> Philippe Delrieu
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From philippe.delrieu at free.fr  Thu Dec  5 13:29:59 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 05 Dec 2013 22:29:59 +0100
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <CA++BO6R+cYNXXpsBD_G0tBajWiUnN-4xOGEGZHgz8v7fF9Qp3g@mail.gmail.com>
References: <52A03CC5.7070500@free.fr>	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>	<52A04D1F.3040102@free.fr>	<52A0E166.9060207@free.fr>
	<CA++BO6R+cYNXXpsBD_G0tBajWiUnN-4xOGEGZHgz8v7fF9Qp3g@mail.gmail.com>
Message-ID: <52A0F057.8090109@free.fr>

Perhaps the error message can be more explicit like trait not found for 
method instead of method not found.


Le 05/12/2013 21:57, Corey Richardson a ?crit :
> No, since it isn't known which trait the method should come from. It
> could list *all* the traits that provide that method with that
> signature, but even that wouldn't be great if you had the signature
> off.
>
> On Thu, Dec 5, 2013 at 3:26 PM, Philippe Delrieu
> <philippe.delrieu at free.fr> wrote:
>> I found my error. It's a classical problem.
>> TestStruct2 implement the trait `extra::serialize::Encodable` using the
>> generated impl by the compiler.
>> I didn't declare : use extra::serialize::Encodable;
>> So the compiler doesn't find it and declare the problem at the
>> implementation.
>> It's the same problem when you work with different file and the trait is
>> implemented in one file and use in another.
>> Usually I found the error but I was confused with other errors and the
>> message wasn't clear.
>> Is it possible to change the message by for example in this case trait
>> `extra::serialize::Encodable` not found for encode,
>> or to add all `use` needed when using a type and its implementation.
>>
>> Philippe
>>
>> Le 05/12/2013 10:53, Philippe Delrieu a ?crit :
>>
>>> Thank you it correct my first problems.
>>>
>>> I didn't send code because I thought it has the same cause. For the last
>>> problems the code is :
>>>
>>> use extra::serialize;
>>> use extra::json::{Json, Decoder, ToJson, Object, Encoder, Decoder};
>>> use extra::treemap::TreeMap;
>>> use std::io::Decorator;
>>>
>>> //second struct with manually implemented  Decodable, Encodable
>>> #[deriving(Decodable, Encodable, Eq)]
>>> pub struct TestStruct2    {
>>>      dataInt: u8,
>>>      dataStr:~str,
>>>      dataArray:~[u8],
>>> }
>>>
>>>      let test3 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto",
>>> dataArray:~[2,3,4,5]};
>>> //{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
>>>      let mut m3 = MemWriter::new();
>>>      {
>>>          let mut encoder3 =Encoder::init(&mut m3 as &mut Writer);
>>>          test3.encode(&mut encoder3);
>>>      }
>>>
>>> Rustc result :
>>> test_json.rs:292:8: 292:36 error: type `TestStruct2` does not implement
>>> any method in scope named `encode`
>>> test/test_json.rs:292         test3.encode(&mut encoder3);
>>>
>>> Philippe
>>>
>>>
>>>
>>> Le 05/12/2013 09:56, Kevin Ballard a ?crit :
>>>> `do` no longer works with stack closures. It now only works with the new
>>>> proc() type, which basically means you're only going to see it used with
>>>> spawn().
>>>>
>>>> You need to now say something like
>>>>
>>>>       let rc = endpoint.with_c_str(|cstr| {
>>>>           unsafe {smq_bind(self.sock, cstr)}
>>>>       });
>>>>
>>>> I can't speculate on your encode error without seeing it.
>>>>
>>>> -Kevin
>>>>
>>>> On Dec 5, 2013, at 12:43 AM, Philippe Delrieu <philippe.delrieu at free.fr>
>>>> wrote:
>>>>
>>>>> Hello,
>>>>>
>>>>> since a few days, I have a lot of new errors in the master compiler. For
>>>>> example in the rust_zmq lib that I use. When I compile it I have these
>>>>> errors :
>>>>> 321:9 error: last argument in `do` call has non-procedure type: |*i8| ->
>>>>> <V3>
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319
>>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320
>>>>> unsafe {zmq_bind(self.sock, cstr)}
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321
>>>>> };
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29:
>>>>> 330:9 error: last argument in `do` call has non-procedure type: |*i8| ->
>>>>> <V3>
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328
>>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329
>>>>> unsafe {zmq_connect(self.sock, cstr)}
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330
>>>>> };
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16:
>>>>> 352:9 error: last argument in `do` call has non-procedure type: |*u8, uint|
>>>>> -> <V3>
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337
>>>>> do data.as_imm_buf |base_ptr, len| {
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338
>>>>> let msg = [0, ..32];
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340
>>>>> unsafe {
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341
>>>>> // Copy the data into the message.
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>>> zmq_msg_init_size(&msg, len as size_t);
>>>>> ...
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40:
>>>>> 342:43 error: the type of this value must be known in this context
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>>> zmq_msg_init_size(&msg, len as size_t);
>>>>> ^~~
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16:
>>>>> 344:32 error: cannot determine a type for this bounded type parameter:
>>>>> unconstrained type
>>>>>
>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344
>>>>> ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr, len);
>>>>> ^~~~~~~~~~~~~~~~
>>>>> I have the same type of errors in my code plus other error when the
>>>>> trait can't be found like type `MyType` does not implement any method in
>>>>> scope named `encode` and the function is implemented just above.
>>>>> This code where compiling last week.
>>>>>
>>>>> Philippe Delrieu
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>


From michaelwoerister at posteo.de  Thu Dec  5 13:45:20 2013
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Thu, 05 Dec 2013 22:45:20 +0100
Subject: [rust-dev] Persistent data structures
In-Reply-To: <BAY170-W413DA4E9AB072162B65290F8D70@phx.gbl>
References: <529ED9A4.4080901@isaac.cedarswampstudios.org>, ,
	<BAY170-W35EE1C372AB8E96113E1E8F8D40@phx.gbl>, ,
	<529FA1DB.9030000@isaac.cedarswampstudios.org>,
	<BAY170-W706439C41008F2FA575F12F8D70@phx.gbl>,
	<52A088CA.1020902@posteo.de>
	<BAY170-W413DA4E9AB072162B65290F8D70@phx.gbl>
Message-ID: <52A0F3F0.30804@posteo.de>

On 05.12.2013 16:59, Bill Myers wrote:
> No, the problem you describe does not exist in my implementation 
> because it requires an &mut to the smart pointer.
You are right. I needed some time to wrap my head around this :)
This is really a very clever approach! I'm looking forward to 
experimenting with it in my HAMT implementation.

-Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/d549646b/attachment.html>

From corey at octayn.net  Thu Dec  5 13:50:06 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 5 Dec 2013 16:50:06 -0500
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <52A0F057.8090109@free.fr>
References: <52A03CC5.7070500@free.fr>
	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>
	<52A04D1F.3040102@free.fr> <52A0E166.9060207@free.fr>
	<CA++BO6R+cYNXXpsBD_G0tBajWiUnN-4xOGEGZHgz8v7fF9Qp3g@mail.gmail.com>
	<52A0F057.8090109@free.fr>
Message-ID: <CA++BO6Sx466Xbp6zXvXtyJUf8bvzrA47r+QYHK4ZPJt+EVYT4Q@mail.gmail.com>

How about "method `foo` no found and no trait in scope provided one" ?

On Thu, Dec 5, 2013 at 4:29 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> Perhaps the error message can be more explicit like trait not found for
> method instead of method not found.
>
>
> Le 05/12/2013 21:57, Corey Richardson a ?crit :
>
>> No, since it isn't known which trait the method should come from. It
>> could list *all* the traits that provide that method with that
>> signature, but even that wouldn't be great if you had the signature
>> off.
>>
>> On Thu, Dec 5, 2013 at 3:26 PM, Philippe Delrieu
>> <philippe.delrieu at free.fr> wrote:
>>>
>>> I found my error. It's a classical problem.
>>> TestStruct2 implement the trait `extra::serialize::Encodable` using the
>>> generated impl by the compiler.
>>> I didn't declare : use extra::serialize::Encodable;
>>> So the compiler doesn't find it and declare the problem at the
>>> implementation.
>>> It's the same problem when you work with different file and the trait is
>>> implemented in one file and use in another.
>>> Usually I found the error but I was confused with other errors and the
>>> message wasn't clear.
>>> Is it possible to change the message by for example in this case trait
>>> `extra::serialize::Encodable` not found for encode,
>>> or to add all `use` needed when using a type and its implementation.
>>>
>>> Philippe
>>>
>>> Le 05/12/2013 10:53, Philippe Delrieu a ?crit :
>>>
>>>> Thank you it correct my first problems.
>>>>
>>>> I didn't send code because I thought it has the same cause. For the last
>>>> problems the code is :
>>>>
>>>> use extra::serialize;
>>>> use extra::json::{Json, Decoder, ToJson, Object, Encoder, Decoder};
>>>> use extra::treemap::TreeMap;
>>>> use std::io::Decorator;
>>>>
>>>> //second struct with manually implemented  Decodable, Encodable
>>>> #[deriving(Decodable, Encodable, Eq)]
>>>> pub struct TestStruct2    {
>>>>      dataInt: u8,
>>>>      dataStr:~str,
>>>>      dataArray:~[u8],
>>>> }
>>>>
>>>>      let test3 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto",
>>>> dataArray:~[2,3,4,5]};
>>>> //{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
>>>>      let mut m3 = MemWriter::new();
>>>>      {
>>>>          let mut encoder3 =Encoder::init(&mut m3 as &mut Writer);
>>>>          test3.encode(&mut encoder3);
>>>>      }
>>>>
>>>> Rustc result :
>>>> test_json.rs:292:8: 292:36 error: type `TestStruct2` does not implement
>>>> any method in scope named `encode`
>>>> test/test_json.rs:292         test3.encode(&mut encoder3);
>>>>
>>>> Philippe
>>>>
>>>>
>>>>
>>>> Le 05/12/2013 09:56, Kevin Ballard a ?crit :
>>>>>
>>>>> `do` no longer works with stack closures. It now only works with the
>>>>> new
>>>>> proc() type, which basically means you're only going to see it used
>>>>> with
>>>>> spawn().
>>>>>
>>>>> You need to now say something like
>>>>>
>>>>>       let rc = endpoint.with_c_str(|cstr| {
>>>>>           unsafe {smq_bind(self.sock, cstr)}
>>>>>       });
>>>>>
>>>>> I can't speculate on your encode error without seeing it.
>>>>>
>>>>> -Kevin
>>>>>
>>>>> On Dec 5, 2013, at 12:43 AM, Philippe Delrieu
>>>>> <philippe.delrieu at free.fr>
>>>>> wrote:
>>>>>
>>>>>> Hello,
>>>>>>
>>>>>> since a few days, I have a lot of new errors in the master compiler.
>>>>>> For
>>>>>> example in the rust_zmq lib that I use. When I compile it I have these
>>>>>> errors :
>>>>>> 321:9 error: last argument in `do` call has non-procedure type: |*i8|
>>>>>> ->
>>>>>> <V3>
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:319
>>>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:320
>>>>>> unsafe {zmq_bind(self.sock, cstr)}
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:321
>>>>>> };
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328:29:
>>>>>> 330:9 error: last argument in `do` call has non-procedure type: |*i8|
>>>>>> ->
>>>>>> <V3>
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:328
>>>>>> let rc = do endpoint.with_c_str |cstr| {
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:329
>>>>>> unsafe {zmq_connect(self.sock, cstr)}
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:330
>>>>>> };
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337:16:
>>>>>> 352:9 error: last argument in `do` call has non-procedure type: |*u8,
>>>>>> uint|
>>>>>> -> <V3>
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:337
>>>>>> do data.as_imm_buf |base_ptr, len| {
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:338
>>>>>> let msg = [0, ..32];
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:339
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:340
>>>>>> unsafe {
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:341
>>>>>> // Copy the data into the message.
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>>>> zmq_msg_init_size(&msg, len as size_t);
>>>>>> ...
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342:40:
>>>>>> 342:43 error: the type of this value must be known in this context
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:342
>>>>>> zmq_msg_init_size(&msg, len as size_t);
>>>>>> ^~~
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344:16:
>>>>>> 344:32 error: cannot determine a type for this bounded type parameter:
>>>>>> unconstrained type
>>>>>>
>>>>>>
>>>>>> /home/pdelrieu/Documents/dev/musit/rust/zmq/git/rust-zmq/src/zmq/lib.rs:344
>>>>>> ptr::copy_memory(::cast::transmute(zmq_msg_data(&msg)), base_ptr,
>>>>>> len);
>>>>>> ^~~~~~~~~~~~~~~~
>>>>>> I have the same type of errors in my code plus other error when the
>>>>>> trait can't be found like type `MyType` does not implement any method
>>>>>> in
>>>>>> scope named `encode` and the function is implemented just above.
>>>>>> This code where compiling last week.
>>>>>>
>>>>>> Philippe Delrieu
>>>>>>
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From erick.tryzelaar at gmail.com  Thu Dec  5 19:27:54 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 5 Dec 2013 19:27:54 -0800
Subject: [rust-dev] December 17th San Francisco Bay Area Meetup
Message-ID: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>

Good evening Rusties,

I'm happy to announce the next Bay Area Rust meetup on December 17th in San
Francisco. Mozilla is graciously hosting us again. We've got a couple short
talks lined up:

? Luqman Aden will talk about using Rust to make a Minecraft Chat
Client<https://github.com/luqmana/mcchat>
.

? Alex Crichton will talk about Channels and their performance.

? Brian Anderson will talk about *something*.

? And if he's able to get it to a presentable state, Kevin Ballard will
talk about his safe Lua Bindings.

It'll start at 7:00pm and go until 10:00pm. If you would like to attend,
please sign up here:

http://www.meetup.com/Rust-Bay-Area/events/153010612/

We also might have some room for more other talks, so if you would like to
present something at this meetup, or a future one, please let me know.

I hope you can make it!
-Erick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/f0fa20f7/attachment.html>

From banderson at mozilla.com  Thu Dec  5 19:42:08 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 05 Dec 2013 19:42:08 -0800
Subject: [rust-dev] December 17th San Francisco Bay Area Meetup
In-Reply-To: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
References: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
Message-ID: <52A14790.2050907@mozilla.com>

Thanks for organizing this, Erick! I'm super-excited. The last event was 
a blast.

On 12/05/2013 07:27 PM, Erick Tryzelaar wrote:
> Good evening Rusties,
>
> I'm happy to announce the next Bay Area Rust meetup on December 17th 
> in San Francisco. Mozilla is graciously hosting us again. We've got a 
> couple short talks lined up:
>
> . Luqman Aden will talk about using Rust to make a Minecraft Chat 
> Client <https://github.com/luqmana/mcchat>.
>
> . Alex Crichton will talk about Channels and their performance.
>
> . Brian Anderson will talk about /something/.
>
> . And if he's able to get it to a presentable state, Kevin Ballard 
> will talk about his safe Lua Bindings.
>
>
> It'll start at 7:00pm and go until 10:00pm. If you would like to 
> attend, please sign up here:
>
> http://www.meetup.com/Rust-Bay-Area/events/153010612/
>
> We also might have some room for more other talks, so if you would 
> like to present something at this meetup, or a future one, please let 
> me know.
>
> I hope you can make it!
> -Erick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/48ec68cb/attachment.html>

From erick.tryzelaar at gmail.com  Thu Dec  5 20:01:09 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 5 Dec 2013 20:01:09 -0800
Subject: [rust-dev] December 17th San Francisco Bay Area Meetup
In-Reply-To: <52A14790.2050907@mozilla.com>
References: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
	<52A14790.2050907@mozilla.com>
Message-ID: <CALdfqQJD6v3L_WFWyY2B9Y4ZVNvqHSFRjciXTNLR1CaPURNE3A@mail.gmail.com>

Me too! I love this community.


On Thu, Dec 5, 2013 at 7:42 PM, Brian Anderson <banderson at mozilla.com>wrote:

>  Thanks for organizing this, Erick! I'm super-excited. The last event was
> a blast.
>
>
> On 12/05/2013 07:27 PM, Erick Tryzelaar wrote:
>
>  Good evening Rusties,
>
>  I'm happy to announce the next Bay Area Rust meetup on December 17th in
> San Francisco. Mozilla is graciously hosting us again. We've got a couple
> short talks lined up:
>
> ? Luqman Aden will talk about using Rust to make a Minecraft Chat Client<https://github.com/luqmana/mcchat>
> .
>
> ? Alex Crichton will talk about Channels and their performance.
>
> ? Brian Anderson will talk about *something*.
>
> ? And if he's able to get it to a presentable state, Kevin Ballard will
> talk about his safe Lua Bindings.
>
>  It'll start at 7:00pm and go until 10:00pm. If you would like to attend,
> please sign up here:
>
> http://www.meetup.com/Rust-Bay-Area/events/153010612/
>
>  We also might have some room for more other talks, so if you would like
> to present something at this meetup, or a future one, please let me know.
>
>  I hope you can make it!
>  -Erick
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131205/bf217331/attachment-0001.html>

From philippe.delrieu at free.fr  Thu Dec  5 22:44:57 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 06 Dec 2013 07:44:57 +0100
Subject: [rust-dev] new compile errors in the master since a few days
In-Reply-To: <CA++BO6Sx466Xbp6zXvXtyJUf8bvzrA47r+QYHK4ZPJt+EVYT4Q@mail.gmail.com>
References: <52A03CC5.7070500@free.fr>	<DAF31832-3C33-42CE-A6A5-23B572D208A3@sb.org>	<52A04D1F.3040102@free.fr>	<52A0E166.9060207@free.fr>	<CA++BO6R+cYNXXpsBD_G0tBajWiUnN-4xOGEGZHgz8v7fF9Qp3g@mail.gmail.com>	<52A0F057.8090109@free.fr>
	<CA++BO6Sx466Xbp6zXvXtyJUf8bvzrA47r+QYHK4ZPJt+EVYT4Q@mail.gmail.com>
Message-ID: <52A17269.2040200@free.fr>

I find this message better than the current. It won't mislead me.

Le 05/12/2013 22:50, Corey Richardson a ?crit :
> How about "method `foo` no found and no trait in scope provided one" ?
>
> On Thu, Dec 5, 2013 at 4:29 PM, Philippe Delrieu
> <philippe.delrieu at free.fr> wrote:
>> Perhaps the error message can be more explicit like trait not found for
>> method instead of method not found.
>>
>>
>> Le 05/12/2013 21:57, Corey Richardson a ?crit :
>>
>>> No, since it isn't known which trait the method should come from. It
>>> could list *all* the traits that provide that method with that
>>> signature, but even that wouldn't be great if you had the signature
>>> off.
>>>
>>> On Thu, Dec 5, 2013 at 3:26 PM, Philippe Delrieu
>>> <philippe.delrieu at free.fr> wrote:
>>>> I found my error. It's a classical problem.
>>>> TestStruct2 implement the trait `extra::serialize::Encodable` using the
>>>> generated impl by the compiler.
>>>> I didn't declare : use extra::serialize::Encodable;
>>>> So the compiler doesn't find it and declare the problem at the
>>>> implementation.
>>>> It's the same problem when you work with different file and the trait is
>>>> implemented in one file and use in another.
>>>> Usually I found the error but I was confused with other errors and the
>>>> message wasn't clear.
>>>> Is it possible to change the message by for example in this case trait
>>>> `extra::serialize::Encodable` not found for encode,
>>>> or to add all `use` needed when using a type and its implementation.
>>>>
>>>> Philippe
>>>>
>>>>


From ezyang at mit.edu  Fri Dec  6 00:11:08 2013
From: ezyang at mit.edu (Edward Z. Yang)
Date: Fri, 06 Dec 2013 00:11:08 -0800
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
Message-ID: <1386315514-sup-3583@sabre>

Imagine that we have a structure of the form:

    typedef struct {
        int payload1;
        foo *link;
        int payload2;
    } foo;

This structure is characterized by two things:

    1) It is a singly linked list, and thus has a simple ownership
    structure which can be captured by Rust's owned pointers

    2) The payload of this struct is interleaved with links, in
    order to save space and an extra indirection.  The layout may
    be fixed, by virtue of being exposed by a C library.

The question now is: can we write an Iterator<&mut foo> for
the corresponding Rust structure foo, without using any unsafe code?

There is a fundamental problem with this structure: iterator
invalidation.  If we are able to issue a &mut foo reference, then the
link field could get mutated.  Rust's borrow checker would reject this,
since the only possible internal state for the iterator (a mutable
reference to the next element) aliases with the mutable reference
returned by next().  I am not sure how to solve this without changing
the layout of the struct; perhaps there might be a way if one could
selectively turn off the mutability of some fields.

Suppose we are willing to change the struct, as per the extra::dlist
implementation, we still fall short of a safe implementation: the
internal state of the iterator utilizes a raw pointer (head), which
provides a function resolve() which simply mints a mutable reference to
the element in question. It seems to be using Rawlink to hide the fact
that it has its fingers on a mutable borrowed reference to the list.  It
recovers some safety by maintaining a mutable reference to the whole
list in the iterator structure as well, but it would be better if no
unsafe code was necessary at all, and I certainly don't feel qualified
to reason about the correctness of this code. (Though, I understand and
appreciate the fact that the back pointers have to be handled unsafely.)

So, is it possible? I just want (provably) safe, mutable iteration over
singly-linked lists...

Edward

From dbau.pp at gmail.com  Fri Dec  6 00:26:36 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 06 Dec 2013 19:26:36 +1100
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <1386315514-sup-3583@sabre>
References: <1386315514-sup-3583@sabre>
Message-ID: <52A18A3C.9060606@gmail.com>

On 06/12/13 19:11, Edward Z. Yang wrote:
> Imagine that we have a structure of the form:
>
>      typedef struct {
>          int payload1;
>          foo *link;
>          int payload2;
>      } foo;
>
> This structure is characterized by two things:
>
>      1) It is a singly linked list, and thus has a simple ownership
>      structure which can be captured by Rust's owned pointers
>
>      2) The payload of this struct is interleaved with links, in
>      order to save space and an extra indirection.  The layout may
>      be fixed, by virtue of being exposed by a C library.
>
> The question now is: can we write an Iterator<&mut foo> for
> the corresponding Rust structure foo, without using any unsafe code?
>
> There is a fundamental problem with this structure: iterator
> invalidation.  If we are able to issue a &mut foo reference, then the
> link field could get mutated.  Rust's borrow checker would reject this,
> since the only possible internal state for the iterator (a mutable
> reference to the next element) aliases with the mutable reference
> returned by next().  I am not sure how to solve this without changing
> the layout of the struct; perhaps there might be a way if one could
> selectively turn off the mutability of some fields.
>
> Suppose we are willing to change the struct, as per the extra::dlist
> implementation, we still fall short of a safe implementation: the
> internal state of the iterator utilizes a raw pointer (head), which
> provides a function resolve() which simply mints a mutable reference to
> the element in question. It seems to be using Rawlink to hide the fact
> that it has its fingers on a mutable borrowed reference to the list.  It
> recovers some safety by maintaining a mutable reference to the whole
> list in the iterator structure as well, but it would be better if no
> unsafe code was necessary at all, and I certainly don't feel qualified
> to reason about the correctness of this code. (Though, I understand and
> appreciate the fact that the back pointers have to be handled unsafely.)
>
> So, is it possible? I just want (provably) safe, mutable iteration over
> singly-linked lists...
>
> Edward
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

One could have an Iterator<(&mut int, &mut int)>, where the references 
point to just the fields. Off the top of my head:

     struct List {
         payload1: int,
         next: Option<~Foo>,
         payload2: f64
     }

     struct ListMutIterator<'a> {
         elem: Option<&'a mut List>
     }

     impl<'a> Iterator<(&'a mut int, &'a mut f64)> for ListMutIterator<'a> {
         fn next(&mut self) -> Option<(&'a mut int, &'a mut f64)> {
              let elem = std::util::replace(self, None); // I think this 
might be necessary to get around the borrow checker.

              let (ret, next) = match elem {
                  Some(&List { payload1: ref mut payload1, next: ref mut 
next, payload2: ref mut payload2 }) => {
                       (Some((payload1, payload2)), next.as_mut_ref())
                  }
                  None => (None, None)
              };
              *self = next;
              ret
         }
     }

(The List pattern match will look nicer if 
https://github.com/mozilla/rust/issues/6137 gets solved; `List { ref mut 
payload1, ref mut next, ref mut payload2 }`.)

I imagine this will end up being very ugly if there are more than just 2 
fields before and after, although one could easily replace the tuple 
with a struct `ListMutRef<'a> { payload1: &'a mut int, payload2: &'a mut 
f64 }`.

Huon

From bill_myers at outlook.com  Fri Dec  6 07:50:59 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Fri, 6 Dec 2013 15:50:59 +0000
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <1386315514-sup-3583@sabre>
References: <1386315514-sup-3583@sabre>
Message-ID: <BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>

Maybe the language should be changed to allow Iterator to be changed to have a signature like this:
pub trait Iterator<A> {
??? fn next<'a>(&'a mut self) -> Option<'a A>;
}

Then you could return the &mut by reborrowing and would be able to advance the iterator without issue afterwards. 		 	   		  

From danielmicay at gmail.com  Fri Dec  6 11:15:18 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 6 Dec 2013 14:15:18 -0500
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>
References: <1386315514-sup-3583@sabre>
	<BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>
Message-ID: <CA+DvKQLaGVCuGB+_eiX4Vx6L5pQ_+G1uYKD0xwRWM-PmFuEQmg@mail.gmail.com>

On Fri, Dec 6, 2013 at 10:50 AM, Bill Myers <bill_myers at outlook.com> wrote:
> Maybe the language should be changed to allow Iterator to be changed to have a signature like this:
> pub trait Iterator<A> {
>     fn next<'a>(&'a mut self) -> Option<'a A>;
> }
>
> Then you could return the &mut by reborrowing and would be able to advance the iterator without issue afterwards.

It can't be defined that way without becoming much less useful for
more common cases.

From simon.sapin at exyr.org  Fri Dec  6 12:41:04 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 06 Dec 2013 20:41:04 +0000
Subject: [rust-dev] =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
Message-ID: <52A23660.5040500@exyr.org>

We have some functions and methods such as 
[std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) 
that may succeed and give a result, or fail when the input is invalid.

1. Sometimes we assume the input is valid and don?t want to deal with 
the error case. Task failure works nicely.

2. Sometimes we do want to do something different on invalid input, so 
returning an `Option<T>` works best.

And so we end up with both `from_utf8` and `from_utf8`. This particular 
case is worse because we also have `from_utf8_owned` and 
`from_utf8_owned_opt`, to cover everything.

Multiplying names like this is just not good design. I?d like to reduce 
this pattern.

Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on 
the Option. I think we should rename every `foo_opt()` function or 
method to just `foo`, remove the old `foo()` behavior, and tell people 
(through documentation) to use `foo().unwrap()` if they want it back?

The downsides are that unwrap is more verbose and gives less helpful 
error messages on task failure. But I think it?s worth it.

What do you think?

(PS: I?m guilty of making this worse in #10828, but I?d like to discuss 
this before sending pull requests with invasive API changes.)

-- 
Simon Sapin

From corey at octayn.net  Fri Dec  6 12:48:22 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 6 Dec 2013 15:48:22 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>

I'm in favor of this but it makes things less "pretty". Is the choice
really between pretty and fast?

On Fri, Dec 6, 2013 at 3:41 PM, Simon Sapin <simon.sapin at exyr.org> wrote:
> We have some functions and methods such as
> [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html)
> that may succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with the
> error case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so
> returning an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This particular case
> is worse because we also have `from_utf8_owned` and `from_utf8_owned_opt`,
> to cover everything.
>
> Multiplying names like this is just not good design. I?d like to reduce this
> pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
> Option. I think we should rename every `foo_opt()` function or method to
> just `foo`, remove the old `foo()` behavior, and tell people (through
> documentation) to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful error
> messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss this
> before sending pull requests with invasive API changes.)
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From leo.testard at gmail.com  Fri Dec  6 12:55:56 2013
From: leo.testard at gmail.com (=?windows-1252?Q?L=E9o_Testard?=)
Date: Fri, 6 Dec 2013 21:55:56 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
Message-ID: <3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>

Hi,

Just a suggestion, don't know what it's worth...

For the "not helpful error message" thing, couldn't we extend the option API, to be able to specify at the creation of a None value the
error string that will be displayed if one calls unwrap() on this value ? This may be useful in several situations.

Leo

Le 6 d?c. 2013 ? 21:48, Corey Richardson <corey at octayn.net> a ?crit :

> I'm in favor of this but it makes things less "pretty". Is the choice
> really between pretty and fast?
> 
> On Fri, Dec 6, 2013 at 3:41 PM, Simon Sapin <simon.sapin at exyr.org> wrote:
>> We have some functions and methods such as
>> [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html)
>> that may succeed and give a result, or fail when the input is invalid.
>> 
>> 1. Sometimes we assume the input is valid and don?t want to deal with the
>> error case. Task failure works nicely.
>> 
>> 2. Sometimes we do want to do something different on invalid input, so
>> returning an `Option<T>` works best.
>> 
>> And so we end up with both `from_utf8` and `from_utf8`. This particular case
>> is worse because we also have `from_utf8_owned` and `from_utf8_owned_opt`,
>> to cover everything.
>> 
>> Multiplying names like this is just not good design. I?d like to reduce this
>> pattern.
>> 
>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
>> Option. I think we should rename every `foo_opt()` function or method to
>> just `foo`, remove the old `foo()` behavior, and tell people (through
>> documentation) to use `foo().unwrap()` if they want it back?
>> 
>> The downsides are that unwrap is more verbose and gives less helpful error
>> messages on task failure. But I think it?s worth it.
>> 
>> What do you think?
>> 
>> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss this
>> before sending pull requests with invasive API changes.)
>> 
>> --
>> Simon Sapin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131206/bdaacf88/attachment.sig>

From ezyang at mit.edu  Fri Dec  6 01:15:48 2013
From: ezyang at mit.edu (Edward Z. Yang)
Date: Fri, 06 Dec 2013 01:15:48 -0800
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <52A18A3C.9060606@gmail.com>
References: <1386315514-sup-3583@sabre> <52A18A3C.9060606@gmail.com>
Message-ID: <1386321238-sup-7265@sabre>

Excerpts from Huon Wilson's message of 2013-12-06 00:26:36 -0800:
> One could have an Iterator<(&mut int, &mut int)>, where the references 
> point to just the fields. Off the top of my head:

Sure. (This is not so good when there are a lot of fields.)

>      impl<'a> Iterator<(&'a mut int, &'a mut f64)> for ListMutIterator<'a> {
>          fn next(&mut self) -> Option<(&'a mut int, &'a mut f64)> {
>               let elem = std::util::replace(self, None); // I think this 
> might be necessary to get around the borrow checker.
> 
>               let (ret, next) = match elem {
>                   Some(&List { payload1: ref mut payload1, next: ref mut 
> next, payload2: ref mut payload2 }) => {
>                        (Some((payload1, payload2)), next.as_mut_ref())

I fixed some of the egregious type-checking errors, but this one has me
stuck.  There is no as_mut_ref() in the version of Rust I'm running, and
the plausible replacement mut_ref() doesn't do what I want:

    Huon.rs|24 col 37 error| mismatched types: expected `std::option::Option<&mut List>` but found `std::option::Option<&mut ~List>` (expected struct List but found ~-ptr)

(Because, of course, the thing inside the option is a ~List, not a
List).

Cheers,
Edward

From ezyang at mit.edu  Fri Dec  6 01:22:42 2013
From: ezyang at mit.edu (Edward Z. Yang)
Date: Fri, 06 Dec 2013 01:22:42 -0800
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <1386321238-sup-7265@sabre>
References: <1386315514-sup-3583@sabre> <52A18A3C.9060606@gmail.com>
	<1386321238-sup-7265@sabre>
Message-ID: <1386321636-sup-8996@sabre>

OK, with a little bit of tweaking I have come up with a version
that seems to work:

    struct List {
        payload1: int,
        next: Option<~List>,
        payload2: f64
    }

    struct ListMutIterator<'a> {
        elem: Option<&'a mut List>
    }

    impl<'a> Iterator<(&'a mut int, &'a mut f64)> for ListMutIterator<'a> {
        fn next(&mut self) -> Option<(&'a mut int, &'a mut f64)> {
            let elem = std::util::replace(self, ListMutIterator{elem:None}); // I think this might be necessary to get around the borrow checker.

            let (ret, next) = match elem {
                ListMutIterator{elem: Some(&List { payload1: ref mut payload1, next: ref mut next, payload2: ref mut payload2 })} => {
                     (Some((payload1, payload2)), match *next {
                        None => None,
                         Some(ref mut p) => Some(&mut **p)
                     })
                }
                ListMutIterator{elem: None} => (None, None)
            };
            *self = ListMutIterator{elem:next};
            ret
        }
    }

Perhaps dlist should be updated to use this implementation strategy?

Edward

From danielmicay at gmail.com  Fri Dec  6 13:41:53 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 6 Dec 2013 16:41:53 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <CA+DvKQLEPi9C1aqVvkDZ1i_yMELXzQmUjSZ9eXS6GWZhq1LeEg@mail.gmail.com>

On Fri, Dec 6, 2013 at 3:41 PM, Simon Sapin <simon.sapin at exyr.org> wrote:
> We have some functions and methods such as
> [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html)
> that may succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with the
> error case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so
> returning an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This particular case
> is worse because we also have `from_utf8_owned` and `from_utf8_owned_opt`,
> to cover everything.
>
> Multiplying names like this is just not good design. I?d like to reduce this
> pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
> Option. I think we should rename every `foo_opt()` function or method to
> just `foo`, remove the old `foo()` behavior, and tell people (through
> documentation) to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful error
> messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss this
> before sending pull requests with invasive API changes.)
>
> --
> Simon Sapin

A stack trace already tells you where the error came from so I don't
think it's an important consideration. Rust can provide stack traces
on failure by default if that's desired.

From simon.sapin at exyr.org  Fri Dec  6 13:43:49 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 06 Dec 2013 21:43:49 +0000
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
Message-ID: <52A24515.6080407@exyr.org>

On 06/12/2013 20:48, Corey Richardson wrote:
> I'm in favor of this but it makes things less "pretty". Is the choice
> really between pretty and fast?

I don?t think this is about speed. My concern is that having two 
almost-identical names for functions that do almost the same thing is 
not a good design, and should be avoided if possible.

-- 
Simon Sapin

From banderson at mozilla.com  Fri Dec  6 13:44:11 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 06 Dec 2013 13:44:11 -0800
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <52A2452B.7030102@mozilla.com>

On 12/06/2013 12:41 PM, Simon Sapin wrote:
> We have some functions and methods such as 
> [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) 
> that may succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with 
> the error case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so 
> returning an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This 
> particular case is worse because we also have `from_utf8_owned` and 
> `from_utf8_owned_opt`, to cover everything.
>
> Multiplying names like this is just not good design. I?d like to 
> reduce this pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on 
> the Option. I think we should rename every `foo_opt()` function or 
> method to just `foo`, remove the old `foo()` behavior, and tell people 
> (through documentation) to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful 
> error messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to 
> discuss this before sending pull requests with invasive API changes.)
>

I agree in this case (and probably a lot of cases), especially since 
this is a relatively uncommon operation and since (I think) we're 
prefering 'get' to 'unwrap' and that's even shorter.

There are some cases where I think failure is the right option by 
default though; in particular I was worried you were going to bring up 
the 'send' and 'recv' methods on channels which fail when disconnected. 
In this case I think it won't be common to handle the failure since it 
indicates some logic error, and these are very common operations.


From simon.sapin at exyr.org  Fri Dec  6 13:45:55 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 06 Dec 2013 21:45:55 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
Message-ID: <52A24593.4020203@exyr.org>

On 06/12/2013 20:55, L?o Testard wrote:
> Hi,
>
> Just a suggestion, don't know what it's worth...
>
> For the "not helpful error message" thing, couldn't we extend the
> option API, to be able to specify at the creation of a None value
> the error string that will be displayed if one calls unwrap() on this
> value ? This may be useful in several situations.

That would require making the memory representation of every Option 
bigger. Just for the (hopefully) uncommon case of task failure, it?s not 
worth the cost in my opinion.

We could instead have .unwrap() that take an error message, but that 
leaves the responsibility to the user of the API.

-- 
Simon Sapin

From ecreed at cs.washington.edu  Fri Dec  6 13:50:00 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Fri, 6 Dec 2013 13:50:00 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A24593.4020203@exyr.org>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
Message-ID: <CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>

FYI, there's already a method on Option that is unwrap() with an error
message: expect().

Personally, I prefer making functions that don't fail and use Option or
Result and then composing them with functions that fail for certain
outputs, but I think I'm in the minority there.


On Fri, Dec 6, 2013 at 1:45 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> On 06/12/2013 20:55, L?o Testard wrote:
>
>> Hi,
>>
>> Just a suggestion, don't know what it's worth...
>>
>> For the "not helpful error message" thing, couldn't we extend the
>> option API, to be able to specify at the creation of a None value
>> the error string that will be displayed if one calls unwrap() on this
>> value ? This may be useful in several situations.
>>
>
> That would require making the memory representation of every Option
> bigger. Just for the (hopefully) uncommon case of task failure, it?s not
> worth the cost in my opinion.
>
> We could instead have .unwrap() that take an error message, but that
> leaves the responsibility to the user of the API.
>
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131206/14562117/attachment.html>

From simon.sapin at exyr.org  Fri Dec  6 13:50:48 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 06 Dec 2013 21:50:48 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A2452B.7030102@mozilla.com>
References: <52A23660.5040500@exyr.org> <52A2452B.7030102@mozilla.com>
Message-ID: <52A246B8.7050809@exyr.org>

On 06/12/2013 21:44, Brian Anderson wrote:
> I agree in this case (and probably a lot of cases), especially since
> this is a relatively uncommon operation and since (I think) we're
> prefering 'get' to 'unwrap' and that's even shorter.
>
> There are some cases where I think failure is the right option by
> default though; in particular I was worried you were going to bring up
> the 'send' and 'recv' methods on channels which fail when disconnected.
> In this case I think it won't be common to handle the failure since it
> indicates some logic error, and these are very common operations.


Maybe this should be a case-by-case decision, but send/try_send and 
recv/try_recv have the same issue as from_utf8/from_utf8_opt of two 
slightly different names for almost the same thing.

-- 
Simon Sapin

From simon.sapin at exyr.org  Fri Dec  6 13:52:07 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Fri, 06 Dec 2013 21:52:07 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
Message-ID: <52A24707.4020709@exyr.org>

On 06/12/2013 21:50, Eric Reed wrote:
> Personally, I prefer making functions that don't fail and use Option or
> Result and then composing them with functions that fail for certain
> outputs, but I think I'm in the minority there.

Yes, this is what I?m suggesting.

-- 
Simon Sapin

From palmercox at gmail.com  Fri Dec  6 16:00:53 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Fri, 6 Dec 2013 19:00:53 -0500
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A24707.4020709@exyr.org>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
Message-ID: <CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>

Why not use Result instead of Option for these types of things? Result is
already defined to be able to return error codes using Err. The only way to
indicate an error when returning an Option is to return None which doesn't
allow for that. Also, IMO, None doesn't necessarily mean "error" to me.
Lets say we have a function defined as:

fn do_something(value: Option<~str>);

It seems like it would be much to easy to accidentally write something
like: do_something(str::from_utf8(...)) which might result in the error
being hidden since do_something might not consider None to be an error
input.

-Palmer Cox



On Fri, Dec 6, 2013 at 4:52 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> On 06/12/2013 21:50, Eric Reed wrote:
>
>> Personally, I prefer making functions that don't fail and use Option or
>> Result and then composing them with functions that fail for certain
>> outputs, but I think I'm in the minority there.
>>
>
> Yes, this is what I?m suggesting.
>
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131206/2b36cdf7/attachment.html>

From danielmicay at gmail.com  Fri Dec  6 16:02:43 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 6 Dec 2013 19:02:43 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
Message-ID: <CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>

On Fri, Dec 6, 2013 at 7:00 PM, Palmer Cox <palmercox at gmail.com> wrote:
> Why not use Result instead of Option for these types of things? Result is
> already defined to be able to return error codes using Err. The only way to
> indicate an error when returning an Option is to return None which doesn't
> allow for that. Also, IMO, None doesn't necessarily mean "error" to me. Lets
> say we have a function defined as:
>
> fn do_something(value: Option<~str>);
>
> It seems like it would be much to easy to accidentally write something like:
> do_something(str::from_utf8(...)) which might result in the error being
> hidden since do_something might not consider None to be an error input.
>
> -Palmer Cox

If there's only one reason it could fail, then `Option` is the
idiomatic way to report the error case. It's exactly what `Option` is
used for. A stack trace can report where the error occurred if you
decide to ignore the error case and use `unwrap` (or `get`, if it's
renamed).

From gaetan at xeberon.net  Fri Dec  6 16:12:47 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 7 Dec 2013 01:12:47 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
Message-ID: <CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>

I also find the repeatition of unwrap all over the code being quite nasty

Most of the time the result is just unwrapped without taking into account
the error case, so i think the usage of Option or Result useless.

I think a good solution exits and can make the code more maintainable, and
easier to read. There should not have all these unwrap (or get) call for
code we know it cannot fails, because the necessary check has been done
earlier.

I am in favor of two version of the api: from_str which has already done
the unwrap, and a from_str_safe for instance that returns a Result or
option.

Or perhaps allow the propagation of Option/Result.
Le 7 d?c. 2013 01:03, "Daniel Micay" <danielmicay at gmail.com> a ?crit :

> On Fri, Dec 6, 2013 at 7:00 PM, Palmer Cox <palmercox at gmail.com> wrote:
> > Why not use Result instead of Option for these types of things? Result is
> > already defined to be able to return error codes using Err. The only way
> to
> > indicate an error when returning an Option is to return None which
> doesn't
> > allow for that. Also, IMO, None doesn't necessarily mean "error" to me.
> Lets
> > say we have a function defined as:
> >
> > fn do_something(value: Option<~str>);
> >
> > It seems like it would be much to easy to accidentally write something
> like:
> > do_something(str::from_utf8(...)) which might result in the error being
> > hidden since do_something might not consider None to be an error input.
> >
> > -Palmer Cox
>
> If there's only one reason it could fail, then `Option` is the
> idiomatic way to report the error case. It's exactly what `Option` is
> used for. A stack trace can report where the error occurred if you
> decide to ignore the error case and use `unwrap` (or `get`, if it's
> renamed).
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/98f39e70/attachment-0001.html>

From gaetan at xeberon.net  Fri Dec  6 16:21:31 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 7 Dec 2013 01:21:31 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
	<CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
Message-ID: <CANK7tAFRpDWSLzYEYUAbSBwgwcpq9fdAftWgw3SFaMHyfCS5vw@mail.gmail.com>

Isnt a way for Option to unwrap implicitely when check on error state is
not done ? That would make the code less verbose but still allow the dev to
check for error if want?
Le 7 d?c. 2013 01:12, "Gaetan" <gaetan at xeberon.net> a ?crit :

> I also find the repeatition of unwrap all over the code being quite nasty
>
> Most of the time the result is just unwrapped without taking into account
> the error case, so i think the usage of Option or Result useless.
>
> I think a good solution exits and can make the code more maintainable, and
> easier to read. There should not have all these unwrap (or get) call for
> code we know it cannot fails, because the necessary check has been done
> earlier.
>
> I am in favor of two version of the api: from_str which has already done
> the unwrap, and a from_str_safe for instance that returns a Result or
> option.
>
> Or perhaps allow the propagation of Option/Result.
> Le 7 d?c. 2013 01:03, "Daniel Micay" <danielmicay at gmail.com> a ?crit :
>
>> On Fri, Dec 6, 2013 at 7:00 PM, Palmer Cox <palmercox at gmail.com> wrote:
>> > Why not use Result instead of Option for these types of things? Result
>> is
>> > already defined to be able to return error codes using Err. The only
>> way to
>> > indicate an error when returning an Option is to return None which
>> doesn't
>> > allow for that. Also, IMO, None doesn't necessarily mean "error" to me.
>> Lets
>> > say we have a function defined as:
>> >
>> > fn do_something(value: Option<~str>);
>> >
>> > It seems like it would be much to easy to accidentally write something
>> like:
>> > do_something(str::from_utf8(...)) which might result in the error being
>> > hidden since do_something might not consider None to be an error input.
>> >
>> > -Palmer Cox
>>
>> If there's only one reason it could fail, then `Option` is the
>> idiomatic way to report the error case. It's exactly what `Option` is
>> used for. A stack trace can report where the error occurred if you
>> decide to ignore the error case and use `unwrap` (or `get`, if it's
>> renamed).
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/6db63484/attachment.html>

From simon.sapin at exyr.org  Fri Dec  6 16:47:55 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 07 Dec 2013 00:47:55 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>	<52A24593.4020203@exyr.org>	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>	<52A24707.4020709@exyr.org>	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
	<CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
Message-ID: <52A2703B.4090608@exyr.org>

On 07/12/2013 00:12, Gaetan wrote:
> I am in favor of two version of the api: from_str which has already done
> the unwrap, and a from_str_safe for instance that returns a Result or
> option.

This is what we have now. (Eg. from_utf8() and from_utf8_opt())

The point of my initial email was to argue against this. I think we 
should try to avoid doubling the amount of API.


> Or perhaps allow the propagation of Option/Result.

This is why we have methods like .map() and .and_then()

-- 
Simon Sapin

From denis.spir at gmail.com  Fri Dec  6 16:49:48 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 01:49:48 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <52A270AC.8050700@gmail.com>

On 12/06/2013 09:41 PM, Simon Sapin wrote:
> We have some functions and methods such as
> [std::str::from_utf8](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html)
> that may succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with the error
> case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so returning
> an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This particular case is
> worse because we also have `from_utf8_owned` and `from_utf8_owned_opt`, to cover
> everything.
>
> Multiplying names like this is just not good design. I?d like to reduce this
> pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
> Option. I think we should rename every `foo_opt()` function or method to just
> `foo`, remove the old `foo()` behavior, and tell people (through documentation)
> to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful error
> messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss this
> before sending pull requests with invasive API changes.)

[A bit long, sorry, this is a topic about which i have thought for a while.]

There may be a more complicated general pattern, of all kinds of functions that 
may not be able to perform their nominal task, due to invalid input, but the 
client cannot know whether the input is valid without more or less reproducing 
said task. Checking utf8 validity is about the same job as decoding, for 
instance, to reuse your example.

Compare with a function computing the average value of a collection of numbers 
(or the sum, product, std-dev, etc...) which is passed an empty collection: here 
the client can know, thus:
1. if this abnormal case does not belong to the app's logic, the client should 
just call the func stupidly so that the func failure is a signal of logical 
error on the app side
2. if instead this case belongs to the app's logic, the client should first 
check, and never call the func in this special case
Thus, despite very possible failure, there should here be only one version of 
the func (no *_opt), one that stupidly fails, with a stupid error msg.

Back to the cases where the client cannot know before calling. To this category 
belong a whole series of search/find functions, and many dealing with the file 
system, user input, input in general. In the latter case, a func's input is in 
fact not (all) provided by the client. But there is the same pattern of 
anomalous cases which may, or not, belong to the app logic (1. or 2. above): is 
it correct (if special or exceptional) that such file does not exist, or such 
collection does not hold the searched item? Meaning, should I deal with such 
cases? If not, if such a case does not belong to the application logic, again I 
should stupidly call a func that stupidly fails with a stupid error msg, so I am 
told, simply and early, of my logical errors. These are true errors (not 
so-called exceptions), and the failure is a symptom or signal, a good thing (if, 
indeed, what you want is making good software). I *want* it; and want it so!

I'm in favor of simple funcs doing simple tasks simply, and just failing in 
anomalous cases, for these reasons. [1]

Remains the situation combined of such funcs, of which the client cannot know 
whether they will be able to perform their task, and of abnormal cases belonging 
to the logic of the app (there are also whole categories of maintenance and 
safety modes here). For such situations, it looks somewhat logical to have 2 
versions, I guess. Playing a bit with words:
1. when I ask to _find_ something, I take it for granted the thing is somewhere 
there, and expect a location in return
2. when I ask to _search_ something, I do not take anything for granted, and 
expect in return _either_ "not there!" or a location
This duality applies both to the so-called real world (despite blur natural 
language word meanings) and software worlds, and extends to all cases, it seems. 
We can certainly find a way, using Option or another mean, to combine both 
categories of situations (1. or 2.) using a single tool, but this should be very 
well done, and ensure that:
* In cases of category 1., developers are warned about their errors exactly as 
if they had called a stupidly failing func.
* At the semantic (conceptual) level, the duality of categories remains somehow 
preserved, including in source code.
About the latter, in particular it should be obvious in code, without knowledge 
of language arcanes or weird idioms, that (or whether) the caller expects a 
success unconditionally -- because (and in other words that) the anomalous case 
just does not belong to this app; this is critical information to the reader. 
How to do that right?

PS: I take the opportunity of again thanking the initiators of this Rust project 
for their welcoming and open-mindedness to such exchanges. This is really great. 
I'm not sure anymore Rust is the right language for me (maybe too complicated 
and abstract for my poor and old little mind...) but go on following the mailing 
list (and please keep it a mailing list! ;-) for this quality of sharing.

Denis

[1] I'm very much against complicated funcs, even more against ones that try to 
guess what you want in anomolous cases (eg return 0 as sum of no number, or 1 as 
product, lol!), and totally against the pretention that software should not 
fail, as apparently defended by Go's designers.
This leads to illogical things, like their utf8 decoder, precisely, inserting 
codes for the replacement character U+FFFD ?, a *valid* code, instead of 
signaling invalid source. So that you never know the input was invalid, or 
whether this code belong to the source or was inserted by their func...


From simon.sapin at exyr.org  Fri Dec  6 16:55:19 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 07 Dec 2013 00:55:19 +0000
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A270AC.8050700@gmail.com>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
Message-ID: <52A271F7.9060804@exyr.org>

On 07/12/2013 00:49, spir wrote:
> About the latter, in particular it should be obvious in code, without knowledge
> of language arcanes or weird idioms, that (or whether) the caller expects a
> success unconditionally -- because (and in other words that) the anomalous case
> just does not belong to this app; this is critical information to the reader.
> How to do that right?

If my proposal is accepted (returning Option is favored), then calling 
.unwrap() is the way to express that success is expected. unwrap() 
causes task failure when called with None.

-- 
Simon Sapin

From denis.spir at gmail.com  Fri Dec  6 17:01:47 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 02:01:47 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>	<52A24593.4020203@exyr.org>	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>	<52A24707.4020709@exyr.org>	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
	<CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
Message-ID: <52A2737B.3070901@gmail.com>

On 12/07/2013 01:12 AM, Gaetan wrote:
> I am in favor of two version of the api: from_str which has already done
> the unwrap, and a from_str_safe for instance that returns a Result or
> option.

This provides the important semantic information (that I've evoked at the end 
end of a long earlier reply in this thread) of whether func failure is expected 
and belongs to the logic of the present app and we must deal with it, or not.

But I'm still shared on this topic for finding it also annoying, like Simon, to 
have to duplicate whole catogories of such funcs (of which we cannot know in 
advance whther they'll fail or not), if only the interface as apparently 
proposed by Ga?tan.

Denis

From denis.spir at gmail.com  Fri Dec  6 17:07:28 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 02:07:28 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A271F7.9060804@exyr.org>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
	<52A271F7.9060804@exyr.org>
Message-ID: <52A274D0.5050702@gmail.com>

On 12/07/2013 01:55 AM, Simon Sapin wrote:
> On 07/12/2013 00:49, spir wrote:
>> About the latter, in particular it should be obvious in code, without knowledge
>> of language arcanes or weird idioms, that (or whether) the caller expects a
>> success unconditionally -- because (and in other words that) the anomalous case
>> just does not belong to this app; this is critical information to the reader.
>> How to do that right?
>
> If my proposal is accepted (returning Option is favored), then calling .unwrap()
> is the way to express that success is expected. unwrap() causes task failure
> when called with None.

Maybe it's only me, but this not at at all clear to my eyes. My imagined soluton 
(for a totally different lang) was something like this, on the caller side:

	ucodes = s.utf8_decode()!	// source should be correct, error on failure
         ucodes = s.utf8_decode()?	// logical failure expected, return None or 
whatnot

(But maybe _this_ is obscure to your eyes?)

Denis

From j.boggiano at seld.be  Fri Dec  6 17:08:24 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Sat, 7 Dec 2013 02:08:24 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
Message-ID: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>

On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
> On 12/07/2013 01:12 AM, Gaetan wrote:
>>
>> I am in favor of two version of the api: from_str which has already done
>> the unwrap, and a from_str_safe for instance that returns a Result or
>> option.
>
> This provides the important semantic information (that I've evoked at the
> end end of a long earlier reply in this thread) of whether func failure is
> expected and belongs to the logic of the present app and we must deal with
> it, or not.
>
> But I'm still shared on this topic for finding it also annoying, like Simon,
> to have to duplicate whole catogories of such funcs (of which we cannot know
> in advance whther they'll fail or not), if only the interface as apparently
> proposed by Ga?tan.

Syntax sugar like this would be nice:

let str = std::str::from_utf8("Parse this optimistically, and fail otherwise");
// str is a string or the task fails

vs.

let opt_str = std::str::from_utf?("Parse this if valid"); // note the
question mark
if opt_str.is_some() { .... }

Problem is, this sounds scary to implement at the compiler level, if
it's possible at all :) I am just throwing it out there for others to
judge.

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From j.boggiano at seld.be  Fri Dec  6 17:14:14 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Sat, 7 Dec 2013 02:14:14 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A274D0.5050702@gmail.com>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
	<52A271F7.9060804@exyr.org> <52A274D0.5050702@gmail.com>
Message-ID: <CA+GmM=ydAe4a4m7NTsE6bTzEu-CeYDdQa5cBc1pNisu1J=qCdw@mail.gmail.com>

On Sat, Dec 7, 2013 at 2:07 AM, spir <denis.spir at gmail.com> wrote:
> Maybe it's only me, but this not at at all clear to my eyes. My imagined
> soluton (for a totally different lang) was something like this, on the
> caller side:
>
>         ucodes = s.utf8_decode()!       // source should be correct, error
> on failure
>         ucodes = s.utf8_decode()?       // logical failure expected, return
> None or whatnot
>
> (But maybe _this_ is obscure to your eyes?)

Looks like our mails had a race condition on this one, but
highlighting the cases where we expect a perfect world (i.e. !) is
probably better.

However, if you just call the method without anything it would be the
same as calling it with ? suffix as far as I understand, so I'm not
sure what the point is of keeping that one.

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From dbau.pp at gmail.com  Fri Dec  6 17:14:18 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 07 Dec 2013 12:14:18 +1100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
Message-ID: <52A2766A.6000105@gmail.com>

On 07/12/13 12:08, Jordi Boggiano wrote:
> On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
>> On 12/07/2013 01:12 AM, Gaetan wrote:
>>> I am in favor of two version of the api: from_str which has already done
>>> the unwrap, and a from_str_safe for instance that returns a Result or
>>> option.
>> This provides the important semantic information (that I've evoked at the
>> end end of a long earlier reply in this thread) of whether func failure is
>> expected and belongs to the logic of the present app and we must deal with
>> it, or not.
>>
>> But I'm still shared on this topic for finding it also annoying, like Simon,
>> to have to duplicate whole catogories of such funcs (of which we cannot know
>> in advance whther they'll fail or not), if only the interface as apparently
>> proposed by Ga?tan.
> Syntax sugar like this would be nice:
>
> let str = std::str::from_utf8("Parse this optimistically, and fail otherwise");
> // str is a string or the task fails
>
> vs.
>
> let opt_str = std::str::from_utf?("Parse this if valid"); // note the
> question mark
> if opt_str.is_some() { .... }
>
> Problem is, this sounds scary to implement at the compiler level, if
> it's possible at all :) I am just throwing it out there for others to
> judge.
>
> Cheers
>

I personally think a better solution is something like Haskell's do 
notation[1], where you can chain several computations that return 
Option<..> such that if any intermediate one returns None, the later 
ones are not evaluated and the whole expression returns None, which 
saves having to call .get()/.unwrap()/.expect() a lot.

This can work for types like Result too (in fact, the Haskell 
implementation of `do` is sugar around some monad functions, so any 
monad can be used there; we currently don't have the power to express 
the monad typeclass/trait in Rust so the fully general form probably 
isn't possible as a syntax extension yet, although a limited version is).


Huon

[1]: http://en.wikibooks.org/wiki/Haskell/do_Notation


From bill_myers at outlook.com  Fri Dec  6 17:43:55 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Sat, 7 Dec 2013 01:43:55 +0000
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <CA+DvKQLaGVCuGB+_eiX4Vx6L5pQ_+G1uYKD0xwRWM-PmFuEQmg@mail.gmail.com>
References: <1386315514-sup-3583@sabre>
	<BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>,
	<CA+DvKQLaGVCuGB+_eiX4Vx6L5pQ_+G1uYKD0xwRWM-PmFuEQmg@mail.gmail.com>
Message-ID: <BAY170-W33BFE1B49240FAF5BC5E70F8D10@phx.gbl>

> It can't be defined that way without becoming much less useful for
> more common cases.

Any example of this?

Iterators are most commonly used in for loops, and this change makes no difference in this case. Functions that transform iterators also work the same.

Things like collect() don't work for all iterators, but it should be possible to make them work for iterators on types that don't have lifetimes.

That is, introducing syntax like this:
fn collect<'a, T:'a, U: Iterator<T>>(iter: U) -> ~['a U] {}

where the 'a bound on T means that the 'x T is convertible to 'a T for any x. 		 	   		  

From com.liigo at gmail.com  Fri Dec  6 18:22:27 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sat, 7 Dec 2013 10:22:27 +0800
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A2766A.6000105@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
Message-ID: <CAH8Jz7jtpKNVv33HTJLtm0zBSRHRzKDDKPbP2E3Y+GULq4rWdQ@mail.gmail.com>

Is do-notation in Haskell similar as: try{ block } ?


2013/12/7 Huon Wilson <dbau.pp at gmail.com>

> On 07/12/13 12:08, Jordi Boggiano wrote:
>
>> On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
>>
>>> On 12/07/2013 01:12 AM, Gaetan wrote:
>>>
>>>> I am in favor of two version of the api: from_str which has already done
>>>> the unwrap, and a from_str_safe for instance that returns a Result or
>>>> option.
>>>>
>>> This provides the important semantic information (that I've evoked at the
>>> end end of a long earlier reply in this thread) of whether func failure
>>> is
>>> expected and belongs to the logic of the present app and we must deal
>>> with
>>> it, or not.
>>>
>>> But I'm still shared on this topic for finding it also annoying, like
>>> Simon,
>>> to have to duplicate whole catogories of such funcs (of which we cannot
>>> know
>>> in advance whther they'll fail or not), if only the interface as
>>> apparently
>>> proposed by Ga?tan.
>>>
>> Syntax sugar like this would be nice:
>>
>> let str = std::str::from_utf8("Parse this optimistically, and fail
>> otherwise");
>> // str is a string or the task fails
>>
>> vs.
>>
>> let opt_str = std::str::from_utf?("Parse this if valid"); // note the
>> question mark
>> if opt_str.is_some() { .... }
>>
>> Problem is, this sounds scary to implement at the compiler level, if
>> it's possible at all :) I am just throwing it out there for others to
>> judge.
>>
>> Cheers
>>
>>
> I personally think a better solution is something like Haskell's do
> notation[1], where you can chain several computations that return
> Option<..> such that if any intermediate one returns None, the later ones
> are not evaluated and the whole expression returns None, which saves having
> to call .get()/.unwrap()/.expect() a lot.
>
> This can work for types like Result too (in fact, the Haskell
> implementation of `do` is sugar around some monad functions, so any monad
> can be used there; we currently don't have the power to express the monad
> typeclass/trait in Rust so the fully general form probably isn't possible
> as a syntax extension yet, although a limited version is).
>
>
> Huon
>
> [1]: http://en.wikibooks.org/wiki/Haskell/do_Notation
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/3f550aaa/attachment.html>

From niko at alum.mit.edu  Fri Dec  6 18:46:20 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 6 Dec 2013 21:46:20 -0500
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
Message-ID: <20131207024620.GF21055@Mr-Bennet>

On Fri, Dec 06, 2013 at 07:00:53PM -0500, Palmer Cox wrote:
> Why not use Result instead of Option for these types of things? 

I agree. I've personally been moving towards `Result<T, ()>` in
preference to `Option<T>` when one of the branches reflects an
error. It's worth noting that the compiler could still optimize this
into a pointer-null-pointer representation, though I doubt it does so
now.



Niko

From niko at alum.mit.edu  Fri Dec  6 18:53:26 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 6 Dec 2013 21:53:26 -0500
Subject: [rust-dev] Safely writing iterators over idiomatic C structures
In-Reply-To: <BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>
References: <1386315514-sup-3583@sabre>
	<BAY170-W135E650726C53DBBF6AD7DAF8D60@phx.gbl>
Message-ID: <20131207025326.GG21055@Mr-Bennet>

Please see:

http://smallcultfollowing.com/babysteps/blog/2013/10/24/iterators-yielding-mutable-references/
http://smallcultfollowing.com/babysteps/blog/2013/10/24/iterators-yielding-mutable-references-take-2/

Those posts discuss a lot of things, but I believe the also cover the
tradeoffs involved in distinguishing these two kinds of signatures.


Niko

On Fri, Dec 06, 2013 at 03:50:59PM +0000, Bill Myers wrote:
> Maybe the language should be changed to allow Iterator to be changed to have a signature like this:
> pub trait Iterator<A> {
> ??? fn next<'a>(&'a mut self) -> Option<'a A>;
> }
> 
> Then you could return the &mut by reborrowing and would be able to advance the iterator without issue afterwards. 		 	   		  
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From hatahet at gmail.com  Fri Dec  6 19:04:50 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Fri, 6 Dec 2013 19:04:50 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A2766A.6000105@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
Message-ID: <CAN1rdEw1zLNr7pqqkJftthrCdD_g516zUvReFJPWWsJS5PbmRg@mail.gmail.com>

I posted a question on the mailing list concerning this back in May:
https://mail.mozilla.org/pipermail/rust-dev/2013-May/004176.html

There were a couple of responses which implemented this in a macro. It
would be nice if it were at the language level though.


--
Ziad


On Fri, Dec 6, 2013 at 5:14 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 07/12/13 12:08, Jordi Boggiano wrote:
>
>> On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
>>
>>> On 12/07/2013 01:12 AM, Gaetan wrote:
>>>
>>>> I am in favor of two version of the api: from_str which has already done
>>>> the unwrap, and a from_str_safe for instance that returns a Result or
>>>> option.
>>>>
>>> This provides the important semantic information (that I've evoked at the
>>> end end of a long earlier reply in this thread) of whether func failure
>>> is
>>> expected and belongs to the logic of the present app and we must deal
>>> with
>>> it, or not.
>>>
>>> But I'm still shared on this topic for finding it also annoying, like
>>> Simon,
>>> to have to duplicate whole catogories of such funcs (of which we cannot
>>> know
>>> in advance whther they'll fail or not), if only the interface as
>>> apparently
>>> proposed by Ga?tan.
>>>
>> Syntax sugar like this would be nice:
>>
>> let str = std::str::from_utf8("Parse this optimistically, and fail
>> otherwise");
>> // str is a string or the task fails
>>
>> vs.
>>
>> let opt_str = std::str::from_utf?("Parse this if valid"); // note the
>> question mark
>> if opt_str.is_some() { .... }
>>
>> Problem is, this sounds scary to implement at the compiler level, if
>> it's possible at all :) I am just throwing it out there for others to
>> judge.
>>
>> Cheers
>>
>>
> I personally think a better solution is something like Haskell's do
> notation[1], where you can chain several computations that return
> Option<..> such that if any intermediate one returns None, the later ones
> are not evaluated and the whole expression returns None, which saves having
> to call .get()/.unwrap()/.expect() a lot.
>
> This can work for types like Result too (in fact, the Haskell
> implementation of `do` is sugar around some monad functions, so any monad
> can be used there; we currently don't have the power to express the monad
> typeclass/trait in Rust so the fully general form probably isn't possible
> as a syntax extension yet, although a limited version is).
>
>
> Huon
>
> [1]: http://en.wikibooks.org/wiki/Haskell/do_Notation
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131206/dea5d87c/attachment.html>

From pcwalton at mozilla.com  Fri Dec  6 20:14:38 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 06 Dec 2013 20:14:38 -0800
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <20131207024620.GF21055@Mr-Bennet>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>	<52A24593.4020203@exyr.org>	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>	<52A24707.4020709@exyr.org>	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
	<20131207024620.GF21055@Mr-Bennet>
Message-ID: <52A2A0AE.2060409@mozilla.com>

On 12/6/13 6:46 PM, Niko Matsakis wrote:
> I agree. I've personally been moving towards `Result<T, ()>` in
> preference to `Option<T>` when one of the branches reflects an
> error. It's worth noting that the compiler could still optimize this
> into a pointer-null-pointer representation, though I doubt it does so
> now.

IIRC it does.

Patrick


From bjzaba at yahoo.com.au  Fri Dec  6 22:15:52 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 7 Dec 2013 16:15:52 +1000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A2703B.4090608@exyr.org>
References: <52A23660.5040500@exyr.org>	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>	<52A24593.4020203@exyr.org>	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>	<52A24707.4020709@exyr.org>	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
	<CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
	<52A2703B.4090608@exyr.org>
Message-ID: <2E1A59CD-DAF0-4B81-97D8-4451FC71D52B@yahoo.com.au>


On 7 Dec 2013, at 10:47 am, Simon Sapin <simon.sapin at exyr.org> wrote:

> This is why we have methods like .map() and .and_then()

I like using these higher order functions, but I run into lots of issues with moved values because we don?t have once functions. I end up having to use matches, which are awfully verbose for simple things. :(

~Brendan

From oren at ben-kiki.org  Fri Dec  6 22:45:49 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 7 Dec 2013 08:45:49 +0200
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <2E1A59CD-DAF0-4B81-97D8-4451FC71D52B@yahoo.com.au>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
	<CA+DvKQJvf-SCBFonRHPt=OGwL0zSfTvB_4VvsqTfLuVRcUgXgQ@mail.gmail.com>
	<CANK7tAH-UHjz9uAWtYWjs1+Z4m__dS0xA_1kRqx=KvN3D-3jww@mail.gmail.com>
	<52A2703B.4090608@exyr.org>
	<2E1A59CD-DAF0-4B81-97D8-4451FC71D52B@yahoo.com.au>
Message-ID: <CADJiDhtWVxHJ1AdbcZ9vf2mY_JNL_cnfp6Uviy8kmi6k7nrpzA@mail.gmail.com>

There was a whole thread about the need for once-stack-closures. They are
really vital for simple programming with higher-order functions such as
these. I'm not optimistic about them being added though :-(


On Sat, Dec 7, 2013 at 8:15 AM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:

>
> On 7 Dec 2013, at 10:47 am, Simon Sapin <simon.sapin at exyr.org> wrote:
>
> > This is why we have methods like .map() and .and_then()
>
> I like using these higher order functions, but I run into lots of issues
> with moved values because we don?t have once functions. I end up having to
> use matches, which are awfully verbose for simple things. :(
>
> ~Brendan
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/226af51d/attachment.html>

From palmercox at gmail.com  Fri Dec  6 23:00:44 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Sat, 7 Dec 2013 02:00:44 -0500
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A2A0AE.2060409@mozilla.com>
References: <52A23660.5040500@exyr.org>
	<CA++BO6RuLyJQdG8W9-HON9tJZun2cy39N8s5Xhjht=Jig0RYeA@mail.gmail.com>
	<3223E937-0D90-4080-94F4-ED85037D8589@gmail.com>
	<52A24593.4020203@exyr.org>
	<CANbMr6Hw5TXFVZQOr9yK57XHdJgTEk59HjQy=Km=zBxcpA-cNQ@mail.gmail.com>
	<52A24707.4020709@exyr.org>
	<CAPZendwnZpER4PmXydVnOQXvQVB3Cr+T6ApvQ8E=3HrkUA-sfA@mail.gmail.com>
	<20131207024620.GF21055@Mr-Bennet> <52A2A0AE.2060409@mozilla.com>
Message-ID: <CAPZendwTv1Ctxu8TjcY_6dPs09WQPK_feGvFnW-KLtWA7Vitrg@mail.gmail.com>

Especially if Result<T, ()> is optimized into a single word, it seems ideal
to me to get rid of str::from_utf_opt(&[u8]) -> Option<~str> and just have
str::from_utf(&[u8]) -> Result<~str, ()>. This makes simple programs that
don't care about error handling a little more complicated, of course, since
it forces them to handle the error case. Although, the only extra
complication is ".unwrap()" so, its not that bad. For more complex programs
that do care about error handling it makes it explicit at the call site how
the error condition should be handled which I think is a big win. Return
code checking is a C idiom, and there is nothing wrong with that style of
error handling. However, the C compiler doesn't do much of anything to
force you to check the return codes which leads to lots of code that fails
to do so. Using a Result<>, however, forces the caller to do those checks.
Result<> still supports various chaining functions just like Option<> to
make that easier. However, you don't have to worry about accidentally
passing a None to a function that takes an Option<> as an input parameter
with non-error semantics.

Also, I like "unwrap()" since to me, nothing about "get()" says: this is an
error handling function that might lead to killing the current task. get()
sounds simple and safe, buts its not if called on an Option<>.

-Palmer Cox


On Fri, Dec 6, 2013 at 11:14 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/6/13 6:46 PM, Niko Matsakis wrote:
>
>> I agree. I've personally been moving towards `Result<T, ()>` in
>> preference to `Option<T>` when one of the branches reflects an
>> error. It's worth noting that the compiler could still optimize this
>> into a pointer-null-pointer representation, though I doubt it does so
>> now.
>>
>
> IIRC it does.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/4a452b36/attachment-0001.html>

From qwertie256 at gmail.com  Fri Dec  6 23:10:12 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Sat, 7 Dec 2013 00:10:12 -0700
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
Message-ID: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>

Rust newb here. I have theoretical questions.

Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on
the mailing list a lot, but I had no idea what a HKT was, or what it might
be good for. After reading about them a little, they reminded me of C++'s
"template template parameters". In C++ you can almost write something like
this:

template <template <typename> class collection>
struct Numbers {
   collection<int> integers;
   collection<float> floats;
};

So then you can write Numbers<vector> for a structure that contains
vector<T> collections, and Numbers<list> for a structure that contains
list<T> collections. EXCEPT that it doesn't actually work, because
vector<T> has two template parameters (the second one, the allocator, is
normally left at its default). Let's ignore that, though.

So that brings me to my first question: is this what "higher-kinded types"
means? What is the difference, if any, between HKT and C++ "template
templates"?

However, as a C++ developer I never actually used a "template template"
parameter because I didn't know they existed for a long time. So instead I
would have written this, which has the same end-result:

struct VectorTrait
{
    template<typename T>
    struct collection { typedef vector<T> type; };
};
struct ListTrait
{
    template<typename T>
    struct collection { typedef list<T> type; };
};

template<typename Traits>
struct Numbers
{
    Traits::collection<int>::type integers;
    Traits::collection<float>::type floats;
};
// Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.

This is clunkier, but it would have been a bit simpler if C++ supported
templatized typedefs:

struct VectorTrait
{
    template<typename T> typedef vector<T> collection;
};
struct ListTrait
{
    template<typename T> typedef vector<T> collection;
};

template<typename Traits>
struct Numbers
{
    Traits::collection<int> integers;
    Traits::collection<float> floats;
};
// Now write Numbers<VectorTrait> instead of Numbers<vector>,
//           Numbers<ListTrait> instead of Numbers<list>.

I have found that because of the existence of typedef, "template template"
parameters are never actually necessary; so far, I've never seen a
situation where the typedef-based solution wasn't almost as good. Also, I
have found that "trait" types filled with typedefs seem to be a more
general thing than "template template"; they allow you to do things that
would be very difficult or impossible without them. For example you can use
typedefs-in-a-struct to create circular references among types that don't
"know" about each other:

// I call this a "Combo"; I don't know if the technique has a standard name
struct MyCombo {
    typedef ConcreteA<Traits> A;
    typedef ConcreteB<Traits> B;
    typedef ConcreteC<Traits> C;
};
template<typename Combo>
class ConcreteA { Combo::B* b; ... };
template<typename Combo>
class ConcreteB { Combo::C* c; ... };
template<typename Combo>
class ConcreteC { Combo::A* b; ... };

Here I've created a network of types (ConcreteA<MyCombo>,
ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together
through the "Combo" type MyCombo, so the types can all use each other, but
none of the types refer to each other directly. This design allows you to
freely swap in different implementations of A, B, and C; it has similar
advantages to "dependency injection" or "inversion of control" in languages
like Java and C#, except that the linkages are all defined statically at
compile-time, so no dynamic dispatch is required.

Without the ability to define "typedefs", this approach is not possible at
all if there is a cyclic relationship. Also, if the combo declares more
than three types, it becomes impractical to specify all those types on the
classes directly as type parameters.

In C# I learned that this quickly becomes a major problem if you need to
parameterize on more than one or two types. I tried to do "generic" math
(which requires at least two type parameters due to the under-designed
standard libraries) and I also implemented a GiST data structure (see
http://en.wikipedia.org/wiki/GiST), and found out that the lack of any
analog to C++ typedef makes both of those tasks very clumsy, while also
making the code hard to read, because you end up with a rats' nest of type
parameters (or if you omit (otherwise necessary) type parameters, you might
use lots of casts instead.)

So I guess that leads me to two more questions.

2. Does Rust have a "typedef" equivalent that can be used in this way?
3. Does it make sense to just suggest "just use typedefs instead of
Higher-Kinded Types"?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/13ca9b81/attachment.html>

From bjzaba at yahoo.com.au  Fri Dec  6 23:27:16 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 7 Dec 2013 17:27:16 +1000
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
Message-ID: <DB040815-73EF-4F70-A560-735ACD55AF61@yahoo.com.au>

I?m not sure I understand everything in your post, but this is how I?d write you first C++ example:

    struct Numbers<IV, FV> {
        priv iv: IV,    // priv so the struct can only be constructed in this module
        priv fv: FV,
    }

    impl<I: Int, IV: Collection<I>, F: Float, FV: Collection<F>> Numbers<IV, FV> {
        pub fn new(iv: IV, fv: FV) -> Numbers<IV, FV> {
            Numbers { iv: iv, fv: fv }
        }
    }

You can also write type aliases with type parameters, but I don?t think you can enforce trait bounds on them afaik:

   type A<T> = (T, int);


~Brendan


On 7 Dec 2013, at 5:10 pm, David Piepgrass <qwertie256 at gmail.com> wrote:

> Rust newb here. I have theoretical questions.
> 
> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on the mailing list a lot, but I had no idea what a HKT was, or what it might be good for. After reading about them a little, they reminded me of C++'s "template template parameters". In C++ you can almost write something like this:
> 
> template <template <typename> class collection>
> struct Numbers {
>    collection<int> integers;
>    collection<float> floats;
> };
> 
> So then you can write Numbers<vector> for a structure that contains vector<T> collections, and Numbers<list> for a structure that contains list<T> collections. EXCEPT that it doesn't actually work, because vector<T> has two template parameters (the second one, the allocator, is normally left at its default). Let's ignore that, though.
> 
> So that brings me to my first question: is this what "higher-kinded types" means? What is the difference, if any, between HKT and C++ "template templates"?
> 
> However, as a C++ developer I never actually used a "template template" parameter because I didn't know they existed for a long time. So instead I would have written this, which has the same end-result:
> 
> struct VectorTrait
> {
>     template<typename T>
>     struct collection { typedef vector<T> type; };
> };
> struct ListTrait
> {
>     template<typename T>
>     struct collection { typedef list<T> type; };
> };
> 
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int>::type integers;
>     Traits::collection<float>::type floats;
> };
> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
> 
> This is clunkier, but it would have been a bit simpler if C++ supported templatized typedefs:
> 
> struct VectorTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
> struct ListTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
> 
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int> integers;
>     Traits::collection<float> floats;
> };
> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
> //           Numbers<ListTrait> instead of Numbers<list>.
> 
> I have found that because of the existence of typedef, "template template" parameters are never actually necessary; so far, I've never seen a situation where the typedef-based solution wasn't almost as good. Also, I have found that "trait" types filled with typedefs seem to be a more general thing than "template template"; they allow you to do things that would be very difficult or impossible without them. For example you can use typedefs-in-a-struct to create circular references among types that don't "know" about each other:
> 
> // I call this a "Combo"; I don't know if the technique has a standard name
> struct MyCombo {
>     typedef ConcreteA<Traits> A;
>     typedef ConcreteB<Traits> B;
>     typedef ConcreteC<Traits> C;
> };
> template<typename Combo>
> class ConcreteA { Combo::B* b; ... };
> template<typename Combo>
> class ConcreteB { Combo::C* c; ... };
> template<typename Combo>
> class ConcreteC { Combo::A* b; ... };
> 
> Here I've created a network of types (ConcreteA<MyCombo>, ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together through the "Combo" type MyCombo, so the types can all use each other, but none of the types refer to each other directly. This design allows you to freely swap in different implementations of A, B, and C; it has similar advantages to "dependency injection" or "inversion of control" in languages like Java and C#, except that the linkages are all defined statically at compile-time, so no dynamic dispatch is required.
> 
> Without the ability to define "typedefs", this approach is not possible at all if there is a cyclic relationship. Also, if the combo declares more than three types, it becomes impractical to specify all those types on the classes directly as type parameters.
> 
> In C# I learned that this quickly becomes a major problem if you need to parameterize on more than one or two types. I tried to do "generic" math (which requires at least two type parameters due to the under-designed standard libraries) and I also implemented a GiST data structure (see http://en.wikipedia.org/wiki/GiST), and found out that the lack of any analog to C++ typedef makes both of those tasks very clumsy, while also making the code hard to read, because you end up with a rats' nest of type parameters (or if you omit (otherwise necessary) type parameters, you might use lots of casts instead.)
> 
> So I guess that leads me to two more questions.
> 
> 2. Does Rust have a "typedef" equivalent that can be used in this way?
> 3. Does it make sense to just suggest "just use typedefs instead of Higher-Kinded Types"?
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From bjzaba at yahoo.com.au  Fri Dec  6 23:38:30 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 7 Dec 2013 17:38:30 +1000
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <DB040815-73EF-4F70-A560-735ACD55AF61@yahoo.com.au>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
	<DB040815-73EF-4F70-A560-735ACD55AF61@yahoo.com.au>
Message-ID: <17384D79-DE70-4713-9BD6-A89CE21C8466@yahoo.com.au>

Of course this leads (assuming we had a `Collection` trait) to the horrendously ugly `Numbers::<i32, ~[i32], f32, ~[f32]>(...)` if you wanted to be explicit. But hopefully your code would be such that Rust could infer the bounds. This will be alleviated in the future by associated items, but that will probably be post 1.0.

(I might be getting a little off-topic here)

~Brendan

On 7 Dec 2013, at 5:27 pm, Brendan Zabarauskas <bjzaba at yahoo.com.au> wrote:

> I?m not sure I understand everything in your post, but this is how I?d write you first C++ example:
> 
>    struct Numbers<IV, FV> {
>        priv iv: IV,    // priv so the struct can only be constructed in this module
>        priv fv: FV,
>    }
> 
>    impl<I: Int, IV: Collection<I>, F: Float, FV: Collection<F>> Numbers<IV, FV> {
>        pub fn new(iv: IV, fv: FV) -> Numbers<IV, FV> {
>            Numbers { iv: iv, fv: fv }
>        }
>    }
> 
> You can also write type aliases with type parameters, but I don?t think you can enforce trait bounds on them afaik:
> 
>   type A<T> = (T, int);
> 
> 
> ~Brendan
> 
> 
> On 7 Dec 2013, at 5:10 pm, David Piepgrass <qwertie256 at gmail.com> wrote:
> 
>> Rust newb here. I have theoretical questions.
>> 
>> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on the mailing list a lot, but I had no idea what a HKT was, or what it might be good for. After reading about them a little, they reminded me of C++'s "template template parameters". In C++ you can almost write something like this:
>> 
>> template <template <typename> class collection>
>> struct Numbers {
>>   collection<int> integers;
>>   collection<float> floats;
>> };
>> 
>> So then you can write Numbers<vector> for a structure that contains vector<T> collections, and Numbers<list> for a structure that contains list<T> collections. EXCEPT that it doesn't actually work, because vector<T> has two template parameters (the second one, the allocator, is normally left at its default). Let's ignore that, though.
>> 
>> So that brings me to my first question: is this what "higher-kinded types" means? What is the difference, if any, between HKT and C++ "template templates"?
>> 
>> However, as a C++ developer I never actually used a "template template" parameter because I didn't know they existed for a long time. So instead I would have written this, which has the same end-result:
>> 
>> struct VectorTrait
>> {
>>    template<typename T>
>>    struct collection { typedef vector<T> type; };
>> };
>> struct ListTrait
>> {
>>    template<typename T>
>>    struct collection { typedef list<T> type; };
>> };
>> 
>> template<typename Traits>
>> struct Numbers
>> {
>>    Traits::collection<int>::type integers;
>>    Traits::collection<float>::type floats;
>> };
>> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
>> 
>> This is clunkier, but it would have been a bit simpler if C++ supported templatized typedefs:
>> 
>> struct VectorTrait
>> {
>>    template<typename T> typedef vector<T> collection;
>> };
>> struct ListTrait
>> {
>>    template<typename T> typedef vector<T> collection;
>> };
>> 
>> template<typename Traits>
>> struct Numbers
>> {
>>    Traits::collection<int> integers;
>>    Traits::collection<float> floats;
>> };
>> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
>> //           Numbers<ListTrait> instead of Numbers<list>.
>> 
>> I have found that because of the existence of typedef, "template template" parameters are never actually necessary; so far, I've never seen a situation where the typedef-based solution wasn't almost as good. Also, I have found that "trait" types filled with typedefs seem to be a more general thing than "template template"; they allow you to do things that would be very difficult or impossible without them. For example you can use typedefs-in-a-struct to create circular references among types that don't "know" about each other:
>> 
>> // I call this a "Combo"; I don't know if the technique has a standard name
>> struct MyCombo {
>>    typedef ConcreteA<Traits> A;
>>    typedef ConcreteB<Traits> B;
>>    typedef ConcreteC<Traits> C;
>> };
>> template<typename Combo>
>> class ConcreteA { Combo::B* b; ... };
>> template<typename Combo>
>> class ConcreteB { Combo::C* c; ... };
>> template<typename Combo>
>> class ConcreteC { Combo::A* b; ... };
>> 
>> Here I've created a network of types (ConcreteA<MyCombo>, ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together through the "Combo" type MyCombo, so the types can all use each other, but none of the types refer to each other directly. This design allows you to freely swap in different implementations of A, B, and C; it has similar advantages to "dependency injection" or "inversion of control" in languages like Java and C#, except that the linkages are all defined statically at compile-time, so no dynamic dispatch is required.
>> 
>> Without the ability to define "typedefs", this approach is not possible at all if there is a cyclic relationship. Also, if the combo declares more than three types, it becomes impractical to specify all those types on the classes directly as type parameters.
>> 
>> In C# I learned that this quickly becomes a major problem if you need to parameterize on more than one or two types. I tried to do "generic" math (which requires at least two type parameters due to the under-designed standard libraries) and I also implemented a GiST data structure (see http://en.wikipedia.org/wiki/GiST), and found out that the lack of any analog to C++ typedef makes both of those tasks very clumsy, while also making the code hard to read, because you end up with a rats' nest of type parameters (or if you omit (otherwise necessary) type parameters, you might use lots of casts instead.)
>> 
>> So I guess that leads me to two more questions.
>> 
>> 2. Does Rust have a "typedef" equivalent that can be used in this way?
>> 3. Does it make sense to just suggest "just use typedefs instead of Higher-Kinded Types"?
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From simon.sapin at exyr.org  Sat Dec  7 01:53:52 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 07 Dec 2013 09:53:52 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A274D0.5050702@gmail.com>
References: <52A23660.5040500@exyr.org>
	<52A270AC.8050700@gmail.com>	<52A271F7.9060804@exyr.org>
	<52A274D0.5050702@gmail.com>
Message-ID: <52A2F030.8060105@exyr.org>

On 07/12/2013 01:07, spir wrote:
> Maybe it's only me, but this not at at all clear to my eyes. My imagined soluton
> (for a totally different lang) was something like this, on the caller side:
>
> 	ucodes = s.utf8_decode()!	// source should be correct, error on failure
>       ucodes = s.utf8_decode()?	// logical failure expected, return None or
> whatnot


This is interesting, but I?d like to discuss what to do in this 
particular language, Rust that is trying to go to 1.0 and will probably 
not accept such syntax change :)

-- 
Simon Sapin

From simon.sapin at exyr.org  Sat Dec  7 01:55:55 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 07 Dec 2013 09:55:55 +0000
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A2766A.6000105@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
Message-ID: <52A2F0AB.5050303@exyr.org>

On 07/12/2013 01:14, Huon Wilson wrote:
> I personally think a better solution is something like Haskell's do
> notation[1], where you can chain several computations that return
> Option<..> such that if any intermediate one returns None, the later
> ones are not evaluated and the whole expression returns None, which
> saves having to call .get()/.unwrap()/.expect() a lot.

We have that, it?s Option?s .and_then() method.


> This can work for types like Result too (in fact, the Haskell
> implementation of `do` is sugar around some monad functions, so any
> monad can be used there; we currently don't have the power to express
> the monad typeclass/trait in Rust so the fully general form probably
> isn't possible as a syntax extension yet, although a limited version is).


-- 
Simon Sapin

From dbau.pp at gmail.com  Sat Dec  7 02:27:36 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 07 Dec 2013 21:27:36 +1100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A2F0AB.5050303@exyr.org>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<52A2766A.6000105@gmail.com>
	<52A2F0AB.5050303@exyr.org>
Message-ID: <52A2F818.7060404@gmail.com>

On 07/12/13 20:55, Simon Sapin wrote:
> On 07/12/2013 01:14, Huon Wilson wrote:
>> I personally think a better solution is something like Haskell's do
>> notation[1], where you can chain several computations that return
>> Option<..> such that if any intermediate one returns None, the later
>> ones are not evaluated and the whole expression returns None, which
>> saves having to call .get()/.unwrap()/.expect() a lot.
>
> We have that, it?s Option?s .and_then() method.
>
>
>> This can work for types like Result too (in fact, the Haskell
>> implementation of `do` is sugar around some monad functions, so any
>> monad can be used there; we currently don't have the power to express
>> the monad typeclass/trait in Rust so the fully general form probably
>> isn't possible as a syntax extension yet, although a limited version 
>> is).
>
>

Yes, that's what my syntax extension[1] (to which Ziad alludes) 
desugared to (well, the former name, .chain).

However, even something simple like `foo.and_then(|x| bar.and_then(|y| 
baz.map(|z| x + y + z)))` is significantly worse than

     do
         x <- foo
         y <- bar
         z <- baz
         return $ x + y + z

as it is in Haskell. And more complicated examples with additional 
within the closures are significantly worse for the .and_then form 
(leading to pyramids of doom, and Rust already has enough of those).


Huon

[1]: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004182.html

From denis.spir at gmail.com  Sat Dec  7 03:28:11 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 12:28:11 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CA+GmM=ydAe4a4m7NTsE6bTzEu-CeYDdQa5cBc1pNisu1J=qCdw@mail.gmail.com>
References: <52A23660.5040500@exyr.org>	<52A270AC.8050700@gmail.com>	<52A271F7.9060804@exyr.org>	<52A274D0.5050702@gmail.com>
	<CA+GmM=ydAe4a4m7NTsE6bTzEu-CeYDdQa5cBc1pNisu1J=qCdw@mail.gmail.com>
Message-ID: <52A3064B.6070905@gmail.com>

On 12/07/2013 02:14 AM, Jordi Boggiano wrote:
> On Sat, Dec 7, 2013 at 2:07 AM, spir <denis.spir at gmail.com> wrote:
>> Maybe it's only me, but this not at at all clear to my eyes. My imagined
>> soluton (for a totally different lang) was something like this, on the
>> caller side:
>>
>>          ucodes = s.utf8_decode()!       // source should be correct, error
>> on failure
>>          ucodes = s.utf8_decode()?       // logical failure expected, return
>> None or whatnot
>>
>> (But maybe _this_ is obscure to your eyes?)
>
> Looks like our mails had a race condition on this one, but
> highlighting the cases where we expect a perfect world (i.e. !) is
> probably better.
>
> However, if you just call the method without anything it would be the
> same as calling it with ? suffix as far as I understand, so I'm not
> sure what the point is of keeping that one.

This is because you think in terms of Option, taking it for granted as if it 
were natural (thinking); "call the method without anything" here returns an 
Option element, thus (for you) the case '?' is doing nothing (more). In fact, 
from the point of view of a caller wanting an actual result, barely, the '?' 
case wraps it into an Option "box", while the '!' is the one doing nothing... Clear?

Another way of doing that is having a transparent 'none' flag (or more generally 
'failure' or 'naomaly') somewhere. In '!' case, an eventual anomaly during func 
exec causes the program to stop on error. In '?' case, it sets this flag, which 
then to be tested by the caller. The signs '!' '?' thus parameterise the 
behaviour of (possibly failing) called funcs in anomalous cases.

There is an implementation of light exception handling for C (in ASM in fact) 
that sets the carry flag that way (carry, because it is meaningless in-between 
funcs, and is the only CPU flag set-able at will).

Denis

From denis.spir at gmail.com  Sat Dec  7 03:33:02 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 12:33:02 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A2F030.8060105@exyr.org>
References: <52A23660.5040500@exyr.org>	<52A270AC.8050700@gmail.com>	<52A271F7.9060804@exyr.org>	<52A274D0.5050702@gmail.com>
	<52A2F030.8060105@exyr.org>
Message-ID: <52A3076E.80003@gmail.com>

On 12/07/2013 10:53 AM, Simon Sapin wrote:
> On 07/12/2013 01:07, spir wrote:
>> Maybe it's only me, but this not at at all clear to my eyes. My imagined soluton
>> (for a totally different lang) was something like this, on the caller side:
>>
>>     ucodes = s.utf8_decode()!    // source should be correct, error on failure
>>       ucodes = s.utf8_decode()?    // logical failure expected, return None or
>> whatnot
>
>
> This is interesting, but I?d like to discuss what to do in this particular
> language, Rust that is trying to go to 1.0 and will probably not accept such
> syntax change :)


You are right, indeed! ;-)
But the issue exists anyway... dunno about solution. In fact we'd ned to invert 
the logic: instead of:
	x = foo()		// Option element wrapping possible result
	x = foo().unwrap()	// bare result
think:
	x = foo().option()	// Option element wrapping possible result
	x = foo().direct()	// bare result
or even
	x = foo()		// bare result

Denis

From denis.spir at gmail.com  Sat Dec  7 03:45:32 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 12:45:32 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
Message-ID: <52A30A5C.8070905@gmail.com>

On 12/07/2013 02:08 AM, Jordi Boggiano wrote:
> On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
>> On 12/07/2013 01:12 AM, Gaetan wrote:
>>>
>>> I am in favor of two version of the api: from_str which has already done
>>> the unwrap, and a from_str_safe for instance that returns a Result or
>>> option.
>>
>> This provides the important semantic information (that I've evoked at the
>> end end of a long earlier reply in this thread) of whether func failure is
>> expected and belongs to the logic of the present app and we must deal with
>> it, or not.
>>
>> But I'm still shared on this topic for finding it also annoying, like Simon,
>> to have to duplicate whole catogories of such funcs (of which we cannot know
>> in advance whther they'll fail or not), if only the interface as apparently
>> proposed by Ga?tan.
>
> Syntax sugar like this would be nice:
>
> let str = std::str::from_utf8("Parse this optimistically, and fail otherwise");
> // str is a string or the task fails
>
> vs.
>
> let opt_str = std::str::from_utf?("Parse this if valid"); // note the
> question mark
> if opt_str.is_some() { .... }

That's it! This makes it clear whenever the anomalous case nevertheless belongs 
to the present application's logic (hopefully rare).


> Problem is, this sounds scary to implement at the compiler level, if
> it's possible at all :) I am just throwing it out there for others to
> judge.

Yes. Requires certainly a bit of machinary, even if thought so from the beginning.

But optional tasks exist, semantically, whether the language acknowledges them 
or not. And an Option type only solves half of the issues: namely the ones of 
functions properly speaking (which compute a value); what about actions (which 
perform an effect)? How can Option help the caller know, without failing 
(halting the program on error), whether one has been unable to perform its task? 
How can one know whether this data structure was properly updated, this visual 
object moved, this msg given to the user, this file extended, renamed, deleted...?

There are also, semantically, optional data in function def input and type 
defs... very annoying in a statically typed language ;-)

Denis

From jeanpierreda at gmail.com  Sat Dec  7 03:57:09 2013
From: jeanpierreda at gmail.com (Devin Jeanpierre)
Date: Sat, 7 Dec 2013 03:57:09 -0800
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A3076E.80003@gmail.com>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
	<52A271F7.9060804@exyr.org> <52A274D0.5050702@gmail.com>
	<52A2F030.8060105@exyr.org> <52A3076E.80003@gmail.com>
Message-ID: <CABicbJ+Abq+e25qx6=Sb339x63b4f_n3-3XVO33_trr13wN7ow@mail.gmail.com>

On Sat, Dec 7, 2013 at 3:33 AM, spir <denis.spir at gmail.com> wrote:
> But the issue exists anyway... dunno about solution. In fact we'd ned to
> invert the logic: instead of:
>         x = foo()               // Option element wrapping possible result
>         x = foo().unwrap()      // bare result
> think:
>         x = foo().option()      // Option element wrapping possible result
>         x = foo().direct()      // bare result

In what way is this better? Seems to me it's a basically functionless
layer of abstraction, and things that don't always have a usable
result should always return option, and if you want them to fail, you
can request failure via .unwrap(). If this is too verbose, then we
should make it less verbose, e.g. `x = *foo()` or something.

Or we can keep the status quo, which seems fine to me. I'm not really
picky about verbosity.

-- Devin

From gaetan at xeberon.net  Sat Dec  7 04:06:37 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 7 Dec 2013 13:06:37 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A3076E.80003@gmail.com>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
	<52A271F7.9060804@exyr.org> <52A274D0.5050702@gmail.com>
	<52A2F030.8060105@exyr.org> <52A3076E.80003@gmail.com>
Message-ID: <CANK7tAGUKwE_fM46D+Fvs4-fU2=DOGB2MHPWmbKdsE1igJZ4CA@mail.gmail.com>

What do you think about implicit unwrap? I don't know if this could be done
but I find it pretty elegant.

It's a design choice. For me all API should follow the same pattern, not
some returning bare result without failure case, or return a boolean and
modify the content of a pointer, or use Result/Option.

Most of function look like thing
- function definition
- check inputs are correct
- process with inputs
- return a value

Most of std/extra methods currently look like:
1 function def
2 ... .unwrap()...unwrap()
3 continue to unwrap(), unwrap()
4 return Ok(...) or Err(..) or return Option

while unwrap in part 2 may have sense (check if inputs are correct), they
don't have in the third part of the fn.

What I really advise is to go to a solution where the developer will avoid
each time to call unwrap/get, without checking for the return state because
it cost too much. When you call a system api you check for the result
because it has great chance to fail, but when you know what you have in
input, you call unwrap() without taking care of the failure cases, and if a
failure occurs, you can expect things to be in suffisant bad shape to let
the task completely fails.

Maybe split the methods into two categories: API calls that may fails and
return a Result, and obvious convert methods that has no sens to fails once
the input has been properly check, so doesn't use Result.

But at the end of this discussion, I also strongly advise to write the
solution down in a reference page on the wiki, having the current "state of
the art" for this matter is extremely important, because the source code
has different design choices, with this page everyone will know what is the
current best pratice for such function calls.

PS: I really like the "?" solution, where func?() returns a Result and
func() return the bare result, I find it in the same spirit than fmt!, that
makes the language special but in a sexy way :)


-----
Gaetan



2013/12/7 spir <denis.spir at gmail.com>

> On 12/07/2013 10:53 AM, Simon Sapin wrote:
>
>> On 07/12/2013 01:07, spir wrote:
>>
>>> Maybe it's only me, but this not at at all clear to my eyes. My imagined
>>> soluton
>>> (for a totally different lang) was something like this, on the caller
>>> side:
>>>
>>>     ucodes = s.utf8_decode()!    // source should be correct, error on
>>> failure
>>>       ucodes = s.utf8_decode()?    // logical failure expected, return
>>> None or
>>> whatnot
>>>
>>
>>
>> This is interesting, but I?d like to discuss what to do in this particular
>> language, Rust that is trying to go to 1.0 and will probably not accept
>> such
>> syntax change :)
>>
>
>
> You are right, indeed! ;-)
> But the issue exists anyway... dunno about solution. In fact we'd ned to
> invert the logic: instead of:
>         x = foo()               // Option element wrapping possible result
>         x = foo().unwrap()      // bare result
> think:
>         x = foo().option()      // Option element wrapping possible result
>         x = foo().direct()      // bare result
> or even
>         x = foo()               // bare result
>
> Denis
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/c337d1e8/attachment-0001.html>

From denis.spir at gmail.com  Sat Dec  7 07:30:02 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 07 Dec 2013 16:30:02 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CABicbJ+Abq+e25qx6=Sb339x63b4f_n3-3XVO33_trr13wN7ow@mail.gmail.com>
References: <52A23660.5040500@exyr.org> <52A270AC.8050700@gmail.com>
	<52A271F7.9060804@exyr.org> <52A274D0.5050702@gmail.com>
	<52A2F030.8060105@exyr.org> <52A3076E.80003@gmail.com>
	<CABicbJ+Abq+e25qx6=Sb339x63b4f_n3-3XVO33_trr13wN7ow@mail.gmail.com>
Message-ID: <52A33EFA.9090509@gmail.com>

On 12/07/2013 12:57 PM, Devin Jeanpierre wrote:
> On Sat, Dec 7, 2013 at 3:33 AM, spir <denis.spir at gmail.com> wrote:
>> But the issue exists anyway... dunno about solution. In fact we'd ned to
>> invert the logic: instead of:
>>          x = foo()               // Option element wrapping possible result
>>          x = foo().unwrap()      // bare result
>> think:
>>          x = foo().option()      // Option element wrapping possible result
>>          x = foo().direct()      // bare result
>
> In what way is this better? Seems to me it's a basically functionless
> layer of abstraction, and things that don't always have a usable
> result should always return option, and if you want them to fail, you
> can request failure via .unwrap(). If this is too verbose, then we
> should make it less verbose, e.g. `x = *foo()` or something.
>
> Or we can keep the status quo, which seems fine to me. I'm not really
> picky about verbosity.

Possibly it's clear for you if you are used to the Option workaround, from other 
languages (I have been, in fact, from Ocaml). But with this solution the code 
does not say what it means (lol!), not to speak of idioms repeted everywhere in 
source as evoked by Gaetan (and similar to Java, in fact (lol bis!)). However, 
in my view, this is not a question of verbosity, but of having source code match 
(sic!) the semantics, what we actually mean.

A solution would be to have such functions return either a bare result, or an 
Option wrapping a possible result, depending on how they are called (instead of 
'?', there may be a bool param, why not?). But not a functional either/or, this 
would doubly wrap the result! Instead really either one or the other. Indeed, 
this is not possible in standard in a statically typed language, reason for 
other solutions, such as one evoked in a previous mail: have an 'anomaly' flag 
somewhere, possibly a bare pointer for error data, and minimal syntactic 
support. In fact, simple error management (I don't mean exception handling) may 
require being taken into account in language design righ from the start, even 
more than testing & debugging, for instance; but all 3 of those 
"meta-programming" dimensions are related anyway.

Denis

From qwertie256 at gmail.com  Sat Dec  7 08:42:18 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Sat, 7 Dec 2013 09:42:18 -0700
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
Message-ID: <CAHuo6ZCiOzBAM0o8XSzmnmT4vEmHNGP7RxUCYRFLw5DR5RNHaw@mail.gmail.com>

(Another big reason I like forums over mailing lists, which I forgot to
mention in that other thread, is that I can fix my mistakes!) Typo
correction:

struct ListTrait
{
    template<typename T> typedef list<T> collection;
};

And I'd rephrase my third question:
3. If Rust had C++-style typedefs, would it make sense to argue that "we
don't need Higher-Kinded Types, we can just use typedefs for everything"?

In case people are finding the Combo concept hard to follow, I will offer
GiST (http://en.wikipedia.org/wiki/GiST) as a concrete example. A GiST has
a few different parts, each of which can be swapped out to produce
different kinds of trees. When I tried to implement the GiST in C#, I found
that I wanted 8 type parameters on the GiST base class:

- The derived tree type
- The internal node type
- The leaf node type
- The "compressed" left entry type
- The "uncompressed" leaf entry type
- The "compressed" internal entry type
- The "uncompressed" internal entry type
- The key type (type of data stored in an entry)

This, of course, is utterly impractical when they have to be listed
repeatedly, every time the base class is mentioned. I figured out how to
whittle it down to one parameter on the base class and two elsewhere, but I
had to restructure the code in some unnatural ways, so the readability of
the code was substantially harmed, and there was some performance cost as
well (some interfaces, some virtual methods, more casts.)

Even with one or two type parameters, the names of things were still
unweildy because often the concrete type parameters were themselves
parameterized.

Of course, type parameters are not the only way to do a GiST. It can also
be done by defining everything in terms of interfaces (or in Rust, trait
objects). But this implies that when the different parts of the code
interact, they must use dynamic dispatch. Even worse, although the entries
(leaf/internal, compressed/uncompressed) are small implicitly-copyable data
types (let's say 8 - 32 bytes typically, though I don't have the code
handy), most of the code will be unaware how large or small each entry is,
so the entries would (in C# at least) have to be stored on the heap, rather
than passed around directly as structs (I'm not sure what you'd do in Rust).

Thus, if you want to implement a GiST in C# you get either hard-to-follow
code with sub-optimal performance, or straightforward code with terrible
performance. The third alternative, of course, is to not implement a GiST,
but implement each kind of tree (B+ tree, R-tree, ...) separately. This
requires code duplication and repeated design work, the elimination of
which was the reason GiSTs were invented in the first place.

In Rust, I assume you could use macros to overcome some of the problems
that make a GiST difficult to do in C#. However, I am thinking that if
"typedef" is in some ways a more powerful concept than HKT, arguably Rust
should support them first or investigate whether they can be generalized to
do what HKTs were meant to do.


On Sat, Dec 7, 2013 at 12:10 AM, David Piepgrass <qwertie256 at gmail.com>wrote:

> Rust newb here. I have theoretical questions.
>
> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on
> the mailing list a lot, but I had no idea what a HKT was, or what it might
> be good for. After reading about them a little, they reminded me of C++'s
> "template template parameters". In C++ you can almost write something like
> this:
>
> template <template <typename> class collection>
> struct Numbers {
>    collection<int> integers;
>    collection<float> floats;
> };
>
> So then you can write Numbers<vector> for a structure that contains
> vector<T> collections, and Numbers<list> for a structure that contains
> list<T> collections. EXCEPT that it doesn't actually work, because
> vector<T> has two template parameters (the second one, the allocator, is
> normally left at its default). Let's ignore that, though.
>
> So that brings me to my first question: is this what "higher-kinded types"
> means? What is the difference, if any, between HKT and C++ "template
> templates"?
>
> However, as a C++ developer I never actually used a "template template"
> parameter because I didn't know they existed for a long time. So instead I
> would have written this, which has the same end-result:
>
> struct VectorTrait
> {
>     template<typename T>
>     struct collection { typedef vector<T> type; };
> };
> struct ListTrait
> {
>     template<typename T>
>     struct collection { typedef list<T> type; };
> };
>
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int>::type integers;
>     Traits::collection<float>::type floats;
> };
> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
>
> This is clunkier, but it would have been a bit simpler if C++ supported
> templatized typedefs:
>
> struct VectorTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
> struct ListTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
>
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int> integers;
>     Traits::collection<float> floats;
> };
> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
> //           Numbers<ListTrait> instead of Numbers<list>.
>
> I have found that because of the existence of typedef, "template template"
> parameters are never actually necessary; so far, I've never seen a
> situation where the typedef-based solution wasn't almost as good. Also, I
> have found that "trait" types filled with typedefs seem to be a more
> general thing than "template template"; they allow you to do things that
> would be very difficult or impossible without them. For example you can use
> typedefs-in-a-struct to create circular references among types that don't
> "know" about each other:
>
> // I call this a "Combo"; I don't know if the technique has a standard name
> struct MyCombo {
>     typedef ConcreteA<Traits> A;
>     typedef ConcreteB<Traits> B;
>     typedef ConcreteC<Traits> C;
> };
> template<typename Combo>
> class ConcreteA { Combo::B* b; ... };
> template<typename Combo>
> class ConcreteB { Combo::C* c; ... };
> template<typename Combo>
> class ConcreteC { Combo::A* b; ... };
>
> Here I've created a network of types (ConcreteA<MyCombo>,
> ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together
> through the "Combo" type MyCombo, so the types can all use each other, but
> none of the types refer to each other directly. This design allows you to
> freely swap in different implementations of A, B, and C; it has similar
> advantages to "dependency injection" or "inversion of control" in languages
> like Java and C#, except that the linkages are all defined statically at
> compile-time, so no dynamic dispatch is required.
>
> Without the ability to define "typedefs", this approach is not possible at
> all if there is a cyclic relationship. Also, if the combo declares more
> than three types, it becomes impractical to specify all those types on the
> classes directly as type parameters.
>
> In C# I learned that this quickly becomes a major problem if you need to
> parameterize on more than one or two types. I tried to do "generic" math
> (which requires at least two type parameters due to the under-designed
> standard libraries) and I also implemented a GiST data structure (see
> http://en.wikipedia.org/wiki/GiST), and found out that the lack of any
> analog to C++ typedef makes both of those tasks very clumsy, while also
> making the code hard to read, because you end up with a rats' nest of type
> parameters (or if you omit (otherwise necessary) type parameters, you might
> use lots of casts instead.)
>
> So I guess that leads me to two more questions.
>
> 2. Does Rust have a "typedef" equivalent that can be used in this way?
> 3. Does it make sense to just suggest "just use typedefs instead of
> Higher-Kinded Types"?
>
>


-- 
- David
http://qism.blogspot.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/96197a25/attachment.html>

From gaetan at xeberon.net  Sat Dec  7 08:46:52 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 7 Dec 2013 17:46:52 +0100
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <CAHuo6ZCiOzBAM0o8XSzmnmT4vEmHNGP7RxUCYRFLw5DR5RNHaw@mail.gmail.com>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
	<CAHuo6ZCiOzBAM0o8XSzmnmT4vEmHNGP7RxUCYRFLw5DR5RNHaw@mail.gmail.com>
Message-ID: <CANK7tAEwv52tfv-VpbZ900yNa=rm96DoZ3spj_gJk_Pswz9j1Q@mail.gmail.com>

Stack overflow is your friend, you can even vote for the best anwser !
Le 7 d?c. 2013 17:43, "David Piepgrass" <qwertie256 at gmail.com> a ?crit :

> (Another big reason I like forums over mailing lists, which I forgot to
> mention in that other thread, is that I can fix my mistakes!) Typo
> correction:
>
> struct ListTrait
> {
>     template<typename T> typedef list<T> collection;
> };
>
> And I'd rephrase my third question:
> 3. If Rust had C++-style typedefs, would it make sense to argue that "we
> don't need Higher-Kinded Types, we can just use typedefs for everything"?
>
> In case people are finding the Combo concept hard to follow, I will offer
> GiST (http://en.wikipedia.org/wiki/GiST) as a concrete example. A GiST
> has a few different parts, each of which can be swapped out to produce
> different kinds of trees. When I tried to implement the GiST in C#, I found
> that I wanted 8 type parameters on the GiST base class:
>
> - The derived tree type
> - The internal node type
> - The leaf node type
> - The "compressed" left entry type
> - The "uncompressed" leaf entry type
> - The "compressed" internal entry type
> - The "uncompressed" internal entry type
> - The key type (type of data stored in an entry)
>
> This, of course, is utterly impractical when they have to be listed
> repeatedly, every time the base class is mentioned. I figured out how to
> whittle it down to one parameter on the base class and two elsewhere, but I
> had to restructure the code in some unnatural ways, so the readability of
> the code was substantially harmed, and there was some performance cost as
> well (some interfaces, some virtual methods, more casts.)
>
> Even with one or two type parameters, the names of things were still
> unweildy because often the concrete type parameters were themselves
> parameterized.
>
> Of course, type parameters are not the only way to do a GiST. It can also
> be done by defining everything in terms of interfaces (or in Rust, trait
> objects). But this implies that when the different parts of the code
> interact, they must use dynamic dispatch. Even worse, although the entries
> (leaf/internal, compressed/uncompressed) are small implicitly-copyable data
> types (let's say 8 - 32 bytes typically, though I don't have the code
> handy), most of the code will be unaware how large or small each entry is,
> so the entries would (in C# at least) have to be stored on the heap, rather
> than passed around directly as structs (I'm not sure what you'd do in Rust).
>
> Thus, if you want to implement a GiST in C# you get either hard-to-follow
> code with sub-optimal performance, or straightforward code with terrible
> performance. The third alternative, of course, is to not implement a GiST,
> but implement each kind of tree (B+ tree, R-tree, ...) separately. This
> requires code duplication and repeated design work, the elimination of
> which was the reason GiSTs were invented in the first place.
>
> In Rust, I assume you could use macros to overcome some of the problems
> that make a GiST difficult to do in C#. However, I am thinking that if
> "typedef" is in some ways a more powerful concept than HKT, arguably Rust
> should support them first or investigate whether they can be generalized to
> do what HKTs were meant to do.
>
>
> On Sat, Dec 7, 2013 at 12:10 AM, David Piepgrass <qwertie256 at gmail.com>wrote:
>
>> Rust newb here. I have theoretical questions.
>>
>> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on
>> the mailing list a lot, but I had no idea what a HKT was, or what it might
>> be good for. After reading about them a little, they reminded me of C++'s
>> "template template parameters". In C++ you can almost write something like
>> this:
>>
>> template <template <typename> class collection>
>> struct Numbers {
>>    collection<int> integers;
>>    collection<float> floats;
>> };
>>
>> So then you can write Numbers<vector> for a structure that contains
>> vector<T> collections, and Numbers<list> for a structure that contains
>> list<T> collections. EXCEPT that it doesn't actually work, because
>> vector<T> has two template parameters (the second one, the allocator, is
>> normally left at its default). Let's ignore that, though.
>>
>> So that brings me to my first question: is this what "higher-kinded
>> types" means? What is the difference, if any, between HKT and C++ "template
>> templates"?
>>
>> However, as a C++ developer I never actually used a "template template"
>> parameter because I didn't know they existed for a long time. So instead I
>> would have written this, which has the same end-result:
>>
>> struct VectorTrait
>> {
>>     template<typename T>
>>     struct collection { typedef vector<T> type; };
>> };
>> struct ListTrait
>> {
>>     template<typename T>
>>     struct collection { typedef list<T> type; };
>> };
>>
>> template<typename Traits>
>> struct Numbers
>> {
>>     Traits::collection<int>::type integers;
>>     Traits::collection<float>::type floats;
>> };
>> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
>>
>> This is clunkier, but it would have been a bit simpler if C++ supported
>> templatized typedefs:
>>
>> struct VectorTrait
>> {
>>     template<typename T> typedef vector<T> collection;
>> };
>> struct ListTrait
>> {
>>     template<typename T> typedef vector<T> collection;
>> };
>>
>> template<typename Traits>
>> struct Numbers
>> {
>>     Traits::collection<int> integers;
>>     Traits::collection<float> floats;
>> };
>> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
>> //           Numbers<ListTrait> instead of Numbers<list>.
>>
>> I have found that because of the existence of typedef, "template
>> template" parameters are never actually necessary; so far, I've never seen
>> a situation where the typedef-based solution wasn't almost as good. Also, I
>> have found that "trait" types filled with typedefs seem to be a more
>> general thing than "template template"; they allow you to do things that
>> would be very difficult or impossible without them. For example you can use
>> typedefs-in-a-struct to create circular references among types that don't
>> "know" about each other:
>>
>> // I call this a "Combo"; I don't know if the technique has a standard
>> name
>> struct MyCombo {
>>     typedef ConcreteA<Traits> A;
>>     typedef ConcreteB<Traits> B;
>>     typedef ConcreteC<Traits> C;
>> };
>> template<typename Combo>
>> class ConcreteA { Combo::B* b; ... };
>> template<typename Combo>
>> class ConcreteB { Combo::C* c; ... };
>> template<typename Combo>
>> class ConcreteC { Combo::A* b; ... };
>>
>> Here I've created a network of types (ConcreteA<MyCombo>,
>> ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together
>> through the "Combo" type MyCombo, so the types can all use each other, but
>> none of the types refer to each other directly. This design allows you to
>> freely swap in different implementations of A, B, and C; it has similar
>> advantages to "dependency injection" or "inversion of control" in languages
>> like Java and C#, except that the linkages are all defined statically at
>> compile-time, so no dynamic dispatch is required.
>>
>> Without the ability to define "typedefs", this approach is not possible
>> at all if there is a cyclic relationship. Also, if the combo declares more
>> than three types, it becomes impractical to specify all those types on the
>> classes directly as type parameters.
>>
>> In C# I learned that this quickly becomes a major problem if you need to
>> parameterize on more than one or two types. I tried to do "generic" math
>> (which requires at least two type parameters due to the under-designed
>> standard libraries) and I also implemented a GiST data structure (see
>> http://en.wikipedia.org/wiki/GiST), and found out that the lack of any
>> analog to C++ typedef makes both of those tasks very clumsy, while also
>> making the code hard to read, because you end up with a rats' nest of type
>> parameters (or if you omit (otherwise necessary) type parameters, you might
>> use lots of casts instead.)
>>
>> So I guess that leads me to two more questions.
>>
>> 2. Does Rust have a "typedef" equivalent that can be used in this way?
>> 3. Does it make sense to just suggest "just use typedefs instead of
>> Higher-Kinded Types"?
>>
>>
>
>
> --
> - David
> http://qism.blogspot.com
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/7e6c6486/attachment-0001.html>

From illissius at gmail.com  Sat Dec  7 12:05:17 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 7 Dec 2013 21:05:17 +0100
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
Message-ID: <CAPNUp0_T_j5-u6BC+2-ZAcsqADSkb0iA9r44FNYKDv7KeMWkVw@mail.gmail.com>

Short version: yes, higher-kinded types and template template parameters
are the same thing. (`template<typename> class` is just one particular
higher kind; there's also `template<template<typename> class> class` and so
on, and varying the number of parameters, etc., which you probably know.)

Longer version hopefully upcoming if/when I manage to digest the rest of it.


On Sat, Dec 7, 2013 at 8:10 AM, David Piepgrass <qwertie256 at gmail.com>wrote:

> Rust newb here. I have theoretical questions.
>
> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on
> the mailing list a lot, but I had no idea what a HKT was, or what it might
> be good for. After reading about them a little, they reminded me of C++'s
> "template template parameters". In C++ you can almost write something like
> this:
>
> template <template <typename> class collection>
> struct Numbers {
>    collection<int> integers;
>    collection<float> floats;
> };
>
> So then you can write Numbers<vector> for a structure that contains
> vector<T> collections, and Numbers<list> for a structure that contains
> list<T> collections. EXCEPT that it doesn't actually work, because
> vector<T> has two template parameters (the second one, the allocator, is
> normally left at its default). Let's ignore that, though.
>
> So that brings me to my first question: is this what "higher-kinded types"
> means? What is the difference, if any, between HKT and C++ "template
> templates"?
>
> However, as a C++ developer I never actually used a "template template"
> parameter because I didn't know they existed for a long time. So instead I
> would have written this, which has the same end-result:
>
> struct VectorTrait
> {
>     template<typename T>
>     struct collection { typedef vector<T> type; };
> };
> struct ListTrait
> {
>     template<typename T>
>     struct collection { typedef list<T> type; };
> };
>
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int>::type integers;
>     Traits::collection<float>::type floats;
> };
> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
>
> This is clunkier, but it would have been a bit simpler if C++ supported
> templatized typedefs:
>
> struct VectorTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
> struct ListTrait
> {
>     template<typename T> typedef vector<T> collection;
> };
>
> template<typename Traits>
> struct Numbers
> {
>     Traits::collection<int> integers;
>     Traits::collection<float> floats;
> };
> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
> //           Numbers<ListTrait> instead of Numbers<list>.
>
> I have found that because of the existence of typedef, "template template"
> parameters are never actually necessary; so far, I've never seen a
> situation where the typedef-based solution wasn't almost as good. Also, I
> have found that "trait" types filled with typedefs seem to be a more
> general thing than "template template"; they allow you to do things that
> would be very difficult or impossible without them. For example you can use
> typedefs-in-a-struct to create circular references among types that don't
> "know" about each other:
>
> // I call this a "Combo"; I don't know if the technique has a standard name
> struct MyCombo {
>     typedef ConcreteA<Traits> A;
>     typedef ConcreteB<Traits> B;
>     typedef ConcreteC<Traits> C;
> };
> template<typename Combo>
> class ConcreteA { Combo::B* b; ... };
> template<typename Combo>
> class ConcreteB { Combo::C* c; ... };
> template<typename Combo>
> class ConcreteC { Combo::A* b; ... };
>
> Here I've created a network of types (ConcreteA<MyCombo>,
> ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together
> through the "Combo" type MyCombo, so the types can all use each other, but
> none of the types refer to each other directly. This design allows you to
> freely swap in different implementations of A, B, and C; it has similar
> advantages to "dependency injection" or "inversion of control" in languages
> like Java and C#, except that the linkages are all defined statically at
> compile-time, so no dynamic dispatch is required.
>
> Without the ability to define "typedefs", this approach is not possible at
> all if there is a cyclic relationship. Also, if the combo declares more
> than three types, it becomes impractical to specify all those types on the
> classes directly as type parameters.
>
> In C# I learned that this quickly becomes a major problem if you need to
> parameterize on more than one or two types. I tried to do "generic" math
> (which requires at least two type parameters due to the under-designed
> standard libraries) and I also implemented a GiST data structure (see
> http://en.wikipedia.org/wiki/GiST), and found out that the lack of any
> analog to C++ typedef makes both of those tasks very clumsy, while also
> making the code hard to read, because you end up with a rats' nest of type
> parameters (or if you omit (otherwise necessary) type parameters, you might
> use lots of casts instead.)
>
> So I guess that leads me to two more questions.
>
> 2. Does Rust have a "typedef" equivalent that can be used in this way?
> 3. Does it make sense to just suggest "just use typedefs instead of
> Higher-Kinded Types"?
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/bf9aeca0/attachment.html>

From illissius at gmail.com  Sat Dec  7 13:09:52 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 7 Dec 2013 22:09:52 +0100
Subject: [rust-dev] Higher-Kinded Types vs C++ "Combos"
In-Reply-To: <CAPNUp0_T_j5-u6BC+2-ZAcsqADSkb0iA9r44FNYKDv7KeMWkVw@mail.gmail.com>
References: <CAHuo6ZBoZ5SYYxtb4w5ZgW90kwRMGEAsOOk-3-84eyYDLbg1tg@mail.gmail.com>
	<CAPNUp0_T_j5-u6BC+2-ZAcsqADSkb0iA9r44FNYKDv7KeMWkVw@mail.gmail.com>
Message-ID: <CAPNUp09OyjbM-8kFd5jabp8ErxL-CzyK-wB6XjGeFKbvOd0TWg@mail.gmail.com>

In all these cases with typedefs, you're still implicitly relying on
higher-kinded types, along with what are usually referred to as associated
types:

http://smallcultfollowing.com/babysteps/blog/2013/04/02/associated-items/
http://smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/

Kinds are basically the types of types. In the normal case there's two
varieties:

 - The base kind, which is the kind of what you normally think of as
"types", i.e. things which can be the type of values. In C++ this is called
typename/class (in Haskell: *).

 - The kind of functions from types of one kind to types of another
(potentially the same) kind; in other words, the kind of types
parameterized over type arguments (of varying kind). The simplest case is
the kind of functions from the base kind to the base kind, in C++
template<typename> class (in Haskell: * -> *).

Then you can iterate the second rule however you like for an infinite
regress of different kinds.

In all of these examples you're using an implicit protocol (type of a
particular kind with a particular name as a member) to encode associated
types. The associated types themselves are of higher kinds. In the Numbers
example, the type parameter itself is the base kind, but has an associated
type with a templatized (function) kind, which is what you're actually
using. In this case you could just as easily skip the middleman and pass
around the higher-kinded type directly, but associated types also give you
the ability to "branch" over the input type, which higher-kinded types by
themselves do not. (This is what happens, for example, when strings declare
that their element type is a character, instead of being parameterized over
an element type.)

Basically, this form of "typedefs" already implies HKT, and if we were to
add HKT, there would be no reason to restrict them to only being associated
types.


On Sat, Dec 7, 2013 at 9:05 PM, G?bor Lehel <illissius at gmail.com> wrote:

> Short version: yes, higher-kinded types and template template parameters
> are the same thing. (`template<typename> class` is just one particular
> higher kind; there's also `template<template<typename> class> class` and so
> on, and varying the number of parameters, etc., which you probably know.)
>
> Longer version hopefully upcoming if/when I manage to digest the rest of
> it.
>
>
> On Sat, Dec 7, 2013 at 8:10 AM, David Piepgrass <qwertie256 at gmail.com>wrote:
>
>> Rust newb here. I have theoretical questions.
>>
>> Recently I noticed that Higher-Kinded Types (HKTs) have been mentioned on
>> the mailing list a lot, but I had no idea what a HKT was, or what it might
>> be good for. After reading about them a little, they reminded me of C++'s
>> "template template parameters". In C++ you can almost write something like
>> this:
>>
>> template <template <typename> class collection>
>> struct Numbers {
>>    collection<int> integers;
>>    collection<float> floats;
>> };
>>
>> So then you can write Numbers<vector> for a structure that contains
>> vector<T> collections, and Numbers<list> for a structure that contains
>> list<T> collections. EXCEPT that it doesn't actually work, because
>> vector<T> has two template parameters (the second one, the allocator, is
>> normally left at its default). Let's ignore that, though.
>>
>> So that brings me to my first question: is this what "higher-kinded
>> types" means? What is the difference, if any, between HKT and C++ "template
>> templates"?
>>
>> However, as a C++ developer I never actually used a "template template"
>> parameter because I didn't know they existed for a long time. So instead I
>> would have written this, which has the same end-result:
>>
>> struct VectorTrait
>> {
>>     template<typename T>
>>     struct collection { typedef vector<T> type; };
>> };
>> struct ListTrait
>> {
>>     template<typename T>
>>     struct collection { typedef list<T> type; };
>> };
>>
>> template<typename Traits>
>> struct Numbers
>> {
>>     Traits::collection<int>::type integers;
>>     Traits::collection<float>::type floats;
>> };
>> // Use Numbers<VectorTrait> for vector<T>, Numbers<ListTrait> for list<T>.
>>
>> This is clunkier, but it would have been a bit simpler if C++ supported
>> templatized typedefs:
>>
>> struct VectorTrait
>> {
>>     template<typename T> typedef vector<T> collection;
>> };
>> struct ListTrait
>> {
>>     template<typename T> typedef vector<T> collection;
>> };
>>
>> template<typename Traits>
>> struct Numbers
>> {
>>     Traits::collection<int> integers;
>>     Traits::collection<float> floats;
>> };
>> // Now write Numbers<VectorTrait> instead of Numbers<vector>,
>> //           Numbers<ListTrait> instead of Numbers<list>.
>>
>> I have found that because of the existence of typedef, "template
>> template" parameters are never actually necessary; so far, I've never seen
>> a situation where the typedef-based solution wasn't almost as good. Also, I
>> have found that "trait" types filled with typedefs seem to be a more
>> general thing than "template template"; they allow you to do things that
>> would be very difficult or impossible without them. For example you can use
>> typedefs-in-a-struct to create circular references among types that don't
>> "know" about each other:
>>
>> // I call this a "Combo"; I don't know if the technique has a standard
>> name
>> struct MyCombo {
>>     typedef ConcreteA<Traits> A;
>>     typedef ConcreteB<Traits> B;
>>     typedef ConcreteC<Traits> C;
>> };
>> template<typename Combo>
>> class ConcreteA { Combo::B* b; ... };
>> template<typename Combo>
>> class ConcreteB { Combo::C* c; ... };
>> template<typename Combo>
>> class ConcreteC { Combo::A* b; ... };
>>
>> Here I've created a network of types (ConcreteA<MyCombo>,
>> ConcreteB<MyCombo>, and ConcreteC<MyCombo>) that are linked together
>> through the "Combo" type MyCombo, so the types can all use each other, but
>> none of the types refer to each other directly. This design allows you to
>> freely swap in different implementations of A, B, and C; it has similar
>> advantages to "dependency injection" or "inversion of control" in languages
>> like Java and C#, except that the linkages are all defined statically at
>> compile-time, so no dynamic dispatch is required.
>>
>> Without the ability to define "typedefs", this approach is not possible
>> at all if there is a cyclic relationship. Also, if the combo declares more
>> than three types, it becomes impractical to specify all those types on the
>> classes directly as type parameters.
>>
>> In C# I learned that this quickly becomes a major problem if you need to
>> parameterize on more than one or two types. I tried to do "generic" math
>> (which requires at least two type parameters due to the under-designed
>> standard libraries) and I also implemented a GiST data structure (see
>> http://en.wikipedia.org/wiki/GiST), and found out that the lack of any
>> analog to C++ typedef makes both of those tasks very clumsy, while also
>> making the code hard to read, because you end up with a rats' nest of type
>> parameters (or if you omit (otherwise necessary) type parameters, you might
>> use lots of casts instead.)
>>
>> So I guess that leads me to two more questions.
>>
>> 2. Does Rust have a "typedef" equivalent that can be used in this way?
>> 3. Does it make sense to just suggest "just use typedefs instead of
>> Higher-Kinded Types"?
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/9dcf3e94/attachment-0001.html>

From illissius at gmail.com  Sat Dec  7 14:14:34 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 7 Dec 2013 23:14:34 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <CAPNUp0_jJtCkR6NgZe-wWvpbEh_A=jvbsodWWB5VHnP2ELgTPg@mail.gmail.com>

I agree with this proposal. I also strongly agree with spir that we should
distinguish programmer errors from legitimate result possibilities. A
function should only fail directly if, were it to return a `None` or `Err`,
the only reasonable the thing caller could do would be to fail itself.

Somewhat formally, a function has a domain and a codomain, i.o.w. the
possible input and output values which make sense. If the type used for the
domain is "too big", and allows values which don't make sense in the
context of the function, then this opens up the possibility that the
programmer might mess up and nonetheless pass in one of those values. In
this case the right thing is for the function to fail at runtime: there's
not much else it could do. (This is the null argument /
NullPointerException situation in many other languages.)

The converse case is if the codomain is too small, and doesn't provide a
way to represent all of the possible output values. For example, a search
function might not have a way to say "not found". In this case the function
might also want to fail. But in Rust's type system it's much, much, much
easier to make types bigger than it is to make them smaller, so there's no
excuse not to do so. This function should just return an Option.

Of course, it's not always black and white, and what "makes sense" can
depend on the situation. Sometimes if the container we pass to the search
function doesn't contain the value we're searching for, then it's a bug.
The programmer can always signal this by just calling unwrap() (which I
agree should have a better name, if we can find one) or expect(). But I
think it's also reasonable to add convenience functions if this would be
the case often enough to make them worthwhile. But they should be clearly
presented as "added convenience functions, which fail in [these cases]" and
not as the default option.

Haskell has a bunch of partial functions which do their equivalent of
failing in their Prelude, such as `head :: [a] -> a`, and they've been
regretting it ever since. IMHO, let's try to keep our functions total
whenever we possibly can.


On Fri, Dec 6, 2013 at 9:41 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> We have some functions and methods such as [std::str::from_utf8](http://
> static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may
> succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with the
> error case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so
> returning an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This particular
> case is worse because we also have `from_utf8_owned` and
> `from_utf8_owned_opt`, to cover everything.
>
> Multiplying names like this is just not good design. I?d like to reduce
> this pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
> Option. I think we should rename every `foo_opt()` function or method to
> just `foo`, remove the old `foo()` behavior, and tell people (through
> documentation) to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful error
> messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
> this before sending pull requests with invasive API changes.)
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/64b1f041/attachment.html>

From illissius at gmail.com  Sat Dec  7 14:21:12 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 7 Dec 2013 23:21:12 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A2766A.6000105@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
Message-ID: <CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>

C# is actually adding null-chaining syntax sugar as well:
http://adamralph.com/2013/12/06/ndc-diary-day-3/?1

C# is a very sugar-happy language, and I think it's wise for Rust to be
conservative on this front (much easier to add things later than to remove
them), but given how pervasive it is, I do wonder whether it wouldn't make
sense to add sugar for Option, at least eventually. (`int?` at the type
level is really nice, too... too bad it doesn't play so well with Rust's
sigils. Introducing the potential confusion between `~?T` and `?~T` is
probably a step too far.)


On Sat, Dec 7, 2013 at 2:14 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 07/12/13 12:08, Jordi Boggiano wrote:
>
>> On Sat, Dec 7, 2013 at 2:01 AM, spir <denis.spir at gmail.com> wrote:
>>
>>> On 12/07/2013 01:12 AM, Gaetan wrote:
>>>
>>>> I am in favor of two version of the api: from_str which has already done
>>>> the unwrap, and a from_str_safe for instance that returns a Result or
>>>> option.
>>>>
>>> This provides the important semantic information (that I've evoked at the
>>> end end of a long earlier reply in this thread) of whether func failure
>>> is
>>> expected and belongs to the logic of the present app and we must deal
>>> with
>>> it, or not.
>>>
>>> But I'm still shared on this topic for finding it also annoying, like
>>> Simon,
>>> to have to duplicate whole catogories of such funcs (of which we cannot
>>> know
>>> in advance whther they'll fail or not), if only the interface as
>>> apparently
>>> proposed by Ga?tan.
>>>
>> Syntax sugar like this would be nice:
>>
>> let str = std::str::from_utf8("Parse this optimistically, and fail
>> otherwise");
>> // str is a string or the task fails
>>
>> vs.
>>
>> let opt_str = std::str::from_utf?("Parse this if valid"); // note the
>> question mark
>> if opt_str.is_some() { .... }
>>
>> Problem is, this sounds scary to implement at the compiler level, if
>> it's possible at all :) I am just throwing it out there for others to
>> judge.
>>
>> Cheers
>>
>>
> I personally think a better solution is something like Haskell's do
> notation[1], where you can chain several computations that return
> Option<..> such that if any intermediate one returns None, the later ones
> are not evaluated and the whole expression returns None, which saves having
> to call .get()/.unwrap()/.expect() a lot.
>
> This can work for types like Result too (in fact, the Haskell
> implementation of `do` is sugar around some monad functions, so any monad
> can be used there; we currently don't have the power to express the monad
> typeclass/trait in Rust so the fully general form probably isn't possible
> as a syntax extension yet, although a limited version is).
>
>
> Huon
>
> [1]: http://en.wikibooks.org/wiki/Haskell/do_Notation
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131207/233d3ac6/attachment.html>

From hatahet at gmail.com  Sun Dec  8 01:26:38 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sun, 8 Dec 2013 01:26:38 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
Message-ID: <CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>

On Sat, Dec 7, 2013 at 2:21 PM, G?bor Lehel <illissius at gmail.com> wrote:

> I do wonder whether it wouldn't make sense to add sugar for Option, at
> least eventually. (`int?` at the type level is really nice, too... too bad
> it doesn't play so well with Rust's sigils. Introducing the potential
> confusion between `~?T` and `?~T` is probably a step too far.)
>

Wouldn't it be better to add something similar to Haskell's `do` instead of
another sigil?


--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131208/fdace0f0/attachment.html>

From illissius at gmail.com  Sun Dec  8 04:01:16 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 8 Dec 2013 13:01:16 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
Message-ID: <CAPNUp08T7v7V-xOF6J3jKCE4HmRZe7Wc1p2WSUKh4A-DbQRO0Q@mail.gmail.com>

On Sun, Dec 8, 2013 at 10:26 AM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Sat, Dec 7, 2013 at 2:21 PM, G?bor Lehel <illissius at gmail.com> wrote:
>
>> I do wonder whether it wouldn't make sense to add sugar for Option, at
>> least eventually. (`int?` at the type level is really nice, too... too bad
>> it doesn't play so well with Rust's sigils. Introducing the potential
>> confusion between `~?T` and `?~T` is probably a step too far.)
>>
>
> Wouldn't it be better to add something similar to Haskell's `do` instead
> of another sigil?
>
>
...that's basically what I was saying.



> --
> Ziad
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131208/ee4e7ed7/attachment-0001.html>

From carter.schonwald at gmail.com  Sun Dec  8 09:58:23 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sun, 8 Dec 2013 12:58:23 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
Message-ID: <CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>

Such sugar would would use some sort of monad trait right?

On Sunday, December 8, 2013, Ziad Hatahet wrote:

> On Sat, Dec 7, 2013 at 2:21 PM, G?bor Lehel <illissius at gmail.com<javascript:_e({}, 'cvml', 'illissius at gmail.com');>
> > wrote:
>
>> I do wonder whether it wouldn't make sense to add sugar for Option, at
>> least eventually. (`int?` at the type level is really nice, too... too bad
>> it doesn't play so well with Rust's sigils. Introducing the potential
>> confusion between `~?T` and `?~T` is probably a step too far.)
>>
>
> Wouldn't it be better to add something similar to Haskell's `do` instead
> of another sigil?
>
>
> --
> Ziad
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131208/1c5c684d/attachment.html>

From damienradtke at gmail.com  Mon Dec  9 07:53:20 2013
From: damienradtke at gmail.com (Damien Radtke)
Date: Mon, 9 Dec 2013 09:53:20 -0600
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
Message-ID: <CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>

I have no idea if it would be feasible in the standard library, but
wouldn't the ideal solution be having one function (e.g. from_utf8()) that
could return two possible values, a bare result and an Option? Letting the
compiler decide which version to use based on type inference like this:

    let result: ~str = from_utf8(...);
    let result: Option<~str> = from_utf8(...);

Assuming both of them are passed invalid UTF8, then the first version would
fail, but the second version would just return None.

Again, I don't know if it's possible given the current implementation, but
I do think it would be helpful to have a picture of the ideal, and then
decide on whatever solution comes closest.

As a side note, even if the standard library sticks with two variants for
each option function, I would prefer the default one return an Option and
have the variant fail on invalid input. Task failure at runtime is a
nastier surprise than an invalid type error at compile time, especially for
new users who aren't entirely sure of the difference.


On Sun, Dec 8, 2013 at 11:58 AM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> Such sugar would would use some sort of monad trait right?
>
>
> On Sunday, December 8, 2013, Ziad Hatahet wrote:
>
>> On Sat, Dec 7, 2013 at 2:21 PM, G?bor Lehel <illissius at gmail.com> wrote:
>>
>>> I do wonder whether it wouldn't make sense to add sugar for Option, at
>>> least eventually. (`int?` at the type level is really nice, too... too bad
>>> it doesn't play so well with Rust's sigils. Introducing the potential
>>> confusion between `~?T` and `?~T` is probably a step too far.)
>>>
>>
>> Wouldn't it be better to add something similar to Haskell's `do` instead
>> of another sigil?
>>
>>
>> --
>> Ziad
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131209/cf869df1/attachment.html>

From denis.spir at gmail.com  Mon Dec  9 07:57:03 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 09 Dec 2013 16:57:03 +0100
Subject: [rust-dev]
 =?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
 =?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<52A2766A.6000105@gmail.com>	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
Message-ID: <52A5E84F.4020005@gmail.com>

On 12/09/2013 04:53 PM, Damien Radtke wrote:
> I have no idea if it would be feasible in the standard library, but
> wouldn't the ideal solution be having one function (e.g. from_utf8()) that
> could return two possible values, a bare result and an Option? Letting the
> compiler decide which version to use based on type inference like this:
>
>      let result: ~str = from_utf8(...);
>      let result: Option<~str> = from_utf8(...);
>
> Assuming both of them are passed invalid UTF8, then the first version would
> fail, but the second version would just return None.
>
> Again, I don't know if it's possible given the current implementation, but
> I do think it would be helpful to have a picture of the ideal, [...]

This is indeed close to an ideal version ;-), isn't it?

Denis

From simon.sapin at exyr.org  Mon Dec  9 08:05:53 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 09 Dec 2013 16:05:53 +0000
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<52A2766A.6000105@gmail.com>	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
Message-ID: <52A5EA61.5080704@exyr.org>

On 09/12/2013 15:53, Damien Radtke wrote:
> I have no idea if it would be feasible in the standard library, but
> wouldn't the ideal solution be having one function (e.g. from_utf8())
> that could return two possible values, a bare result and an Option?
> Letting the compiler decide which version to use based on type inference
> like this:
>
>      let result: ~str = from_utf8(...);
>      let result: Option<~str> = from_utf8(...);
>
> Assuming both of them are passed invalid UTF8, then the first version
> would fail, but the second version would just return None.
>
> Again, I don't know if it's possible given the current implementation,
> but I do think it would be helpful to have a picture of the ideal, and
> then decide on whatever solution comes closest.

It is possible to have a generic return value, see for example the 
.collect() method of iterators.

https://github.com/mozilla/rust/blob/4e0cb316fc980f00e1b74f3fdb7a842b540be280/src/libstd/iter.rs#L447

But it involves creating a trait, and implementing it for every 
supported type. IMO it?s a lot more involved than what we would want for 
every operation that may fail on invalid input.


> As a side note, even if the standard library sticks with two variants
> for each option function, I would prefer the default one return an
> Option and have the variant fail on invalid input. Task failure at
> runtime is a nastier surprise than an invalid type error at compile
> time, especially for new users who aren't entirely sure of the difference.

-- 
Simon Sapin

From gaetan at xeberon.net  Mon Dec  9 08:33:05 2013
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 9 Dec 2013 17:33:05 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A5EA61.5080704@exyr.org>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<52A5EA61.5080704@exyr.org>
Message-ID: <CANK7tAGGt1Yn2bPG5k6EeAbtUFz99dJSP0XKe_M1p-1kOAkDrw@mail.gmail.com>

>
>   let result: ~str = from_utf8(...);
>   let result: Option<~str> = from_utf8(...);


That was what I called "implicit unwrap". I however recommend ``let result
= from_utf8(...)`` to be the unwrapped version (ie, result is ~str)

Do you think it is possible to add this syntaxic sugar?

fn any_function() -> Result<~str>
{

...

}

// When called :

let s = any_function(); // unwrap() is automatically called, s is a ~str
let res = any_function?(); // unwrap is not called, res is a Result<~str>
let res2: Result<~str> = any_function(); // unwrap is not called, res is a
Result<~str>
if res.is_ok() {
  let s2 = res.unwrap()
}

Or maybe a simpler version, but the semantic is reversed, where a?() means
a().unwrap():

let res = any_function(); // unwrap is not called, res is a Result<~str>
let s = any_function?(); // unwrap() is automatically called, s is a ~str



-----
Gaetan



2013/12/9 Simon Sapin <simon.sapin at exyr.org>

> On 09/12/2013 15:53, Damien Radtke wrote:
>
>> I have no idea if it would be feasible in the standard library, but
>> wouldn't the ideal solution be having one function (e.g. from_utf8())
>> that could return two possible values, a bare result and an Option?
>> Letting the compiler decide which version to use based on type inference
>> like this:
>>
>>      let result: ~str = from_utf8(...);
>>      let result: Option<~str> = from_utf8(...);
>>
>> Assuming both of them are passed invalid UTF8, then the first version
>> would fail, but the second version would just return None.
>>
>> Again, I don't know if it's possible given the current implementation,
>> but I do think it would be helpful to have a picture of the ideal, and
>> then decide on whatever solution comes closest.
>>
>
> It is possible to have a generic return value, see for example the
> .collect() method of iterators.
>
> https://github.com/mozilla/rust/blob/4e0cb316fc980f00e1b74f3fdb7a84
> 2b540be280/src/libstd/iter.rs#L447
>
> But it involves creating a trait, and implementing it for every supported
> type. IMO it?s a lot more involved than what we would want for every
> operation that may fail on invalid input.
>
>
>
>  As a side note, even if the standard library sticks with two variants
>> for each option function, I would prefer the default one return an
>> Option and have the variant fail on invalid input. Task failure at
>> runtime is a nastier surprise than an invalid type error at compile
>> time, especially for new users who aren't entirely sure of the difference.
>>
>
> --
> Simon Sapin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131209/97241abc/attachment.html>

From niko at alum.mit.edu  Mon Dec  9 09:30:03 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 9 Dec 2013 12:30:03 -0500
Subject: [rust-dev] Define copyable types for [T,
 ..2] static vector initialization
In-Reply-To: <CAEsTQVP4uXf+nSgOggd8+kx37C=LLY4pQzn0b9f2zJXfEFEJ9Q@mail.gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
	<CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
	<148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>
	<CAEsTQVNtB3Z1P6W+ugVFevVhbGZXack1ACyXsspeYRC6uGaAAw@mail.gmail.com>
	<89849A08-511B-4E98-95AD-055178690831@sb.org>
	<CAEsTQVP4uXf+nSgOggd8+kx37C=LLY4pQzn0b9f2zJXfEFEJ9Q@mail.gmail.com>
Message-ID: <20131209173003.GA2242@Mr-Bennet>

On Sat, Nov 30, 2013 at 12:53:24AM -0500, Ashish Myles wrote:
> I have been waiting on integer parameters on traits since I first ran
> into Rust, but the rust team might be avoiding that to prevent getting
> Turing complete generics/templates.

I assume we'll get to it eventually.


Niko

From damienradtke at gmail.com  Mon Dec  9 09:35:10 2013
From: damienradtke at gmail.com (Damien Radtke)
Date: Mon, 9 Dec 2013 11:35:10 -0600
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52A5EA61.5080704@exyr.org>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<52A5EA61.5080704@exyr.org>
Message-ID: <CAH0VdcbqAL8+6OnaQD6F91vXnFnEq1OQc-GyAnp3chG2WCT=Ow@mail.gmail.com>

Why not have it be an auto-implemented trait like Send or Freeze?


On Mon, Dec 9, 2013 at 10:05 AM, Simon Sapin <simon.sapin at exyr.org> wrote:

> On 09/12/2013 15:53, Damien Radtke wrote:
>
>> I have no idea if it would be feasible in the standard library, but
>> wouldn't the ideal solution be having one function (e.g. from_utf8())
>> that could return two possible values, a bare result and an Option?
>> Letting the compiler decide which version to use based on type inference
>> like this:
>>
>>      let result: ~str = from_utf8(...);
>>      let result: Option<~str> = from_utf8(...);
>>
>> Assuming both of them are passed invalid UTF8, then the first version
>> would fail, but the second version would just return None.
>>
>> Again, I don't know if it's possible given the current implementation,
>> but I do think it would be helpful to have a picture of the ideal, and
>> then decide on whatever solution comes closest.
>>
>
> It is possible to have a generic return value, see for example the
> .collect() method of iterators.
>
> https://github.com/mozilla/rust/blob/4e0cb316fc980f00e1b74f3fdb7a84
> 2b540be280/src/libstd/iter.rs#L447
>
> But it involves creating a trait, and implementing it for every supported
> type. IMO it?s a lot more involved than what we would want for every
> operation that may fail on invalid input.
>
>
>
>  As a side note, even if the standard library sticks with two variants
>> for each option function, I would prefer the default one return an
>> Option and have the variant fail on invalid input. Task failure at
>> runtime is a nastier surprise than an invalid type error at compile
>> time, especially for new users who aren't entirely sure of the difference.
>>
>
> --
> Simon Sapin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131209/a839239b/attachment.html>

From danielmicay at gmail.com  Mon Dec  9 12:42:00 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 9 Dec 2013 15:42:00 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
Message-ID: <CA+DvKQKytkhS0oNMC1iZ+8io4Tna-pUnni7=kNnhTmPtePgJZg@mail.gmail.com>

On Mon, Dec 9, 2013 at 10:53 AM, Damien Radtke <damienradtke at gmail.com> wrote:
> I have no idea if it would be feasible in the standard library, but wouldn't
> the ideal solution be having one function (e.g. from_utf8()) that could
> return two possible values, a bare result and an Option? Letting the
> compiler decide which version to use based on type inference like this:
>
>     let result: ~str = from_utf8(...);
>     let result: Option<~str> = from_utf8(...);
>
> Assuming both of them are passed invalid UTF8, then the first version would
> fail, but the second version would just return None.
>
> Again, I don't know if it's possible given the current implementation, but I
> do think it would be helpful to have a picture of the ideal, and then decide
> on whatever solution comes closest.
>
> As a side note, even if the standard library sticks with two variants for
> each option function, I would prefer the default one return an Option and
> have the variant fail on invalid input. Task failure at runtime is a nastier
> surprise than an invalid type error at compile time, especially for new
> users who aren't entirely sure of the difference.

I think this is too complex and error prone. I don't see the problem
with just using `Option` and then calling `get` (currently `unwrap`)
when you want to ignore the possibility of failure. The compiler
should be printing a failure stack trace but for now you can still get
one with `gdb`.

From corey at octayn.net  Mon Dec  9 19:19:25 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 9 Dec 2013 22:19:25 -0500
Subject: [rust-dev] This Week in Rust
Message-ID: <CA++BO6S4CV8BjZEgk65zdiSuTTy-TFUYNibXHGikPov3i0Npmw@mail.gmail.com>

Hello and welcome to another issue of *This Week in Rust*! It's a bit delayed
due to finals, but like the spinning of the Earth it goes on.

Shameless plug: [ask me to do
things](http://www.reddit.com/r/rust/comments/1sikak/ask_cmr_to_do_things/)
over my winter break!

# What's cooking on master?

52 PRs were merged this week.

## Breaking Changes

- The much-discussed [`Result` API
changes](https://github.com/mozilla/rust/pull/10364) have happened. The gist
of it is that `.ok()` and `.err()` return Options. The other changes didn't
land, I assume they will be coming later.
- The [JIT support has been
removed](https://github.com/mozilla/rust/pull/10758), due to lack of
maintenance and upstream
changes (this came with the LLVM upgrade).
- Keywords (except self) are [no longer allowed as lifetime
parameters](https://github.com/mozilla/rust/pull/10675).
- `Path::new` has been [renamed](https://github.com/mozilla/rust/pull/10796)
back to `Path::init`.
- `std::str::from_utf8` [no longer
allocates](https://github.com/mozilla/rust/pull/10701).
- `std::util::ignore` [has been
renamed](https://github.com/mozilla/rust/pull/10701) to `std::util::drop`, to
better reflect what it does.
- Duplicate bindings are [no longer
allowed](https://github.com/mozilla/rust/pull/10776) in struct bindings. That
is, `let SomeStruct { foo, foo } = baz;` is no longer legal.
- Dynamic library propagation [is
reimplemented](https://github.com/mozilla/rust/pull/10777).
- `extra::c_vec` [has been
modernized](https://github.com/mozilla/rust/pull/10736).
- `MutableVector::mut_split` [has been
renamed](https://github.com/mozilla/rust/pull/10757) to `mut_split_at`.

## Other changes

- A part of the tutorial [has been
rewritten](https://github.com/mozilla/rust/pull/10690).
- Vim highlighting [has been
updated](https://github.com/mozilla/rust/pull/10793).
- `deriving` [has better error
messages](https://github.com/mozilla/rust/pull/10844).
- `StrSlice` has [grown some
documentation](https://github.com/mozilla/rust/pull/10824).
- Snapshots are now [statically
linked](https://github.com/mozilla/rust/pull/10809).
- From the "changes I don't really understand" department, [trait lifetime
parameters](https://github.com/mozilla/rust/pull/10506) are early bound in
associated functions.
- A race in the scheduler [has been
squelched](https://github.com/mozilla/rust/pull/10817).
- extra now has an [LRU cache](https://github.com/mozilla/rust/pull/10211).
- A `log_enabled!(level)` macro [has been
added](https://github.com/mozilla/rust/pull/10768), for checking if the
program is being run at a given log level.
- Static linking [now has docs](https://github.com/mozilla/rust/pull/10742)!
- Memory usage when compiling librustc has been killed by 130MB with some
[well-placed indirection](https://github.com/mozilla/rust/pull/10676).
- `MutableVector` has [another
iterator](https://github.com/mozilla/rust/pull/10739): `mut_chunks()`, for
iterating over mutable slices.
- The `reverse-complement` shootout benchmark [has been
rewritten](https://github.com/mozilla/rust/pull/10799).


## New contributors

- Alexandros Tasos
- Diego Ongaro
- Julia Evans
- osa1

# Meeting

The [weekly
meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-03)
discussed using `box` for placement new, some rustpkg discussion, dropping the
dependency on a system C++ library, and the above `from_utf8` and `Result`
pull requests.

# This Week in Servo

Servo is a web browser engine written in Rust and is one of the primary test
cases for the Rust language.

We landed 19 PRs this week.

## Notable additions
- Simon Sapin added the CSS visibility property in
[#1331](https://github.com/mozilla/servo/pull/1331).
- Juneyoung Cho landed local bookmark navigation in
[#1262](https://github.com/mozilla/servo/pull/1262).
- ms2ger added reporting exceptions to JS when the DOM implementation fails in
[#1304](https://github.com/mozilla/servo/pull/1304).
- Keegan McAllister and Patrick Kim landed several changes to continue our
push to remove @-boxes to open up more of our data to safe parallel access
across task boundaries.

## New contributors
- Bruno de Oliveira Abinader
- Daniel Hedlund

## New intern
- Isabelle Carter will be joining us as part of the GNOME Outreach Program for
Women, [OPW]( https://wiki.gnome.org/OutreachProgramForWomen ), and will be
working on adding `position:fixed` support to Servo. The internship runs from
December 10 through March 10.

## Meetings
This week's
[meeting](https://github.com/mozilla/servo/wiki/Meeting-2013-12-02) was short
and mostly covered some build system changes that Jack is working on. In
short, we will use Rust's static linking to make it easier to distribute a
Servo binary and we are making a larger change to CMake in order to get both
more reliable parallel/incremental builds and get support for
cross-compilation.

# Announcements etc

- [Evict-BT](http://www.reddit.com/r/rust/comments/1s5laq/evictbt_an_issue_tracker_written_in_rust_that/)
 \- an issue tracker that integrates loosely with git.
- [Rust with
 Emscripten](http://www.reddit.com/r/rust/comments/1s8c0j/rust_with_emscripten/)
- [Day 36: On programming without
 malloc](http://www.reddit.com/r/rust/comments/1s3jgd/day_36_on_programming_without_malloc/)
- [Rust experience
 report](http://www.reddit.com/r/rust/comments/1s3osp/blast_from_the_past_pre01_raytracer_rustdev_rust/)
 \- a pre-0.1 raytracer and response to the language.
- [Rust frontend to
 GCC](http://www.reddit.com/r/rust/comments/1s0aj5/rust_frontend_to_gcc/)
- [Types in Rust, for
 Beginners](http://www.reddit.com/r/rust/comments/1ry4ym/types_in_rust_for_beginners/)
- [Thoughts on DST, part
 4](http://www.reddit.com/r/rust/comments/1rxj0x/thoughts_on_dst_part_4_including_a_recap_of_parts/)
- [Slides from pnkfelix's codemash
 presentation](http://pnkfelix.github.io/present-rust-codemesh2013/fklock-rust-codemesh2013.pdf).
- [An ML thread on redundant APIs involving
 `Option`](http://www.reddit.com/r/rust/comments/1seoe1/lets_avoid_having_both_foo_and_foo_opt/)
- [What do you want in a Rust Docker
 image?](http://www.reddit.com/r/rust/comments/1se6qa/rfc_what_do_you_want_in_a_rust_docker_image/)
- [A huge thread on lots of things
 Rust](http://www.reddit.com/r/rust/comments/1s9y7o/less_is_more_lambda_the_ultimate/)
- [Rust bindings to
 libsodium/NaCl](http://www.reddit.com/r/rust/comments/1s8opt/sodium_oxide_fast_cryptographic_library_for_rust/)

From kevin at sb.org  Mon Dec  9 19:40:22 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 9 Dec 2013 19:40:22 -0800
Subject: [rust-dev] This Week in Rust
In-Reply-To: <CA++BO6S4CV8BjZEgk65zdiSuTTy-TFUYNibXHGikPov3i0Npmw@mail.gmail.com>
References: <CA++BO6S4CV8BjZEgk65zdiSuTTy-TFUYNibXHGikPov3i0Npmw@mail.gmail.com>
Message-ID: <B1F9ECF5-9F33-4027-9667-C35BB07F3410@sb.org>

On Dec 9, 2013, at 7:19 PM, Corey Richardson <corey at octayn.net> wrote:

> - `Path::new` has been [renamed](https://github.com/mozilla/rust/pull/10796)
> back to `Path::init`.

Other way around. `Path::init` has been renamed back to `Path::new`, along with extra::json and std::rt::deque

-Kevin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131209/46e6f23f/attachment.p7s>

From hatahet at gmail.com  Tue Dec 10 12:35:34 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 10 Dec 2013 12:35:34 -0800
Subject: [rust-dev] List of potential C# 6.0 features
Message-ID: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>

Thought this would be of interest to the list:
http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated


--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131210/4b8b2580/attachment.html>

From ncm at cantrip.org  Tue Dec 10 19:31:21 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Tue, 10 Dec 2013 19:31:21 -0800
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
Message-ID: <52A7DC89.6040408@cantrip.org>

On 12/10/2013 12:35 PM, Ziad Hatahet wrote:
> Thought this would be of interest to the list:
> http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated

It's a good sign that nothing like most of these would add any
value in Rust. The C# syntax hacks (old and proposed) for what
they call "property" members only shorten badly designed code.
Making bad code look less bad than it is should count as a
negative.  In places where there is no practical possibility
of good code, making bad code look better may be the best one
can do, but even there the right choice is to code somewhere
else instead.

Nathan Myers

From zack at z0w0.me  Tue Dec 10 21:04:41 2013
From: zack at z0w0.me (Zack Corr)
Date: Wed, 11 Dec 2013 15:04:41 +1000
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <52A7DC89.6040408@cantrip.org>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
Message-ID: <CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>

I think the Monadic null operator (a.k.a. safe property access operator)
would be pretty useful syntax sugar for mapping over option types, and
certainly help with the whole "option vs fail" for error checking because
it essentially allows monad-like functionality without actually having
(first-class) monads.

For example,

let original: Option<int> = from_str("1");
> let result: Option<Float> = original?.to_float()?.sqrt();


The `?.` operator would first check if the LHE is `Nothing`. If so, the
resulting value will just be nothing. If it's not, it will unwrap the
underlying value and call a method on the value (or reference a property if
for example it is a struct).
I think this would also be future-proof for whenever Rust gets
higher-kinded types (or if it ever does), because instead of being
hard-coded to Option it could work off a builtin Monad trait.

On Wed, Dec 11, 2013 at 1:31 PM, Nathan Myers <ncm at cantrip.org> wrote:

> On 12/10/2013 12:35 PM, Ziad Hatahet wrote:
>
>> Thought this would be of interest to the list:
>> http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated
>>
>
> It's a good sign that nothing like most of these would add any
> value in Rust. The C# syntax hacks (old and proposed) for what
> they call "property" members only shorten badly designed code.
> Making bad code look less bad than it is should count as a
> negative.  In places where there is no practical possibility
> of good code, making bad code look better may be the best one
> can do, but even there the right choice is to code somewhere
> else instead.
>
> Nathan Myers
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/1895b5c1/attachment.html>

From hatahet at gmail.com  Tue Dec 10 23:25:44 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 10 Dec 2013 23:25:44 -0800
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
Message-ID: <CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>

On Tue, Dec 10, 2013 at 9:04 PM, Zack Corr <zack at z0w0.me> wrote:

> I think the Monadic null operator (a.k.a. safe property access operator)
> would be pretty useful syntax sugar for mapping over option types, and
> certainly help with the whole "option vs fail" for error checking because
> it essentially allows monad-like functionality without actually having
> (first-class) monads.
>


I still think that having something like Haskell's `do`, or Scala's `for`
is a better way to go about this. Especially that it generalizes over more
than just `Option<T>`.

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131210/9f531959/attachment.html>

From carter.schonwald at gmail.com  Tue Dec 10 23:43:10 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Wed, 11 Dec 2013 02:43:10 -0500
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
	<CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
Message-ID: <CAHYVw0wYU24eft58ZTwh6eQgbWN6BN9jPcJzk+Th4NH6S15ndg@mail.gmail.com>

do notation is a bit better behaved than scala's for notation  (afaik)

When HKT and the associated traits happen, some analogue of the Functor and
Applicative abstractions in haskell would be great complements to monads.
In fact, it can easily be argued that they're more important in many
library APIs


On Wed, Dec 11, 2013 at 2:25 AM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Tue, Dec 10, 2013 at 9:04 PM, Zack Corr <zack at z0w0.me> wrote:
>
>> I think the Monadic null operator (a.k.a. safe property access operator)
>> would be pretty useful syntax sugar for mapping over option types, and
>> certainly help with the whole "option vs fail" for error checking because
>> it essentially allows monad-like functionality without actually having
>> (first-class) monads.
>>
>
>
> I still think that having something like Haskell's `do`, or Scala's `for`
> is a better way to go about this. Especially that it generalizes over more
> than just `Option<T>`.
>
> --
> Ziad
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/e7968951/attachment.html>

From jurily at gmail.com  Wed Dec 11 01:46:26 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Wed, 11 Dec 2013 10:46:26 +0100
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
Message-ID: <52A83472.7010700@gmail.com>

On 12/11/2013 06:04 AM, Zack Corr wrote:
>     let original: Option<int> = from_str("1");
>     let result: Option<Float> = original?.to_float()?.sqrt();

You can already say

         let original: Option<int> = Some(1);
         let result: Option<f64> = original
              .and_then(|f| f.to_f64())
              .map(|f| f.sqrt());

...which is admittedly not as nice, but at least it's not magical.

From jon.mb at proinbox.com  Wed Dec 11 03:01:46 2013
From: jon.mb at proinbox.com (John Mija)
Date: Wed, 11 Dec 2013 11:01:46 +0000
Subject: [rust-dev] Interface around SQL databases
Message-ID: <52A8461A.2000903@proinbox.com>

Before of release 1.0, it would be very good if it's added to the 
package standard a generic interface to be implemented by the packages 
of SQL drivers.

As example, see packages "database/sql" and "database/sql/driver" in the 
Go's library:

http://golang.org/pkg/database/

From gaetan at xeberon.net  Wed Dec 11 06:24:35 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 11 Dec 2013 15:24:35 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A8461A.2000903@proinbox.com>
References: <52A8461A.2000903@proinbox.com>
Message-ID: <CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>

I'll be glad volunteering for this task, however I'm new in rust so I may
need to have some mentoring for this...

I would be inspired by the python interface:
https://pypi.python.org/pypi/MySQL-python/1.2.4

-----
Gaetan



2013/12/11 John Mija <jon.mb at proinbox.com>

> Before of release 1.0, it would be very good if it's added to the package
> standard a generic interface to be implemented by the packages of SQL
> drivers.
>
> As example, see packages "database/sql" and "database/sql/driver" in the
> Go's library:
>
> http://golang.org/pkg/database/
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/c6360872/attachment.html>

From masklinn at masklinn.net  Wed Dec 11 06:35:34 2013
From: masklinn at masklinn.net (Masklinn)
Date: Wed, 11 Dec 2013 15:35:34 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
Message-ID: <D879C0F2-0F6C-4774-873D-B532622CBD74@masklinn.net>


On 2013-12-11, at 15:24 , Gaetan <gaetan at xeberon.net> wrote:

> I'll be glad volunteering for this task, however I'm new in rust so I may need to have some mentoring for this...
> 
> I would be inspired by the python interface: https://pypi.python.org/pypi/MySQL-python/1.2.4

A better inspiration than a specific module would probably be PEP 249
?DBAPI 2?[0], or Perl?s DBI[1].

[0] http://www.python.org/dev/peps/pep-0249/

[1] http://dbi.perl.org/

From corey at octayn.net  Wed Dec 11 06:44:54 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 11 Dec 2013 09:44:54 -0500
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
Message-ID: <CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>

Python has the advantage of dynamic typing, and Go runtime type
assertions and variadics. Their interfaces probably aren't /too/ good
for inspiration, especially Python's.

See rust-postgres (https://github.com/sfackler/rust-postgres) for an
existing DB binding. I think it's fairly idiomatic and any DB API
should draw inspiration from it. It leverages trait objects, though
it's unclear that that can be generic. Personally I've never really
been a fan of generic SQL APIs. Unless they leverage intense amounts
of magic (Entity Framework, SQLAlchemy), I find they end up being
crippled (luasql) or fairly uses (python's dbapi).

Maybe that's just me.

On Wed, Dec 11, 2013 at 9:24 AM, Gaetan <gaetan at xeberon.net> wrote:
> I'll be glad volunteering for this task, however I'm new in rust so I may
> need to have some mentoring for this...
>
> I would be inspired by the python interface:
> https://pypi.python.org/pypi/MySQL-python/1.2.4
>
> -----
> Gaetan
>
>
>
> 2013/12/11 John Mija <jon.mb at proinbox.com>
>>
>> Before of release 1.0, it would be very good if it's added to the package
>> standard a generic interface to be implemented by the packages of SQL
>> drivers.
>>
>> As example, see packages "database/sql" and "database/sql/driver" in the
>> Go's library:
>>
>> http://golang.org/pkg/database/
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Wed Dec 11 07:15:27 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 11 Dec 2013 16:15:27 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
	<CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>
Message-ID: <CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>

I agree python dbapi is pretty simple to use due to the dynamic nature of
types in python.

I like this rust postgre binding, I can't see why it cannot be extended to
support mysql?

Actually, my main reference is sqlalchemy but it's a step much higher in
term of abstraction of the DB.

-----
Gaetan



2013/12/11 Corey Richardson <corey at octayn.net>

> Python has the advantage of dynamic typing, and Go runtime type
> assertions and variadics. Their interfaces probably aren't /too/ good
> for inspiration, especially Python's.
>
> See rust-postgres (https://github.com/sfackler/rust-postgres) for an
> existing DB binding. I think it's fairly idiomatic and any DB API
> should draw inspiration from it. It leverages trait objects, though
> it's unclear that that can be generic. Personally I've never really
> been a fan of generic SQL APIs. Unless they leverage intense amounts
> of magic (Entity Framework, SQLAlchemy), I find they end up being
> crippled (luasql) or fairly uses (python's dbapi).
>
> Maybe that's just me.
>
> On Wed, Dec 11, 2013 at 9:24 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I'll be glad volunteering for this task, however I'm new in rust so I may
> > need to have some mentoring for this...
> >
> > I would be inspired by the python interface:
> > https://pypi.python.org/pypi/MySQL-python/1.2.4
> >
> > -----
> > Gaetan
> >
> >
> >
> > 2013/12/11 John Mija <jon.mb at proinbox.com>
> >>
> >> Before of release 1.0, it would be very good if it's added to the
> package
> >> standard a generic interface to be implemented by the packages of SQL
> >> drivers.
> >>
> >> As example, see packages "database/sql" and "database/sql/driver" in the
> >> Go's library:
> >>
> >> http://golang.org/pkg/database/
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/0ac66bfa/attachment.html>

From pcwalton at mozilla.com  Wed Dec 11 09:04:49 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 11 Dec 2013 09:04:49 -0800
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A8461A.2000903@proinbox.com>
References: <52A8461A.2000903@proinbox.com>
Message-ID: <52A89B31.2080706@mozilla.com>

On 12/11/13 3:01 AM, John Mija wrote:
> Before of release 1.0, it would be very good if it's added to the
> package standard a generic interface to be implemented by the packages
> of SQL drivers.

We aren't likely to block 1.0 on this. Instead of stabilizing all 
libraries once and for all in 1.0 like Go did, we're taking a gradual 
approach to libraries similar to that of node.js, in which 1.0 will have 
some library modules stable and some modules unstable, and releases 1.1, 
1.2, and beyond will stabilize more and more libraries as time goes on.

I think this approach will give us a higher degree of confidence that we 
don't have to live with library interfaces that are suboptimal for all 
time, since we can focus on libraries one at a time instead of freezing 
everything in one fell swoop.

Patrick


From sfackler at gmail.com  Wed Dec 11 09:10:46 2013
From: sfackler at gmail.com (Steven Fackler)
Date: Wed, 11 Dec 2013 09:10:46 -0800
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
	<CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>
	<CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>
Message-ID: <CANb7cF578BGTjwjpM47crBHZJ=PQO7dUxHR+Cyr0Gg8vXQfLGQ@mail.gmail.com>

The interface can be made generic, but it'd require HKT and potentially
some more work on removing spurious conflicting trait implementation
warnings. It only uses trait objects for query parameters where you
actually need an array of distinct types implementing an interface. I've
also found that generic SQL interfaces are less than useful in the "I can
instantly swap from Postgres to SQLite with a config file toggle" sense
simply because their implementations of SQL (SERIAL vs AUTOINCREMENT, etc)
differ too much for it to work without a ton of pain. If anything, a
generic API would be nice just to push the APIs of different SQL client
libraries closer together.

Someone could absolutely take the interface used by rust-postgres and make
a MySQL/MariaDB driver with it, but that person wouldn't be me :)

Steven Fackler


On Wed, Dec 11, 2013 at 7:15 AM, Gaetan <gaetan at xeberon.net> wrote:

> I agree python dbapi is pretty simple to use due to the dynamic nature of
> types in python.
>
> I like this rust postgre binding, I can't see why it cannot be extended to
> support mysql?
>
> Actually, my main reference is sqlalchemy but it's a step much higher in
> term of abstraction of the DB.
>
> -----
> Gaetan
>
>
>
> 2013/12/11 Corey Richardson <corey at octayn.net>
>
>> Python has the advantage of dynamic typing, and Go runtime type
>> assertions and variadics. Their interfaces probably aren't /too/ good
>> for inspiration, especially Python's.
>>
>> See rust-postgres (https://github.com/sfackler/rust-postgres) for an
>> existing DB binding. I think it's fairly idiomatic and any DB API
>> should draw inspiration from it. It leverages trait objects, though
>> it's unclear that that can be generic. Personally I've never really
>> been a fan of generic SQL APIs. Unless they leverage intense amounts
>> of magic (Entity Framework, SQLAlchemy), I find they end up being
>> crippled (luasql) or fairly uses (python's dbapi).
>>
>> Maybe that's just me.
>>
>> On Wed, Dec 11, 2013 at 9:24 AM, Gaetan <gaetan at xeberon.net> wrote:
>> > I'll be glad volunteering for this task, however I'm new in rust so I
>> may
>> > need to have some mentoring for this...
>> >
>> > I would be inspired by the python interface:
>> > https://pypi.python.org/pypi/MySQL-python/1.2.4
>> >
>> > -----
>> > Gaetan
>> >
>> >
>> >
>> > 2013/12/11 John Mija <jon.mb at proinbox.com>
>> >>
>> >> Before of release 1.0, it would be very good if it's added to the
>> package
>> >> standard a generic interface to be implemented by the packages of SQL
>> >> drivers.
>> >>
>> >> As example, see packages "database/sql" and "database/sql/driver" in
>> the
>> >> Go's library:
>> >>
>> >> http://golang.org/pkg/database/
>> >> _______________________________________________
>> >> Rust-dev mailing list
>> >> Rust-dev at mozilla.org
>> >> https://mail.mozilla.org/listinfo/rust-dev
>> >
>> >
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/1de58afb/attachment-0001.html>

From erick.tryzelaar at gmail.com  Wed Dec 11 09:13:37 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Wed, 11 Dec 2013 09:13:37 -0800
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A89B31.2080706@mozilla.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
Message-ID: <CALdfqQJNNyt_k4qG_=Z0fBWOA8-8Q6BhY3J9t7+JEa-Kfgnp2g@mail.gmail.com>

While I'm all in favor of having a standard SQL interface, but I don't
think it needs to be a part of Rust's standard library. Instead I feel this
is one of those libraries that can live outside of rust proper and be
blessed by the community as being the standard SQL framework. Once rustpkg
is done, using this library shouldn't be any different than using something
out of libstd for the end users. That'll allow the SQL framework to evolve
independently of Rust, and cut down on the rust compiler maintenance.





On Wed, Dec 11, 2013 at 9:04 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/11/13 3:01 AM, John Mija wrote:
>
>> Before of release 1.0, it would be very good if it's added to the
>> package standard a generic interface to be implemented by the packages
>> of SQL drivers.
>>
>
> We aren't likely to block 1.0 on this. Instead of stabilizing all
> libraries once and for all in 1.0 like Go did, we're taking a gradual
> approach to libraries similar to that of node.js, in which 1.0 will have
> some library modules stable and some modules unstable, and releases 1.1,
> 1.2, and beyond will stabilize more and more libraries as time goes on.
>
> I think this approach will give us a higher degree of confidence that we
> don't have to live with library interfaces that are suboptimal for all
> time, since we can focus on libraries one at a time instead of freezing
> everything in one fell swoop.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/6d6434ad/attachment.html>

From jon.mb at proinbox.com  Wed Dec 11 09:27:43 2013
From: jon.mb at proinbox.com (John Mija)
Date: Wed, 11 Dec 2013 17:27:43 +0000
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A89B31.2080706@mozilla.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
Message-ID: <52A8A08F.9060903@proinbox.com>

Sounds good me.

I believed that the API would be frozen in 1.0 like Go. Besides, that 
version is going to attract many developers and without a generic API to 
build SQL drivers, it would be very chaotic to have different clients of 
SQL engines with a different API instead of to have the same one being 
able to switch between them if necessary.

El 11/12/13 17:04, Patrick Walton escribi?:
> On 12/11/13 3:01 AM, John Mija wrote:
>> Before of release 1.0, it would be very good if it's added to the
>> package standard a generic interface to be implemented by the packages
>> of SQL drivers.
>
> We aren't likely to block 1.0 on this. Instead of stabilizing all
> libraries once and for all in 1.0 like Go did, we're taking a gradual
> approach to libraries similar to that of node.js, in which 1.0 will have
> some library modules stable and some modules unstable, and releases 1.1,
> 1.2, and beyond will stabilize more and more libraries as time goes on.
>
> I think this approach will give us a higher degree of confidence that we
> don't have to live with library interfaces that are suboptimal for all
> time, since we can focus on libraries one at a time instead of freezing
> everything in one fell swoop.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>

From lists at dhardy.name  Wed Dec 11 10:10:31 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Wed, 11 Dec 2013 19:10:31 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A8A08F.9060903@proinbox.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
	<52A8A08F.9060903@proinbox.com>
Message-ID: <2385889.7k3drJ585f@tph-l10036>

On Wednesday 11 December 2013 17:27:43 John Mija wrote:
> Sounds good me.
> 
> I believed that the API would be frozen in 1.0 like Go. Besides, that
> version is going to attract many developers and without a generic API to
> build SQL drivers, it would be very chaotic to have different clients of
> SQL engines with a different API instead of to have the same one being
> able to switch between them if necessary.

I don't see why that is a problem. It requires some coordination/response by 
those writing DB drivers for sure, but it shouldn't require inclusion in Rust 
core to get a stable API. Maybe a certain amount of unpredictability during 
the early days is for the best...

> > I think this approach will give us a higher degree of confidence that we
> > don't have to live with library interfaces that are suboptimal for all
> > time, since we can focus on libraries one at a time instead of freezing
> > everything in one fell swoop.
> > 
> > Patrick
> > 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/b89a9a0f/attachment.sig>

From kevin at sb.org  Wed Dec 11 10:14:48 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 11 Dec 2013 10:14:48 -0800
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CANb7cF578BGTjwjpM47crBHZJ=PQO7dUxHR+Cyr0Gg8vXQfLGQ@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
	<CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>
	<CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>
	<CANb7cF578BGTjwjpM47crBHZJ=PQO7dUxHR+Cyr0Gg8vXQfLGQ@mail.gmail.com>
Message-ID: <DCBB52BD-5080-4B41-A01D-A201D6CCA418@sb.org>

My belief is that a generic interface to DBs is only useful because that way you can write other DB-driven libraries that don't care about the details of the DB. I don't think I've ever seen code in the wild that uses this functionality though (although, admittedly, I haven't looked at a lot of code that uses databases in general).

-Kevin

On Dec 11, 2013, at 9:10 AM, Steven Fackler <sfackler at gmail.com> wrote:

> The interface can be made generic, but it'd require HKT and potentially some more work on removing spurious conflicting trait implementation warnings. It only uses trait objects for query parameters where you actually need an array of distinct types implementing an interface. I've also found that generic SQL interfaces are less than useful in the "I can instantly swap from Postgres to SQLite with a config file toggle" sense simply because their implementations of SQL (SERIAL vs AUTOINCREMENT, etc) differ too much for it to work without a ton of pain. If anything, a generic API would be nice just to push the APIs of different SQL client libraries closer together.
> 
> Someone could absolutely take the interface used by rust-postgres and make a MySQL/MariaDB driver with it, but that person wouldn't be me :)
> 
> Steven Fackler
> 
> 
> On Wed, Dec 11, 2013 at 7:15 AM, Gaetan <gaetan at xeberon.net> wrote:
> I agree python dbapi is pretty simple to use due to the dynamic nature of types in python.
> 
> I like this rust postgre binding, I can't see why it cannot be extended to support mysql?
> 
> Actually, my main reference is sqlalchemy but it's a step much higher in term of abstraction of the DB.
> 
> -----
> Gaetan
> 
> 
> 
> 2013/12/11 Corey Richardson <corey at octayn.net>
> Python has the advantage of dynamic typing, and Go runtime type
> assertions and variadics. Their interfaces probably aren't /too/ good
> for inspiration, especially Python's.
> 
> See rust-postgres (https://github.com/sfackler/rust-postgres) for an
> existing DB binding. I think it's fairly idiomatic and any DB API
> should draw inspiration from it. It leverages trait objects, though
> it's unclear that that can be generic. Personally I've never really
> been a fan of generic SQL APIs. Unless they leverage intense amounts
> of magic (Entity Framework, SQLAlchemy), I find they end up being
> crippled (luasql) or fairly uses (python's dbapi).
> 
> Maybe that's just me.
> 
> On Wed, Dec 11, 2013 at 9:24 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I'll be glad volunteering for this task, however I'm new in rust so I may
> > need to have some mentoring for this...
> >
> > I would be inspired by the python interface:
> > https://pypi.python.org/pypi/MySQL-python/1.2.4
> >
> > -----
> > Gaetan
> >
> >
> >
> > 2013/12/11 John Mija <jon.mb at proinbox.com>
> >>
> >> Before of release 1.0, it would be very good if it's added to the package
> >> standard a generic interface to be implemented by the packages of SQL
> >> drivers.
> >>
> >> As example, see packages "database/sql" and "database/sql/driver" in the
> >> Go's library:
> >>
> >> http://golang.org/pkg/database/
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/863360af/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/863360af/attachment-0001.p7s>

From gaetan at xeberon.net  Wed Dec 11 11:01:38 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 11 Dec 2013 20:01:38 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <DCBB52BD-5080-4B41-A01D-A201D6CCA418@sb.org>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
	<CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>
	<CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>
	<CANb7cF578BGTjwjpM47crBHZJ=PQO7dUxHR+Cyr0Gg8vXQfLGQ@mail.gmail.com>
	<DCBB52BD-5080-4B41-A01D-A201D6CCA418@sb.org>
Message-ID: <CANK7tAEta032POevzeSKHrSmoW+PNy2h9nHcp1jJVrjGrrvfPQ@mail.gmail.com>

most of the time:
- either you rely on full abstraction of the db in your library (sql
alchemy), ie, the library gives you a complete abstraction of the
views/tables/ etc of the sql database.
- either you just use the SQL statements with minor data type binding
(dbapi).

i ve used both, especially for python. The first kind is really complete,
can handle database migration,.. but is really heavy and does not fit for
all use (not be able to use it for 1/2 sql databases out in the wild).
While the second one you can potentially interrogate any SQL databases, but
maintenance can quickly becomes a nightmare.

i am not really confortable having something too complex, because many
times, developers will want to write their own abstraction of their
database (every database is different). The way rust-postgre project does
seem the good one for me.

However, I don t think having a sql driver is a requirement for 1.0, but
maybe to set a "standard" or reference project/library and avoid
fragmentation...

-----
Gaetan



2013/12/11 Kevin Ballard <kevin at sb.org>

> My belief is that a generic interface to DBs is only useful because that
> way you can write other DB-driven libraries that don't care about the
> details of the DB. I don't think I've ever seen code in the wild that uses
> this functionality though (although, admittedly, I haven't looked at a lot
> of code that uses databases in general).
>
> -Kevin
>
> On Dec 11, 2013, at 9:10 AM, Steven Fackler <sfackler at gmail.com> wrote:
>
> The interface can be made generic, but it'd require HKT and potentially
> some more work on removing spurious conflicting trait implementation
> warnings. It only uses trait objects for query parameters where you
> actually need an array of distinct types implementing an interface. I've
> also found that generic SQL interfaces are less than useful in the "I can
> instantly swap from Postgres to SQLite with a config file toggle" sense
> simply because their implementations of SQL (SERIAL vs AUTOINCREMENT, etc)
> differ too much for it to work without a ton of pain. If anything, a
> generic API would be nice just to push the APIs of different SQL client
> libraries closer together.
>
> Someone could absolutely take the interface used by rust-postgres and make
> a MySQL/MariaDB driver with it, but that person wouldn't be me :)
>
> Steven Fackler
>
>
> On Wed, Dec 11, 2013 at 7:15 AM, Gaetan <gaetan at xeberon.net> wrote:
>
>> I agree python dbapi is pretty simple to use due to the dynamic nature of
>> types in python.
>>
>> I like this rust postgre binding, I can't see why it cannot be extended
>> to support mysql?
>>
>> Actually, my main reference is sqlalchemy but it's a step much higher in
>> term of abstraction of the DB.
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/12/11 Corey Richardson <corey at octayn.net>
>>
>>> Python has the advantage of dynamic typing, and Go runtime type
>>> assertions and variadics. Their interfaces probably aren't /too/ good
>>> for inspiration, especially Python's.
>>>
>>> See rust-postgres (https://github.com/sfackler/rust-postgres) for an
>>> existing DB binding. I think it's fairly idiomatic and any DB API
>>> should draw inspiration from it. It leverages trait objects, though
>>> it's unclear that that can be generic. Personally I've never really
>>> been a fan of generic SQL APIs. Unless they leverage intense amounts
>>> of magic (Entity Framework, SQLAlchemy), I find they end up being
>>> crippled (luasql) or fairly uses (python's dbapi).
>>>
>>> Maybe that's just me.
>>>
>>> On Wed, Dec 11, 2013 at 9:24 AM, Gaetan <gaetan at xeberon.net> wrote:
>>> > I'll be glad volunteering for this task, however I'm new in rust so I
>>> may
>>> > need to have some mentoring for this...
>>> >
>>> > I would be inspired by the python interface:
>>> > https://pypi.python.org/pypi/MySQL-python/1.2.4
>>> >
>>> > -----
>>> > Gaetan
>>> >
>>> >
>>> >
>>> > 2013/12/11 John Mija <jon.mb at proinbox.com>
>>> >>
>>> >> Before of release 1.0, it would be very good if it's added to the
>>> package
>>> >> standard a generic interface to be implemented by the packages of SQL
>>> >> drivers.
>>> >>
>>> >> As example, see packages "database/sql" and "database/sql/driver" in
>>> the
>>> >> Go's library:
>>> >>
>>> >> http://golang.org/pkg/database/
>>> >> _______________________________________________
>>> >> Rust-dev mailing list
>>> >> Rust-dev at mozilla.org
>>> >> https://mail.mozilla.org/listinfo/rust-dev
>>> >
>>> >
>>> >
>>> > _______________________________________________
>>> > Rust-dev mailing list
>>> > Rust-dev at mozilla.org
>>> > https://mail.mozilla.org/listinfo/rust-dev
>>> >
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/55bfbb8d/attachment.html>

From denis.spir at gmail.com  Wed Dec 11 12:15:58 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 11 Dec 2013 21:15:58 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>
Message-ID: <52A8C7FE.6080501@gmail.com>

On 12/11/2013 03:24 PM, Gaetan wrote:
> I would be inspired by the python interface:

Yes, on this point python just does "the right thing".

Denis

From denis.spir at gmail.com  Wed Dec 11 12:23:51 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 11 Dec 2013 21:23:51 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <DCBB52BD-5080-4B41-A01D-A201D6CCA418@sb.org>
References: <52A8461A.2000903@proinbox.com>	<CANK7tAHjv=EhewwpTw3pgzdxQDfBsNCd6_Nbxejnu7Fk-7BvPw@mail.gmail.com>	<CA++BO6SvgVUWnYQfFnSA1PztnYigZs0NtzPho19S9qyCO-WMZw@mail.gmail.com>	<CANK7tAFrPsPoPrbuFcEFA4okM4c+h6gY5BmiqB=eD5NxeFZVig@mail.gmail.com>	<CANb7cF578BGTjwjpM47crBHZJ=PQO7dUxHR+Cyr0Gg8vXQfLGQ@mail.gmail.com>
	<DCBB52BD-5080-4B41-A01D-A201D6CCA418@sb.org>
Message-ID: <52A8C9D7.1030203@gmail.com>

On 12/11/2013 07:14 PM, Kevin Ballard wrote:
> My belief is that a generic interface to DBs is only useful because that way you can write other DB-driven libraries that don't care about the details of the DB. I don't think I've ever seen code in the wild that uses this functionality though (although, admittedly, I haven't looked at a lot of code that uses databases in general).
>
> -Kevin

Agreed, but on the other hand (at least partially) abstracting 
DB-framework-specific details is like abstracting OS-specific or 
filesystem-specific details: it helps anyway. (Eg, I hate to be forced to deal 
with SQL idiosyncracies, I wish I would not be forced to learn this language's 
design failures).

Denis

From denis.spir at gmail.com  Wed Dec 11 12:27:36 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 11 Dec 2013 21:27:36 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A89B31.2080706@mozilla.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
Message-ID: <52A8CAB8.1020701@gmail.com>

On 12/11/2013 06:04 PM, Patrick Walton wrote:
> We aren't likely to block 1.0 on this. Instead of stabilizing all libraries once
> and for all in 1.0 like Go did, we're taking a gradual approach to libraries
> similar to that of node.js, in which 1.0 will have some library modules stable
> and some modules unstable, and releases 1.1, 1.2, and beyond will stabilize more
> and more libraries as time goes on.

A good thing, I guess, especially in that the latest trend in Rust seems to be 
moving primitives into the library.

Denis

From carter.schonwald at gmail.com  Wed Dec 11 14:57:21 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Wed, 11 Dec 2013 17:57:21 -0500
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <52A8CAB8.1020701@gmail.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
	<52A8CAB8.1020701@gmail.com>
Message-ID: <CAHYVw0yM2zzz3E=y+9v4wtaTF=ptK-RgVPuwn=2AwZ7BmXPt2A@mail.gmail.com>

as another point in the design space, a pretty idiom for SQL style dbs in
haskell is the *-simple family of libs

postgres simple
http://hackage.haskell.org/package/postgresql-simple-0.3.7.0/docs/Database-PostgreSQL-Simple.html

mysql-simple
http://hackage.haskell.org/package/mysql-simple-0.2.2.4/docs/Database-MySQL-Simple.html
and

sqlite-simple
https://hackage.haskell.org/package/sqlite-simple-0.4.4.0/docs/Database-SQLite-Simple.html

the common pattern is a nice way to write query strings and argument/result
tuples in a type safe way, and are only really related in being a nice
pattern for sql db interaction.

note that by type safe, i mean injection safe! I think similar could be
adapted to rust, perhaps with a wee bit of help using macros (which maybe
aren't needed once higher kinded types/ traits) are around?

On Wed, Dec 11, 2013 at 3:27 PM, spir <denis.spir at gmail.com> wrote:

> On 12/11/2013 06:04 PM, Patrick Walton wrote:
>
>> We aren't likely to block 1.0 on this. Instead of stabilizing all
>> libraries once
>> and for all in 1.0 like Go did, we're taking a gradual approach to
>> libraries
>> similar to that of node.js, in which 1.0 will have some library modules
>> stable
>> and some modules unstable, and releases 1.1, 1.2, and beyond will
>> stabilize more
>> and more libraries as time goes on.
>>
>
> A good thing, I guess, especially in that the latest trend in Rust seems
> to be moving primitives into the library.
>
> Denis
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/917d73bf/attachment.html>

From piotr.kukielka at gmail.com  Wed Dec 11 15:15:38 2013
From: piotr.kukielka at gmail.com (=?ISO-8859-2?Q?Piotr_Kukie=B3ka?=)
Date: Thu, 12 Dec 2013 00:15:38 +0100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CAHYVw0yM2zzz3E=y+9v4wtaTF=ptK-RgVPuwn=2AwZ7BmXPt2A@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com> <52A89B31.2080706@mozilla.com>
	<52A8CAB8.1020701@gmail.com>
	<CAHYVw0yM2zzz3E=y+9v4wtaTF=ptK-RgVPuwn=2AwZ7BmXPt2A@mail.gmail.com>
Message-ID: <CANtrdzo0zjxunj02k-KxdM_anHy3hmJ6+OXWJ34vi3CZfchEdA@mail.gmail.com>

If at some point of time something like haskell do notation or scala for
comprehension will be implemented in rust then it would be worth to look at
slick:
http://slick.typesafe.com/

Example from slick home page:

//--------------------------------------------------------
@table("COFFEES") case class Coffee(
  @column("COF_NAME")  name:  String,
  @column("SUP_ID") supID: Int,
  @column("PRICE") price: Double
)

val coffees = Queryable[Coffee]

val l = for {
  c <- coffees if c.supID == 101
} yield (c.name, c.price)

backend.result( l, session ).foreach { case (n, p) => println(n + ": " + p)
}
//--------------------------------------------------------

This approach quarantines real type safety (both in terms of dependency
injection and sql correctness)
and still give developers reasonable amount of space to tune details (code
is directly mapped to sql query, no ORM magic).


2013/12/11 Carter Schonwald <carter.schonwald at gmail.com>

> as another point in the design space, a pretty idiom for SQL style dbs in
> haskell is the *-simple family of libs
>
> postgres simple
>
> http://hackage.haskell.org/package/postgresql-simple-0.3.7.0/docs/Database-PostgreSQL-Simple.html
>
> mysql-simple
>
> http://hackage.haskell.org/package/mysql-simple-0.2.2.4/docs/Database-MySQL-Simple.html
> and
>
> sqlite-simple
>
> https://hackage.haskell.org/package/sqlite-simple-0.4.4.0/docs/Database-SQLite-Simple.html
>
> the common pattern is a nice way to write query strings and
> argument/result tuples in a type safe way, and are only really related in
> being a nice pattern for sql db interaction.
>
> note that by type safe, i mean injection safe! I think similar could be
> adapted to rust, perhaps with a wee bit of help using macros (which maybe
> aren't needed once higher kinded types/ traits) are around?
>
> On Wed, Dec 11, 2013 at 3:27 PM, spir <denis.spir at gmail.com> wrote:
>
>> On 12/11/2013 06:04 PM, Patrick Walton wrote:
>>
>>> We aren't likely to block 1.0 on this. Instead of stabilizing all
>>> libraries once
>>> and for all in 1.0 like Go did, we're taking a gradual approach to
>>> libraries
>>> similar to that of node.js, in which 1.0 will have some library modules
>>> stable
>>> and some modules unstable, and releases 1.1, 1.2, and beyond will
>>> stabilize more
>>> and more libraries as time goes on.
>>>
>>
>> A good thing, I guess, especially in that the latest trend in Rust seems
>> to be moving primitives into the library.
>>
>> Denis
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131212/531e2430/attachment.html>

From dbau.pp at gmail.com  Wed Dec 11 15:31:47 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 12 Dec 2013 10:31:47 +1100
Subject: [rust-dev] Interface around SQL databases
In-Reply-To: <CAHYVw0yM2zzz3E=y+9v4wtaTF=ptK-RgVPuwn=2AwZ7BmXPt2A@mail.gmail.com>
References: <52A8461A.2000903@proinbox.com>
	<52A89B31.2080706@mozilla.com>	<52A8CAB8.1020701@gmail.com>
	<CAHYVw0yM2zzz3E=y+9v4wtaTF=ptK-RgVPuwn=2AwZ7BmXPt2A@mail.gmail.com>
Message-ID: <52A8F5E3.5020601@gmail.com>

On 12/12/13 09:57, Carter Schonwald wrote:
> as another point in the design space, a pretty idiom for SQL style dbs 
> in haskell is the *-simple family of libs
>
> postgres simple
> http://hackage.haskell.org/package/postgresql-simple-0.3.7.0/docs/Database-PostgreSQL-Simple.html
>
> mysql-simple
> http://hackage.haskell.org/package/mysql-simple-0.2.2.4/docs/Database-MySQL-Simple.html
> and
>
> sqlite-simple
> https://hackage.haskell.org/package/sqlite-simple-0.4.4.0/docs/Database-SQLite-Simple.html
>
> the common pattern is a nice way to write query strings and 
> argument/result tuples in a type safe way, and are only really related 
> in being a nice pattern for sql db interaction.
>
> note that by type safe, i mean injection safe! I think similar could 
> be adapted to rust, perhaps with a wee bit of help using macros (which 
> maybe aren't needed once higher kinded types/ traits) are around?

FWIW, I believe SQL tokenises, so a macro like

    let x = 10;
    let y = "foo";

    // injection-safe substitution.
    let query = sql!(SELECT relevant_column FROM table WHERE 
search_column = $y LIMIT $x);

    let result = db_driver.execute(&query);

might be possible (if anyone is interested in a raw SQL interface). Of 
course, it is extremely unlikely to be possible as a structural macro 
(i.e. macro_rules), it probably requires a full blown procedural one 
(i.e. a syntax extension, which have to be hard-coded into libsyntax for 
the moment).


Huon

>
> On Wed, Dec 11, 2013 at 3:27 PM, spir <denis.spir at gmail.com 
> <mailto:denis.spir at gmail.com>> wrote:
>
>     On 12/11/2013 06:04 PM, Patrick Walton wrote:
>
>         We aren't likely to block 1.0 on this. Instead of stabilizing
>         all libraries once
>         and for all in 1.0 like Go did, we're taking a gradual
>         approach to libraries
>         similar to that of node.js, in which 1.0 will have some
>         library modules stable
>         and some modules unstable, and releases 1.1, 1.2, and beyond
>         will stabilize more
>         and more libraries as time goes on.
>
>
>     A good thing, I guess, especially in that the latest trend in Rust
>     seems to be moving primitives into the library.
>
>     Denis
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131212/6151f428/attachment-0001.html>

From zack at z0w0.me  Wed Dec 11 15:57:23 2013
From: zack at z0w0.me (Zack Corr)
Date: Thu, 12 Dec 2013 09:57:23 +1000
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
	<CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
Message-ID: <CAJjz6c2c8_Qzcv1UHm2z+=o1-d9_PjdrkALQc0eMJPdbUBQGgg@mail.gmail.com>

Yes, but Rust doesn't have HKT. I was suggesting it on this basis. I'd
prefer `do` as well.


On Wed, Dec 11, 2013 at 5:25 PM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Tue, Dec 10, 2013 at 9:04 PM, Zack Corr <zack at z0w0.me> wrote:
>
>> I think the Monadic null operator (a.k.a. safe property access operator)
>> would be pretty useful syntax sugar for mapping over option types, and
>> certainly help with the whole "option vs fail" for error checking because
>> it essentially allows monad-like functionality without actually having
>> (first-class) monads.
>>
>
>
> I still think that having something like Haskell's `do`, or Scala's `for`
> is a better way to go about this. Especially that it generalizes over more
> than just `Option<T>`.
>
> --
> Ziad
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131212/94a20aa5/attachment.html>

From zack at z0w0.me  Wed Dec 11 18:30:31 2013
From: zack at z0w0.me (Zack Corr)
Date: Thu, 12 Dec 2013 12:30:31 +1000
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <BE45A91D-957D-4A3E-AD13-202D1171F5AE@yahoo.com.au>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
	<CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
	<CAJjz6c2c8_Qzcv1UHm2z+=o1-d9_PjdrkALQc0eMJPdbUBQGgg@mail.gmail.com>
	<BE45A91D-957D-4A3E-AD13-202D1171F5AE@yahoo.com.au>
Message-ID: <CAJjz6c0e_-HQMpqW7XbuSCGpQ197j=pU1Vur0CGPiEDDvxQBGg@mail.gmail.com>

It could certainly be implemented now, if it was restrictive to builtin
monad types - like `Option`. The real question would be what sort of syntax
fits in with Rust. Would there be a new bind operator, or have `bind`
instead of `let` in `do` blocks or just reuse let and have any option types
be automatically deconstructed in the binding (yuck).

For example using the first,

fn str_larger_than_five(str: ~str) {
>   do {
>     val <- from_str("1");
>
>     return val > 5;
>   }
> }


or perhaps a bind keyword would nicer (my preference, but requires an extra
keyword):

bind val = from_str("1");

return val > 5;


Of course the current usage of `do` would need to be removed in favour of
another keyword.



On Thu, Dec 12, 2013 at 10:55 AM, Brendan Zabarauskas
<bjzaba at yahoo.com.au>wrote:

> Could `do` be implemented using sugar for now? Like, it expects such and
> such methods in order for it to work. We could put it behind a feature flag
> until we have HKT.
>
> ~Brendan
>
> On 12 Dec 2013, at 9:57 am, Zack Corr <zack at z0w0.me> wrote:
>
> > Yes, but Rust doesn't have HKT. I was suggesting it on this basis. I'd
> prefer `do` as well.
> >
> >
> > On Wed, Dec 11, 2013 at 5:25 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
> > On Tue, Dec 10, 2013 at 9:04 PM, Zack Corr <zack at z0w0.me> wrote:
> > I think the Monadic null operator (a.k.a. safe property access operator)
> would be pretty useful syntax sugar for mapping over option types, and
> certainly help with the whole "option vs fail" for error checking because
> it essentially allows monad-like functionality without actually having
> (first-class) monads.
> >
> >
> > I still think that having something like Haskell's `do`, or Scala's
> `for` is a better way to go about this. Especially that it generalizes over
> more than just `Option<T>`.
> >
> > --
> > Ziad
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131212/7b0d6975/attachment.html>

From hatahet at gmail.com  Wed Dec 11 19:02:04 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 11 Dec 2013 19:02:04 -0800
Subject: [rust-dev] List of potential C# 6.0 features
In-Reply-To: <CAJjz6c0e_-HQMpqW7XbuSCGpQ197j=pU1Vur0CGPiEDDvxQBGg@mail.gmail.com>
References: <CAN1rdExbtnpFaqKsXS_2LBz_6AvzPvsj0BJp+hLtEtgViAFg6A@mail.gmail.com>
	<52A7DC89.6040408@cantrip.org>
	<CAJjz6c2EuQk+GvXpSEg2K4k6y65QcK0d_t7dQ+n-kvMX3nt1dA@mail.gmail.com>
	<CAN1rdEz5SwM9nomaHzZ3T8af5OQJfY-n3Hbb0b-VmaV0mbqvqA@mail.gmail.com>
	<CAJjz6c2c8_Qzcv1UHm2z+=o1-d9_PjdrkALQc0eMJPdbUBQGgg@mail.gmail.com>
	<BE45A91D-957D-4A3E-AD13-202D1171F5AE@yahoo.com.au>
	<CAJjz6c0e_-HQMpqW7XbuSCGpQ197j=pU1Vur0CGPiEDDvxQBGg@mail.gmail.com>
Message-ID: <CAN1rdEwwZUadpBYhbKmY2E3eFXOnfoHGG7rpq8BZ_LinJi6u3Q@mail.gmail.com>

If `do` is going away from being used as syntactic sugar to invoke
functions with closure arguments, would it be a possibility to use it here?

--
Ziad


On Wed, Dec 11, 2013 at 6:30 PM, Zack Corr <zack at z0w0.me> wrote:

> It could certainly be implemented now, if it was restrictive to builtin
> monad types - like `Option`. The real question would be what sort of syntax
> fits in with Rust. Would there be a new bind operator, or have `bind`
> instead of `let` in `do` blocks or just reuse let and have any option types
> be automatically deconstructed in the binding (yuck).
>
> For example using the first,
>
> fn str_larger_than_five(str: ~str) {
>>   do {
>>     val <- from_str("1");
>>
>>     return val > 5;
>>   }
>> }
>
>
> or perhaps a bind keyword would nicer (my preference, but requires an
> extra keyword):
>
> bind val = from_str("1");
>
> return val > 5;
>
>
> Of course the current usage of `do` would need to be removed in favour of
> another keyword.
>
>
>
> On Thu, Dec 12, 2013 at 10:55 AM, Brendan Zabarauskas <bjzaba at yahoo.com.au
> > wrote:
>
>> Could `do` be implemented using sugar for now? Like, it expects such and
>> such methods in order for it to work. We could put it behind a feature flag
>> until we have HKT.
>>
>> ~Brendan
>>
>> On 12 Dec 2013, at 9:57 am, Zack Corr <zack at z0w0.me> wrote:
>>
>> > Yes, but Rust doesn't have HKT. I was suggesting it on this basis. I'd
>> prefer `do` as well.
>> >
>> >
>> > On Wed, Dec 11, 2013 at 5:25 PM, Ziad Hatahet <hatahet at gmail.com>
>> wrote:
>> > On Tue, Dec 10, 2013 at 9:04 PM, Zack Corr <zack at z0w0.me> wrote:
>> > I think the Monadic null operator (a.k.a. safe property access
>> operator) would be pretty useful syntax sugar for mapping over option
>> types, and certainly help with the whole "option vs fail" for error
>> checking because it essentially allows monad-like functionality without
>> actually having (first-class) monads.
>> >
>> >
>> > I still think that having something like Haskell's `do`, or Scala's
>> `for` is a better way to go about this. Especially that it generalizes over
>> more than just `Option<T>`.
>> >
>> > --
>> > Ziad
>> >
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131211/d4fe1271/attachment.html>

From ktt3ja at virginia.edu  Wed Dec 11 23:26:32 2013
From: ktt3ja at virginia.edu (Kiet Tran)
Date: Thu, 12 Dec 2013 02:26:32 -0500
Subject: [rust-dev] librustc: How do I get DefId of a trait method from an
	ExprMethodCall?
Message-ID: <CACeDKetovHzt+OWcvvRWUV8bqyBpZw+1-6UkQdaaSA8nGMn85A@mail.gmail.com>

Suppose I have an object `foo` of some type that implements the trait
`Foo { fn blah() {} }`, and I see an ExprMethodCall `foo.blah()`, how
do I get the DefId of the trait method `blah`?

The following is what I have tried so far. The particular part I'm
concerned about is the match arm for `typeck::method_param` and
`typeck::method_object`.

```
let id = match e.node {
    ast::ExprPath(..) | ast::ExprStruct(..) => {
        match cx.tcx.def_map.find(&e.id) {
            Some(&def) => ast_util::def_id_of_def(def),
            None => return
        }
    }
    ast::ExprMethodCall(..) => {
        match cx.method_map.find(&e.id) {
            Some(&typeck::method_map_entry { origin, .. }) => {
                match origin {
                    typeck::method_static(def_id) => def_id,
                    typeck::method_param(typeck::method_param {
                        trait_id: trait_id,
                        method_num: index,
                        ..
                    })
                    | typeck::method_object(typeck::method_object {
                        trait_id: trait_id,
                        method_num: index,
                        ..
                    }) => {
                        ty::trait_method(cx.tcx, trait_id, index).def_id
                    }
                }
            }
            None => return
        }
    }
    _ => return
};
```

I thought the above would work, but when I try to look up `id.node` in
the `ty::ctxt.items` map, it does not return any entry. I have also
tried replacing the line `ty::trait_method(cx.tcx, trait_id,
index).def_id` with

```
let method = ty::trait_method(cx.tcx, trait_id, index);
method.provided_source.unwrap_or(method.def_id)
```

but it doesn't work. I'm now out of idea and would like some help.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131212/e60c648f/attachment-0001.html>

From piotr.kukielka at gmail.com  Thu Dec 12 15:36:54 2013
From: piotr.kukielka at gmail.com (=?ISO-8859-2?Q?Piotr_Kukie=B3ka?=)
Date: Fri, 13 Dec 2013 00:36:54 +0100
Subject: [rust-dev] Rust crates and the module system
Message-ID: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>

Hi all,

I'm new to rust but I'm quite interested in learning it more deeply and
contributing to language itself.
However right now I'm just studying tutorial/manual/wiki to understand it
better, and sometimes I have doubts about language design.
My biggest concern so far was connected with module system.
Right now rust have 3 different (if I'm counting correctly) keywords used
for marking which library/module should be imported and used.
Why not just one? It would actually solve few problems at once.

So, this is my idea:
Drop *mod* and *extern mod *keywords and just leave *use*.
Since there would be only one keyword responsible for importing left, you
wouldn't need to care about their order.
Then, when compiler see new identifiers it checks:
1) If there is local definition of it available? If there is, then we are
done.
2) Is there matching import in scope?
    a) If yes, then is it labeled with resource path marker?
*) If yes, then check if it's:
                  +) Path to local file => it's equivalent of #[path=".."]
mod rust;
                  +) Something like "http://github.com/mozilla/rust" =>
it's equivalent of extern mod rust = "github.com/mozilla/rust";
                  +) Something like "rust:0.8" =>  it's equivalent of extern
mod my_rust(name = "rust", vers = "0.8");             *) If no, then first
check local mods, and if nothing is found then scan libs (extern mod)
    b) If no, then it's unknown symbol and we got error

What are the real benefits?

1) End user just need to remember and understand one syntax, *use, *
examples:
use farm;
use my_farm(path = "farm", vers = "2.5");
use my_farm(path = "http://github.com/farming/farm", vers = "2.5");
use my_farm(path = "../../farm/farm.rs");
2) You don't need 3 special keywords
3) Order of use doesn't matter (and there are no doubts about shadowing
order).
4) You don't need special cases use super and use self, you can use path to
replace them as well (i.e. to replace self: use some_child_module::
some_item(path = ".");)
5) You won't link unused modules even if they are imported with *use.*
6) If I'll decide to move part of my modules to separate library it can
still work without code changes
7) It would be easy to implement imports which works only in scope this way
(as it is done in scala for example)
8) this way use works more like import on jvm than include in C/C++ (and I
think C style include should be avoided)

Downsides?
I probably don't know all corner cases and maybe there are good and valid
reasons to do it as it done right now.
But unless they are really good then I think simplification of imports
should be seriously considered.

Best regards,
Piotr Kukielka
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/c297e399/attachment.html>

From com.liigo at gmail.com  Fri Dec 13 01:29:15 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Fri, 13 Dec 2013 17:29:15 +0800
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
Message-ID: <CAH8Jz7j2r7FvyvrMhrRUJQ8=T6LYrQfN01+CsuHTYtCPGn370A@mail.gmail.com>

looks like a good idea.

I always think "extern mod extra" is repetitious, because, when i "use
extra::Something", the compiler always know I'm using the mod "extra".


2013/12/13 Piotr Kukie?ka <piotr.kukielka at gmail.com>

> Hi all,
>
> I'm new to rust but I'm quite interested in learning it more deeply and
> contributing to language itself.
> However right now I'm just studying tutorial/manual/wiki to understand it
> better, and sometimes I have doubts about language design.
> My biggest concern so far was connected with module system.
> Right now rust have 3 different (if I'm counting correctly) keywords used
> for marking which library/module should be imported and used.
> Why not just one? It would actually solve few problems at once.
>
> So, this is my idea:
> Drop *mod* and *extern mod *keywords and just leave *use*.
> Since there would be only one keyword responsible for importing left, you
> wouldn't need to care about their order.
> Then, when compiler see new identifiers it checks:
> 1) If there is local definition of it available? If there is, then we are
> done.
> 2) Is there matching import in scope?
>     a) If yes, then is it labeled with resource path marker?
>  *) If yes, then check if it's:
>                   +) Path to local file => it's equivalent of #[path=".."]
> mod rust;
>                   +) Something like "http://github.com/mozilla/rust" =>
> it's equivalent of extern mod rust = "github.com/mozilla/rust";
>                   +) Something like "rust:0.8" =>  it's equivalent of
> extern mod my_rust(name = "rust", vers = "0.8");             *) If no,
> then first check local mods, and if nothing is found then scan libs (extern
> mod)
>     b) If no, then it's unknown symbol and we got error
>
> What are the real benefits?
>
> 1) End user just need to remember and understand one syntax, *use, *
> examples:
> use farm;
> use my_farm(path = "farm", vers = "2.5");
> use my_farm(path = "http://github.com/farming/farm", vers = "2.5");
> use my_farm(path = "../../farm/farm.rs");
> 2) You don't need 3 special keywords
> 3) Order of use doesn't matter (and there are no doubts about shadowing
> order).
> 4) You don't need special cases use super and use self, you can use path
> to replace them as well (i.e. to replace self: use some_child_module::
> some_item(path = ".");)
> 5) You won't link unused modules even if they are imported with *use.*
> 6) If I'll decide to move part of my modules to separate library it can
> still work without code changes
> 7) It would be easy to implement imports which works only in scope this
> way (as it is done in scala for example)
> 8) this way use works more like import on jvm than include in C/C++ (and
> I think C style include should be avoided)
>
> Downsides?
> I probably don't know all corner cases and maybe there are good and valid
> reasons to do it as it done right now.
> But unless they are really good then I think simplification of imports
> should be seriously considered.
>
> Best regards,
> Piotr Kukielka
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/d568bf3d/attachment-0001.html>

From dbau.pp at gmail.com  Fri Dec 13 01:32:15 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 13 Dec 2013 20:32:15 +1100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7j2r7FvyvrMhrRUJQ8=T6LYrQfN01+CsuHTYtCPGn370A@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<CAH8Jz7j2r7FvyvrMhrRUJQ8=T6LYrQfN01+CsuHTYtCPGn370A@mail.gmail.com>
Message-ID: <52AAD41F.9030407@gmail.com>

On 13/12/13 20:29, Liigo Zhuang wrote:
> looks like a good idea.
>
> I always think "extern mod extra" is repetitious, because, when i "use 
> extra::Something", the compiler always know I'm using the mod "extra".
>

You only need one `extern mod extra` per program which is hardly 
repetitive, and, what if you have a submodule called `extra`, how can 
the compiler tell that you want to be importing from it, rather than the 
extra crate?

(In general, one has to explicitly import external crates, because they 
can be named anything.)



Huon

>
> 2013/12/13 Piotr Kukie?ka <piotr.kukielka at gmail.com 
> <mailto:piotr.kukielka at gmail.com>>
>
>     Hi all,
>
>     I'm new to rust but I'm quite interested in learning it more
>     deeply and contributing to language itself.
>     However right now I'm just studying tutorial/manual/wiki to
>     understand it better, and sometimes I have doubts about language
>     design.
>     My biggest concern so far was connected with module system.
>     Right now rust have 3 different (if I'm counting correctly)
>     keywords used for marking which library/module should be imported
>     and used.
>     Why not just one? It would actually solve few problems at once.
>
>     So, this is my idea:
>     Drop *mod* and *extern mod *keywords and just leave *use*.
>     Since there would be only one keyword responsible for importing
>     left, you wouldn't need to care about their order.
>     Then, when compiler see new identifiers it checks:
>     1) If there is local definition of it available? If there is, then
>     we are done.
>     2) Is there matching import in scope?
>         a) If yes, then is it labeled with resource path marker?
>     *) If yes, then check if it's:
>                       +) Path to local file => it's equivalent of
>     #[path=".."] modrust;
>                       +) Something like
>     "http://github.com/mozilla/rust" => it's equivalent of
>     externmodrust= "github.com/mozilla/rust
>     <http://github.com/mozilla/rust>";
>                       +) Something like "rust:0.8" =>  it's equivalent
>     of externmodmy_rust(name= "rust", vers= "0.8");            *) If
>     no, then first check local mods, and if nothing is found then scan
>     libs (extern mod)
>         b) If no, then it's unknown symbol and we got error
>
>     What are the real benefits?
>
>     1) End user just need to remember and understand one syntax, *use,
>     *examples:
>     usefarm;
>     usemy_farm(path= "farm", vers= "2.5");
>     usemy_farm(path= "http://github.com/farming/farm", vers= "2.5");
>     usemy_farm(path= "../../farm/farm.rs <http://farm.rs>");
>     2) You don't need 3 special keywords
>     3) Order of use doesn't matter (and there are no doubts about
>     shadowing order).
>     4) You don't need special cases usesuper anduse self,you can use
>     path to replace them as well (i.e. to replace self:
>     usesome_child_module::some_item(path= ".");)
>     5) You won't link unused modules even if they are imported with *use.*
>     6) If I'll decide to move part of my modules to separate library
>     it can still work without code changes
>     7) It would be easy to implement imports which works only in scope
>     this way (as it is done in scala for example)
>     8) this way use works more like import on jvm than include in
>     C/C++ (and I think C style include should be avoided)
>
>     Downsides?
>     I probably don't know all corner cases and maybe there are good
>     and valid reasons to do it as it done right now.
>     But unless they are really good then I think simplification of
>     imports should be seriously considered.
>
>     Best regards,
>     Piotr Kukielka
>
>     *
>     *
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> -- 
> by *Liigo*, http://blog.csdn.net/liigo/
> Google+ https://plus.google.com/105597640837742873343/
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/1503ce50/attachment-0001.html>

From piotr.kukielka at gmail.com  Fri Dec 13 02:13:29 2013
From: piotr.kukielka at gmail.com (=?ISO-8859-2?Q?Piotr_Kukie=B3ka?=)
Date: Fri, 13 Dec 2013 11:13:29 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAD41F.9030407@gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<CAH8Jz7j2r7FvyvrMhrRUJQ8=T6LYrQfN01+CsuHTYtCPGn370A@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
Message-ID: <CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>

If you have a submodule called `extra`, how can the compiler tell that you
want to be importing from it?
I think I covered this in my description:
If there is matching import in scope and it isn't labeled with resource
path marker then first check local mods, and if nothing is found then scan
libs (extern mod).

But I starts to see one downside of what I proposed.
If you need to specify path to some external module then probably you don't
want to repeat this in every place you want to import it, it would look
weird.
On the other hand you still could use only one keyword (like *use*) with
the requirement that in at least one place its defined with full path (if
needed).
Even if one decide that it's better to keep *use *and *mod *distinct then I
still don't see any benefits of having separate *mod *and *extern mod.*
Probably both of them should be replace with single keyword like *crate*.

2013/12/13 Huon Wilson <dbau.pp at gmail.com>

>  On 13/12/13 20:29, Liigo Zhuang wrote:
>
> looks like a good idea.
>
>  I always think "extern mod extra" is repetitious, because, when i "use
> extra::Something", the compiler always know I'm using the mod "extra".
>
>
> You only need one `extern mod extra` per program which is hardly
> repetitive, and, what if you have a submodule called `extra`, how can the
> compiler tell that you want to be importing from it, rather than the extra
> crate?
>
> (In general, one has to explicitly import external crates, because they
> can be named anything.)
>
>
>
> Huon
>
>
>
> 2013/12/13 Piotr Kukie?ka <piotr.kukielka at gmail.com>
>
>>  Hi all,
>>
>>  I'm new to rust but I'm quite interested in learning it more deeply and
>> contributing to language itself.
>> However right now I'm just studying tutorial/manual/wiki to understand it
>> better, and sometimes I have doubts about language design.
>> My biggest concern so far was connected with module system.
>> Right now rust have 3 different (if I'm counting correctly) keywords used
>> for marking which library/module should be imported and used.
>>  Why not just one? It would actually solve few problems at once.
>>
>>  So, this is my idea:
>> Drop *mod* and *extern mod *keywords and just leave *use*.
>> Since there would be only one keyword responsible for importing left, you
>> wouldn't need to care about their order.
>> Then, when compiler see new identifiers it checks:
>> 1) If there is local definition of it available? If there is, then we are
>> done.
>> 2) Is there matching import in scope?
>>     a) If yes, then is it labeled with resource path marker?
>>  *) If yes, then check if it's:
>>                   +) Path to local file => it's equivalent of #[path=".."]
>> mod rust;
>>                   +) Something like "http://github.com/mozilla/rust" =>
>> it's equivalent of extern mod rust = "github.com/mozilla/rust";
>>                   +) Something like "rust:0.8" =>  it's equivalent of
>> extern mod my_rust(name = "rust", vers = "0.8");             *) If no,
>> then first check local mods, and if nothing is found then scan libs (extern
>> mod)
>>     b) If no, then it's unknown symbol and we got error
>>
>>  What are the real benefits?
>>
>>  1) End user just need to remember and understand one syntax, *use, *
>> examples:
>> use farm;
>> use my_farm(path = "farm", vers = "2.5");
>> use my_farm(path = "http://github.com/farming/farm", vers = "2.5");
>> use my_farm(path = "../../farm/farm.rs");
>> 2) You don't need 3 special keywords
>> 3) Order of use doesn't matter (and there are no doubts about shadowing
>> order).
>> 4) You don't need special cases use super and use self, you can use path
>> to replace them as well (i.e. to replace self: use some_child_module::
>> some_item(path = ".");)
>> 5) You won't link unused modules even if they are imported with *use.*
>> 6) If I'll decide to move part of my modules to separate library it can
>> still work without code changes
>> 7) It would be easy to implement imports which works only in scope this
>> way (as it is done in scala for example)
>> 8) this way use works more like import on jvm than include in C/C++ (and
>> I think C style include should be avoided)
>>
>>  Downsides?
>> I probably don't know all corner cases and maybe there are good and valid
>> reasons to do it as it done right now.
>> But unless they are really good then I think simplification of imports
>> should be seriously considered.
>>
>>  Best regards,
>> Piotr Kukielka
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
>  --
> by *Liigo*, http://blog.csdn.net/liigo/
>  Google+  https://plus.google.com/105597640837742873343/
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/593efcc7/attachment.html>

From lists at dhardy.name  Fri Dec 13 02:43:36 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Fri, 13 Dec 2013 11:43:36 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
Message-ID: <1520654.c5FlcGdRxj@tph-l10036>

Three jobs, three key "words":

1) creating structure: `mod foo { ... }` is used to organise code into modules

2) external references: `extern mod foo` "imports" foo, but without any name 
binding (e.g. Java and Python's import statements also bind names)

3) creating aliases/binding names: `use a::b::c`

What would you do?

Have no structure (no mod)? Or automatically create it from the file structure?

Automatically make any libraries found by the compiler available for import?


On Friday 13 December 2013 11:13:29 Piotr Kukie?ka wrote:
> If you have a submodule called `extra`, how can the compiler tell that you
> want to be importing from it?
> I think I covered this in my description:
> If there is matching import in scope and it isn't labeled with resource
> path marker then first check local mods, and if nothing is found then scan
> libs (extern mod).
> 
> But I starts to see one downside of what I proposed.
> If you need to specify path to some external module then probably you don't
> want to repeat this in every place you want to import it, it would look
> weird.
> On the other hand you still could use only one keyword (like *use*) with
> the requirement that in at least one place its defined with full path (if
> needed).
> Even if one decide that it's better to keep *use *and *mod *distinct then I
> still don't see any benefits of having separate *mod *and *extern mod.*
> Probably both of them should be replace with single keyword like *crate*.
> 
> 2013/12/13 Huon Wilson <dbau.pp at gmail.com>
> 
> >  On 13/12/13 20:29, Liigo Zhuang wrote:
> > looks like a good idea.
> > 
> >  I always think "extern mod extra" is repetitious, because, when i "use
> > 
> > extra::Something", the compiler always know I'm using the mod "extra".
> > 
> > 
> > You only need one `extern mod extra` per program which is hardly
> > repetitive, and, what if you have a submodule called `extra`, how can the
> > compiler tell that you want to be importing from it, rather than the extra
> > crate?
> > 
> > (In general, one has to explicitly import external crates, because they
> > can be named anything.)
> > 
> > 
> > 
> > Huon
> > 
> > 
> > 
> > 2013/12/13 Piotr Kukie?ka <piotr.kukielka at gmail.com>
> > 
> >>  Hi all,
> >>  
> >>  I'm new to rust but I'm quite interested in learning it more deeply and
> >> 
> >> contributing to language itself.
> >> However right now I'm just studying tutorial/manual/wiki to understand it
> >> better, and sometimes I have doubts about language design.
> >> My biggest concern so far was connected with module system.
> >> Right now rust have 3 different (if I'm counting correctly) keywords used
> >> for marking which library/module should be imported and used.
> >> 
> >>  Why not just one? It would actually solve few problems at once.
> >> 
> >>  So, this is my idea:
> >> Drop *mod* and *extern mod *keywords and just leave *use*.
> >> Since there would be only one keyword responsible for importing left, you
> >> wouldn't need to care about their order.
> >> Then, when compiler see new identifiers it checks:
> >> 1) If there is local definition of it available? If there is, then we are
> >> done.
> >> 2) Is there matching import in scope?
> >> 
> >>     a) If yes, then is it labeled with resource path marker?
> >>  
> >>  *) If yes, then check if it's:
> >>                   +) Path to local file => it's equivalent of
> >>                   #[path=".."]
> >> 
> >> mod rust;
> >> 
> >>                   +) Something like "http://github.com/mozilla/rust" =>
> >> 
> >> it's equivalent of extern mod rust = "github.com/mozilla/rust";
> >> 
> >>                   +) Something like "rust:0.8" =>  it's equivalent of
> >> 
> >> extern mod my_rust(name = "rust", vers = "0.8");             *) If no,
> >> then first check local mods, and if nothing is found then scan libs
> >> (extern
> >> mod)
> >> 
> >>     b) If no, then it's unknown symbol and we got error
> >>  
> >>  What are the real benefits?
> >>  
> >>  1) End user just need to remember and understand one syntax, *use, *
> >> 
> >> examples:
> >> use farm;
> >> use my_farm(path = "farm", vers = "2.5");
> >> use my_farm(path = "http://github.com/farming/farm", vers = "2.5");
> >> use my_farm(path = "../../farm/farm.rs");
> >> 2) You don't need 3 special keywords
> >> 3) Order of use doesn't matter (and there are no doubts about shadowing
> >> order).
> >> 4) You don't need special cases use super and use self, you can use path
> >> to replace them as well (i.e. to replace self: use some_child_module::
> >> some_item(path = ".");)
> >> 5) You won't link unused modules even if they are imported with *use.*
> >> 6) If I'll decide to move part of my modules to separate library it can
> >> still work without code changes
> >> 7) It would be easy to implement imports which works only in scope this
> >> way (as it is done in scala for example)
> >> 8) this way use works more like import on jvm than include in C/C++ (and
> >> I think C style include should be avoided)
> >> 
> >>  Downsides?
> >> 
> >> I probably don't know all corner cases and maybe there are good and valid
> >> reasons to do it as it done right now.
> >> But unless they are really good then I think simplification of imports
> >> should be seriously considered.
> >> 
> >>  Best regards,
> >> 
> >> Piotr Kukielka
> >> 
> >> 
> >> 
> >> 
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >> 
> >  --
> > 
> > by *Liigo*, http://blog.csdn.net/liigo/
> > 
> >  Google+  https://plus.google.com/105597640837742873343/
> > 
> > _______________________________________________
> > Rust-dev mailing
> > listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
> > 
> > 
> > 
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/e9a73a28/attachment.sig>

From denis.spir at gmail.com  Fri Dec 13 03:53:01 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 13 Dec 2013 12:53:01 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <1520654.c5FlcGdRxj@tph-l10036>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036>
Message-ID: <52AAF51D.7080804@gmail.com>

On 12/13/2013 11:43 AM, Diggory Hardy wrote:
> What would you do?
>
> Have no structure (no mod)? Or automatically create it from the file structure?

I think this is a good possibility, make the module/crate organisation mirror 
the filesystem (or the opposite):
* 1 module = 1 file of code
* 1 package = 1 dir
This may be limiting at times, possibility one may want multi-module files and 
multi-file modules. But this forms a good, simple base (anyway, we have mini & 
maxi modules & code files, whatever the logical & physical organisations). 
Another point is that very often we have package (I mean crate ;-) sub-dirs 
which are not packages themselves. Then, as usual, we'd have a special code file 
representing a package at its top dir (the same name as the package, or a magic 
name like 'main').

Then, module sharing is code file sharing, and package management is dir 
management (trivially .zip-ed or .tar.gz-ed, and then the name "package" is here 
for something).

Denis

From pnkfelix at mozilla.com  Fri Dec 13 04:14:02 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Fri, 13 Dec 2013 13:14:02 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAF51D.7080804@gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>	<1520654.c5FlcGdRxj@tph-l10036>
	<52AAF51D.7080804@gmail.com>
Message-ID: <52AAFA0A.2070701@mozilla.com>

On 13/12/2013 12:53, spir wrote:
> I think this is a good possibility, make the module/crate organisation 
> mirror the filesystem (or the opposite):
> * 1 module = 1 file of code
> * 1 package = 1 dir
> This may be limiting at times, possibility one may want multi-module 
> files and multi-file modules. 
Yes, one may indeed want those things.  In particular, *I* want 
multi-module files.

I do not want to move towards a Java-style approach where the package 
nesting structure needs to match the file/directory nesting structure.  
Being able to declare nested modules within a file is very useful for 
flexible namespace control.

I like our current support for nesting modules in files, and breaking 
them out into separate files as one wants.

But then again, I also think that the current approach of { `extern 
mod`... `use`... `mod`... } is pretty understandable once you, well, 
understand it.  My main complaint has been about the slightly 
context-dependent interpretation of paths [1], but that's pretty minor.  
So perhaps I have the wrong point-of-view for interpreting these 
suggestions for change.

Cheers,
-Felix

[1] https://github.com/mozilla/rust/issues/10910

On 13/12/2013 12:53, spir wrote:
> On 12/13/2013 11:43 AM, Diggory Hardy wrote:
>> What would you do?
>>
>> Have no structure (no mod)? Or automatically create it from the file 
>> structure?
>
> I think this is a good possibility, make the module/crate organisation 
> mirror the filesystem (or the opposite):
> * 1 module = 1 file of code
> * 1 package = 1 dir
> This may be limiting at times, possibility one may want multi-module 
> files and multi-file modules. But this forms a good, simple base 
> (anyway, we have mini & maxi modules & code files, whatever the 
> logical & physical organisations). Another point is that very often we 
> have package (I mean crate ;-) sub-dirs which are not packages 
> themselves. Then, as usual, we'd have a special code file representing 
> a package at its top dir (the same name as the package, or a magic 
> name like 'main').
>
> Then, module sharing is code file sharing, and package management is 
> dir management (trivially .zip-ed or .tar.gz-ed, and then the name 
> "package" is here for something).
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com


From jurily at gmail.com  Fri Dec 13 05:26:56 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Fri, 13 Dec 2013 14:26:56 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAF51D.7080804@gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>	<1520654.c5FlcGdRxj@tph-l10036>
	<52AAF51D.7080804@gmail.com>
Message-ID: <52AB0B20.60502@gmail.com>

On 12/13/2013 12:53 PM, spir wrote:
> I think this is a good possibility, make the module/crate organisation
> mirror the filesystem (or the opposite):
> * 1 module = 1 file of code
> * 1 package = 1 dir
> This may be limiting at times, possibility one may want multi-module
> files and multi-file modules. But this forms a good, simple base
> (anyway, we have mini & maxi modules & code files, whatever the logical
> & physical organisations). Another point is that very often we have
> package (I mean crate ;-) sub-dirs which are not packages themselves.
> Then, as usual, we'd have a special code file representing a package at
> its top dir (the same name as the package, or a magic name like 'main').
>
> Then, module sharing is code file sharing, and package management is dir
> management (trivially .zip-ed or .tar.gz-ed, and then the name "package"
> is here for something).

Haskell does that, it's really painful. You have to create one extra 
boilerplate file per folder for public re-exports, and Haskell libraries 
share a global namespace so typically your actual code starts 3-4 
directories deep.

From gaetan at xeberon.net  Fri Dec 13 05:03:12 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 13 Dec 2013 14:03:12 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAFA0A.2070701@mozilla.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
Message-ID: <CANK7tAE8_QTBpJa5bCdmeSsNMc88-_XuXpmAYNM6Ejgz6+EjZA@mail.gmail.com>

I actually really like the way python modules are organised, it's really
helpfulfor developping, really easy for unit testing just some modules. If
it is that way by default, and allow different structure by adding some
boilderplate, that could be really interesting

-----
Gaetan



2013/12/13 Felix S. Klock II <pnkfelix at mozilla.com>

> On 13/12/2013 12:53, spir wrote:
>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules.
>>
> Yes, one may indeed want those things.  In particular, *I* want
> multi-module files.
>
> I do not want to move towards a Java-style approach where the package
> nesting structure needs to match the file/directory nesting structure.
>  Being able to declare nested modules within a file is very useful for
> flexible namespace control.
>
> I like our current support for nesting modules in files, and breaking them
> out into separate files as one wants.
>
> But then again, I also think that the current approach of { `extern
> mod`... `use`... `mod`... } is pretty understandable once you, well,
> understand it.  My main complaint has been about the slightly
> context-dependent interpretation of paths [1], but that's pretty minor.  So
> perhaps I have the wrong point-of-view for interpreting these suggestions
> for change.
>
> Cheers,
> -Felix
>
> [1] https://github.com/mozilla/rust/issues/10910
>
>
> On 13/12/2013 12:53, spir wrote:
>
>> On 12/13/2013 11:43 AM, Diggory Hardy wrote:
>>
>>> What would you do?
>>>
>>> Have no structure (no mod)? Or automatically create it from the file
>>> structure?
>>>
>>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules. But this forms a good, simple base (anyway,
>> we have mini & maxi modules & code files, whatever the logical & physical
>> organisations). Another point is that very often we have package (I mean
>> crate ;-) sub-dirs which are not packages themselves. Then, as usual, we'd
>> have a special code file representing a package at its top dir (the same
>> name as the package, or a magic name like 'main').
>>
>> Then, module sharing is code file sharing, and package management is dir
>> management (trivially .zip-ed or .tar.gz-ed, and then the name "package" is
>> here for something).
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/79a5e17e/attachment.html>

From carter.schonwald at gmail.com  Fri Dec 13 07:45:55 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 13 Dec 2013 10:45:55 -0500
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AB0B20.60502@gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AB0B20.60502@gmail.com>
Message-ID: <CAHYVw0w2WjZdT_NvynQcLfnAkUMdXv-rKmZgs1h=Px4ZUVp5bA@mail.gmail.com>

Yup. It's a known problem in the Haskell community that folks wish to
eventually move away from.

On Friday, December 13, 2013, Gy?rgy Andrasek wrote:

> On 12/13/2013 12:53 PM, spir wrote:
>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules. But this forms a good, simple base
>> (anyway, we have mini & maxi modules & code files, whatever the logical
>> & physical organisations). Another point is that very often we have
>> package (I mean crate ;-) sub-dirs which are not packages themselves.
>> Then, as usual, we'd have a special code file representing a package at
>> its top dir (the same name as the package, or a magic name like 'main').
>>
>> Then, module sharing is code file sharing, and package management is dir
>> management (trivially .zip-ed or .tar.gz-ed, and then the name "package"
>> is here for something).
>>
>
> Haskell does that, it's really painful. You have to create one extra
> boilerplate file per folder for public re-exports, and Haskell libraries
> share a global namespace so typically your actual code starts 3-4
> directories deep.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/7f5cfb70/attachment.html>

From piotr.kukielka at gmail.com  Fri Dec 13 11:57:47 2013
From: piotr.kukielka at gmail.com (=?ISO-8859-2?Q?Piotr_Kukie=B3ka?=)
Date: Fri, 13 Dec 2013 20:57:47 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAFA0A.2070701@mozilla.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
Message-ID: <CANtrdzo0NOgRSYpP3rmYNVSu3z2d9X9++WyXKLDbz78BtbT6eQ@mail.gmail.com>

I understand that one could want flexibility and matching file with package
is not always optimal.
And it's not what I wanted to suggest in first place ;)

Let's clear one confusion first. When I said that I think *mod* and *extern
mod* are redundant I thought about using them in context of importing.
I think *mod *keyword used for creating modules (in sense of namespaces) is
fine and there is nothing wrong with it.
Now, I don't see big difference between *mod *and  *extern mod, *because in
both cases intention is very similar: you want to signalize that required
modules are in external crate.
If I'll compile on of my modules into stand alone library and I'll put it
inside the project instead of module source files it should still work.
Because if it's technically possible, then why to complicate it?

I will try to clarify this with example. Current situation looks like this:

//-----------------> CUT HERE <--------------------
//------------------------- a.rs ---------------------------
mod b;

pub mod a_inner {
  pub fn a_func() { ::b::b_inner::b_func(); }
}

fn main() {
  a_inner::a_func();
}

//------------------------- b.rs ---------------------------
extern mod clib;

pub mod b_inner {
  pub fn b_func() { super::clib::c_func2() }
}

//------------------------- c.rs ---------------------------
#[crate_type = "lib"];
#[link(package_id = "clib", name = "clib", vers = "0.1")];

use c_inner::c_func;

pub mod c_inner {
  pub fn c_func() { println("c_func invocation"); }
}

pub fn c_func2() { c_func(); }

//-----------------> CUT HERE <--------------------





What I'm trying to say is it could look like that:




//-----------------> CUT HERE <--------------------
//------------------------- a.rs ---------------------------
use b::b_inner::b_func;

pub mod a_inner {
  pub fn a_func() { b_func(); }
}

fn main() {
  a_inner::a_func();
}

//------------------------- b.rs ---------------------------
use clib::clib::c_func2;

pub mod b_inner {
  pub fn b_func() { c_func2() }
}

//------------------------- c.rs ---------------------------
#[crate_type = "lib"];
#[link(package_id = "clib", name = "clib", vers = "0.1")];

use c_inner::c_func;

pub mod c_inner {
  pub fn c_func() { println("c_func invocation"); }
}

pub fn c_func2() { c_func(); }
//-----------------> CUT HERE <--------------------

So instead of using *mod*, *extern mod* and *use, *just *use *seems to be
sufficient.


BTW. Few interesting notices:

1) Inside b_func() I had to use super, otherwise clib was not visible.

2) Code like this doesn't compile:

//-----------------> CUT HERE <--------------------
//------------------------- a.rs ---------------------------
use b::b_inner::b_func;
mod b;

pub mod a_inner {
  pub fn a_func() { b_func(); }
}

fn main() {
  a_inner::a_func();
}
//-----------------> CUT HERE <--------------------

*a.rs:6:20: 6:26 error: unresolved name `b_func`.*
*a.rs:6 <http://a.rs:6>   pub fn a_func() { b_func(); }*
                           ^~~~~~
3) Someone said before that I need to use* extern mod* just once, if I
understood correctly.
I found it's not the case. If I'll try to change a.rs like that:

//-----------------> CUT HERE <--------------------
//------------------------- a.rs ---------------------------
mod b;

pub mod a_inner {
  pub fn a_func() {  super::clib::c_func2(); }
}

fn main() {
  a_inner::a_func();
}
//-----------------> CUT HERE <--------------------

It won't compile. Moving *extern mod clib; *from b.rs to a.rs makes
a.rscompiling obviously, but
b.rs broken.
This means to make it work correctly I need to add *extern mod clib; *in
both files (then it compiles and works).
This can lead to have code like extern mod rust = "github.com/mozilla/rust";
in multiple files, which I think is not manageable.
Even worse, what if someone will specify different versions of the same lib?
(Actually I checked and I see that compiler just printf note about that.
Does it mean it's correct and supported behavior?)

4) #[feature(globs)] seems to be broken. I.e. this doesn't compile:

//------------------------- a.rs ---------------------------
#[feature(globs)];
use b::*;

// (...)
//------------------------- a.rs ---------------------------

But maybe I'm just trying to use it in wrong way.
I also didn't managed to get #[path=""] working correctly, but I think it's
enough for now...

Overall my opinion on current module is that if it could be simplified then
it should be.
And don't get me wrong. I love how current system let me create and manage
libs and dependencies without complicated makefiles.
And it is conceptually really simple. So I don't talk about stripping down
any features.
I just think syntax can (?) and should follow that conceptual simplicity
and it should be a bit more consistent
(i.e. some thinks are managed by annotations and some but parameters in
round brackets, which seems to be a bit random, etc).

Sorry for long post ;)

Best regards,
Piotr Kukielka



2013/12/13 Felix S. Klock II <pnkfelix at mozilla.com>

> On 13/12/2013 12:53, spir wrote:
>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules.
>>
> Yes, one may indeed want those things.  In particular, *I* want
> multi-module files.
>
> I do not want to move towards a Java-style approach where the package
> nesting structure needs to match the file/directory nesting structure.
>  Being able to declare nested modules within a file is very useful for
> flexible namespace control.
>
> I like our current support for nesting modules in files, and breaking them
> out into separate files as one wants.
>
> But then again, I also think that the current approach of { `extern
> mod`... `use`... `mod`... } is pretty understandable once you, well,
> understand it.  My main complaint has been about the slightly
> context-dependent interpretation of paths [1], but that's pretty minor.  So
> perhaps I have the wrong point-of-view for interpreting these suggestions
> for change.
>
> Cheers,
> -Felix
>
> [1] https://github.com/mozilla/rust/issues/10910
>
>
> On 13/12/2013 12:53, spir wrote:
>
>> On 12/13/2013 11:43 AM, Diggory Hardy wrote:
>>
>>> What would you do?
>>>
>>> Have no structure (no mod)? Or automatically create it from the file
>>> structure?
>>>
>>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules. But this forms a good, simple base (anyway,
>> we have mini & maxi modules & code files, whatever the logical & physical
>> organisations). Another point is that very often we have package (I mean
>> crate ;-) sub-dirs which are not packages themselves. Then, as usual, we'd
>> have a special code file representing a package at its top dir (the same
>> name as the package, or a magic name like 'main').
>>
>> Then, module sharing is code file sharing, and package management is dir
>> management (trivially .zip-ed or .tar.gz-ed, and then the name "package" is
>> here for something).
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/fa3cc83f/attachment-0001.html>

From slabode at aim.com  Fri Dec 13 12:28:21 2013
From: slabode at aim.com (SiegeLord)
Date: Fri, 13 Dec 2013 15:28:21 -0500
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CANtrdzo0NOgRSYpP3rmYNVSu3z2d9X9++WyXKLDbz78BtbT6eQ@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CANtrdzo0NOgRSYpP3rmYNVSu3z2d9X9++WyXKLDbz78BtbT6eQ@mail.gmail.com>
Message-ID: <52AB6DE5.9050602@aim.com>

On 12/13/2013 02:57 PM, Piotr Kukie?ka wrote:
> I understand that one could want flexibility and matching file with
> package is not always optimal.
> And it's not what I wanted to suggest in first place ;)
>
> Let's clear one confusion first. When I said that I think *mod* and
> *extern mod* are redundant I thought about using them in context of
> importing.

I do not think it is correct to think of `mod foo;` as importing 
anything. Rust's module system is not based upon files: files are just a 
convenience. "mod foo;" is literally just a shortcut for `mod foo { 
<paste the contents of foo.rs or foo/mod.rs> here> }`. You could write 
every crate in Rust as a single file per crate without changing the 
semantics at all.

 > Now, I don't see big difference between mod and  extern mod, because 
in both cases intention is very similar: you want to signalize that 
required modules are in external crate.

`mod foo;` does not signify that modules are in an external crate, it 
signifies that they are in the same crate. There are some big 
differences to whether a module is in a separate crate or not. For 
example, if crate Crate1 has a trait T and a type A, Crate2 cannot 
implement trait T for type A. If T and A were in a different module of 
Crate2, then it would be able to implement T for A. This is a very 
important property of the crate system, and making it confusing by 
merging `mod` and `extern mod` is a bad idea, in my opinion.

 > This means to make it work correctly I need to add extern mod clib; 
in both files (then it compiles and works).

No, that's not the case. To make it work you can do:

~~~
//------------------------- a.rs ---------------------------
mod b;

pub mod a_inner {
   pub fn a_func() {  ::b::clib::c_func2(); }
}

fn main() {
   a_inner::a_func();
}
~~~

A similar modification will work with moving `extern mod clib` into a.rs.

The 'notices' you've written suggest to me that you don't completely 
understand how the module system works today, which is very important to 
do before suggesting changes to it (even if it's flawed you still need 
to understand it). I suggest reading the relevant portion of the 
tutorial again. All 4 'notices' you mentioned maybe become more clear then.

-SL

From piotr.kukielka at gmail.com  Fri Dec 13 13:17:02 2013
From: piotr.kukielka at gmail.com (=?ISO-8859-2?Q?Piotr_Kukie=B3ka?=)
Date: Fri, 13 Dec 2013 22:17:02 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AB6DE5.9050602@aim.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CANtrdzo0NOgRSYpP3rmYNVSu3z2d9X9++WyXKLDbz78BtbT6eQ@mail.gmail.com>
	<52AB6DE5.9050602@aim.com>
Message-ID: <CANtrdzoBvLtJ2Jjb4h-cgXt=OatDm5Picij9E-cENzrfdf6cow@mail.gmail.com>

Thanks, you are right.

So correcting myself:
1) It doesn't require super, ::b works as well. It makes sense.
2) It works if *use* is in right scope, in this case inside a_inner. I must
admit it's a bit surprising that imports are not inherited from the parent
scope.
4) #[feature(globs)] works fine, when I have *use* in proper scope

Thanks for example with trait T for type A, it makes sense.
I guess I just need some small project in rust to get better feel of the
language.

let this be a lesson in humility for me ;)


2013/12/13 SiegeLord <slabode at aim.com>

> On 12/13/2013 02:57 PM, Piotr Kukie?ka wrote:
>
>> I understand that one could want flexibility and matching file with
>> package is not always optimal.
>> And it's not what I wanted to suggest in first place ;)
>>
>> Let's clear one confusion first. When I said that I think *mod* and
>> *extern mod* are redundant I thought about using them in context of
>> importing.
>>
>
> I do not think it is correct to think of `mod foo;` as importing anything.
> Rust's module system is not based upon files: files are just a convenience.
> "mod foo;" is literally just a shortcut for `mod foo { <paste the contents
> of foo.rs or foo/mod.rs> here> }`. You could write every crate in Rust as
> a single file per crate without changing the semantics at all.
>
>
> > Now, I don't see big difference between mod and  extern mod, because in
> both cases intention is very similar: you want to signalize that required
> modules are in external crate.
>
> `mod foo;` does not signify that modules are in an external crate, it
> signifies that they are in the same crate. There are some big differences
> to whether a module is in a separate crate or not. For example, if crate
> Crate1 has a trait T and a type A, Crate2 cannot implement trait T for type
> A. If T and A were in a different module of Crate2, then it would be able
> to implement T for A. This is a very important property of the crate
> system, and making it confusing by merging `mod` and `extern mod` is a bad
> idea, in my opinion.
>
>
> > This means to make it work correctly I need to add extern mod clib; in
> both files (then it compiles and works).
>
> No, that's not the case. To make it work you can do:
>
> ~~~
>
> //------------------------- a.rs ---------------------------
> mod b;
>
> pub mod a_inner {
>   pub fn a_func() {  ::b::clib::c_func2(); }
> }
>
> fn main() {
>   a_inner::a_func();
> }
> ~~~
>
> A similar modification will work with moving `extern mod clib` into a.rs.
>
> The 'notices' you've written suggest to me that you don't completely
> understand how the module system works today, which is very important to do
> before suggesting changes to it (even if it's flawed you still need to
> understand it). I suggest reading the relevant portion of the tutorial
> again. All 4 'notices' you mentioned maybe become more clear then.
>
> -SL
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131213/a6b783d5/attachment.html>

From com.liigo at gmail.com  Fri Dec 13 16:56:30 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sat, 14 Dec 2013 08:56:30 +0800
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52AAFA0A.2070701@mozilla.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
Message-ID: <CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>

"package" and "module", we only need one. Most other language only have
one. The more, the more complicate.

libstd.so: What we call it? "library" "package" "crate"?? other language
usually call it "library".
std::io::fs: We call it "module", other language usually call it "package"
or "module".

So, whatever we call it, package and module, we only need ONE of them, and
let another gone.



2013/12/13 Felix S. Klock II <pnkfelix at mozilla.com>

> On 13/12/2013 12:53, spir wrote:
>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules.
>>
> Yes, one may indeed want those things.  In particular, *I* want
> multi-module files.
>
> I do not want to move towards a Java-style approach where the package
> nesting structure needs to match the file/directory nesting structure.
>  Being able to declare nested modules within a file is very useful for
> flexible namespace control.
>
> I like our current support for nesting modules in files, and breaking them
> out into separate files as one wants.
>
> But then again, I also think that the current approach of { `extern
> mod`... `use`... `mod`... } is pretty understandable once you, well,
> understand it.  My main complaint has been about the slightly
> context-dependent interpretation of paths [1], but that's pretty minor.  So
> perhaps I have the wrong point-of-view for interpreting these suggestions
> for change.
>
> Cheers,
> -Felix
>
> [1] https://github.com/mozilla/rust/issues/10910
>
>
> On 13/12/2013 12:53, spir wrote:
>
>> On 12/13/2013 11:43 AM, Diggory Hardy wrote:
>>
>>> What would you do?
>>>
>>> Have no structure (no mod)? Or automatically create it from the file
>>> structure?
>>>
>>
>> I think this is a good possibility, make the module/crate organisation
>> mirror the filesystem (or the opposite):
>> * 1 module = 1 file of code
>> * 1 package = 1 dir
>> This may be limiting at times, possibility one may want multi-module
>> files and multi-file modules. But this forms a good, simple base (anyway,
>> we have mini & maxi modules & code files, whatever the logical & physical
>> organisations). Another point is that very often we have package (I mean
>> crate ;-) sub-dirs which are not packages themselves. Then, as usual, we'd
>> have a special code file representing a package at its top dir (the same
>> name as the package, or a magic name like 'main').
>>
>> Then, module sharing is code file sharing, and package management is dir
>> management (trivially .zip-ed or .tar.gz-ed, and then the name "package" is
>> here for something).
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> --
> irc: pnkfelix on irc.mozilla.org
> email: {fklock, pnkfelix}@mozilla.com
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/43888f93/attachment.html>

From pcwalton at mozilla.com  Fri Dec 13 17:02:03 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 13 Dec 2013 17:02:03 -0800
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>	<1520654.c5FlcGdRxj@tph-l10036>
	<52AAF51D.7080804@gmail.com>	<52AAFA0A.2070701@mozilla.com>
	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
Message-ID: <52ABAE0B.9080609@mozilla.com>

On 12/13/13 4:56 PM, Liigo Zhuang wrote:
> "package" and "module", we only need one. Most other language only have
> one. The more, the more complicate.
>
> libstd.so: What we call it? "library" "package" "crate"?? other language
> usually call it "library".
> std::io::fs: We call it "module", other language usually call it
> "package" or "module".
>
> So, whatever we call it, package and module, we only need ONE of them,
> and let another gone.

.NET has a two-level distinction: assembly and namespace.

C++ has a three-level distinction in practice?namespace, 
library/executable, and translation unit?although C++'s is somewhat 
different.

OCaml has a two-level distinction: library and module.

D has a two-level distinction as far as I can tell: library and module.

Racket has a two-level distinction as far as I can tell: package and module.

Patrick

From com.liigo at gmail.com  Fri Dec 13 17:14:32 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sat, 14 Dec 2013 09:14:32 +0800
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <52ABAE0B.9080609@mozilla.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
	<52ABAE0B.9080609@mozilla.com>
Message-ID: <CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>

What is the distinction of package and crate in Rust?


2013/12/14 Patrick Walton <pcwalton at mozilla.com>

> On 12/13/13 4:56 PM, Liigo Zhuang wrote:
>
>> "package" and "module", we only need one. Most other language only have
>> one. The more, the more complicate.
>>
>> libstd.so: What we call it? "library" "package" "crate"?? other language
>> usually call it "library".
>> std::io::fs: We call it "module", other language usually call it
>> "package" or "module".
>>
>> So, whatever we call it, package and module, we only need ONE of them,
>> and let another gone.
>>
>
> .NET has a two-level distinction: assembly and namespace.
>
> C++ has a three-level distinction in practice?namespace,
> library/executable, and translation unit?although C++'s is somewhat
> different.
>
> OCaml has a two-level distinction: library and module.
>
> D has a two-level distinction as far as I can tell: library and module.
>
> Racket has a two-level distinction as far as I can tell: package and
> module.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/79a4b31c/attachment.html>

From corey at octayn.net  Fri Dec 13 17:26:29 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 13 Dec 2013 20:26:29 -0500
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
	<52ABAE0B.9080609@mozilla.com>
	<CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
Message-ID: <CA++BO6QeRH3MR6qpMWRg3KZFPuzTUb1iUg+m88EJ-Smpy+wo1w@mail.gmail.com>

Packages don't really exist as a concept at all. Supposedly `rustpkg`
deals with "packages" but in reality, it just deals with crates.

And they're certainly not part of the module system.

On Fri, Dec 13, 2013 at 8:14 PM, Liigo Zhuang <com.liigo at gmail.com> wrote:
> What is the distinction of package and crate in Rust?
>
>
> 2013/12/14 Patrick Walton <pcwalton at mozilla.com>
>>
>> On 12/13/13 4:56 PM, Liigo Zhuang wrote:
>>>
>>> "package" and "module", we only need one. Most other language only have
>>> one. The more, the more complicate.
>>>
>>> libstd.so: What we call it? "library" "package" "crate"?? other language
>>> usually call it "library".
>>> std::io::fs: We call it "module", other language usually call it
>>> "package" or "module".
>>>
>>> So, whatever we call it, package and module, we only need ONE of them,
>>> and let another gone.
>>
>>
>> .NET has a two-level distinction: assembly and namespace.
>>
>> C++ has a three-level distinction in practice?namespace,
>> library/executable, and translation unit?although C++'s is somewhat
>> different.
>>
>> OCaml has a two-level distinction: library and module.
>>
>> D has a two-level distinction as far as I can tell: library and module.
>>
>> Racket has a two-level distinction as far as I can tell: package and
>> module.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> --
> by Liigo, http://blog.csdn.net/liigo/
> Google+  https://plus.google.com/105597640837742873343/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From jurily at gmail.com  Fri Dec 13 18:29:02 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sat, 14 Dec 2013 03:29:02 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>	<1520654.c5FlcGdRxj@tph-l10036>
	<52AAF51D.7080804@gmail.com>	<52AAFA0A.2070701@mozilla.com>	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>	<52ABAE0B.9080609@mozilla.com>
	<CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
Message-ID: <52ABC26E.7040509@gmail.com>

On 12/14/2013 02:14 AM, Liigo Zhuang wrote:
> What is the distinction of package and crate in Rust?

Crate is the compilation unit. Package is what you say it is, the Rust 
manual does not mention that word.

From masanori.ogino at gmail.com  Fri Dec 13 18:13:39 2013
From: masanori.ogino at gmail.com (Masanori Ogino)
Date: Sat, 14 Dec 2013 11:13:39 +0900
Subject: [rust-dev] [rustpkg] Deal with libs whose name includes '-'
Message-ID: <CAA-4+jdJbf6n4_XWjn01P3_MCDHWjRPcRKut62OqFz4Sk0_uGg@mail.gmail.com>

Hello. I'm the author of msgpack-rust [1]_, a (incomplete yet) Rust
implementation of MessagePack [2]_.

I've working on rustpkg-ize the library and now rustpkg-rust can be built
with latest Rust and rustpkg. (many thanks to rustpkg developers!)

However, I got a problem. The problem is that the statement 'extern mod
msgpack-rust;' is invalid. I don't want to rename it to e.g. msgpack even
though everything in the library is under msgpack::*, because repositories
of MessagePack impl. are usually named msgpack-<langname>. (see
https://github.com/msgpack .)

Because of the problem, I can't test and use it with rustpkg. How can I
solve the problem properly?

.. [1] https://github.com/omasanori/msgpack-rust
.. [2] http://msgpack.org/

-- 
Masanori Ogino <masanori.ogino at gmail.com>
http://twitter.com/omasanori
http://gplus.to/omasanori
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/36240250/attachment.html>

From jack at metajack.im  Fri Dec 13 18:15:08 2013
From: jack at metajack.im (Jack Moffitt)
Date: Fri, 13 Dec 2013 19:15:08 -0700
Subject: [rust-dev] [rustpkg] Deal with libs whose name includes '-'
In-Reply-To: <CAA-4+jdJbf6n4_XWjn01P3_MCDHWjRPcRKut62OqFz4Sk0_uGg@mail.gmail.com>
References: <CAA-4+jdJbf6n4_XWjn01P3_MCDHWjRPcRKut62OqFz4Sk0_uGg@mail.gmail.com>
Message-ID: <CAP7VpsVc4_n5hXVp50BrGASe2CXYquXYnAn6F0ynkCK9TKiORQ@mail.gmail.com>

extern mod msgpack = "msgpack-rust";

jack.

On Fri, Dec 13, 2013 at 7:13 PM, Masanori Ogino
<masanori.ogino at gmail.com> wrote:
>
> Hello. I'm the author of msgpack-rust [1]_, a (incomplete yet) Rust
> implementation of MessagePack [2]_.
>
> I've working on rustpkg-ize the library and now rustpkg-rust can be built
> with latest Rust and rustpkg. (many thanks to rustpkg developers!)
>
> However, I got a problem. The problem is that the statement 'extern mod
> msgpack-rust;' is invalid. I don't want to rename it to e.g. msgpack even
> though everything in the library is under msgpack::*, because repositories
> of MessagePack impl. are usually named msgpack-<langname>. (see
> https://github.com/msgpack .)
>
> Because of the problem, I can't test and use it with rustpkg. How can I
> solve the problem properly?
>
> .. [1] https://github.com/omasanori/msgpack-rust
> .. [2] http://msgpack.org/
>
> --
> Masanori Ogino <masanori.ogino at gmail.com>
> http://twitter.com/omasanori
> http://gplus.to/omasanori
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From masanori.ogino at gmail.com  Fri Dec 13 18:30:19 2013
From: masanori.ogino at gmail.com (Masanori Ogino)
Date: Sat, 14 Dec 2013 11:30:19 +0900
Subject: [rust-dev] [rustpkg] Deal with libs whose name includes '-'
In-Reply-To: <CAP7VpsVc4_n5hXVp50BrGASe2CXYquXYnAn6F0ynkCK9TKiORQ@mail.gmail.com>
References: <CAA-4+jdJbf6n4_XWjn01P3_MCDHWjRPcRKut62OqFz4Sk0_uGg@mail.gmail.com>
	<CAP7VpsVc4_n5hXVp50BrGASe2CXYquXYnAn6F0ynkCK9TKiORQ@mail.gmail.com>
Message-ID: <CAA-4+jf6J6=V6Kwm423fRiqqs50cNHrrJ2hqqLU2kwkVaEX9iQ@mail.gmail.com>

Thank you very much!


2013/12/14 Jack Moffitt <jack at metajack.im>

> extern mod msgpack = "msgpack-rust";
>
> jack.
>
> On Fri, Dec 13, 2013 at 7:13 PM, Masanori Ogino
> <masanori.ogino at gmail.com> wrote:
> >
> > Hello. I'm the author of msgpack-rust [1]_, a (incomplete yet) Rust
> > implementation of MessagePack [2]_.
> >
> > I've working on rustpkg-ize the library and now rustpkg-rust can be built
> > with latest Rust and rustpkg. (many thanks to rustpkg developers!)
> >
> > However, I got a problem. The problem is that the statement 'extern mod
> > msgpack-rust;' is invalid. I don't want to rename it to e.g. msgpack even
> > though everything in the library is under msgpack::*, because
> repositories
> > of MessagePack impl. are usually named msgpack-<langname>. (see
> > https://github.com/msgpack .)
> >
> > Because of the problem, I can't test and use it with rustpkg. How can I
> > solve the problem properly?
> >
> > .. [1] https://github.com/omasanori/msgpack-rust
> > .. [2] http://msgpack.org/
> >
> > --
> > Masanori Ogino <masanori.ogino at gmail.com>
> > http://twitter.com/omasanori
> > http://gplus.to/omasanori
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>



-- 
Masanori Ogino <masanori.ogino at gmail.com>
http://twitter.com/omasanori
http://gplus.to/omasanori
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/65ebd931/attachment-0001.html>

From com.liigo at gmail.com  Fri Dec 13 20:28:03 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sat, 14 Dec 2013 12:28:03 +0800
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CA++BO6QeRH3MR6qpMWRg3KZFPuzTUb1iUg+m88EJ-Smpy+wo1w@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
	<52ABAE0B.9080609@mozilla.com>
	<CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
	<CA++BO6QeRH3MR6qpMWRg3KZFPuzTUb1iUg+m88EJ-Smpy+wo1w@mail.gmail.com>
Message-ID: <CAH8Jz7gjtTxpadKf1GiTdDvH8kqDYDS6AiK3xPFgHw5isdDtNA@mail.gmail.com>

2013/12/14 Corey Richardson <corey at octayn.net>

> Packages don't really exist as a concept at all. Supposedly `rustpkg`
> deals with "packages" but in reality, it just deals with crates.
>
> And they're certainly not part of the module system.


2013/12/14 Gy?rgy Andrasek <jurily at gmail.com>

> On 12/14/2013 02:14 AM, Liigo Zhuang wrote:
>
>> What is the distinction of package and crate in Rust?
>>
>
> Crate is the compilation unit. Package is what you say it is, the Rust
> manual does not mention that word.



There is an official tool called "rustpkg", and there is a attribute call
"pkgid", so you cann't just easily saying "there is no package" in rust. If
no package, why not using "rustcrate" and "crateid" for consistency? (I do
not think 'crate' is a good name, other languages tend to call it 'package'
or 'library'.)



> On Fri, Dec 13, 2013 at 8:14 PM, Liigo Zhuang <com.liigo at gmail.com> wrote:
> > What is the distinction of package and crate in Rust?
> >
> >
> > 2013/12/14 Patrick Walton <pcwalton at mozilla.com>
> >>
> >> On 12/13/13 4:56 PM, Liigo Zhuang wrote:
> >>>
> >>> "package" and "module", we only need one. Most other language only have
> >>> one. The more, the more complicate.
> >>>
> >>> libstd.so: What we call it? "library" "package" "crate"?? other
> language
> >>> usually call it "library".
> >>> std::io::fs: We call it "module", other language usually call it
> >>> "package" or "module".
> >>>
> >>> So, whatever we call it, package and module, we only need ONE of them,
> >>> and let another gone.
> >>
> >>
> >> .NET has a two-level distinction: assembly and namespace.
> >>
> >> C++ has a three-level distinction in practice?namespace,
> >> library/executable, and translation unit?although C++'s is somewhat
> >> different.
> >>
> >> OCaml has a two-level distinction: library and module.
> >>
> >> D has a two-level distinction as far as I can tell: library and module.
> >>
> >> Racket has a two-level distinction as far as I can tell: package and
> >> module.
> >>
> >> Patrick
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> >
> > --
> > by Liigo, http://blog.csdn.net/liigo/
> > Google+  https://plus.google.com/105597640837742873343/
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/0e0f32e6/attachment.html>

From gaetan at xeberon.net  Sat Dec 14 01:44:56 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 14 Dec 2013 10:44:56 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7gjtTxpadKf1GiTdDvH8kqDYDS6AiK3xPFgHw5isdDtNA@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>
	<52AAD41F.9030407@gmail.com>
	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>
	<1520654.c5FlcGdRxj@tph-l10036> <52AAF51D.7080804@gmail.com>
	<52AAFA0A.2070701@mozilla.com>
	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>
	<52ABAE0B.9080609@mozilla.com>
	<CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>
	<CA++BO6QeRH3MR6qpMWRg3KZFPuzTUb1iUg+m88EJ-Smpy+wo1w@mail.gmail.com>
	<CAH8Jz7gjtTxpadKf1GiTdDvH8kqDYDS6AiK3xPFgHw5isdDtNA@mail.gmail.com>
Message-ID: <CANK7tAGnFsbku36CPVhzS5b7OyE3KMJBi9Bcoffnjb76TURtoA@mail.gmail.com>

Libstuff is a library, in the system semantic (linux, same for windows). It
may contain one crate, it should be still named after what it is in the
system, but it is not properly speaking part of the rust semantic.

However alone it is almost useless, you need extra data to.locate, index,
install, uninstall it,... and that what a package should be.

Rust as two level: crates and package. Even if a concurrent packaging
system "rustbetterpkg" can appear and do the same job differently without
changing the rust language.
Le 14 d?c. 2013 05:28, "Liigo Zhuang" <com.liigo at gmail.com> a ?crit :

> 2013/12/14 Corey Richardson <corey at octayn.net>
>
>> Packages don't really exist as a concept at all. Supposedly `rustpkg`
>> deals with "packages" but in reality, it just deals with crates.
>>
>> And they're certainly not part of the module system.
>
>
> 2013/12/14 Gy?rgy Andrasek <jurily at gmail.com>
>
>> On 12/14/2013 02:14 AM, Liigo Zhuang wrote:
>>
>>> What is the distinction of package and crate in Rust?
>>>
>>
>> Crate is the compilation unit. Package is what you say it is, the Rust
>> manual does not mention that word.
>
>
>
> There is an official tool called "rustpkg", and there is a attribute call
> "pkgid", so you cann't just easily saying "there is no package" in rust. If
> no package, why not using "rustcrate" and "crateid" for consistency? (I do
> not think 'crate' is a good name, other languages tend to call it 'package'
> or 'library'.)
>
>
>
>> On Fri, Dec 13, 2013 at 8:14 PM, Liigo Zhuang <com.liigo at gmail.com>
>> wrote:
>> > What is the distinction of package and crate in Rust?
>> >
>> >
>> > 2013/12/14 Patrick Walton <pcwalton at mozilla.com>
>> >>
>> >> On 12/13/13 4:56 PM, Liigo Zhuang wrote:
>> >>>
>> >>> "package" and "module", we only need one. Most other language only
>> have
>> >>> one. The more, the more complicate.
>> >>>
>> >>> libstd.so: What we call it? "library" "package" "crate"?? other
>> language
>> >>> usually call it "library".
>> >>> std::io::fs: We call it "module", other language usually call it
>> >>> "package" or "module".
>> >>>
>> >>> So, whatever we call it, package and module, we only need ONE of them,
>> >>> and let another gone.
>> >>
>> >>
>> >> .NET has a two-level distinction: assembly and namespace.
>> >>
>> >> C++ has a three-level distinction in practice?namespace,
>> >> library/executable, and translation unit?although C++'s is somewhat
>> >> different.
>> >>
>> >> OCaml has a two-level distinction: library and module.
>> >>
>> >> D has a two-level distinction as far as I can tell: library and module.
>> >>
>> >> Racket has a two-level distinction as far as I can tell: package and
>> >> module.
>> >>
>> >> Patrick
>> >>
>> >> _______________________________________________
>> >> Rust-dev mailing list
>> >> Rust-dev at mozilla.org
>> >> https://mail.mozilla.org/listinfo/rust-dev
>> >
>> >
>> >
>> >
>> > --
>> > by Liigo, http://blog.csdn.net/liigo/
>> > Google+  https://plus.google.com/105597640837742873343/
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>
>
>
> --
> by *Liigo*, http://blog.csdn.net/liigo/
> Google+  https://plus.google.com/105597640837742873343/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131214/7099663e/attachment.html>

From denis.spir at gmail.com  Sat Dec 14 05:36:09 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 14 Dec 2013 14:36:09 +0100
Subject: [rust-dev] Rust crates and the module system
In-Reply-To: <CAH8Jz7gjtTxpadKf1GiTdDvH8kqDYDS6AiK3xPFgHw5isdDtNA@mail.gmail.com>
References: <CANtrdzrzOyJRKr858jqBnvKw0TRPb64JLi_4pGLz6jr7r=Mhhw@mail.gmail.com>	<52AAD41F.9030407@gmail.com>	<CANtrdzqngY1H8JqUCsFVNOtvin9hm9duVPPjtzV1=nr75+EcXA@mail.gmail.com>	<1520654.c5FlcGdRxj@tph-l10036>
	<52AAF51D.7080804@gmail.com>	<52AAFA0A.2070701@mozilla.com>	<CAH8Jz7jCzjyCw76zZWFq97nyCCrjB_KzNXkHkwzeL-2OGA=rLA@mail.gmail.com>	<52ABAE0B.9080609@mozilla.com>	<CAH8Jz7gbLkdMfJrTeNRa40dwuHc+EXZD_RFKwkNR=iV+O731mw@mail.gmail.com>	<CA++BO6QeRH3MR6qpMWRg3KZFPuzTUb1iUg+m88EJ-Smpy+wo1w@mail.gmail.com>
	<CAH8Jz7gjtTxpadKf1GiTdDvH8kqDYDS6AiK3xPFgHw5isdDtNA@mail.gmail.com>
Message-ID: <52AC5EC9.2070907@gmail.com>

On 12/14/2013 05:28 AM, Liigo Zhuang wrote:
> There is an official tool called "rustpkg", and there is a attribute call
> "pkgid", so you cann't just easily saying "there is no package" in rust. If
> no package, why not using "rustcrate" and "crateid" for consistency? (I do
> not think 'crate' is a good name, other languages tend to call it 'package'
> or 'library'.)

Agreed. And library should be left alone as a set of packages, as in "std lib".

Denis

From jack at metajack.im  Sat Dec 14 07:39:45 2013
From: jack at metajack.im (Jack Moffitt)
Date: Sat, 14 Dec 2013 08:39:45 -0700
Subject: [rust-dev] IRC moderation due to attacks
Message-ID: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>

Some botnet is picking on #rust. Until the situation is resolved[1] or
the botnet gives up, we've been turning on moderation in the #rust IRC
room.

This means that you won't be able to join #rust or talk in the channel
unless you have registered with NickServ[2].

Right now the attack seems focused on #rust, but if the others
channels start getting attacked as well we will have to turn on
moderation there too.

It would be useful if someone who has some free time could update the
IRC page on the wiki to suggest people register their nicks and point
them to the instructions below. You might also mention that moderation
is employed from time to time to prevent spam bot attacks and that
will prevent unregistered participants from joining and/or talking.

We apologize for the inconvenience, and we'll hopefully be able to go
back to our previous, unmoderated setup soon.

jack.

[1] https://bugzilla.mozilla.org/show_bug.cgi?id=950187
[2] https://wiki.mozilla.org/IRC#Register_your_nickname

From banderson at mozilla.com  Sat Dec 14 14:07:34 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Sat, 14 Dec 2013 14:07:34 -0800
Subject: [rust-dev] IRC moderation due to attacks
In-Reply-To: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>
References: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>
Message-ID: <52ACD6A6.4000303@mozilla.com>

On 12/14/2013 07:39 AM, Jack Moffitt wrote:
> Some botnet is picking on #rust. Until the situation is resolved[1] or
> the botnet gives up, we've been turning on moderation in the #rust IRC
> room.
>
> This means that you won't be able to join #rust or talk in the channel
> unless you have registered with NickServ[2].
>
> Right now the attack seems focused on #rust, but if the others
> channels start getting attacked as well we will have to turn on
> moderation there too.
>
> It would be useful if someone who has some free time could update the
> IRC page on the wiki to suggest people register their nicks and point
> them to the instructions below. You might also mention that moderation
> is employed from time to time to prevent spam bot attacks and that
> will prevent unregistered participants from joining and/or talking.

I added a note to the wiki: https://github.com/mozilla/rust/wiki/Docs

>
> We apologize for the inconvenience, and we'll hopefully be able to go
> back to our previous, unmoderated setup soon.
>
> jack.
>
> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=950187
> [2] https://wiki.mozilla.org/IRC#Register_your_nickname
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From andres.osinski at gmail.com  Sun Dec 15 00:24:19 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Sun, 15 Dec 2013 06:24:19 -0200
Subject: [rust-dev] Trait container return types
Message-ID: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>

Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
library to manage some common business object behavior.

trait Field<T> {
    fn name() -> ~str;
    fn get_validators() -> ~[&Validator<T>];
    fn get(&self) -> T;
    fn is_valid(&self) -> bool;
}

trait Model {
    fn get_fields(&self) -> ~[@Field];
    fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
}

The code fails with the following compiler error:

models.rs:80:35: 80:40 error: wrong number of type arguments: expected 1
but found 0
models.rs:80         fn get_fields(&self) -> ~[@Field];

The reason for the get_fields() method is to return a list of heterogenous
trait-upcasted objects, and for each of them I'd be invoking the is_valid()
method.

I would understand that the compiler may not understand the notion of trait
return types (which would make sense) but I'd be interested to know whether
this is a bug or a design limitation, and in the second case, whether
there's a sensible alternative.

Thanks

-- 
Andr?s Osinski
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/ea0db4fe/attachment.html>

From me at chrismorgan.info  Sun Dec 15 02:24:26 2013
From: me at chrismorgan.info (Chris Morgan)
Date: Sun, 15 Dec 2013 21:24:26 +1100
Subject: [rust-dev] Trait container return types
In-Reply-To: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
References: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
Message-ID: <CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>

The problem there is that `@Field` is not a type, because you haven't
specified the value for the generic constraint T. That is, the
pertinent trait object would be something like `@Field<int>`. It's not
possible to have a field without the type being specified; that is,
`get_fields()` can only be designed to return fields of one type
(think of it this way?what will the type checker think of the value of
`model.get_fields()[0].get()`? It's got to be exactly one type, but
it's not possible to infer it).

You'd need to deal with something like std::any::Any to achieve what
it looks likely that you're trying to do. Because I wouldn't encourage
designing something in that way as a starting point, I won't just now
give you code covering how you would implement such a thing; see if
it's possible for you to design it in such a way that this constraint
doesn't cause you trouble. Using enums instead of traits is one way
that can often?though certainly not always?get around this problem.

One final note?avoid using @-boxes if possible; is it possible for you
to give owned pointers or references?

On Sun, Dec 15, 2013 at 7:24 PM, Andres Osinski
<andres.osinski at gmail.com> wrote:
> Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
> library to manage some common business object behavior.
>
> trait Field<T> {
>     fn name() -> ~str;
>     fn get_validators() -> ~[&Validator<T>];
>     fn get(&self) -> T;
>     fn is_valid(&self) -> bool;
> }
>
> trait Model {
>     fn get_fields(&self) -> ~[@Field];
>     fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
> }
>
> The code fails with the following compiler error:
>
> models.rs:80:35: 80:40 error: wrong number of type arguments: expected 1 but
> found 0
> models.rs:80         fn get_fields(&self) -> ~[@Field];
>
> The reason for the get_fields() method is to return a list of heterogenous
> trait-upcasted objects, and for each of them I'd be invoking the is_valid()
> method.
>
> I would understand that the compiler may not understand the notion of trait
> return types (which would make sense) but I'd be interested to know whether
> this is a bug or a design limitation, and in the second case, whether
> there's a sensible alternative.
>
> Thanks
>
> --
> Andr?s Osinski
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From andres.osinski at gmail.com  Sun Dec 15 02:39:39 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Sun, 15 Dec 2013 08:39:39 -0200
Subject: [rust-dev] Trait container return types
In-Reply-To: <CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>
References: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
	<CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>
Message-ID: <CA+xF-PzPiFHFyGGrznEi80xNkx8rfnB9jLwWZsLyXkcNhLuYBw@mail.gmail.com>

I have not gotten around to examining the ownership issues of @-boxes -
I've used them because they're mentioned as the only way to do runtime
polymorphism - but I will definitely be looking at the Any type.

The essential point is that, for a set of Field<T> containers, I want to
invoke a method whose signature does  not have generic type parameters,
name the is_valid() method which would return a bool.

The thing is, the specialization for Field is something that I want to
leave open to the user, so an Enum solution or any solution which places a
constraint on T is not good for my use case. I'm open to doing whatever
unsafe manipulations would be necessary, but unfortunately there's not that
much code that's been written to go around to get an example.


On Sun, Dec 15, 2013 at 7:24 AM, Chris Morgan <me at chrismorgan.info> wrote:

> The problem there is that `@Field` is not a type, because you haven't
> specified the value for the generic constraint T. That is, the
> pertinent trait object would be something like `@Field<int>`. It's not
> possible to have a field without the type being specified; that is,
> `get_fields()` can only be designed to return fields of one type
> (think of it this way?what will the type checker think of the value of
> `model.get_fields()[0].get()`? It's got to be exactly one type, but
> it's not possible to infer it).
>
> You'd need to deal with something like std::any::Any to achieve what
> it looks likely that you're trying to do. Because I wouldn't encourage
> designing something in that way as a starting point, I won't just now
> give you code covering how you would implement such a thing; see if
> it's possible for you to design it in such a way that this constraint
> doesn't cause you trouble. Using enums instead of traits is one way
> that can often?though certainly not always?get around this problem.
>
> One final note?avoid using @-boxes if possible; is it possible for you
> to give owned pointers or references?
>
> On Sun, Dec 15, 2013 at 7:24 PM, Andres Osinski
> <andres.osinski at gmail.com> wrote:
> > Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
> > library to manage some common business object behavior.
> >
> > trait Field<T> {
> >     fn name() -> ~str;
> >     fn get_validators() -> ~[&Validator<T>];
> >     fn get(&self) -> T;
> >     fn is_valid(&self) -> bool;
> > }
> >
> > trait Model {
> >     fn get_fields(&self) -> ~[@Field];
> >     fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
> > }
> >
> > The code fails with the following compiler error:
> >
> > models.rs:80:35: 80:40 error: wrong number of type arguments: expected
> 1 but
> > found 0
> > models.rs:80         fn get_fields(&self) -> ~[@Field];
> >
> > The reason for the get_fields() method is to return a list of
> heterogenous
> > trait-upcasted objects, and for each of them I'd be invoking the
> is_valid()
> > method.
> >
> > I would understand that the compiler may not understand the notion of
> trait
> > return types (which would make sense) but I'd be interested to know
> whether
> > this is a bug or a design limitation, and in the second case, whether
> > there's a sensible alternative.
> >
> > Thanks
> >
> > --
> > Andr?s Osinski
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>



-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/6035aba0/attachment.html>

From ecreed at cs.washington.edu  Sun Dec 15 02:52:18 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Sun, 15 Dec 2013 02:52:18 -0800
Subject: [rust-dev] Trait container return types
In-Reply-To: <CA+xF-PzPiFHFyGGrznEi80xNkx8rfnB9jLwWZsLyXkcNhLuYBw@mail.gmail.com>
References: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
	<CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>
	<CA+xF-PzPiFHFyGGrznEi80xNkx8rfnB9jLwWZsLyXkcNhLuYBw@mail.gmail.com>
Message-ID: <CANbMr6FdJqrbpkMz0Axi2QY+7g=Qeruv-Y0webFfLHN0UrnBeQ@mail.gmail.com>

I'm on a phone so I haven't tested this, but I'd suggest removing the T
parameter of Field and replacing uses of T with Self. In case you don't
already know, Self is a implicit type parameter representing the type of
self, i.e. the type you impl the trait for. Would that work for your use
case?
On Dec 15, 2013 2:40 AM, "Andres Osinski" <andres.osinski at gmail.com> wrote:

> I have not gotten around to examining the ownership issues of @-boxes -
> I've used them because they're mentioned as the only way to do runtime
> polymorphism - but I will definitely be looking at the Any type.
>
> The essential point is that, for a set of Field<T> containers, I want to
> invoke a method whose signature does  not have generic type parameters,
> name the is_valid() method which would return a bool.
>
> The thing is, the specialization for Field is something that I want to
> leave open to the user, so an Enum solution or any solution which places a
> constraint on T is not good for my use case. I'm open to doing whatever
> unsafe manipulations would be necessary, but unfortunately there's not that
> much code that's been written to go around to get an example.
>
>
> On Sun, Dec 15, 2013 at 7:24 AM, Chris Morgan <me at chrismorgan.info> wrote:
>
>> The problem there is that `@Field` is not a type, because you haven't
>> specified the value for the generic constraint T. That is, the
>> pertinent trait object would be something like `@Field<int>`. It's not
>> possible to have a field without the type being specified; that is,
>> `get_fields()` can only be designed to return fields of one type
>> (think of it this way?what will the type checker think of the value of
>> `model.get_fields()[0].get()`? It's got to be exactly one type, but
>> it's not possible to infer it).
>>
>> You'd need to deal with something like std::any::Any to achieve what
>> it looks likely that you're trying to do. Because I wouldn't encourage
>> designing something in that way as a starting point, I won't just now
>> give you code covering how you would implement such a thing; see if
>> it's possible for you to design it in such a way that this constraint
>> doesn't cause you trouble. Using enums instead of traits is one way
>> that can often?though certainly not always?get around this problem.
>>
>> One final note?avoid using @-boxes if possible; is it possible for you
>> to give owned pointers or references?
>>
>> On Sun, Dec 15, 2013 at 7:24 PM, Andres Osinski
>> <andres.osinski at gmail.com> wrote:
>> > Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
>> > library to manage some common business object behavior.
>> >
>> > trait Field<T> {
>> >     fn name() -> ~str;
>> >     fn get_validators() -> ~[&Validator<T>];
>> >     fn get(&self) -> T;
>> >     fn is_valid(&self) -> bool;
>> > }
>> >
>> > trait Model {
>> >     fn get_fields(&self) -> ~[@Field];
>> >     fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
>> > }
>> >
>> > The code fails with the following compiler error:
>> >
>> > models.rs:80:35: 80:40 error: wrong number of type arguments: expected
>> 1 but
>> > found 0
>> > models.rs:80         fn get_fields(&self) -> ~[@Field];
>> >
>> > The reason for the get_fields() method is to return a list of
>> heterogenous
>> > trait-upcasted objects, and for each of them I'd be invoking the
>> is_valid()
>> > method.
>> >
>> > I would understand that the compiler may not understand the notion of
>> trait
>> > return types (which would make sense) but I'd be interested to know
>> whether
>> > this is a bug or a design limitation, and in the second case, whether
>> > there's a sensible alternative.
>> >
>> > Thanks
>> >
>> > --
>> > Andr?s Osinski
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>
>
>
> --
> Andr?s Osinski
> http://www.andresosinski.com.ar/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/40399c7c/attachment-0001.html>

From andres.osinski at gmail.com  Sun Dec 15 03:13:37 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Sun, 15 Dec 2013 09:13:37 -0200
Subject: [rust-dev] Trait container return types
In-Reply-To: <CANbMr6FdJqrbpkMz0Axi2QY+7g=Qeruv-Y0webFfLHN0UrnBeQ@mail.gmail.com>
References: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
	<CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>
	<CA+xF-PzPiFHFyGGrznEi80xNkx8rfnB9jLwWZsLyXkcNhLuYBw@mail.gmail.com>
	<CANbMr6FdJqrbpkMz0Axi2QY+7g=Qeruv-Y0webFfLHN0UrnBeQ@mail.gmail.com>
Message-ID: <CA+xF-Py5k1EK3KiRbXp4BY_Ym1FWHt3fET0S1h_ALRkUUySHag@mail.gmail.com>

I'll have to consider it. To be honest this is my first endeavor in
attempting to capture classic OO business object-y rules using Rust-style
traits, and evidently I have some gaps in my knowledge and how to design
around those constraints.


On Sun, Dec 15, 2013 at 7:52 AM, Eric Reed <ecreed at cs.washington.edu> wrote:

> I'm on a phone so I haven't tested this, but I'd suggest removing the T
> parameter of Field and replacing uses of T with Self. In case you don't
> already know, Self is a implicit type parameter representing the type of
> self, i.e. the type you impl the trait for. Would that work for your use
> case?
>  On Dec 15, 2013 2:40 AM, "Andres Osinski" <andres.osinski at gmail.com>
> wrote:
>
>> I have not gotten around to examining the ownership issues of @-boxes -
>> I've used them because they're mentioned as the only way to do runtime
>> polymorphism - but I will definitely be looking at the Any type.
>>
>> The essential point is that, for a set of Field<T> containers, I want to
>> invoke a method whose signature does  not have generic type parameters,
>> name the is_valid() method which would return a bool.
>>
>> The thing is, the specialization for Field is something that I want to
>> leave open to the user, so an Enum solution or any solution which places a
>> constraint on T is not good for my use case. I'm open to doing whatever
>> unsafe manipulations would be necessary, but unfortunately there's not that
>> much code that's been written to go around to get an example.
>>
>>
>> On Sun, Dec 15, 2013 at 7:24 AM, Chris Morgan <me at chrismorgan.info>wrote:
>>
>>> The problem there is that `@Field` is not a type, because you haven't
>>> specified the value for the generic constraint T. That is, the
>>> pertinent trait object would be something like `@Field<int>`. It's not
>>> possible to have a field without the type being specified; that is,
>>> `get_fields()` can only be designed to return fields of one type
>>> (think of it this way?what will the type checker think of the value of
>>> `model.get_fields()[0].get()`? It's got to be exactly one type, but
>>> it's not possible to infer it).
>>>
>>> You'd need to deal with something like std::any::Any to achieve what
>>> it looks likely that you're trying to do. Because I wouldn't encourage
>>> designing something in that way as a starting point, I won't just now
>>> give you code covering how you would implement such a thing; see if
>>> it's possible for you to design it in such a way that this constraint
>>> doesn't cause you trouble. Using enums instead of traits is one way
>>> that can often?though certainly not always?get around this problem.
>>>
>>> One final note?avoid using @-boxes if possible; is it possible for you
>>> to give owned pointers or references?
>>>
>>> On Sun, Dec 15, 2013 at 7:24 PM, Andres Osinski
>>> <andres.osinski at gmail.com> wrote:
>>> > Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
>>> > library to manage some common business object behavior.
>>> >
>>> > trait Field<T> {
>>> >     fn name() -> ~str;
>>> >     fn get_validators() -> ~[&Validator<T>];
>>> >     fn get(&self) -> T;
>>> >     fn is_valid(&self) -> bool;
>>> > }
>>> >
>>> > trait Model {
>>> >     fn get_fields(&self) -> ~[@Field];
>>> >     fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
>>> > }
>>> >
>>> > The code fails with the following compiler error:
>>> >
>>> > models.rs:80:35: 80:40 error: wrong number of type arguments:
>>> expected 1 but
>>> > found 0
>>> > models.rs:80         fn get_fields(&self) -> ~[@Field];
>>> >
>>> > The reason for the get_fields() method is to return a list of
>>> heterogenous
>>> > trait-upcasted objects, and for each of them I'd be invoking the
>>> is_valid()
>>> > method.
>>> >
>>> > I would understand that the compiler may not understand the notion of
>>> trait
>>> > return types (which would make sense) but I'd be interested to know
>>> whether
>>> > this is a bug or a design limitation, and in the second case, whether
>>> > there's a sensible alternative.
>>> >
>>> > Thanks
>>> >
>>> > --
>>> > Andr?s Osinski
>>> >
>>> > _______________________________________________
>>> > Rust-dev mailing list
>>> > Rust-dev at mozilla.org
>>> > https://mail.mozilla.org/listinfo/rust-dev
>>> >
>>>
>>
>>
>>
>> --
>> Andr?s Osinski
>> http://www.andresosinski.com.ar/
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>


-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/ce5da57d/attachment.html>

From hatahet at gmail.com  Sun Dec 15 03:16:52 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sun, 15 Dec 2013 03:16:52 -0800
Subject: [rust-dev] Trait container return types
In-Reply-To: <CA+xF-Py5k1EK3KiRbXp4BY_Ym1FWHt3fET0S1h_ALRkUUySHag@mail.gmail.com>
References: <CA+xF-PwathtP6GAU0uofTGQyHmnwYaPwov1MWcK0qdygAKgWtQ@mail.gmail.com>
	<CAMF4WehPxdNjRGKucEnm=ebCpEG+FdADLknbyROFc81e_L+fSg@mail.gmail.com>
	<CA+xF-PzPiFHFyGGrznEi80xNkx8rfnB9jLwWZsLyXkcNhLuYBw@mail.gmail.com>
	<CANbMr6FdJqrbpkMz0Axi2QY+7g=Qeruv-Y0webFfLHN0UrnBeQ@mail.gmail.com>
	<CA+xF-Py5k1EK3KiRbXp4BY_Ym1FWHt3fET0S1h_ALRkUUySHag@mail.gmail.com>
Message-ID: <CAN1rdEw_1W=KTCU-_gSoJDooYnSh_ahLJay0_wkFBJOSwLfv4Q@mail.gmail.com>

Can you have the definition be: fn get_fields<T>(&self) -> ~[@Field<T>];?

--
Ziad


On Sun, Dec 15, 2013 at 3:13 AM, Andres Osinski <andres.osinski at gmail.com>wrote:

> I'll have to consider it. To be honest this is my first endeavor in
> attempting to capture classic OO business object-y rules using Rust-style
> traits, and evidently I have some gaps in my knowledge and how to design
> around those constraints.
>
>
> On Sun, Dec 15, 2013 at 7:52 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> I'm on a phone so I haven't tested this, but I'd suggest removing the T
>> parameter of Field and replacing uses of T with Self. In case you don't
>> already know, Self is a implicit type parameter representing the type of
>> self, i.e. the type you impl the trait for. Would that work for your use
>> case?
>>  On Dec 15, 2013 2:40 AM, "Andres Osinski" <andres.osinski at gmail.com>
>> wrote:
>>
>>> I have not gotten around to examining the ownership issues of @-boxes -
>>> I've used them because they're mentioned as the only way to do runtime
>>> polymorphism - but I will definitely be looking at the Any type.
>>>
>>> The essential point is that, for a set of Field<T> containers, I want to
>>> invoke a method whose signature does  not have generic type parameters,
>>> name the is_valid() method which would return a bool.
>>>
>>> The thing is, the specialization for Field is something that I want to
>>> leave open to the user, so an Enum solution or any solution which places a
>>> constraint on T is not good for my use case. I'm open to doing whatever
>>> unsafe manipulations would be necessary, but unfortunately there's not that
>>> much code that's been written to go around to get an example.
>>>
>>>
>>> On Sun, Dec 15, 2013 at 7:24 AM, Chris Morgan <me at chrismorgan.info>wrote:
>>>
>>>> The problem there is that `@Field` is not a type, because you haven't
>>>> specified the value for the generic constraint T. That is, the
>>>> pertinent trait object would be something like `@Field<int>`. It's not
>>>> possible to have a field without the type being specified; that is,
>>>> `get_fields()` can only be designed to return fields of one type
>>>> (think of it this way?what will the type checker think of the value of
>>>> `model.get_fields()[0].get()`? It's got to be exactly one type, but
>>>> it's not possible to infer it).
>>>>
>>>> You'd need to deal with something like std::any::Any to achieve what
>>>> it looks likely that you're trying to do. Because I wouldn't encourage
>>>> designing something in that way as a starting point, I won't just now
>>>> give you code covering how you would implement such a thing; see if
>>>> it's possible for you to design it in such a way that this constraint
>>>> doesn't cause you trouble. Using enums instead of traits is one way
>>>> that can often?though certainly not always?get around this problem.
>>>>
>>>> One final note?avoid using @-boxes if possible; is it possible for you
>>>> to give owned pointers or references?
>>>>
>>>> On Sun, Dec 15, 2013 at 7:24 PM, Andres Osinski
>>>> <andres.osinski at gmail.com> wrote:
>>>> > Hi everyone, I'm doing a bit of Rust coding and I'm trying to build a
>>>> > library to manage some common business object behavior.
>>>> >
>>>> > trait Field<T> {
>>>> >     fn name() -> ~str;
>>>> >     fn get_validators() -> ~[&Validator<T>];
>>>> >     fn get(&self) -> T;
>>>> >     fn is_valid(&self) -> bool;
>>>> > }
>>>> >
>>>> > trait Model {
>>>> >     fn get_fields(&self) -> ~[@Field];
>>>> >     fn validate(&self) -> Option<HashMap<~str, ~[FieldError]>> {
>>>> > }
>>>> >
>>>> > The code fails with the following compiler error:
>>>> >
>>>> > models.rs:80:35: 80:40 error: wrong number of type arguments:
>>>> expected 1 but
>>>> > found 0
>>>> > models.rs:80         fn get_fields(&self) -> ~[@Field];
>>>> >
>>>> > The reason for the get_fields() method is to return a list of
>>>> heterogenous
>>>> > trait-upcasted objects, and for each of them I'd be invoking the
>>>> is_valid()
>>>> > method.
>>>> >
>>>> > I would understand that the compiler may not understand the notion of
>>>> trait
>>>> > return types (which would make sense) but I'd be interested to know
>>>> whether
>>>> > this is a bug or a design limitation, and in the second case, whether
>>>> > there's a sensible alternative.
>>>> >
>>>> > Thanks
>>>> >
>>>> > --
>>>> > Andr?s Osinski
>>>> >
>>>> > _______________________________________________
>>>> > Rust-dev mailing list
>>>> > Rust-dev at mozilla.org
>>>> > https://mail.mozilla.org/listinfo/rust-dev
>>>> >
>>>>
>>>
>>>
>>>
>>> --
>>> Andr?s Osinski
>>> http://www.andresosinski.com.ar/
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>
>
> --
> Andr?s Osinski
> http://www.andresosinski.com.ar/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/0d9a056b/attachment-0001.html>

From bjzaba at yahoo.com.au  Sun Dec 15 04:41:31 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sun, 15 Dec 2013 22:41:31 +1000
Subject: [rust-dev] IRC moderation due to attacks
In-Reply-To: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>
References: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>
Message-ID: <F1A18389-C94B-49C7-91A7-02A8B5F88CBF@yahoo.com.au>


On 15 Dec 2013, at 1:39 am, Jack Moffitt <jack at metajack.im> wrote:

> Some botnet is picking on #rust. Until the situation is resolved[1] or
> the botnet gives up, we've been turning on moderation in the #rust IRC
> room.
> 
> This means that you won't be able to join #rust or talk in the channel
> unless you have registered with NickServ[2].
> 
> Right now the attack seems focused on #rust, but if the others
> channels start getting attacked as well we will have to turn on
> moderation there too.
> 
> It would be useful if someone who has some free time could update the
> IRC page on the wiki to suggest people register their nicks and point
> them to the instructions below. You might also mention that moderation
> is employed from time to time to prevent spam bot attacks and that
> will prevent unregistered participants from joining and/or talking.
> 
> We apologize for the inconvenience, and we'll hopefully be able to go
> back to our previous, unmoderated setup soon.
> 
> jack.
> 
> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=950187
> [2] https://wiki.mozilla.org/IRC#Register_your_nickname
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

I was just hit by a bot spamming /querys on me using random nicks. Can?t connect to #rust. :(

~Brendan

From com.liigo at gmail.com  Sun Dec 15 04:52:06 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sun, 15 Dec 2013 20:52:06 +0800
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7i9uksBvsHwJcCOD_cOSMB7RG31VyqLx1AO2cSr-9=v8g@mail.gmail.com>
	<CAH8Jz7ieAB6yynLje8ComoEm7T8TiwPan2U18xc7Vy6Y+vbJRg@mail.gmail.com>
	<CAH8Jz7i+EVvWtUPqxwTsRNe2UM0jbKUcN_0DZzMWy1dDkeUhiw@mail.gmail.com>
	<CAH8Jz7hEGu=ZktNCLi0nKyBkc81BEZoB4EcxkVPb9FPyDb4wMQ@mail.gmail.com>
	<CAH8Jz7iW33sH=tPFz+WMMuaaeOfBO5m221DqMgR51KkOSS8OaA@mail.gmail.com>
	<CAH8Jz7jNDTcHZ5yjBddZe4j4ibEy9px+Jps2-o6JiO822PMXQg@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
Message-ID: <CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>

Rust compiler compiles "crates", rustpkg manages "packages".

When develope a library for rust, I write these code in lib.rs:
```
#[pkgid = "whoami"];
#[crate_type = "lib"];
????
```
Note, I set its "package" id, and set its "crate" type, and it is compiled
to an .so library. Now please tell me, what "it" is? A package? A crate? or
just a library? If it's a package, why I set its crate type? If it's a
crate, why I set its package id? Confusing.

And when use it ("whoami"), I must write the code:
```
extern mod whoami;
```
Now was it transmuted to a "module"?? If it's a module, why I haven't set
its module id and module type? If it's not a module, why not use `extern
package whoami` or  `extern crate whoami` here? Full of confusion.

Can you please tell me WHAT it really is? Thank you.

~~~~~~~~~~~~~~~~~~~~~~~~~~

The following is my answer and my solution:

We remove "crate" everywhere. And the answer is obvious: it is a package.

Package is a compile unit, it contains a root module (with the same name as
pkgid), and module contains sub-modules. A package may be compiled to
dynamic library, static library or executable program. "package" is a new
keyword.

When define a package, we first write one of these lines:
```
package newpkg; /// pkgid is "newpkg", compile to dynamic library (.so)
package main; /// pkgid "main" means compile to executable program (.exe)
static package newpkg; /// pkgid is "newpkg", compile to static library
```
It replaced the #[pkgid] and #[crate_type], the doc-comments replaced the
#[desc].

When declare using the package, we write code:
```
extern package newpkg; // or ?
extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";
```
The `extern package newpkg;` should be optional, because, when we write:
```
use newpkg::a::b;
```
? rust compiler always knows it's using extern package `newpkg`. (If name
conflicts with local module, compiler should emit an error.)

Liigo, 2013-12-15.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/7f8cdd44/attachment.html>

From dbau.pp at gmail.com  Sun Dec 15 04:58:59 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 15 Dec 2013 23:58:59 +1100
Subject: [rust-dev] IRC moderation due to attacks
In-Reply-To: <F1A18389-C94B-49C7-91A7-02A8B5F88CBF@yahoo.com.au>
References: <CAP7VpsXVd=PASi5vw9FwY6KDEe5dSRqgqpgNFXCaUVT_y0X4KA@mail.gmail.com>
	<F1A18389-C94B-49C7-91A7-02A8B5F88CBF@yahoo.com.au>
Message-ID: <52ADA793.30502@gmail.com>

And we're having a large amount of bot-spam in the main channel right now.

(Although, it did get the channel up to 1000 people at one point, so 
it's not all bad.)


Huon


On 15/12/13 23:41, Brendan Zabarauskas wrote:
> On 15 Dec 2013, at 1:39 am, Jack Moffitt <jack at metajack.im> wrote:
>
>> Some botnet is picking on #rust. Until the situation is resolved[1] or
>> the botnet gives up, we've been turning on moderation in the #rust IRC
>> room.
>>
>> This means that you won't be able to join #rust or talk in the channel
>> unless you have registered with NickServ[2].
>>
>> Right now the attack seems focused on #rust, but if the others
>> channels start getting attacked as well we will have to turn on
>> moderation there too.
>>
>> It would be useful if someone who has some free time could update the
>> IRC page on the wiki to suggest people register their nicks and point
>> them to the instructions below. You might also mention that moderation
>> is employed from time to time to prevent spam bot attacks and that
>> will prevent unregistered participants from joining and/or talking.
>>
>> We apologize for the inconvenience, and we'll hopefully be able to go
>> back to our previous, unmoderated setup soon.
>>
>> jack.
>>
>> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=950187
>> [2] https://wiki.mozilla.org/IRC#Register_your_nickname
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> I was just hit by a bot spamming /querys on me using random nicks. Can?t connect to #rust. :(
>
> ~Brendan
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From gaetan at xeberon.net  Sun Dec 15 05:08:58 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sun, 15 Dec 2013 14:08:58 +0100
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7i9uksBvsHwJcCOD_cOSMB7RG31VyqLx1AO2cSr-9=v8g@mail.gmail.com>
	<CAH8Jz7ieAB6yynLje8ComoEm7T8TiwPan2U18xc7Vy6Y+vbJRg@mail.gmail.com>
	<CAH8Jz7i+EVvWtUPqxwTsRNe2UM0jbKUcN_0DZzMWy1dDkeUhiw@mail.gmail.com>
	<CAH8Jz7hEGu=ZktNCLi0nKyBkc81BEZoB4EcxkVPb9FPyDb4wMQ@mail.gmail.com>
	<CAH8Jz7iW33sH=tPFz+WMMuaaeOfBO5m221DqMgR51KkOSS8OaA@mail.gmail.com>
	<CAH8Jz7jNDTcHZ5yjBddZe4j4ibEy9px+Jps2-o6JiO822PMXQg@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
Message-ID: <CANK7tAFEHNQ4WZpYJyzXjjpp7bkJsCUMBCwfoHW4sj5rPmYQLA@mail.gmail.com>

I prefere keeping crate and package, turn crate_type to package_typa, and
change "mod" keyword to crate. But I don't know what rust devevelopers think

#[pkgid = "whoami"];
#[package_type = "lib"];
...
extern crate whoami


-----
Gaetan



2013/12/15 Liigo Zhuang <com.liigo at gmail.com>

> Rust compiler compiles "crates", rustpkg manages "packages".
>
> When develope a library for rust, I write these code in lib.rs:
> ```
> #[pkgid = "whoami"];
> #[crate_type = "lib"];
> ????
> ```
> Note, I set its "package" id, and set its "crate" type, and it is compiled
> to an .so library. Now please tell me, what "it" is? A package? A crate? or
> just a library? If it's a package, why I set its crate type? If it's a
> crate, why I set its package id? Confusing.
>
> And when use it ("whoami"), I must write the code:
> ```
> extern mod whoami;
> ```
> Now was it transmuted to a "module"?? If it's a module, why I haven't set
> its module id and module type? If it's not a module, why not use `extern
> package whoami` or  `extern crate whoami` here? Full of confusion.
>
> Can you please tell me WHAT it really is? Thank you.
>
> ~~~~~~~~~~~~~~~~~~~~~~~~~~
>
> The following is my answer and my solution:
>
> We remove "crate" everywhere. And the answer is obvious: it is a package.
>
> Package is a compile unit, it contains a root module (with the same name
> as pkgid), and module contains sub-modules. A package may be compiled to
> dynamic library, static library or executable program. "package" is a new
> keyword.
>
> When define a package, we first write one of these lines:
> ```
> package newpkg; /// pkgid is "newpkg", compile to dynamic library (.so)
> package main; /// pkgid "main" means compile to executable program (.exe)
> static package newpkg; /// pkgid is "newpkg", compile to static library
> ```
> It replaced the #[pkgid] and #[crate_type], the doc-comments replaced the
> #[desc].
>
> When declare using the package, we write code:
> ```
> extern package newpkg; // or ?
> extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";
> ```
> The `extern package newpkg;` should be optional, because, when we write:
> ```
> use newpkg::a::b;
> ```
> ? rust compiler always knows it's using extern package `newpkg`. (If name
> conflicts with local module, compiler should emit an error.)
>
> Liigo, 2013-12-15.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/d294ed39/attachment.html>

From slabode at aim.com  Sun Dec 15 13:03:40 2013
From: slabode at aim.com (SiegeLord)
Date: Sun, 15 Dec 2013 16:03:40 -0500
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7iW33sH=tPFz+WMMuaaeOfBO5m221DqMgR51KkOSS8OaA@mail.gmail.com>
	<CAH8Jz7jNDTcHZ5yjBddZe4j4ibEy9px+Jps2-o6JiO822PMXQg@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
Message-ID: <52AE192C.4060006@aim.com>

On 12/15/2013 07:52 AM, Liigo Zhuang wrote:
> Rust compiler compiles "crates", rustpkg manages "packages".
>
> When develope a library for rust, I write these code in lib.rs
> <http://lib.rs>:
> ```
> #[pkgid = "whoami"];
> #[crate_type = "lib"];
> ????
> ```
> Note, I set its "package" id, and set its "crate" type, and it is
> compiled to an .so library. Now please tell me, what "it" is? A package?
> A crate? or just a library? If it's a package, why I set its crate type?
> If it's a crate, why I set its package id? Confusing.

I agree that 'pkgid' is a really unfortunate name that stems from the 
confusion of whether or not a package is allowed to contain multiple 
crates. I think it should, but it feels like I'm in a minority. 'pkgid' 
is used to generate the crate output name, at least for libraries, (i.e. 
lib<name>-<hash>-<version>.so). Frankly, I liked the old link metadata 
idea better where you specified the Author, Version and output name 
separately, and it was not conflated with the rustpkg idea. I believe 
the movement to #[pkgid] was driven by the desire for external tools to 
be able to compute the hash (e.g. see 
http://metajack.im/2013/12/12/building-rust-code--using-make/)... but I 
think that's a mistake. I really don't think this is a solution:

RUST_CRATE_PKGID = $(shell sed -ne 's/^#[ *pkgid *= *"(.*)" *];$$/\1/p' 
$(firstword $(1)))
RUST_CRATE_HASH = $(shell printf $(strip $(1)) | shasum -a 256 | sed -ne 
's/^(.{8}).*$$/\1/p')
_rust_crate_pkgid = $$(call RUST_CRATE_PKGID, $$(_rust_crate_lib))
_rust_crate_hash = $$(call RUST_CRATE_HASH, $$(_rust_crate_pkgid))

I'd rather just do:

RUST_CRATE_HASH = $(shell rustc --get-crate-hash $1)
_rust_crate_hash = $$(call RUST_CRATE_HASH, $$(_rust_crate_lib))

Personally, I'd remove the notion of a package id from the language, and 
leave it entirely up to the external package management tool to deal with.

That'd mean the removal of the unfortunate `extern mod foo = "pkgid";` 
syntax which conflates crates and packages (it could be replaced with 
`#[pkgid="pkgid"] extern mod foo;` if source annotation of external 
dependencies is really desired. It'd have to have different semantics in 
order not to repeat the confusion.).

>
> And when use it ("whoami"), I must write the code:
> ```
> extern mod whoami;
> ```
> Now was it transmuted to a "module"?? If it's a module, why I haven't
> set its module id and module type? If it's not a module, why not use
> `extern package whoami` or  `extern crate whoami` here? Full of confusion.
>
> Can you please tell me WHAT it really is? Thank you.

For what it is worth, "extern mod" is slated to be changed to be 
"crate", I think: https://github.com/mozilla/rust/issues/9880 .

-SL

From banderson at mozilla.com  Sun Dec 15 18:01:12 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Sun, 15 Dec 2013 18:01:12 -0800
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>	<CAH8Jz7iW33sH=tPFz+WMMuaaeOfBO5m221DqMgR51KkOSS8OaA@mail.gmail.com>	<CAH8Jz7jNDTcHZ5yjBddZe4j4ibEy9px+Jps2-o6JiO822PMXQg@mail.gmail.com>	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
Message-ID: <52AE5EE8.8020004@mozilla.com>

I agree this is a mess and we need to resolve this quickly.

On 12/15/2013 04:52 AM, Liigo Zhuang wrote:
>
> Rust compiler compiles "crates", rustpkg manages "packages".
>
> When develope a library for rust, I write these code in lib.rs 
> <http://lib.rs>:
> ```
> #[pkgid = "whoami"];
> #[crate_type = "lib"];
> ............
> ```
> Note, I set its "package" id, and set its "crate" type, and it is 
> compiled to an .so library. Now please tell me, what "it" is? A 
> package? A crate? or just a library? If it's a package, why I set its 
> crate type? If it's a crate, why I set its package id? Confusing.
>
> And when use it ("whoami"), I must write the code:
> ```
> extern mod whoami;
> ```
> Now was it transmuted to a "module"?? If it's a module, why I haven't 
> set its module id and module type? If it's not a module, why not use 
> `extern package whoami` or  `extern crate whoami` here? Full of confusion.
>
> Can you please tell me WHAT it really is? Thank you.
>
> ~~~~~~~~~~~~~~~~~~~~~~~~~~
>
> The following is my answer and my solution:
>
> We remove "crate" everywhere. And the answer is obvious: it is a package.
>

My feeling is that it is a crate, since that's the name we've 
historically used. There's already been agreement to remove "extern mod" 
in favor of "crate".

> Package is a compile unit, it contains a root module (with the same 
> name as pkgid), and module contains sub-modules. A package may be 
> compiled to dynamic library, static library or executable program. 
> "package" is a new keyword.
>
> When define a package, we first write one of these lines:
> ```
> package newpkg; /// pkgid is "newpkg", compile to dynamic library (.so)
> package main; /// pkgid "main" means compile to executable program (.exe)
> static package newpkg; /// pkgid is "newpkg", compile to static library
> ```
> It replaced the #[pkgid] and #[crate_type], the doc-comments replaced 
> the #[desc].
>
> When declare using the package, we write code:
> ```
> extern package newpkg; // or ...
> extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";
> ```
> The `extern package newpkg;` should be optional, because, when we write:
> ```
> use newpkg::a::b;
> ```
> ... rust compiler always knows it's using extern package `newpkg`. (If 
> name conflicts with local module, compiler should emit an error.)
>
> Liigo, 2013-12-15.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131215/f1143633/attachment.html>

From com.liigo at gmail.com  Mon Dec 16 18:41:35 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Tue, 17 Dec 2013 10:41:35 +0800
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <52AE5EE8.8020004@mozilla.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7iW33sH=tPFz+WMMuaaeOfBO5m221DqMgR51KkOSS8OaA@mail.gmail.com>
	<CAH8Jz7jNDTcHZ5yjBddZe4j4ibEy9px+Jps2-o6JiO822PMXQg@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
	<52AE5EE8.8020004@mozilla.com>
Message-ID: <CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>

2013/12/16 Brian Anderson <banderson at mozilla.com>

>  My feeling is that it is a crate, since that's the name we've
> historically used. There's already been agreement to remove "extern mod" in
> favor of "crate".
>

IMO, "package" is used in several languages, maybe it's much familiar and
friendly to rust newbies:


> ```

package newpkg; // pkgid is "newpkg", compile to dynamic library (.so)

package main; // pkgid "main" means compile to executable program (.exe)

static package newpkg; // pkgid is "newpkg", compile to static library



extern package newpkg; // or ?
>
extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";

```


But I'm OK if "crate" is used here.

Liigo, 2013-12-17.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131217/f382abba/attachment.html>

From stefan.plantikow at gmail.com  Tue Dec 17 11:06:56 2013
From: stefan.plantikow at gmail.com (Stefan Plantikow)
Date: Tue, 17 Dec 2013 20:06:56 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
Message-ID: <CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>

Hi,


Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:

> I have no idea if it would be feasible in the standard library, but wouldn't the ideal solution be having one function (e.g. from_utf8()) that could return two possible values, a bare result and an Option? Letting the compiler decide which version to use based on type inference like this:
> 
>     let result: ~str = from_utf8(...);
>     let result: Option<~str> = from_utf8(...);
> 
> Assuming both of them are passed invalid UTF8, then the first version would fail, but the second version would just return None.


If rust allowed pattern matching in let, this problem would go away:

  let Some(~result) = from_utf8(?);

This would fail if from_utf8(..) would not return None. This solution has several benefits:

- The code clearly expresses intent (a result was expected and thus it should fail if instead None is returned) 
- Only one function is needed and that functions signature covers all possible return cases
- This approach isn?t limited to Option and could very well also work with Result.  The generated error message could contain the value that was not matched (and thus have more detailed error information).
- IMHO the required syntax change won't  break existing code (?)



Cheers,


Stefan

From corey at octayn.net  Tue Dec 17 11:10:29 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 17 Dec 2013 14:10:29 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
Message-ID: <CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>

On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
<stefan.plantikow at gmail.com> wrote:
> Hi,
>
>
> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>
>> I have no idea if it would be feasible in the standard library, but wouldn't the ideal solution be having one function (e.g. from_utf8()) that could return two possible values, a bare result and an Option? Letting the compiler decide which version to use based on type inference like this:
>>
>>     let result: ~str = from_utf8(...);
>>     let result: Option<~str> = from_utf8(...);
>>
>> Assuming both of them are passed invalid UTF8, then the first version would fail, but the second version would just return None.
>
>
> If rust allowed pattern matching in let, this problem would go away:
>
>   let Some(~result) = from_utf8(?);
>
> This would fail if from_utf8(..) would not return None. This solution has several benefits:
>
> - The code clearly expresses intent (a result was expected and thus it should fail if instead None is returned)
> - Only one function is needed and that functions signature covers all possible return cases
> - This approach isn?t limited to Option and could very well also work with Result.  The generated error message could contain the value that was not matched (and thus have more detailed error information).
> - IMHO the required syntax change won't  break existing code (?)
>

We already have pattern matching in `let` (the LHS is a pattern), but
it's only for irrefutable patterns. IOW, `let` can never fail, and
that's a very very useful property IMO.

From banderson at mozilla.com  Tue Dec 17 11:18:25 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 17 Dec 2013 11:18:25 -0800
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>	<52AE5EE8.8020004@mozilla.com>
	<CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>
Message-ID: <52B0A381.7080505@mozilla.com>

We discussed this some in the meeting today: 
https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17

On 12/16/2013 06:41 PM, Liigo Zhuang wrote:
>
> 2013/12/16 Brian Anderson <banderson at mozilla.com 
> <mailto:banderson at mozilla.com>>
>
>     My feeling is that it is a crate, since that's the name we've
>     historically used. There's already been agreement to remove
>     "extern mod" in favor of "crate".
>
>
> IMO, "package" is used in several languages, maybe it's much familiar 
> and friendly to rust newbies:
>
>     ``` 
>
>     package newpkg; // pkgid is "newpkg", compile to dynamic library (.so)
>
>     package main; // pkgid "main" means compile to executable program
>     (.exe)
>
>     static package newpkg; // pkgid is "newpkg", compile to static library
>
>     extern package newpkg; // or ?
>
>     extern package newpkg =
>     "http://github.com/liigo/rust-newpkg#newpkg:1.0";
>
>     ```
>
> But I'm OK if "crate" is used here.
>
> Liigo, 2013-12-17.
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131217/e12824ac/attachment.html>

From stefan.plantikow at gmail.com  Tue Dec 17 11:37:42 2013
From: stefan.plantikow at gmail.com (Stefan Plantikow)
Date: Tue, 17 Dec 2013 20:37:42 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
Message-ID: <1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>

Hi,

Am 17.12.2013 um 20:10 schrieb Corey Richardson <corey at octayn.net>:

> On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
> <stefan.plantikow at gmail.com> wrote:
>> Hi,
>> 
>> 
>> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>> 
>>> I have no idea if it would be feasible in the standard library, but wouldn't the ideal solution be having one function (e.g. from_utf8()) that could return two possible values, a bare result and an Option? Letting the compiler decide which version to use based on type inference like this:
>>> 
>>>    let result: ~str = from_utf8(...);
>>>    let result: Option<~str> = from_utf8(...);
>>> 
>>> Assuming both of them are passed invalid UTF8, then the first version would fail, but the second version would just return None.
>> 
>> 
> 
> We already have pattern matching in `let` (the LHS is a pattern), but
> it's only for irrefutable patterns. IOW, `let` can never fail, and
> that's a very very useful property IMO.

oh ok I haven?t kept up on the syntax then. Given the utility of destructuring bind for error handling, wouldn't it make sense to have a variant of let that can fail? 

Now syntax is a matter of practicality and taste but spontaneously this comes to mind:

   let opt Some(~result) = from_utf8(..)

comes to mind.



Cheers,



Stefan.




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131217/21cee35f/attachment-0001.html>

From kevin at sb.org  Tue Dec 17 12:11:24 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 17 Dec 2013 12:11:24 -0800
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
Message-ID: <46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>

On Dec 17, 2013, at 11:37 AM, Stefan Plantikow <stefan.plantikow at gmail.com> wrote:

> Hi,
> 
> Am 17.12.2013 um 20:10 schrieb Corey Richardson <corey at octayn.net>:
> 
>> On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
>> <stefan.plantikow at gmail.com> wrote:
>>> Hi,
>>> 
>>> 
>>> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>>> 
>>>> I have no idea if it would be feasible in the standard library, but wouldn't the ideal solution be having one function (e.g. from_utf8()) that could return two possible values, a bare result and an Option? Letting the compiler decide which version to use based on type inference like this:
>>>> 
>>>>    let result: ~str = from_utf8(...);
>>>>    let result: Option<~str> = from_utf8(...);
>>>> 
>>>> Assuming both of them are passed invalid UTF8, then the first version would fail, but the second version would just return None.
>>> 
>>> 
>> 
>> We already have pattern matching in `let` (the LHS is a pattern), but
>> it's only for irrefutable patterns. IOW, `let` can never fail, and
>> that's a very very useful property IMO.
> 
> oh ok I haven?t kept up on the syntax then. Given the utility of destructuring bind for error handling, wouldn't it make sense to have a variant of let that can fail? 
> 
> Now syntax is a matter of practicality and taste but spontaneously this comes to mind:
> 
>    let opt Some(~result) = from_utf8(..)
> 
> comes to mind.

You can do it with a bit more verbosity, which I think is perfectly fine as it makes failure much more obvious.

    let result = match from_utf8(..) {
        Some(~result) => result,
        _ => fail!("b0rk b0rk b0rk")
    };

Of course, in this particular example, you'd probably just write

    let result = from_utf8(..).unwrap();

but the longer match form will work for other enums.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131217/59efc6c3/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131217/59efc6c3/attachment.p7s>

From kevin at sb.org  Tue Dec 17 12:19:39 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 17 Dec 2013 12:19:39 -0800
Subject: [rust-dev] Alternative proposal for `use crate`
Message-ID: <AE389AC5-587E-46D2-94C4-D0583A8EAAE8@sb.org>

In today's meeting[1], it appears as though `extern mod foo` may become `use crate foo`. I have a minor worry about this, which is reserving yet another keyword for a very limited usage. My general feeling is we shouldn't be adding keywords unnecessarily, especially if their scope is extremely limited. And unlike the `in` from `for _ in _`, this one can't be made contextual (if we ever decide to go that route), because doing so would allow `mod crate`, which would then make `use crate` ambiguous.

One suggestion I didn't see in the meeting, that seems reasonable to me, is `extern use`, as in

    extern use foo;

This doesn't reserve any new keywords, and it also ties in nicely with the idea that we're linking to something external. It also seems to emphasize the right thing, which is that we're trying to pull in something external. The fact that the thing we're pulling in is a crate seems less important than the fact that it's an external thing that we need to link to.

-Kevin

[1]: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17

From kevin at sb.org  Tue Dec 17 12:25:42 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 17 Dec 2013 12:25:42 -0800
Subject: [rust-dev] Alternative proposal for `use crate`
In-Reply-To: <AE389AC5-587E-46D2-94C4-D0583A8EAAE8@sb.org>
References: <AE389AC5-587E-46D2-94C4-D0583A8EAAE8@sb.org>
Message-ID: <096180D1-6F90-454C-8956-F10DB0625752@sb.org>

After chatting with Alex Crichton on IRC, it turns out `use crate` was actually rejected. It just wasn't captured properly in the notes.

Apparently the current leading proposal is `extern crate foo`. This still has the problem of defining a new limited-scope keyword, but it's better than `use crate foo`.

-Kevin

On Dec 17, 2013, at 12:19 PM, Kevin Ballard <kevin at sb.org> wrote:

> In today's meeting[1], it appears as though `extern mod foo` may become `use crate foo`. I have a minor worry about this, which is reserving yet another keyword for a very limited usage. My general feeling is we shouldn't be adding keywords unnecessarily, especially if their scope is extremely limited. And unlike the `in` from `for _ in _`, this one can't be made contextual (if we ever decide to go that route), because doing so would allow `mod crate`, which would then make `use crate` ambiguous.
> 
> One suggestion I didn't see in the meeting, that seems reasonable to me, is `extern use`, as in
> 
>    extern use foo;
> 
> This doesn't reserve any new keywords, and it also ties in nicely with the idea that we're linking to something external. It also seems to emphasize the right thing, which is that we're trying to pull in something external. The fact that the thing we're pulling in is a crate seems less important than the fact that it's an external thing that we need to link to.
> 
> -Kevin
> 
> [1]: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17


From jack at metajack.im  Tue Dec 17 12:40:01 2013
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 17 Dec 2013 13:40:01 -0700
Subject: [rust-dev] Alternative proposal for `use crate`
In-Reply-To: <096180D1-6F90-454C-8956-F10DB0625752@sb.org>
References: <AE389AC5-587E-46D2-94C4-D0583A8EAAE8@sb.org>
	<096180D1-6F90-454C-8956-F10DB0625752@sb.org>
Message-ID: <CAP7VpsXrvtak1f1cPxB8KFvp0_TeQSbnfnSKLzOaCJm4K0j_cA@mail.gmail.com>

`extern use foo` has the some of the same drawbacks as `use crate
foo`. The `use` might lead people to think you can do `use crate
foo::bar`. The fact that there wasn't a whole lot of love for any
particular options suggests maybe we should wait for more ideas.

It occurs to me now that `extern foo` would probably work too.

jack.

On Tue, Dec 17, 2013 at 1:25 PM, Kevin Ballard <kevin at sb.org> wrote:
> After chatting with Alex Crichton on IRC, it turns out `use crate` was actually rejected. It just wasn't captured properly in the notes.
>
> Apparently the current leading proposal is `extern crate foo`. This still has the problem of defining a new limited-scope keyword, but it's better than `use crate foo`.
>
> -Kevin
>
> On Dec 17, 2013, at 12:19 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> In today's meeting[1], it appears as though `extern mod foo` may become `use crate foo`. I have a minor worry about this, which is reserving yet another keyword for a very limited usage. My general feeling is we shouldn't be adding keywords unnecessarily, especially if their scope is extremely limited. And unlike the `in` from `for _ in _`, this one can't be made contextual (if we ever decide to go that route), because doing so would allow `mod crate`, which would then make `use crate` ambiguous.
>>
>> One suggestion I didn't see in the meeting, that seems reasonable to me, is `extern use`, as in
>>
>>    extern use foo;
>>
>> This doesn't reserve any new keywords, and it also ties in nicely with the idea that we're linking to something external. It also seems to emphasize the right thing, which is that we're trying to pull in something external. The fact that the thing we're pulling in is a crate seems less important than the fact that it's an external thing that we need to link to.
>>
>> -Kevin
>>
>> [1]: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From com.liigo at gmail.com  Tue Dec 17 21:02:40 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 18 Dec 2013 13:02:40 +0800
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <52B0A381.7080505@mozilla.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
	<52AE5EE8.8020004@mozilla.com>
	<CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>
	<52B0A381.7080505@mozilla.com>
Message-ID: <CAH8Jz7gXACKfxd6ChaBnLyLNvjMCoMg2kVPSPDZHmLk7GssSJg@mail.gmail.com>

`use crate foo; ` looks good to me. i always think it should be optional.
rustc can deduce which crate will be used, from use mods lines, in most
situations.


2013/12/18 Brian Anderson <banderson at mozilla.com>

>  We discussed this some in the meeting today:
> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17
>
>
> On 12/16/2013 06:41 PM, Liigo Zhuang wrote:
>
>
> 2013/12/16 Brian Anderson <banderson at mozilla.com>
>
>>  My feeling is that it is a crate, since that's the name we've
>> historically used. There's already been agreement to remove "extern mod" in
>> favor of "crate".
>>
>
>  IMO, "package" is used in several languages, maybe it's much familiar
> and friendly to rust newbies:
>
>
>> ```
>
> package newpkg; // pkgid is "newpkg", compile to dynamic library (.so)
>
> package main; // pkgid "main" means compile to executable program (.exe)
>
> static package newpkg; // pkgid is "newpkg", compile to static library
>
>
>
> extern package newpkg; // or ?
>>
> extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";
>
> ```
>
>
> But I'm OK if "crate" is used here.
>
>  Liigo, 2013-12-17.
>
>
>


-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/a00c87b2/attachment.html>

From jurily at gmail.com  Tue Dec 17 22:38:24 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Wed, 18 Dec 2013 07:38:24 +0100
Subject: [rust-dev] Alternative proposal for `use crate`
In-Reply-To: <CAP7VpsXrvtak1f1cPxB8KFvp0_TeQSbnfnSKLzOaCJm4K0j_cA@mail.gmail.com>
References: <AE389AC5-587E-46D2-94C4-D0583A8EAAE8@sb.org>	<096180D1-6F90-454C-8956-F10DB0625752@sb.org>
	<CAP7VpsXrvtak1f1cPxB8KFvp0_TeQSbnfnSKLzOaCJm4K0j_cA@mail.gmail.com>
Message-ID: <52B142E0.7070502@gmail.com>

On 12/17/2013 09:40 PM, Jack Moffitt wrote:
> `extern use foo` has the some of the same drawbacks as `use crate
> foo`. The `use` might lead people to think you can do `use crate
> foo::bar`. The fact that there wasn't a whole lot of love for any
> particular options suggests maybe we should wait for more ideas.
>
> It occurs to me now that `extern foo` would probably work too.

How about `extern foo in "pkgid"`?

From gaetan at xeberon.net  Wed Dec 18 00:48:02 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 18 Dec 2013 09:48:02 +0100
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CAH8Jz7gXACKfxd6ChaBnLyLNvjMCoMg2kVPSPDZHmLk7GssSJg@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>
	<CAH8Jz7hh+ZkXgafOqM1-TG6rjftB3U=zVgop6f6CVnq9UMxyng@mail.gmail.com>
	<CAH8Jz7hgVdd9U5+8eTnbznytvrBjasZif0uPcdfFs2U_kEToBw@mail.gmail.com>
	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>
	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>
	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>
	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>
	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>
	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>
	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>
	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>
	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>
	<52AE5EE8.8020004@mozilla.com>
	<CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>
	<52B0A381.7080505@mozilla.com>
	<CAH8Jz7gXACKfxd6ChaBnLyLNvjMCoMg2kVPSPDZHmLk7GssSJg@mail.gmail.com>
Message-ID: <CANK7tAG9YATn9dLpyM+pp4=FfFKegkbseqisH8Waezpz3MNRVg@mail.gmail.com>

I am in favor of replacing the mod keyword by crate.
#[package_id = "whoami"];
#[package_type = "lib"];
...
use crate whoamiextern

but I wouldn't understand why the 'mod' keyword would stay


-----
Gaetan



2013/12/18 Liigo Zhuang <com.liigo at gmail.com>

> `use crate foo; ` looks good to me. i always think it should be optional.
> rustc can deduce which crate will be used, from use mods lines, in most
> situations.
>
>
> 2013/12/18 Brian Anderson <banderson at mozilla.com>
>
>>  We discussed this some in the meeting today:
>> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17
>>
>>
>> On 12/16/2013 06:41 PM, Liigo Zhuang wrote:
>>
>>
>> 2013/12/16 Brian Anderson <banderson at mozilla.com>
>>
>>>  My feeling is that it is a crate, since that's the name we've
>>> historically used. There's already been agreement to remove "extern mod" in
>>> favor of "crate".
>>>
>>
>>  IMO, "package" is used in several languages, maybe it's much familiar
>> and friendly to rust newbies:
>>
>>
>>> ```
>>
>> package newpkg; // pkgid is "newpkg", compile to dynamic library (.so)
>>
>> package main; // pkgid "main" means compile to executable program (.exe)
>>
>> static package newpkg; // pkgid is "newpkg", compile to static library
>>
>>
>>
>> extern package newpkg; // or ?
>>>
>> extern package newpkg = "http://github.com/liigo/rust-newpkg#newpkg:1.0";
>>
>> ```
>>
>>
>> But I'm OK if "crate" is used here.
>>
>>  Liigo, 2013-12-17.
>>
>>
>>
>
>
> --
> by *Liigo*, http://blog.csdn.net/liigo/
> Google+  https://plus.google.com/105597640837742873343/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/5dd535df/attachment.html>

From pnkfelix at mozilla.com  Wed Dec 18 03:25:36 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Wed, 18 Dec 2013 12:25:36 +0100
Subject: [rust-dev] [whoami] "crate", "package" and "module" confused me!
In-Reply-To: <CANK7tAG9YATn9dLpyM+pp4=FfFKegkbseqisH8Waezpz3MNRVg@mail.gmail.com>
References: <CAH8Jz7jtptnrn9JnsNCXO65Sow6zi0tkUX67TPfzDz_CVGnuzA@mail.gmail.com>	<CAH8Jz7gaNeJ92Cngj5+2_ypzNx_KugjZ2Nz24aSyHJhjUWPTxg@mail.gmail.com>	<CAH8Jz7g1amktLZOFL4OqULeQ-uma15C59HUMC_rYGMtpB7ucvQ@mail.gmail.com>	<CAH8Jz7jKjuVuqxBu6h1ef5AxLc1S1hYT6_cHL6O2M5ahvk3NGA@mail.gmail.com>	<CAH8Jz7gq_nesPUtmu4Rep=q54o6RO9Rquu0yeWLi8mpzPNUCSw@mail.gmail.com>	<CAH8Jz7g6q95SexVG9r3PsDNdciLKVKQ9xb=2ycaLAi2ED550gQ@mail.gmail.com>	<CAH8Jz7gN9R+Xe4241wZ8vXsWMOxedd4q1w_bN3k=XFG_oaxNow@mail.gmail.com>	<CAH8Jz7g77=tjQ4xDSfYFkYbo=tOMq_8PidDKnhnFPbXD0sWcmA@mail.gmail.com>	<CAH8Jz7hAbh9nfNwxGCjNe4MWiRwk2ztJN6fCrjSkS_tUkBQ5gA@mail.gmail.com>	<CAH8Jz7gNTvS0=nxn8B6NZ0vMCG2cxtUOCdbgPteZrgi3ShMXww@mail.gmail.com>	<52AE5EE8.8020004@mozilla.com>	<CAH8Jz7jD_V=T7f_7TM0XiMwR-zxG-osWuUCQZGPb4qLF79d2Qw@mail.gmail.com>	<52B0A381.7080505@mozilla.com>	<CAH8Jz7gXACKfxd6ChaBnLyLNvjMCoMg2kVPSPDZHmLk7GssSJg@mail.gmail.com>
	<CANK7tAG9YATn9dLpyM+pp4=FfFKegkbseqisH8Waezpz3MNRVg@mail.gmail.com>
Message-ID: <52B18630.6090907@mozilla.com>

Gaetan (cc'ing rust-dev)-

On 18/12/2013 09:48, Gaetan wrote:
> but I wouldn't understand why the 'mod' keyword would stay
Because a Rust module is not the same thing as a crate.

Changes to the syntax for linking to an external crate is orthogonal to 
the concept of a module.  So as long as we want to be able to define 
modules (which are not crates), we probably want a `mod` keyword.

----


Quick tutorial
--------------

The keyword `mod` (without extern) is used to define modules.

A module gathers together a set of names (either by defining each name 
as some item in the module, or by importing them from the outside via 
`use`).  Modules can be nested within one another:

     mod a {
         pub mod b {
             pub fn f(x:i32) -> i32 { 3 * x * x }
         }
         pub mod c {
             pub fn f(x:f32) -> f32 { 3.14 * x * x }
         }
     }

     fn main() {
         use a::{b, c};
         println!("b::f(2) = {} c::f(2) = {}", b::f(2), c::f(2.0))
     }

One could write a whole slew of modules in a single file by nesting 
them.  But since many developers would prefer to be able to break their 
modules into multiple files, the `mod` form also lets you define a inner 
module but put its body into another file.  So here's another way to 
write the `mod a` from above:

     mod a {
         pub mod b; // (moved definition of pub fn f:i32 -> i32 to file 
at "a/b.rs")
         pub mod c; // (moved definition of pub fn f:f32 -> f32 to file 
at "a/c.rs")
     }

Modules are for namespace and static-access control.

On the other hand, a crate is a unit of compilation, composed of one or 
more modules nested together in a hierarchical structure. The rust 
compiler works on a whole crate at a time; this allows it to perform 
code analyses and transformations that cross module boundaries (such as 
the enforcing the coherence rule for trait implementations).

----

I believe all of this is spelled out in the "Crates and the module 
system" section [1] of the tutorial.

(There is always a single *root module* for each crate; it is the root 
of the tree hierarchy of modules.  This correspondence may be the reason 
for your confusion differentiating the two concepts.)

The use of `extern mod` as a way to import a crate is on its way out, as 
discussed in another message.  But that has nothing to do with the 
Rust's concept of a module.

Cheers,
-Felix

[1] 
http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system

On 18/12/2013 09:48, Gaetan wrote:
> I am in favor of replacing the mod keyword by crate.
> #[package_id = "whoami"];
> #[package_type = "lib"];
> ...
> use crate whoamiextern
>
> but I wouldn't understand why the 'mod' keyword would stay
>
>
> -----
> Gaetan
>
>
>
> 2013/12/18 Liigo Zhuang <com.liigo at gmail.com <mailto:com.liigo at gmail.com>>
>
>     `use crate foo; ` looks good to me. i always think it should be
>     optional. rustc can deduce which crate will be used, from use mods
>     lines, in most situations.
>
>
>     2013/12/18 Brian Anderson <banderson at mozilla.com
>     <mailto:banderson at mozilla.com>>
>
>         We discussed this some in the meeting today:
>         https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17
>
>
>         On 12/16/2013 06:41 PM, Liigo Zhuang wrote:
>>
>>         2013/12/16 Brian Anderson <banderson at mozilla.com
>>         <mailto:banderson at mozilla.com>>
>>
>>             My feeling is that it is a crate, since that's the name
>>             we've historically used. There's already been agreement
>>             to remove "extern mod" in favor of "crate".
>>
>>
>>         IMO, "package" is used in several languages, maybe it's much
>>         familiar and friendly to rust newbies:
>>
>>             ``` 
>>
>>             package newpkg; // pkgid is "newpkg", compile to dynamic
>>             library (.so)
>>
>>             package main; // pkgid "main" means compile to executable
>>             program (.exe)
>>
>>             static package newpkg; // pkgid is "newpkg", compile to
>>             static library
>>
>>             extern package newpkg; // or ...
>>
>>             extern package newpkg =
>>             "http://github.com/liigo/rust-newpkg#newpkg:1.0";
>>
>>             ```
>>
>>         But I'm OK if "crate" is used here.
>>
>>         Liigo, 2013-12-17.
>>
>
>
>
>
>     -- 
>     by *Liigo*, http://blog.csdn.net/liigo/
>     Google+ https://plus.google.com/105597640837742873343/
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/55befcd2/attachment-0001.html>

From ben.striegel at gmail.com  Wed Dec 18 06:26:14 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 18 Dec 2013 09:26:14 -0500
Subject: [rust-dev] Joe Armstrong's "universal server"
Message-ID: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>

Hello rusties, I was reading a blog post by Joe Armstrong recently in which
he shows off his favorite tiny Erlang program, called the Universal Server:

http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html

I know that Rust doesn't have quite the same task communication primitives
as Erlang, but I'd be interested to see what the Rust equivalent of this
program would look like if anyone's up to the task of translating it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/9376dafe/attachment.html>

From redbrain at gcc.gnu.org  Wed Dec 18 07:41:36 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Wed, 18 Dec 2013 15:41:36 +0000
Subject: [rust-dev] rustc abi
Message-ID: <CAEvRbep0PC32pdf3U0ZTe5a+iUywM15TmMwbiBDJUU5V-A10aA@mail.gmail.com>

Hey all

Been writing more rust to learn more. And i have been attempting to
write python bindings to rust. And for example

if i create a function in rust:

pub fn spam () {
  ...
}

the symbol gets mangled to:

redbrain at pherron-mtfdev-vbox {~/workspace/python-rs} $ nm -s spam.o
0000000000000000 t _ZN4spam19h46502db08befd726ah4v0.0E

Looks almost similar to the C++ abi at least the _ZN stuff does. Is
there any way to make a function be compiled to a C abi.

I know when we do soemthing like:

extern {
  fn Py_Initialize ();
}

Calling into the Python api it knows to use the C ABI. Is there anyway
to make a normal rust function to use the C ABI as i want to write a
rust module which can be loaded by python just to see if i can more
than anything.

As currently if i continue python won't be able to load it i dont
think at least anyways.

--Phil

From leo.testard at gmail.com  Wed Dec 18 07:46:28 2013
From: leo.testard at gmail.com (=?iso-8859-1?Q?L=E9o_Testard?=)
Date: Wed, 18 Dec 2013 16:46:28 +0100
Subject: [rust-dev] rustc abi
In-Reply-To: <CAEvRbep0PC32pdf3U0ZTe5a+iUywM15TmMwbiBDJUU5V-A10aA@mail.gmail.com>
References: <CAEvRbep0PC32pdf3U0ZTe5a+iUywM15TmMwbiBDJUU5V-A10aA@mail.gmail.com>
Message-ID: <65A274A9-943B-42F6-8F50-9206750B022B@gmail.com>

Hello Philip,


Le 18 d?c. 2013 ? 16:41, Philip Herron <redbrain at gcc.gnu.org> a ?crit :

> Hey all
> 
> Been writing more rust to learn more. And i have been attempting to
> write python bindings to rust. And for example
> 
> if i create a function in rust:
> 
> pub fn spam () {
>  ...
> }
> 
> the symbol gets mangled to:
> 
> redbrain at pherron-mtfdev-vbox {~/workspace/python-rs} $ nm -s spam.o
> 0000000000000000 t _ZN4spam19h46502db08befd726ah4v0.0E
> 
> Looks almost similar to the C++ abi at least the _ZN stuff does. Is
> there any way to make a function be compiled to a C abi.

There is a way to at least disable the name mangling, using the #[no_mangle] attribute:

#[no_mangle]
fn foo() {
...
}

The symbol name in the binary will be what you expect.


> 
> I know when we do soemthing like:
> 
> extern {
>  fn Py_Initialize ();
> }
> 
> Calling into the Python api it knows to use the C ABI. Is there anyway
> to make a normal rust function to use the C ABI as i want to write a
> rust module which can be loaded by python just to see if i can more
> than anything.

I believe there is also the following syntax:

extern "C" fn foo() {
}

where C matches a specific ABI. according to Rustc, the available are : [cdecl, stdcall, fastcall, aapcs, win64, Rust, C, system, rust-intrinsic]


Leo

> 
> As currently if i continue python won't be able to load it i dont
> think at least anyways.
> 
> --Phil

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/65d3e30e/attachment.sig>

From redbrain at gcc.gnu.org  Wed Dec 18 07:50:36 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Wed, 18 Dec 2013 15:50:36 +0000
Subject: [rust-dev] rustc abi
In-Reply-To: <65A274A9-943B-42F6-8F50-9206750B022B@gmail.com>
References: <CAEvRbep0PC32pdf3U0ZTe5a+iUywM15TmMwbiBDJUU5V-A10aA@mail.gmail.com>
	<65A274A9-943B-42F6-8F50-9206750B022B@gmail.com>
Message-ID: <CAEvRbeo1PsPyfmg0z12V_XWA-cgAjunkGdsvqMOZ7_ppAxBo5Q@mail.gmail.com>

Ah woo thanks that solves it.

--Phil

On 18 December 2013 15:46, L?o Testard <leo.testard at gmail.com> wrote:
> Hello Philip,
>
>
> Le 18 d?c. 2013 ? 16:41, Philip Herron <redbrain at gcc.gnu.org> a ?crit :
>
>> Hey all
>>
>> Been writing more rust to learn more. And i have been attempting to
>> write python bindings to rust. And for example
>>
>> if i create a function in rust:
>>
>> pub fn spam () {
>>  ...
>> }
>>
>> the symbol gets mangled to:
>>
>> redbrain at pherron-mtfdev-vbox {~/workspace/python-rs} $ nm -s spam.o
>> 0000000000000000 t _ZN4spam19h46502db08befd726ah4v0.0E
>>
>> Looks almost similar to the C++ abi at least the _ZN stuff does. Is
>> there any way to make a function be compiled to a C abi.
>
> There is a way to at least disable the name mangling, using the #[no_mangle] attribute:
>
> #[no_mangle]
> fn foo() {
> ...
> }
>
> The symbol name in the binary will be what you expect.
>
>
>>
>> I know when we do soemthing like:
>>
>> extern {
>>  fn Py_Initialize ();
>> }
>>
>> Calling into the Python api it knows to use the C ABI. Is there anyway
>> to make a normal rust function to use the C ABI as i want to write a
>> rust module which can be loaded by python just to see if i can more
>> than anything.
>
> I believe there is also the following syntax:
>
> extern "C" fn foo() {
> }
>
> where C matches a specific ABI. according to Rustc, the available are : [cdecl, stdcall, fastcall, aapcs, win64, Rust, C, system, rust-intrinsic]
>
>
> Leo
>
>>
>> As currently if i continue python won't be able to load it i dont
>> think at least anyways.
>>
>> --Phil
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From kevin at sb.org  Wed Dec 18 10:17:31 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 18 Dec 2013 10:17:31 -0800
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
Message-ID: <5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>

That's cute, but I don't really understand the point. The sample program he gave:

test() ->
    Pid = spawn(fun universal_server/0),
    Pid ! {become, fun factorial_server/0},
    Pid ! {self(), 50},
    receive
        X -> X
    end.

will behave identically if you remove universal_server from the equation:

test() ->
    Pid = spawn(fun factorial_server/0),
    Pid ! {self(), 50},
    receive
        X -> X
    end.

The whole point of universal_server, AFAICT, is to just demonstrate something clever about Erlang's task communication primitives. The equivalent in Rust would require passing channels back and forth, because factorial_server needs to receive different data than universal_server. The only alternative that I can think of would be to have a channel of ~Any+Send objects, which isn't very nice.

To that end, I don't see the benefit of trying to reproduce the same functionality in Rust, because it's just not a good fit for Rust's task communication primitives.

-Kevin

On Dec 18, 2013, at 6:26 AM, Benjamin Striegel <ben.striegel at gmail.com> wrote:

> Hello rusties, I was reading a blog post by Joe Armstrong recently in which he shows off his favorite tiny Erlang program, called the Universal Server:
> 
> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
> 
> I know that Rust doesn't have quite the same task communication primitives as Erlang, but I'd be interested to see what the Rust equivalent of this program would look like if anyone's up to the task of translating it.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/58f7662e/attachment.html>

From a.stavonin at gmail.com  Tue Dec 17 23:50:00 2013
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Wed, 18 Dec 2013 11:50:00 +0400
Subject: [rust-dev] Rust in OSX kernel
Message-ID: <CAErP+amyPKWuSNJuMN60omaiZMNmkH0+ZC41_8T0AkQ3nd+K6g@mail.gmail.com>

Hi, I ported rust.ko to OSX. Maybe it'll be interesting for somebody
https://github.com/astavonin/RustyKext
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/cc8612a2/attachment.html>

From a.stavonin at gmail.com  Wed Dec 18 11:08:24 2013
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Wed, 18 Dec 2013 23:08:24 +0400
Subject: [rust-dev] Rust and OSX kexts
Message-ID: <C8E641A6-B9D6-48CF-B45A-DCD36CBB1BF5@gmail.com>

Just for information. Hi, I've ported rust.ko project to OSX. Maybe it'll be interesting for somebody https://github.com/astavonin/RustyKext
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/c069c36e/attachment-0001.html>

From bjzaba at yahoo.com.au  Wed Dec 18 11:49:33 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 19 Dec 2013 06:49:33 +1100
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
Message-ID: <B43D9490-7014-4DAC-8CCE-9410235D6376@yahoo.com.au>


On 19 Dec 2013, at 1:26 am, Benjamin Striegel <ben.striegel at gmail.com> wrote:

> Hello rusties, I was reading a blog post by Joe Armstrong recently in which he shows off his favorite tiny Erlang program, called the Universal Server:
> 
> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
> 
> I know that Rust doesn't have quite the same task communication primitives as Erlang, but I'd be interested to see what the Rust equivalent of this program would look like if anyone's up to the task of translating it.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Universal server... done! https://gist.github.com/bjz/e4d536c63900960c9e15

Here?s the code:

> extern mod extra;
> use extra::comm::DuplexStream;
> 
> enum Request<T, U> {
>     Request(T),
>     Become(extern fn(T) -> U),
> }
> 
> struct Client<T, U> {
>     priv stream: DuplexStream<Request<T, U>, U>
> }
> 
> impl<T: Send, U: Send> Client<T, U> {
>     fn request(&self, x: T) -> U {
>         self.stream.send(Request(x));
>         self.stream.recv()
>     }
> 
>     fn become(&self, f: extern fn(T) -> U) {
>         self.stream.send(Become(f));
>     }
> }
> 
> fn start_server<T: Send, U: Send>() -> Client<T, U> {
>     fn failing<T, U>(_: T) -> U {
>         fail!("Server not yet initialised.")
>     }
> 
>     let (client, server) = DuplexStream::<Request<T, U>, U>::new();
>     spawn(proc() {
>         let mut f = failing::<T, U>;
>         loop {  // Need iterators for DuplexStreams!
>             match server.recv_opt() {
>                 Some(Request(x)) => server.send(f(x)),
>                 Some(Become(g)) => f = g,
>                 None => break,
>             }
>         }
>     });
>     Client { stream: client }
> }
> 
> fn factorial(n: u64) -> u64 {
>     match n {
>         0 => 1,
>         n => n * factorial(n - 1),
>     }
> }
> 
> fn main() {
>     let client = start_server();
>     client.become(factorial);
>     println!("{}", client.request(50));
> }

This was isn?t as elegant the Erlang example due to Rust?s static type system and/or lack of local type inference.

You might be interested in my port of Erlang?s `gen_server` that I?ve been working on[1]. It needs to be fixed up to work with the new updates to std::comm though, so it won?t compile.

~Brendan

[1] https://gist.github.com/bjz/c2b0ce9362cf748b4193


From bjzaba at yahoo.com.au  Wed Dec 18 12:13:30 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 19 Dec 2013 07:13:30 +1100
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
	<5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
Message-ID: <71444815-F81D-4584-B8DC-0B45BFD3C699@yahoo.com.au>


On 19 Dec 2013, at 5:17 am, Kevin Ballard <kevin at sb.org> wrote:

> That's cute, but I don't really understand the point. The sample program he gave:
> 
> test() ->
>     Pid = spawn(fun universal_server/0),
>     Pid ! {become, fun factorial_server/0},
>     Pid ! {self(), 50},
>     receive
>         X -> X
>     end.
> 
> will behave identically if you remove universal_server from the equation:
> 
> test() ->
>     Pid = spawn(fun factorial_server/0),
>     Pid ! {self(), 50},
>     receive
>         X -> X
>     end.
> 
> The whole point of universal_server, AFAICT, is to just demonstrate something clever about Erlang's task communication primitives. The equivalent in Rust would require passing channels back and forth, because factorial_server needs to receive different data than universal_server. The only alternative that I can think of would be to have a channel of ~Any+Send objects, which isn't very nice.
> 
> To that end, I don't see the benefit of trying to reproduce the same functionality in Rust, because it's just not a good fit for Rust's task communication primitives.
> 
> -Kevin
> 
> On Dec 18, 2013, at 6:26 AM, Benjamin Striegel <ben.striegel at gmail.com> wrote:
> 
>> Hello rusties, I was reading a blog post by Joe Armstrong recently in which he shows off his favorite tiny Erlang program, called the Universal Server:
>> 
>> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
>> 
>> I know that Rust doesn't have quite the same task communication primitives as Erlang, but I'd be interested to see what the Rust equivalent of this program would look like if anyone's up to the task of translating it.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

I think one of the points was that you could update the behaviour of the server as it was running. I changed my gist to show that: https://gist.github.com/bjz/e4d536c63900960c9e15#file-universal_server-rs-L63-L67

This is where I find that the static types come in handy, despite their verbosity. It?s much easier to understand what?s going on from the types alone.

~Brendan


From bascule at gmail.com  Wed Dec 18 18:29:01 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 18 Dec 2013 18:29:01 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
Message-ID: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>

Some context:

https://twitter.com/mentalguy/status/284776872452173824

As someone who knows a lot of people who use Erlang in production (Erlang
has unbounded mailboxes), and the maintainer of my own actor-based
concurrency framework (Celluloid, which started with unbounded mailboxes
and is in the process of moving to bounded ones), I have come to the Hard
Won Knowledge(TM) that unbounded queues/mailboxes/channels are a bad idea.

In terms of production users of these sorts of systems, my personal
experience is that nobody likes unboundedness and most have experienced
some sort of production outage because of it. This isn't just a minor
nitpick. This is the sort of decision that makes or breaks the reliability
of systems under load.

The main problem with unboundedness is that users systems based on
unbounded queues fail to adequately build mechanisms for providing
backpressure into their code. They then start flooding their systems with
messages, and get confused why they're performing so poorly when the answer
is they have a huge backlog of unprocessed messages. Processes overloaded
with too many messages will slow down and grow in memory until they
eventually exhaust system resources and crash.

Adding bounds to a channel doesn't require that sends block, and I think
Rust is doing the Right Thing(TM) here in regard to non-blocking sends and
I would never ask you to change that. There are other options for bounding
channels which don't involve a blocking send though:

1) Drop messages on the floor: This falls into the category of "at most
once" message semantics that actor systems are typically described as
having (although there's a fun discussion about this right now on the friam
mailing list). My personal opinion is that systems that can tolerate the
loss of messages are more robust by design

2) Crash the sender: This works similarly to the above in that it results
in the messages being discarded, but can loop in Erlang-style fault
tolerance to recover from an overloaded system. I definitely find this less
preferable than simply dropping messages on the floor though. This is a
particularly invasive option that I think doesn't translate well to
distributed systems.

3) Make sends to a full channel an error: I'm really not a fan of this
option at all but I'm listing it for completeness. We could make everyone
check every message send for success. Ick. No thanks.

Bounded channels offer a lot of advantages over unbounded ones, IMO.
Fixed-size data structures confer a natural performance advantage over
elastic ones that need to be resized to accomodate growing numbers of
messages. Depending on what data structure you use, you either take an
up-front performance hit to provide variable capacity, or take an invisible
performance hit whenever you hit some cap and need to resize. Adding a
bound makes it easier to reason about the use cases and requirements and
will generally allow you to leverage better data structures (e.g. ring
buffers) that will confer maximum performance.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131218/7cd2615a/attachment.html>

From jack at metajack.im  Wed Dec 18 18:59:19 2013
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 18 Dec 2013 19:59:19 -0700
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
Message-ID: <CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>

> Processes overloaded with too many
> messages will slow down and grow in memory until they eventually exhaust
> system resources and crash.

In Erlang this is true, but Rust semantics are different. Memory is
certainly consumed but there is no mailbox scanning like Erlang nor is
there anything like Erlang's physically separate heaps. There is also
no garbage collection by default. The risk here is unbounded memory
use. The size of the messages waiting on a port does not affect
performance as in other systems (aside from those stemming from lack
of memory).

> 1) Drop messages on the floor: This falls into the category of "at most
> once" message semantics that actor systems are typically described as having
> (although there's a fun discussion about this right now on the friam mailing
> list). My personal opinion is that systems that can tolerate the loss of
> messages are more robust by design

This is unsuitable as a general purpose mechanism. Whether this is
appropriate is highly application specific.

> 2) Crash the sender: This works similarly to the above in that it results in
> the messages being discarded, but can loop in Erlang-style fault tolerance
> to recover from an overloaded system. I definitely find this less preferable
> than simply dropping messages on the floor though. This is a particularly
> invasive option that I think doesn't translate well to distributed systems.

Rust does not have supervisors and failure recovery features that
Erlang has. It would have to grow these for this to be really viable.
If you did this in a callback from a C FFI you'd have to abort the
whole process.

> 3) Make sends to a full channel an error: I'm really not a fan of this
> option at all but I'm listing it for completeness. We could make everyone
> check every message send for success. Ick. No thanks.

What should the default be? This makes the API a lot more complicated.

There is a solution 4, which is the old proto! stuff, which created
bounded protocols, but bitrotted. I think this is probably what you're
really looking for.

Opting into #2 or #3 seems like it might be useful.

I'm not sure I have formed a complete opinion yet, but thought I'd
present some of the counter arguments.

jack.

From pcwalton at mozilla.com  Wed Dec 18 19:07:14 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 18 Dec 2013 19:07:14 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
Message-ID: <52B262E2.5090006@mozilla.com>

On 12/18/13 6:59 PM, Jack Moffitt wrote:
>> 1) Drop messages on the floor: This falls into the category of "at most
>> once" message semantics that actor systems are typically described as having
>> (although there's a fun discussion about this right now on the friam mailing
>> list). My personal opinion is that systems that can tolerate the loss of
>> messages are more robust by design
>
> This is unsuitable as a general purpose mechanism. Whether this is
> appropriate is highly application specific.

I think it's mostly a question of defaults. We can't really drop any UI 
events in Servo, so we need the really-unbounded-queues, with all their 
known problems. But I can definitely believe that some applications 
(servers) want bounded messages with message overflow dropping on the 
floor. So I think we should have both in the language.

The question in my mind is not whether we should have both primitives 
but which should be the default. For this I'm not sure: the 
possibilities (dropping messages, or exploding in memory consumption, or 
introducing subtle deadlocks) are all pretty bad. It may well be that 
dropping the messages is the last bad option, because the last two 
options usually result in a crashed app...

Patrick


From ncm at cantrip.org  Wed Dec 18 19:10:17 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 18 Dec 2013 19:10:17 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
Message-ID: <52B26399.8020104@cantrip.org>

On 12/18/2013 06:29 PM, Tony Arcieri wrote:
>
> Adding bounds to a channel doesn't require that sends block, and I think
> Rust is doing the Right Thing(TM) here in regard to non-blocking sends and
> I would never ask you to change that. There are other options for bounding
> channels which don't involve a blocking send though:
>
> 1) Drop messages on the floor:
> 2) Crash the sender:
> 3) Make sends to a full channel an error: ...

Of course there is little difficulty in providing three different
send primitives, and anyway both (1) and (2) can be trivially
constructed from (3), albeit at prohibitive (i.e. one or two cycles!) 
cost.  I confess that (2) had not occurred to me as a reasonable
alternative.  In Rust I assume it would cleanly terminate the task.

Discussion late into the night suggested that fixing channels (in
both senses) is still very much within the charter of post-0.8
development, and I join the chorus of proponents of this change.
For many applications a one-element channel is the right size.
Probably for practically all uses a compile-time-fixed size is
best, and (thus) suffices for a built-in feature.

Nathan Myers

From jack at metajack.im  Wed Dec 18 19:19:48 2013
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 18 Dec 2013 20:19:48 -0700
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B262E2.5090006@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com>
Message-ID: <CAP7VpsVi2gvnVWiyVPv0x1vJ0GOa1sxLOtnaHTzc-tWbs9ezxg@mail.gmail.com>

>> This is unsuitable as a general purpose mechanism. Whether this is
>> appropriate is highly application specific.
>
>
> I think it's mostly a question of defaults.

I chose my words poorly. I meant that I don't think it's a good
default. Obviously it's a useful tool in many situations.

jack.

From banderson at mozilla.com  Wed Dec 18 19:21:11 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 18 Dec 2013 19:21:11 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
Message-ID: <52B26627.6070905@mozilla.com>

On 12/18/2013 06:59 PM, Jack Moffitt wrote:
>> 3) Make sends to a full channel an error: I'm really not a fan of this
>> option at all but I'm listing it for completeness. We could make everyone
>> check every message send for success. Ick. No thanks.
> What should the default be? This makes the API a lot more complicated.
>
> There is a solution 4, which is the old proto! stuff, which created
> bounded protocols, but bitrotted. I think this is probably what you're
> really looking for.

I do think we should re-explore channel protocols in the future since 
they provide the advantages of never blocking nor allocating on sends - 
the buffers are always exactly the right size. If this strategy panned 
out then it would solve the common complaints about unbounded channels 
(while possibly adding new ones about complexity).

From banderson at mozilla.com  Wed Dec 18 19:29:30 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 18 Dec 2013 19:29:30 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
Message-ID: <52B2681A.4030607@mozilla.com>

On 12/18/2013 06:29 PM, Tony Arcieri wrote:
> Some context:
>
> https://twitter.com/mentalguy/status/284776872452173824
>
> As someone who knows a lot of people who use Erlang in production 
> (Erlang has unbounded mailboxes), and the maintainer of my own 
> actor-based concurrency framework (Celluloid, which started with 
> unbounded mailboxes and is in the process of moving to bounded ones), 
> I have come to the Hard Won Knowledge(TM) that unbounded 
> queues/mailboxes/channels are a bad idea.
>
> In terms of production users of these sorts of systems, my personal 
> experience is that nobody likes unboundedness and most have 
> experienced some sort of production outage because of it. This isn't 
> just a minor nitpick. This is the sort of decision that makes or 
> breaks the reliability of systems under load.
>
> The main problem with unboundedness is that users systems based on 
> unbounded queues fail to adequately build mechanisms for providing 
> backpressure into their code. They then start flooding their systems 
> with messages, and get confused why they're performing so poorly when 
> the answer is they have a huge backlog of unprocessed messages. 
> Processes overloaded with too many messages will slow down and grow in 
> memory until they eventually exhaust system resources and crash.

Is anybody aware of existing analyses of the tradeoffs of bounded vs. 
unbounded channels? I've always considered this a tradeoff between 
unexpected OOM vs. unexpected deadlock (assuming blocking sends). Based 
on some of your other feedback it seems like the tradeoff could also be 
OOM vs. failure or dropped messages.

I'd like to point out that in the standard library our goal is just to 
provide a dead-simple and fast default message passing type. There are 
lots of interesting designs here, but things like disruptor can be done 
outside std.

From ncm at cantrip.org  Wed Dec 18 19:55:25 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 18 Dec 2013 19:55:25 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B262E2.5090006@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com>
Message-ID: <52B26E2D.30107@cantrip.org>

On 12/18/2013 07:07 PM, Patrick Walton wrote:
> (dropping messages, or exploding in memory consumption, or
> introducing subtle deadlocks) are all pretty bad. It may well
 > be that dropping the messages is the last bad option, because
> the last two options usually result in a crashed app...

As I understand it, getting into a state where the channel would
drop messages is a programming error.  In that sense, terminating
the task in such a case amounts to an assertion failure.

In the case of Servo, somebody needs drop excess events
because it makes no sense to queue more user-interface actions
than the user can remember.

Nathan Myers

From kevin at sb.org  Wed Dec 18 20:48:02 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 18 Dec 2013 20:48:02 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B26E2D.30107@cantrip.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
Message-ID: <9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>

On Dec 18, 2013, at 7:55 PM, Nathan Myers <ncm at cantrip.org> wrote:

> On 12/18/2013 07:07 PM, Patrick Walton wrote:
>> (dropping messages, or exploding in memory consumption, or
>> introducing subtle deadlocks) are all pretty bad. It may well
> > be that dropping the messages is the last bad option, because
>> the last two options usually result in a crashed app...
> 
> As I understand it, getting into a state where the channel would
> drop messages is a programming error.  In that sense, terminating
> the task in such a case amounts to an assertion failure.
> 
> In the case of Servo, somebody needs drop excess events
> because it makes no sense to queue more user-interface actions
> than the user can remember.

By that logic, you'd want to drop the oldest unprocessed events, not the newest.

-Kevin

From pcwalton at mozilla.com  Wed Dec 18 21:36:35 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 18 Dec 2013 21:36:35 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>	<52B262E2.5090006@mozilla.com>
	<52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
Message-ID: <52B285E3.8050200@mozilla.com>

On 12/18/13 8:48 PM, Kevin Ballard wrote:

> By that logic, you'd want to drop the oldest unprocessed events, not the newest.

Right.

To reiterate, there is a meta-point here: Blessing any communications 
primitive as the One True Primitive never goes well for high-performance 
code. I think we need multiple choices. The hard decision is what should 
be the default.

Patrick


From kevin at sb.org  Wed Dec 18 22:23:14 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 18 Dec 2013 22:23:14 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B285E3.8050200@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>	<52B262E2.5090006@mozilla.com>
	<52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
Message-ID: <F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>

In my experience using Go, most of the time when I use a channel I don't particularly care about the size, as long as it has a size of at least 1 (to avoid blocking on the send). However, if I do care about the size, usually I want it to be effectively infinite (and I have some code in my IRC bot that uses a separate goroutine in order to implement an infinite channel). Upon occasion I do want an explicitly bounded channel, but, at least in my code, that tends to be rarer than wanting effectively infinite.

My general feeling is that providing both bounded and unbounded channels would be good. Even better would be allowing for different ways of handling bounded channels (e.g. block on send, drop messages, etc.), but I imagine that providing only one type of bounded channel (using block on send if it's full and providing a .try_send() that avoids blocking) would be sufficient (especially as e.g. dropping messages can be implemented on top of this type of channel).

I also believe that unbounded should be the default, because it's the most tolerant type of channel when you don't want to have to think about bounding limits. It also means async send is the default, which I think is a good idea.

-Kevin

On Dec 18, 2013, at 9:36 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 12/18/13 8:48 PM, Kevin Ballard wrote:
> 
>> By that logic, you'd want to drop the oldest unprocessed events, not the newest.
> 
> Right.
> 
> To reiterate, there is a meta-point here: Blessing any communications primitive as the One True Primitive never goes well for high-performance code. I think we need multiple choices. The hard decision is what should be the default.
> 
> Patrick
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From ncm at cantrip.org  Wed Dec 18 22:23:38 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 18 Dec 2013 22:23:38 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B285E3.8050200@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>	<52B262E2.5090006@mozilla.com>
	<52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
Message-ID: <52B290EA.3080906@cantrip.org>

On 12/18/2013 09:36 PM, Patrick Walton wrote:
> On 12/18/13 8:48 PM, Kevin Ballard wrote:
>
>> By that logic, you'd want to drop the oldest unprocessed events, not
>> the newest.

Dropping is dropping. If you prefer to drop old events, pull them off
the channel and drop them fast enough that new events don't spill.

> To reiterate, there is a meta-point here: Blessing any communications
> primitive as the One True Primitive never goes well for high-performance
> code. I think we need multiple choices. The hard decision is what should
> be the default.

It helps to consider what serves as a useful building block.  An
unbounded channel is useless as the basis for a bounded channel.

You can easily code an unbounded channel that implements precisely
the storage-management and ultimate-failure policies that suit
you.  A primitive can't choose correctly, or even enable you to
express your choices without arbitrary limitations or vexing
complexity.

Nathan Myers

From danielmicay at gmail.com  Wed Dec 18 22:49:40 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 19 Dec 2013 01:49:40 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
	<F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
Message-ID: <CA+DvKQJePqd2QjHZ4gs21xgbanYV7c2j4L=oS75Gx+dB8Z8yZQ@mail.gmail.com>

On Thu, Dec 19, 2013 at 1:23 AM, Kevin Ballard <kevin at sb.org> wrote:
> In my experience using Go, most of the time when I use a channel I don't particularly care about the size, as long as it has a size of at least 1 (to avoid blocking on the send). However, if I do care about the size, usually I want it to be effectively infinite (and I have some code in my IRC bot that uses a separate goroutine in order to implement an infinite channel). Upon occasion I do want an explicitly bounded channel, but, at least in my code, that tends to be rarer than wanting effectively infinite.

It's not effectively infinite, because you can run out of memory. The
difference between a bounded queue and an unbounded queue is whether
running out of space blocks or aborts the process. The maximum
capacity doesn't also have to be the minimum capacity - that's just an
optimization used by some specific implementations and doesn't apply
to all bounded channels.

> I also believe that unbounded should be the default, because it's the most tolerant type of channel when you don't want to have to think about bounding limits. It also means async send is the default, which I think is a good idea.
>
> -Kevin

You do have to think about bounding limits. The limits just have to be
externally implemented instead of being enforced by the queue. It's
not a matter of whether send is synchronous or asynchronous but
whether or not the data structure ignores the possibility of running
out of resources.

From ncm at cantrip.org  Wed Dec 18 22:50:45 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 18 Dec 2013 22:50:45 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>	<52B262E2.5090006@mozilla.com>
	<52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
	<F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
Message-ID: <52B29745.2000408@cantrip.org>

On 12/18/2013 10:23 PM, Kevin Ballard wrote:
> In my experience using Go, most of the time when I use a channel I don't particularly care about the size, as long as it has a size of at least 1 (to avoid blocking on the send). However, if I do care about the size, usually I want it to be effectively infinite (and I have some code in my IRC bot that uses a separate goroutine in order to implement an infinite channel). Upon occasion I do want an explicitly bounded channel, but, at least in my code, that tends to be rarer than wanting effectively infinite.

In a working system, "effectively infinite" means the sender uses up
its timeslice before exceeding your latency goal, and the receiver
empties the channel before its timeslice is used up. In a failing 
system, it means unpredictable performance or behavior.

> My general feeling is that providing both bounded and unbounded channels would be good. Even better would be allowing for different ways of handling bounded channels (e.g. block on send, drop messages, etc.), but I imagine that providing only one type of bounded channel (using block on send if it's full and providing a .try_send() that avoids blocking) would be sufficient (especially as e.g. dropping messages can be implemented on top of this type of channel).

More choice is always better, except when you have limited resources.
We always have limited resources, so we consider priorities.

> I also believe that unbounded should be the default, because it's the most tolerant type of channel when you don't want to have to think about bounding limits. It also means async send is the default, which I think is a good idea.

There are different definitions of tolerant, as there are of simplicity.
Usually it's better to fail in ways that are easy to understand and fix.
This is the same lesson we learn from garbage-collected memory systems.

Nathan Myers

> On Dec 18, 2013, at 9:36 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
>> On 12/18/13 8:48 PM, Kevin Ballard wrote:
>>
>>> By that logic, you'd want to drop the oldest unprocessed events, not the newest.
>>
>> Right.
>>
>> To reiterate, there is a meta-point here: Blessing any communications primitive as the One True Primitive never goes well for high-performance code. I think we need multiple choices. The hard decision is what should be the default.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>


From carter.schonwald at gmail.com  Wed Dec 18 22:54:40 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 19 Dec 2013 01:54:40 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B285E3.8050200@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
Message-ID: <CAHYVw0yDdJPaA4xGzxLyXwh51eqK=o9dFyU4Vg2nbBikOn_kxw@mail.gmail.com>

maybe i'm not understanding things, but is there any reason why the
standard library couldn't provide both types of channels? Its really really
not a "which should be the default", but two abstractions/data structures
which are very very different in when they're used in practice!

Looking at the docs for
http://static.rust-lang.org/doc/master/std/comm/index.html, a send type
like the following (for no wait/ not blocking) would make sense for bounded
channels (the following type is pseudo code, i'm still learning rust so
this is slightly wrong likely )

*fn sendBoundedNoWait(&self, t: T) -> Result<int,T>*,

 so that the send for a bounded channel, on success you know the current
size of the channel, and on failure (ie you can't send it right away, so
you'd have to wait otherwise) you get back the value you were trying to
send. something like
*fn sendBoundedNoWait(&self, t: T) -> Result<int,(int,T)>*
 because certain channel models you may have to wait even if the queue
isn't full, or something like that, so the congestion should be part of the
info in a failed send?  And the normal send t would block when the channel
queue is full perhaps, to retry once theres a spot?

point being, bounded channels don't have to be blocking, but the non
blocking api variant needs to have an API that provides enough information
that the sender can handle that error/retry logic.

I work with and have the pleasure of knowing a number of people who build
some pretty nontrivial dist systems. They all  explain to me (on multiple
occasions) is that unbounded queues (in the context of asynchronous
messages) are a pain / nightmare in terms of debugging the composite
system, and in providing good performance characteristics under heavy
loads. If you don't get feedback that you're producing far far faster than
can be consumed, thats a bug! No back pressure is a scary thing problem to
have if you're processing terabytes of real time event data a day.

With a bounded channel, you're actually forced to have a policy to deal
with the issue of "i'm producing more than is being consumed", and when you
have a composed system of channels, it becomes possible to debug throughput
issues because of this, rather than wondering "why is there a space leak".
 This idea is often called backflow / backpressure etc  by many folks.

with unbounded channels, you don't have a way of building a policy for how
to handle heavy workloads, and then any latency sensitive computation turns
into a high latency space leak.  Unbounded channels are definitely a bit
easier to work in terms of "oh, i can send a message to another computation
running in parallel and it just works", but you very very easily can
manufacture examples where this blows up in your face wrt performance
characteristics and space usage.

point being, BOTH are valuable, and they're fundamentally very different
critters in terms of when they're appropriate. Talking about which should
be the default is a pretty dangerous thing :).


That said if you have to choose a "default", if the "spirit of rust" is
about good performance with predictable resource usage characteristics,
bounded channels plus something like the straw man non blocking
*sendBoundedNoWait* as part of the api.

that said, there shouldn't be a default, they're not the same thing at all.

cheers
-Carter


On Thu, Dec 19, 2013 at 12:36 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/18/13 8:48 PM, Kevin Ballard wrote:
>
>  By that logic, you'd want to drop the oldest unprocessed events, not the
>> newest.
>>
>
> Right.
>
> To reiterate, there is a meta-point here: Blessing any communications
> primitive as the One True Primitive never goes well for high-performance
> code. I think we need multiple choices. The hard decision is what should be
> the default.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/1feae94f/attachment.html>

From kevin at sb.org  Thu Dec 19 00:57:15 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 00:57:15 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJePqd2QjHZ4gs21xgbanYV7c2j4L=oS75Gx+dB8Z8yZQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
	<F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
	<CA+DvKQJePqd2QjHZ4gs21xgbanYV7c2j4L=oS75Gx+dB8Z8yZQ@mail.gmail.com>
Message-ID: <59DA99C7-6CF8-4F64-A1DA-C41C30F3002B@sb.org>

On Dec 18, 2013, at 10:49 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Thu, Dec 19, 2013 at 1:23 AM, Kevin Ballard <kevin at sb.org> wrote:
>> In my experience using Go, most of the time when I use a channel I don't particularly care about the size, as long as it has a size of at least 1 (to avoid blocking on the send). However, if I do care about the size, usually I want it to be effectively infinite (and I have some code in my IRC bot that uses a separate goroutine in order to implement an infinite channel). Upon occasion I do want an explicitly bounded channel, but, at least in my code, that tends to be rarer than wanting effectively infinite.
> 
> It's not effectively infinite, because you can run out of memory. The
> difference between a bounded queue and an unbounded queue is whether
> running out of space blocks or aborts the process. The maximum
> capacity doesn't also have to be the minimum capacity - that's just an
> optimization used by some specific implementations and doesn't apply
> to all bounded channels.
> 
>> I also believe that unbounded should be the default, because it's the most tolerant type of channel when you don't want to have to think about bounding limits. It also means async send is the default, which I think is a good idea.
>> 
>> -Kevin
> 
> You do have to think about bounding limits. The limits just have to be
> externally implemented instead of being enforced by the queue. It's
> not a matter of whether send is synchronous or asynchronous but
> whether or not the data structure ignores the possibility of running
> out of resources.

Running out of memory can certainly be a problem with unbounded channels, but it's not a problem unique to unbounded channels. I'm not sure why it deserves so much extra thought here to the point that we may default to bounded. We don't default to bounded in other potential resource-exhaustion scenarios. For example, ~[T] doesn't default to having a maximum capacity that cannot be exceeded. The only maximum there is the limits of memory. I can write a loop that calls .push() on a ~[T] until I exhaust all my resources, but nobody thinks that's a serious issue.

There is definitely a use-case for bounded channels. But I don't think it should be the default. If bounded channels are the default, then everyone who uses a channel needs to have to think about what an appropriate bound is, and in practice will probably just throw some small number at the channel and call it a day. I expect most uses of channels aren't going to grow the channel infinitely, and as such there's no need to require the programmer to try and come up with a bound for it, especially because if they come up with a bound that's too low then it will cause problems (e.g. performance problems, if the failure case is blocking on send).

If the channel does have the potential to grow infinitely, then the programmer needs to recognize this case and handle it explicitly (e.g. by opting into a bounded channel and determining an appropriate bound to use). No default behavior will handle the need for bounded channels correctly for everyone.

-Kevin

From ncm at cantrip.org  Thu Dec 19 01:52:03 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Thu, 19 Dec 2013 01:52:03 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <59DA99C7-6CF8-4F64-A1DA-C41C30F3002B@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
	<F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
	<CA+DvKQJePqd2QjHZ4gs21xgbanYV7c2j4L=oS75Gx+dB8Z8yZQ@mail.gmail.com>
	<59DA99C7-6CF8-4F64-A1DA-C41C30F3002B@sb.org>
Message-ID: <52B2C1C3.8040106@cantrip.org>

On 12/19/2013 12:57 AM, Kevin Ballard wrote:

> Running out of memory can certainly be a problem with unbounded channels, but it's not a problem unique to unbounded channels. I'm not sure why it deserves so much extra thought here to the point that we may default to bounded. We don't default to bounded in other potential resource-exhaustion scenarios. For example, ~[T] doesn't default to having a maximum capacity that cannot be exceeded. The only maximum there is the limits of memory. I can write a loop that calls .push() on a ~[T] until I exhaust all my resources, but nobody thinks that's a serious issue.

This is a reasonable question.  A channel should be able to handle an
indefinitely large amount of traffic over its lifetime.  In the absence
of performance considerations, there is no reason for its capacity to
be more than one.  A channel with a capacity of more than one supports
pipelining, enabling coarser-grained work units that reduce scheduling
overhead.  As the capacity grows, that benefit shrinks to zero, while
system latency may grow without bound.

By contrast, there is nothing inherently time-related about ~[T].

I wonder... maybe filling in the last slot in a channel should also
make the sending thread yield, and if the channel is still full when
the thread runs again, something interesting is allowed to happen --
by default, nothing or task termination, but you can provide a
callback that might grow the channel, or push back upstream, or
what-have-you. Then there's only one kind of channel seen by
send and recv, maximally optimized, that does whatever fool thing
you want, and only ever costs extra at a scheduling boundary when
you can afford it.

Probably this idea is incompatible with 1:1 threads, or something.

Nathan Myers

From pnkfelix at mozilla.com  Thu Dec 19 03:03:31 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Thu, 19 Dec 2013 12:03:31 +0100
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
	<5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
Message-ID: <52B2D283.7080102@mozilla.com>

rust-dev-

 From reading the article, I thought the point was that a universal 
server could be deployed and initiated before the actual service it 
would offer had actually been *written*.

I agree with Kevin that the exercise would be pretty much pointless for 
Rust, unless you enjoy writing interpreters and/or JIT compilers and 
want to implement one for Rust.  (I know we had rusti at one point, keep 
reading...)

In particular, I assume this works in Erlang because Erlang programs are 
compiled to an interpreted bytecode representation (for an abstract BEAM 
machine) that can then be JIT compiled for the target architecture when 
it is run.

But Rust does not not have an architecture independent target code 
representation; I do not think LLVM bitcode counts, at least not the 
kind we generate, since I believe that has assumptions about the target 
architecture baked into the generated code.

Cheers,
-Felix

On 18/12/2013 19:17, Kevin Ballard wrote:
> That's cute, but I don't really understand the point. The sample 
> program he gave:
>
> test() ->
>     Pid = spawn(fun universal_server/0),
>     Pid ! {become, fun factorial_server/0},
>     Pid ! {self(), 50},
>     receive
>         X -> X
>     end.
>
> will behave identically if you remove universal_server from the equation:
>
> test() ->
>     Pid = spawn(fun factorial_server/0),
>     Pid ! {self(), 50},
>     receive
>         X -> X
>     end.
>
> The whole point of universal_server, AFAICT, is to just demonstrate 
> something clever about Erlang's task communication primitives. The 
> equivalent in Rust would require passing channels back and forth, 
> because factorial_server needs to receive different data than 
> universal_server. The only alternative that I can think of would be to 
> have a channel of ~Any+Send objects, which isn't very nice.
>
> To that end, I don't see the benefit of trying to reproduce the same 
> functionality in Rust, because it's just not a good fit for Rust's 
> task communication primitives.
>
> -Kevin
>
> On Dec 18, 2013, at 6:26 AM, Benjamin Striegel <ben.striegel at gmail.com 
> <mailto:ben.striegel at gmail.com>> wrote:
>
>> Hello rusties, I was reading a blog post by Joe Armstrong recently in 
>> which he shows off his favorite tiny Erlang program, called the 
>> Universal Server:
>>
>> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
>>
>> I know that Rust doesn't have quite the same task communication 
>> primitives as Erlang, but I'd be interested to see what the Rust 
>> equivalent of this program would look like if anyone's up to the task 
>> of translating it.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/0ab182d5/attachment.html>

From ncm at cantrip.org  Thu Dec 19 04:01:14 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Thu, 19 Dec 2013 04:01:14 -0800
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <52B2D283.7080102@mozilla.com>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
	<5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
	<52B2D283.7080102@mozilla.com>
Message-ID: <52B2E00A.9090005@cantrip.org>

So, Rust is incompatible with dlopen()?

Nathan Myers

On 12/19/2013 03:03 AM, Felix S. Klock II wrote:
> rust-dev-
>
>  From reading the article, I thought the point was that a universal
> server could be deployed and initiated before the actual service it
> would offer had actually been *written*.
>
> I agree with Kevin that the exercise would be pretty much pointless for
> Rust, unless you enjoy writing interpreters and/or JIT compilers and
> want to implement one for Rust.  (I know we had rusti at one point, keep
> reading...)
>
> In particular, I assume this works in Erlang because Erlang programs are
> compiled to an interpreted bytecode representation (for an abstract BEAM
> machine) that can then be JIT compiled for the target architecture when
> it is run.
>
> But Rust does not not have an architecture independent target code
> representation; I do not think LLVM bitcode counts, at least not the
> kind we generate, since I believe that has assumptions about the target
> architecture baked into the generated code.
>
> Cheers,
> -Felix
>
> On 18/12/2013 19:17, Kevin Ballard wrote:
>> That's cute, but I don't really understand the point. The sample
>> program he gave:
>>
>> test() ->
>>     Pid = spawn(fun universal_server/0),
>>     Pid ! {become, fun factorial_server/0},
>>     Pid ! {self(), 50},
>>     receive
>>         X -> X
>>     end.
>>
>> will behave identically if you remove universal_server from the equation:
>>
>> test() ->
>>     Pid = spawn(fun factorial_server/0),
>>     Pid ! {self(), 50},
>>     receive
>>         X -> X
>>     end.
>>
>> The whole point of universal_server, AFAICT, is to just demonstrate
>> something clever about Erlang's task communication primitives. The
>> equivalent in Rust would require passing channels back and forth,
>> because factorial_server needs to receive different data than
>> universal_server. The only alternative that I can think of would be to
>> have a channel of ~Any+Send objects, which isn't very nice.
>>
>> To that end, I don't see the benefit of trying to reproduce the same
>> functionality in Rust, because it's just not a good fit for Rust's
>> task communication primitives.
>>
>> -Kevin
>>
>> On Dec 18, 2013, at 6:26 AM, Benjamin Striegel <ben.striegel at gmail.com
>> <mailto:ben.striegel at gmail.com>> wrote:
>>
>>> Hello rusties, I was reading a blog post by Joe Armstrong recently in
>>> which he shows off his favorite tiny Erlang program, called the
>>> Universal Server:
>>>
>>> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
>>>
>>> I know that Rust doesn't have quite the same task communication
>>> primitives as Erlang, but I'd be interested to see what the Rust
>>> equivalent of this program would look like if anyone's up to the task
>>> of translating it.


From bjzaba at yahoo.com.au  Thu Dec 19 04:11:31 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 19 Dec 2013 23:11:31 +1100
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <52B2D283.7080102@mozilla.com>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>
	<5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>
	<52B2D283.7080102@mozilla.com>
Message-ID: <AFE9909F-508C-4641-84F5-033832E73631@yahoo.com.au>


On 19 Dec 2013, at 10:03 pm, Felix S. Klock II <pnkfelix at mozilla.com> wrote:

> rust-dev-
> 
> From reading the article, I thought the point was that a universal server could be deployed and initiated before the actual service it would offer had actually been *written*.

Ah, that makes more sense - that definitely fits in with the Erlang philosophy. Tricky to do in a language like Rust.

~Brendan

From pnkfelix at mozilla.com  Thu Dec 19 04:36:59 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Thu, 19 Dec 2013 13:36:59 +0100
Subject: [rust-dev] Joe Armstrong's "universal server"
In-Reply-To: <52B2E00A.9090005@cantrip.org>
References: <CAAvrL-mpsy2Bvu1165SHWiJzppdFPXE-02PWhA1URK+h0pyWzw@mail.gmail.com>	<5668AAFE-ED22-4E77-BCC1-24184EA9A44A@sb.org>	<52B2D283.7080102@mozilla.com>
	<52B2E00A.9090005@cantrip.org>
Message-ID: <52B2E86B.1080202@mozilla.com>

That is not what I was saying.

I was assuming a network of mixed target processor architectures.

If you have a network of machines with uniform architectures (and 
same/compatible OS versions etc), then that simplifies the problem here.

-Felix

On 19/12/2013 13:01, Nathan Myers wrote:
> So, Rust is incompatible with dlopen()?
>
> Nathan Myers
>
> On 12/19/2013 03:03 AM, Felix S. Klock II wrote:
>> rust-dev-
>>
>>  From reading the article, I thought the point was that a universal
>> server could be deployed and initiated before the actual service it
>> would offer had actually been *written*.
>>
>> I agree with Kevin that the exercise would be pretty much pointless for
>> Rust, unless you enjoy writing interpreters and/or JIT compilers and
>> want to implement one for Rust.  (I know we had rusti at one point, keep
>> reading...)
>>
>> In particular, I assume this works in Erlang because Erlang programs are
>> compiled to an interpreted bytecode representation (for an abstract BEAM
>> machine) that can then be JIT compiled for the target architecture when
>> it is run.
>>
>> But Rust does not not have an architecture independent target code
>> representation; I do not think LLVM bitcode counts, at least not the
>> kind we generate, since I believe that has assumptions about the target
>> architecture baked into the generated code.
>>
>> Cheers,
>> -Felix
>>
>> On 18/12/2013 19:17, Kevin Ballard wrote:
>>> That's cute, but I don't really understand the point. The sample
>>> program he gave:
>>>
>>> test() ->
>>>     Pid = spawn(fun universal_server/0),
>>>     Pid ! {become, fun factorial_server/0},
>>>     Pid ! {self(), 50},
>>>     receive
>>>         X -> X
>>>     end.
>>>
>>> will behave identically if you remove universal_server from the 
>>> equation:
>>>
>>> test() ->
>>>     Pid = spawn(fun factorial_server/0),
>>>     Pid ! {self(), 50},
>>>     receive
>>>         X -> X
>>>     end.
>>>
>>> The whole point of universal_server, AFAICT, is to just demonstrate
>>> something clever about Erlang's task communication primitives. The
>>> equivalent in Rust would require passing channels back and forth,
>>> because factorial_server needs to receive different data than
>>> universal_server. The only alternative that I can think of would be to
>>> have a channel of ~Any+Send objects, which isn't very nice.
>>>
>>> To that end, I don't see the benefit of trying to reproduce the same
>>> functionality in Rust, because it's just not a good fit for Rust's
>>> task communication primitives.
>>>
>>> -Kevin
>>>
>>> On Dec 18, 2013, at 6:26 AM, Benjamin Striegel <ben.striegel at gmail.com
>>> <mailto:ben.striegel at gmail.com>> wrote:
>>>
>>>> Hello rusties, I was reading a blog post by Joe Armstrong recently in
>>>> which he shows off his favorite tiny Erlang program, called the
>>>> Universal Server:
>>>>
>>>> http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html
>>>>
>>>> I know that Rust doesn't have quite the same task communication
>>>> primitives as Erlang, but I'd be interested to see what the Rust
>>>> equivalent of this program would look like if anyone's up to the task
>>>> of translating it.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com


From danielmicay at gmail.com  Thu Dec 19 04:42:38 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 19 Dec 2013 07:42:38 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <59DA99C7-6CF8-4F64-A1DA-C41C30F3002B@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAP7VpsX651yHG+djP8c7CK0Uxs6sy7y+Y-F9ZXjtZE3p2On5bA@mail.gmail.com>
	<52B262E2.5090006@mozilla.com> <52B26E2D.30107@cantrip.org>
	<9BDB071B-0830-4FDB-B1E6-BDCBE759C6CF@sb.org>
	<52B285E3.8050200@mozilla.com>
	<F35A911A-293A-440F-87BA-0F21FAC2F12F@sb.org>
	<CA+DvKQJePqd2QjHZ4gs21xgbanYV7c2j4L=oS75Gx+dB8Z8yZQ@mail.gmail.com>
	<59DA99C7-6CF8-4F64-A1DA-C41C30F3002B@sb.org>
Message-ID: <CA+DvKQ+u1CfbBvKHYDdFDy61FPcKD8pYpwm_QNarCoJ2bQzxJg@mail.gmail.com>

On Thu, Dec 19, 2013 at 3:57 AM, Kevin Ballard <kevin at sb.org> wrote:
>
> Running out of memory can certainly be a problem with unbounded channels, but it's not a problem unique to unbounded channels. I'm not sure why it deserves so much extra thought here to the point that we may default to bounded. We don't default to bounded in other potential resource-exhaustion scenarios. For example, ~[T] doesn't default to having a maximum capacity that cannot be exceeded. The only maximum there is the limits of memory. I can write a loop that calls .push() on a ~[T] until I exhaust all my resources, but nobody thinks that's a serious issue.
>
> There is definitely a use-case for bounded channels. But I don't think it should be the default. If bounded channels are the default, then everyone who uses a channel needs to have to think about what an appropriate bound is, and in practice will probably just throw some small number at the channel and call it a day. I expect most uses of channels aren't going to grow the channel infinitely, and as such there's no need to require the programmer to try and come up with a bound for it, especially because if they come up with a bound that's too low then it will cause problems (e.g. performance problems, if the failure case is blocking on send).
>
> If the channel does have the potential to grow infinitely, then the programmer needs to recognize this case and handle it explicitly (e.g. by opting into a bounded channel and determining an appropriate bound to use). No default behavior will handle the need for bounded channels correctly for everyone.
>
> -Kevin

Any producer/consumer situation where the input isn't limited can
easily exhaust resources with an unbounded channel if the producer is
given more CPU time than the consumer, or runs at a higher rate.

From jfager at gmail.com  Thu Dec 19 06:31:54 2013
From: jfager at gmail.com (Jason Fager)
Date: Thu, 19 Dec 2013 09:31:54 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
Message-ID: <CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>

I work on a system that handles 10s of billions of events per day, and we
do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
in-memory queues aren't, they just have a bound you have no direct control
over and that blows up the world when its hit.

The only reason to have a queue size greater than 1 is to handle spikes in
the producer, short outages in the consumer, or a bit of out-of-phaseness
between producers and consumers.  If your consumers habitually can't keep
up with your producers, you're screwed regardless, but unbounded queues
make your problem grow from simply being 'consumer can't keep up' to
'consumer can't keep up, I'm OOMing, and I just lost a boatload of
messages'. If the only option that's available are unbounded queues, there
are going to be a lot of explicit semaphores sitting around in production
Rust code.

I would also hope that Rust doesn't decide to silently drop messages on the
floor.  It's very true that systems that can tolerate dropped messages are
more robust, but not all messages are created equal, and not all messages
can just be dropped (i.e., if they come from a 3rd party).  I need to have
control over what happens to a message that I can't send, whether that
means slow-pathing it to something on-disk, passing an error back to my
source, or just deciding to drop it.

The twitter conversation has discussion of blocking sends leading to
deadlocks:  yes, blocking indefinitely is also bad, so don't do that.  If
it's blocking it should have a timeout, or as others have mentioned you can
keep the sends non-blocking and just have them fail if the queue is full.




On Wed, Dec 18, 2013 at 9:29 PM, Tony Arcieri <bascule at gmail.com> wrote:

> Some context:
>
> https://twitter.com/mentalguy/status/284776872452173824
>
> As someone who knows a lot of people who use Erlang in production (Erlang
> has unbounded mailboxes), and the maintainer of my own actor-based
> concurrency framework (Celluloid, which started with unbounded mailboxes
> and is in the process of moving to bounded ones), I have come to the Hard
> Won Knowledge(TM) that unbounded queues/mailboxes/channels are a bad idea.
>
> In terms of production users of these sorts of systems, my personal
> experience is that nobody likes unboundedness and most have experienced
> some sort of production outage because of it. This isn't just a minor
> nitpick. This is the sort of decision that makes or breaks the reliability
> of systems under load.
>
> The main problem with unboundedness is that users systems based on
> unbounded queues fail to adequately build mechanisms for providing
> backpressure into their code. They then start flooding their systems with
> messages, and get confused why they're performing so poorly when the answer
> is they have a huge backlog of unprocessed messages. Processes overloaded
> with too many messages will slow down and grow in memory until they
> eventually exhaust system resources and crash.
>
> Adding bounds to a channel doesn't require that sends block, and I think
> Rust is doing the Right Thing(TM) here in regard to non-blocking sends and
> I would never ask you to change that. There are other options for bounding
> channels which don't involve a blocking send though:
>
> 1) Drop messages on the floor: This falls into the category of "at most
> once" message semantics that actor systems are typically described as
> having (although there's a fun discussion about this right now on the friam
> mailing list). My personal opinion is that systems that can tolerate the
> loss of messages are more robust by design
>
> 2) Crash the sender: This works similarly to the above in that it results
> in the messages being discarded, but can loop in Erlang-style fault
> tolerance to recover from an overloaded system. I definitely find this less
> preferable than simply dropping messages on the floor though. This is a
> particularly invasive option that I think doesn't translate well to
> distributed systems.
>
> 3) Make sends to a full channel an error: I'm really not a fan of this
> option at all but I'm listing it for completeness. We could make everyone
> check every message send for success. Ick. No thanks.
>
> Bounded channels offer a lot of advantages over unbounded ones, IMO.
> Fixed-size data structures confer a natural performance advantage over
> elastic ones that need to be resized to accomodate growing numbers of
> messages. Depending on what data structure you use, you either take an
> up-front performance hit to provide variable capacity, or take an invisible
> performance hit whenever you hit some cap and need to resize. Adding a
> bound makes it easier to reason about the use cases and requirements and
> will generally allow you to leverage better data structures (e.g. ring
> buffers) that will confer maximum performance.
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/74c8d881/attachment.html>

From pcwalton at mozilla.com  Thu Dec 19 08:38:42 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 19 Dec 2013 08:38:42 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
Message-ID: <52B32112.2070800@mozilla.com>

On 12/19/13 6:31 AM, Jason Fager wrote:
> I work on a system that handles 10s of billions of events per day, and
> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
> in-memory queues aren't, they just have a bound you have no direct
> control over and that blows up the world when its hit.
>
> The only reason to have a queue size greater than 1 is to handle spikes
> in the producer, short outages in the consumer, or a bit of
> out-of-phaseness between producers and consumers.

Well, also parallelism.

Patrick


From corey at octayn.net  Thu Dec 19 09:09:38 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 19 Dec 2013 12:09:38 -0500
Subject: [rust-dev] pkgid changes
Message-ID: <CA++BO6T32f3_Ge3ZAKCPBiykQ8RNLsG6ibacZUhB0yQUPoJ8Pw@mail.gmail.com>

Hey all,

#11041 just landed, which changes the pkgid attribute to crate_id.
It's a very straightforward transition, but probably inconvenient,
especially for the rust-ci users. With it also landed the
--crate-name, --crate-id, and --crate-file-name flags to rustc, which
will print out those attributes about the crate.

From jfager at gmail.com  Thu Dec 19 10:04:00 2013
From: jfager at gmail.com (Jason Fager)
Date: Thu, 19 Dec 2013 13:04:00 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B32112.2070800@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
Message-ID: <CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>

Okay, parallelism, of course, and I'm sure others.  Bad use of the word
'only'.  The point is that if your consumers aren't keeping up with your
producers, you're screwed anyways, and growing the queue indefinitely isn't
a way to get around that.  Growing queues should only serve specific
purposes and make it easy to apply back pressure when the assumptions
behind those purposes go awry.


On Thursday, December 19, 2013, Patrick Walton wrote:

> On 12/19/13 6:31 AM, Jason Fager wrote:
>
>> I work on a system that handles 10s of billions of events per day, and
>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>> in-memory queues aren't, they just have a bound you have no direct
>> control over and that blows up the world when its hit.
>>
>> The only reason to have a queue size greater than 1 is to handle spikes
>> in the producer, short outages in the consumer, or a bit of
>> out-of-phaseness between producers and consumers.
>>
>
> Well, also parallelism.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/1c1364fa/attachment.html>

From kevin at sb.org  Thu Dec 19 10:23:30 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 10:23:30 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
Message-ID: <409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>

Here?s an example from where I use an infinite queue.

I have an IRC bot, written in Go. The incoming network traffic of this bot is handled in one goroutine, which parses each line into its components, and enqueues the result on a channel. The channel is very deliberately made infinite (via a separate goroutine that stores the infinite buffer in a local slice). The reason it?s infinite is because the bot needs to be resilient against the case where either the consumer unexpectedly blocks, or the network traffic spikes. The general assumption is that, under normal conditions, the consumer will always be able to keep up with the producer (as the producer is based on network traffic and not e.g. a tight CPU loop generating messages as fast as possible). Backpressure makes no sense here, as you cannot put backpressure on the network short of letting the socket buffer fill up, and letting the socket buffer fill up with cause the IRC network to disconnect you. So the overriding goal here is to prevent network disconnects, while assuming that the consumer will be able to catch up if it ever gets behind.

This particular use case very explicitly wants a dynamically-sized infinite channel. I suppose an absurdly large channel would be acceptable, because if the consumer ever gets e.g. 100,000 lines behind then it?s in trouble already, but I?d rather not have the memory overhead of a statically-allocated gigantic channel buffer.

-Kevin

On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:

> Okay, parallelism, of course, and I'm sure others.  Bad use of the word 'only'.  The point is that if your consumers aren't keeping up with your producers, you're screwed anyways, and growing the queue indefinitely isn't a way to get around that.  Growing queues should only serve specific purposes and make it easy to apply back pressure when the assumptions behind those purposes go awry.
> 
> 
> On Thursday, December 19, 2013, Patrick Walton wrote:
> On 12/19/13 6:31 AM, Jason Fager wrote:
> I work on a system that handles 10s of billions of events per day, and
> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
> in-memory queues aren't, they just have a bound you have no direct
> control over and that blows up the world when its hit.
> 
> The only reason to have a queue size greater than 1 is to handle spikes
> in the producer, short outages in the consumer, or a bit of
> out-of-phaseness between producers and consumers.
> 
> Well, also parallelism.
> 
> Patrick
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/4c5c6b6f/attachment-0001.html>

From matthieu.monrocq at gmail.com  Thu Dec 19 10:25:50 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Thu, 19 Dec 2013 19:25:50 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
Message-ID: <CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>

On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:

> Here?s an example from where I use an infinite queue.
>
> I have an IRC bot, written in Go. The incoming network traffic of this bot
> is handled in one goroutine, which parses each line into its components,
> and enqueues the result on a channel. The channel is very deliberately made
> infinite (via a separate goroutine that stores the infinite buffer in a
> local slice). The reason it?s infinite is because the bot needs to be
> resilient against the case where either the consumer unexpectedly blocks,
> or the network traffic spikes. The general assumption is that, under normal
> conditions, the consumer will always be able to keep up with the producer
> (as the producer is based on network traffic and not e.g. a tight CPU loop
> generating messages as fast as possible). Backpressure makes no sense here,
> as you cannot put backpressure on the network short of letting the socket
> buffer fill up, and letting the socket buffer fill up with cause the IRC
> network to disconnect you. So the overriding goal here is to prevent
> network disconnects, while assuming that the consumer will be able to catch
> up if it ever gets behind.
>
> This particular use case very explicitly wants a dynamically-sized
> infinite channel. I suppose an absurdly large channel would be acceptable,
> because if the consumer ever gets e.g. 100,000 lines behind then it?s in
> trouble already, but I?d rather not have the memory overhead of a
> statically-allocated gigantic channel buffer.
>

I feel the need to point out that the producer could locally queue the
messages before sending over the channel if it were bounded.


>
> -Kevin
>
> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>
> Okay, parallelism, of course, and I'm sure others.  Bad use of the word
> 'only'.  The point is that if your consumers aren't keeping up with your
> producers, you're screwed anyways, and growing the queue indefinitely isn't
> a way to get around that.  Growing queues should only serve specific
> purposes and make it easy to apply back pressure when the assumptions
> behind those purposes go awry.
>
>
> On Thursday, December 19, 2013, Patrick Walton wrote:
>
>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>
>>> I work on a system that handles 10s of billions of events per day, and
>>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>>> in-memory queues aren't, they just have a bound you have no direct
>>> control over and that blows up the world when its hit.
>>>
>>> The only reason to have a queue size greater than 1 is to handle spikes
>>> in the producer, short outages in the consumer, or a bit of
>>> out-of-phaseness between producers and consumers.
>>>
>>
>> Well, also parallelism.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/b1883e3b/attachment.html>

From kevin at sb.org  Thu Dec 19 10:33:06 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 10:33:06 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
Message-ID: <5B09CF9C-4622-429E-A562-6D1B20C19DB4@sb.org>

On Dec 19, 2013, at 10:25 AM, Matthieu Monrocq <matthieu.monrocq at gmail.com> wrote:

> On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:
> Here?s an example from where I use an infinite queue.
> 
> I have an IRC bot, written in Go. The incoming network traffic of this bot is handled in one goroutine, which parses each line into its components, and enqueues the result on a channel. The channel is very deliberately made infinite (via a separate goroutine that stores the infinite buffer in a local slice). The reason it?s infinite is because the bot needs to be resilient against the case where either the consumer unexpectedly blocks, or the network traffic spikes. The general assumption is that, under normal conditions, the consumer will always be able to keep up with the producer (as the producer is based on network traffic and not e.g. a tight CPU loop generating messages as fast as possible). Backpressure makes no sense here, as you cannot put backpressure on the network short of letting the socket buffer fill up, and letting the socket buffer fill up with cause the IRC network to disconnect you. So the overriding goal here is to prevent network disconnects, while assuming that the consumer will be able to catch up if it ever gets behind.
> 
> This particular use case very explicitly wants a dynamically-sized infinite channel. I suppose an absurdly large channel would be acceptable, because if the consumer ever gets e.g. 100,000 lines behind then it?s in trouble already, but I?d rather not have the memory overhead of a statically-allocated gigantic channel buffer.
> 
> I feel the need to point out that the producer could locally queue the messages before sending over the channel if it were bounded.

No it can?t. Most of the time, the producer is blocked waiting to read from the socket. If it?s locally queued the messages, and the channel empties out, the producer will still be blocked on the socket and won?t be able to send any of the queued messages.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/8eab89bd/attachment.html>

From matthieu.monrocq at gmail.com  Thu Dec 19 10:38:54 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Thu, 19 Dec 2013 19:38:54 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
Message-ID: <CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>

Also working in a distributed system, I cannot emphasize enough how back
pressure is essential.

With back pressure, you offer the producer a chance to react: it can decide
to drop the message, send it over another channel, keep it around for
later, etc...

Furthermore, it is relatively easy to build an unbounded channel over a
bounded one: just have the producer queue things. Depending on whether
sequencing from multiple producers is important or not, this queue can be
either shared or producer-local, with relative ease.


Regarding the various behaviors that may be implemented, most behaviors can
actually be implemented outside of the channel implementation:

+ dropping the message can be implemented on producer side: if it cannot
queue, it just goes on
+ crashing is similar: if it cannot queue, crash
+ blocking is generally a good idea, but if a timed-wait primitive exists
then I imagine an infinite (or close enough) duration would be sufficient


So it might be more interesting to reason in terms of primitives, and those
might be more methods than types (hopefully):

(1) immediate queueing (returning an error), a special case of time-bound
queueing which may be slightly more efficient
(2) time-bound queueing (returning an error after the timeout)
(3) immediate + exchange with head (in which case the producer also locally
acts as a consumer, this might be tricky to pull off efficiently on Single
Consumer queues)
(4) immediate + atomic subscription to "place has been freed" event in case
of full-queue

(Note: (4) somehow implies a dual channel, if you have a MPSC a
back-channel SPMC is created to dispatch the "space available"
notifications... which can be a simple counter, obviously; this
back-channel must be "select"-able so that producers that usually block on
other stuff can use a "space available" event to unblock)

I cannot see another interesting primitive, at the moment.

-- Matthieu


On Thu, Dec 19, 2013 at 7:25 PM, Matthieu Monrocq <
matthieu.monrocq at gmail.com> wrote:

>
>
>
> On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> Here?s an example from where I use an infinite queue.
>>
>> I have an IRC bot, written in Go. The incoming network traffic of this
>> bot is handled in one goroutine, which parses each line into its
>> components, and enqueues the result on a channel. The channel is very
>> deliberately made infinite (via a separate goroutine that stores the
>> infinite buffer in a local slice). The reason it?s infinite is because the
>> bot needs to be resilient against the case where either the consumer
>> unexpectedly blocks, or the network traffic spikes. The general assumption
>> is that, under normal conditions, the consumer will always be able to keep
>> up with the producer (as the producer is based on network traffic and not
>> e.g. a tight CPU loop generating messages as fast as possible).
>> Backpressure makes no sense here, as you cannot put backpressure on the
>> network short of letting the socket buffer fill up, and letting the socket
>> buffer fill up with cause the IRC network to disconnect you. So the
>> overriding goal here is to prevent network disconnects, while assuming that
>> the consumer will be able to catch up if it ever gets behind.
>>
>> This particular use case very explicitly wants a dynamically-sized
>> infinite channel. I suppose an absurdly large channel would be acceptable,
>> because if the consumer ever gets e.g. 100,000 lines behind then it?s in
>> trouble already, but I?d rather not have the memory overhead of a
>> statically-allocated gigantic channel buffer.
>>
>
> I feel the need to point out that the producer could locally queue the
> messages before sending over the channel if it were bounded.
>
>
>>
>> -Kevin
>>
>> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>>
>> Okay, parallelism, of course, and I'm sure others.  Bad use of the word
>> 'only'.  The point is that if your consumers aren't keeping up with your
>> producers, you're screwed anyways, and growing the queue indefinitely isn't
>> a way to get around that.  Growing queues should only serve specific
>> purposes and make it easy to apply back pressure when the assumptions
>> behind those purposes go awry.
>>
>>
>> On Thursday, December 19, 2013, Patrick Walton wrote:
>>
>>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>>
>>>> I work on a system that handles 10s of billions of events per day, and
>>>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>>>> in-memory queues aren't, they just have a bound you have no direct
>>>> control over and that blows up the world when its hit.
>>>>
>>>> The only reason to have a queue size greater than 1 is to handle spikes
>>>> in the producer, short outages in the consumer, or a bit of
>>>> out-of-phaseness between producers and consumers.
>>>>
>>>
>>> Well, also parallelism.
>>>
>>> Patrick
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>  _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/3883c5c7/attachment-0001.html>

From pwalton at mozilla.com  Thu Dec 19 10:40:43 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Thu, 19 Dec 2013 10:40:43 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
	<CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>
Message-ID: <d5379eae-5af5-41c2-b829-6e9cb7601e9f@email.android.com>

Again, isn't blocking just likely to lead to deadlocks?

Patrick

Matthieu Monrocq <matthieu.monrocq at gmail.com> wrote:
>Also working in a distributed system, I cannot emphasize enough how
>back
>pressure is essential.
>
>With back pressure, you offer the producer a chance to react: it can
>decide
>to drop the message, send it over another channel, keep it around for
>later, etc...
>
>Furthermore, it is relatively easy to build an unbounded channel over a
>bounded one: just have the producer queue things. Depending on whether
>sequencing from multiple producers is important or not, this queue can
>be
>either shared or producer-local, with relative ease.
>
>
>Regarding the various behaviors that may be implemented, most behaviors
>can
>actually be implemented outside of the channel implementation:
>
>+ dropping the message can be implemented on producer side: if it
>cannot
>queue, it just goes on
>+ crashing is similar: if it cannot queue, crash
>+ blocking is generally a good idea, but if a timed-wait primitive
>exists
>then I imagine an infinite (or close enough) duration would be
>sufficient
>
>
>So it might be more interesting to reason in terms of primitives, and
>those
>might be more methods than types (hopefully):
>
>(1) immediate queueing (returning an error), a special case of
>time-bound
>queueing which may be slightly more efficient
>(2) time-bound queueing (returning an error after the timeout)
>(3) immediate + exchange with head (in which case the producer also
>locally
>acts as a consumer, this might be tricky to pull off efficiently on
>Single
>Consumer queues)
>(4) immediate + atomic subscription to "place has been freed" event in
>case
>of full-queue
>
>(Note: (4) somehow implies a dual channel, if you have a MPSC a
>back-channel SPMC is created to dispatch the "space available"
>notifications... which can be a simple counter, obviously; this
>back-channel must be "select"-able so that producers that usually block
>on
>other stuff can use a "space available" event to unblock)
>
>I cannot see another interesting primitive, at the moment.
>
>-- Matthieu
>
>
>On Thu, Dec 19, 2013 at 7:25 PM, Matthieu Monrocq <
>matthieu.monrocq at gmail.com> wrote:
>
>>
>>
>>
>> On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>>> Here?s an example from where I use an infinite queue.
>>>
>>> I have an IRC bot, written in Go. The incoming network traffic of
>this
>>> bot is handled in one goroutine, which parses each line into its
>>> components, and enqueues the result on a channel. The channel is
>very
>>> deliberately made infinite (via a separate goroutine that stores the
>>> infinite buffer in a local slice). The reason it?s infinite is
>because the
>>> bot needs to be resilient against the case where either the consumer
>>> unexpectedly blocks, or the network traffic spikes. The general
>assumption
>>> is that, under normal conditions, the consumer will always be able
>to keep
>>> up with the producer (as the producer is based on network traffic
>and not
>>> e.g. a tight CPU loop generating messages as fast as possible).
>>> Backpressure makes no sense here, as you cannot put backpressure on
>the
>>> network short of letting the socket buffer fill up, and letting the
>socket
>>> buffer fill up with cause the IRC network to disconnect you. So the
>>> overriding goal here is to prevent network disconnects, while
>assuming that
>>> the consumer will be able to catch up if it ever gets behind.
>>>
>>> This particular use case very explicitly wants a dynamically-sized
>>> infinite channel. I suppose an absurdly large channel would be
>acceptable,
>>> because if the consumer ever gets e.g. 100,000 lines behind then
>it?s in
>>> trouble already, but I?d rather not have the memory overhead of a
>>> statically-allocated gigantic channel buffer.
>>>
>>
>> I feel the need to point out that the producer could locally queue
>the
>> messages before sending over the channel if it were bounded.
>>
>>
>>>
>>> -Kevin
>>>
>>> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>>>
>>> Okay, parallelism, of course, and I'm sure others.  Bad use of the
>word
>>> 'only'.  The point is that if your consumers aren't keeping up with
>your
>>> producers, you're screwed anyways, and growing the queue
>indefinitely isn't
>>> a way to get around that.  Growing queues should only serve specific
>>> purposes and make it easy to apply back pressure when the
>assumptions
>>> behind those purposes go awry.
>>>
>>>
>>> On Thursday, December 19, 2013, Patrick Walton wrote:
>>>
>>>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>>>
>>>>> I work on a system that handles 10s of billions of events per day,
>and
>>>>> we do a lot of queueing.  Big +1 on having bounded queues. 
>Unbounded
>>>>> in-memory queues aren't, they just have a bound you have no direct
>>>>> control over and that blows up the world when its hit.
>>>>>
>>>>> The only reason to have a queue size greater than 1 is to handle
>spikes
>>>>> in the producer, short outages in the consumer, or a bit of
>>>>> out-of-phaseness between producers and consumers.
>>>>>
>>>>
>>>> Well, also parallelism.
>>>>
>>>> Patrick
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>  _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/dd5b619c/attachment.html>

From kevin at sb.org  Thu Dec 19 10:48:26 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 10:48:26 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
	<CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>
Message-ID: <C2EF7584-6B54-4C19-9DA6-DE2E801A41D5@sb.org>

On Dec 19, 2013, at 10:38 AM, Matthieu Monrocq <matthieu.monrocq at gmail.com> wrote:

> Furthermore, it is relatively easy to build an unbounded channel over a bounded one: just have the producer queue things. Depending on whether sequencing from multiple producers is important or not, this queue can be either shared or producer-local, with relative ease.

This is incorrect. The producer cannot queue messages and preserve the appearance of an unbounded channel. Except when sending a message on the channel, the producer is busy doing something else. It?s producing. That?s why it?s called a producer. This means that if the channel empties out, the consumer will run out of things to consume until the producer has finished producing another value. At this point, the producer can send as many enqueued values as fits in the channel, but it?s too late, the consumer has already stalled out.

The only type of producer that can enqueue the messages locally is one that produces by selecting on channels, as it can add the sending channel to the mix (but even this assumes that its processing of the other channels is fast enough to avoid letting the channel go empty).

It?s for this very reason that in Go, the way to produce an infinite channel looks like this:

    // run this in its own goroutine
    // replace Type with the proper channel type
    func makeInfiniteChan(in <-chan Type, next chan<- Type) {
        defer close(next)

        // pending events (this is the "infinite" part)
        pending := []Type{}

    recv:
        for {
            // Ensure that pending always has values so the select can
            // multiplex between the receiver and sender properly
            if len(pending) == 0 {
                v, ok := <-in
                if !ok {
                    // in is closed, flush values
                    break
                }

                // We now have something to send
                pending = append(pending, v)
            }

            select {
            // Queue incoming values
            case v, ok := <-in:
                if !ok {
                    // in is closed, flush values
                    break recv
                }
                pending = append(pending, v)

            // Send queued values
            case next <- pending[0]:
                pending = pending[1:]
            }
        }

        // After in is closed, we may still have events to send
        for _, v := range pending {
            next <- v
        }
    }

It?s a bit complicated, and requires a separate goroutine just to do the buffering. It works, but it shouldn?t be necessary. And it?s not going to be viable in Rust because of 1:1 scheduling.

-Kevin

From carter.schonwald at gmail.com  Thu Dec 19 10:50:55 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 19 Dec 2013 13:50:55 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <d5379eae-5af5-41c2-b829-6e9cb7601e9f@email.android.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAKE6RfhV9GqRLs0d1gbm5Sw7SFeq4sC0nSOVuMvONT7baCbtgw@mail.gmail.com>
	<CAKE6RfhVdtUsG2LOEJLM4zjLNGgE8pY9ktpFRM9-2bBsAmKXHw@mail.gmail.com>
	<d5379eae-5af5-41c2-b829-6e9cb7601e9f@email.android.com>
Message-ID: <CAHYVw0yBJHD=KmQ2o5tycnzhFgGrFHi+S4_2HBLhq2rVrguXWw@mail.gmail.com>

could you explain an example deadlock scenario concretely?

by blocking we mean a function like *fn sendBlockingBoundedChan(&self,
t:T)-> ()*

that doesn't return until the message in enqueued? Why should that even be
the default sending procedure?


On Thu, Dec 19, 2013 at 1:40 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> Again, isn't blocking just likely to lead to deadlocks?
>
> Patrick
>
> Matthieu Monrocq <matthieu.monrocq at gmail.com> wrote:
>>
>>  Also working in a distributed system, I cannot emphasize enough how
>> back pressure is essential.
>>
>> With back pressure, you offer the producer a chance to react: it can
>> decide to drop the message, send it over another channel, keep it around
>> for later, etc...
>>
>> Furthermore, it is relatively easy to build an unbounded channel over a
>> bounded one: just have the producer queue things. Depending on whether
>> sequencing from multiple producers is important or not, this queue can be
>> either shared or producer-local, with relative ease.
>>
>>
>> Regarding the various behaviors that may be implemented, most behaviors
>> can actually be implemented outside of the channel implementation:
>>
>> + dropping the message can be implemented on producer side: if it cannot
>> queue, it just goes on
>> + crashing is similar: if it cannot queue, crash
>> + blocking is generally a good idea, but if a timed-wait primitive exists
>> then I imagine an infinite (or close enough) duration would be sufficient
>>
>>
>> So it might be more interesting to reason in terms of primitives, and
>> those might be more methods than types (hopefully):
>>
>> (1) immediate queueing (returning an error), a special case of time-bound
>> queueing which may be slightly more efficient
>> (2) time-bound queueing (returning an error after the timeout)
>> (3) immediate + exchange with head (in which case the producer also
>> locally acts as a consumer, this might be tricky to pull off efficiently on
>> Single Consumer queues)
>> (4) immediate + atomic subscription to "place has been freed" event in
>> case of full-queue
>>
>> (Note: (4) somehow implies a dual channel, if you have a MPSC a
>> back-channel SPMC is created to dispatch the "space available"
>> notifications... which can be a simple counter, obviously; this
>> back-channel must be "select"-able so that producers that usually block on
>> other stuff can use a "space available" event to unblock)
>>
>> I cannot see another interesting primitive, at the moment.
>>
>> -- Matthieu
>>
>>
>> On Thu, Dec 19, 2013 at 7:25 PM, Matthieu Monrocq <
>> matthieu.monrocq at gmail.com> wrote:
>>
>>>
>>>
>>>
>>> On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>>> Here?s an example from where I use an infinite queue.
>>>>
>>>> I have an IRC bot, written in Go. The incoming network traffic of this
>>>> bot is handled in one goroutine, which parses each line into its
>>>> components, and enqueues the result on a channel. The channel is very
>>>> deliberately made infinite (via a separate goroutine that stores the
>>>> infinite buffer in a local slice). The reason it?s infinite is because the
>>>> bot needs to be resilient against the case where either the consumer
>>>> unexpectedly blocks, or the network traffic spikes. The general assumption
>>>> is that, under normal conditions, the consumer will always be able to keep
>>>> up with the producer (as the producer is based on network traffic and not
>>>> e.g. a tight CPU loop generating messages as fast as possible).
>>>> Backpressure makes no sense here, as you cannot put backpressure on the
>>>> network short of letting the socket buffer fill up, and letting the socket
>>>> buffer fill up with cause the IRC network to disconnect you. So the
>>>> overriding goal here is to prevent network disconnects, while assu ming
>>>> that the consumer will be able to catch up if it ever gets behind.
>>>>
>>>> This particular use case very explicitly wants a dynamically-sized
>>>> infinite channel. I suppose an absurdly large channel would be acceptable,
>>>> because if the consumer ever gets e.g. 100,000 lines behind then it?s in
>>>> trouble already, but I?d rather not have the memory overhead of a
>>>> statically-allocated gigantic channel buffer.
>>>>
>>>
>>> I feel the need to point out that the producer could locally queue the
>>> messages before sending over the channel if it were bounded.
>>>
>>>
>>>>
>>>> -Kevin
>>>>
>>>> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>>>>
>>>> Okay, parallelism, of course, and I'm sure others.  Bad use of the word
>>>> 'only'.  The point is that if your consumers aren't keeping up with your
>>>> producers, you're screwed anyways, and growing the queue indefinitely isn't
>>>> a way to get around that.  Growing queues should only serve specific
>>>> purposes and make it easy to apply back pressure when the assumptions
>>>> behind those purposes go awry.
>>>>
>>>>
>>>> On Thursday, December 19, 2013, Patrick Walton wrote:
>>>>
>>>>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>>>>
>>>>>> I work on a system that handles 10s of billions of events per day, and
>>>>>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>>>>>> in-memory queues aren't, they just have a bound you have no direct
>>>>>> control over and that blows up the world when its hit.
>>>>>>
>>>>>> The only reason to have a queue size greater than 1 is to handle
>>>>>> spikes
>>>>>> in the producer, short outages in the consumer, or a bit of
>>>>>> out-of-phaseness between producers and consumers.
>>>>>>
>>>>>
>>>>> Well, also parallelism.
>>>>>
>>>>> Patrick
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>  _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/35b21e32/attachment-0001.html>

From jfager at gmail.com  Thu Dec 19 11:08:17 2013
From: jfager at gmail.com (Jason Fager)
Date: Thu, 19 Dec 2013 14:08:17 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
Message-ID: <CAFEbTaWVCPyuA-pc_4kp_0PQ9jjWDV8VYrj4_eV5L4NX=xMeeA@mail.gmail.com>

So what do you do when you OOM?  A network traffic spike beyond a
particular threshold is exactly why you want a bounded queue, b/c it gives
you an opportunity to actually handle it and recover, even if the recovery
is just "drop messages I can't handle".

Backpressure doesn't make sense on an edge server handling traffic you
don't control, but spill-to-disk or discarding messages does.

Having a bound on your queue size and statically allocating a gigantic
channel buffer are orthogonal issues.  You can bound a linked list.


On Thu, Dec 19, 2013 at 1:23 PM, Kevin Ballard <kevin at sb.org> wrote:

> Here?s an example from where I use an infinite queue.
>
> I have an IRC bot, written in Go. The incoming network traffic of this bot
> is handled in one goroutine, which parses each line into its components,
> and enqueues the result on a channel. The channel is very deliberately made
> infinite (via a separate goroutine that stores the infinite buffer in a
> local slice). The reason it?s infinite is because the bot needs to be
> resilient against the case where either the consumer unexpectedly blocks,
> or the network traffic spikes. The general assumption is that, under normal
> conditions, the consumer will always be able to keep up with the producer
> (as the producer is based on network traffic and not e.g. a tight CPU loop
> generating messages as fast as possible). Backpressure makes no sense here,
> as you cannot put backpressure on the network short of letting the socket
> buffer fill up, and letting the socket buffer fill up with cause the IRC
> network to disconnect you. So the overriding goal here is to prevent
> network disconnects, while assuming that the consumer will be able to catch
> up if it ever gets behind.
>
> This particular use case very explicitly wants a dynamically-sized
> infinite channel. I suppose an absurdly large channel would be acceptable,
> because if the consumer ever gets e.g. 100,000 lines behind then it?s in
> trouble already, but I?d rather not have the memory overhead of a
> statically-allocated gigantic channel buffer.
>
> -Kevin
>
> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>
> Okay, parallelism, of course, and I'm sure others.  Bad use of the word
> 'only'.  The point is that if your consumers aren't keeping up with your
> producers, you're screwed anyways, and growing the queue indefinitely isn't
> a way to get around that.  Growing queues should only serve specific
> purposes and make it easy to apply back pressure when the assumptions
> behind those purposes go awry.
>
>
> On Thursday, December 19, 2013, Patrick Walton wrote:
>
>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>
>>> I work on a system that handles 10s of billions of events per day, and
>>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>>> in-memory queues aren't, they just have a bound you have no direct
>>> control over and that blows up the world when its hit.
>>>
>>> The only reason to have a queue size greater than 1 is to handle spikes
>>> in the producer, short outages in the consumer, or a bit of
>>> out-of-phaseness between producers and consumers.
>>>
>>
>> Well, also parallelism.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/2a59047f/attachment.html>

From kevin at sb.org  Thu Dec 19 11:21:35 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 11:21:35 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAFEbTaWVCPyuA-pc_4kp_0PQ9jjWDV8VYrj4_eV5L4NX=xMeeA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAFEbTaWVCPyuA-pc_4kp_0PQ9jjWDV8VYrj4_eV5L4NX=xMeeA@mail.gmail.com>
Message-ID: <898C0F28-B864-47A4-B84F-A95CF1BB605F@sb.org>

On Dec 19, 2013, at 11:08 AM, Jason Fager <jfager at gmail.com> wrote:

> So what do you do when you OOM?  A network traffic spike beyond a particular threshold is exactly why you want a bounded queue, b/c it gives you an opportunity to actually handle it and recover, even if the recovery is just "drop messages I can't handle".
> 
> Backpressure doesn't make sense on an edge server handling traffic you don't control, but spill-to-disk or discarding messages does.

Dropping messages is unacceptable, because that corrupts the internal state of the client such that it no longer reflects the state of the server.

OOM is not a worry here. If the channel gets backed up so much that it actually causes memory issues, then I've got something seriously wrong with my program, something that a bounded channel won't fix. The only thing I can do with a bounded channel is disconnect if I run out of space, which is also unacceptable. Running OOM and being terminated by the system is the best-case behavior here, because anything else means effectively giving up while I still had available resources.

> Having a bound on your queue size and statically allocating a gigantic channel buffer are orthogonal issues.  You can bound a linked list.

Correct, but my understanding is that Go's channels do allocate the buffer up front.

-Kevin

> On Thu, Dec 19, 2013 at 1:23 PM, Kevin Ballard <kevin at sb.org> wrote:
> Here?s an example from where I use an infinite queue.
> 
> I have an IRC bot, written in Go. The incoming network traffic of this bot is handled in one goroutine, which parses each line into its components, and enqueues the result on a channel. The channel is very deliberately made infinite (via a separate goroutine that stores the infinite buffer in a local slice). The reason it?s infinite is because the bot needs to be resilient against the case where either the consumer unexpectedly blocks, or the network traffic spikes. The general assumption is that, under normal conditions, the consumer will always be able to keep up with the producer (as the producer is based on network traffic and not e.g. a tight CPU loop generating messages as fast as possible). Backpressure makes no sense here, as you cannot put backpressure on the network short of letting the socket buffer fill up, and letting the socket buffer fill up with cause the IRC network to disconnect you. So the overriding goal here is to prevent network disconnects, while assuming that the consumer will be able to catch up if it ever gets behind.
> 
> This particular use case very explicitly wants a dynamically-sized infinite channel. I suppose an absurdly large channel would be acceptable, because if the consumer ever gets e.g. 100,000 lines behind then it?s in trouble already, but I?d rather not have the memory overhead of a statically-allocated gigantic channel buffer.
> 
> -Kevin
> 
> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
> 
>> Okay, parallelism, of course, and I'm sure others.  Bad use of the word 'only'.  The point is that if your consumers aren't keeping up with your producers, you're screwed anyways, and growing the queue indefinitely isn't a way to get around that.  Growing queues should only serve specific purposes and make it easy to apply back pressure when the assumptions behind those purposes go awry.
>> 
>> 
>> On Thursday, December 19, 2013, Patrick Walton wrote:
>> On 12/19/13 6:31 AM, Jason Fager wrote:
>> I work on a system that handles 10s of billions of events per day, and
>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>> in-memory queues aren't, they just have a bound you have no direct
>> control over and that blows up the world when its hit.
>> 
>> The only reason to have a queue size greater than 1 is to handle spikes
>> in the producer, short outages in the consumer, or a bit of
>> out-of-phaseness between producers and consumers.
>> 
>> Well, also parallelism.
>> 
>> Patrick
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/7ef9b91c/attachment.html>

From glaebhoerl at gmail.com  Thu Dec 19 11:23:47 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Thu, 19 Dec 2013 20:23:47 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
Message-ID: <CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>

I don't have any special expertise in or experience with this, I'm just
trying to draw logical inferences from what others have written.

Stated:

 - From a semantic perspective the only distinction is between bounded and
unbounded queues. The capacity of a bounded queue only makes a difference
with regards to performance.

 - There is also no such thing as an unbounded queue. The only distinction
is between queues whose capacities are constrained by us, and fail
predictably, and queues whose capacities are constrained by the available
resources, and fail chaotically.

 - The storage for a bounded queue need not all be allocated up-front, this
also just a performance optimization (or pessimization).

The big difference is in the user of the queue and the use case. Some users
in some cases don't want to have to think about the possibility of failure,
either because they believe that it's extremely unlikely or impossible (the
producer is only ever going to send 100 messages, no way it's going to
exhaust resources), and/or because failure is not a big problem for them
(we can just restart the thing, and putting in the effort to rule failure
out up-front doesn't pass the cost-benefit test). Other users in other
cases believe failure is a serious consideration and they want to be able
to prevent it or handle it well.

Assuming that we want to continue catering foremost to the people who don't
want to think about failure, but also don't want to leave the people who do
want to think about it out in the cold, what about:

 - Having only one type of queue, which is bounded,

 - and whose default capacity is just small enough that it would be hit
before exhausting resources, but is otherwise still ridiculously large
("effectively unbounded") (so basically what Kevin wrote),

 - failing the task on `send()` if the capacity would be exceeded,

 - allowing a smaller capacity (down to 1) to be specified instead,

 - also providing a try_send() method which returns false/Err, instead of
failing, when there is no available capacity,

 - and using a different representation for the queue storage for different
capacity classes: e.g. allocating up-front if it's "small" and growing it
incrementally if it's "large"?

The last point is speculative: I don't know if bounded and "effectively
unbounded" queues can both be implemented performantly in a single type.

Anyway: could this work?


On Thu, Dec 19, 2013 at 7:23 PM, Kevin Ballard <kevin at sb.org> wrote:

> Here?s an example from where I use an infinite queue.
>
> I have an IRC bot, written in Go. The incoming network traffic of this bot
> is handled in one goroutine, which parses each line into its components,
> and enqueues the result on a channel. The channel is very deliberately made
> infinite (via a separate goroutine that stores the infinite buffer in a
> local slice). The reason it?s infinite is because the bot needs to be
> resilient against the case where either the consumer unexpectedly blocks,
> or the network traffic spikes. The general assumption is that, under normal
> conditions, the consumer will always be able to keep up with the producer
> (as the producer is based on network traffic and not e.g. a tight CPU loop
> generating messages as fast as possible). Backpressure makes no sense here,
> as you cannot put backpressure on the network short of letting the socket
> buffer fill up, and letting the socket buffer fill up with cause the IRC
> network to disconnect you. So the overriding goal here is to prevent
> network disconnects, while assuming that the consumer will be able to catch
> up if it ever gets behind.
>
> This particular use case very explicitly wants a dynamically-sized
> infinite channel. I suppose an absurdly large channel would be acceptable,
> because if the consumer ever gets e.g. 100,000 lines behind then it?s in
> trouble already, but I?d rather not have the memory overhead of a
> statically-allocated gigantic channel buffer.
>
> -Kevin
>
> On Dec 19, 2013, at 10:04 AM, Jason Fager <jfager at gmail.com> wrote:
>
> Okay, parallelism, of course, and I'm sure others.  Bad use of the word
> 'only'.  The point is that if your consumers aren't keeping up with your
> producers, you're screwed anyways, and growing the queue indefinitely isn't
> a way to get around that.  Growing queues should only serve specific
> purposes and make it easy to apply back pressure when the assumptions
> behind those purposes go awry.
>
>
> On Thursday, December 19, 2013, Patrick Walton wrote:
>
>> On 12/19/13 6:31 AM, Jason Fager wrote:
>>
>>> I work on a system that handles 10s of billions of events per day, and
>>> we do a lot of queueing.  Big +1 on having bounded queues.  Unbounded
>>> in-memory queues aren't, they just have a bound you have no direct
>>> control over and that blows up the world when its hit.
>>>
>>> The only reason to have a queue size greater than 1 is to handle spikes
>>> in the producer, short outages in the consumer, or a bit of
>>> out-of-phaseness between producers and consumers.
>>>
>>
>> Well, also parallelism.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/a5584f27/attachment-0001.html>

From kevin at sb.org  Thu Dec 19 11:43:24 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 11:43:24 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
Message-ID: <993373D7-1503-4ABC-BF0D-22DF38238FB6@sb.org>

On Dec 19, 2013, at 11:23 AM, G?bor Lehel <glaebhoerl at gmail.com> wrote:

>  - From a semantic perspective the only distinction is between bounded and unbounded queues. The capacity of a bounded queue only makes a difference with regards to performance.

While this may be true in most cases, I can come up with ways to use a channel that require a capacity greater than 1 to avoid a deadlock (assuming block-on-send).

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/d38fbef1/attachment.html>

From kevin at sb.org  Thu Dec 19 11:46:11 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 19 Dec 2013 11:46:11 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
Message-ID: <9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>

On Dec 19, 2013, at 11:23 AM, G?bor Lehel <glaebhoerl at gmail.com> wrote:

>  - Having only one type of queue, which is bounded,
>  
>  - and whose default capacity is just small enough that it would be hit before exhausting resources, but is otherwise still ridiculously large ("effectively unbounded") (so basically what Kevin wrote),

For people who don't want to think about failure cases, I don't see how this is any better than a genuinely unbounded queue. And for people who do want to think about failure causes, they have to think about the bounds anyway so some sort of ridiculously high default isn't very usable.

I also am not sure how you can come up with an appropriate ridiculously-high default that is guaranteed to be small enough to fit into available resources for everyone.

My feeling here is that we should have a genuinely unbounded queue, and we should have a bounded queue that requires setting a bound instead of providing a default.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/5c57e88c/attachment.html>

From bascule at gmail.com  Thu Dec 19 14:13:29 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 19 Dec 2013 14:13:29 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
Message-ID: <CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>

On Thu, Dec 19, 2013 at 11:46 AM, Kevin Ballard <kevin at sb.org> wrote:

> For people who don't want to think about failure cases, I don't see how
> this is any better than a genuinely unbounded queue.
>

As was mentioned earlier, there's no such thing as a "genuinely unbounded
queue". It's a system resource-bounded queue. People who "don't want to
think about failure cases" are simply accepting whatever failure mode
happens by virtue of not thinking about it. As soon as a failure happens,
whatever it may be, they will become much more concerned.

I'd suggest not giving too much worry to these people. They'll either have
everything work swimmingly if they don't process a lot of messages, and one
way or another will have everything explode once they hit a resource cap,
whether it's bounded by the language or system resources. So I think that
entire line of reasoning is a red herring. People writing toy programs that
never have their channels fill beyond a small number of messages won't care
either way.

However, overloaded programs + queues bounded by system resources are a
production outage waiting to happen. What's really important here is
providing a means of backpressure so overloaded Rust programs don't grow
until they consume system resources and OOM.

--
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/f04e4fe8/attachment.html>

From erick.tryzelaar at gmail.com  Thu Dec 19 18:57:30 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 19 Dec 2013 18:57:30 -0800
Subject: [rust-dev] December 17th San Francisco Bay Area Meetup
In-Reply-To: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
References: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
Message-ID: <CALdfqQJwnpV0W+PDbr5z7AuEXBavTAgJ3TZUpqeQN62MRLrR2Q@mail.gmail.com>

Good evening everyone!

We had a great meetup earlier this week, and we were fortunate to have Air
Mozilla record the presentations in case any of you were not able to
attend: https://air.mozilla.org/rust-meetup-december-2013/. Also, you can
find the slides of all the presentations here:

Steve: http://steveklabnik.github.io/rust_documentation/#/
Chris: http://chrismorgan.info/blog/rust-docs-vision-presentation.html
Alex:
https://docs.google.com/presentation/d/1oB3hwBByGNcgst-X0SSmRyu-uMfayeySNAJdkwwtB9Q/edit?usp=sharing

Luqman didn't use slides, but he did step through his Mincraft Chat Client,
which you can find here: https://github.com/luqmana/mcchat

Thanks everyone for participating!
-Erick




On Thu, Dec 5, 2013 at 7:27 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com>wrote:

> Good evening Rusties,
>
> I'm happy to announce the next Bay Area Rust meetup on December 17th in
> San Francisco. Mozilla is graciously hosting us again. We've got a couple
> short talks lined up:
>
> ? Luqman Aden will talk about using Rust to make a Minecraft Chat Client<https://github.com/luqmana/mcchat>
> .
>
> ? Alex Crichton will talk about Channels and their performance.
>
> ? Brian Anderson will talk about *something*.
>
> ? And if he's able to get it to a presentable state, Kevin Ballard will
> talk about his safe Lua Bindings.
>
> It'll start at 7:00pm and go until 10:00pm. If you would like to attend,
> please sign up here:
>
> http://www.meetup.com/Rust-Bay-Area/events/153010612/
>
> We also might have some room for more other talks, so if you would like to
> present something at this meetup, or a future one, please let me know.
>
> I hope you can make it!
> -Erick
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131219/c60a3f5a/attachment.html>

From gaetan at xeberon.net  Fri Dec 20 05:24:15 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 20 Dec 2013 14:24:15 +0100
Subject: [rust-dev] December 17th San Francisco Bay Area Meetup
In-Reply-To: <CALdfqQJwnpV0W+PDbr5z7AuEXBavTAgJ3TZUpqeQN62MRLrR2Q@mail.gmail.com>
References: <CALdfqQKN8ydc=bCF0SePWP=ZGMEPwBg9W3ePcHeqYGzQvU3Txw@mail.gmail.com>
	<CALdfqQJwnpV0W+PDbr5z7AuEXBavTAgJ3TZUpqeQN62MRLrR2Q@mail.gmail.com>
Message-ID: <CANK7tAHfMu3rBeGoAnk8tRywh3EUHPCPZr=JcQ5ONeahT9se-g@mail.gmail.com>

Thanks!

I fully agree for all the anti markdown part! sphinx/RST is much more
powerful for generating the documentation.

-----
Gaetan



2013/12/20 Erick Tryzelaar <erick.tryzelaar at gmail.com>

> Good evening everyone!
>
> We had a great meetup earlier this week, and we were fortunate to have Air
> Mozilla record the presentations in case any of you were not able to
> attend: https://air.mozilla.org/rust-meetup-december-2013/. Also, you can
> find the slides of all the presentations here:
>
> Steve: http://steveklabnik.github.io/rust_documentation/#/
> Chris: http://chrismorgan.info/blog/rust-docs-vision-presentation.html
> Alex:
> https://docs.google.com/presentation/d/1oB3hwBByGNcgst-X0SSmRyu-uMfayeySNAJdkwwtB9Q/edit?usp=sharing
>
> Luqman didn't use slides, but he did step through his Mincraft Chat
> Client, which you can find here: https://github.com/luqmana/mcchat
>
> Thanks everyone for participating!
> -Erick
>
>
>
>
> On Thu, Dec 5, 2013 at 7:27 PM, Erick Tryzelaar <erick.tryzelaar at gmail.com
> > wrote:
>
>> Good evening Rusties,
>>
>> I'm happy to announce the next Bay Area Rust meetup on December 17th in
>> San Francisco. Mozilla is graciously hosting us again. We've got a couple
>> short talks lined up:
>>
>> ? Luqman Aden will talk about using Rust to make a Minecraft Chat Client<https://github.com/luqmana/mcchat>
>> .
>>
>> ? Alex Crichton will talk about Channels and their performance.
>>
>> ? Brian Anderson will talk about *something*.
>>
>> ? And if he's able to get it to a presentable state, Kevin Ballard will
>> talk about his safe Lua Bindings.
>>
>> It'll start at 7:00pm and go until 10:00pm. If you would like to attend,
>> please sign up here:
>>
>> http://www.meetup.com/Rust-Bay-Area/events/153010612/
>>
>> We also might have some room for more other talks, so if you would like
>> to present something at this meetup, or a future one, please let me know.
>>
>> I hope you can make it!
>> -Erick
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/ae36cb54/attachment.html>

From jurily at gmail.com  Fri Dec 20 05:52:40 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Fri, 20 Dec 2013 14:52:40 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>	<52B32112.2070800@mozilla.com>	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
Message-ID: <52B44BA8.9060507@gmail.com>

On 12/19/2013 11:13 PM, Tony Arcieri wrote:
> So I think that entire line of reasoning is a red herring. People
> writing toy programs that never have their channels fill beyond a small
> number of messages won't care either way.
>
> However, overloaded programs + queues bounded by system resources are a
> production outage waiting to happen. What's really important here is
> providing a means of backpressure so overloaded Rust programs don't grow
> until they consume system resources and OOM.

While I disagree with the notion that all programs which don't have 
their bottlenecks right here are "toys", we should definitely strive for 
the invariant that task failure does not cause independent tasks to fail.

Also, OOM is not free. If you manage to go OOM on a desktop, you'll get 
a *very* unhappy user, regardless of their expectations wrt your memory 
usage. Linux with a spinning disk and swap for example will degrade to 
the point where they'll reboot before the OOM killer kicks in.

Can we PLEASE not do that *by default*?

From carter.schonwald at gmail.com  Fri Dec 20 08:59:53 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 20 Dec 2013 11:59:53 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52B44BA8.9060507@gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
Message-ID: <CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>

agreed! Applications that lack explicit logic for handling heavy workloads
(ie producers outpacing consumers for a sustained period) are the most
common culprit for unresponsive desktop applications that become completely
unusable.

relatedly: would not bounded but programmatically growable channels also
make it trivial to provide a "unbounded" style channel abstraction? (not
that i'm advocating that, merely that it seems like it would turn the
unbounded channel abstraction into an equivalent one that is resource usage
aware)


On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com> wrote:

> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>
>> So I think that entire line of reasoning is a red herring. People
>> writing toy programs that never have their channels fill beyond a small
>> number of messages won't care either way.
>>
>> However, overloaded programs + queues bounded by system resources are a
>> production outage waiting to happen. What's really important here is
>> providing a means of backpressure so overloaded Rust programs don't grow
>> until they consume system resources and OOM.
>>
>
> While I disagree with the notion that all programs which don't have their
> bottlenecks right here are "toys", we should definitely strive for the
> invariant that task failure does not cause independent tasks to fail.
>
> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get a
> *very* unhappy user, regardless of their expectations wrt your memory
> usage. Linux with a spinning disk and swap for example will degrade to the
> point where they'll reboot before the OOM killer kicks in.
>
> Can we PLEASE not do that *by default*?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/45012e68/attachment-0001.html>

From kevin at sb.org  Fri Dec 20 09:54:41 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 20 Dec 2013 09:54:41 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
Message-ID: <03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>

On Dec 20, 2013, at 8:59 AM, Carter Schonwald <carter.schonwald at gmail.com> wrote:

> agreed! Applications that lack explicit logic for handling heavy workloads (ie producers outpacing consumers for a sustained period) are the most common culprit for unresponsive desktop applications that become completely unusable. 

That?s a pretty strong claim, and one I would have to disagree with quite strongly. Every time I?ve sampled an unresponsive application, I don?t think I?ve ever seen a backtrace that suggests a producer outpacing a consumer.

-Kevin

> relatedly: would not bounded but programmatically growable channels also make it trivial to provide a "unbounded" style channel abstraction? (not that i'm advocating that, merely that it seems like it would turn the unbounded channel abstraction into an equivalent one that is resource usage aware)
> 
> 
> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com> wrote:
> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
> So I think that entire line of reasoning is a red herring. People
> writing toy programs that never have their channels fill beyond a small
> number of messages won't care either way.
> 
> However, overloaded programs + queues bounded by system resources are a
> production outage waiting to happen. What's really important here is
> providing a means of backpressure so overloaded Rust programs don't grow
> until they consume system resources and OOM.
> 
> While I disagree with the notion that all programs which don't have their bottlenecks right here are "toys", we should definitely strive for the invariant that task failure does not cause independent tasks to fail.
> 
> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get a *very* unhappy user, regardless of their expectations wrt your memory usage. Linux with a spinning disk and swap for example will degrade to the point where they'll reboot before the OOM killer kicks in.
> 
> Can we PLEASE not do that *by default*?
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/658a6561/attachment.html>

From carter.schonwald at gmail.com  Fri Dec 20 12:55:38 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 20 Dec 2013 15:55:38 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
Message-ID: <CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>

kevin, what sort of applications and workloads are you speaking about. Eg
in your example irc server, whats the typical workload when you've used it?

cheers
-Carter


On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <carter.schonwald at gmail.com>
> wrote:
>
> agreed! Applications that lack explicit logic for handling heavy workloads
> (ie producers outpacing consumers for a sustained period) are the most
> common culprit for unresponsive desktop applications that become completely
> unusable.
>
>
> That?s a pretty strong claim, and one I would have to disagree with quite
> strongly. Every time I?ve sampled an unresponsive application, I don?t
> think I?ve *ever* seen a backtrace that suggests a producer outpacing a
> consumer.
>
> -Kevin
>
> relatedly: would not bounded but programmatically growable channels also
> make it trivial to provide a "unbounded" style channel abstraction? (not
> that i'm advocating that, merely that it seems like it would turn the
> unbounded channel abstraction into an equivalent one that is resource usage
> aware)
>
>
> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com> wrote:
>
>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>
>>> So I think that entire line of reasoning is a red herring. People
>>> writing toy programs that never have their channels fill beyond a small
>>> number of messages won't care either way.
>>>
>>> However, overloaded programs + queues bounded by system resources are a
>>> production outage waiting to happen. What's really important here is
>>> providing a means of backpressure so overloaded Rust programs don't grow
>>> until they consume system resources and OOM.
>>>
>>
>> While I disagree with the notion that all programs which don't have their
>> bottlenecks right here are "toys", we should definitely strive for the
>> invariant that task failure does not cause independent tasks to fail.
>>
>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get a
>> *very* unhappy user, regardless of their expectations wrt your memory
>> usage. Linux with a spinning disk and swap for example will degrade to the
>> point where they'll reboot before the OOM killer kicks in.
>>
>> Can we PLEASE not do that *by default*?
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/516d3471/attachment.html>

From kevin at sb.org  Fri Dec 20 13:09:39 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 20 Dec 2013 13:09:39 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
Message-ID: <0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>

I haven?t profiled it, but my belief is that under normal circumstances, messages come in slow enough that the consumer is always idle and ready to process the next message as soon as it?s sent. However, I expect it does occasionally back up a bit, e.g. when I get a burst of traffic such as during a netsplit when I?m sent a large batch of ?<user> has quit? or ?<user> has joined? (when the netsplit is over). I don?t know how much the channel backs up at that point, probably not too much.

For this particular use-case, a channel that?s bounded at e.g. 100,000 elements would be indistinguishable from an infinite channel, as long as it still dynamically allocates (I don?t think Go channels dynamically allocate, which is why I can?t just use a 100,000 element channel for real).

However, my overall point about large bounds being indistinguishable from infinite is that if your goal is to pick a bound large enough to appear infinite to the program, without actually risking OOM, then there?s no automated way to do this. Different environments have differing amounts of available resources, and there?s no good way to pick a bound that is sufficiently high but is definitively lower than the resource bounds. This is why I?m recommending that we have truly infinite channels, for users who don?t want to have to think about bounds (e.g. my irc program), as well as bounded channels, where the user has to explicitly pick a bound (with no ?default? provided).

-Kevin

On Dec 20, 2013, at 12:55 PM, Carter Schonwald <carter.schonwald at gmail.com> wrote:

> kevin, what sort of applications and workloads are you speaking about. Eg in your example irc server, whats the typical workload when you've used it?
> 
> cheers
> -Carter
> 
> 
> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <carter.schonwald at gmail.com> wrote:
> 
>> agreed! Applications that lack explicit logic for handling heavy workloads (ie producers outpacing consumers for a sustained period) are the most common culprit for unresponsive desktop applications that become completely unusable. 
> 
> That?s a pretty strong claim, and one I would have to disagree with quite strongly. Every time I?ve sampled an unresponsive application, I don?t think I?ve ever seen a backtrace that suggests a producer outpacing a consumer.
> 
> -Kevin
> 
>> relatedly: would not bounded but programmatically growable channels also make it trivial to provide a "unbounded" style channel abstraction? (not that i'm advocating that, merely that it seems like it would turn the unbounded channel abstraction into an equivalent one that is resource usage aware)
>> 
>> 
>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com> wrote:
>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>> So I think that entire line of reasoning is a red herring. People
>> writing toy programs that never have their channels fill beyond a small
>> number of messages won't care either way.
>> 
>> However, overloaded programs + queues bounded by system resources are a
>> production outage waiting to happen. What's really important here is
>> providing a means of backpressure so overloaded Rust programs don't grow
>> until they consume system resources and OOM.
>> 
>> While I disagree with the notion that all programs which don't have their bottlenecks right here are "toys", we should definitely strive for the invariant that task failure does not cause independent tasks to fail.
>> 
>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get a *very* unhappy user, regardless of their expectations wrt your memory usage. Linux with a spinning disk and swap for example will degrade to the point where they'll reboot before the OOM killer kicks in.
>> 
>> Can we PLEASE not do that *by default*?
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/9b2771ba/attachment.html>

From carter.schonwald at gmail.com  Fri Dec 20 13:15:02 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 20 Dec 2013 16:15:02 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
	<0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
Message-ID: <CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>

i'd be very very surprised if bounded channels in go don't dynamically
resize their queues and then atomically insert / remove elements while
checking the bound.  I'd actually argue that such would be a bug.


On Fri, Dec 20, 2013 at 4:09 PM, Kevin Ballard <kevin at sb.org> wrote:

> I haven?t profiled it, but my belief is that under normal circumstances,
> messages come in slow enough that the consumer is always idle and ready to
> process the next message as soon as it?s sent. However, I expect it does
> occasionally back up a bit, e.g. when I get a burst of traffic such as
> during a netsplit when I?m sent a large batch of ?<user> has quit? or
> ?<user> has joined? (when the netsplit is over). I don?t know how much the
> channel backs up at that point, probably not too much.
>
> For this particular use-case, a channel that?s bounded at e.g. 100,000
> elements would be indistinguishable from an infinite channel, as long as it
> still dynamically allocates (I don?t *think* Go channels dynamically
> allocate, which is why I can?t just use a 100,000 element channel for real).
>
> However, my overall point about large bounds being indistinguishable from
> infinite is that if your goal is to pick a bound large enough to appear
> infinite to the program, without actually risking OOM, then there?s no
> automated way to do this. Different environments have differing amounts of
> available resources, and there?s no good way to pick a bound that is
> sufficiently high but is definitively lower than the resource bounds. This
> is why I?m recommending that we have truly infinite channels, for users who
> don?t want to have to think about bounds (e.g. my irc program), as well as
> bounded channels, where the user has to explicitly pick a bound (with no
> ?default? provided).
>
> -Kevin
>
> On Dec 20, 2013, at 12:55 PM, Carter Schonwald <carter.schonwald at gmail.com>
> wrote:
>
> kevin, what sort of applications and workloads are you speaking about. Eg
> in your example irc server, whats the typical workload when you've used it?
>
> cheers
> -Carter
>
>
> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <carter.schonwald at gmail.com>
>> wrote:
>>
>> agreed! Applications that lack explicit logic for handling heavy
>> workloads (ie producers outpacing consumers for a sustained period) are the
>> most common culprit for unresponsive desktop applications that become
>> completely unusable.
>>
>>
>> That?s a pretty strong claim, and one I would have to disagree with quite
>> strongly. Every time I?ve sampled an unresponsive application, I don?t
>> think I?ve *ever* seen a backtrace that suggests a producer outpacing a
>> consumer.
>>
>> -Kevin
>>
>> relatedly: would not bounded but programmatically growable channels also
>> make it trivial to provide a "unbounded" style channel abstraction? (not
>> that i'm advocating that, merely that it seems like it would turn the
>> unbounded channel abstraction into an equivalent one that is resource usage
>> aware)
>>
>>
>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com>wrote:
>>
>>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>>
>>>> So I think that entire line of reasoning is a red herring. People
>>>> writing toy programs that never have their channels fill beyond a small
>>>> number of messages won't care either way.
>>>>
>>>> However, overloaded programs + queues bounded by system resources are a
>>>> production outage waiting to happen. What's really important here is
>>>> providing a means of backpressure so overloaded Rust programs don't grow
>>>> until they consume system resources and OOM.
>>>>
>>>
>>> While I disagree with the notion that all programs which don't have
>>> their bottlenecks right here are "toys", we should definitely strive for
>>> the invariant that task failure does not cause independent tasks to fail.
>>>
>>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get
>>> a *very* unhappy user, regardless of their expectations wrt your memory
>>> usage. Linux with a spinning disk and swap for example will degrade to the
>>> point where they'll reboot before the OOM killer kicks in.
>>>
>>> Can we PLEASE not do that *by default*?
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/8f11e040/attachment-0001.html>

From carter.schonwald at gmail.com  Fri Dec 20 13:19:23 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 20 Dec 2013 16:19:23 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
	<0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
	<CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>
Message-ID: <CAHYVw0z2rwn+C-=KBqdSx0B--NB7Uh+tgBF7ZkvPXfhcQFR2AA@mail.gmail.com>

actually, you're right, in go they're fixed sized buffers
http://golang.org/src/pkg/runtime/chan.c . I can understands (and agree!)
that this is not a good default if a more dynamic data structure can work
well.

in haskell / ghc , bounded channels are dynamically sized, and merely have
a max size thats enforced by the provided api,and I've been speaking with
that sort of memory usage model in mind.


On Fri, Dec 20, 2013 at 4:15 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> i'd be very very surprised if bounded channels in go don't dynamically
> resize their queues and then atomically insert / remove elements while
> checking the bound.  I'd actually argue that such would be a bug.
>
>
> On Fri, Dec 20, 2013 at 4:09 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> I haven?t profiled it, but my belief is that under normal circumstances,
>> messages come in slow enough that the consumer is always idle and ready to
>> process the next message as soon as it?s sent. However, I expect it does
>> occasionally back up a bit, e.g. when I get a burst of traffic such as
>> during a netsplit when I?m sent a large batch of ?<user> has quit? or
>> ?<user> has joined? (when the netsplit is over). I don?t know how much the
>> channel backs up at that point, probably not too much.
>>
>> For this particular use-case, a channel that?s bounded at e.g. 100,000
>> elements would be indistinguishable from an infinite channel, as long as it
>> still dynamically allocates (I don?t *think* Go channels dynamically
>> allocate, which is why I can?t just use a 100,000 element channel for real).
>>
>> However, my overall point about large bounds being indistinguishable from
>> infinite is that if your goal is to pick a bound large enough to appear
>> infinite to the program, without actually risking OOM, then there?s no
>> automated way to do this. Different environments have differing amounts of
>> available resources, and there?s no good way to pick a bound that is
>> sufficiently high but is definitively lower than the resource bounds. This
>> is why I?m recommending that we have truly infinite channels, for users who
>> don?t want to have to think about bounds (e.g. my irc program), as well as
>> bounded channels, where the user has to explicitly pick a bound (with no
>> ?default? provided).
>>
>> -Kevin
>>
>> On Dec 20, 2013, at 12:55 PM, Carter Schonwald <
>> carter.schonwald at gmail.com> wrote:
>>
>> kevin, what sort of applications and workloads are you speaking about. Eg
>> in your example irc server, whats the typical workload when you've used it?
>>
>> cheers
>> -Carter
>>
>>
>> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>>> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <
>>> carter.schonwald at gmail.com> wrote:
>>>
>>> agreed! Applications that lack explicit logic for handling heavy
>>> workloads (ie producers outpacing consumers for a sustained period) are the
>>> most common culprit for unresponsive desktop applications that become
>>> completely unusable.
>>>
>>>
>>> That?s a pretty strong claim, and one I would have to disagree with
>>> quite strongly. Every time I?ve sampled an unresponsive application, I
>>> don?t think I?ve *ever* seen a backtrace that suggests a producer
>>> outpacing a consumer.
>>>
>>> -Kevin
>>>
>>> relatedly: would not bounded but programmatically growable channels also
>>> make it trivial to provide a "unbounded" style channel abstraction? (not
>>> that i'm advocating that, merely that it seems like it would turn the
>>> unbounded channel abstraction into an equivalent one that is resource usage
>>> aware)
>>>
>>>
>>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com>wrote:
>>>
>>>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>>>
>>>>> So I think that entire line of reasoning is a red herring. People
>>>>> writing toy programs that never have their channels fill beyond a small
>>>>> number of messages won't care either way.
>>>>>
>>>>> However, overloaded programs + queues bounded by system resources are a
>>>>> production outage waiting to happen. What's really important here is
>>>>> providing a means of backpressure so overloaded Rust programs don't
>>>>> grow
>>>>> until they consume system resources and OOM.
>>>>>
>>>>
>>>> While I disagree with the notion that all programs which don't have
>>>> their bottlenecks right here are "toys", we should definitely strive for
>>>> the invariant that task failure does not cause independent tasks to fail.
>>>>
>>>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll get
>>>> a *very* unhappy user, regardless of their expectations wrt your memory
>>>> usage. Linux with a spinning disk and swap for example will degrade to the
>>>> point where they'll reboot before the OOM killer kicks in.
>>>>
>>>> Can we PLEASE not do that *by default*?
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/b7e25db9/attachment.html>

From palmercox at gmail.com  Fri Dec 20 20:51:42 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Fri, 20 Dec 2013 23:51:42 -0500
Subject: [rust-dev] RFC: Iterator naming convention
Message-ID: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>

I noticed recently that there seem to be 3 distinct Iterator naming
conventions currently in use:

1. Use the "Iterator" suffix. Examples of this are SplitIterator and
DoubleEndedIterator.
2. Use the "Iter" suffix. Examples of this are ChunkIter and ComponentIter.
3. Use no particular suffix. Examples of this are Invert and Union.

Iterators are somewhat special objects, so, it makes sense to me that they
have a suffix in common to denote their common behavior. It seems
non-ideal, however, that there appear to be 3 separate conventions in use
since that is just confusing. Personally, I think I prefer #1 because its
far and away the most common and and because I think #2 and #3 have issues:

#2 ("Iter" suffix): If we used this suffix, would we rename
DoubleEndedIterator to DoubleEndedIter? That looks awkward since we
abbreviated Iterator without abbreviating anything else. However,
DblEndedIter is a monstrosity. So, this convention seems non-ideal to me.

#3 (no suffix): I think its pretty confusing while reading through code
that there are both iter::Map and container::Map since they are completely
unrelated. I'm also not a big fan of Union since I think as a union as a
collection of information that I can iterate multiple times. However, since
Union is itself an Iterator, I can only iterate it once. This means I would
have to be careful passing a Union around to make sure I don't pass around
an already iterated Union object.

So, I opened up https://github.com/mozilla/rust/pull/11001 to standardize
on #1 - all Iterators have an Iterator suffix.

Thoughts?

-Palmer Cox
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131220/ccc8fb73/attachment.html>

From yati.sagade at gmail.com  Fri Dec 20 21:48:22 2013
From: yati.sagade at gmail.com (yati sagade)
Date: Sat, 21 Dec 2013 11:18:22 +0530
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
Message-ID: <CANpY+HmJL0CxN+9DyWWvY7RXgRLNgJnpNpHu8hF3LQPb6A1KMA@mail.gmail.com>

I personally like #1, the Iterator suffix for all iterators. It is very
slightly verbose, but I think most of the time this should not matter.


On Sat, Dec 21, 2013 at 10:21 AM, Palmer Cox <palmercox at gmail.com> wrote:

> I noticed recently that there seem to be 3 distinct Iterator naming
> conventions currently in use:
>
> 1. Use the "Iterator" suffix. Examples of this are SplitIterator and
> DoubleEndedIterator.
> 2. Use the "Iter" suffix. Examples of this are ChunkIter and ComponentIter.
> 3. Use no particular suffix. Examples of this are Invert and Union.
>
> Iterators are somewhat special objects, so, it makes sense to me that they
> have a suffix in common to denote their common behavior. It seems
> non-ideal, however, that there appear to be 3 separate conventions in use
> since that is just confusing. Personally, I think I prefer #1 because its
> far and away the most common and and because I think #2 and #3 have issues:
>
> #2 ("Iter" suffix): If we used this suffix, would we rename
> DoubleEndedIterator to DoubleEndedIter? That looks awkward since we
> abbreviated Iterator without abbreviating anything else. However,
> DblEndedIter is a monstrosity. So, this convention seems non-ideal to me.
>
> #3 (no suffix): I think its pretty confusing while reading through code
> that there are both iter::Map and container::Map since they are completely
> unrelated. I'm also not a big fan of Union since I think as a union as a
> collection of information that I can iterate multiple times. However, since
> Union is itself an Iterator, I can only iterate it once. This means I would
> have to be careful passing a Union around to make sure I don't pass around
> an already iterated Union object.
>
> So, I opened up https://github.com/mozilla/rust/pull/11001 to standardize
> on #1 - all Iterators have an Iterator suffix.
>
> Thoughts?
>
> -Palmer Cox
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Yati Sagade

Software Engineer at mquotient <http://www.mquotient.net/>
<http://twitter.com/yati_itay>

Twitter: @yati_itay <http://twitter.com/yati_itay> | Github:
yati-sagade<https://github.com/yati-sagade>

Organizing member of TEDx EasternMetropolitanBypass
http://www.ted.com/tedx/events/4933
https://www.facebook.com/pages/TEDx-EasternMetropolitanBypass/337763226244869
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/3096d204/attachment-0001.html>

From acrichton at mozilla.com  Fri Dec 20 22:50:40 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Fri, 20 Dec 2013 22:50:40 -0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
Message-ID: <CAFnh-md0vmrvU6arHz4G1hiScbV_5=syXoPEwsC2vxGNPoKktg@mail.gmail.com>

In the past we have explicitly attempted to drop as many suffixes as
possible (see #8090). This is a little bit of a tricky topic, and to
me it depends on how you name the iterator. To me, iter::Map and
container::Map are clearly different if they are named that way. If
they are imported and then named via Map, then I can see how there
would be some confusion. I have a preference to naming things through
a module instead of importing giant numbers of capital-letter things
at the top of a file.

We already have an open issue about reorganizing libstd (#9208) with a
major goal of reducing stuttering all over the place (which adding
Iterator suffixes would add in a few places).

Mostly just food for thought.

On Fri, Dec 20, 2013 at 8:51 PM, Palmer Cox <palmercox at gmail.com> wrote:
> I noticed recently that there seem to be 3 distinct Iterator naming
> conventions currently in use:
>
> 1. Use the "Iterator" suffix. Examples of this are SplitIterator and
> DoubleEndedIterator.
> 2. Use the "Iter" suffix. Examples of this are ChunkIter and ComponentIter.
> 3. Use no particular suffix. Examples of this are Invert and Union.
>
> Iterators are somewhat special objects, so, it makes sense to me that they
> have a suffix in common to denote their common behavior. It seems non-ideal,
> however, that there appear to be 3 separate conventions in use since that is
> just confusing. Personally, I think I prefer #1 because its far and away the
> most common and and because I think #2 and #3 have issues:
>
> #2 ("Iter" suffix): If we used this suffix, would we rename
> DoubleEndedIterator to DoubleEndedIter? That looks awkward since we
> abbreviated Iterator without abbreviating anything else. However,
> DblEndedIter is a monstrosity. So, this convention seems non-ideal to me.
>
> #3 (no suffix): I think its pretty confusing while reading through code that
> there are both iter::Map and container::Map since they are completely
> unrelated. I'm also not a big fan of Union since I think as a union as a
> collection of information that I can iterate multiple times. However, since
> Union is itself an Iterator, I can only iterate it once. This means I would
> have to be careful passing a Union around to make sure I don't pass around
> an already iterated Union object.
>
> So, I opened up https://github.com/mozilla/rust/pull/11001 to standardize on
> #1 - all Iterators have an Iterator suffix.
>
> Thoughts?
>
> -Palmer Cox
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From hatahet at gmail.com  Sat Dec 21 06:20:08 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 21 Dec 2013 06:20:08 -0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAFnh-md0vmrvU6arHz4G1hiScbV_5=syXoPEwsC2vxGNPoKktg@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAFnh-md0vmrvU6arHz4G1hiScbV_5=syXoPEwsC2vxGNPoKktg@mail.gmail.com>
Message-ID: <CAN1rdEwx6T-rv885azz9i1VtASE=VaBzvgbY5wxNvKdVP1DdKA@mail.gmail.com>

I favor this approach too. As an example, Scala does something similar: a
call to Map() constructs an immutable map object (it is in the "default"
namespace), whereas if you want a mutable Map object, you have to import it
from scala.collection.mutable.Map.

--
Ziad


On Fri, Dec 20, 2013 at 10:50 PM, Alex Crichton <acrichton at mozilla.com>wrote:

> In the past we have explicitly attempted to drop as many suffixes as
> possible (see #8090). This is a little bit of a tricky topic, and to
> me it depends on how you name the iterator. To me, iter::Map and
> container::Map are clearly different if they are named that way. If
> they are imported and then named via Map, then I can see how there
> would be some confusion. I have a preference to naming things through
> a module instead of importing giant numbers of capital-letter things
> at the top of a file.
>
> We already have an open issue about reorganizing libstd (#9208) with a
> major goal of reducing stuttering all over the place (which adding
> Iterator suffixes would add in a few places).
>
> Mostly just food for thought.
>
> On Fri, Dec 20, 2013 at 8:51 PM, Palmer Cox <palmercox at gmail.com> wrote:
> > I noticed recently that there seem to be 3 distinct Iterator naming
> > conventions currently in use:
> >
> > 1. Use the "Iterator" suffix. Examples of this are SplitIterator and
> > DoubleEndedIterator.
> > 2. Use the "Iter" suffix. Examples of this are ChunkIter and
> ComponentIter.
> > 3. Use no particular suffix. Examples of this are Invert and Union.
> >
> > Iterators are somewhat special objects, so, it makes sense to me that
> they
> > have a suffix in common to denote their common behavior. It seems
> non-ideal,
> > however, that there appear to be 3 separate conventions in use since
> that is
> > just confusing. Personally, I think I prefer #1 because its far and away
> the
> > most common and and because I think #2 and #3 have issues:
> >
> > #2 ("Iter" suffix): If we used this suffix, would we rename
> > DoubleEndedIterator to DoubleEndedIter? That looks awkward since we
> > abbreviated Iterator without abbreviating anything else. However,
> > DblEndedIter is a monstrosity. So, this convention seems non-ideal to me.
> >
> > #3 (no suffix): I think its pretty confusing while reading through code
> that
> > there are both iter::Map and container::Map since they are completely
> > unrelated. I'm also not a big fan of Union since I think as a union as a
> > collection of information that I can iterate multiple times. However,
> since
> > Union is itself an Iterator, I can only iterate it once. This means I
> would
> > have to be careful passing a Union around to make sure I don't pass
> around
> > an already iterated Union object.
> >
> > So, I opened up https://github.com/mozilla/rust/pull/11001 to
> standardize on
> > #1 - all Iterators have an Iterator suffix.
> >
> > Thoughts?
> >
> > -Palmer Cox
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/dd476c38/attachment.html>

From pansbc at gmail.com  Sat Dec 21 06:23:23 2013
From: pansbc at gmail.com (Pedro Santos)
Date: Sat, 21 Dec 2013 14:23:23 +0000
Subject: [rust-dev] UK Servers down
Message-ID: <CA+gBkden0r_ST3NcG57ND7zMn38XeZ=6T2NCRsB8GXhVjQc5uw@mail.gmail.com>

Hello,

Is it possible to some one to explaion why the UK servers are all down ?
i know the game is a beta but because i pay for it and its not free 4 play
i think ppl deserve an explanation why the servers are down for the last 20
hours.

Regards,

Pedro
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/c1fc0fc0/attachment.html>

From hatahet at gmail.com  Sat Dec 21 06:27:37 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 21 Dec 2013 06:27:37 -0800
Subject: [rust-dev] UK Servers down
In-Reply-To: <CA+gBkden0r_ST3NcG57ND7zMn38XeZ=6T2NCRsB8GXhVjQc5uw@mail.gmail.com>
References: <CA+gBkden0r_ST3NcG57ND7zMn38XeZ=6T2NCRsB8GXhVjQc5uw@mail.gmail.com>
Message-ID: <CAN1rdEyC+LtMNLUT49yksqhWfS8fF0TF9Hn0CKp0WN_2nHK9Fw@mail.gmail.com>

I think you have the wrong mailing list :) This is for the Rust programming
language (rust-lang.org), not the Rust game.

--
Ziad


On Sat, Dec 21, 2013 at 6:23 AM, Pedro Santos <pansbc at gmail.com> wrote:

> Hello,
>
> Is it possible to some one to explaion why the UK servers are all down ?
> i know the game is a beta but because i pay for it and its not free 4 play
> i think ppl deserve an explanation why the servers are down for the last 20
> hours.
>
> Regards,
>
> Pedro
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/fff4555c/attachment.html>

From com.liigo at gmail.com  Sat Dec 21 06:30:12 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Sat, 21 Dec 2013 22:30:12 +0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
Message-ID: <CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>

I like Iter suffix, short, and say what it is.
? 2013?12?21? ??12:51?"Palmer Cox" <palmercox at gmail.com>???

> I noticed recently that there seem to be 3 distinct Iterator naming
> conventions currently in use:
>
> 1. Use the "Iterator" suffix. Examples of this are SplitIterator and
> DoubleEndedIterator.
> 2. Use the "Iter" suffix. Examples of this are ChunkIter and ComponentIter.
> 3. Use no particular suffix. Examples of this are Invert and Union.
>
> Iterators are somewhat special objects, so, it makes sense to me that they
> have a suffix in common to denote their common behavior. It seems
> non-ideal, however, that there appear to be 3 separate conventions in use
> since that is just confusing. Personally, I think I prefer #1 because its
> far and away the most common and and because I think #2 and #3 have issues:
>
> #2 ("Iter" suffix): If we used this suffix, would we rename
> DoubleEndedIterator to DoubleEndedIter? That looks awkward since we
> abbreviated Iterator without abbreviating anything else. However,
> DblEndedIter is a monstrosity. So, this convention seems non-ideal to me.
>
> #3 (no suffix): I think its pretty confusing while reading through code
> that there are both iter::Map and container::Map since they are completely
> unrelated. I'm also not a big fan of Union since I think as a union as a
> collection of information that I can iterate multiple times. However, since
> Union is itself an Iterator, I can only iterate it once. This means I would
> have to be careful passing a Union around to make sure I don't pass around
> an already iterated Union object.
>
> So, I opened up https://github.com/mozilla/rust/pull/11001 to standardize
> on #1 - all Iterators have an Iterator suffix.
>
> Thoughts?
>
> -Palmer Cox
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/3e03ed40/attachment-0001.html>

From me at kevincantu.org  Sat Dec 21 12:14:51 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Sat, 21 Dec 2013 12:14:51 -0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
Message-ID: <CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>

IMHO Hungarian notation is for things the type system and tooling
cannot deal with.  I'm not sure this is one of them...


Kevin

From palmercox at gmail.com  Sat Dec 21 12:50:55 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Sat, 21 Dec 2013 15:50:55 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
Message-ID: <CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>

I'm not a big fan of Hungarian notation either. I'm not sure that having a
naming convention for Iterators is Hungarian notation, however. For
example, if you are doing Windows programming, you'll see stuff like:

DWORD dwFoo = 0;

In this case, the "dw" prefix on the variable indicates that we have a
DWORD variable. However, the Iterator suffix that I'm proposing here is a
suffix on the type names, not the actual variable names. So, if you are
writing Rust code, you'd write something like this:

let chunks = some_vector.chunks(50);

So, the actual variable name doesn't have the Hungarian notation and the
types aren't even generally visible since the compiler infers much of that.
However, someone reading through the documentation and/or code will see a
struct named ChunkIterator and instance know how the struct behaves - as an
Iterator. So, I think the suffix serves less to describe the datatype and
more to describe class of behavior that the struct implements.

Anyway, as I said, I prefer #1. But, I also have done lots of Java
programming so I'm probably much more used to verbosity than others. I'm
not horribly against some sort of other naming convention, either, of
course, but I would like to see some consistency.

My main motivation for opening the request was because I created
MutChunkIter and then realized that it was named differently than majority
of other Iterators. I don't want to be responsible for someone reading
through the docs and seeing something thats inconsistent for no good
reason! Also, I was reading through some code and happened upon a "Map" and
was exceptionally confused about it, until I realized it was iter::Map as
opposed to container::Map. I figured I probably wasn't the only person that
was going to be confused by something like this.

-Palmer Cox





On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org> wrote:

> IMHO Hungarian notation is for things the type system and tooling
> cannot deal with.  I'm not sure this is one of them...
>
>
> Kevin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/08a20dd3/attachment.html>

From me at kevincantu.org  Sat Dec 21 13:24:30 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Sat, 21 Dec 2013 13:24:30 -0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
Message-ID: <CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>

Iterators are just structs which implement the "Iterator" or a related
trait, right?

These structs which do can also implement lots of other traits, too:
no reason to make -Iter special.


Kevin



On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com> wrote:
> I'm not a big fan of Hungarian notation either. I'm not sure that having a
> naming convention for Iterators is Hungarian notation, however. For example,
> if you are doing Windows programming, you'll see stuff like:
>
> DWORD dwFoo = 0;
>
> In this case, the "dw" prefix on the variable indicates that we have a DWORD
> variable. However, the Iterator suffix that I'm proposing here is a suffix
> on the type names, not the actual variable names. So, if you are writing
> Rust code, you'd write something like this:
>
> let chunks = some_vector.chunks(50);
>
> So, the actual variable name doesn't have the Hungarian notation and the
> types aren't even generally visible since the compiler infers much of that.
> However, someone reading through the documentation and/or code will see a
> struct named ChunkIterator and instance know how the struct behaves - as an
> Iterator. So, I think the suffix serves less to describe the datatype and
> more to describe class of behavior that the struct implements.
>
> Anyway, as I said, I prefer #1. But, I also have done lots of Java
> programming so I'm probably much more used to verbosity than others. I'm not
> horribly against some sort of other naming convention, either, of course,
> but I would like to see some consistency.
>
> My main motivation for opening the request was because I created
> MutChunkIter and then realized that it was named differently than majority
> of other Iterators. I don't want to be responsible for someone reading
> through the docs and seeing something thats inconsistent for no good reason!
> Also, I was reading through some code and happened upon a "Map" and was
> exceptionally confused about it, until I realized it was iter::Map as
> opposed to container::Map. I figured I probably wasn't the only person that
> was going to be confused by something like this.
>
> -Palmer Cox
>
>
>
>
>
> On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>
>> IMHO Hungarian notation is for things the type system and tooling
>> cannot deal with.  I'm not sure this is one of them...
>>
>>
>> Kevin
>
>

From palmercox at gmail.com  Sat Dec 21 13:30:56 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Sat, 21 Dec 2013 16:30:56 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
Message-ID: <CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>

Are there examples of structs that implement Iterator that also implement
other non-Iterator related traits? Although its possible to do that, I
can't think of a use case for it off the top of my head. An Iterator
basically represents the state of an ongoing computation and once that
computation is completed, the object is mostly uselss. It seems like it
would be awkward to implement other traits for such an object. Maybe I'm
not thinking of something, however.

-Palmer Cox



On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org> wrote:

> Iterators are just structs which implement the "Iterator" or a related
> trait, right?
>
> These structs which do can also implement lots of other traits, too:
> no reason to make -Iter special.
>
>
> Kevin
>
>
>
> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com> wrote:
> > I'm not a big fan of Hungarian notation either. I'm not sure that having
> a
> > naming convention for Iterators is Hungarian notation, however. For
> example,
> > if you are doing Windows programming, you'll see stuff like:
> >
> > DWORD dwFoo = 0;
> >
> > In this case, the "dw" prefix on the variable indicates that we have a
> DWORD
> > variable. However, the Iterator suffix that I'm proposing here is a
> suffix
> > on the type names, not the actual variable names. So, if you are writing
> > Rust code, you'd write something like this:
> >
> > let chunks = some_vector.chunks(50);
> >
> > So, the actual variable name doesn't have the Hungarian notation and the
> > types aren't even generally visible since the compiler infers much of
> that.
> > However, someone reading through the documentation and/or code will see a
> > struct named ChunkIterator and instance know how the struct behaves - as
> an
> > Iterator. So, I think the suffix serves less to describe the datatype and
> > more to describe class of behavior that the struct implements.
> >
> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
> > programming so I'm probably much more used to verbosity than others. I'm
> not
> > horribly against some sort of other naming convention, either, of course,
> > but I would like to see some consistency.
> >
> > My main motivation for opening the request was because I created
> > MutChunkIter and then realized that it was named differently than
> majority
> > of other Iterators. I don't want to be responsible for someone reading
> > through the docs and seeing something thats inconsistent for no good
> reason!
> > Also, I was reading through some code and happened upon a "Map" and was
> > exceptionally confused about it, until I realized it was iter::Map as
> > opposed to container::Map. I figured I probably wasn't the only person
> that
> > was going to be confused by something like this.
> >
> > -Palmer Cox
> >
> >
> >
> >
> >
> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org> wrote:
> >>
> >> IMHO Hungarian notation is for things the type system and tooling
> >> cannot deal with.  I'm not sure this is one of them...
> >>
> >>
> >> Kevin
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/cf58ba68/attachment.html>

From me at kevincantu.org  Sat Dec 21 13:35:52 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Sat, 21 Dec 2013 13:35:52 -0800
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
Message-ID: <CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>

Rust's standard libs are still pretty thin on their trait hierarchies,
but I'm sure this will change.

Kevin

On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com> wrote:
> Are there examples of structs that implement Iterator that also implement
> other non-Iterator related traits? Although its possible to do that, I can't
> think of a use case for it off the top of my head. An Iterator basically
> represents the state of an ongoing computation and once that computation is
> completed, the object is mostly uselss. It seems like it would be awkward to
> implement other traits for such an object. Maybe I'm not thinking of
> something, however.
>
> -Palmer Cox
>
>
>
> On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>
>> Iterators are just structs which implement the "Iterator" or a related
>> trait, right?
>>
>> These structs which do can also implement lots of other traits, too:
>> no reason to make -Iter special.
>>
>>
>> Kevin
>>
>>
>>
>> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com> wrote:
>> > I'm not a big fan of Hungarian notation either. I'm not sure that having
>> > a
>> > naming convention for Iterators is Hungarian notation, however. For
>> > example,
>> > if you are doing Windows programming, you'll see stuff like:
>> >
>> > DWORD dwFoo = 0;
>> >
>> > In this case, the "dw" prefix on the variable indicates that we have a
>> > DWORD
>> > variable. However, the Iterator suffix that I'm proposing here is a
>> > suffix
>> > on the type names, not the actual variable names. So, if you are writing
>> > Rust code, you'd write something like this:
>> >
>> > let chunks = some_vector.chunks(50);
>> >
>> > So, the actual variable name doesn't have the Hungarian notation and the
>> > types aren't even generally visible since the compiler infers much of
>> > that.
>> > However, someone reading through the documentation and/or code will see
>> > a
>> > struct named ChunkIterator and instance know how the struct behaves - as
>> > an
>> > Iterator. So, I think the suffix serves less to describe the datatype
>> > and
>> > more to describe class of behavior that the struct implements.
>> >
>> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
>> > programming so I'm probably much more used to verbosity than others. I'm
>> > not
>> > horribly against some sort of other naming convention, either, of
>> > course,
>> > but I would like to see some consistency.
>> >
>> > My main motivation for opening the request was because I created
>> > MutChunkIter and then realized that it was named differently than
>> > majority
>> > of other Iterators. I don't want to be responsible for someone reading
>> > through the docs and seeing something thats inconsistent for no good
>> > reason!
>> > Also, I was reading through some code and happened upon a "Map" and was
>> > exceptionally confused about it, until I realized it was iter::Map as
>> > opposed to container::Map. I figured I probably wasn't the only person
>> > that
>> > was going to be confused by something like this.
>> >
>> > -Palmer Cox
>> >
>> >
>> >
>> >
>> >
>> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org> wrote:
>> >>
>> >> IMHO Hungarian notation is for things the type system and tooling
>> >> cannot deal with.  I'm not sure this is one of them...
>> >>
>> >>
>> >> Kevin
>> >
>> >
>
>

From corey at octayn.net  Sat Dec 21 17:22:18 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 21 Dec 2013 20:22:18 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
	<CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
Message-ID: <CA++BO6QWuoRjoNA_NLybJS3TDZX6w72iMyjv5M_Juv_Wkx6S0A@mail.gmail.com>

The reason the Iterator suffix was removed is because when when one is
required to write the type signature it becomes hugely annoying to
keep writing Iterator all the time. Personally I think Alex's idea is
a good way forward.

On Sat, Dec 21, 2013 at 4:35 PM, Kevin Cantu <me at kevincantu.org> wrote:
> Rust's standard libs are still pretty thin on their trait hierarchies,
> but I'm sure this will change.
>
> Kevin
>
> On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com> wrote:
>> Are there examples of structs that implement Iterator that also implement
>> other non-Iterator related traits? Although its possible to do that, I can't
>> think of a use case for it off the top of my head. An Iterator basically
>> represents the state of an ongoing computation and once that computation is
>> completed, the object is mostly uselss. It seems like it would be awkward to
>> implement other traits for such an object. Maybe I'm not thinking of
>> something, however.
>>
>> -Palmer Cox
>>
>>
>>
>> On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>>
>>> Iterators are just structs which implement the "Iterator" or a related
>>> trait, right?
>>>
>>> These structs which do can also implement lots of other traits, too:
>>> no reason to make -Iter special.
>>>
>>>
>>> Kevin
>>>
>>>
>>>
>>> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com> wrote:
>>> > I'm not a big fan of Hungarian notation either. I'm not sure that having
>>> > a
>>> > naming convention for Iterators is Hungarian notation, however. For
>>> > example,
>>> > if you are doing Windows programming, you'll see stuff like:
>>> >
>>> > DWORD dwFoo = 0;
>>> >
>>> > In this case, the "dw" prefix on the variable indicates that we have a
>>> > DWORD
>>> > variable. However, the Iterator suffix that I'm proposing here is a
>>> > suffix
>>> > on the type names, not the actual variable names. So, if you are writing
>>> > Rust code, you'd write something like this:
>>> >
>>> > let chunks = some_vector.chunks(50);
>>> >
>>> > So, the actual variable name doesn't have the Hungarian notation and the
>>> > types aren't even generally visible since the compiler infers much of
>>> > that.
>>> > However, someone reading through the documentation and/or code will see
>>> > a
>>> > struct named ChunkIterator and instance know how the struct behaves - as
>>> > an
>>> > Iterator. So, I think the suffix serves less to describe the datatype
>>> > and
>>> > more to describe class of behavior that the struct implements.
>>> >
>>> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
>>> > programming so I'm probably much more used to verbosity than others. I'm
>>> > not
>>> > horribly against some sort of other naming convention, either, of
>>> > course,
>>> > but I would like to see some consistency.
>>> >
>>> > My main motivation for opening the request was because I created
>>> > MutChunkIter and then realized that it was named differently than
>>> > majority
>>> > of other Iterators. I don't want to be responsible for someone reading
>>> > through the docs and seeing something thats inconsistent for no good
>>> > reason!
>>> > Also, I was reading through some code and happened upon a "Map" and was
>>> > exceptionally confused about it, until I realized it was iter::Map as
>>> > opposed to container::Map. I figured I probably wasn't the only person
>>> > that
>>> > was going to be confused by something like this.
>>> >
>>> > -Palmer Cox
>>> >
>>> >
>>> >
>>> >
>>> >
>>> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>> >>
>>> >> IMHO Hungarian notation is for things the type system and tooling
>>> >> cannot deal with.  I'm not sure this is one of them...
>>> >>
>>> >>
>>> >> Kevin
>>> >
>>> >
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ecreed at cs.washington.edu  Sat Dec 21 17:43:33 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Sat, 21 Dec 2013 20:43:33 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
	<CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
Message-ID: <CANbMr6E9cE3n+T6DMZ0EHaUG89esNiLCyzK3LEA8tVjXXs3rPA@mail.gmail.com>

I prefer the 'no suffix' option and generally agree with Alex.
Iterators aren't special and their iterator behavior is already denoted by
implementing the Iterator trait.

Frankly, aside from documentation where it is clear that something is an
iterator, I'm not sure when a user would even see concrete iterator types.
I can't think of a reason why you'd ever want to restrict the type of a
variable to a specific kind of iterator (i.e. Map or Union).

Acceptor and Port could implement Iterator directly, but currently they
create a struct containing only a mutable borrow of themselves to prevent
anything else from using the socket/channel in the meantime.
Reader could directly implement an Iterator that does one byte reads, but
currently it does the same trick as Acceptor and Port.
You only need a separate Iterator object if you actually require additional
state or if you want to prevent others from changing the underlying source
(mutable borrow of self).



On Sat, Dec 21, 2013 at 4:35 PM, Kevin Cantu <me at kevincantu.org> wrote:

> Rust's standard libs are still pretty thin on their trait hierarchies,
> but I'm sure this will change.
>
> Kevin
>
> On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com> wrote:
> > Are there examples of structs that implement Iterator that also implement
> > other non-Iterator related traits? Although its possible to do that, I
> can't
> > think of a use case for it off the top of my head. An Iterator basically
> > represents the state of an ongoing computation and once that computation
> is
> > completed, the object is mostly uselss. It seems like it would be
> awkward to
> > implement other traits for such an object. Maybe I'm not thinking of
> > something, however.
> >
> > -Palmer Cox
> >
> >
> >
> > On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org> wrote:
> >>
> >> Iterators are just structs which implement the "Iterator" or a related
> >> trait, right?
> >>
> >> These structs which do can also implement lots of other traits, too:
> >> no reason to make -Iter special.
> >>
> >>
> >> Kevin
> >>
> >>
> >>
> >> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com>
> wrote:
> >> > I'm not a big fan of Hungarian notation either. I'm not sure that
> having
> >> > a
> >> > naming convention for Iterators is Hungarian notation, however. For
> >> > example,
> >> > if you are doing Windows programming, you'll see stuff like:
> >> >
> >> > DWORD dwFoo = 0;
> >> >
> >> > In this case, the "dw" prefix on the variable indicates that we have a
> >> > DWORD
> >> > variable. However, the Iterator suffix that I'm proposing here is a
> >> > suffix
> >> > on the type names, not the actual variable names. So, if you are
> writing
> >> > Rust code, you'd write something like this:
> >> >
> >> > let chunks = some_vector.chunks(50);
> >> >
> >> > So, the actual variable name doesn't have the Hungarian notation and
> the
> >> > types aren't even generally visible since the compiler infers much of
> >> > that.
> >> > However, someone reading through the documentation and/or code will
> see
> >> > a
> >> > struct named ChunkIterator and instance know how the struct behaves -
> as
> >> > an
> >> > Iterator. So, I think the suffix serves less to describe the datatype
> >> > and
> >> > more to describe class of behavior that the struct implements.
> >> >
> >> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
> >> > programming so I'm probably much more used to verbosity than others.
> I'm
> >> > not
> >> > horribly against some sort of other naming convention, either, of
> >> > course,
> >> > but I would like to see some consistency.
> >> >
> >> > My main motivation for opening the request was because I created
> >> > MutChunkIter and then realized that it was named differently than
> >> > majority
> >> > of other Iterators. I don't want to be responsible for someone reading
> >> > through the docs and seeing something thats inconsistent for no good
> >> > reason!
> >> > Also, I was reading through some code and happened upon a "Map" and
> was
> >> > exceptionally confused about it, until I realized it was iter::Map as
> >> > opposed to container::Map. I figured I probably wasn't the only person
> >> > that
> >> > was going to be confused by something like this.
> >> >
> >> > -Palmer Cox
> >> >
> >> >
> >> >
> >> >
> >> >
> >> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org>
> wrote:
> >> >>
> >> >> IMHO Hungarian notation is for things the type system and tooling
> >> >> cannot deal with.  I'm not sure this is one of them...
> >> >>
> >> >>
> >> >> Kevin
> >> >
> >> >
> >
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/793c00a8/attachment.html>

From ecreed at cs.washington.edu  Sat Dec 21 18:33:47 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Sat, 21 Dec 2013 21:33:47 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0z2rwn+C-=KBqdSx0B--NB7Uh+tgBF7ZkvPXfhcQFR2AA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
	<0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
	<CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>
	<CAHYVw0z2rwn+C-=KBqdSx0B--NB7Uh+tgBF7ZkvPXfhcQFR2AA@mail.gmail.com>
Message-ID: <CANbMr6EfCXvMqG=tL5YzrNLKFKK828CC_HW5R_a=JYCit77_uw@mail.gmail.com>

IMO the best alternative for a non-blocking send on a bounded channel is
returning an Option.
If you send successfully, you return None.
If you can't send because the channel is full, you return Some(message).
This lets the sender recover the message (important for moveable objects)
and decide how to handle it (retry, fail, drop, etc.).

Personally, I lean toward providing unbounded channels as the primitive and
implementing bounded channels on top of them OR providing both as
primitives.


On Fri, Dec 20, 2013 at 4:19 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> actually, you're right, in go they're fixed sized buffers
> http://golang.org/src/pkg/runtime/chan.c . I can understands (and agree!)
> that this is not a good default if a more dynamic data structure can work
> well.
>
> in haskell / ghc , bounded channels are dynamically sized, and merely have
> a max size thats enforced by the provided api,and I've been speaking with
> that sort of memory usage model in mind.
>
>
> On Fri, Dec 20, 2013 at 4:15 PM, Carter Schonwald <
> carter.schonwald at gmail.com> wrote:
>
>> i'd be very very surprised if bounded channels in go don't dynamically
>> resize their queues and then atomically insert / remove elements while
>> checking the bound.  I'd actually argue that such would be a bug.
>>
>>
>> On Fri, Dec 20, 2013 at 4:09 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>>> I haven?t profiled it, but my belief is that under normal circumstances,
>>> messages come in slow enough that the consumer is always idle and ready to
>>> process the next message as soon as it?s sent. However, I expect it does
>>> occasionally back up a bit, e.g. when I get a burst of traffic such as
>>> during a netsplit when I?m sent a large batch of ?<user> has quit? or
>>> ?<user> has joined? (when the netsplit is over). I don?t know how much the
>>> channel backs up at that point, probably not too much.
>>>
>>> For this particular use-case, a channel that?s bounded at e.g. 100,000
>>> elements would be indistinguishable from an infinite channel, as long as it
>>> still dynamically allocates (I don?t *think* Go channels dynamically
>>> allocate, which is why I can?t just use a 100,000 element channel for real).
>>>
>>> However, my overall point about large bounds being indistinguishable
>>> from infinite is that if your goal is to pick a bound large enough to
>>> appear infinite to the program, without actually risking OOM, then there?s
>>> no automated way to do this. Different environments have differing amounts
>>> of available resources, and there?s no good way to pick a bound that is
>>> sufficiently high but is definitively lower than the resource bounds. This
>>> is why I?m recommending that we have truly infinite channels, for users who
>>> don?t want to have to think about bounds (e.g. my irc program), as well as
>>> bounded channels, where the user has to explicitly pick a bound (with no
>>> ?default? provided).
>>>
>>> -Kevin
>>>
>>> On Dec 20, 2013, at 12:55 PM, Carter Schonwald <
>>> carter.schonwald at gmail.com> wrote:
>>>
>>> kevin, what sort of applications and workloads are you speaking about.
>>> Eg in your example irc server, whats the typical workload when you've used
>>> it?
>>>
>>> cheers
>>> -Carter
>>>
>>>
>>> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>>> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <
>>>> carter.schonwald at gmail.com> wrote:
>>>>
>>>> agreed! Applications that lack explicit logic for handling heavy
>>>> workloads (ie producers outpacing consumers for a sustained period) are the
>>>> most common culprit for unresponsive desktop applications that become
>>>> completely unusable.
>>>>
>>>>
>>>> That?s a pretty strong claim, and one I would have to disagree with
>>>> quite strongly. Every time I?ve sampled an unresponsive application, I
>>>> don?t think I?ve *ever* seen a backtrace that suggests a producer
>>>> outpacing a consumer.
>>>>
>>>> -Kevin
>>>>
>>>> relatedly: would not bounded but programmatically growable channels
>>>> also make it trivial to provide a "unbounded" style channel abstraction?
>>>> (not that i'm advocating that, merely that it seems like it would turn the
>>>> unbounded channel abstraction into an equivalent one that is resource usage
>>>> aware)
>>>>
>>>>
>>>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com>wrote:
>>>>
>>>>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>>>>
>>>>>> So I think that entire line of reasoning is a red herring. People
>>>>>> writing toy programs that never have their channels fill beyond a
>>>>>> small
>>>>>> number of messages won't care either way.
>>>>>>
>>>>>> However, overloaded programs + queues bounded by system resources are
>>>>>> a
>>>>>> production outage waiting to happen. What's really important here is
>>>>>> providing a means of backpressure so overloaded Rust programs don't
>>>>>> grow
>>>>>> until they consume system resources and OOM.
>>>>>>
>>>>>
>>>>> While I disagree with the notion that all programs which don't have
>>>>> their bottlenecks right here are "toys", we should definitely strive for
>>>>> the invariant that task failure does not cause independent tasks to fail.
>>>>>
>>>>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll
>>>>> get a *very* unhappy user, regardless of their expectations wrt your memory
>>>>> usage. Linux with a spinning disk and swap for example will degrade to the
>>>>> point where they'll reboot before the OOM killer kicks in.
>>>>>
>>>>> Can we PLEASE not do that *by default*?
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>>
>>>
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/ac307aa6/attachment-0001.html>

From carter.schonwald at gmail.com  Sat Dec 21 19:48:25 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sat, 21 Dec 2013 22:48:25 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CANbMr6EfCXvMqG=tL5YzrNLKFKK828CC_HW5R_a=JYCit77_uw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
	<0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
	<CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>
	<CAHYVw0z2rwn+C-=KBqdSx0B--NB7Uh+tgBF7ZkvPXfhcQFR2AA@mail.gmail.com>
	<CANbMr6EfCXvMqG=tL5YzrNLKFKK828CC_HW5R_a=JYCit77_uw@mail.gmail.com>
Message-ID: <CAHYVw0w8S5UJhaNY57zgDnGJVEi4xU-7aPnqt_rSvTvgUzfvNA@mail.gmail.com>

Eric, thats exactly why I suggested the use of the Result or Either type.
 Some is a bit misleaning, because the Nothing case is usually means a
failure rather than a success.


On Sat, Dec 21, 2013 at 9:33 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> IMO the best alternative for a non-blocking send on a bounded channel is
> returning an Option.
> If you send successfully, you return None.
> If you can't send because the channel is full, you return Some(message).
> This lets the sender recover the message (important for moveable objects)
> and decide how to handle it (retry, fail, drop, etc.).
>
> Personally, I lean toward providing unbounded channels as the primitive
> and implementing bounded channels on top of them OR providing both as
> primitives.
>
>
> On Fri, Dec 20, 2013 at 4:19 PM, Carter Schonwald <
> carter.schonwald at gmail.com> wrote:
>
>> actually, you're right, in go they're fixed sized buffers
>> http://golang.org/src/pkg/runtime/chan.c . I can understands (and
>> agree!) that this is not a good default if a more dynamic data structure
>> can work well.
>>
>> in haskell / ghc , bounded channels are dynamically sized, and merely
>> have a max size thats enforced by the provided api,and I've been speaking
>> with that sort of memory usage model in mind.
>>
>>
>> On Fri, Dec 20, 2013 at 4:15 PM, Carter Schonwald <
>> carter.schonwald at gmail.com> wrote:
>>
>>> i'd be very very surprised if bounded channels in go don't dynamically
>>> resize their queues and then atomically insert / remove elements while
>>> checking the bound.  I'd actually argue that such would be a bug.
>>>
>>>
>>> On Fri, Dec 20, 2013 at 4:09 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>>> I haven?t profiled it, but my belief is that under normal
>>>> circumstances, messages come in slow enough that the consumer is always
>>>> idle and ready to process the next message as soon as it?s sent. However, I
>>>> expect it does occasionally back up a bit, e.g. when I get a burst of
>>>> traffic such as during a netsplit when I?m sent a large batch of ?<user>
>>>> has quit? or ?<user> has joined? (when the netsplit is over). I don?t know
>>>> how much the channel backs up at that point, probably not too much.
>>>>
>>>> For this particular use-case, a channel that?s bounded at e.g. 100,000
>>>> elements would be indistinguishable from an infinite channel, as long as it
>>>> still dynamically allocates (I don?t *think* Go channels dynamically
>>>> allocate, which is why I can?t just use a 100,000 element channel for real).
>>>>
>>>> However, my overall point about large bounds being indistinguishable
>>>> from infinite is that if your goal is to pick a bound large enough to
>>>> appear infinite to the program, without actually risking OOM, then there?s
>>>> no automated way to do this. Different environments have differing amounts
>>>> of available resources, and there?s no good way to pick a bound that is
>>>> sufficiently high but is definitively lower than the resource bounds. This
>>>> is why I?m recommending that we have truly infinite channels, for users who
>>>> don?t want to have to think about bounds (e.g. my irc program), as well as
>>>> bounded channels, where the user has to explicitly pick a bound (with no
>>>> ?default? provided).
>>>>
>>>> -Kevin
>>>>
>>>> On Dec 20, 2013, at 12:55 PM, Carter Schonwald <
>>>> carter.schonwald at gmail.com> wrote:
>>>>
>>>> kevin, what sort of applications and workloads are you speaking about.
>>>> Eg in your example irc server, whats the typical workload when you've used
>>>> it?
>>>>
>>>> cheers
>>>> -Carter
>>>>
>>>>
>>>> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>>> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <
>>>>> carter.schonwald at gmail.com> wrote:
>>>>>
>>>>> agreed! Applications that lack explicit logic for handling heavy
>>>>> workloads (ie producers outpacing consumers for a sustained period) are the
>>>>> most common culprit for unresponsive desktop applications that become
>>>>> completely unusable.
>>>>>
>>>>>
>>>>> That?s a pretty strong claim, and one I would have to disagree with
>>>>> quite strongly. Every time I?ve sampled an unresponsive application, I
>>>>> don?t think I?ve *ever* seen a backtrace that suggests a producer
>>>>> outpacing a consumer.
>>>>>
>>>>> -Kevin
>>>>>
>>>>> relatedly: would not bounded but programmatically growable channels
>>>>> also make it trivial to provide a "unbounded" style channel abstraction?
>>>>> (not that i'm advocating that, merely that it seems like it would turn the
>>>>> unbounded channel abstraction into an equivalent one that is resource usage
>>>>> aware)
>>>>>
>>>>>
>>>>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com>wrote:
>>>>>
>>>>>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>>>>>
>>>>>>> So I think that entire line of reasoning is a red herring. People
>>>>>>> writing toy programs that never have their channels fill beyond a
>>>>>>> small
>>>>>>> number of messages won't care either way.
>>>>>>>
>>>>>>> However, overloaded programs + queues bounded by system resources
>>>>>>> are a
>>>>>>> production outage waiting to happen. What's really important here is
>>>>>>> providing a means of backpressure so overloaded Rust programs don't
>>>>>>> grow
>>>>>>> until they consume system resources and OOM.
>>>>>>>
>>>>>>
>>>>>> While I disagree with the notion that all programs which don't have
>>>>>> their bottlenecks right here are "toys", we should definitely strive for
>>>>>> the invariant that task failure does not cause independent tasks to fail.
>>>>>>
>>>>>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll
>>>>>> get a *very* unhappy user, regardless of their expectations wrt your memory
>>>>>> usage. Linux with a spinning disk and swap for example will degrade to the
>>>>>> point where they'll reboot before the OOM killer kicks in.
>>>>>>
>>>>>> Can we PLEASE not do that *by default*?
>>>>>>
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>>
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/89338f2b/attachment.html>

From ecreed at cs.washington.edu  Sat Dec 21 20:24:44 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Sat, 21 Dec 2013 23:24:44 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0w8S5UJhaNY57zgDnGJVEi4xU-7aPnqt_rSvTvgUzfvNA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAFEbTaXsQaEZNruX0k824yUSQrNj5LWinJMYB7RKBXcr_-XszQ@mail.gmail.com>
	<52B32112.2070800@mozilla.com>
	<CAFEbTaVks9+21WRSgWfdGww3Za6vA=1VX3bfMEu+1No9bpx_fA@mail.gmail.com>
	<409D34FF-D19F-4208-94B2-86F4FB73F022@sb.org>
	<CAPoegsx70TmmoGH4KMgh4Fp=JjhOfAXBJraNVni6TFA9=8AKXQ@mail.gmail.com>
	<9B1F8378-FDE4-4FAF-ABF8-1CC8D10DC60C@sb.org>
	<CAHOTMVLeu10X1CfMiWNP9DLHrwSjTLk=grdUpkJo5xvsHKkDFA@mail.gmail.com>
	<52B44BA8.9060507@gmail.com>
	<CAHYVw0yPPxFsTK1dhV_wT_ZgZmn-92aY58vdCfUWpDZvG8oK8A@mail.gmail.com>
	<03FF2481-4857-465F-A7F7-6C5C3AC3416E@sb.org>
	<CAHYVw0yJQdmL+abCtx2Z5Ratguf2JsHkj67d3ULqZo4=kxZ6gQ@mail.gmail.com>
	<0A1BABE1-FA15-4340-9214-14DAA2717430@sb.org>
	<CAHYVw0zKPrvS6v39fesWcxhDhqu56Eu1ZfJCA9bOgybXdhnFPg@mail.gmail.com>
	<CAHYVw0z2rwn+C-=KBqdSx0B--NB7Uh+tgBF7ZkvPXfhcQFR2AA@mail.gmail.com>
	<CANbMr6EfCXvMqG=tL5YzrNLKFKK828CC_HW5R_a=JYCit77_uw@mail.gmail.com>
	<CAHYVw0w8S5UJhaNY57zgDnGJVEi4xU-7aPnqt_rSvTvgUzfvNA@mail.gmail.com>
Message-ID: <CANbMr6ETF_BEvthhqHdDrHPJa-Z9Tsz_XaE3y5VUc2kPDVWYYQ@mail.gmail.com>

I disagree. Option is precisely the right type because all Option means is
you can get something or nothing.
Sometimes it can make sense to consider 'something' success and 'nothing'
failure, like attempting to parse a string.
Sometimes it can make sense to consider 'nothing' success and 'something'
failure, like a potential error code from a side effecting operation.
Sometimes it doesn't really make sense either way, like looking up a value
for a key in a map. If the key isn't present, is that failure? Only if you
expected it to be there, but the lookup function doesn't care. It just
tells you if the value exists.

Either just means you can get something one one kind or something of a
different kind. No meaning of failure or success is implicit (consider
Either<char, int>).
Conventionally, if you use Either for success/failure, then you use Left
for failure and Right for success, but this is mostly just because of the
pun with Right and that the default monad for Either allows the Right to
change type.
Result is just Either with actual success/failure meaning built in.

Yeah, we could use Result<(), Err> for a side effecting operation that
could return an error, but that's just a more verbose way of writing
Option<Err>.
Option<Err> is very clear about what it does. It might return an error code
or it might return nothing. If it returns nothing then there clearly there
wasn't an error code so it must have been successful.



On Sat, Dec 21, 2013 at 10:48 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> Eric, thats exactly why I suggested the use of the Result or Either type.
>  Some is a bit misleaning, because the Nothing case is usually means a
> failure rather than a success.
>
>
> On Sat, Dec 21, 2013 at 9:33 PM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> IMO the best alternative for a non-blocking send on a bounded channel is
>> returning an Option.
>> If you send successfully, you return None.
>> If you can't send because the channel is full, you return Some(message).
>> This lets the sender recover the message (important for moveable objects)
>> and decide how to handle it (retry, fail, drop, etc.).
>>
>> Personally, I lean toward providing unbounded channels as the primitive
>> and implementing bounded channels on top of them OR providing both as
>> primitives.
>>
>>
>> On Fri, Dec 20, 2013 at 4:19 PM, Carter Schonwald <
>> carter.schonwald at gmail.com> wrote:
>>
>>> actually, you're right, in go they're fixed sized buffers
>>> http://golang.org/src/pkg/runtime/chan.c . I can understands (and
>>> agree!) that this is not a good default if a more dynamic data structure
>>> can work well.
>>>
>>> in haskell / ghc , bounded channels are dynamically sized, and merely
>>> have a max size thats enforced by the provided api,and I've been speaking
>>> with that sort of memory usage model in mind.
>>>
>>>
>>> On Fri, Dec 20, 2013 at 4:15 PM, Carter Schonwald <
>>> carter.schonwald at gmail.com> wrote:
>>>
>>>> i'd be very very surprised if bounded channels in go don't dynamically
>>>> resize their queues and then atomically insert / remove elements while
>>>> checking the bound.  I'd actually argue that such would be a bug.
>>>>
>>>>
>>>> On Fri, Dec 20, 2013 at 4:09 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>>> I haven?t profiled it, but my belief is that under normal
>>>>> circumstances, messages come in slow enough that the consumer is always
>>>>> idle and ready to process the next message as soon as it?s sent. However, I
>>>>> expect it does occasionally back up a bit, e.g. when I get a burst of
>>>>> traffic such as during a netsplit when I?m sent a large batch of ?<user>
>>>>> has quit? or ?<user> has joined? (when the netsplit is over). I don?t know
>>>>> how much the channel backs up at that point, probably not too much.
>>>>>
>>>>> For this particular use-case, a channel that?s bounded at e.g. 100,000
>>>>> elements would be indistinguishable from an infinite channel, as long as it
>>>>> still dynamically allocates (I don?t *think* Go channels dynamically
>>>>> allocate, which is why I can?t just use a 100,000 element channel for real).
>>>>>
>>>>> However, my overall point about large bounds being indistinguishable
>>>>> from infinite is that if your goal is to pick a bound large enough to
>>>>> appear infinite to the program, without actually risking OOM, then there?s
>>>>> no automated way to do this. Different environments have differing amounts
>>>>> of available resources, and there?s no good way to pick a bound that is
>>>>> sufficiently high but is definitively lower than the resource bounds. This
>>>>> is why I?m recommending that we have truly infinite channels, for users who
>>>>> don?t want to have to think about bounds (e.g. my irc program), as well as
>>>>> bounded channels, where the user has to explicitly pick a bound (with no
>>>>> ?default? provided).
>>>>>
>>>>> -Kevin
>>>>>
>>>>> On Dec 20, 2013, at 12:55 PM, Carter Schonwald <
>>>>> carter.schonwald at gmail.com> wrote:
>>>>>
>>>>> kevin, what sort of applications and workloads are you speaking about.
>>>>> Eg in your example irc server, whats the typical workload when you've used
>>>>> it?
>>>>>
>>>>> cheers
>>>>> -Carter
>>>>>
>>>>>
>>>>> On Fri, Dec 20, 2013 at 12:54 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>
>>>>>> On Dec 20, 2013, at 8:59 AM, Carter Schonwald <
>>>>>> carter.schonwald at gmail.com> wrote:
>>>>>>
>>>>>> agreed! Applications that lack explicit logic for handling heavy
>>>>>> workloads (ie producers outpacing consumers for a sustained period) are the
>>>>>> most common culprit for unresponsive desktop applications that become
>>>>>> completely unusable.
>>>>>>
>>>>>>
>>>>>> That?s a pretty strong claim, and one I would have to disagree with
>>>>>> quite strongly. Every time I?ve sampled an unresponsive application, I
>>>>>> don?t think I?ve *ever* seen a backtrace that suggests a producer
>>>>>> outpacing a consumer.
>>>>>>
>>>>>> -Kevin
>>>>>>
>>>>>> relatedly: would not bounded but programmatically growable channels
>>>>>> also make it trivial to provide a "unbounded" style channel abstraction?
>>>>>> (not that i'm advocating that, merely that it seems like it would turn the
>>>>>> unbounded channel abstraction into an equivalent one that is resource usage
>>>>>> aware)
>>>>>>
>>>>>>
>>>>>> On Fri, Dec 20, 2013 at 8:52 AM, Gy?rgy Andrasek <jurily at gmail.com>wrote:
>>>>>>
>>>>>>> On 12/19/2013 11:13 PM, Tony Arcieri wrote:
>>>>>>>
>>>>>>>> So I think that entire line of reasoning is a red herring. People
>>>>>>>> writing toy programs that never have their channels fill beyond a
>>>>>>>> small
>>>>>>>> number of messages won't care either way.
>>>>>>>>
>>>>>>>> However, overloaded programs + queues bounded by system resources
>>>>>>>> are a
>>>>>>>> production outage waiting to happen. What's really important here is
>>>>>>>> providing a means of backpressure so overloaded Rust programs don't
>>>>>>>> grow
>>>>>>>> until they consume system resources and OOM.
>>>>>>>>
>>>>>>>
>>>>>>> While I disagree with the notion that all programs which don't have
>>>>>>> their bottlenecks right here are "toys", we should definitely strive for
>>>>>>> the invariant that task failure does not cause independent tasks to fail.
>>>>>>>
>>>>>>> Also, OOM is not free. If you manage to go OOM on a desktop, you'll
>>>>>>> get a *very* unhappy user, regardless of their expectations wrt your memory
>>>>>>> usage. Linux with a spinning disk and swap for example will degrade to the
>>>>>>> point where they'll reboot before the OOM killer kicks in.
>>>>>>>
>>>>>>> Can we PLEASE not do that *by default*?
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Rust-dev mailing list
>>>>>>> Rust-dev at mozilla.org
>>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/c16d2bfe/attachment-0001.html>

From palmercox at gmail.com  Sat Dec 21 20:35:52 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Sat, 21 Dec 2013 23:35:52 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CANbMr6E9cE3n+T6DMZ0EHaUG89esNiLCyzK3LEA8tVjXXs3rPA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
	<CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
	<CANbMr6E9cE3n+T6DMZ0EHaUG89esNiLCyzK3LEA8tVjXXs3rPA@mail.gmail.com>
Message-ID: <CAPZendwWU2e9H8+oDOEvJGWN6=H1vLFhePkTWszwnWmEe5SCCA@mail.gmail.com>

Due to type inference, my assumption is that in many cases the only people
that see the actual type names are the developers creating them and people
reading the docs. I hadn't though about the Reader / Port cases, but those
do seem like pretty reasonable places where you might want to have an
object implement Iterator in addition to other traits.

So, if the decision is no suffixes, what do we do with all of the existing
Iterators that have suffixes? Strip them? Maybe the rule of thumb should
look something like this:

1. If you are implementing a struct that only implements the Iterator
trait, make the name plural, but don't use the Iterator suffix. eg: Chunks
2. If you are implementing a struct that implements traits in addition to
Iterator, there is no need to make it plural. eg: Port / Reader

If that's the general rule of thumb, then SplitIterator becomes Splits and
MutChunkIter becomes MutChunks. I guess that means that DoubleEndedIterator
also becomes just DoubledEnded. That seems reasonable to me, since it fits
it better with the ExactSize trait also defined in the iter module. That
doesn't really directly solve my issue with Map from the iter module being
confusing. If its referenced as iter::Map, its not confusing of course, but
at least some of the current code doesn't do that and there isn't any way
to force future code to do so. Its probably not a huge deal, though.

Does that sound like the general opinion?

-Palmer Cox





On Sat, Dec 21, 2013 at 8:43 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> I prefer the 'no suffix' option and generally agree with Alex.
> Iterators aren't special and their iterator behavior is already denoted by
> implementing the Iterator trait.
>
> Frankly, aside from documentation where it is clear that something is an
> iterator, I'm not sure when a user would even see concrete iterator types.
> I can't think of a reason why you'd ever want to restrict the type of a
> variable to a specific kind of iterator (i.e. Map or Union).
>
> Acceptor and Port could implement Iterator directly, but currently they
> create a struct containing only a mutable borrow of themselves to prevent
> anything else from using the socket/channel in the meantime.
> Reader could directly implement an Iterator that does one byte reads, but
> currently it does the same trick as Acceptor and Port.
> You only need a separate Iterator object if you actually require
> additional state or if you want to prevent others from changing the
> underlying source (mutable borrow of self).
>
>
>
> On Sat, Dec 21, 2013 at 4:35 PM, Kevin Cantu <me at kevincantu.org> wrote:
>
>> Rust's standard libs are still pretty thin on their trait hierarchies,
>> but I'm sure this will change.
>>
>> Kevin
>>
>> On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com> wrote:
>> > Are there examples of structs that implement Iterator that also
>> implement
>> > other non-Iterator related traits? Although its possible to do that, I
>> can't
>> > think of a use case for it off the top of my head. An Iterator basically
>> > represents the state of an ongoing computation and once that
>> computation is
>> > completed, the object is mostly uselss. It seems like it would be
>> awkward to
>> > implement other traits for such an object. Maybe I'm not thinking of
>> > something, however.
>> >
>> > -Palmer Cox
>> >
>> >
>> >
>> > On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org> wrote:
>> >>
>> >> Iterators are just structs which implement the "Iterator" or a related
>> >> trait, right?
>> >>
>> >> These structs which do can also implement lots of other traits, too:
>> >> no reason to make -Iter special.
>> >>
>> >>
>> >> Kevin
>> >>
>> >>
>> >>
>> >> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com>
>> wrote:
>> >> > I'm not a big fan of Hungarian notation either. I'm not sure that
>> having
>> >> > a
>> >> > naming convention for Iterators is Hungarian notation, however. For
>> >> > example,
>> >> > if you are doing Windows programming, you'll see stuff like:
>> >> >
>> >> > DWORD dwFoo = 0;
>> >> >
>> >> > In this case, the "dw" prefix on the variable indicates that we have
>> a
>> >> > DWORD
>> >> > variable. However, the Iterator suffix that I'm proposing here is a
>> >> > suffix
>> >> > on the type names, not the actual variable names. So, if you are
>> writing
>> >> > Rust code, you'd write something like this:
>> >> >
>> >> > let chunks = some_vector.chunks(50);
>> >> >
>> >> > So, the actual variable name doesn't have the Hungarian notation and
>> the
>> >> > types aren't even generally visible since the compiler infers much of
>> >> > that.
>> >> > However, someone reading through the documentation and/or code will
>> see
>> >> > a
>> >> > struct named ChunkIterator and instance know how the struct behaves
>> - as
>> >> > an
>> >> > Iterator. So, I think the suffix serves less to describe the datatype
>> >> > and
>> >> > more to describe class of behavior that the struct implements.
>> >> >
>> >> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
>> >> > programming so I'm probably much more used to verbosity than others.
>> I'm
>> >> > not
>> >> > horribly against some sort of other naming convention, either, of
>> >> > course,
>> >> > but I would like to see some consistency.
>> >> >
>> >> > My main motivation for opening the request was because I created
>> >> > MutChunkIter and then realized that it was named differently than
>> >> > majority
>> >> > of other Iterators. I don't want to be responsible for someone
>> reading
>> >> > through the docs and seeing something thats inconsistent for no good
>> >> > reason!
>> >> > Also, I was reading through some code and happened upon a "Map" and
>> was
>> >> > exceptionally confused about it, until I realized it was iter::Map as
>> >> > opposed to container::Map. I figured I probably wasn't the only
>> person
>> >> > that
>> >> > was going to be confused by something like this.
>> >> >
>> >> > -Palmer Cox
>> >> >
>> >> >
>> >> >
>> >> >
>> >> >
>> >> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org>
>> wrote:
>> >> >>
>> >> >> IMHO Hungarian notation is for things the type system and tooling
>> >> >> cannot deal with.  I'm not sure this is one of them...
>> >> >>
>> >> >>
>> >> >> Kevin
>> >> >
>> >> >
>> >
>> >
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131221/1673ff9b/attachment.html>

From glaebhoerl at gmail.com  Sun Dec 22 07:47:09 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 22 Dec 2013 16:47:09 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
Message-ID: <CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>

Using `match` works well enough, but if there's demand for a refutable
`let` which is lighter-weight, what about:

    let Some(result) = from_utf8(some_bytes) else fail!();

In other words, if the `let` pattern is refutable, you have to provide
something `else` with return type `!` as the alternative for when the `let`
fails to match.


(I could imagine that being generalized to any number of `else`s of which
only the last "returns `!`" (i.o.w. never returns), for example

    let Some(result) = from_utf8(some_bytes) else
from_utf8(some_other_bytes) else fail!();

and/or to allowing anything `else` which always matches, e.g.

    let Some(result) = from_utf8(some_bytes) else Some("default");

of which anything that "returns" `!` would be only a special case. But
these have progressively diminishing returns, and I'm merely mentioning,
not endorsing them.)


On Tue, Dec 17, 2013 at 9:11 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Dec 17, 2013, at 11:37 AM, Stefan Plantikow <stefan.plantikow at gmail.com>
> wrote:
>
> Hi,
>
> Am 17.12.2013 um 20:10 schrieb Corey Richardson <corey at octayn.net>:
>
> On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
> <stefan.plantikow at gmail.com> wrote:
>
> Hi,
>
>
> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>
> I have no idea if it would be feasible in the standard library, but
> wouldn't the ideal solution be having one function (e.g. from_utf8()) that
> could return two possible values, a bare result and an Option? Letting the
> compiler decide which version to use based on type inference like this:
>
>    let result: ~str = from_utf8(...);
>    let result: Option<~str> = from_utf8(...);
>
> Assuming both of them are passed invalid UTF8, then the first version
> would fail, but the second version would just return None.
>
>
>
>
> We already have pattern matching in `let` (the LHS is a pattern), but
> it's only for irrefutable patterns. IOW, `let` can never fail, and
> that's a very very useful property IMO.
>
>
> oh ok I haven?t kept up on the syntax then. Given the utility of
> destructuring bind for error handling, wouldn't it make sense to have a
> variant of let that can fail?
>
> Now syntax is a matter of practicality and taste but spontaneously this
> comes to mind:
>
>    let opt Some(~result) = from_utf8(..)
>
> comes to mind.
>
>
> You can do it with a bit more verbosity, which I think is perfectly fine
> as it makes failure much more obvious.
>
>     let result = match from_utf8(..) {
>         Some(~result) => result,
>         _ => fail!("b0rk b0rk b0rk")
>     };
>
> Of course, in this particular example, you'd probably just write
>
>     let result = from_utf8(..).unwrap();
>
> but the longer match form will work for other enums.
>
> -Kevin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/136ee8f4/attachment-0001.html>

From gaetan at xeberon.net  Sun Dec 22 08:55:02 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sun, 22 Dec 2013 17:55:02 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
Message-ID: <CANK7tAEVwWxzwOse7oQLbvDkkCb+8UCarJDVn3sfakW9CkSujA@mail.gmail.com>

That is pretty elegant.
Le 22 d?c. 2013 16:47, "G?bor Lehel" <glaebhoerl at gmail.com> a ?crit :

> Using `match` works well enough, but if there's demand for a refutable
> `let` which is lighter-weight, what about:
>
>     let Some(result) = from_utf8(some_bytes) else fail!();
>
> In other words, if the `let` pattern is refutable, you have to provide
> something `else` with return type `!` as the alternative for when the `let`
> fails to match.
>
>
> (I could imagine that being generalized to any number of `else`s of which
> only the last "returns `!`" (i.o.w. never returns), for example
>
>     let Some(result) = from_utf8(some_bytes) else
> from_utf8(some_other_bytes) else fail!();
>
> and/or to allowing anything `else` which always matches, e.g.
>
>     let Some(result) = from_utf8(some_bytes) else Some("default");
>
> of which anything that "returns" `!` would be only a special case. But
> these have progressively diminishing returns, and I'm merely mentioning,
> not endorsing them.)
>
>
> On Tue, Dec 17, 2013 at 9:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 17, 2013, at 11:37 AM, Stefan Plantikow <
>> stefan.plantikow at gmail.com> wrote:
>>
>> Hi,
>>
>> Am 17.12.2013 um 20:10 schrieb Corey Richardson <corey at octayn.net>:
>>
>> On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
>> <stefan.plantikow at gmail.com> wrote:
>>
>> Hi,
>>
>>
>> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>>
>> I have no idea if it would be feasible in the standard library, but
>> wouldn't the ideal solution be having one function (e.g. from_utf8()) that
>> could return two possible values, a bare result and an Option? Letting the
>> compiler decide which version to use based on type inference like this:
>>
>>    let result: ~str = from_utf8(...);
>>    let result: Option<~str> = from_utf8(...);
>>
>> Assuming both of them are passed invalid UTF8, then the first version
>> would fail, but the second version would just return None.
>>
>>
>>
>>
>> We already have pattern matching in `let` (the LHS is a pattern), but
>> it's only for irrefutable patterns. IOW, `let` can never fail, and
>> that's a very very useful property IMO.
>>
>>
>> oh ok I haven?t kept up on the syntax then. Given the utility of
>> destructuring bind for error handling, wouldn't it make sense to have a
>> variant of let that can fail?
>>
>> Now syntax is a matter of practicality and taste but spontaneously this
>> comes to mind:
>>
>>    let opt Some(~result) = from_utf8(..)
>>
>> comes to mind.
>>
>>
>> You can do it with a bit more verbosity, which I think is perfectly fine
>> as it makes failure much more obvious.
>>
>>     let result = match from_utf8(..) {
>>         Some(~result) => result,
>>         _ => fail!("b0rk b0rk b0rk")
>>     };
>>
>> Of course, in this particular example, you'd probably just write
>>
>>     let result = from_utf8(..).unwrap();
>>
>> but the longer match form will work for other enums.
>>
>> -Kevin
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/d56b836b/attachment.html>

From corey at octayn.net  Sun Dec 22 08:57:29 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 22 Dec 2013 11:57:29 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
Message-ID: <CA++BO6QDs2mwGsJdjqt147EddifUY=PXv659Wb_dby9=c2FeKw@mail.gmail.com>

I quite like this proposal, though I'd suggest that the "else" clause
is evaluated as the value for when the pattern fails. `!` would always
be substitutable there.

On Sun, Dec 22, 2013 at 10:47 AM, G?bor Lehel <glaebhoerl at gmail.com> wrote:
> Using `match` works well enough, but if there's demand for a refutable `let`
> which is lighter-weight, what about:
>
>     let Some(result) = from_utf8(some_bytes) else fail!();
>
> In other words, if the `let` pattern is refutable, you have to provide
> something `else` with return type `!` as the alternative for when the `let`
> fails to match.
>
>
> (I could imagine that being generalized to any number of `else`s of which
> only the last "returns `!`" (i.o.w. never returns), for example
>
>     let Some(result) = from_utf8(some_bytes) else
> from_utf8(some_other_bytes) else fail!();
>
> and/or to allowing anything `else` which always matches, e.g.
>
>     let Some(result) = from_utf8(some_bytes) else Some("default");
>
> of which anything that "returns" `!` would be only a special case. But these
> have progressively diminishing returns, and I'm merely mentioning, not
> endorsing them.)
>
>
> On Tue, Dec 17, 2013 at 9:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>> On Dec 17, 2013, at 11:37 AM, Stefan Plantikow
>> <stefan.plantikow at gmail.com> wrote:
>>
>> Hi,
>>
>> Am 17.12.2013 um 20:10 schrieb Corey Richardson <corey at octayn.net>:
>>
>> On Tue, Dec 17, 2013 at 2:06 PM, Stefan Plantikow
>> <stefan.plantikow at gmail.com> wrote:
>>
>> Hi,
>>
>>
>> Am 09.12.2013 um 16:53 schrieb Damien Radtke <damienradtke at gmail.com>:
>>
>> I have no idea if it would be feasible in the standard library, but
>> wouldn't the ideal solution be having one function (e.g. from_utf8()) that
>> could return two possible values, a bare result and an Option? Letting the
>> compiler decide which version to use based on type inference like this:
>>
>>    let result: ~str = from_utf8(...);
>>    let result: Option<~str> = from_utf8(...);
>>
>> Assuming both of them are passed invalid UTF8, then the first version
>> would fail, but the second version would just return None.
>>
>>
>>
>>
>> We already have pattern matching in `let` (the LHS is a pattern), but
>> it's only for irrefutable patterns. IOW, `let` can never fail, and
>> that's a very very useful property IMO.
>>
>>
>> oh ok I haven?t kept up on the syntax then. Given the utility of
>> destructuring bind for error handling, wouldn't it make sense to have a
>> variant of let that can fail?
>>
>> Now syntax is a matter of practicality and taste but spontaneously this
>> comes to mind:
>>
>>    let opt Some(~result) = from_utf8(..)
>>
>> comes to mind.
>>
>>
>> You can do it with a bit more verbosity, which I think is perfectly fine
>> as it makes failure much more obvious.
>>
>>     let result = match from_utf8(..) {
>>         Some(~result) => result,
>>         _ => fail!("b0rk b0rk b0rk")
>>     };
>>
>> Of course, in this particular example, you'd probably just write
>>
>>     let result = from_utf8(..).unwrap();
>>
>> but the longer match form will work for other enums.
>>
>> -Kevin
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From stefan.plantikow at gmail.com  Sun Dec 22 09:59:23 2013
From: stefan.plantikow at gmail.com (Stefan Plantikow)
Date: Sun, 22 Dec 2013 18:59:23 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
Message-ID: <382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>

Hi,

Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:

> Using `match` works well enough, but if there's demand for a refutable `let` which is lighter-weight, what about:
> 
>     let Some(result) = from_utf8(some_bytes) else fail!();
> 

This is a nice idea.  At first I thought it wouldn?t work with `if` but in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:

let Some(result) = if cond { .. } else { ? }  else fail();

> In other words, if the `let` pattern is refutable, you have to provide something `else` with return type `!` as the alternative for when the `let` fails to match.
> 

Shouldn't the return be the same for all expressions? This would allow:

    let Some(result) = from_utf8(some_bytes) else Some(defaultValue);



Stefan.

From gaetan at xeberon.net  Sun Dec 22 10:49:15 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sun, 22 Dec 2013 19:49:15 +0100
Subject: [rust-dev] =?windows-1252?q?Fwd=3A_Re=3A__Let=92s_avoid_having_bo?=
	=?windows-1252?q?th_foo=28=29_and_foo=5Fopt=28=29?=
In-Reply-To: <CANK7tAHffY0S0hh7=A3Dp79PvMpMPRRm3-SELsyYpByNuELWCA@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<CANK7tAHffY0S0hh7=A3Dp79PvMpMPRRm3-SELsyYpByNuELWCA@mail.gmail.com>
Message-ID: <CANK7tAHQiuMdOyitrfiNThhN_QVOeVzz0E=pVo2MxzdRQc--Uw@mail.gmail.com>

> I like this syntax:
>
> let Some(result) = from_utf8(some_bytes) else defaultValue;
>
> Or
>
> Let result = from_utf8 (some_bytes) else defaultValue
>
> If implicit conversion could be properly checked it would be so cool !
>
> Hi,
>
> Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
>
> > Using `match` works well enough, but if there's demand for a refutable
`let` which is lighter-weight, what about:
> >
> >     let Some(result) = from_utf8(some_bytes) else fail!();
> >
>
> This is a nice idea.  At first I thought it wouldn?t work with `if` but
in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
>
> let Some(result) = if cond { .. } else { ? }  else fail();
>
> > In other words, if the `let` pattern is refutable, you have to provide
something `else` with return type `!` as the alternative for when the `let`
fails to match.
> >
>
> Shouldn't the return be the same for all expressions? This would allow:
>
>     let Some(result) = from_utf8(some_bytes) else Some(defaultValue);
>
>
>
> Stefan.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/6af9534c/attachment-0001.html>

From leo.testard at gmail.com  Sun Dec 22 10:37:28 2013
From: leo.testard at gmail.com (=?windows-1252?Q?L=E9o_Testard?=)
Date: Sun, 22 Dec 2013 19:37:28 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
Message-ID: <B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>

Hello,

Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com> a ?crit :

> Hi,
> 
> Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
> 
> This is a nice idea.  At first I thought it wouldn?t work with `if` but in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
> 

No, it doesn't. As long as the if's "true block" returns unit.
let foo = if ... { }; is perfectly legal, even it doesn't make much sense in practice.

Leo
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/7b0d73d6/attachment.sig>

From bascule at gmail.com  Sun Dec 22 12:34:00 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Sun, 22 Dec 2013 12:34:00 -0800
Subject: [rust-dev] [ANN] irust 1.0.0: a REPL for the Rust programming
 language (powered by Ruby)
Message-ID: <CAHOTMV+S8Wm2V=0EnMt+s4C7LqjKbtrhXr7gLsqfC4gYMCX_3A@mail.gmail.com>

iRust is an interactive Rust REPL, i.e. a Read Eval Print loop which lets
you type some code into a prompt and see it evaluated before your eyes:

https://github.com/tarcieri/irust

It's installable as a RubyGem. Detailed installation instructions are
provided by clicking the link.

I wrote this because I'm a REPL-lover and Rust's existing REPL is broken.
It's not meant to be a permanent REPL for Rust, but a stopgap solution for
those who want a REPL until Rust ships a working one.

Enjoy!

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/94bad326/attachment.html>

From hatahet at gmail.com  Sun Dec 22 18:00:12 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sun, 22 Dec 2013 18:00:12 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
Message-ID: <CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>

But we already have Option::unwrap_or() and Option::unwrap_or_else() that
behave similar to the 'else' syntax suggested above.

--
Ziad


On Sun, Dec 22, 2013 at 10:37 AM, L?o Testard <leo.testard at gmail.com> wrote:

> Hello,
>
> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com> a
> ?crit :
>
> > Hi,
> >
> > Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
> >
> > This is a nice idea.  At first I thought it wouldn?t work with `if` but
> in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
> >
>
> No, it doesn't. As long as the if's "true block" returns unit.
> let foo = if ... { }; is perfectly legal, even it doesn't make much sense
> in practice.
>
> Leo
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/a7ec0095/attachment.html>

From carter.schonwald at gmail.com  Sun Dec 22 20:00:24 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sun, 22 Dec 2013 23:00:24 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
Message-ID: <CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>

Agreed!

On Sunday, December 22, 2013, Ziad Hatahet wrote:

> But we already have Option::unwrap_or() and Option::unwrap_or_else() that
> behave similar to the 'else' syntax suggested above.
>
> --
> Ziad
>
>
> On Sun, Dec 22, 2013 at 10:37 AM, L?o Testard <leo.testard at gmail.com<javascript:_e({}, 'cvml', 'leo.testard at gmail.com');>
> > wrote:
>
>> Hello,
>>
>> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com<javascript:_e({}, 'cvml', 'stefan.plantikow at gmail.com');>>
>> a ?crit :
>>
>> > Hi,
>> >
>> > Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com<javascript:_e({}, 'cvml', 'glaebhoerl at gmail.com');>
>> >:
>> >
>> > This is a nice idea.  At first I thought it wouldn?t work with `if` but
>> in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
>> >
>>
>> No, it doesn't. As long as the if's "true block" returns unit.
>> let foo = if ... { }; is perfectly legal, even it doesn't make much sense
>> in practice.
>>
>> Leo
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131222/14f75f93/attachment.html>

From corey at octayn.net  Sun Dec 22 20:12:02 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 22 Dec 2013 23:12:02 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
Message-ID: <CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>

I find the ability to have refutable let more compelling than the
ability to work around it with functions wrapping `match`

On Sun, Dec 22, 2013 at 11:00 PM, Carter Schonwald
<carter.schonwald at gmail.com> wrote:
> Agreed!
>
>
> On Sunday, December 22, 2013, Ziad Hatahet wrote:
>>
>> But we already have Option::unwrap_or() and Option::unwrap_or_else() that
>> behave similar to the 'else' syntax suggested above.
>>
>> --
>> Ziad
>>
>>
>> On Sun, Dec 22, 2013 at 10:37 AM, L?o Testard <leo.testard at gmail.com>
>> wrote:
>>>
>>> Hello,
>>>
>>> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com> a
>>> ?crit :
>>>
>>> > Hi,
>>> >
>>> > Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
>>> >
>>> > This is a nice idea.  At first I thought it wouldn?t work with `if` but
>>> > in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
>>> >
>>>
>>> No, it doesn't. As long as the if's "true block" returns unit.
>>> let foo = if ... { }; is perfectly legal, even it doesn't make much sense
>>> in practice.
>>>
>>> Leo
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From masklinn at masklinn.net  Mon Dec 23 01:11:42 2013
From: masklinn at masklinn.net (Masklinn)
Date: Mon, 23 Dec 2013 10:11:42 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
Message-ID: <F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>


On 2013-12-23, at 05:12 , Corey Richardson <corey at octayn.net> wrote:

> I find the ability to have refutable let

I may have missed it, but is there a reason not to have just that? Make
let similar to Erlang?s `=` and fail on refutation?

You said you find the basic let?s irrefutability to be a useful property
but have not explained why, and why it makes sense to introduce a
separate-but-similar construct with subtly different semantics
(I also see this as a possible failure, would users of the language
really expect `let` to be irrefutable and `let [else]` to be refutable,
or would they expect `let [else]` to allow returning a value and `let`
to just fail on mismatch? If such different semantics are desired,
I?d suggest using a different keyword entirely)

> more compelling than the
> ability to work around it with functions wrapping `match`

That assertion seems ill supported so far: just about every example is
in terms of `Option`, and `Option` is the one type which does not need a
refutable let, owing to its truckload of convenience methods covering
just about every basic use cases the only reasons to use a `match` with
Option are personal preferences and insufficient knowledge of the type.

> On Sun, Dec 22, 2013 at 11:00 PM, Carter Schonwald
> <carter.schonwald at gmail.com> wrote:
>> Agreed!
>> 
>> 
>> On Sunday, December 22, 2013, Ziad Hatahet wrote:
>>> 
>>> But we already have Option::unwrap_or() and Option::unwrap_or_else() that
>>> behave similar to the 'else' syntax suggested above.
>>> 
>>> --
>>> Ziad
>>> 
>>> 
>>> On Sun, Dec 22, 2013 at 10:37 AM, L?o Testard <leo.testard at gmail.com>
>>> wrote:
>>>> 
>>>> Hello,
>>>> 
>>>> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com> a
>>>> ?crit :
>>>> 
>>>>> Hi,
>>>>> 
>>>>> Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
>>>>> 
>>>>> This is a nice idea.  At first I thought it wouldn?t work with `if` but
>>>>> in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
>>>>> 
>>>> 
>>>> No, it doesn't. As long as the if's "true block" returns unit.
>>>> let foo = if ... { }; is perfectly legal, even it doesn't make much sense
>>>> in practice.
>>>> 
>>>> Leo
>>>> 
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>> 
>>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From stefan.plantikow at gmail.com  Mon Dec 23 03:17:43 2013
From: stefan.plantikow at gmail.com (Stefan Plantikow)
Date: Mon, 23 Dec 2013 12:17:43 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
Message-ID: <B28B91BE-C8D8-4492-AD47-D277A96C02EB@googlemail.com>



Hi,

Am 23.12.2013 um 10:11 schrieb Masklinn <masklinn at masklinn.net>:

> 
> On 2013-12-23, at 05:12 , Corey Richardson <corey at octayn.net> wrote:
> 
>> I find the ability to have refutable let
> 
> I may have missed it, but is there a reason not to have just that? Make
> let similar to Erlang?s `=` and fail on refutation?
> 

I didn?t understand this to be about wether let should accept refutable patterns in general. Rather this is about wether there should be additional syntax for refutable patterns. The decision to make irrefutable let the default seems reasonable as it avoids silent breakage when new variants are introduced for an enum type.

> You said you find the basic let?s irrefutability to be a useful property
> but have not explained why, and why it makes sense to introduce a
> separate-but-similar construct with subtly different semantics
> (I also see this as a possible failure, would users of the language
> really expect `let` to be irrefutable and `let [else]` to be refutable,
> or would they expect `let [else]` to allow returning a value and `let`
> to just fail on mismatch? If such different semantics are desired,
> I?d suggest using a different keyword entirely)
> 
>> more compelling than the
>> ability to work around it with functions wrapping `match`
> 
> That assertion seems ill supported so far: just about every example is
> in terms of `Option`, and `Option` is the one type which does not need a
> refutable let, owing to its truckload of convenience methods covering
> just about every basic use cases the only reasons to use a `match` with
> Option are personal preferences and insufficient knowledge of the type.
> 

Sure, this discussion has used Option as a running example. I guess the more interesting use case is a library defined type without an unwrap() or similar method. A client of the library could of course implement his own helper method to solve that issue - or just use a variant of let with refutable patterns.

The benefit of the refutable patterns would be less boilerplate for helper methods like unwrap(), the ability to ?unwrap? any type, and a nice syntax for trying multiple values in succession ( let Some(x) =? try_1(), try_2(), fail() ).  


Cheers,


Stefan.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/d4b8ee69/attachment-0001.html>

From glaebhoerl at gmail.com  Mon Dec 23 04:12:04 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 23 Dec 2013 13:12:04 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
Message-ID: <CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>

On Mon, Dec 23, 2013 at 10:11 AM, Masklinn <masklinn at masklinn.net> wrote:

>
> On 2013-12-23, at 05:12 , Corey Richardson <corey at octayn.net> wrote:
>
> > I find the ability to have refutable let
>
> I may have missed it, but is there a reason not to have just that? Make
> let similar to Erlang?s `=` and fail on refutation?
>

I don't like either that (a) the possible failure is silent, and refutable
lets look the same as irrefutable ones, nor (b) baking fail!() into the
semantics. Haskell has these also and I think it's a wart. The proposed
syntax solves both issues.

Rust doesn't allow partial matches in `match`es either, for reasons, so I
think it would be pretty strange to turn around and silently allow them in
`let`s.

The strongest arguments against IMHO are YAGNI (which is why I prefaced the
whole thing with *if* there's demand for a refutable let), and the
ambiguity with `if` (which is a technical issue that may or may not have a
satisfactory solution).

A meta-level process question: now that we have the `feature` attribute,
wouldn't that be a great way to empirically decide questions like these?
Implement the feature, put it behind a feature gate, and see how much use
it gets, and/or if there are any problems with it? This isn't the first
case where it seems like that might be more productive than trying to
anticipate all of the answers from theory alone. And it seems to work
pretty well for GHC. Just perhaps we could be more aggressive about
removing features which weren't successful.


>
> You said you find the basic let?s irrefutability to be a useful property
> but have not explained why, and why it makes sense to introduce a
> separate-but-similar construct with subtly different semantics
> (I also see this as a possible failure, would users of the language
> really expect `let` to be irrefutable and `let [else]` to be refutable,
> or would they expect `let [else]` to allow returning a value and `let`
> to just fail on mismatch? If such different semantics are desired,
> I?d suggest using a different keyword entirely)
>

If I'm understanding you correctly, this is a problem that would solve
itself: if someone thinks a plain `let` is refutable and will just fail on
mismatch, the compiler will quickly tell her otherwise.


>
> > more compelling than the
> > ability to work around it with functions wrapping `match`
>
> That assertion seems ill supported so far: just about every example is
> in terms of `Option`, and `Option` is the one type which does not need a
> refutable let, owing to its truckload of convenience methods covering
> just about every basic use cases the only reasons to use a `match` with
> Option are personal preferences and insufficient knowledge of the type.
>
> > On Sun, Dec 22, 2013 at 11:00 PM, Carter Schonwald
> > <carter.schonwald at gmail.com> wrote:
> >> Agreed!
> >>
> >>
> >> On Sunday, December 22, 2013, Ziad Hatahet wrote:
> >>>
> >>> But we already have Option::unwrap_or() and Option::unwrap_or_else()
> that
> >>> behave similar to the 'else' syntax suggested above.
> >>>
> >>> --
> >>> Ziad
> >>>
> >>>
> >>> On Sun, Dec 22, 2013 at 10:37 AM, L?o Testard <leo.testard at gmail.com>
> >>> wrote:
> >>>>
> >>>> Hello,
> >>>>
> >>>> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com>
> a
> >>>> ?crit :
> >>>>
> >>>>> Hi,
> >>>>>
> >>>>> Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
> >>>>>
> >>>>> This is a nice idea.  At first I thought it wouldn?t work with `if`
> but
> >>>>> in expressions `if` requires `else` so the grammar wouldn?t be
> ambiguous:
> >>>>>
> >>>>
> >>>> No, it doesn't. As long as the if's "true block" returns unit.
> >>>> let foo = if ... { }; is perfectly legal, even it doesn't make much
> sense
> >>>> in practice.
> >>>>
> >>>> Leo
> >>>>
> >>>> _______________________________________________
> >>>> Rust-dev mailing list
> >>>> Rust-dev at mozilla.org
> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/2d905860/attachment.html>

From glaebhoerl at gmail.com  Mon Dec 23 04:33:19 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 23 Dec 2013 13:33:19 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
Message-ID: <CAPoegsyPjOo1W1h=1SBc=Mnv=r2_qz9i8aE3t94XMo+famiJXw@mail.gmail.com>

On Sun, Dec 22, 2013 at 7:37 PM, L?o Testard <leo.testard at gmail.com> wrote:

> Hello,
>
> Le 22 d?c. 2013 ? 18:59, Stefan Plantikow <stefan.plantikow at gmail.com> a
> ?crit :
>
> > Hi,
> >
> > Am 22.12.2013 um 16:47 schrieb G?bor Lehel <glaebhoerl at gmail.com>:
> >
> > This is a nice idea.  At first I thought it wouldn?t work with `if` but
> in expressions `if` requires `else` so the grammar wouldn?t be ambiguous:
> >
>
> No, it doesn't. As long as the if's "true block" returns unit.
> let foo = if ... { }; is perfectly legal, even it doesn't make much sense
> in practice.
>
> Leo
>

Thinking about this, if we say that `else` following a `let` is allowed if
*and only if* the pattern is refutable, then this wouldn't actually be
ambiguous, because something of type `()` can never be refutable. Therefore
`let ... = if { ... } else { ... };` can only be legal if the `else`
belongs to the `if`.

I'm not completely clear on the relationship between grammatic and semantic
ambiguity. Would the grammar still be ambiguous in this case? I would
naively think that you're not allowed to take types and such into account
at the grammar level, but Rust seemingly already does so w.r.t. whether or
not things (such as `if`) return `()`, so I'm a little bit confused. Can
someone explain?



>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/4bfd2a50/attachment.html>

From jack at metajack.im  Mon Dec 23 07:48:45 2013
From: jack at metajack.im (Jack Moffitt)
Date: Mon, 23 Dec 2013 08:48:45 -0700
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<52A2766A.6000105@gmail.com>
	<CAPNUp087moxk+3AHqekFY5O2oxcqGAekBNF9+UF1Pvm=tb-XLA@mail.gmail.com>
	<CAN1rdEzLneeiPMwWNmuUWyg=2eyNZVM3VLakTCiLLT7veAX=6A@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
Message-ID: <CAP7VpsXM4Raq_VQVvv-QnUvbWM=9jwU024NcCkdu=RMM=EpJCA@mail.gmail.com>

> I may have missed it, but is there a reason not to have just that? Make
> let similar to Erlang?s `=` and fail on refutation?

Erlang is designed around handling failure. It has links, monitors,
supervisors, and so forth. Rust has only some very basic tools for
catching the failure of a task.

I'll also note, that because Erlang has pattern matching in the
clauses themselves, many failures occur even before the function
bodies.

Some of those features incur non-trivial runtime costs which is why
Rust doesn't have them.

jack.

From pcwalton at mozilla.com  Mon Dec 23 09:23:06 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 23 Dec 2013 09:23:06 -0800
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
Message-ID: <52B8717A.9020401@mozilla.com>

On 12/23/13 4:12 AM, G?bor Lehel wrote:
> I don't like either that (a) the possible failure is silent, and
> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
> into the semantics. Haskell has these also and I think it's a wart. The
> proposed syntax solves both issues.

For what it's worth, Rust's pattern matching is pretty heavily based on 
OCaml's and the OCaml compiler complains with a warning if you use a 
refutable pattern in `let`.

Patrick


From carter.schonwald at gmail.com  Mon Dec 23 10:03:33 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Mon, 23 Dec 2013 13:03:33 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <52B8717A.9020401@mozilla.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
Message-ID: <CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>

that seems like a reasonable balance


On Mon, Dec 23, 2013 at 12:23 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/23/13 4:12 AM, G?bor Lehel wrote:
>
>> I don't like either that (a) the possible failure is silent, and
>> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
>> into the semantics. Haskell has these also and I think it's a wart. The
>> proposed syntax solves both issues.
>>
>
> For what it's worth, Rust's pattern matching is pretty heavily based on
> OCaml's and the OCaml compiler complains with a warning if you use a
> refutable pattern in `let`.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/7be015f5/attachment.html>

From ben.striegel at gmail.com  Mon Dec 23 10:48:20 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 23 Dec 2013 13:48:20 -0500
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52B8717A.9020401@mozilla.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
Message-ID: <CAAvrL-kWpTdNtDZwRGqS4VSw=2qxABvSf1TSHvFYuT5hmE=vGA@mail.gmail.com>

> the OCaml compiler complains with a warning if you use a refutable
pattern in `let`.

And what does OCaml do at runtime if the pattern is refuted?


On Mon, Dec 23, 2013 at 12:23 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/23/13 4:12 AM, G?bor Lehel wrote:
>
>> I don't like either that (a) the possible failure is silent, and
>> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
>> into the semantics. Haskell has these also and I think it's a wart. The
>> proposed syntax solves both issues.
>>
>
> For what it's worth, Rust's pattern matching is pretty heavily based on
> OCaml's and the OCaml compiler complains with a warning if you use a
> refutable pattern in `let`.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/d6611cf7/attachment.html>

From pcwalton at mozilla.com  Mon Dec 23 10:58:14 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 23 Dec 2013 10:58:14 -0800
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAAvrL-kWpTdNtDZwRGqS4VSw=2qxABvSf1TSHvFYuT5hmE=vGA@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>	<52B8717A.9020401@mozilla.com>
	<CAAvrL-kWpTdNtDZwRGqS4VSw=2qxABvSf1TSHvFYuT5hmE=vGA@mail.gmail.com>
Message-ID: <52B887C6.30201@mozilla.com>

On 12/23/13 10:48 AM, Benjamin Striegel wrote:
>  > the OCaml compiler complains with a warning if you use a refutable
> pattern in `let`.
>
> And what does OCaml do at runtime if the pattern is refuted?

Throws.

Patrick



From glaebhoerl at gmail.com  Mon Dec 23 11:44:49 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 23 Dec 2013 20:44:49 +0100
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
	<CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>
Message-ID: <CAPoegsxsF7UNe4xfMAUzDMJQs9pxJUWvXmU_fmRmcnrHSL0XYw@mail.gmail.com>

That seems like a nice compromise, but I don't think it's a good one.
Either you intended the pattern to be refutable or you didn't. If you
didn't and it is, you should get an error, not a warning. If you did, you
shouldn't get a warning at all. Are you going to put a compiler pragma to
disable the warning at every use site where you intentionally want a let to
be refutable? At that point, you might as well have separate syntax for
refutable and irrefutable lets. Or are you just going to live with having
false positive warnings in your code?

(FWIW, I'm basically fine with having only irrefutable lets, and using
`match` for the other cases, or in other words the status quo. But if we
*do* add refutable lets, I strongly think they should be explicit.)


On Mon, Dec 23, 2013 at 7:03 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> that seems like a reasonable balance
>
>
> On Mon, Dec 23, 2013 at 12:23 PM, Patrick Walton <pcwalton at mozilla.com>wrote:
>
>> On 12/23/13 4:12 AM, G?bor Lehel wrote:
>>
>>> I don't like either that (a) the possible failure is silent, and
>>> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
>>> into the semantics. Haskell has these also and I think it's a wart. The
>>> proposed syntax solves both issues.
>>>
>>
>> For what it's worth, Rust's pattern matching is pretty heavily based on
>> OCaml's and the OCaml compiler complains with a warning if you use a
>> refutable pattern in `let`.
>>
>
>> Patrick
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/c4f8727f/attachment.html>

From ben.striegel at gmail.com  Mon Dec 23 11:55:51 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 23 Dec 2013 14:55:51 -0500
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAPoegsxsF7UNe4xfMAUzDMJQs9pxJUWvXmU_fmRmcnrHSL0XYw@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
	<CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>
	<CAPoegsxsF7UNe4xfMAUzDMJQs9pxJUWvXmU_fmRmcnrHSL0XYw@mail.gmail.com>
Message-ID: <CAAvrL-meA5Qs+JM4s8WnjzZOk9cd4LZTsxOXo=EhZYWQdP_gYw@mail.gmail.com>

I too think it would be a big mistake to allow let patterns to be
refutable, when we've already tried and rejected allowing the same in match
statements (ancient Rust history quiz: who else remembers `match check`?).


On Mon, Dec 23, 2013 at 2:44 PM, G?bor Lehel <glaebhoerl at gmail.com> wrote:

> That seems like a nice compromise, but I don't think it's a good one.
> Either you intended the pattern to be refutable or you didn't. If you
> didn't and it is, you should get an error, not a warning. If you did, you
> shouldn't get a warning at all. Are you going to put a compiler pragma to
> disable the warning at every use site where you intentionally want a let to
> be refutable? At that point, you might as well have separate syntax for
> refutable and irrefutable lets. Or are you just going to live with having
> false positive warnings in your code?
>
> (FWIW, I'm basically fine with having only irrefutable lets, and using
> `match` for the other cases, or in other words the status quo. But if we
> *do* add refutable lets, I strongly think they should be explicit.)
>
>
>
> On Mon, Dec 23, 2013 at 7:03 PM, Carter Schonwald <
> carter.schonwald at gmail.com> wrote:
>
>> that seems like a reasonable balance
>>
>>
>> On Mon, Dec 23, 2013 at 12:23 PM, Patrick Walton <pcwalton at mozilla.com>wrote:
>>
>>> On 12/23/13 4:12 AM, G?bor Lehel wrote:
>>>
>>>> I don't like either that (a) the possible failure is silent, and
>>>> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
>>>> into the semantics. Haskell has these also and I think it's a wart. The
>>>> proposed syntax solves both issues.
>>>>
>>>
>>> For what it's worth, Rust's pattern matching is pretty heavily based on
>>> OCaml's and the OCaml compiler complains with a warning if you use a
>>> refutable pattern in `let`.
>>>
>>
>>> Patrick
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/acff22d3/attachment-0001.html>

From simon.sapin at exyr.org  Mon Dec 23 12:40:34 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 23 Dec 2013 21:40:34 +0100
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAAvrL-meA5Qs+JM4s8WnjzZOk9cd4LZTsxOXo=EhZYWQdP_gYw@mail.gmail.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>	<52B8717A.9020401@mozilla.com>	<CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>	<CAPoegsxsF7UNe4xfMAUzDMJQs9pxJUWvXmU_fmRmcnrHSL0XYw@mail.gmail.com>
	<CAAvrL-meA5Qs+JM4s8WnjzZOk9cd4LZTsxOXo=EhZYWQdP_gYw@mail.gmail.com>
Message-ID: <52B89FC2.2070509@exyr.org>

On 23/12/2013 20:55, Benjamin Striegel wrote:
> I too think it would be a big mistake to allow let patterns to be
> refutable, when we've already tried and rejected allowing the same in
> match statements (ancient Rust history quiz: who else remembers `match
> check`?).

For those of us that were not around or do not remember, can you explain 
what was tried and rejected?

I sometimes find myself writing a `_ => ()` arm for match and wish it 
could be implied? and sometimes `_ => fail!()`. That the two are 
sometimes used is probably a sign that the status quo (require it to be 
explicit) is better.

-- 
Simon Sapin

From simon.sapin at exyr.org  Mon Dec 23 12:42:28 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 23 Dec 2013 21:42:28 +0100
Subject: [rust-dev] =?windows-1252?q?See_pull_request_=2311129_=28was=3A_R?=
 =?windows-1252?q?e=3A__Let=92s_avoid_having_both_foo=28=29_and_foo=5Fopt?=
 =?windows-1252?q?=28=29=29?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <52B8A034.7030301@exyr.org>

FYI, made a pull request according to this proposal:

https://github.com/mozilla/rust/pull/11129

-- 
Simon Sapin

From com.liigo at gmail.com  Mon Dec 23 13:19:26 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Tue, 24 Dec 2013 05:19:26 +0800
Subject: [rust-dev]
	=?utf-8?q?See_pull_request_=2311129_=28was=3A_Re=3A_Le?=
	=?utf-8?q?t=E2=80=99s_avoid_having_both_foo=28=29_and_foo=5Fopt=28?=
	=?utf-8?b?KSk=?=
In-Reply-To: <52B8A034.7030301@exyr.org>
References: <52A23660.5040500@exyr.org>
	<52B8A034.7030301@exyr.org>
Message-ID: <CAH8Jz7jX+h=aPDuMXOtjNg18MwUU+A2gp5gGscriE-5uHUhTcw@mail.gmail.com>

Code full of .unwrap() is not good smell I think.
? 2013?12?24? ??4:42?"Simon Sapin" <simon.sapin at exyr.org>???

> FYI, made a pull request according to this proposal:
>
> https://github.com/mozilla/rust/pull/11129
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/e8ea111a/attachment.html>

From simon.sapin at exyr.org  Mon Dec 23 13:24:47 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 23 Dec 2013 22:24:47 +0100
Subject: [rust-dev] See pull request #11129
In-Reply-To: <CAH8Jz7jX+h=aPDuMXOtjNg18MwUU+A2gp5gGscriE-5uHUhTcw@mail.gmail.com>
References: <52A23660.5040500@exyr.org>	<52B8A034.7030301@exyr.org>
	<CAH8Jz7jX+h=aPDuMXOtjNg18MwUU+A2gp5gGscriE-5uHUhTcw@mail.gmail.com>
Message-ID: <52B8AA1F.3000705@exyr.org>

On 23/12/2013 22:19, Liigo Zhuang wrote:
> Code full of .unwrap() is not good smell I think.

I agree, and I wrote in the first email that it is one of the downsides.

But doubling the API (from_utf8 and from_utf8_opt) is also not a good 
smell, so it?s a compromise to find.

-- 
Simon Sapin

From kevin at sb.org  Mon Dec 23 13:26:37 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 23 Dec 2013 13:26:37 -0800
Subject: [rust-dev] See pull request #11129
In-Reply-To: <52B8AA1F.3000705@exyr.org>
References: <52A23660.5040500@exyr.org>	<52B8A034.7030301@exyr.org>
	<CAH8Jz7jX+h=aPDuMXOtjNg18MwUU+A2gp5gGscriE-5uHUhTcw@mail.gmail.com>
	<52B8AA1F.3000705@exyr.org>
Message-ID: <2F08F9DA-0C9E-4DAD-994B-221FEDF37CB3@sb.org>

Even with refutable `let`s, I think there's still a good case for having `.unwrap()`-style APIs on enums, which is that often you need to unwrap an enum inside a larger expression. A refutable `let` only works if you're actually using a `let`-binding to begin with.

-Kevin

On Dec 23, 2013, at 1:24 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> On 23/12/2013 22:19, Liigo Zhuang wrote:
>> Code full of .unwrap() is not good smell I think.
> 
> I agree, and I wrote in the first email that it is one of the downsides.
> 
> But doubling the API (from_utf8 and from_utf8_opt) is also not a good smell, so it?s a compromise to find.
> 
> -- 
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From ben.striegel at gmail.com  Mon Dec 23 13:26:29 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 23 Dec 2013 16:26:29 -0500
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52B89FC2.2070509@exyr.org>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
	<CAHYVw0xL_PQb-UTwbetbFH0zXKoY=nEbXut_RSBqNDp7Va2g9w@mail.gmail.com>
	<CAPoegsxsF7UNe4xfMAUzDMJQs9pxJUWvXmU_fmRmcnrHSL0XYw@mail.gmail.com>
	<CAAvrL-meA5Qs+JM4s8WnjzZOk9cd4LZTsxOXo=EhZYWQdP_gYw@mail.gmail.com>
	<52B89FC2.2070509@exyr.org>
Message-ID: <CAAvrL-=JtTtwu7FFmjW3pO8WQrSQjhXSnSUimJCyH5-yWoVwdg@mail.gmail.com>

> For those of us that were not around or do not remember, can you explain
what was tried and rejected?

Heh, it was so long ago that I forgot that the `match` keyword used to be
`alt`. Here's the relevant section from the 0.1 manual (Jan 2012):

https://github.com/mozilla/rust/blob/16e4369fe3b5f00aa3cdc584a4e41c51c0d3ca8a/doc/tutorial.md#pattern-matching

"If the arm with the wildcard pattern was left off in the above example,
running it on a number greater than ten (or negative) would cause a
run-time failure. When no arm matches, alt constructs do not silently fall
through?they blow up instead."

Back then, we had no facility to statically force exhaustiveness. This
changed in 0.2, when exhaustive matches became the default, though you
could still opt-in to non-exhaustive matches by using `alt check` rather
than `alt`.

https://github.com/mozilla/rust/blob/619c4fce891f31ec234a3ac162d40d3def95956e/RELEASES.txt#L581

Indeed, as you mention, at the time people were worried that this would
lead to widespread proliferation of `_ => fail`, especially for uses such
as matching on integers, which we lack the facilities to exhaustively
check. However, in the years since, I can remember only a single person
noticing this and lamenting it, and the peace of mind provided by
statically-checked exhaustiveness is certainly pleasant. Furthermore, so
few people opted-in to dynamic checking via `alt check` that we had dropped
the functionality entirely by 0.4.


On Mon, Dec 23, 2013 at 3:40 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> On 23/12/2013 20:55, Benjamin Striegel wrote:
>
>> I too think it would be a big mistake to allow let patterns to be
>> refutable, when we've already tried and rejected allowing the same in
>> match statements (ancient Rust history quiz: who else remembers `match
>> check`?).
>>
>
> For those of us that were not around or do not remember, can you explain
> what was tried and rejected?
>
> I sometimes find myself writing a `_ => ()` arm for match and wish it
> could be implied? and sometimes `_ => fail!()`. That the two are sometimes
> used is probably a sign that the status quo (require it to be explicit) is
> better.
>
> --
> Simon Sapin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131223/9e7a186c/attachment.html>

From simon.sapin at exyr.org  Mon Dec 23 13:32:07 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Mon, 23 Dec 2013 22:32:07 +0100
Subject: [rust-dev] See pull request #11129
In-Reply-To: <2F08F9DA-0C9E-4DAD-994B-221FEDF37CB3@sb.org>
References: <52A23660.5040500@exyr.org>	<52B8A034.7030301@exyr.org>
	<CAH8Jz7jX+h=aPDuMXOtjNg18MwUU+A2gp5gGscriE-5uHUhTcw@mail.gmail.com>
	<52B8AA1F.3000705@exyr.org>
	<2F08F9DA-0C9E-4DAD-994B-221FEDF37CB3@sb.org>
Message-ID: <52B8ABD7.90802@exyr.org>

On 23/12/2013 22:26, Kevin Ballard wrote:
> Even with refutable `let`s, I think there's still a good case for
> having `.unwrap()`-style APIs on enums, which is that often you need
> to unwrap an enum inside a larger expression. A refutable `let` only
> works if you're actually using a `let`-binding to begin with.

Please don?t change the subject of (at least this part of) this thread.

This is about having both variations of an API (using task failure or 
returning Option) vs. only the latter (and using unwrap() when task 
failure is desired.) It is not about refutable let vs. unwrap-style methods.

-- 
Simon Sapin

From philippe.delrieu at free.fr  Tue Dec 24 03:41:41 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 24 Dec 2013 12:41:41 +0100
Subject: [rust-dev] How to send a closure in a task
Message-ID: <52B972F5.2050803@free.fr>

Hello,

I try to capture a closure in a task and I have the error:
error: cannot capture variable of type `|u64, T|`, which does not 
fulfill `Send`, in a bounded closure

Any hint to make the closure 'send-able'?

The code I use :

     pub fn Pt_start<T:Send> (resolution : u64, userData : T , callback: 
|u64 , T|) {
         let mut task = task::task();
         task.sched_mode(task::SingleThreaded);
         do task.spawn || {
             let mut timer = timer::Timer::new().unwrap();
             let periodic = timer.periodic(resolution);
             loop {
                 periodic.recv();
                 callback(10, userData);
             }

         }

     }

thank for your help.

Philippe Delrieu


From larsberg at mozilla.com  Tue Dec 24 08:01:18 2013
From: larsberg at mozilla.com (Lars Bergstrom)
Date: Tue, 24 Dec 2013 10:01:18 -0600
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52B8717A.9020401@mozilla.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
Message-ID: <670C1C8E-6A9C-4A48-ACF1-DCBAEE9D18A9@mozilla.com>

On Dec 23, 2013, at 11:23 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> 
> On 12/23/13 4:12 AM, G?bor Lehel wrote:
>> I don't like either that (a) the possible failure is silent, and
>> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
>> into the semantics. Haskell has these also and I think it's a wart. The
>> proposed syntax solves both issues.
> 
> For what it's worth, Rust's pattern matching is pretty heavily based on OCaml's and the OCaml compiler complains with a warning if you use a refutable pattern in `let`.

At the time SML and Caml made those decisions, neither language provided stack backtraces. According to the folks I've asked about it, the reason that refutable patterns in let bindings were left in there with a warning was that if you called Option.valOf on NONE, you just get:
uncaught exception Option
  raised at: Basis/Implementation/option.sml:17.25-17.31
- 

And the debugging is a real pain because "you failed in the basis library" doesn't help you track it down and you're pretty much stuck with printf-debugging (because there were also no debuggers / breakpoints). Whereas if you fail on the binding, the exception is thrown on the line where the binding attempt occurred:
uncaught exception Bind [nonexhaustive binding failure]
  raised at: stdIn:1.10-3.10
- 

This was supposedly an especially contentious decision in the SML language design meetings.

Given that modern ML implementations at least have the option to provide stack backtraces in debugging builds, the people I've talked to have said they would probably not allow refutable patterns today because large codebases written in this style end up with hundreds to thousands of "ignorable warnings" in their output, which both looks ugly and drowns out any real warnings. But, they can't change things now because it would break too much legacy code.
- Lars

From bill_myers at outlook.com  Tue Dec 24 08:23:51 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Tue, 24 Dec 2013 16:23:51 +0000
Subject: [rust-dev] RFC: Generalized monadic notation
Message-ID: <BAY170-W1231E673FBDB6CBA0E03F21F8C00@phx.gbl>

Some languages support a special "do notation" that allows to express monadic operations more naturally.

However, there is an even more powerful option, that I'd call "in notation" (I came up with it, but it's obvious, so I'm sure there's some language that has something like it).

The idea is that we add an "in" keyword, and in-types, which are the type "in T" where T is a monadic type.

In-types are physically represented as the monadic type, but semantically behave like the type contained in the monad; they are constructed with the expression "in x".

The "out" keyword does the opposite, converting an in-type to the wrapped type.

Operations performed on in types actually act on the value inside of the monad, as better specified below

Quick examples:
out(in Some(3) + 6) gives Some(9)
out(in Some(3) + in Some(6)) also gives Some(9)
out(in Some(3) + in None) gives None
out(in ~[1, 2, 3] + 10) gives ~[11, 12, 13]
out(in ~[1, 2, 3] + in ~[10, 20, 30]) gives ~[11, 21, 31, 12, 22, 32, 13, 23, 33]

Internally, when the compiler encounters any expression including an in-type (expressions include control flow constructs), it proceeds like this (considering its operands from left to right):
1. Optionally, if the expression is correctly typed (e.g. calling a function that takes an in-type), it compiles it normally
2. If the expression does not have an in-type value itself, it converts the expression into a closure, and passes it to map()
2. If the expression does have an in-type value itself (for example in x + in y has an in-type when viewed as a function of in x, due to the presence of in y), it converts out(expression) into a closure, and passes it to flat_map()

Non-movable control flow like return or break is forbidden in expression involving in-types (they can be implemented with a flag, but that causes other equivalence issues).

The advantage of this is that special do-notation syntax is not required, and one can naturally manipulate the values.

The disadvantage is that it adds a layer of "magic", making what the code actually does less obvious.

This is particularly true with list-like monads, where simple things like (in x) + (in y) actually become a double loop with quadratic run-time; this can be optionally avoided by only allowing "in notation" to be used with monads that call the closure once.

Also, side effects will be performed a different amount of times depending on the monad values, which may also not be obvious.

Note that there are a lot of details that I omitted for the sake of brevity, and would need to be handled. 		 	   		  

From carter.schonwald at gmail.com  Tue Dec 24 08:58:31 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 24 Dec 2013 11:58:31 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <670C1C8E-6A9C-4A48-ACF1-DCBAEE9D18A9@mozilla.com>
References: <CA+GmM=yZjFtfWNYWBtW4gF09fP2QPZjHuirs363UE4QBSNCe2g@mail.gmail.com>
	<CAHYVw0zpigk5hi=DpNWdVskhHCFpVY=UvkTEjZOJ4Z+FTJnwag@mail.gmail.com>
	<CAH0VdcbNpaRJT0hZoCPFZQXcGP1E7n0FupWhF9Aju18yuKQU7w@mail.gmail.com>
	<CD962755-4A9A-453E-BFA1-76CBB8DCACC6@googlemail.com>
	<CA++BO6TM32nJ1cnV-PROh48WbSSLK2NGPmfo1ZxOERnkDTwreQ@mail.gmail.com>
	<1FB3EFDF-81A8-47BB-B2AE-F605587CDFB5@googlemail.com>
	<46CDCD0E-4E6E-4D58-BB19-18AA698EC4C1@sb.org>
	<CAPoegsw_mW+RZ+A8EsZjyn5a7frcrxp60jPNppUi8f204eWekQ@mail.gmail.com>
	<382C7778-80F1-4E17-BDD1-CFAFAC5CBB85@googlemail.com>
	<B4B69C06-0BF3-4478-9D78-19375C5DE7D5@gmail.com>
	<CAN1rdEz3xvtVkKwi2s2JSh+zeJ3Esv24tvvDRNeQC6kggH2hjg@mail.gmail.com>
	<CAHYVw0wVDAUyHfqGfWx2UjYMB-ETKn8_VJLKYEfSiArEG=Qu_A@mail.gmail.com>
	<CA++BO6Qo=PoC5M133owsieBS42mQKaKO+SKy-qmZNK_EDFqV4A@mail.gmail.com>
	<F9C26F66-25A1-477A-BB77-D7FAB6D80F94@masklinn.net>
	<CAPoegsy2r7KzeHEvUhMR0h7t-yUq5bV7tnzjihK6eYX=U6JQSg@mail.gmail.com>
	<52B8717A.9020401@mozilla.com>
	<670C1C8E-6A9C-4A48-ACF1-DCBAEE9D18A9@mozilla.com>
Message-ID: <CAHYVw0zWwk2TdYngoU1j5WQ21Zq7ggKEYtavrhbGDu_H9XP4qw@mail.gmail.com>

This is a very good point.  Many of those same issues apply in Haskell too.

Additionally, the examples people have given for refutable let thus far all
seem to be special cases of a do notation / computation expression /
monadic abstraction.

That said, unless a special builtin trait is made, that line of
recommendation seems like it's not viable until rusts type system gets a
bit more enriched, what with higher kinded types being needed etc.

On Tuesday, December 24, 2013, Lars Bergstrom wrote:

> On Dec 23, 2013, at 11:23 AM, Patrick Walton <pcwalton at mozilla.com<javascript:;>>
> wrote:
> >
> > On 12/23/13 4:12 AM, G?bor Lehel wrote:
> >> I don't like either that (a) the possible failure is silent, and
> >> refutable lets look the same as irrefutable ones, nor (b) baking fail!()
> >> into the semantics. Haskell has these also and I think it's a wart. The
> >> proposed syntax solves both issues.
> >
> > For what it's worth, Rust's pattern matching is pretty heavily based on
> OCaml's and the OCaml compiler complains with a warning if you use a
> refutable pattern in `let`.
>
> At the time SML and Caml made those decisions, neither language provided
> stack backtraces. According to the folks I've asked about it, the reason
> that refutable patterns in let bindings were left in there with a warning
> was that if you called Option.valOf on NONE, you just get:
> uncaught exception Option
>   raised at: Basis/Implementation/option.sml:17.25-17.31
> -
>
> And the debugging is a real pain because "you failed in the basis library"
> doesn't help you track it down and you're pretty much stuck with
> printf-debugging (because there were also no debuggers / breakpoints).
> Whereas if you fail on the binding, the exception is thrown on the line
> where the binding attempt occurred:
> uncaught exception Bind [nonexhaustive binding failure]
>   raised at: stdIn:1.10-3.10
> -
>
> This was supposedly an especially contentious decision in the SML language
> design meetings.
>
> Given that modern ML implementations at least have the option to provide
> stack backtraces in debugging builds, the people I've talked to have said
> they would probably not allow refutable patterns today because large
> codebases written in this style end up with hundreds to thousands of
> "ignorable warnings" in their output, which both looks ugly and drowns out
> any real warnings. But, they can't change things now because it would break
> too much legacy code.
> - Lars
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/d700774f/attachment.html>

From danielmicay at gmail.com  Tue Dec 24 09:09:15 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 12:09:15 -0500
Subject: [rust-dev] RFC: Generalized monadic notation
In-Reply-To: <BAY170-W1231E673FBDB6CBA0E03F21F8C00@phx.gbl>
References: <BAY170-W1231E673FBDB6CBA0E03F21F8C00@phx.gbl>
Message-ID: <CA+DvKQJiUqSWrTJH3sAA6xZBDCbq-MTBzVjpV0cc4Jiez_+www@mail.gmail.com>

On Tue, Dec 24, 2013 at 11:23 AM, Bill Myers <bill_myers at outlook.com> wrote:
> Some languages support a special "do notation" that allows to express monadic operations more naturally.
>
> However, there is an even more powerful option, that I'd call "in notation" (I came up with it, but it's obvious, so I'm sure there's some language that has something like it).
>
> The idea is that we add an "in" keyword, and in-types, which are the type "in T" where T is a monadic type.
>
> In-types are physically represented as the monadic type, but semantically behave like the type contained in the monad; they are constructed with the expression "in x".
>
> The "out" keyword does the opposite, converting an in-type to the wrapped type.
>
> Operations performed on in types actually act on the value inside of the monad, as better specified below
>
> Quick examples:
> out(in Some(3) + 6) gives Some(9)
> out(in Some(3) + in Some(6)) also gives Some(9)
> out(in Some(3) + in None) gives None
> out(in ~[1, 2, 3] + 10) gives ~[11, 12, 13]
> out(in ~[1, 2, 3] + in ~[10, 20, 30]) gives ~[11, 21, 31, 12, 22, 32, 13, 23, 33]
>
> Internally, when the compiler encounters any expression including an in-type (expressions include control flow constructs), it proceeds like this (considering its operands from left to right):
> 1. Optionally, if the expression is correctly typed (e.g. calling a function that takes an in-type), it compiles it normally
> 2. If the expression does not have an in-type value itself, it converts the expression into a closure, and passes it to map()
> 2. If the expression does have an in-type value itself (for example in x + in y has an in-type when viewed as a function of in x, due to the presence of in y), it converts out(expression) into a closure, and passes it to flat_map()
>
> Non-movable control flow like return or break is forbidden in expression involving in-types (they can be implemented with a flag, but that causes other equivalence issues).
>
> The advantage of this is that special do-notation syntax is not required, and one can naturally manipulate the values.
>
> The disadvantage is that it adds a layer of "magic", making what the code actually does less obvious.
>
> This is particularly true with list-like monads, where simple things like (in x) + (in y) actually become a double loop with quadratic run-time; this can be optionally avoided by only allowing "in notation" to be used with monads that call the closure once.
>
> Also, side effects will be performed a different amount of times depending on the monad values, which may also not be obvious.
>
> Note that there are a lot of details that I omitted for the sake of brevity, and would need to be handled.

I'm strongly against adding complex language features like this.
Parser expansion hacks or complex fallback paths have no place in the
language proper. The pattern should be possible to encode in traits
and needs to be proven as a widely applicable form of code reuse with
an insignificant cognitive and performance overhead before discussing
syntactic sugar makes sense.

From ben.striegel at gmail.com  Tue Dec 24 09:27:22 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 24 Dec 2013 12:27:22 -0500
Subject: [rust-dev] RFC: Generalized monadic notation
In-Reply-To: <CA+DvKQJiUqSWrTJH3sAA6xZBDCbq-MTBzVjpV0cc4Jiez_+www@mail.gmail.com>
References: <BAY170-W1231E673FBDB6CBA0E03F21F8C00@phx.gbl>
	<CA+DvKQJiUqSWrTJH3sAA6xZBDCbq-MTBzVjpV0cc4Jiez_+www@mail.gmail.com>
Message-ID: <CAAvrL-n9r_WEEh3fCd5Sxxo4DzCOU9HFQUy3-UhUmkpZkOjc9Q@mail.gmail.com>

Every time that we've added magic, we've lived to regret it and ultimately
revert it. If there exists only a single lesson of the past few years of
language evolution, let it be this.

Furthermore, any discussions of monads and/or HKT are pie-in-the-sky at
this point. Our complexity budget is stretched thin enough as it is. Assume
that Rust 1.0 will *not* have these features, and plan accordingly.


On Tue, Dec 24, 2013 at 12:09 PM, Daniel Micay <danielmicay at gmail.com>wrote:

> On Tue, Dec 24, 2013 at 11:23 AM, Bill Myers <bill_myers at outlook.com>
> wrote:
> > Some languages support a special "do notation" that allows to express
> monadic operations more naturally.
> >
> > However, there is an even more powerful option, that I'd call "in
> notation" (I came up with it, but it's obvious, so I'm sure there's some
> language that has something like it).
> >
> > The idea is that we add an "in" keyword, and in-types, which are the
> type "in T" where T is a monadic type.
> >
> > In-types are physically represented as the monadic type, but
> semantically behave like the type contained in the monad; they are
> constructed with the expression "in x".
> >
> > The "out" keyword does the opposite, converting an in-type to the
> wrapped type.
> >
> > Operations performed on in types actually act on the value inside of the
> monad, as better specified below
> >
> > Quick examples:
> > out(in Some(3) + 6) gives Some(9)
> > out(in Some(3) + in Some(6)) also gives Some(9)
> > out(in Some(3) + in None) gives None
> > out(in ~[1, 2, 3] + 10) gives ~[11, 12, 13]
> > out(in ~[1, 2, 3] + in ~[10, 20, 30]) gives ~[11, 21, 31, 12, 22, 32,
> 13, 23, 33]
> >
> > Internally, when the compiler encounters any expression including an
> in-type (expressions include control flow constructs), it proceeds like
> this (considering its operands from left to right):
> > 1. Optionally, if the expression is correctly typed (e.g. calling a
> function that takes an in-type), it compiles it normally
> > 2. If the expression does not have an in-type value itself, it converts
> the expression into a closure, and passes it to map()
> > 2. If the expression does have an in-type value itself (for example in x
> + in y has an in-type when viewed as a function of in x, due to the
> presence of in y), it converts out(expression) into a closure, and passes
> it to flat_map()
> >
> > Non-movable control flow like return or break is forbidden in expression
> involving in-types (they can be implemented with a flag, but that causes
> other equivalence issues).
> >
> > The advantage of this is that special do-notation syntax is not
> required, and one can naturally manipulate the values.
> >
> > The disadvantage is that it adds a layer of "magic", making what the
> code actually does less obvious.
> >
> > This is particularly true with list-like monads, where simple things
> like (in x) + (in y) actually become a double loop with quadratic run-time;
> this can be optionally avoided by only allowing "in notation" to be used
> with monads that call the closure once.
> >
> > Also, side effects will be performed a different amount of times
> depending on the monad values, which may also not be obvious.
> >
> > Note that there are a lot of details that I omitted for the sake of
> brevity, and would need to be handled.
>
> I'm strongly against adding complex language features like this.
> Parser expansion hacks or complex fallback paths have no place in the
> language proper. The pattern should be possible to encode in traits
> and needs to be proven as a widely applicable form of code reuse with
> an insignificant cognitive and performance overhead before discussing
> syntactic sugar makes sense.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/616b090e/attachment-0001.html>

From pcwalton at mozilla.com  Tue Dec 24 10:06:03 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 10:06:03 -0800
Subject: [rust-dev] How to send a closure in a task
In-Reply-To: <52B972F5.2050803@free.fr>
References: <52B972F5.2050803@free.fr>
Message-ID: <52B9CD0B.4050606@mozilla.com>

On 12/24/13 3:41 AM, Philippe Delrieu wrote:
> Hello,
>
> I try to capture a closure in a task and I have the error:
> error: cannot capture variable of type `|u64, T|`, which does not
> fulfill `Send`, in a bounded closure
>
> Any hint to make the closure 'send-able'?

Try `'static |u64, T|` or `extern "Rust" fn(u64, T)`.

Patrick


From igor at mir2.org  Tue Dec 24 10:45:02 2013
From: igor at mir2.org (Igor Bukanov)
Date: Tue, 24 Dec 2013 19:45:02 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
Message-ID: <CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>

In Closure there are no unbounded channels and this talk
http://www.infoq.com/presentations/clojure-core-async starting from
minute 22 describes that Closure explicitly does not support unbounded
channels and never will.

From pwalton at mozilla.com  Tue Dec 24 10:56:43 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 10:56:43 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
Message-ID: <3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>

I think we need them to handle the Web semantics though. We can't just drop input events.

Igor Bukanov <igor at mir2.org> wrote:
>In Closure there are no unbounded channels and this talk
>http://www.infoq.com/presentations/clojure-core-async starting from
>minute 22 describes that Closure explicitly does not support unbounded
>channels and never will.
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/2f8c17e8/attachment.html>

From danielmicay at gmail.com  Tue Dec 24 11:03:16 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 14:03:16 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
Message-ID: <CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>

On Tue, Dec 24, 2013 at 1:56 PM, Patrick Walton <pwalton at mozilla.com> wrote:
> I think we need them to handle the Web semantics though. We can't just drop
> input events.

It would be better to use a bounded queue and report an error when it
gets to megabytes or gigabytes in size than going out-of-memory
though. A user will prefer a clean exit of the tab or browser compared
to it becoming locked because the events aren't being promptly
handled or it causing a significant system performance degradation
ending with the browser being killed.

From carter.schonwald at gmail.com  Tue Dec 24 11:12:27 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 24 Dec 2013 14:12:27 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
Message-ID: <CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>

Indeed! And the producer can always have their own private backlog. There
is nothing preventing each producer having it's one internal backlog queue
that's not bounded. But such behavior should be deliberate rather than
accidental.

On Tuesday, December 24, 2013, Daniel Micay wrote:

> On Tue, Dec 24, 2013 at 1:56 PM, Patrick Walton <pwalton at mozilla.com<javascript:;>>
> wrote:
> > I think we need them to handle the Web semantics though. We can't just
> drop
> > input events.
>
> It would be better to use a bounded queue and report an error when it
> gets to megabytes or gigabytes in size than going out-of-memory
> though. A user will prefer a clean exit of the tab or browser compared
> to it becoming locked because the events aren't being promptly
> handled or it causing a significant system performance degradation
> ending with the browser being killed.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/135d0c99/attachment.html>

From vadimcn at gmail.com  Tue Dec 24 14:42:24 2013
From: vadimcn at gmail.com (Vadim)
Date: Tue, 24 Dec 2013 14:42:24 -0800
Subject: [rust-dev] Man or boy?
Message-ID: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>

Hi,
For a bit of holiday fun, I want to present a Rust implementation of
Knuth's man-or-boy <http://en.wikipedia.org/wiki/Man_or_boy_test> compiler
test.  Can this be improved?
Here's<http://rosettacode.org/wiki/Man_or_boy_test>how it looks in
other languages.

Right off the bat, I would say that would be prettier if we had argument
auto-borrowing, if invocation operator would auto-deref, and if closure
assignment was in scope to be captured inside the closure itself (wouldn't
have to do dummy init of the B var).

cheers,
Vadim

type T<'s> = 's || -> int;

fn man_or_boy(k:int) -> int {
    fn A(k:int, x1:&T, x2:&T, x3:&T, x4:&T, x5:&T) -> int {
        let mut k = k;

        let mut B: T = || {fail!()};
        B = || {
            k -= 1;
            A(k, &B, x1, x2, x3, x4)
        };

        if k <= 0 {
            (*x4)() + (*x5)()
        } else {
            B()
        }
    }
    A(k, &||{1}, &||{-1}, &||{-1}, &||{1}, &||{0})
}

fn main() {
    for k in range(0,20) {
        println!("{} => {}", k, man_or_boy(k));
    }
}


Sample output:

0 => 1
1 => 0
2 => -2
3 => 0
4 => 1
5 => 0
6 => 1
7 => -1
8 => -10
9 => -30
10 => -67
11 => -138
12 => -291
13 => -642
14 => -1446
task '<main>' has overflowed its stack
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/85742f35/attachment.html>

From me at kevincantu.org  Tue Dec 24 15:32:51 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Tue, 24 Dec 2013 15:32:51 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
Message-ID: <CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>

This seems like a false dichotomy.  I'd rather ask: do we want the
scheduling library code to deliberately avoid resource exhaustion or
do we want the Servo code to deliberately avoid resource exhaustion?

Kevin



On Tue, Dec 24, 2013 at 11:12 AM, Carter Schonwald
<carter.schonwald at gmail.com> wrote:
> Indeed! And the producer can always have their own private backlog. There is
> nothing preventing each producer having it's one internal backlog queue
> that's not bounded. But such behavior should be deliberate rather than
> accidental.
>
>
> On Tuesday, December 24, 2013, Daniel Micay wrote:
>>
>> On Tue, Dec 24, 2013 at 1:56 PM, Patrick Walton <pwalton at mozilla.com>
>> wrote:
>> > I think we need them to handle the Web semantics though. We can't just
>> > drop
>> > input events.
>>
>> It would be better to use a bounded queue and report an error when it
>> gets to megabytes or gigabytes in size than going out-of-memory
>> though. A user will prefer a clean exit of the tab or browser compared
>> to it becoming locked because the events aren't being promptly
>> handled or it causing a significant system performance degradation
>> ending with the browser being killed.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From pcwalton at mozilla.com  Tue Dec 24 16:53:53 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 16:53:53 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
Message-ID: <52BA2CA1.4010709@mozilla.com>

On 12/24/13 11:03 AM, Daniel Micay wrote:
> On Tue, Dec 24, 2013 at 1:56 PM, Patrick Walton <pwalton at mozilla.com> wrote:
>> I think we need them to handle the Web semantics though. We can't just drop
>> input events.
>
> It would be better to use a bounded queue and report an error when it
> gets to megabytes or gigabytes in size than going out-of-memory
> though. A user will prefer a clean exit of the tab or browser compared
> to it becoming locked because the events aren't being promptly
> handled or it causing a significant system performance degradation
> ending with the browser being killed.

This is just one specific case of out-of-memory, though. I would rather 
handle the problem of too much resource consumption in some generic way: 
input event floods can cause OOM, sure, but so can an infinite loop 
creating DOM objects, or an infinite loop filling the user's history 
with a flood of URLs, or any number of other things.

I haven't heard of input event flooding causing OOM being a problem in 
practice, though I could be wrong of course.

A quick search suggests that Qt's event queue is unbounded.

Patrick


From pcwalton at mozilla.com  Tue Dec 24 16:55:46 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 16:55:46 -0800
Subject: [rust-dev] Man or boy?
In-Reply-To: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
References: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
Message-ID: <52BA2D12.9000103@mozilla.com>

On 12/24/13 2:42 PM, Vadim wrote:
> Hi,
> For a bit of holiday fun, I want to present a Rust implementation of
> Knuth's man-or-boy <http://en.wikipedia.org/wiki/Man_or_boy_test>
> compiler test.  Can this be improved? Here's
> <http://rosettacode.org/wiki/Man_or_boy_test> how it looks in other
> languages.
>
> Right off the bat, I would say that would be prettier if we had argument
> auto-borrowing

I'm again pretty nervous about this, because this is one of the 
much-maligned features of C++ references.

> if invocation operator would auto-deref

I think I'm OK with this.

> and if closure
> assignment was in scope to be captured inside the closure itself
> (wouldn't have to do dummy init of the B var).

This would prevent the useful `let mut foo = foo` pattern.

Patrick


From pcwalton at mozilla.com  Tue Dec 24 17:02:09 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 17:02:09 -0800
Subject: [rust-dev] Man or boy?
In-Reply-To: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
References: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
Message-ID: <52BA2E91.2000705@mozilla.com>

On 12/24/13 2:42 PM, Vadim wrote:
>
> type T<'s> = 's || -> int;
>
> fn man_or_boy(k:int) -> int {
>      fn A(k:int, x1:&T, x2:&T, x3:&T, x4:&T, x5:&T) -> int {
>          let mut k = k;
>
>          let mut B: T = || {fail!()};
>          B = || {
>              k -= 1;
>              A(k, &B, x1, x2, x3, x4)
>          };
>
>          if k <= 0 {
>              (*x4)() + (*x5)()
>          } else {
>              B()
>          }
>      }
>      A(k, &||{1}, &||{-1}, &||{-1}, &||{1}, &||{0})
> }

Are you sure that calling a closure via an &-pointer `&||` isn't 
exploiting a bug in the borrow checker that can cause unsoundness (see 
"The Case of the Recurring Closure")? Niko, can you weigh in?

Patrick


From vadimcn at gmail.com  Tue Dec 24 17:17:58 2013
From: vadimcn at gmail.com (Vadim)
Date: Tue, 24 Dec 2013 17:17:58 -0800
Subject: [rust-dev] Man or boy?
In-Reply-To: <52BA2D12.9000103@mozilla.com>
References: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
	<52BA2D12.9000103@mozilla.com>
Message-ID: <-1126821932957398395@unknownmsgid>

Right off the bat, I would say that would be prettier if we had argument

auto-borrowing


I'm again pretty nervous about this, because this is one of the
much-maligned features of C++ references.


*Why* is it maligned, though?

and if closure

assignment was in scope to be captured inside the closure itself

(wouldn't have to do dummy init of the B var).


This would prevent the useful `let mut foo = foo` pattern.


How so?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131224/e3b96502/attachment.html>

From danielmicay at gmail.com  Tue Dec 24 17:45:59 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 20:45:59 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
Message-ID: <CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>

On Tue, Dec 24, 2013 at 6:32 PM, Kevin Cantu <me at kevincantu.org> wrote:
> This seems like a false dichotomy.  I'd rather ask: do we want the
> scheduling library code to deliberately avoid resource exhaustion or
> do we want the Servo code to deliberately avoid resource exhaustion?
>
> Kevin

Bounded channels present the choice between blocking (with an optional
timeout) when the channel is full or making a non-blocking call with
custom handling of the error case. Unbounded channels don't provide a
way to write robust systems without layering on application-level
message passing and book-keeping. It doesn't absolve you of handling
deadlocks by considering the bounds because you're just going to get a
far worse out-of-memory condition instead.

It's not sane to rely on the OS scheduler giving a consistent balance
of time slices between producers and consumers over a given period of
time. If you really know there are external factors limiting the size
of the queue, you can pass that as a bound. I don't think there's much
reason to use an unbounded queue when you aren't micro-optimizing to
the point where you're saving bytes and instructions by dropping one
of the condition variables.

From comexk at gmail.com  Tue Dec 24 18:10:48 2013
From: comexk at gmail.com (comex)
Date: Tue, 24 Dec 2013 21:10:48 -0500
Subject: [rust-dev] Man or boy?
In-Reply-To: <-1126821932957398395@unknownmsgid>
References: <CADecdiK3PeDW0WmoGRD5cU0Orxj-Vk9-zi72j7E7VAoR674G1w@mail.gmail.com>
	<52BA2D12.9000103@mozilla.com> <-1126821932957398395@unknownmsgid>
Message-ID: <CAPM5UJ2NY7Wz+j26AA5xkh3EVFP93=bjkKYEN7D2F=5xSH9fNQ@mail.gmail.com>

On Tue, Dec 24, 2013 at 8:17 PM, Vadim <vadimcn at gmail.com> wrote:
> I'm again pretty nervous about this, because this is one of the
> much-maligned features of C++ references.
>
>
> Why is it maligned, though?

I malign it mainly because it allows (and encourages) confusing code
that looks like it's calling a function with a variable as an argument
but actually mutates the variable.  Arguably, only auto-borrowing
immutably would sidestep this issue.

From pcwalton at mozilla.com  Tue Dec 24 18:48:01 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 18:48:01 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
Message-ID: <52BA4761.7040304@mozilla.com>

On 12/24/13 5:45 PM, Daniel Micay wrote:
> Bounded channels present the choice between blocking (with an optional
> timeout) when the channel is full or making a non-blocking call with
> custom handling of the error case.

I prefer the latter.

> Unbounded channels don't provide a
> way to write robust systems without layering on application-level
> message passing and book-keeping. It doesn't absolve you of handling
> deadlocks by considering the bounds because you're just going to get a
> far worse out-of-memory condition instead.

I don't think OOM is far worse than a deadlock. On the server side both 
amount to "get a page and log into the machine and restart the affected 
process". Which is of course very bad, but I don't think one is that 
much worse than the other.

Anyway, I'm OK with bounded channels to avoid OOM, but I'm pretty unsure 
about the following three things:

1. Blocking on the sender side when the queue is full. This causes 
deadlocks. You can create the equivalent using two channels if you 
really want this behavior.

2. Allocating a flat array with the size of the bound up front for 
channels. In a producer/consumer scenario, you want the bound to be high 
to maximize parallelism, without paying a constant memory usage penalty.

3. Having a bound of 1 by default. The default should allow for parallelism.

Haskell may be a nice thing to look at here: the unbounded channel is 
the primitive, and bounded channels are built on top of unbounded ones 
using an `MVar` to rate limit. Such a thing could be easily built in 
Rust using a channel paired with an `AtomicUint`.

Patrick


From danielmicay at gmail.com  Tue Dec 24 19:23:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 22:23:58 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BA4761.7040304@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
Message-ID: <CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>

On Tue, Dec 24, 2013 at 9:48 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 12/24/13 5:45 PM, Daniel Micay wrote:
>>
>> Bounded channels present the choice between blocking (with an optional
>> timeout) when the channel is full or making a non-blocking call with
>> custom handling of the error case.
>
>
> I prefer the latter.
>
>
>> Unbounded channels don't provide a
>> way to write robust systems without layering on application-level
>> message passing and book-keeping. It doesn't absolve you of handling
>> deadlocks by considering the bounds because you're just going to get a
>> far worse out-of-memory condition instead.
>
>
> I don't think OOM is far worse than a deadlock. On the server side both
> amount to "get a page and log into the machine and restart the affected
> process". Which is of course very bad, but I don't think one is that much
> worse than the other.

It's worse than a deadlock because out-of-memory causes significant
issues for the rest of the system. It will cause a massive amount of
swapping, which without an SSD can cause a catastrophic increase in
latency where the system will just churn for ages.

On a system without overcommit, many processes are going to hit
failures in `malloc` and may have to flush buffers and terminate. In a
system with overcommit, the misbehaving Rust process will hopefully be
killed but it's not a sure thing since another process may be using a
lot more memory for a valid reason.

I think the ability to deadlock is overstated... as it's not going to
happen without two-way communication. If you have clear consumers and
producers then it's not an issue you can hit. If you don't, then you
can still have a well-defined communication protocol handling the
issue.

> Anyway, I'm OK with bounded channels to avoid OOM, but I'm pretty unsure
> about the following three things:
>
> 1. Blocking on the sender side when the queue is full. This causes
> deadlocks. You can create the equivalent using two channels if you really
> want this behavior.

When an unbounded queue is full, a process is killed. It's not really
a point in favour of unbounded queues in my opinion.

> 2. Allocating a flat array with the size of the bound up front for channels.
> In a producer/consumer scenario, you want the bound to be high to maximize
> parallelism, without paying a constant memory usage penalty.

It makes sense to allocate it up-front for some lock-free queues but
not a classical one built on a mutex and two condition variables. I
doubt that a lock-free algorithm with have any significant wins
against a Linux mutex or Windows critical section, and on Haswell lock
elision erases the theoretical benefits too.

> 3. Having a bound of 1 by default. The default should allow for parallelism.

A bound of 1 by default seems pretty stupid. I've never understood why
Go does this... it belongs in a separate type.

> Haskell may be a nice thing to look at here: the unbounded channel is the
> primitive, and bounded channels are built on top of unbounded ones using an
> `MVar` to rate limit. Such a thing could be easily built in Rust using a
> channel paired with an `AtomicUint`.

The performance does matter though and this seems like it would slow
things down. If it's built on top of the lock-free channels it will be
doing needless atomic operations.

From pcwalton at mozilla.com  Tue Dec 24 19:33:36 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 24 Dec 2013 19:33:36 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
Message-ID: <52BA5210.2080100@mozilla.com>

On 12/24/13 7:23 PM, Daniel Micay wrote:
> I think the ability to deadlock is overstated... as it's not going to
> happen without two-way communication. If you have clear consumers and
> producers then it's not an issue you can hit. If you don't, then you
> can still have a well-defined communication protocol handling the
> issue.

It can happen with one-way communication too. Here's the example I 
always give. Suppose you have an photo app that fetches a list of images 
from the network, sorts them by date, and places the result into a 
folder. You might structure it as two tasks, A and B, and two channels, 
"Images" and "Done". A fetches images one by one and places them into 
the "Images" channel. When it's done it sends a ping on the "Done" 
channel. B waits on the "Done" channel, then drains the "Images" 
channel, sorts the results, and writes the result into a folder.

Despite having only one-way communication, this app contains a nasty 
deadlock hazard with bounded channels. If there are more images than the 
size of the "Images" channel then you will deadlock. Your unit tests may 
not catch this, because it only happens if you have a lot of images. 
Unbounded channels do not have this problem.

You could argue that this is bad design, and of course it is bad design 
if you have bounded channels, but one of the purposes of API design is 
to minimize the fallout of ill-thought-through designs.

Patrick


From danielmicay at gmail.com  Tue Dec 24 19:55:51 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 22:55:51 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BA5210.2080100@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<52BA5210.2080100@mozilla.com>
Message-ID: <CA+DvKQJ6j_xqj6YXkqdqJJbZzQLa2qUZeBEpfYFa625+AHkD8A@mail.gmail.com>

On Tue, Dec 24, 2013 at 10:33 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 12/24/13 7:23 PM, Daniel Micay wrote:
>>
>> I think the ability to deadlock is overstated... as it's not going to
>> happen without two-way communication. If you have clear consumers and
>> producers then it's not an issue you can hit. If you don't, then you
>> can still have a well-defined communication protocol handling the
>> issue.
>
> It can happen with one-way communication too. Here's the example I always
> give. Suppose you have an photo app that fetches a list of images from the
> network, sorts them by date, and places the result into a folder. You might
> structure it as two tasks, A and B, and two channels, "Images" and "Done". A
> fetches images one by one and places them into the "Images" channel. When
> it's done it sends a ping on the "Done" channel. B waits on the "Done"
> channel, then drains the "Images" channel, sorts the results, and writes the
> result into a folder.

Ah, I was thinking about simple thread pools and task trees with a
single work queue and didn't consider more complex situations like
this.

> Despite having only one-way communication, this app contains a nasty
> deadlock hazard with bounded channels. If there are more images than the
> size of the "Images" channel then you will deadlock. Your unit tests may not
> catch this, because it only happens if you have a lot of images. Unbounded
> channels do not have this problem.

In an example where it's not totally serialized, the bounded queue
would handle the source being a fast solid state disk and the
destination being a slow hard drive but the unbounded queue will
deplete all the available memory with enough images. Your unit tests
probably aren't going to catch either issue.

The unbounded queue still has a bound, it's just higher. There's a
greater chance of hitting the limit on a bounded queue since it's
probably lower, so it will happen more in production *and* in the
tests.

From danielmicay at gmail.com  Tue Dec 24 20:06:02 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 24 Dec 2013 23:06:02 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
Message-ID: <CA+DvKQJdbHmes8PmvTJD=Bi78RxNz5g7aOS=zd=p3Es25q+dYA@mail.gmail.com>

On Tue, Dec 24, 2013 at 10:23 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>
>> 3. Having a bound of 1 by default. The default should allow for parallelism.
>
> A bound of 1 by default seems pretty stupid. I've never understood why
> Go does this... it belongs in a separate type.

On second thought, this is a great thing for a debug build. It could
help to prevent the code from developing a dependency on the queue
capacity.

From james at mansionfamily.plus.com  Wed Dec 25 02:14:22 2013
From: james at mansionfamily.plus.com (james)
Date: Wed, 25 Dec 2013 10:14:22 +0000
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
Message-ID: <52BAAFFE.7020006@mansionfamily.plus.com>

On 25/12/2013 01:45, Daniel Micay wrote:
> Unbounded channels don't provide a
> way to write robust systems without layering on application-level
> message passing and book-keeping.
Can I point out that flow control isn't necessarily just back to the 
immediate producer?

It is relatively unusual to have a system that spontaneously explodes 
through
internal messaging.  Normally event chains start from an external event and
the resulting peak load on internal messaging can be estimated (and 
controlled).

So we have two types of queues - one handling external events and one 
handling
internal messaging.

It is also useful to consider this as three types:
  - external queues for unsolicited requests (ie externally initiated 
events)
  - external queues for response events to requests we made
  - internal queues

In most systems, what you really want is:
  - keep processing external responses (to avoid deadlocks)
  - keep processing internal events
  - back pressure to slow or stop unsolicited requests

Are you sure this isn't most directly handled by having a means to inspect
the total resource pressure and attaching events to thresholds, so that
input channels can be controlled?  Not all input channels are created
equal; the admin and diagnostics interface (whether an embedded web gui
or something else needs (ideally) to keep going when interactive and batch
feeds are stalled.

It concerns me that providing back pressure to the immediate chain only
can lead to a lot of messy propagation code.  And its code that's not so 
easy
to test or reason about.


From ben at 0x539.de  Wed Dec 25 06:00:34 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Wed, 25 Dec 2013 15:00:34 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BA4761.7040304@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
Message-ID: <1387980034.2653.10.camel@vigil>

On Tue, 2013-12-24 at 18:48 -0800, Patrick Walton wrote:
> Haskell may be a nice thing to look at here: the unbounded channel is 
> the primitive, and bounded channels are built on top of unbounded ones 
> using an `MVar` to rate limit. Such a thing could be easily built in 
> Rust using a channel paired with an `AtomicUint`.

Arguably the MVar as a bounded channel of fixed capacity 1 is the
primitive (both taking from and putting into an MVar will block if it is
empty or full, respectively), and unbounded Chans are just MVars all the
way down. But I'm not sure if that's not just nitpicking. ;)

-benh


From carter.schonwald at gmail.com  Wed Dec 25 07:22:37 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Wed, 25 Dec 2013 10:22:37 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <1387980034.2653.10.camel@vigil>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com> <1387980034.2653.10.camel@vigil>
Message-ID: <CAHYVw0zG0babPKBH=OLm084D4g3AJ2YztbHHBAv2N4rUMu1Gow@mail.gmail.com>

I'm not sure if that's how ghc channels work.  I seem to recall that the
main ones are using STM, though I think there's an MVAr one. There's some
differences in semantics for the two.



On Wednesday, December 25, 2013, Benjamin Herr wrote:

> On Tue, 2013-12-24 at 18:48 -0800, Patrick Walton wrote:
> > Haskell may be a nice thing to look at here: the unbounded channel is
> > the primitive, and bounded channels are built on top of unbounded ones
> > using an `MVar` to rate limit. Such a thing could be easily built in
> > Rust using a channel paired with an `AtomicUint`.
>
> Arguably the MVar as a bounded channel of fixed capacity 1 is the
> primitive (both taking from and putting into an MVar will block if it is
> empty or full, respectively), and unbounded Chans are just MVars all the
> way down. But I'm not sure if that's not just nitpicking. ;)
>
> -benh
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/28873349/attachment.html>

From bascule at gmail.com  Wed Dec 25 10:55:38 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 25 Dec 2013 10:55:38 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BAAFFE.7020006@mansionfamily.plus.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BAAFFE.7020006@mansionfamily.plus.com>
Message-ID: <CAHOTMVJQroisF9Rvdbyj8fWBeDOCOLHoeKGHxrrndVcBKZJ9ag@mail.gmail.com>

On Wed, Dec 25, 2013 at 2:14 AM, james <james at mansionfamily.plus.com> wrote:

> Can I point out that flow control isn't necessarily just back to the
> immediate producer?
>
> It is relatively unusual to have a system that spontaneously explodes
> through
> internal messaging.


This isn't true at all. I've helped many people debug overloaded systems
that didn't have sufficient mechanisms for internal backpressure between
actors in Celluloid.

--
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/b1afe3de/attachment.html>

From james at mansionfamily.plus.com  Wed Dec 25 11:08:17 2013
From: james at mansionfamily.plus.com (james)
Date: Wed, 25 Dec 2013 19:08:17 +0000
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVJQroisF9Rvdbyj8fWBeDOCOLHoeKGHxrrndVcBKZJ9ag@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BAAFFE.7020006@mansionfamily.plus.com>
	<CAHOTMVJQroisF9Rvdbyj8fWBeDOCOLHoeKGHxrrndVcBKZJ9ag@mail.gmail.com>
Message-ID: <52BB2D21.6000303@mansionfamily.plus.com>

On 25/12/2013 18:55, Tony Arcieri wrote:
> On Wed, Dec 25, 2013 at 2:14 AM, james <james at mansionfamily.plus.com 
> <mailto:james at mansionfamily.plus.com>> wrote:
>
>     Can I point out that flow control isn't necessarily just back to
>     the immediate producer?
>
>     It is relatively unusual to have a system that spontaneously
>     explodes through
>     internal messaging.
>
>
> This isn't true at all. I've helped many people debug overloaded 
> systems that didn't have sufficient mechanisms for internal 
> backpressure between actors in Celluloid.
>
> --
> Tony Arcieri
Really?  It just decides to start messaging for no reason and blows up, 
after no external stimulus?  Not even a timer?


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/74eeacb6/attachment.html>

From bascule at gmail.com  Wed Dec 25 11:40:23 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 25 Dec 2013 12:40:23 -0700
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BB2D21.6000303@mansionfamily.plus.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BAAFFE.7020006@mansionfamily.plus.com>
	<CAHOTMVJQroisF9Rvdbyj8fWBeDOCOLHoeKGHxrrndVcBKZJ9ag@mail.gmail.com>
	<52BB2D21.6000303@mansionfamily.plus.com>
Message-ID: <-63432512819739274@unknownmsgid>

> On Dec 25, 2013, at 12:08 PM, james <james at mansionfamily.plus.com> wrote:
> Really?  It just decides to start messaging for no reason and blows up, after no external stimulus?  Not even a timer?

Well, if that's what you meant, then your point is valid but a bit
silly, because useful systems will generally have non-message events

--
Tony Arcieri

From philippe.delrieu at free.fr  Wed Dec 25 11:41:19 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 25 Dec 2013 20:41:19 +0100
Subject: [rust-dev] How to send a closure in a task
In-Reply-To: <52B9CD0B.4050606@mozilla.com>
References: <52B972F5.2050803@free.fr> <52B9CD0B.4050606@mozilla.com>
Message-ID: <52BB34DF.4090503@free.fr>

Thank you for your help.

I test extern "Rust" fn(u64, T) and it works when I use a declared 
function. I didn't manage to make it works with a closure.

For the 'static |u64, &T| I have the same error :

cannot capture variable of type `'static |u64, &T|`, which does not 
fulfill `Send`, in a bounded closure

The function signature :
pub fn Pt_start<T:Send> (&self, resolution : u64, userData : T , 
callback: 'static |u64, &T|) {

Philippe

Le 24/12/2013 19:06, Patrick Walton a ?crit :
> On 12/24/13 3:41 AM, Philippe Delrieu wrote:
>> Hello,
>>
>> I try to capture a closure in a task and I have the error:
>> error: cannot capture variable of type `|u64, T|`, which does not
>> fulfill `Send`, in a bounded closure
>>
>> Any hint to make the closure 'send-able'?
>
> Try `'static |u64, T|` or `extern "Rust" fn(u64, T)`.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/ffe9ff97/attachment.html>

From kevin at sb.org  Wed Dec 25 13:41:55 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 25 Dec 2013 16:41:55 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
Message-ID: <4759AA17-99CF-4128-98EA-F13EB8155E2B@sb.org>

On Dec 24, 2013, at 10:23 PM, Daniel Micay <danielmicay at gmail.com> wrote:

>> 3. Having a bound of 1 by default. The default should allow for parallelism.
> 
> A bound of 1 by default seems pretty stupid. I've never understood why
> Go does this... it belongs in a separate type.

Go actually has a default bound of 0. When you send on a channel that wasn?t allocated with a given bound, it blocks until something else reads. A bound of 1 allows for a single item to be stored in the channel without blocking.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/5def4545/attachment.html>

From vadimcn at gmail.com  Wed Dec 25 14:17:22 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 25 Dec 2013 14:17:22 -0800
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
Message-ID: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>

I agree that unexpected mutation is undesirable, but:
- requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
- as currently implemented, Rust does not always require mut when callee
mutates the argument, for example:

fn main() {
    let mut i: int = 0;
    foo(&mut i);
    println!("{}", i);
}
fn foo(i: &mut int) {
    bar(i); // no mut!
}
fn bar(i: &mut int) {
    *i = *i + 1;
}

Note that invocation of bar() inside foo() does not forewarn reader by
requiring 'mut'.  Wouldn't you rather see this?:

fn main() {
    let mut i: int = 0;
    foo(mut i);
    println!("{}", i);
}
fn foo(i: &mut int) {
    bar(mut i);
}
fn bar(i: &mut int) {
    i = i + 1;
}



On Tue, Dec 24, 2013 at 6:10 PM, comex <comexk at gmail.com> wrote:

> On Tue, Dec 24, 2013 at 8:17 PM, Vadim <vadimcn at gmail.com> wrote:
> > I'm again pretty nervous about this, because this is one of the
> > much-maligned features of C++ references.
> >
> >
> > Why is it maligned, though?
>
> I malign it mainly because it allows (and encourages) confusing code
> that looks like it's calling a function with a variable as an argument
> but actually mutates the variable.  Arguably, only auto-borrowing
> immutably would sidestep this issue.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/4cd409df/attachment.html>

From kevin at sb.org  Wed Dec 25 15:11:01 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 25 Dec 2013 18:11:01 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
Message-ID: <93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>

On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:

> I agree that unexpected mutation is undesirable, but:
> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
> - as currently implemented, Rust does not always require mut when callee mutates the argument, for example:
> 
> fn main() {
>     let mut i: int = 0;
>     foo(&mut i);
>     println!("{}", i);
> }
> fn foo(i: &mut int) {
>     bar(i); // no mut!
> }
> fn bar(i: &mut int) {
>     *i = *i + 1;
> }
> 
> Note that invocation of bar() inside foo() does not forewarn reader by requiring 'mut'.  Wouldn't you rather see this?:
> 
> fn main() {
>     let mut i: int = 0;
>     foo(mut i);
>     println!("{}", i);
> }
> fn foo(i: &mut int) {
>     bar(mut i);
> }
> fn bar(i: &mut int) {
>     i = i + 1;
> }

What is the point of adding `mut` here? bar() does not need `mut` because calling bar(i) does not auto-borrow i. It?s already a `&mut int`.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131225/f3319cc8/attachment.html>

From james at mansionfamily.plus.com  Thu Dec 26 00:57:50 2013
From: james at mansionfamily.plus.com (james)
Date: Thu, 26 Dec 2013 08:57:50 +0000
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <-63432512819739274@unknownmsgid>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BAAFFE.7020006@mansionfamily.plus.com>
	<CAHOTMVJQroisF9Rvdbyj8fWBeDOCOLHoeKGHxrrndVcBKZJ9ag@mail.gmail.com>
	<52BB2D21.6000303@mansionfamily.plus.com>
	<-63432512819739274@unknownmsgid>
Message-ID: <52BBEF8E.7070102@mansionfamily.plus.com>

On 25/12/2013 19:40, Tony Arcieri wrote:
>> >On Dec 25, 2013, at 12:08 PM, james<james at mansionfamily.plus.com>  wrote:
>> >Really?  It just decides to start messaging for no reason and blows up, after no external stimulus?  Not even a timer?
> Well, if that's what you meant, then your point is valid but a bit
> silly, because useful systems will generally have non-message events
>
> --
> Tony Arcieri
Well, I thought that was the point I was making, along with a suggestion 
that you
can normally estimate the messaging load that will result from them.  Of 
course an
event that is 'runAllRisksOnAllDeals' suffers a combinatorial behaviour, 
but if you
just instantiate every task immediately with no bounds on the concurrent 
load,
you are asking for trouble whether it manifests as a livelock or 
resource exhaustion.

Personally I think that if you must have bounded queues then at least:
  - allow rather large bounds
  - allow inspection of 'indicative' size
  - allow multi-item put and get (and ideally peak)

Having very small bounds will just cause thread switching and everything 
will
be slow - the alternative would seem to be that a shared data structure 
gets used
and the channel is used for 'wakeup' signalling only.  Its quite usable 
but to me it
looks like the provided facility was inadequate.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131226/e55c63ad/attachment.html>

From comexk at gmail.com  Thu Dec 26 11:10:19 2013
From: comexk at gmail.com (comex)
Date: Thu, 26 Dec 2013 20:10:19 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
Message-ID: <CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>

On Wed, Dec 25, 2013 at 4:23 AM, Daniel Micay <danielmicay at gmail.com> wrote:
> It makes sense to allocate it up-front for some lock-free queues but
> not a classical one built on a mutex and two condition variables. I
> doubt that a lock-free algorithm with have any significant wins
> against a Linux mutex or Windows critical section, and on Haswell lock
> elision erases the theoretical benefits too.

I'm skeptical of the claim that a lock-free algorithm would not have
any significant benefits.  Do you have a citation?

From carter.schonwald at gmail.com  Thu Dec 26 11:23:22 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 26 Dec 2013 14:23:22 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
Message-ID: <CAHYVw0zhXm43Z+0U9YNj+=bCJR==HN7faCSd2_q1qWib=gYACQ@mail.gmail.com>

I'd be interested too. A good lock-free wait-free data structure is a
powerful abstraction in terms of the programmer's quality of life.

Likewise, afaik, hardware lock Ellision is only a real win in the no / low
contention case.  You still need to provide a code path to fall back on if
there's any contention.

On Thursday, December 26, 2013, comex wrote:

> On Wed, Dec 25, 2013 at 4:23 AM, Daniel Micay <danielmicay at gmail.com<javascript:;>>
> wrote:
> > It makes sense to allocate it up-front for some lock-free queues but
> > not a classical one built on a mutex and two condition variables. I
> > doubt that a lock-free algorithm with have any significant wins
> > against a Linux mutex or Windows critical section, and on Haswell lock
> > elision erases the theoretical benefits too.
>
> I'm skeptical of the claim that a lock-free algorithm would not have
> any significant benefits.  Do you have a citation?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131226/a84a3dc6/attachment.html>

From danielmicay at gmail.com  Thu Dec 26 11:48:05 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 26 Dec 2013 14:48:05 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
Message-ID: <CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>

On Thu, Dec 26, 2013 at 2:10 PM, comex <comexk at gmail.com> wrote:
> On Wed, Dec 25, 2013 at 4:23 AM, Daniel Micay <danielmicay at gmail.com> wrote:
>> It makes sense to allocate it up-front for some lock-free queues but
>> not a classical one built on a mutex and two condition variables. I
>> doubt that a lock-free algorithm with have any significant wins
>> against a Linux mutex or Windows critical section, and on Haswell lock
>> elision erases the theoretical benefits too.
>
> I'm skeptical of the claim that a lock-free algorithm would not have
> any significant benefits.  Do you have a citation?

Acquiring and releasing a mutex when there's low contention takes two
atomic operations. Switching to a linked data structure adds far more
overhead than an extra atomic operation.

Intel Thread Building Blocks makes exclusive use of locking for both
the non-blocking and blocking concurrent queues because it performs as
well as lock-free implementations without losing priority-aware
multiple-producer/multiple-consumer support.

A simple array-backed circular buffer has a tiny lock scope, so it
won't ever have high contention. In a less simple case, a mutex will
spin for a bit before falling back to a `futex` system call.

From danielmicay at gmail.com  Thu Dec 26 11:53:28 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 26 Dec 2013 14:53:28 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0zhXm43Z+0U9YNj+=bCJR==HN7faCSd2_q1qWib=gYACQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CAHYVw0zhXm43Z+0U9YNj+=bCJR==HN7faCSd2_q1qWib=gYACQ@mail.gmail.com>
Message-ID: <CA+DvKQKQeddD_vhBiKgPPk_2x--fk9z_qOROb7UaCXj=oD7mjQ@mail.gmail.com>

On Thu, Dec 26, 2013 at 2:23 PM, Carter Schonwald
<carter.schonwald at gmail.com> wrote:
> I'd be interested too. A good lock-free wait-free data structure is a
> powerful abstraction in terms of the programmer's quality of life.
>
> Likewise, afaik, hardware lock Ellision is only a real win in the no / low
> contention case.  You still need to provide a code path to fall back on if
> there's any contention.

Hardware transactional memory has a fallback case for when it fails to
commit the transaction. Lock elision is a separate feature providing a
subset of the functionality. It allows for speculative execution in
the presence of locks by avoiding the cache synchronization the
`cmpxchg` operation would cause if the work inside the lock scopes
doesn't conflict.

From comexk at gmail.com  Thu Dec 26 13:19:18 2013
From: comexk at gmail.com (comex)
Date: Thu, 26 Dec 2013 22:19:18 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
Message-ID: <CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>

On Thu, Dec 26, 2013 at 8:48 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> Acquiring and releasing a mutex when there's low contention takes two
> atomic operations. Switching to a linked data structure adds far more
> overhead than an extra atomic operation.
> [...]
> A simple array-backed circular buffer has a tiny lock scope, so it
> won't ever have high contention. In a less simple case, a mutex will
> spin for a bit before falling back to a `futex` system call.

Fair enough, but why do you assume a lock-free queue is a linked data
structure?  A simple (bounded) array-backed circular buffer can be
lock-free too and then there are zero atomic operations.

From danielmicay at gmail.com  Thu Dec 26 13:32:36 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 26 Dec 2013 16:32:36 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
Message-ID: <CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>

On Thu, Dec 26, 2013 at 4:19 PM, comex <comexk at gmail.com> wrote:
> On Thu, Dec 26, 2013 at 8:48 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>> Acquiring and releasing a mutex when there's low contention takes two
>> atomic operations. Switching to a linked data structure adds far more
>> overhead than an extra atomic operation.
>> [...]
>> A simple array-backed circular buffer has a tiny lock scope, so it
>> won't ever have high contention. In a less simple case, a mutex will
>> spin for a bit before falling back to a `futex` system call.
>
> Fair enough, but why do you assume a lock-free queue is a linked data
> structure?  A simple (bounded) array-backed circular buffer can be
> lock-free too and then there are zero atomic operations.

Lock-free data structures use atomic operations... you're doing at
least one atomic operation or you won't have consistency between
threads. An atomic operation will result in cache synchronization and
stall the CPU pipeline. On an architecture with a weaker memory model
(not x86), it might not have to stall the pipeline as much if you use
a weaker ordering.

From danielmicay at gmail.com  Thu Dec 26 13:57:10 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 26 Dec 2013 16:57:10 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
Message-ID: <CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>

On Thu, Dec 26, 2013 at 4:32 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Thu, Dec 26, 2013 at 4:19 PM, comex <comexk at gmail.com> wrote:
>> On Thu, Dec 26, 2013 at 8:48 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>>> Acquiring and releasing a mutex when there's low contention takes two
>>> atomic operations. Switching to a linked data structure adds far more
>>> overhead than an extra atomic operation.
>>> [...]
>>> A simple array-backed circular buffer has a tiny lock scope, so it
>>> won't ever have high contention. In a less simple case, a mutex will
>>> spin for a bit before falling back to a `futex` system call.
>>
>> Fair enough, but why do you assume a lock-free queue is a linked data
>> structure?  A simple (bounded) array-backed circular buffer can be
>> lock-free too and then there are zero atomic operations.
>
> Lock-free data structures use atomic operations... you're doing at
> least one atomic operation or you won't have consistency between
> threads. An atomic operation will result in cache synchronization and
> stall the CPU pipeline. On an architecture with a weaker memory model
> (not x86), it might not have to stall the pipeline as much if you use
> a weaker ordering.

Anyway, I think there's a misunderstanding in this thread of what
locking is. A blocking queue is by definition not lock-free/wait-free,
since the wait is known as a lock. It can be done via a spin lock, a
system call like `futex` or the mix used by Linux mutexes but it's a
lock by any other name.

From carter.schonwald at gmail.com  Thu Dec 26 14:29:20 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 26 Dec 2013 17:29:20 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
Message-ID: <CAHYVw0w4kQGkmSfem0xWXM_p3uzie_t0jqr5E223OxMZx_FtpA@mail.gmail.com>

Exactly.  Hence my suggestion :-). Non blocking explicit failure plus
(optionally adjustable) boundedness.

I believe some folks recently hacked out a nonblocking queue for rust a
month or so ago in the context of work stealing right?

On Thursday, December 26, 2013, Daniel Micay wrote:

> On Thu, Dec 26, 2013 at 4:32 PM, Daniel Micay <danielmicay at gmail.com<javascript:;>>
> wrote:
> > On Thu, Dec 26, 2013 at 4:19 PM, comex <comexk at gmail.com <javascript:;>>
> wrote:
> >> On Thu, Dec 26, 2013 at 8:48 PM, Daniel Micay <danielmicay at gmail.com<javascript:;>>
> wrote:
> >>> Acquiring and releasing a mutex when there's low contention takes two
> >>> atomic operations. Switching to a linked data structure adds far more
> >>> overhead than an extra atomic operation.
> >>> [...]
> >>> A simple array-backed circular buffer has a tiny lock scope, so it
> >>> won't ever have high contention. In a less simple case, a mutex will
> >>> spin for a bit before falling back to a `futex` system call.
> >>
> >> Fair enough, but why do you assume a lock-free queue is a linked data
> >> structure?  A simple (bounded) array-backed circular buffer can be
> >> lock-free too and then there are zero atomic operations.
> >
> > Lock-free data structures use atomic operations... you're doing at
> > least one atomic operation or you won't have consistency between
> > threads. An atomic operation will result in cache synchronization and
> > stall the CPU pipeline. On an architecture with a weaker memory model
> > (not x86), it might not have to stall the pipeline as much if you use
> > a weaker ordering.
>
> Anyway, I think there's a misunderstanding in this thread of what
> locking is. A blocking queue is by definition not lock-free/wait-free,
> since the wait is known as a lock. It can be done via a spin lock, a
> system call like `futex` or the mix used by Linux mutexes but it's a
> lock by any other name.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131226/5c6ee3ab/attachment.html>

From bascule at gmail.com  Thu Dec 26 14:36:40 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 26 Dec 2013 15:36:40 -0700
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
Message-ID: <CAHOTMV+hGrCnd_Tw_vtQH1-z0N2y6b-P08ObhTi=xFQkX9cwig@mail.gmail.com>

On Thursday, December 26, 2013, Daniel Micay wrote:

> A blocking queue is by definition not lock-free/wait-free,
> since the wait is known as a lock. It can be done via a spin lock, a
> system call like `futex` or the mix used by Linux mutexes but it's a
> lock by any other name.
>

There are also sleeping waits with a context switch, which in an M:N setup
can occur within the same scheduler thread.


-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131226/e1d7c1e5/attachment.html>

From ncm at cantrip.org  Thu Dec 26 17:29:51 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Thu, 26 Dec 2013 17:29:51 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
Message-ID: <52BCD80F.2000806@cantrip.org>

It's clear that you can have any sort of channel, or all
possible combinations, and end up with a language usable for
typical problems. Any single primitive works to build all the
rest.  So, this isn't a question of whether users are allowed
to code the way they want to. It comes down to a question of
what and who Rust is for.

A systems language meant to implement rigorously specified
designs needs to be as rigorously specified itself -- a huge job,
at best.  For that, it needs a primitive with behavior that can
be completely and precisely expressed for all runtime conditions.
Anything else that can be built using the primitive can go in
libraries that a rigorous design need not depend on.

If performance matters, then the primitive chosen should impose
no overhead for features not needed in the simplest, fastest
use case.  It's easy to add features and overhead.  It's not
just good luck that the primitives that are simplest to specify
usually are also fastest.

Nathan Myers

From palmercox at gmail.com  Thu Dec 26 22:50:59 2013
From: palmercox at gmail.com (Palmer Cox)
Date: Fri, 27 Dec 2013 01:50:59 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendwWU2e9H8+oDOEvJGWN6=H1vLFhePkTWszwnWmEe5SCCA@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
	<CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
	<CANbMr6E9cE3n+T6DMZ0EHaUG89esNiLCyzK3LEA8tVjXXs3rPA@mail.gmail.com>
	<CAPZendwWU2e9H8+oDOEvJGWN6=H1vLFhePkTWszwnWmEe5SCCA@mail.gmail.com>
Message-ID: <CAPZendwdYOYyfTu-fQbKxbkX5gYUannU4iRm_W5-PY7+XYTj_A@mail.gmail.com>

So,

The rules that I tried to concoct don't really work. I don't know what to
do with something like BitvIterator. Rename it to BitvElements? Anyway, I'm
thinking of amending my pull request to just rename the *Iter structs to
*Iterator and leave the rest alone.

Thoughts?

I pulled together what I believe is the full list of iterators in Rust as
of f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9. If someone has a better
suggestion of how to unify their naming, I'm happy to do it.

+------------------------------------------+---------------------------+
| File                                     | Name                      |
+------------------------------------------+---------------------------+
| src/libextra/bitv.rs                     | BitvIterator              |
+------------------------------------------+---------------------------+
| src/libextra/bitv.rs                     | BitvSetIterator           |
+------------------------------------------+---------------------------+
| src/libextra/dlist.rs                    | DListIterator             |
+------------------------------------------+---------------------------+
| src/libextra/dlist.rs                    | MutDListIterator          |
+------------------------------------------+---------------------------+
| src/libextra/dlist.rs                    | MoveIterator              |
+------------------------------------------+---------------------------+
| src/libextra/enum_set.rs                 | EnumSetIterator           |
+------------------------------------------+---------------------------+
| src/libextra/glob.rs                     | GlobIterator              |
+------------------------------------------+---------------------------+
| src/libextra/priority_queue.rs           | PriorityQueueIterator     |
+------------------------------------------+---------------------------+
| src/libextra/ringbuf.rs                  | RingBufIterator           |
+------------------------------------------+---------------------------+
| src/libextra/ringbuf.rs                  | RingBufMutIterator        |
+------------------------------------------+---------------------------+
| src/libextra/smallintmap.rs              | SmallIntMapIterator       |
+------------------------------------------+---------------------------+
| src/libextra/smallintmap.rs              | SmallIntMapMutIterator    |
+------------------------------------------+---------------------------+
| src/libextra/smallintmap.rs              | SmallIntMapRevIterator    |
+------------------------------------------+---------------------------+
| src/libextra/smallintmap.rs              | SmallIntMapMutRevIterator |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | TreeMapIterator           |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | TreeMapRevIterator        |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | TreeMapMoveIterator       |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | TreeSetIterator           |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | TreeSetRevIterator        |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | Difference                |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | SymDifference             |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | Intersection              |
+------------------------------------------+---------------------------+
| src/libextra/treemap.rs                  | Union                     |
+------------------------------------------+---------------------------+
| src/librustc/middle/trans/basic_block.rs | PredIterator              |
+------------------------------------------+---------------------------+
| src/librustc/middle/trans/value.rs       | UserIterator              |
+------------------------------------------+---------------------------+
| src/librustpkg/package_id.rs             | Prefixes                  |
+------------------------------------------+---------------------------+
| src/libstd/c_str.rs                      | CStringIterator           |
+------------------------------------------+---------------------------+
| src/libstd/comm/mod.rs                   | PortIterator              |
+------------------------------------------+---------------------------+
| src/libstd/comm/select.rs                | PacketIterator            |
+------------------------------------------+---------------------------+
| src/libstd/either.rs                     | Lefts                     |
+------------------------------------------+---------------------------+
| src/libstd/either.rs                     | Rights                    |
+------------------------------------------+---------------------------+
| src/libstd/fmt/parse.rs                  | Parser                    |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | HashMapIterator           |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | HashMapMutIterator        |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | HashMapMoveIterator       |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | HashSetIterator           |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | HashSetMoveIterator       |
+------------------------------------------+---------------------------+
| src/libstd/hashmap.rs                    | SetAlgebraIter            |
+------------------------------------------+---------------------------+
| src/libstd/io/extensions.rs              | ByteIterator              |
+------------------------------------------+---------------------------+
| src/libstd/io/fs.rs                      | WalkIterator              |
+------------------------------------------+---------------------------+
| src/libstd/io/mod.rs                     | LineIterator              |
+------------------------------------------+---------------------------+
| src/libstd/io/mod.rs                     | IncomingIterator          |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Invert                    |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | ByRef                     |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Cycle                     |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Chain                     |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Zip                       |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Map                       |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Filter                    |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | FilterMap                 |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Enumerate                 |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Peekable                  |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | SkipWhile                 |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | TakeWhile                 |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Skip                      |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Take                      |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Scan                      |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | FlatMap                   |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Fuse                      |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Inspect                   |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Unfold                    |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Counter                   |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Range                     |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | RangeInclusive            |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | RangeStep                 |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | RangeStepInclusive        |
+------------------------------------------+---------------------------+
| src/libstd/iter.rs                       | Repeat                    |
+------------------------------------------+---------------------------+
| src/libstd/option.rs                     | OptionIterator            |
+------------------------------------------+---------------------------+
| src/libstd/path/posix.rs                 | ComponentIter             |
+------------------------------------------+---------------------------+
| src/libstd/path/posix.rs                 | RevComponentIter          |
+------------------------------------------+---------------------------+
| src/libstd/path/posix.rs                 | StrComponentIter          |
+------------------------------------------+---------------------------+
| src/libstd/path/posix.rs                 | RevStrComponentIter       |
+------------------------------------------+---------------------------+
| src/libstd/path/windows.rs               | StrComponentIter          |
+------------------------------------------+---------------------------+
| src/libstd/path/windows.rs               | RevStrComponentIter       |
+------------------------------------------+---------------------------+
| src/libstd/path/windows.rs               | ComponentIter             |
+------------------------------------------+---------------------------+
| src/libstd/path/windows.rs               | RevComponentIter          |
+------------------------------------------+---------------------------+
| src/libstd/rt/task.rs                    | BlockedTaskIterator       |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharIterator              |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharOffsetIterator        |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharSplitIterator         |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharSplitNIterator        |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | MatchesIndexIterator      |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | StrSplitIterator          |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | NormalizationIterator     |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharRevIterator           |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharOffsetRevIterator     |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | ByteIterator              |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | ByteRevIterator           |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | CharRSplitIterator        |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | WordIterator              |
+------------------------------------------+---------------------------+
| src/libstd/str.rs                        | AnyLineIterator           |
+------------------------------------------+---------------------------+
| src/libstd/trie.rs                       | TrieMapIterator           |
+------------------------------------------+---------------------------+
| src/libstd/trie.rs                       | TrieSetIterator           |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | SplitIterator             |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | RSplitIterator            |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | ElementSwaps              |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | Permutations              |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | WindowIter                |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | ChunkIter                 |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | VecIterator               |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | VecMutIterator            |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | MutSplitIterator          |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | MutChunkIter              |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | MoveIterator              |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | RevIterator               |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | MutRevIterator            |
+------------------------------------------+---------------------------+
| src/libstd/vec.rs                        | MoveRevIterator           |
+------------------------------------------+---------------------------+
| src/libsyntax/opt_vec.rs                 | OptVecIterator            |
+------------------------------------------+---------------------------+
| src/libsyntax/util/small_vector.rs       | SmallVectorMoveIterator   |
+------------------------------------------+---------------------------+

Thanks,
-Palmer Cox



On Sat, Dec 21, 2013 at 11:35 PM, Palmer Cox <palmercox at gmail.com> wrote:

> Due to type inference, my assumption is that in many cases the only people
> that see the actual type names are the developers creating them and people
> reading the docs. I hadn't though about the Reader / Port cases, but those
> do seem like pretty reasonable places where you might want to have an
> object implement Iterator in addition to other traits.
>
> So, if the decision is no suffixes, what do we do with all of the existing
> Iterators that have suffixes? Strip them? Maybe the rule of thumb should
> look something like this:
>
> 1. If you are implementing a struct that only implements the Iterator
> trait, make the name plural, but don't use the Iterator suffix. eg: Chunks
> 2. If you are implementing a struct that implements traits in addition to
> Iterator, there is no need to make it plural. eg: Port / Reader
>
> If that's the general rule of thumb, then SplitIterator becomes Splits and
> MutChunkIter becomes MutChunks. I guess that means that DoubleEndedIterator
> also becomes just DoubledEnded. That seems reasonable to me, since it fits
> it better with the ExactSize trait also defined in the iter module. That
> doesn't really directly solve my issue with Map from the iter module being
> confusing. If its referenced as iter::Map, its not confusing of course, but
> at least some of the current code doesn't do that and there isn't any way
> to force future code to do so. Its probably not a huge deal, though.
>
> Does that sound like the general opinion?
>
> -Palmer Cox
>
>
>
>
>
> On Sat, Dec 21, 2013 at 8:43 PM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> I prefer the 'no suffix' option and generally agree with Alex.
>> Iterators aren't special and their iterator behavior is already denoted
>> by implementing the Iterator trait.
>>
>> Frankly, aside from documentation where it is clear that something is an
>> iterator, I'm not sure when a user would even see concrete iterator types.
>> I can't think of a reason why you'd ever want to restrict the type of a
>> variable to a specific kind of iterator (i.e. Map or Union).
>>
>> Acceptor and Port could implement Iterator directly, but currently they
>> create a struct containing only a mutable borrow of themselves to prevent
>> anything else from using the socket/channel in the meantime.
>> Reader could directly implement an Iterator that does one byte reads, but
>> currently it does the same trick as Acceptor and Port.
>> You only need a separate Iterator object if you actually require
>> additional state or if you want to prevent others from changing the
>> underlying source (mutable borrow of self).
>>
>>
>>
>> On Sat, Dec 21, 2013 at 4:35 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>
>>> Rust's standard libs are still pretty thin on their trait hierarchies,
>>> but I'm sure this will change.
>>>
>>> Kevin
>>>
>>> On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com> wrote:
>>> > Are there examples of structs that implement Iterator that also
>>> implement
>>> > other non-Iterator related traits? Although its possible to do that, I
>>> can't
>>> > think of a use case for it off the top of my head. An Iterator
>>> basically
>>> > represents the state of an ongoing computation and once that
>>> computation is
>>> > completed, the object is mostly uselss. It seems like it would be
>>> awkward to
>>> > implement other traits for such an object. Maybe I'm not thinking of
>>> > something, however.
>>> >
>>> > -Palmer Cox
>>> >
>>> >
>>> >
>>> > On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org>
>>> wrote:
>>> >>
>>> >> Iterators are just structs which implement the "Iterator" or a related
>>> >> trait, right?
>>> >>
>>> >> These structs which do can also implement lots of other traits, too:
>>> >> no reason to make -Iter special.
>>> >>
>>> >>
>>> >> Kevin
>>> >>
>>> >>
>>> >>
>>> >> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com>
>>> wrote:
>>> >> > I'm not a big fan of Hungarian notation either. I'm not sure that
>>> having
>>> >> > a
>>> >> > naming convention for Iterators is Hungarian notation, however. For
>>> >> > example,
>>> >> > if you are doing Windows programming, you'll see stuff like:
>>> >> >
>>> >> > DWORD dwFoo = 0;
>>> >> >
>>> >> > In this case, the "dw" prefix on the variable indicates that we
>>> have a
>>> >> > DWORD
>>> >> > variable. However, the Iterator suffix that I'm proposing here is a
>>> >> > suffix
>>> >> > on the type names, not the actual variable names. So, if you are
>>> writing
>>> >> > Rust code, you'd write something like this:
>>> >> >
>>> >> > let chunks = some_vector.chunks(50);
>>> >> >
>>> >> > So, the actual variable name doesn't have the Hungarian notation
>>> and the
>>> >> > types aren't even generally visible since the compiler infers much
>>> of
>>> >> > that.
>>> >> > However, someone reading through the documentation and/or code will
>>> see
>>> >> > a
>>> >> > struct named ChunkIterator and instance know how the struct behaves
>>> - as
>>> >> > an
>>> >> > Iterator. So, I think the suffix serves less to describe the
>>> datatype
>>> >> > and
>>> >> > more to describe class of behavior that the struct implements.
>>> >> >
>>> >> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
>>> >> > programming so I'm probably much more used to verbosity than
>>> others. I'm
>>> >> > not
>>> >> > horribly against some sort of other naming convention, either, of
>>> >> > course,
>>> >> > but I would like to see some consistency.
>>> >> >
>>> >> > My main motivation for opening the request was because I created
>>> >> > MutChunkIter and then realized that it was named differently than
>>> >> > majority
>>> >> > of other Iterators. I don't want to be responsible for someone
>>> reading
>>> >> > through the docs and seeing something thats inconsistent for no good
>>> >> > reason!
>>> >> > Also, I was reading through some code and happened upon a "Map" and
>>> was
>>> >> > exceptionally confused about it, until I realized it was iter::Map
>>> as
>>> >> > opposed to container::Map. I figured I probably wasn't the only
>>> person
>>> >> > that
>>> >> > was going to be confused by something like this.
>>> >> >
>>> >> > -Palmer Cox
>>> >> >
>>> >> >
>>> >> >
>>> >> >
>>> >> >
>>> >> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org>
>>> wrote:
>>> >> >>
>>> >> >> IMHO Hungarian notation is for things the type system and tooling
>>> >> >> cannot deal with.  I'm not sure this is one of them...
>>> >> >>
>>> >> >>
>>> >> >> Kevin
>>> >> >
>>> >> >
>>> >
>>> >
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131227/14c01277/attachment-0001.html>

From bascule at gmail.com  Fri Dec 27 13:29:15 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 27 Dec 2013 14:29:15 -0700
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BCD80F.2000806@cantrip.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
Message-ID: <CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>

On Thu, Dec 26, 2013 at 6:29 PM, Nathan Myers <ncm at cantrip.org> wrote:

> A systems language meant to implement rigorously specified
> designs needs to be as rigorously specified itself -- a huge job,
> at best.  For that, it needs a primitive with behavior that can
> be completely and precisely expressed for all runtime conditions.


This is an excellent point, thank you!

So here's a big question: if Rust tasks and channels were the underpinnings
of an operating system kernel, would unbounded channels be suitable or not?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131227/e9a5504f/attachment.html>

From danielmicay at gmail.com  Fri Dec 27 13:34:33 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 27 Dec 2013 16:34:33 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
Message-ID: <CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>

On Fri, Dec 27, 2013 at 4:29 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Thu, Dec 26, 2013 at 6:29 PM, Nathan Myers <ncm at cantrip.org> wrote:
>>
>> A systems language meant to implement rigorously specified
>> designs needs to be as rigorously specified itself -- a huge job,
>> at best.  For that, it needs a primitive with behavior that can
>> be completely and precisely expressed for all runtime conditions.
>
>
> This is an excellent point, thank you!
>
> So here's a big question: if Rust tasks and channels were the underpinnings
> of an operating system kernel, would unbounded channels be suitable or not?
>
> --
> Tony Arcieri

Rust tasks and channels don't work in a freestanding environment.
Unbounded allocation is *definitely* not suitable for a kernel
though... even a large bounded channel would be unsuitable. The world
of small stacks and interrupts is quite different than what the
standard library is written for.

From pcwalton at mozilla.com  Fri Dec 27 13:35:41 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 27 Dec 2013 13:35:41 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
Message-ID: <52BDF2AD.9070605@mozilla.com>

On 12/27/13 1:34 PM, Daniel Micay wrote:
> On Fri, Dec 27, 2013 at 4:29 PM, Tony Arcieri <bascule at gmail.com> wrote:
>> On Thu, Dec 26, 2013 at 6:29 PM, Nathan Myers <ncm at cantrip.org> wrote:
>>>
>>> A systems language meant to implement rigorously specified
>>> designs needs to be as rigorously specified itself -- a huge job,
>>> at best.  For that, it needs a primitive with behavior that can
>>> be completely and precisely expressed for all runtime conditions.
>>
>>
>> This is an excellent point, thank you!
>>
>> So here's a big question: if Rust tasks and channels were the underpinnings
>> of an operating system kernel, would unbounded channels be suitable or not?
>>
>> --
>> Tony Arcieri
>
> Rust tasks and channels don't work in a freestanding environment.
> Unbounded allocation is *definitely* not suitable for a kernel
> though... even a large bounded channel would be unsuitable. The world
> of small stacks and interrupts is quite different than what the
> standard library is written for.

I think the standard library should get there over time though.

Patrick


From vadimcn at gmail.com  Fri Dec 27 13:59:54 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 27 Dec 2013 13:59:54 -0800
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
Message-ID: <CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>

For the same reason we currently have to say `&mut i` in main() - to
explicitly acknowledge that the callee may mutate i.  By the same logic,
this should be done everywhere.


On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>
> I agree that unexpected mutation is undesirable, but:
> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
> - as currently implemented, Rust does not always require mut when callee
> mutates the argument, for example:
>
> fn main() {
>     let mut i: int = 0;
>     foo(&mut i);
>     println!("{}", i);
> }
> fn foo(i: &mut int) {
>     bar(i); // no mut!
> }
> fn bar(i: &mut int) {
>     *i = *i + 1;
> }
>
> Note that invocation of bar() inside foo() does not forewarn reader by
> requiring 'mut'.  Wouldn't you rather see this?:
>
> fn main() {
>     let mut i: int = 0;
>     foo(mut i);
>     println!("{}", i);
> }
> fn foo(i: &mut int) {
>     bar(mut i);
> }
> fn bar(i: &mut int) {
>     i = i + 1;
> }
>
>
> What is the point of adding `mut` here? bar() does not need `mut` because
> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>
> -Kevin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131227/17b109ba/attachment.html>

From ncm at cantrip.org  Fri Dec 27 19:10:19 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Fri, 27 Dec 2013 19:10:19 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BDF2AD.9070605@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com>
Message-ID: <52BE411B.3040100@cantrip.org>

On 12/27/2013 01:35 PM, Patrick Walton wrote:
> On 12/27/13 1:34 PM, Daniel Micay wrote:
>> Rust tasks and channels don't work in a freestanding environment.
>> Unbounded allocation is *definitely* not suitable for a kernel
>> though... even a large bounded channel would be unsuitable. The world
>> of small stacks and interrupts is quite different than what the
>> standard library is written for.
>
> I think the standard library should get there over time though.

Possibly the best measure of a language's power is how well it enables
writing generally useful libraries.  How much of the standard library
older languages would have had to build in is an objective measure of
success.  While important parts of the runtime will be re-implemented
for a kernel setting, kernel coders will need many of the powerful
standard-library features.

This argues for including those standard-library features that mean
the same everywhere in the "freestanding" language definition. In
kernel code, tasks and channels might be created differently, but
used identically.

Nathan Myers

From danielmicay at gmail.com  Fri Dec 27 20:18:23 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 27 Dec 2013 23:18:23 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BE411B.3040100@cantrip.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
Message-ID: <CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>

On Fri, Dec 27, 2013 at 10:10 PM, Nathan Myers <ncm at cantrip.org> wrote:
> On 12/27/2013 01:35 PM, Patrick Walton wrote:
>>
>> On 12/27/13 1:34 PM, Daniel Micay wrote:
>>>
>>> Rust tasks and channels don't work in a freestanding environment.
>>> Unbounded allocation is *definitely* not suitable for a kernel
>>> though... even a large bounded channel would be unsuitable. The world
>>> of small stacks and interrupts is quite different than what the
>>> standard library is written for.
>>
>>
>> I think the standard library should get there over time though.
>
>
> Possibly the best measure of a language's power is how well it enables
> writing generally useful libraries.  How much of the standard library
> older languages would have had to build in is an objective measure of
> success.  While important parts of the runtime will be re-implemented
> for a kernel setting, kernel coders will need many of the powerful
> standard-library features.

Most of the standard library isn't appropriate for a kernel. The
support for concurrency (threads/tasks, mutexes, condition variables,
blocking channels), floating point math, input/output, failure,
multi-processing, logging and garbage collection isn't going to work.
The containers in the standard library are quite inappropriate for
most kernels since they're based on eagerly allocated vectors prone to
fragmenting memory. It also has no support for anything but a
hard-wired global allocator based on the malloc/free API...

Iterators, atomics, Option and low-level memory/pointer functions are
useful, but it's also trivial to re-implement and the standard library
doesn't do it particularly well in the first place.

> This argues for including those standard-library features that mean
> the same everywhere in the "freestanding" language definition. In
> kernel code, tasks and channels might be created differently, but
> used identically.

I don't think the same concurrency concepts will be appropriate in a
kernel. Interrupts are a different world than blocking on system calls
and you have to be really careful about interactions with userspace
code.

From pcwalton at mozilla.com  Fri Dec 27 21:09:42 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 27 Dec 2013 21:09:42 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>
	<52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
Message-ID: <52BE5D16.40100@mozilla.com>

On 12/27/13 8:18 PM, Daniel Micay wrote:
> Most of the standard library isn't appropriate for a kernel. The
> support for concurrency (threads/tasks, mutexes, condition variables,
> blocking channels), floating point math, input/output, failure,
> multi-processing, logging and garbage collection isn't going to work.

I'd like to make that stuff either moved out into a separate library or 
discardable.

> The containers in the standard library are quite inappropriate for
> most kernels since they're based on eagerly allocated vectors prone to
> fragmenting memory. It also has no support for anything but a
> hard-wired global allocator based on the malloc/free API...

This isn't always a problem. Check out Apple's `OSDictionary`, for 
example, which is designed for use in kernel space and has the same 
restrictions:

http://www.opensource.apple.com/source/xnu/xnu-792.13.8/libkern/c++/OSDictionary.cpp

https://developer.apple.com/librarY/mac/documentation/Kernel/Reference/OSDictionary_reference/translated_content/OSDictionary.html

(It's even reference counted with RTTI and COM-like system! In kernel 
space!)

But, in any case, I see no reason why we can't have allocator support in 
`libstd`'s containers. Hiding the extra allocator type parameter can be 
done with a typedef and some compiler/language work to make that 
palatable. There should be an absolute minimum number of containers in 
`libstd` in the first place, so I don't see the implementation burden as 
insurmountably high.

> Iterators, atomics, Option and low-level memory/pointer functions are
> useful, but it's also trivial to re-implement and the standard library
> doesn't do it particularly well in the first place.

Then let's get bugs on file and fix them upstream in libstd. 
Inefficiency in userspace is just as bad as inefficiency in kernel space.

> I don't think the same concurrency concepts will be appropriate in a
> kernel. Interrupts are a different world than blocking on system calls
> and you have to be really careful about interactions with userspace
> code.

I share some skepticism about the usability of tasking in kernel space 
for high-performance kernels. However, some embedded apps that run in 
ring 0 for efficiency/simplicity reasons (e.g. console games) may still 
want a task system.

Patrick


From ncm at cantrip.org  Fri Dec 27 23:17:11 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Fri, 27 Dec 2013 23:17:11 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BE5D16.40100@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>
	<52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.co m>
Message-ID: <52BE7AF7.3050306@cantrip.org>

On 12/27/2013 09:09 PM, Patrick Walton wrote:
> On 12/27/13 8:18 PM, Daniel Micay wrote:
>> Most of the standard library isn't appropriate for a kernel. The
>> support for concurrency (threads/tasks, mutexes, condition variables,
>> blocking channels), floating point math, input/output, failure,
>> multi-processing, logging and garbage collection isn't going to work.
>
> I'd like to make that stuff either moved out into a separate library or
> discardable.

I think we really are close to agreement on the above.

Tasks remain useful as a unit of resource management, independently
of threads or concurrency.  Kernel i/o differs, but int->ASCII is
the same as in user space.  Logging in kernels is often the only
way to locate bugs, and it differs in initialization, but not in
usage.  Memory management in the Linux kernel uses different allocation
methods, but makes very heavy use of (manual!) reference-counted
garbage collection.

Partitioning between core-language and supplementary libraries by
general category would be a mistake.  Usually the apparatus that
enforces usage conventions should be in the core, for interoperability,
but embodiments of the conventions (e.g. specific data structures,
spawn() methods, allocators) not.

>> Iterators, atomics, Option and low-level memory/pointer functions are
>> useful, but it's also trivial to re-implement and the standard library
>> doesn't do it particularly well in the first place.
>
> Then let's get bugs on file and fix them upstream in libstd.
> Inefficiency in userspace is just as bad as inefficiency in kernel space.

They are trivial to implement given a design, but a good design is
arrived at only through long and difficult evolution.  That makes it
especially worth exposing in the core library, and making user space
analogs match.

Nathan Myers

From kevin at sb.org  Sat Dec 28 10:03:47 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 28 Dec 2013 13:03:47 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
Message-ID: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>

We have to say `&mut i` in main() because `&i` is non-mutable. We?re explicitly taking a mutable borrow.

But once it?s in foo(), it?s already mutable. The type `&mut int` carries its mutability with it. Having to say `mut` again makes no sense and is nothing but pure noise.

-Kevin

On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:

> For the same reason we currently have to say `&mut i` in main() - to explicitly acknowledge that the callee may mutate i.  By the same logic, this should be done everywhere.
> 
> 
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
> 
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>> - as currently implemented, Rust does not always require mut when callee mutates the argument, for example:
>> 
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>> 
>> Note that invocation of bar() inside foo() does not forewarn reader by requiring 'mut'.  Wouldn't you rather see this?:
>> 
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
> 
> What is the point of adding `mut` here? bar() does not need `mut` because calling bar(i) does not auto-borrow i. It?s already a `&mut int`.
> 
> -Kevin
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/eb1150ed/attachment.html>

From alex at crichton.co  Sat Dec 28 10:37:25 2013
From: alex at crichton.co (Alex Crichton)
Date: Sat, 28 Dec 2013 12:37:25 -0600
Subject: [rust-dev] Using libgreen/libnative
Message-ID: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>

Greetings rusticians!

Recently pull request #10965 landed, so the rust standard library no longer has
any scheduling baked into it, but rather it's refactored out into two libraries.
This means that if you want a 1:1 program, you can jettison all M:N support with
just a few `extern mod` statements. A brief overview of the current state of
things is:

1. All programs not using std::rt directly should still continue to operate as
   usual today
2. All programs still start up in M:N mode, although this will likely change
   once 1:1 I/O work has been completed
3. There are two more libraries available, libgreen and libnative, which allow
   custom fine-grained control over how programs run.
4. Whenever a new task is spawned, it is by default spawned as a "sibling" which
   means that it is spawned in the same mode as the spawning thread. This means
   that if a green thread spawns a thread then it will also be a green thread,
   while a native thread will spawn another OS thread.

With this migration, there have been a few changes in the public APIs, and
things still aren't quite where I'd like them to be. PR #11153 is the last major
step in this process as it allows you to link to both libnative and libgreen,
yet still choose which one is used to boot your program. Some breaking changes
you may notice are:

* it's still not possible to easily start up in 1:1 mode - This is fixed by
  #11153. In the meantime, you can use #[start] with native::start in order to
  boot up in 1:1 mode. Be warned though that the majority of I/O is still
  missing from libnative (see PR #11159 for some progress)

      https://gist.github.com/8162357

* std::rt::{start, run} are gone - These are temporarily moved into green/native
  while #[boot] is getting sorted out. The green/native counterparts perform as
  you would expect.

      https://gist.github.com/8162372

* std::rt::start_on_main_thread is gone - This function has been removed with no
  direct counterpart. As a consequence of refactoring the green/native
  libraries, the "single threaded" spawn mode for a task has been removed (this
  doesn't make sense in 1:1 land). This behavior can be restored by directly
  using libnative and libgreen. You can use libgreen to spin up a pool of
  schedulers and then use libnative for the main task to do things like GUI
  management.

      https://gist.github.com/8162399

And of course with the removal of some features comes the addition of new ones!
Some new things you may notice are:

* libstd is no longer burdened with libgreen and libnative! This means that the
  compile times for libstd should be a little faster, but most notably those
  applications only using libstd will have even less code pulled in than before,
  meaning that libstd is that much closer to being used in a "bare metal"
  context. It's still aways off, but we're getting closer every day!

* libgreen has a full-fleged SchedPool type. You can see a bit of how it's used
  in gist I posted above. This type is meant to represent a dynamic pool of
  schedulers. Right now it's not possible to remove a scheduler from the pool
  (requires some more thought and possibly libuv modifications), but you can add
  new schedulers dynamically to the pool.

  This type supercedes the ThreadPool type in libextra at this point, and
  management of a SchedPool should provide any fine-grained control needed over
  the 'M' number in an M:N runtime.

* libgreen and libnative can be used directly to guarantee spawning a green or a
  native task, regardless of the flavor of task that is doing the spawning.

In the coming months, I plan on filling out more native I/O to bring it up to
speed with the M:N implementation. I also plan on rewriting the core components
of extra::comm to be performant in both scheduling modes in order to bring the
extra::{comm, arc, sync} primitives up to date with their std::comm
counterparts.

If there are any questions about any of this, feel free to ask me! This thread
is always available, and I'm also reachable as acrichto on IRC or alexcrichton
on github.

From marcianx at gmail.com  Sat Dec 28 10:53:01 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 28 Dec 2013 13:53:01 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
Message-ID: <CAEsTQVOkbrGm4Vpzs14Js8qLQVVLRaj-Lv3Eoe4=QCfJg6hC+w@mail.gmail.com>

I think I see the confusion (as I suffered from the same point of
confusion). So let me restate your answer and please correct me of I am
wrong.
1. "mut int" and "& mut int" are different types and the former doesn't
automatically convert to the latter.
2. The way to get the latter from the former is to say "&mut i" since "&i"
is defined as taking a non-mut borrow even if i is mut. (This was the point
of confusion I believe.)
3. No explicit conversion is needed within foo() since the type of i is
already "&mut int".

Ashish
 On Dec 28, 2013 1:33 PM, "Kevin Ballard" <kevin at sb.org> wrote:

> We have to say `&mut i` in main() because `&i` is non-mutable. We?re
> explicitly taking a mutable borrow.
>
> But once it?s in foo(), it?s *already* mutable. The type `&mut int`
> carries its mutability with it. Having to say `mut` again makes no sense
> and is nothing but pure noise.
>
> -Kevin
>
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
>
> For the same reason we currently have to say `&mut i` in main() - to
> explicitly acknowledge that the callee may mutate i.  By the same logic,
> this should be done everywhere.
>
>
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>  - as currently implemented, Rust does not always require mut when callee
>> mutates the argument, for example:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>>
>> Note that invocation of bar() inside foo() does not forewarn reader by
>> requiring 'mut'.  Wouldn't you rather see this?:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
>>
>>
>> What is the point of adding `mut` here? bar() does not need `mut` because
>> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>>
>> -Kevin
>>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/6c2a6476/attachment-0001.html>

From alex at crichton.co  Sat Dec 28 10:37:25 2013
From: alex at crichton.co (Alex Crichton)
Date: Sat, 28 Dec 2013 12:37:25 -0600
Subject: [rust-dev] Using libgreen/libnative
Message-ID: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>

Greetings rusticians!

Recently pull request #10965 landed, so the rust standard library no longer has
any scheduling baked into it, but rather it's refactored out into two libraries.
This means that if you want a 1:1 program, you can jettison all M:N support with
just a few `extern mod` statements. A brief overview of the current state of
things is:

1. All programs not using std::rt directly should still continue to operate as
   usual today
2. All programs still start up in M:N mode, although this will likely change
   once 1:1 I/O work has been completed
3. There are two more libraries available, libgreen and libnative, which allow
   custom fine-grained control over how programs run.
4. Whenever a new task is spawned, it is by default spawned as a "sibling" which
   means that it is spawned in the same mode as the spawning thread. This means
   that if a green thread spawns a thread then it will also be a green thread,
   while a native thread will spawn another OS thread.

With this migration, there have been a few changes in the public APIs, and
things still aren't quite where I'd like them to be. PR #11153 is the last major
step in this process as it allows you to link to both libnative and libgreen,
yet still choose which one is used to boot your program. Some breaking changes
you may notice are:

* it's still not possible to easily start up in 1:1 mode - This is fixed by
  #11153. In the meantime, you can use #[start] with native::start in order to
  boot up in 1:1 mode. Be warned though that the majority of I/O is still
  missing from libnative (see PR #11159 for some progress)

      https://gist.github.com/8162357

* std::rt::{start, run} are gone - These are temporarily moved into green/native
  while #[boot] is getting sorted out. The green/native counterparts perform as
  you would expect.

      https://gist.github.com/8162372

* std::rt::start_on_main_thread is gone - This function has been removed with no
  direct counterpart. As a consequence of refactoring the green/native
  libraries, the "single threaded" spawn mode for a task has been removed (this
  doesn't make sense in 1:1 land). This behavior can be restored by directly
  using libnative and libgreen. You can use libgreen to spin up a pool of
  schedulers and then use libnative for the main task to do things like GUI
  management.

      https://gist.github.com/8162399

And of course with the removal of some features comes the addition of new ones!
Some new things you may notice are:

* libstd is no longer burdened with libgreen and libnative! This means that the
  compile times for libstd should be a little faster, but most notably those
  applications only using libstd will have even less code pulled in than before,
  meaning that libstd is that much closer to being used in a "bare metal"
  context. It's still aways off, but we're getting closer every day!

* libgreen has a full-fleged SchedPool type. You can see a bit of how it's used
  in gist I posted above. This type is meant to represent a dynamic pool of
  schedulers. Right now it's not possible to remove a scheduler from the pool
  (requires some more thought and possibly libuv modifications), but you can add
  new schedulers dynamically to the pool.

  This type supercedes the ThreadPool type in libextra at this point, and
  management of a SchedPool should provide any fine-grained control needed over
  the 'M' number in an M:N runtime.

* libgreen and libnative can be used directly to guarantee spawning a green or a
  native task, regardless of the flavor of task that is doing the spawning.

In the coming months, I plan on filling out more native I/O to bring it up to
speed with the M:N implementation. I also plan on rewriting the core components
of extra::comm to be performant in both scheduling modes in order to bring the
extra::{comm, arc, sync} primitives up to date with their std::comm
counterparts.

If there are any questions about any of this, feel free to ask me! This thread
is always available, and I'm also reachable as acrichto on IRC or alexcrichton
on github.

From marcianx at gmail.com  Sat Dec 28 10:53:01 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 28 Dec 2013 13:53:01 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
Message-ID: <CAEsTQVOkbrGm4Vpzs14Js8qLQVVLRaj-Lv3Eoe4=QCfJg6hC+w@mail.gmail.com>

I think I see the confusion (as I suffered from the same point of
confusion). So let me restate your answer and please correct me of I am
wrong.
1. "mut int" and "& mut int" are different types and the former doesn't
automatically convert to the latter.
2. The way to get the latter from the former is to say "&mut i" since "&i"
is defined as taking a non-mut borrow even if i is mut. (This was the point
of confusion I believe.)
3. No explicit conversion is needed within foo() since the type of i is
already "&mut int".

Ashish
 On Dec 28, 2013 1:33 PM, "Kevin Ballard" <kevin at sb.org> wrote:

> We have to say `&mut i` in main() because `&i` is non-mutable. We?re
> explicitly taking a mutable borrow.
>
> But once it?s in foo(), it?s *already* mutable. The type `&mut int`
> carries its mutability with it. Having to say `mut` again makes no sense
> and is nothing but pure noise.
>
> -Kevin
>
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
>
> For the same reason we currently have to say `&mut i` in main() - to
> explicitly acknowledge that the callee may mutate i.  By the same logic,
> this should be done everywhere.
>
>
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>  - as currently implemented, Rust does not always require mut when callee
>> mutates the argument, for example:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>>
>> Note that invocation of bar() inside foo() does not forewarn reader by
>> requiring 'mut'.  Wouldn't you rather see this?:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
>>
>>
>> What is the point of adding `mut` here? bar() does not need `mut` because
>> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>>
>> -Kevin
>>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/6c2a6476/attachment-0002.html>

From kevin at sb.org  Sat Dec 28 11:25:53 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 28 Dec 2013 14:25:53 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <CAEsTQVOkbrGm4Vpzs14Js8qLQVVLRaj-Lv3Eoe4=QCfJg6hC+w@mail.gmail.com>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
	<CAEsTQVOkbrGm4Vpzs14Js8qLQVVLRaj-Lv3Eoe4=QCfJg6hC+w@mail.gmail.com>
Message-ID: <BCEB9934-D9C7-488A-B96F-1EA2DB726032@sb.org>

On Dec 28, 2013, at 1:53 PM, Ashish Myles <marcianx at gmail.com> wrote:

> I think I see the confusion (as I suffered from the same point of confusion). So let me restate your answer and please correct me of I am wrong.
> 1. "mut int" and "& mut int" are different types and the former doesn't automatically convert to the latter.
> 
Effectively correct. `mut int` isn?t actually a type, `int` is a type and the `mut` here means that the slot is mutable. `&mut int` is a type. You can in fact have `mut i: &mut int` to have a mutable slot containing a `&mut int`. This would allow you to replace the pointer stored in `i` with a different pointer. If the slot is not mutable, the pointer is fixed but because it?s a `&mut int` the data that?s being pointed to can be modified.
> 2. The way to get the latter from the former is to say "&mut i" since "&i" is defined as taking a non-mut borrow even if i is mut. (This was the point of confusion I believe.)
> 
Correct.

There is in fact one way to automatically borrow `mut i` to `&mut i`, and that?s when calling a method on `i` that takes `&mut self`. But I believe that?s the only way to automatically perform this borrowing.
> 3. No explicit conversion is needed within foo() since the type of i is already "&mut int?.
> 
Correct.

-Kevin
> Ashish
> 
> On Dec 28, 2013 1:33 PM, "Kevin Ballard" <kevin at sb.org> wrote:
> We have to say `&mut i` in main() because `&i` is non-mutable. We?re explicitly taking a mutable borrow.
> 
> But once it?s in foo(), it?s already mutable. The type `&mut int` carries its mutability with it. Having to say `mut` again makes no sense and is nothing but pure noise.
> 
> -Kevin
> 
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
> 
>> For the same reason we currently have to say `&mut i` in main() - to explicitly acknowledge that the callee may mutate i.  By the same logic, this should be done everywhere.
>> 
>> 
>> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>> 
>>> I agree that unexpected mutation is undesirable, but:
>>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>> - as currently implemented, Rust does not always require mut when callee mutates the argument, for example:
>>> 
>>> fn main() {
>>>     let mut i: int = 0;
>>>     foo(&mut i);
>>>     println!("{}", i);
>>> }
>>> fn foo(i: &mut int) {
>>>     bar(i); // no mut!
>>> }
>>> fn bar(i: &mut int) {
>>>     *i = *i + 1;
>>> }
>>> 
>>> Note that invocation of bar() inside foo() does not forewarn reader by requiring 'mut'.  Wouldn't you rather see this?:
>>> 
>>> fn main() {
>>>     let mut i: int = 0;
>>>     foo(mut i);
>>>     println!("{}", i);
>>> }
>>> fn foo(i: &mut int) {
>>>     bar(mut i);
>>> }
>>> fn bar(i: &mut int) {
>>>     i = i + 1;
>>> }
>> 
>> What is the point of adding `mut` here? bar() does not need `mut` because calling bar(i) does not auto-borrow i. It?s already a `&mut int`.
>> 
>> -Kevin
>> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/a2ba9fe8/attachment-0001.html>

From dbau.pp at gmail.com  Sat Dec 28 16:12:08 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 29 Dec 2013 11:12:08 +1100
Subject: [rust-dev] Using libgreen/libnative
In-Reply-To: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
References: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
Message-ID: <52BF68D8.6000800@gmail.com>

This is awesome!


I have a question: does the #[boot] addition mean that we now have 5 
ways to (partially) set-up the entry point of a program?
- fn main
- #[main]
- #[start]
- #[boot]
- #[lang="start"]


Huon


On 29/12/13 05:37, Alex Crichton wrote:
> Greetings rusticians!
>
> Recently pull request #10965 landed, so the rust standard library no longer has
> any scheduling baked into it, but rather it's refactored out into two libraries.
> This means that if you want a 1:1 program, you can jettison all M:N support with
> just a few `extern mod` statements. A brief overview of the current state of
> things is:
>
> 1. All programs not using std::rt directly should still continue to operate as
>     usual today
> 2. All programs still start up in M:N mode, although this will likely change
>     once 1:1 I/O work has been completed
> 3. There are two more libraries available, libgreen and libnative, which allow
>     custom fine-grained control over how programs run.
> 4. Whenever a new task is spawned, it is by default spawned as a "sibling" which
>     means that it is spawned in the same mode as the spawning thread. This means
>     that if a green thread spawns a thread then it will also be a green thread,
>     while a native thread will spawn another OS thread.
>
> With this migration, there have been a few changes in the public APIs, and
> things still aren't quite where I'd like them to be. PR #11153 is the last major
> step in this process as it allows you to link to both libnative and libgreen,
> yet still choose which one is used to boot your program. Some breaking changes
> you may notice are:
>
> * it's still not possible to easily start up in 1:1 mode - This is fixed by
>    #11153. In the meantime, you can use #[start] with native::start in order to
>    boot up in 1:1 mode. Be warned though that the majority of I/O is still
>    missing from libnative (see PR #11159 for some progress)
>
>        https://gist.github.com/8162357
>
> * std::rt::{start, run} are gone - These are temporarily moved into green/native
>    while #[boot] is getting sorted out. The green/native counterparts perform as
>    you would expect.
>
>        https://gist.github.com/8162372
>
> * std::rt::start_on_main_thread is gone - This function has been removed with no
>    direct counterpart. As a consequence of refactoring the green/native
>    libraries, the "single threaded" spawn mode for a task has been removed (this
>    doesn't make sense in 1:1 land). This behavior can be restored by directly
>    using libnative and libgreen. You can use libgreen to spin up a pool of
>    schedulers and then use libnative for the main task to do things like GUI
>    management.
>
>        https://gist.github.com/8162399
>
> And of course with the removal of some features comes the addition of new ones!
> Some new things you may notice are:
>
> * libstd is no longer burdened with libgreen and libnative! This means that the
>    compile times for libstd should be a little faster, but most notably those
>    applications only using libstd will have even less code pulled in than before,
>    meaning that libstd is that much closer to being used in a "bare metal"
>    context. It's still aways off, but we're getting closer every day!
>
> * libgreen has a full-fleged SchedPool type. You can see a bit of how it's used
>    in gist I posted above. This type is meant to represent a dynamic pool of
>    schedulers. Right now it's not possible to remove a scheduler from the pool
>    (requires some more thought and possibly libuv modifications), but you can add
>    new schedulers dynamically to the pool.
>
>    This type supercedes the ThreadPool type in libextra at this point, and
>    management of a SchedPool should provide any fine-grained control needed over
>    the 'M' number in an M:N runtime.
>
> * libgreen and libnative can be used directly to guarantee spawning a green or a
>    native task, regardless of the flavor of task that is doing the spawning.
>
> In the coming months, I plan on filling out more native I/O to bring it up to
> speed with the M:N implementation. I also plan on rewriting the core components
> of extra::comm to be performant in both scheduling modes in order to bring the
> extra::{comm, arc, sync} primitives up to date with their std::comm
> counterparts.
>
> If there are any questions about any of this, feel free to ask me! This thread
> is always available, and I'm also reachable as acrichto on IRC or alexcrichton
> on github.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From vadimcn at gmail.com  Sat Dec 28 16:10:39 2013
From: vadimcn at gmail.com (Vadim)
Date: Sat, 28 Dec 2013 16:10:39 -0800
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
Message-ID: <CADecdiJn_4a6_5ps6eNA3W2i0-xhL9ifPYp=+ps2YYhfOVZdHA@mail.gmail.com>

Right, that's how it works now.   But I was speculating on how it could
work with auto-borrow.  Specifically, I was addressing comex's concern that
C++-like reference auto-borrowing would make it non-obvious when the callee
might mutate the value.

You could have said "Well, I've already declared my variable as mutable,
i.e. `let mut i = 0`.  Since is already mutable, why do I have to say "mut"
again when borrowing?  The compiler could have easily inferred that."   I
believe the answer is "To help readers of this code realize that the called
function is [most likely] going to mutate the variable".   I believe the
same logic should apply to mut references.

I know that when I write my code, *on the caller side*, I am much more
concerned about which calls are going to mutate my variables, then about
whether they are passed by-value or by-reference.  After all, the callee
has already chosen that for me.
And, judging by the number of C++ projects that ban non-const references
but nave no problem with const ones, I think that a significant proportion
of developers feel similarly.

Vadim



On Sat, Dec 28, 2013 at 10:03 AM, Kevin Ballard <kevin at sb.org> wrote:

> We have to say `&mut i` in main() because `&i` is non-mutable. We?re
> explicitly taking a mutable borrow.
>
> But once it?s in foo(), it?s *already* mutable. The type `&mut int`
> carries its mutability with it. Having to say `mut` again makes no sense
> and is nothing but pure noise.
>
> -Kevin
>
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
>
> For the same reason we currently have to say `&mut i` in main() - to
> explicitly acknowledge that the callee may mutate i.  By the same logic,
> this should be done everywhere.
>
>
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>  - as currently implemented, Rust does not always require mut when callee
>> mutates the argument, for example:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>>
>> Note that invocation of bar() inside foo() does not forewarn reader by
>> requiring 'mut'.  Wouldn't you rather see this?:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
>>
>>
>> What is the point of adding `mut` here? bar() does not need `mut` because
>> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>>
>> -Kevin
>>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/e1bf4fba/attachment.html>

From vadimcn at gmail.com  Sat Dec 28 16:10:39 2013
From: vadimcn at gmail.com (Vadim)
Date: Sat, 28 Dec 2013 16:10:39 -0800
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
Message-ID: <CADecdiJn_4a6_5ps6eNA3W2i0-xhL9ifPYp=+ps2YYhfOVZdHA@mail.gmail.com>

Right, that's how it works now.   But I was speculating on how it could
work with auto-borrow.  Specifically, I was addressing comex's concern that
C++-like reference auto-borrowing would make it non-obvious when the callee
might mutate the value.

You could have said "Well, I've already declared my variable as mutable,
i.e. `let mut i = 0`.  Since is already mutable, why do I have to say "mut"
again when borrowing?  The compiler could have easily inferred that."   I
believe the answer is "To help readers of this code realize that the called
function is [most likely] going to mutate the variable".   I believe the
same logic should apply to mut references.

I know that when I write my code, *on the caller side*, I am much more
concerned about which calls are going to mutate my variables, then about
whether they are passed by-value or by-reference.  After all, the callee
has already chosen that for me.
And, judging by the number of C++ projects that ban non-const references
but nave no problem with const ones, I think that a significant proportion
of developers feel similarly.

Vadim



On Sat, Dec 28, 2013 at 10:03 AM, Kevin Ballard <kevin at sb.org> wrote:

> We have to say `&mut i` in main() because `&i` is non-mutable. We?re
> explicitly taking a mutable borrow.
>
> But once it?s in foo(), it?s *already* mutable. The type `&mut int`
> carries its mutability with it. Having to say `mut` again makes no sense
> and is nothing but pure noise.
>
> -Kevin
>
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
>
> For the same reason we currently have to say `&mut i` in main() - to
> explicitly acknowledge that the callee may mutate i.  By the same logic,
> this should be done everywhere.
>
>
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>  - as currently implemented, Rust does not always require mut when callee
>> mutates the argument, for example:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>>
>> Note that invocation of bar() inside foo() does not forewarn reader by
>> requiring 'mut'.  Wouldn't you rather see this?:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
>>
>>
>> What is the point of adding `mut` here? bar() does not need `mut` because
>> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>>
>> -Kevin
>>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/e1bf4fba/attachment-0003.html>

From banderson at mozilla.com  Sat Dec 28 17:06:39 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Sat, 28 Dec 2013 17:06:39 -0800
Subject: [rust-dev] Using libgreen/libnative
In-Reply-To: <52BF68D8.6000800@gmail.com>
References: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
	<52BF68D8.6000800@gmail.com>
Message-ID: <52BF759F.4000007@mozilla.com>

On 12/28/2013 04:12 PM, Huon Wilson wrote:
> This is awesome!
>
>
> I have a question: does the #[boot] addition mean that we now have 5 
> ways to (partially) set-up the entry point of a program?
> - fn main
> - #[main]
> - #[start]
> - #[boot]
> - #[lang="start"]

Yeah, pretty much, and there's also a 6th way of defining an entry point 
- by using #[no_main] and just defining main like in C. Alex and I had a 
pretty decent laugh when we decided to add #[boot] to the mix. Note 
though that #[boot] won't define a new entry point - it just changes how 
the runtime configures itself before running main. Clearly, this is 
getting pretty silly and this will continue to evolve, and hopefully 
we'll end up in a spot where most users don't need to know about all 
these mechanisms.

>
>
> Huon
>
>
> On 29/12/13 05:37, Alex Crichton wrote:
>> Greetings rusticians!
>>
>> Recently pull request #10965 landed, so the rust standard library no 
>> longer has
>> any scheduling baked into it, but rather it's refactored out into two 
>> libraries.
>> This means that if you want a 1:1 program, you can jettison all M:N 
>> support with
>> just a few `extern mod` statements. A brief overview of the current 
>> state of
>> things is:
>>
>> 1. All programs not using std::rt directly should still continue to 
>> operate as
>>     usual today
>> 2. All programs still start up in M:N mode, although this will likely 
>> change
>>     once 1:1 I/O work has been completed
>> 3. There are two more libraries available, libgreen and libnative, 
>> which allow
>>     custom fine-grained control over how programs run.
>> 4. Whenever a new task is spawned, it is by default spawned as a 
>> "sibling" which
>>     means that it is spawned in the same mode as the spawning thread. 
>> This means
>>     that if a green thread spawns a thread then it will also be a 
>> green thread,
>>     while a native thread will spawn another OS thread.
>>
>> With this migration, there have been a few changes in the public 
>> APIs, and
>> things still aren't quite where I'd like them to be. PR #11153 is the 
>> last major
>> step in this process as it allows you to link to both libnative and 
>> libgreen,
>> yet still choose which one is used to boot your program. Some 
>> breaking changes
>> you may notice are:
>>
>> * it's still not possible to easily start up in 1:1 mode - This is 
>> fixed by
>>    #11153. In the meantime, you can use #[start] with native::start 
>> in order to
>>    boot up in 1:1 mode. Be warned though that the majority of I/O is 
>> still
>>    missing from libnative (see PR #11159 for some progress)
>>
>>        https://gist.github.com/8162357
>>
>> * std::rt::{start, run} are gone - These are temporarily moved into 
>> green/native
>>    while #[boot] is getting sorted out. The green/native counterparts 
>> perform as
>>    you would expect.
>>
>>        https://gist.github.com/8162372
>>
>> * std::rt::start_on_main_thread is gone - This function has been 
>> removed with no
>>    direct counterpart. As a consequence of refactoring the green/native
>>    libraries, the "single threaded" spawn mode for a task has been 
>> removed (this
>>    doesn't make sense in 1:1 land). This behavior can be restored by 
>> directly
>>    using libnative and libgreen. You can use libgreen to spin up a 
>> pool of
>>    schedulers and then use libnative for the main task to do things 
>> like GUI
>>    management.
>>
>>        https://gist.github.com/8162399
>>
>> And of course with the removal of some features comes the addition of 
>> new ones!
>> Some new things you may notice are:
>>
>> * libstd is no longer burdened with libgreen and libnative! This 
>> means that the
>>    compile times for libstd should be a little faster, but most 
>> notably those
>>    applications only using libstd will have even less code pulled in 
>> than before,
>>    meaning that libstd is that much closer to being used in a "bare 
>> metal"
>>    context. It's still aways off, but we're getting closer every day!
>>
>> * libgreen has a full-fleged SchedPool type. You can see a bit of how 
>> it's used
>>    in gist I posted above. This type is meant to represent a dynamic 
>> pool of
>>    schedulers. Right now it's not possible to remove a scheduler from 
>> the pool
>>    (requires some more thought and possibly libuv modifications), but 
>> you can add
>>    new schedulers dynamically to the pool.
>>
>>    This type supercedes the ThreadPool type in libextra at this 
>> point, and
>>    management of a SchedPool should provide any fine-grained control 
>> needed over
>>    the 'M' number in an M:N runtime.
>>
>> * libgreen and libnative can be used directly to guarantee spawning a 
>> green or a
>>    native task, regardless of the flavor of task that is doing the 
>> spawning.
>>
>> In the coming months, I plan on filling out more native I/O to bring 
>> it up to
>> speed with the M:N implementation. I also plan on rewriting the core 
>> components
>> of extra::comm to be performant in both scheduling modes in order to 
>> bring the
>> extra::{comm, arc, sync} primitives up to date with their std::comm
>> counterparts.
>>
>> If there are any questions about any of this, feel free to ask me! 
>> This thread
>> is always available, and I'm also reachable as acrichto on IRC or 
>> alexcrichton
>> on github.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Sat Dec 28 17:15:54 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Sat, 28 Dec 2013 17:15:54 -0800
Subject: [rust-dev] Using libgreen/libnative
In-Reply-To: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
References: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
Message-ID: <52BF77CA.3040302@mozilla.com>

Thanks for writing this up, Alex. The improvements you've made to the 
runtime recently are very impressive. Now we've got nearly complete and 
reasonably fast I/O, fast message passing, a scheduler-agnostic standard 
library, and very soon an embeddable runtime and a standard library that 
can be used in almost any environment. After years of iteration I'm 
hopeful that we're finally converging on a good design for the runtime.


On 12/28/2013 10:37 AM, Alex Crichton wrote:
> Greetings rusticians!
>
> Recently pull request #10965 landed, so the rust standard library no longer has
> any scheduling baked into it, but rather it's refactored out into two libraries.
> This means that if you want a 1:1 program, you can jettison all M:N support with
> just a few `extern mod` statements. A brief overview of the current state of
> things is:
>
> 1. All programs not using std::rt directly should still continue to operate as
>     usual today
> 2. All programs still start up in M:N mode, although this will likely change
>     once 1:1 I/O work has been completed
> 3. There are two more libraries available, libgreen and libnative, which allow
>     custom fine-grained control over how programs run.
> 4. Whenever a new task is spawned, it is by default spawned as a "sibling" which
>     means that it is spawned in the same mode as the spawning thread. This means
>     that if a green thread spawns a thread then it will also be a green thread,
>     while a native thread will spawn another OS thread.
>
> With this migration, there have been a few changes in the public APIs, and
> things still aren't quite where I'd like them to be. PR #11153 is the last major
> step in this process as it allows you to link to both libnative and libgreen,
> yet still choose which one is used to boot your program. Some breaking changes
> you may notice are:
>
> * it's still not possible to easily start up in 1:1 mode - This is fixed by
>    #11153. In the meantime, you can use #[start] with native::start in order to
>    boot up in 1:1 mode. Be warned though that the majority of I/O is still
>    missing from libnative (see PR #11159 for some progress)
>
>        https://gist.github.com/8162357
>
> * std::rt::{start, run} are gone - These are temporarily moved into green/native
>    while #[boot] is getting sorted out. The green/native counterparts perform as
>    you would expect.
>
>        https://gist.github.com/8162372
>
> * std::rt::start_on_main_thread is gone - This function has been removed with no
>    direct counterpart. As a consequence of refactoring the green/native
>    libraries, the "single threaded" spawn mode for a task has been removed (this
>    doesn't make sense in 1:1 land). This behavior can be restored by directly
>    using libnative and libgreen. You can use libgreen to spin up a pool of
>    schedulers and then use libnative for the main task to do things like GUI
>    management.
>
>        https://gist.github.com/8162399
>
> And of course with the removal of some features comes the addition of new ones!
> Some new things you may notice are:
>
> * libstd is no longer burdened with libgreen and libnative! This means that the
>    compile times for libstd should be a little faster, but most notably those
>    applications only using libstd will have even less code pulled in than before,
>    meaning that libstd is that much closer to being used in a "bare metal"
>    context. It's still aways off, but we're getting closer every day!
>
> * libgreen has a full-fleged SchedPool type. You can see a bit of how it's used
>    in gist I posted above. This type is meant to represent a dynamic pool of
>    schedulers. Right now it's not possible to remove a scheduler from the pool
>    (requires some more thought and possibly libuv modifications), but you can add
>    new schedulers dynamically to the pool.
>
>    This type supercedes the ThreadPool type in libextra at this point, and
>    management of a SchedPool should provide any fine-grained control needed over
>    the 'M' number in an M:N runtime.
>
> * libgreen and libnative can be used directly to guarantee spawning a green or a
>    native task, regardless of the flavor of task that is doing the spawning.
>
> In the coming months, I plan on filling out more native I/O to bring it up to
> speed with the M:N implementation. I also plan on rewriting the core components
> of extra::comm to be performant in both scheduling modes in order to bring the
> extra::{comm, arc, sync} primitives up to date with their std::comm
> counterparts.
>
> If there are any questions about any of this, feel free to ask me! This thread
> is always available, and I'm also reachable as acrichto on IRC or alexcrichton
> on github.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From vadimcn at gmail.com  Sat Dec 28 16:10:39 2013
From: vadimcn at gmail.com (Vadim)
Date: Sat, 28 Dec 2013 16:10:39 -0800
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
Message-ID: <CADecdiJn_4a6_5ps6eNA3W2i0-xhL9ifPYp=+ps2YYhfOVZdHA@mail.gmail.com>

Right, that's how it works now.   But I was speculating on how it could
work with auto-borrow.  Specifically, I was addressing comex's concern that
C++-like reference auto-borrowing would make it non-obvious when the callee
might mutate the value.

You could have said "Well, I've already declared my variable as mutable,
i.e. `let mut i = 0`.  Since is already mutable, why do I have to say "mut"
again when borrowing?  The compiler could have easily inferred that."   I
believe the answer is "To help readers of this code realize that the called
function is [most likely] going to mutate the variable".   I believe the
same logic should apply to mut references.

I know that when I write my code, *on the caller side*, I am much more
concerned about which calls are going to mutate my variables, then about
whether they are passed by-value or by-reference.  After all, the callee
has already chosen that for me.
And, judging by the number of C++ projects that ban non-const references
but nave no problem with const ones, I think that a significant proportion
of developers feel similarly.

Vadim



On Sat, Dec 28, 2013 at 10:03 AM, Kevin Ballard <kevin at sb.org> wrote:

> We have to say `&mut i` in main() because `&i` is non-mutable. We?re
> explicitly taking a mutable borrow.
>
> But once it?s in foo(), it?s *already* mutable. The type `&mut int`
> carries its mutability with it. Having to say `mut` again makes no sense
> and is nothing but pure noise.
>
> -Kevin
>
> On Dec 27, 2013, at 4:59 PM, Vadim <vadimcn at gmail.com> wrote:
>
> For the same reason we currently have to say `&mut i` in main() - to
> explicitly acknowledge that the callee may mutate i.  By the same logic,
> this should be done everywhere.
>
>
> On Wed, Dec 25, 2013 at 3:11 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Dec 25, 2013, at 5:17 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>> I agree that unexpected mutation is undesirable, but:
>> - requiring 'mut' is orthogonal to requiring '&' sigil, IMHO,
>>  - as currently implemented, Rust does not always require mut when callee
>> mutates the argument, for example:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(i); // no mut!
>> }
>> fn bar(i: &mut int) {
>>     *i = *i + 1;
>> }
>>
>> Note that invocation of bar() inside foo() does not forewarn reader by
>> requiring 'mut'.  Wouldn't you rather see this?:
>>
>> fn main() {
>>     let mut i: int = 0;
>>     foo(mut i);
>>     println!("{}", i);
>> }
>> fn foo(i: &mut int) {
>>     bar(mut i);
>> }
>> fn bar(i: &mut int) {
>>     i = i + 1;
>> }
>>
>>
>> What is the point of adding `mut` here? bar() does not need `mut` because
>> calling bar(i) does not auto-borrow i. It?s *already* a `&mut int`.
>>
>> -Kevin
>>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/e1bf4fba/attachment-0004.html>

From kevin at sb.org  Sat Dec 28 20:03:37 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 28 Dec 2013 23:03:37 -0500
Subject: [rust-dev] Auto-borrow/deref (again, sorry)
In-Reply-To: <CADecdiJn_4a6_5ps6eNA3W2i0-xhL9ifPYp=+ps2YYhfOVZdHA@mail.gmail.com>
References: <CADecdiLu1v+oTH_snXC4toVexE-i3xqLKxrLKX4EV2NrcZ2KfA@mail.gmail.com>
	<93054ADE-517A-42A0-96AC-3D4756763FD5@sb.org>
	<CADecdiK8n2B7rOMpfUkydPccn6GghzpLagZdUg+VD7bk2sYVbQ@mail.gmail.com>
	<61F0D9AD-EFD7-41CF-9EDC-685F506DD5FE@sb.org>
	<CADecdiJn_4a6_5ps6eNA3W2i0-xhL9ifPYp=+ps2YYhfOVZdHA@mail.gmail.com>
Message-ID: <BAC362BA-EF0C-4372-91CC-C57B39662A63@sb.org>

On Dec 28, 2013, at 7:10 PM, Vadim <vadimcn at gmail.com> wrote:

> You could have said "Well, I've already declared my variable as mutable, i.e. `let mut i = 0`.  Since is already mutable, why do I have to say "mut" again when borrowing?  The compiler could have easily inferred that."   I believe the answer is "To help readers of this code realize that the called function is [most likely] going to mutate the variable".   I believe the same logic should apply to mut references.

The answer is because &T and &mut T are distinct types, with distinct behavior (notably, mutable borrows must be unique).

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131228/caeb954d/attachment-0001.html>

From erick.tryzelaar at gmail.com  Sun Dec 29 07:48:36 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Sun, 29 Dec 2013 10:48:36 -0500
Subject: [rust-dev] Announcing rust-openssl
Message-ID: <CALdfqQ+QNdTD0Bs2PBXXMhMqS1E_Z0UccE5Y1Af+6oOM9D_+ug@mail.gmail.com>

Hello everyone!

I wanted to let you all know that Steven Fackler and I have merged my
rustcrypto and his rust-ssl projects into rust-openssl, found here:

https://github.com/sfackler/rust-openssl

This project exposes many of the OpenSSL symmetric and PKI cryptographic
services, and also supports wrapping a rust `std::io::Stream` with SSL. We
still have some work to do to finish merging the projects together, but all
the tests pass and we are registered with rust-ci. Please try it out and
let us know if you run into any problems.

Thanks,
Erick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131229/a46d2519/attachment.html>

From pcwalton at mozilla.com  Sun Dec 29 09:12:36 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 29 Dec 2013 09:12:36 -0800
Subject: [rust-dev] Announcing rust-openssl
In-Reply-To: <CALdfqQ+QNdTD0Bs2PBXXMhMqS1E_Z0UccE5Y1Af+6oOM9D_+ug@mail.gmail.com>
References: <CALdfqQ+QNdTD0Bs2PBXXMhMqS1E_Z0UccE5Y1Af+6oOM9D_+ug@mail.gmail.com>
Message-ID: <52C05804.7090006@mozilla.com>

On 12/29/13 7:48 AM, Erick Tryzelaar wrote:
> Hello everyone!
>
> I wanted to let you all know that Steven Fackler and I have merged my
> rustcrypto and his rust-ssl projects into rust-openssl, found here:
>
> https://github.com/sfackler/rust-openssl
>
> This project exposes many of the OpenSSL symmetric and PKI cryptographic
> services, and also supports wrapping a rust `std::io::Stream` with SSL.
> We still have some work to do to finish merging the projects together,
> but all the tests pass and we are registered with rust-ci. Please try it
> out and let us know if you run into any problems.

Sounds like an ideal candidate for integration with `rust-http`. (Not 
proposing merging the two projects, just wondering about integration.) 
Can `rust-http` be made to work with a user-supplied stream?

Patrick


From sfackler at gmail.com  Sun Dec 29 09:49:58 2013
From: sfackler at gmail.com (Steven Fackler)
Date: Sun, 29 Dec 2013 10:49:58 -0700
Subject: [rust-dev] Announcing rust-openssl
In-Reply-To: <52C05804.7090006@mozilla.com>
References: <CALdfqQ+QNdTD0Bs2PBXXMhMqS1E_Z0UccE5Y1Af+6oOM9D_+ug@mail.gmail.com>
	<52C05804.7090006@mozilla.com>
Message-ID: <CANb7cF7wdf0ndtnTdsp9R3qMy=ReQCLYOkRrFKPRDWOzc+tE=A@mail.gmail.com>

There's an old open PR to optionally integrate with rust-ssl or rust-nss (
https://github.com/chris-morgan/rust-http/pull/31) but it'd need to be
updated.

Steven Fackler


On Sun, Dec 29, 2013 at 10:12 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/29/13 7:48 AM, Erick Tryzelaar wrote:
>
>> Hello everyone!
>>
>> I wanted to let you all know that Steven Fackler and I have merged my
>> rustcrypto and his rust-ssl projects into rust-openssl, found here:
>>
>> https://github.com/sfackler/rust-openssl
>>
>> This project exposes many of the OpenSSL symmetric and PKI cryptographic
>> services, and also supports wrapping a rust `std::io::Stream` with SSL.
>> We still have some work to do to finish merging the projects together,
>> but all the tests pass and we are registered with rust-ci. Please try it
>> out and let us know if you run into any problems.
>>
>
> Sounds like an ideal candidate for integration with `rust-http`. (Not
> proposing merging the two projects, just wondering about integration.) Can
> `rust-http` be made to work with a user-supplied stream?
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131229/eef8c677/attachment.html>

From armin.ronacher at active-4.com  Mon Dec 30 05:00:30 2013
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Mon, 30 Dec 2013 14:00:30 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
Message-ID: <52C16E6E.6090603@active-4.com>

Hi,

I am not using Rust nearly as much as I wish I could, but I absolutely 
love playing around with it and seeing where it's heading.  I think all 
things considered the language is going exactly where I want it to go. 
It's for the most part very pleasant to work with and it's getting 
better and better.

But there is so much more work needed.  Not just because the language is 
lacking things that are needed, but because many users of the language 
are not sure yet how to use it.

The compiler and the standard library use widely different patterns and 
so do libraries written by other people.  There are half a dozen ways to 
deal with errors now, there are different patterns of how to deal with 
Options and Results.  There are vastly different ways to design whole 
APIs, how to deal with the traits and so forth.  There are different 
patterns to interface with native libraries, different patterns to 
interface with task local data etc.

The introduction of external iterators (which I found the most exciting 
change of the language) has shown a whole new area of shortcomings in 
the current feature set (lack decltype when returning composed iterators 
for instance, non sendable closures etc.).  Not only did it show 
shortcomings in lacking features, it also put some emphasis on new 
patterns that are not widely deployed in the stdlib yet.

I really hope there is left enough time to actually continue evolving 
the language and libraries before freezing anything.  Especially now 
that the split into libnative and libgreen is happening it will be 
important to stay flexible for adjusting the design of the standard 
library so that we don't end up with two vastly different ways to do IO.

It does not take a genius to realize that there is already some tension 
among developers with regards to where the language should be going, and 
at what pace.

As an outside observer that is very much in love with Rust and where 
it's heading, I want to voice the wish that there will be enough time to 
continue evolving the language before racing to a 1.0 release. 
Especially now that there is a lot of interest in Rust and similar 
languages I believe this is necessary.  As it stands right now, there 
are too many things that make Rust still frustrating because you program 
yourself into a corner.


TL;DR: please don't rush a 1.0 release.


Regards,
Armin

From j.boggiano at seld.be  Mon Dec 30 06:35:51 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Mon, 30 Dec 2013 15:35:51 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C16E6E.6090603@active-4.com>
References: <52C16E6E.6090603@active-4.com>
Message-ID: <CA+GmM=zsV+ho704Jy4XJy9Lbte2-FpVjP-3my8O+034tSpLjGg@mail.gmail.com>

On Mon, Dec 30, 2013 at 2:00 PM, Armin Ronacher
<armin.ronacher at active-4.com> wrote:
> TL;DR: please don't rush a 1.0 release.

FWIW I'm all for waiting as well.

That said maybe it would be worth it to discuss having a 1.0 soonish
with a clear timeline that could maybe bring both sides together:

- 1 or 2 years of planned BC/bugfixes/support depending on who can or
wants to provide such reassurances. Therefore libs could stabilize on
1.x releases for now and more people could use rust for more than
play-things, bringing more experience towards..
- a 2.0 planned with BC breaks planned for a year after the 1.0
release, which would allow broader changes to still happen in the
master branch, and make sure we don't get stuck with rushed decisions
for 10 years.

Cheers

From flaper87 at gmail.com  Mon Dec 30 06:36:27 2013
From: flaper87 at gmail.com (Flaper87)
Date: Mon, 30 Dec 2013 15:36:27 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C16E6E.6090603@active-4.com>
References: <52C16E6E.6090603@active-4.com>
Message-ID: <CAMOT3C0mnVMwXtGtWqTowSGVQ=aSfg3h9EvVL4VJis3CxwS6mg@mail.gmail.com>

2013/12/30 Armin Ronacher <armin.ronacher at active-4.com>

> Hi,
>
> I am not using Rust nearly as much as I wish I could, but I absolutely
> love playing around with it and seeing where it's heading.  I think all
> things considered the language is going exactly where I want it to go. It's
> for the most part very pleasant to work with and it's getting better and
> better.
>
> But there is so much more work needed.  Not just because the language is
> lacking things that are needed, but because many users of the language are
> not sure yet how to use it.
>
> The compiler and the standard library use widely different patterns and so
> do libraries written by other people.  There are half a dozen ways to deal
> with errors now, there are different patterns of how to deal with Options
> and Results.  There are vastly different ways to design whole APIs, how to
> deal with the traits and so forth.  There are different patterns to
> interface with native libraries, different patterns to interface with task
> local data etc.
>
> The introduction of external iterators (which I found the most exciting
> change of the language) has shown a whole new area of shortcomings in the
> current feature set (lack decltype when returning composed iterators for
> instance, non sendable closures etc.).  Not only did it show shortcomings
> in lacking features, it also put some emphasis on new patterns that are not
> widely deployed in the stdlib yet.
>
> I really hope there is left enough time to actually continue evolving the
> language and libraries before freezing anything.  Especially now that the
> split into libnative and libgreen is happening it will be important to stay
> flexible for adjusting the design of the standard library so that we don't
> end up with two vastly different ways to do IO.
>
> It does not take a genius to realize that there is already some tension
> among developers with regards to where the language should be going, and at
> what pace.
>
> As an outside observer that is very much in love with Rust and where it's
> heading, I want to voice the wish that there will be enough time to
> continue evolving the language before racing to a 1.0 release. Especially
> now that there is a lot of interest in Rust and similar languages I believe
> this is necessary.  As it stands right now, there are too many things that
> make Rust still frustrating because you program yourself into a corner.
>
>
> TL;DR: please don't rush a 1.0 release.
>
>
FWIW, I couldn't agree more with Armin.

There's a lot of excitement about Rust right now. The language has evolved
a lot lately and some folks can't wait to get their hands on it. However,
it's really important not to rush it and make sure the language is not just
what people expect. The language has to reach a point were it's enough
features for people to use it and contribute back. It's also important to
make sure the language reaches the point where it's possible to keep adding
/ removing things without much pain.

Cheers,
FF

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/68e449f2/attachment.html>

From michael.letterle+rust at gmail.com  Mon Dec 30 07:07:35 2013
From: michael.letterle+rust at gmail.com (Michael Letterle)
Date: Mon, 30 Dec 2013 10:07:35 -0500
Subject: [rust-dev] Announcing rust-openssl
In-Reply-To: <CANb7cF7wdf0ndtnTdsp9R3qMy=ReQCLYOkRrFKPRDWOzc+tE=A@mail.gmail.com>
References: <CALdfqQ+QNdTD0Bs2PBXXMhMqS1E_Z0UccE5Y1Af+6oOM9D_+ug@mail.gmail.com>
	<52C05804.7090006@mozilla.com>
	<CANb7cF7wdf0ndtnTdsp9R3qMy=ReQCLYOkRrFKPRDWOzc+tE=A@mail.gmail.com>
Message-ID: <CA+UdSrvcdJ3OtgbcvvqyOk=R7e-kdXnwhtx2d_3XOpyrxJbjRw@mail.gmail.com>

I can update the PR, I have to do some catching up.. holidays and all :)


On Sun, Dec 29, 2013 at 12:49 PM, Steven Fackler <sfackler at gmail.com> wrote:

> There's an old open PR to optionally integrate with rust-ssl or rust-nss (
> https://github.com/chris-morgan/rust-http/pull/31) but it'd need to be
> updated.
>
> Steven Fackler
>
>
> On Sun, Dec 29, 2013 at 10:12 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>
>> On 12/29/13 7:48 AM, Erick Tryzelaar wrote:
>>
>>> Hello everyone!
>>>
>>> I wanted to let you all know that Steven Fackler and I have merged my
>>> rustcrypto and his rust-ssl projects into rust-openssl, found here:
>>>
>>> https://github.com/sfackler/rust-openssl
>>>
>>> This project exposes many of the OpenSSL symmetric and PKI cryptographic
>>> services, and also supports wrapping a rust `std::io::Stream` with SSL.
>>> We still have some work to do to finish merging the projects together,
>>> but all the tests pass and we are registered with rust-ci. Please try it
>>> out and let us know if you run into any problems.
>>>
>>
>> Sounds like an ideal candidate for integration with `rust-http`. (Not
>> proposing merging the two projects, just wondering about integration.) Can
>> `rust-http` be made to work with a user-supplied stream?
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/e26750ef/attachment.html>

From pcwalton at mozilla.com  Mon Dec 30 08:29:41 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 08:29:41 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C16E6E.6090603@active-4.com>
References: <52C16E6E.6090603@active-4.com>
Message-ID: <52C19F75.5090703@mozilla.com>

On 12/30/13 5:00 AM, Armin Ronacher wrote:
> But there is so much more work needed.  Not just because the language is
> lacking things that are needed, but because many users of the language
> are not sure yet how to use it.

Documentation is independent of freezing the language definition.

> The compiler and the standard library use widely different patterns and
> so do libraries written by other people.

IMO, the compiler doesn't need to be updated to modern Rust before 1.0. 
(`javac` is still not updated to modern Java standards, for example.) 
The standard library does, however.

> There are half a dozen ways to
> deal with errors now, there are different patterns of how to deal with
> Options and Results.

These need to be cleaned up before 1.0. Conditions in particular need to 
be removed.

> There are vastly different ways to design whole
> APIs, how to deal with the traits and so forth.

We'll standardize on something before 1.0. The traits need to be 
redesigned in general.

> There are different
> patterns to interface with native libraries, different patterns to
> interface with task local data etc.

Are you referencing RAII versus `with_foo` style methods? The latter are 
deprecated and should be removed before 1.0.

> The introduction of external iterators (which I found the most exciting
> change of the language) has shown a whole new area of shortcomings in
> the current feature set (lack decltype when returning composed iterators
> for instance,

This is the first time I've heard of this as a missing feature, and I'm 
opposed. This would make typechecking significantly more complex.

> non sendable closures etc.).

Is `proc` not sufficient? We could prioritize adding unboxed closures, 
but since they're backwards compatible as far as I know, I don't see a 
major need to add them before 1.0.

> Not only did it show
> shortcomings in lacking features, it also put some emphasis on new
> patterns that are not widely deployed in the stdlib yet.

We need to add them before 1.0, but I personally don't see any major 
missing language features that we absolutely need to add, except those 
that are already on the roadmap.

> I really hope there is left enough time to actually continue evolving
> the language and libraries before freezing anything.  Especially now
> that the split into libnative and libgreen is happening it will be
> important to stay flexible for adjusting the design of the standard
> library so that we don't end up with two vastly different ways to do IO.

We aren't going to freeze the entire standard library for all time with 
1.0. Instead there will be "stability levels" like node.js (something 
like "frozen", "stabilizing", "unstable", "experimental"). I don't 
anticipate that all of libstd will be frozen before 1.0. Some modules 
will, and other modules will not.

> As it stands right now, there
> are too many things that make Rust still frustrating because you program
> yourself into a corner.

It'd be best to file specific issues here. I'm sympathetic to wanting to 
adding more features if they're necessary, but none of the *specific* 
things mentioned in this post seem like blockers to me.

In general I understand the concern, but there are also a huge number of 
people who just want the language to stabilize so that they can use it 
in production. The window for relevance is finite and we've been 
designing the language for a *long* time at this point.

Patrick


From glaebhoerl at gmail.com  Mon Dec 30 09:08:27 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 30 Dec 2013 18:08:27 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C19F75.5090703@mozilla.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>
Message-ID: <CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>

It would be helpful to know what the (rough) plan is for after 1.0. A
series of 1.x releases and later 2.0, or just 2.0? At what kind of time
scales? What kind of changes will be appropriate for each? (i.e. language
features, bugfixes, compatibility breaks of various forms in various places)

How is Rust going to feel about the prospect of backwards-incompatible
changes after 1.0? Like C++: never ever break anything ever ever?


On Mon, Dec 30, 2013 at 5:29 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/30/13 5:00 AM, Armin Ronacher wrote:
>
>> But there is so much more work needed.  Not just because the language is
>> lacking things that are needed, but because many users of the language
>> are not sure yet how to use it.
>>
>
> Documentation is independent of freezing the language definition.
>
>
>  The compiler and the standard library use widely different patterns and
>> so do libraries written by other people.
>>
>
> IMO, the compiler doesn't need to be updated to modern Rust before 1.0.
> (`javac` is still not updated to modern Java standards, for example.) The
> standard library does, however.
>
>
>  There are half a dozen ways to
>> deal with errors now, there are different patterns of how to deal with
>> Options and Results.
>>
>
> These need to be cleaned up before 1.0. Conditions in particular need to
> be removed.
>
>
>  There are vastly different ways to design whole
>> APIs, how to deal with the traits and so forth.
>>
>
> We'll standardize on something before 1.0. The traits need to be
> redesigned in general.
>
>
>  There are different
>> patterns to interface with native libraries, different patterns to
>> interface with task local data etc.
>>
>
> Are you referencing RAII versus `with_foo` style methods? The latter are
> deprecated and should be removed before 1.0.
>
>
>  The introduction of external iterators (which I found the most exciting
>> change of the language) has shown a whole new area of shortcomings in
>> the current feature set (lack decltype when returning composed iterators
>> for instance,
>>
>
> This is the first time I've heard of this as a missing feature, and I'm
> opposed. This would make typechecking significantly more complex.
>
>  non sendable closures etc.).
>>
>
> Is `proc` not sufficient? We could prioritize adding unboxed closures, but
> since they're backwards compatible as far as I know, I don't see a major
> need to add them before 1.0.
>
>
>  Not only did it show
>> shortcomings in lacking features, it also put some emphasis on new
>> patterns that are not widely deployed in the stdlib yet.
>>
>
> We need to add them before 1.0, but I personally don't see any major
> missing language features that we absolutely need to add, except those that
> are already on the roadmap.
>
>
>  I really hope there is left enough time to actually continue evolving
>> the language and libraries before freezing anything.  Especially now
>> that the split into libnative and libgreen is happening it will be
>> important to stay flexible for adjusting the design of the standard
>> library so that we don't end up with two vastly different ways to do IO.
>>
>
> We aren't going to freeze the entire standard library for all time with
> 1.0. Instead there will be "stability levels" like node.js (something like
> "frozen", "stabilizing", "unstable", "experimental"). I don't anticipate
> that all of libstd will be frozen before 1.0. Some modules will, and other
> modules will not.
>
>
>  As it stands right now, there
>> are too many things that make Rust still frustrating because you program
>> yourself into a corner.
>>
>
> It'd be best to file specific issues here. I'm sympathetic to wanting to
> adding more features if they're necessary, but none of the *specific*
> things mentioned in this post seem like blockers to me.
>
> In general I understand the concern, but there are also a huge number of
> people who just want the language to stabilize so that they can use it in
> production. The window for relevance is finite and we've been designing the
> language for a *long* time at this point.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/bcfaadc3/attachment.html>

From denis.spir at gmail.com  Mon Dec 30 09:15:45 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 30 Dec 2013 18:15:45 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C19F75.5090703@mozilla.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
Message-ID: <52C1AA41.7010402@gmail.com>

On 12/30/2013 05:29 PM, Patrick Walton wrote:
> In general I understand the concern, but there are also a huge number of people
> who just want the language to stabilize so that they can use it in production.
> The window for relevance is finite and we've been designing the language for a
> *long* time at this point.

I understand and share this view, but see it as one side of the story: the other 
side beeing that the language has evolved pretty much in recent times, and this 
in part about several core features (pointer management, traits, basic data 
structures, error handling...). Obviously much remains unclear to the 
proto-user-base, and is felt as unstable and susceptible to drastic evolution 
still (maybe it's not for you, but maybe you are wrong on this ;-).

I guess a significant number of people would prefere seeing the language go on 
evolving the time needed to have it reach a point where at least core constructs 
look like beeing close to as good as possible (considering the state of present 
knowledge about programming is or should be: read, probably much too few). I 
personly would cry when I see Rust ending up beeing yet another failed 
replacement for C (for the present, it would be so in part because it's much too 
difficult to use).

Denis

From pwalton at mozilla.com  Mon Dec 30 09:18:59 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 09:18:59 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C1AA41.7010402@gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C1AA41.7010402@gmail.com>
Message-ID: <0b55ae67-f462-4e01-85ec-a4623dd19ba3@email.android.com>

Again, I need specific things that are so difficult to use that the language will fail without them. Just saying "don't finalize the language yet or it will fail" is unhelpful stop energy.

Patrick

spir <denis.spir at gmail.com> wrote:
>On 12/30/2013 05:29 PM, Patrick Walton wrote:
>> In general I understand the concern, but there are also a huge number
>of people
>> who just want the language to stabilize so that they can use it in
>production.
>> The window for relevance is finite and we've been designing the
>language for a
>> *long* time at this point.
>
>I understand and share this view, but see it as one side of the story:
>the other 
>side beeing that the language has evolved pretty much in recent times,
>and this 
>in part about several core features (pointer management, traits, basic
>data 
>structures, error handling...). Obviously much remains unclear to the 
>proto-user-base, and is felt as unstable and susceptible to drastic
>evolution 
>still (maybe it's not for you, but maybe you are wrong on this ;-).
>
>I guess a significant number of people would prefere seeing the
>language go on 
>evolving the time needed to have it reach a point where at least core
>constructs 
>look like beeing close to as good as possible (considering the state of
>present 
>knowledge about programming is or should be: read, probably much too
>few). I 
>personly would cry when I see Rust ending up beeing yet another failed 
>replacement for C (for the present, it would be so in part because it's
>much too 
>difficult to use).
>
>Denis
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/172ecad1/attachment.html>

From denis.spir at gmail.com  Mon Dec 30 09:21:30 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 30 Dec 2013 18:21:30 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C16E6E.6090603@active-4.com>
References: <52C16E6E.6090603@active-4.com>
Message-ID: <52C1AB9A.7050908@gmail.com>

On 12/30/2013 02:00 PM, Armin Ronacher wrote:
> Hi,
>
> I am not using Rust nearly as much as I wish I could, but I absolutely love
> playing around with it and seeing where it's heading.  I think all things
> considered the language is going exactly where I want it to go. It's for the
> most part very pleasant to work with and it's getting better and better.
>
> But there is so much more work needed.  Not just because the language is lacking
> things that are needed, but because many users of the language are not sure yet
> how to use it.
>
> The compiler and the standard library use widely different patterns and so do
> libraries written by other people.  There are half a dozen ways to deal with
> errors now, there are different patterns of how to deal with Options and
> Results.  There are vastly different ways to design whole APIs, how to deal with
> the traits and so forth.  There are different patterns to interface with native
> libraries, different patterns to interface with task local data etc.
>
> The introduction of external iterators (which I found the most exciting change
> of the language) has shown a whole new area of shortcomings in the current
> feature set (lack decltype when returning composed iterators for instance, non
> sendable closures etc.).  Not only did it show shortcomings in lacking features,
> it also put some emphasis on new patterns that are not widely deployed in the
> stdlib yet.
>
> I really hope there is left enough time to actually continue evolving the
> language and libraries before freezing anything.  Especially now that the split
> into libnative and libgreen is happening it will be important to stay flexible
> for adjusting the design of the standard library so that we don't end up with
> two vastly different ways to do IO.
>
> It does not take a genius to realize that there is already some tension among
> developers with regards to where the language should be going, and at what pace.
>
> As an outside observer that is very much in love with Rust and where it's
> heading, I want to voice the wish that there will be enough time to continue
> evolving the language before racing to a 1.0 release. Especially now that there
> is a lot of interest in Rust and similar languages I believe this is necessary.
> As it stands right now, there are too many things that make Rust still
> frustrating because you program yourself into a corner.
>
>
> TL;DR: please don't rush a 1.0 release.

+++ ; couldn't have said it better

Question: what is the timeline, if any?

Remark: we programmers have already waited for 40 years for a usable replacement 
for C: safe, meaningful, expressive (and I'm still waiting for it). Rust could 
be it (but not in present or near-future state: much too hard to use). 2, 3, 5 
years more is nothing.

Denis

From pwalton at mozilla.com  Mon Dec 30 09:25:08 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 09:25:08 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C1AA41.7010402@gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C1AA41.7010402@gmail.com>
Message-ID: <fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>

The basic way pointers and traits work are not changing at this point, unless some unsoundness is found. Remaining effort beyond what's on the roadmap is going to focus on documentation.

If you believe the language will fail unless we radically change either one, then all I can say is that I disagree, and I'm sorry Rust is not the language for you.

Patrick

spir <denis.spir at gmail.com> wrote:
>On 12/30/2013 05:29 PM, Patrick Walton wrote:
>> In general I understand the concern, but there are also a huge number
>of people
>> who just want the language to stabilize so that they can use it in
>production.
>> The window for relevance is finite and we've been designing the
>language for a
>> *long* time at this point.
>
>I understand and share this view, but see it as one side of the story:
>the other 
>side beeing that the language has evolved pretty much in recent times,
>and this 
>in part about several core features (pointer management, traits, basic
>data 
>structures, error handling...). Obviously much remains unclear to the 
>proto-user-base, and is felt as unstable and susceptible to drastic
>evolution 
>still (maybe it's not for you, but maybe you are wrong on this ;-).
>
>I guess a significant number of people would prefere seeing the
>language go on 
>evolving the time needed to have it reach a point where at least core
>constructs 
>look like beeing close to as good as possible (considering the state of
>present 
>knowledge about programming is or should be: read, probably much too
>few). I 
>personly would cry when I see Rust ending up beeing yet another failed 
>replacement for C (for the present, it would be so in part because it's
>much too 
>difficult to use).
>
>Denis
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/36f705f8/attachment.html>

From pwalton at mozilla.com  Mon Dec 30 09:35:09 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 09:35:09 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
Message-ID: <36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>

We plan on not breaking code after Rust 1.0, except for gated features. That said, we reserve the right to change things in potentially breaking ways if type/memory unsoundness is discovered. We also might change small, inconsequential things if we're reasonably sure nobody is relying on them--the bar for this is high, however.

Libraries will follow a set of stability level guarantees that vary on a module-by-module basis. Stability encompasses both API level stability and semantic stability: if the semantics change in a way that is likely to break code, we'll introduce a new API instead of modifying a stable one.

There will be plenty of new features added (e.g. unboxed closures, higher kinded type parameters), and we discuss them a lot these days to make sure we don't close them off.

We haven't discussed it, but I assume Rust 2.0 might break things. That will presumably be a long way off though.

Patrick

"G?bor Lehel" <glaebhoerl at gmail.com> wrote:
>It would be helpful to know what the (rough) plan is for after 1.0. A
>series of 1.x releases and later 2.0, or just 2.0? At what kind of time
>scales? What kind of changes will be appropriate for each? (i.e.
>language
>features, bugfixes, compatibility breaks of various forms in various
>places)
>
>How is Rust going to feel about the prospect of backwards-incompatible
>changes after 1.0? Like C++: never ever break anything ever ever?
>
>
>On Mon, Dec 30, 2013 at 5:29 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> On 12/30/13 5:00 AM, Armin Ronacher wrote:
>>
>>> But there is so much more work needed.  Not just because the
>language is
>>> lacking things that are needed, but because many users of the
>language
>>> are not sure yet how to use it.
>>>
>>
>> Documentation is independent of freezing the language definition.
>>
>>
>>  The compiler and the standard library use widely different patterns
>and
>>> so do libraries written by other people.
>>>
>>
>> IMO, the compiler doesn't need to be updated to modern Rust before
>1.0.
>> (`javac` is still not updated to modern Java standards, for example.)
>The
>> standard library does, however.
>>
>>
>>  There are half a dozen ways to
>>> deal with errors now, there are different patterns of how to deal
>with
>>> Options and Results.
>>>
>>
>> These need to be cleaned up before 1.0. Conditions in particular need
>to
>> be removed.
>>
>>
>>  There are vastly different ways to design whole
>>> APIs, how to deal with the traits and so forth.
>>>
>>
>> We'll standardize on something before 1.0. The traits need to be
>> redesigned in general.
>>
>>
>>  There are different
>>> patterns to interface with native libraries, different patterns to
>>> interface with task local data etc.
>>>
>>
>> Are you referencing RAII versus `with_foo` style methods? The latter
>are
>> deprecated and should be removed before 1.0.
>>
>>
>>  The introduction of external iterators (which I found the most
>exciting
>>> change of the language) has shown a whole new area of shortcomings
>in
>>> the current feature set (lack decltype when returning composed
>iterators
>>> for instance,
>>>
>>
>> This is the first time I've heard of this as a missing feature, and
>I'm
>> opposed. This would make typechecking significantly more complex.
>>
>>  non sendable closures etc.).
>>>
>>
>> Is `proc` not sufficient? We could prioritize adding unboxed
>closures, but
>> since they're backwards compatible as far as I know, I don't see a
>major
>> need to add them before 1.0.
>>
>>
>>  Not only did it show
>>> shortcomings in lacking features, it also put some emphasis on new
>>> patterns that are not widely deployed in the stdlib yet.
>>>
>>
>> We need to add them before 1.0, but I personally don't see any major
>> missing language features that we absolutely need to add, except
>those that
>> are already on the roadmap.
>>
>>
>>  I really hope there is left enough time to actually continue
>evolving
>>> the language and libraries before freezing anything.  Especially now
>>> that the split into libnative and libgreen is happening it will be
>>> important to stay flexible for adjusting the design of the standard
>>> library so that we don't end up with two vastly different ways to do
>IO.
>>>
>>
>> We aren't going to freeze the entire standard library for all time
>with
>> 1.0. Instead there will be "stability levels" like node.js (something
>like
>> "frozen", "stabilizing", "unstable", "experimental"). I don't
>anticipate
>> that all of libstd will be frozen before 1.0. Some modules will, and
>other
>> modules will not.
>>
>>
>>  As it stands right now, there
>>> are too many things that make Rust still frustrating because you
>program
>>> yourself into a corner.
>>>
>>
>> It'd be best to file specific issues here. I'm sympathetic to wanting
>to
>> adding more features if they're necessary, but none of the *specific*
>> things mentioned in this post seem like blockers to me.
>>
>> In general I understand the concern, but there are also a huge number
>of
>> people who just want the language to stabilize so that they can use
>it in
>> production. The window for relevance is finite and we've been
>designing the
>> language for a *long* time at this point.
>>
>> Patrick
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/2d2bdb87/attachment.html>

From jurily at gmail.com  Mon Dec 30 09:38:56 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Mon, 30 Dec 2013 18:38:56 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>	<52C1AA41.7010402@gmail.com>
	<fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>
Message-ID: <52C1AFB0.2010608@gmail.com>

On 12/30/2013 06:25 PM, Patrick Walton wrote:
> The basic way pointers and traits work are not changing at this point,
> unless some unsoundness is found. Remaining effort beyond what's on the
> roadmap is going to focus on documentation.
>
> If you believe the language will fail unless we radically change either
> one, then all I can say is that I disagree, and I'm sorry Rust is not
> the language for you.
>
> Patrick

Would it make sense to finalize Rust-the-language 1.0 and keep libstd in 
flux? It would give a head start to IDE writers and help shake the 
feeling of "oh god, I have to fix all my code again".

From pwalton at mozilla.com  Mon Dec 30 09:41:42 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 09:41:42 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C1AFB0.2010608@gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C1AA41.7010402@gmail.com>
	<fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>
	<52C1AFB0.2010608@gmail.com>
Message-ID: <4472e86e-f8e9-48d2-b4ab-518592d5f481@email.android.com>

Yup, that's the plan. :) The idea is to have the language be stable at 1.0, but to have the standard library in varying states of stability, with some modules marked stable and others marked unstable. This approach has worked well for node.js and we're more comfortable doing that as opposed to freezing the standard library in one fell swoop.

Patrick

"Gy?rgy Andrasek" <jurily at gmail.com> wrote:
>On 12/30/2013 06:25 PM, Patrick Walton wrote:
>> The basic way pointers and traits work are not changing at this
>point,
>> unless some unsoundness is found. Remaining effort beyond what's on
>the
>> roadmap is going to focus on documentation.
>>
>> If you believe the language will fail unless we radically change
>either
>> one, then all I can say is that I disagree, and I'm sorry Rust is not
>> the language for you.
>>
>> Patrick
>
>Would it make sense to finalize Rust-the-language 1.0 and keep libstd
>in 
>flux? It would give a head start to IDE writers and help shake the 
>feeling of "oh god, I have to fix all my code again".
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/cf759e31/attachment-0001.html>

From andres.osinski at gmail.com  Mon Dec 30 09:45:44 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Mon, 30 Dec 2013 15:45:44 -0200
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <4472e86e-f8e9-48d2-b4ab-518592d5f481@email.android.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C1AA41.7010402@gmail.com>
	<fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>
	<52C1AFB0.2010608@gmail.com>
	<4472e86e-f8e9-48d2-b4ab-518592d5f481@email.android.com>
Message-ID: <CA+xF-Pwh5NTQDoDQk1gkm2j1D4opV0+RC7z50Zac0kX1sR_j0g@mail.gmail.com>

Question: assuming something like optional/kwargs is eventually introduced
(and I'm assuming at this time everyone understands their usefulness but
has more important things going on in the language) what would happen with
the std, considering those features would open up a plethora of new
function signatures that might deprecate older methods?


On Mon, Dec 30, 2013 at 2:41 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> Yup, that's the plan. :) The idea is to have the language be stable at
> 1.0, but to have the standard library in varying states of stability, with
> some modules marked stable and others marked unstable. This approach has
> worked well for node.js and we're more comfortable doing that as opposed to
> freezing the standard library in one fell swoop.
>
> Patrick
>
> "Gy?rgy Andrasek" <jurily at gmail.com> wrote:
>>
>> On 12/30/2013 06:25 PM, Patrick Walton wrote:
>>
>>> The basic way pointers and traits work are not changing at this point,
>>>
>>> unless some unsoundness is found. Remaining effort beyond what's on the
>>> roadmap is going to focus on documentation.
>>>
>>> If you believe the language will fail unless we radically change either
>>> one, then all I can say is that I disagree, and I'm sorry Rust is not
>>>
>>> the language for you.
>>>
>>> Patrick
>>
>>
>> Would it make sense to finalize Rust-the-language 1.0 and keep libstd in
>> flux? It would give a head start to IDE writers and help shake the
>> feeling of "oh god, I have to fix all my code again".
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Andr?s Osinski
http://www.andresosinski.com.ar/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/4651bcdc/attachment.html>

From thadguidry at gmail.com  Mon Dec 30 09:46:47 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 30 Dec 2013 11:46:47 -0600
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
Message-ID: <CAChbWaOxr4gH2Sc1NqvW56beWjDD1gmaGER+UvnJym_X85oXWg@mail.gmail.com>

>
>
> Libraries will follow a set of stability level guarantees that vary on a
> module-by-module basis. Stability encompasses both API level stability and
> semantic stability: if the semantics change in a way that is likely to
> break code, we'll introduce a new API instead of modifying a stable one.
>
> Patrick
>
>
+1 DEPRECATION, instead of removal.  Thad likes this.

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/ee518eb2/attachment.html>

From pcwalton at mozilla.com  Mon Dec 30 09:49:55 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 09:49:55 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CA+xF-Pwh5NTQDoDQk1gkm2j1D4opV0+RC7z50Zac0kX1sR_j0g@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C1AA41.7010402@gmail.com>
	<fc6e6e06-b861-4464-822f-37a69814ea0b@email.android.com>
	<52C1AFB0.2010608@gmail.com>
	<4472e86e-f8e9-48d2-b4ab-518592d5f481@email.android.com>
	<CA+xF-Pwh5NTQDoDQk1gkm2j1D4opV0+RC7z50Zac0kX1sR_j0g@mail.gmail.com>
Message-ID: <52C1B243.9040306@mozilla.com>

On 12/30/13 9:45 AM, Andres Osinski wrote:
> Question: assuming something like optional/kwargs is eventually
> introduced (and I'm assuming at this time everyone understands their
> usefulness but has more important things going on in the language) what
> would happen with the std, considering those features would open up a
> plethora of new function signatures that might deprecate older methods?

It's a pain, but we'd probably have to live with the bad signatures in 
libstd, or create new labeled versions (like OCaml did), or design the 
feature in such a way as to permit multiple invocation styles of a 
function. This hasn't really been discussed in detail though.

Patrick


From pcwalton at mozilla.com  Mon Dec 30 13:11:27 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 13:11:27 -0800
Subject: [rust-dev] RFC: Future-proof for unboxed closures
Message-ID: <52C1E17F.2010809@mozilla.com>

I've been thinking that to future-proof unboxed closures in the future 
we should maybe limit `|x| x+1` lambda syntax to either (a) require `&` 
in front or (b) in function position.

So today you would write:

     let f = |x| x+1;

But tomorrow you would write:

     let f = &|x| x+1;

But it would always work here:

     v.map(|&x| x+1);

The reason is simply that we'd like `|x| x+1` to become an unboxed 
closure in the future and it's easier in the language semantics to 
future-proof for it this way: we simply special-case the function 
argument position.

Alternatively we can do it with assignability: say that `|x| x+1` is an 
anonymous type (an error today) that is assignable to the type 
`|int|->int`. That might be cleaner than special-casing the function 
argument position.

Patrick

From glaebhoerl at gmail.com  Mon Dec 30 16:59:01 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 31 Dec 2013 01:59:01 +0100
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <52C1E17F.2010809@mozilla.com>
References: <52C1E17F.2010809@mozilla.com>
Message-ID: <CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>

Wouldn't it have to be `&mut` rather than `&` to fit the semantics of | |,
which is affine and can mutate its environment?

And wouldn't this lead to divergence between the type- and value syntax,
with | | as a type being a boxed closure (`&mut FnMut`), and an unboxed
closure as a value? This was one of the nicer points of the recent closure
overhaul, and it would be a shame to lose it so soon.


On Mon, Dec 30, 2013 at 10:11 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> I've been thinking that to future-proof unboxed closures in the future we
> should maybe limit `|x| x+1` lambda syntax to either (a) require `&` in
> front or (b) in function position.
>
> So today you would write:
>
>     let f = |x| x+1;
>
> But tomorrow you would write:
>
>     let f = &|x| x+1;
>
> But it would always work here:
>
>     v.map(|&x| x+1);
>
> The reason is simply that we'd like `|x| x+1` to become an unboxed closure
> in the future and it's easier in the language semantics to future-proof for
> it this way: we simply special-case the function argument position.
>
> Alternatively we can do it with assignability: say that `|x| x+1` is an
> anonymous type (an error today) that is assignable to the type
> `|int|->int`. That might be cleaner than special-casing the function
> argument position.
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/dbb71a17/attachment.html>

From pwalton at mozilla.com  Mon Dec 30 19:31:45 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 19:31:45 -0800
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
Message-ID: <4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>

Yes, it would need to be &mut, you're right.

I think the underlying type syntax would be something like `Fn<int,&int>` for the unboxed version, and `&mut Fn<int,&int>` for the boxed version. The type syntax with the bars is just syntactic sugar for the latter (and, in trait bound position, for the former).

It's somewhat unfortunate but I don't see a particularly good alternative if we want boxed and unboxed closures alike to have nice-looking APIs. The alternative, I guess, is to block 1.0 on unboxed closures, convert all our APIs to unboxed closures where possible, and just say that if you want a boxed closure you have to write `&mut |x| x + 1` at each closure construction site...

Patrick

"G?bor Lehel" <glaebhoerl at gmail.com> wrote:
>Wouldn't it have to be `&mut` rather than `&` to fit the semantics of |
>|,
>which is affine and can mutate its environment?
>
>And wouldn't this lead to divergence between the type- and value
>syntax,
>with | | as a type being a boxed closure (`&mut FnMut`), and an unboxed
>closure as a value? This was one of the nicer points of the recent
>closure
>overhaul, and it would be a shame to lose it so soon.
>
>
>On Mon, Dec 30, 2013 at 10:11 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> I've been thinking that to future-proof unboxed closures in the
>future we
>> should maybe limit `|x| x+1` lambda syntax to either (a) require `&`
>in
>> front or (b) in function position.
>>
>> So today you would write:
>>
>>     let f = |x| x+1;
>>
>> But tomorrow you would write:
>>
>>     let f = &|x| x+1;
>>
>> But it would always work here:
>>
>>     v.map(|&x| x+1);
>>
>> The reason is simply that we'd like `|x| x+1` to become an unboxed
>closure
>> in the future and it's easier in the language semantics to
>future-proof for
>> it this way: we simply special-case the function argument position.
>>
>> Alternatively we can do it with assignability: say that `|x| x+1` is
>an
>> anonymous type (an error today) that is assignable to the type
>> `|int|->int`. That might be cleaner than special-casing the function
>> argument position.
>>
>> Patrick
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131230/c17652be/attachment.html>

From ohler at gnu.org  Mon Dec 30 20:40:58 2013
From: ohler at gnu.org (Christian Ohler)
Date: Mon, 30 Dec 2013 20:40:58 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BE7AF7.3050306@cantrip.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
Message-ID: <CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>

A few thoughts on this:


(1) Unbounded vectors are safe; unbounded channels are unsafe, since
scheduling is nondeterministic.

(2) Use of bounded channels and blocking send is what makes scheduling
"deterministic enough" to be safe.

(3) I'm not worried that bounded channels and blocking sends will
cause deadlocks out of nowhere.

(4) Servo should implement web semantics without pushing them as
requirements into libstd.



In more detail:

(1) Unbounded vectors are safe; unbounded channels are unsafe, since
scheduling is nondeterministic.

The number of elements in a vector is determined by the algorithm,
which the programmer controls.  The number of elements in a channel
is, in many cases, determined by the scheduler, which is not under the
programmer's direct control ? from the programmer's perspective,
scheduling is nondeterministic.  This makes unbounded channels unsafe.

Example: Even if the scheduling is perfectly fair and assigns the same
number of cycles to a producing task and the corresponding consuming
task, the producer can still outrun the consumer if producing a
message takes fewer cycles than consuming one, leading to memory
exhaustion if the channel is unbounded.

Vectors don't have such problems.  We can construct programs where the
size of a vector becomes dependent on scheduling or other
nondeterministic runtime behavior; but channels are inherently tied to
inter-task communication and scheduling, and vectors are not.


(2) Use of bounded channels and blocking send is what makes scheduling
"deterministic enough" to be safe.

A simple way to avoid the above memory exhaustion is making the
channel bounded and blocking on send, so that the scheduler stops the
producer when appropriate, and runs the consumer instead.  Without
blocking on send, the scheduler has no way of knowing that the
consumer should be assigned more cycles than the producer; blocking on
send is the tool that lets the programmer influence the scheduler's
behavior.  (Blocking on receive plays a symmetrical role, but is a
less subtle requirement because of the data dependency.)

Scheduling is nondeterministic, but blocking the sender when the
receiver can't keep up limits the set of possible schedulings to a
safe subset.  (This is a simple example of backpressure and how it
helps.)

Finding the right channel buffer size is a performance tuning problem
similar to finding a good size for a cache.


(3) I'm not worried that bounded channels and blocking sends will
cause deadlocks out of nowhere.

Unbounded channels are unsafe because they make memory consumption
unbounded and outside of the programmer's control; but bounded
channels and blocking sends can lead to deadlocks, so aren't they also
unsafe?

This concern about potential deadlocks was something that really
worried me for a while, but I now suspect that task communication can
usually be structured in patterns that avoid dead ends in the task
communication state machines, eliminating the possibility of
deadlocks.  Bounded channels and blocking sends are unsafe in the
sense that rustc won't be able to reliably detect deadlocks, but the
program design can ensure their absence.

For example, processing might happen in stages, and data flows "left
to right", where tasks are either ready to receive any message from
the left, or blocked sending a specific message to the right.  Since
there is never a mismatch in what the receiver expects and what the
sender sends, nor is there a cycle in the blocking sends, there won't
be deadlocks.

Other code might follow a request-response pattern where a task T
sends requests to a task M that manages a resource, and T passes in a
size-1 response channel with each request and waits for M's response
on that channel.  T blocks until M's request channel is ready to
receive, but the response channel will be used for only one message
and is guaranteed to have room for it, so M's send will not block.
Since M's send will not block, M will only block waiting for requests,
never deadlocking with T.

I haven't thought this through completely, and don?t have a formal
argument, but I am finding these patterns in systems that I?m working
on.  Perhaps this is analogous to how we are generally not worried
that language features like unrestricted function calls and
higher-order functions will make it difficult to avoid infinite
recursion: Programmers have a mental model of how their system is
layered, and they know that calls generally go from higher layers into
lower layers, with few exceptions that they structure in ways that
avoid infinite recursion.


(4) Servo should implement web semantics without pushing them as
requirements into libstd.

Servo needs an unbounded UI event queue, but that doesn't mean libstd
needs to provide unbounded channels.  Mapping the UI event queue
directly to a libstd channel may be a neat match right now, but it
seems prudent to leave servo product features decoupled from libstd
features and being prepared to introduce intermediate layers, since
servo's product requirements can shift.

From ohler at gnu.org  Mon Dec 30 20:46:13 2013
From: ohler at gnu.org (Christian Ohler)
Date: Mon, 30 Dec 2013 20:46:13 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52BA5210.2080100@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<52BA5210.2080100@mozilla.com>
Message-ID: <CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>

On Tue, Dec 24, 2013 at 7:33 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> Suppose you have an photo app that fetches a list of images from the
> network, sorts them by date, and places the result into a folder. You might
> structure it as two tasks, A and B, and two channels, "Images" and "Done". A
> fetches images one by one and places them into the "Images" channel. When
> it's done it sends a ping on the "Done" channel. B waits on the "Done"
> channel, then drains the "Images" channel, sorts the results, and writes the
> result into a folder.
>
> Despite having only one-way communication, this app contains a nasty
> deadlock hazard with bounded channels. If there are more images than the
> size of the "Images" channel then you will deadlock. Your unit tests may not
> catch this, because it only happens if you have a lot of images. Unbounded
> channels do not have this problem.
>
> You could argue that this is bad design, and of course it is bad design if
> you have bounded channels, but one of the purposes of API design is to
> minimize the fallout of ill-thought-through designs.

To address the last sentence ? bounded channels with default size 0
_do_ minimize the fallout of this design: The program would reliably
deadlock every time it is tested with a nonzero number of images,
since A will try to write to "Images" while B is blocked receiving
from "Done", not listening on "Images" yet.  I don't see this deadlock
as a nasty hazard ? the code wouldn't work at all, and the programmer
would immediately notice.  If the programmer uses a non-zero buffer
size for the channel, it's a magic number that they came up with, so
they should know to test inputs around that magnitude.


But it looks like a bad design, regardless of whether channels are
bounded or unbounded:

The processing is sequential, so using two tasks seems rather
contrived.  The natural way to program this would be to read the
images into a vector, sort it, and write them out, all in one task.

If we really want to use two tasks, the first task should read all
images into a vector, then send that vector as part of the "done"
message over the channel.  There is no point in sending the images
one-by-one over the channel if they aren't going to be processed
one-by-one.

Both of these approaches avoid deadlocks.  The approach you describe
uses a channel as nothing but an unbounded buffer.  Using a channel
where a vector is called for, and concluding that channels should
behave more like vectors (by being unbounded), is not very compelling.
 It's a little bit like implementing a loop recursively and concluding
that recursion should behave more like loops, asking for tail call
optimization.


As soon as we switch to an approach where feeding items into a channel
one-by-one makes sense ? by allowing task B to run concurrently with
task A, rather than waiting for "done" ? we immediately benefit from
the boundedness of channels, since they force the scheduler to
allocate cycles to B when A runs too far ahead, keeping the memory
consumption caused by scheduling decisions in check.  B still puts
everything in a vector, so memory consumption is still unbounded; but
that is the way the algorithm works, not a scheduling artifact.

(In this approach, it would also be more natural to have the "done"
message on the same channel as the images.)

From me at kevincantu.org  Mon Dec 30 20:56:57 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Mon, 30 Dec 2013 20:56:57 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
Message-ID: <CABq6+ad5092AmV9k7kY=4cvjumLBYC9BkdWVPsERvd_MfwPCdw@mail.gmail.com>

Does the current API work well enough if we swapped default libs with
hypothetical unbounded channels?  Do we need to hash out what changes
would be necessary, before any implementing?

At some point code will be more valuable than more emails...


Kevin



On Mon, Dec 30, 2013 at 8:40 PM, Christian Ohler <ohler at gnu.org> wrote:
> A few thoughts on this:
>
>
> (1) Unbounded vectors are safe; unbounded channels are unsafe, since
> scheduling is nondeterministic.
>
> (2) Use of bounded channels and blocking send is what makes scheduling
> "deterministic enough" to be safe.
>
> (3) I'm not worried that bounded channels and blocking sends will
> cause deadlocks out of nowhere.
>
> (4) Servo should implement web semantics without pushing them as
> requirements into libstd.
>
>
>
> In more detail:
>
> (1) Unbounded vectors are safe; unbounded channels are unsafe, since
> scheduling is nondeterministic.
>
> The number of elements in a vector is determined by the algorithm,
> which the programmer controls.  The number of elements in a channel
> is, in many cases, determined by the scheduler, which is not under the
> programmer's direct control ? from the programmer's perspective,
> scheduling is nondeterministic.  This makes unbounded channels unsafe.
>
> Example: Even if the scheduling is perfectly fair and assigns the same
> number of cycles to a producing task and the corresponding consuming
> task, the producer can still outrun the consumer if producing a
> message takes fewer cycles than consuming one, leading to memory
> exhaustion if the channel is unbounded.
>
> Vectors don't have such problems.  We can construct programs where the
> size of a vector becomes dependent on scheduling or other
> nondeterministic runtime behavior; but channels are inherently tied to
> inter-task communication and scheduling, and vectors are not.
>
>
> (2) Use of bounded channels and blocking send is what makes scheduling
> "deterministic enough" to be safe.
>
> A simple way to avoid the above memory exhaustion is making the
> channel bounded and blocking on send, so that the scheduler stops the
> producer when appropriate, and runs the consumer instead.  Without
> blocking on send, the scheduler has no way of knowing that the
> consumer should be assigned more cycles than the producer; blocking on
> send is the tool that lets the programmer influence the scheduler's
> behavior.  (Blocking on receive plays a symmetrical role, but is a
> less subtle requirement because of the data dependency.)
>
> Scheduling is nondeterministic, but blocking the sender when the
> receiver can't keep up limits the set of possible schedulings to a
> safe subset.  (This is a simple example of backpressure and how it
> helps.)
>
> Finding the right channel buffer size is a performance tuning problem
> similar to finding a good size for a cache.
>
>
> (3) I'm not worried that bounded channels and blocking sends will
> cause deadlocks out of nowhere.
>
> Unbounded channels are unsafe because they make memory consumption
> unbounded and outside of the programmer's control; but bounded
> channels and blocking sends can lead to deadlocks, so aren't they also
> unsafe?
>
> This concern about potential deadlocks was something that really
> worried me for a while, but I now suspect that task communication can
> usually be structured in patterns that avoid dead ends in the task
> communication state machines, eliminating the possibility of
> deadlocks.  Bounded channels and blocking sends are unsafe in the
> sense that rustc won't be able to reliably detect deadlocks, but the
> program design can ensure their absence.
>
> For example, processing might happen in stages, and data flows "left
> to right", where tasks are either ready to receive any message from
> the left, or blocked sending a specific message to the right.  Since
> there is never a mismatch in what the receiver expects and what the
> sender sends, nor is there a cycle in the blocking sends, there won't
> be deadlocks.
>
> Other code might follow a request-response pattern where a task T
> sends requests to a task M that manages a resource, and T passes in a
> size-1 response channel with each request and waits for M's response
> on that channel.  T blocks until M's request channel is ready to
> receive, but the response channel will be used for only one message
> and is guaranteed to have room for it, so M's send will not block.
> Since M's send will not block, M will only block waiting for requests,
> never deadlocking with T.
>
> I haven't thought this through completely, and don?t have a formal
> argument, but I am finding these patterns in systems that I?m working
> on.  Perhaps this is analogous to how we are generally not worried
> that language features like unrestricted function calls and
> higher-order functions will make it difficult to avoid infinite
> recursion: Programmers have a mental model of how their system is
> layered, and they know that calls generally go from higher layers into
> lower layers, with few exceptions that they structure in ways that
> avoid infinite recursion.
>
>
> (4) Servo should implement web semantics without pushing them as
> requirements into libstd.
>
> Servo needs an unbounded UI event queue, but that doesn't mean libstd
> needs to provide unbounded channels.  Mapping the UI event queue
> directly to a libstd channel may be a neat match right now, but it
> seems prudent to leave servo product features decoupled from libstd
> features and being prepared to introduce intermediate layers, since
> servo's product requirements can shift.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From pcwalton at mozilla.com  Mon Dec 30 20:58:23 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 20:58:23 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>
	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>
	<52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
Message-ID: <52C24EEF.2010104@mozilla.com>

On 12/30/13 8:40 PM, Christian Ohler wrote:
> Example: Even if the scheduling is perfectly fair and assigns the same
> number of cycles to a producing task and the corresponding consuming
> task, the producer can still outrun the consumer if producing a
> message takes fewer cycles than consuming one, leading to memory
> exhaustion if the channel is unbounded.

Unless there's some kind of protocol.

>
> Vectors don't have such problems.  We can construct programs where the
> size of a vector becomes dependent on scheduling or other
> nondeterministic runtime behavior; but channels are inherently tied to
> inter-task communication and scheduling, and vectors are not.

But the size of a vector can be dependent on user input and various 
other things pretty easily as well. I think unbounded channels are no 
worse than vectors.

> For example, processing might happen in stages, and data flows "left
> to right", where tasks are either ready to receive any message from
> the left, or blocked sending a specific message to the right.  Since
> there is never a mismatch in what the receiver expects and what the
> sender sends, nor is there a cycle in the blocking sends, there won't
> be deadlocks.

I gave an example earlier in which deadlocks can happen.

> I haven't thought this through completely, and don?t have a formal
> argument, but I am finding these patterns in systems that I?m working
> on.  Perhaps this is analogous to how we are generally not worried
> that language features like unrestricted function calls and
> higher-order functions will make it difficult to avoid infinite
> recursion: Programmers have a mental model of how their system is
> layered, and they know that calls generally go from higher layers into
> lower layers, with few exceptions that they structure in ways that
> avoid infinite recursion.

But this argument applies equally well to unbounded channels, in that 
you can use them safely as long as you think through the way in which 
you're using them. For example, Servo is architected in such a way so 
that the channels will never overflow, due to the acknowledgement 
pattern among other forms of backpressure.

It is clear that you can implement one on top of the other in both 
directions. The question is how difficult it is to do so, and how much 
performance you lose.

> (4) Servo should implement web semantics without pushing them as
> requirements into libstd.
>
> Servo needs an unbounded UI event queue, but that doesn't mean libstd
> needs to provide unbounded channels.  Mapping the UI event queue
> directly to a libstd channel may be a neat match right now, but it
> seems prudent to leave servo product features decoupled from libstd
> features and being prepared to introduce intermediate layers, since
> servo's product requirements can shift.

Servo is not the only thing that wants unbounded channels. There have 
been other examples of applications that need unbounded channels on this 
very list.

I'm not particularly interested in sacrificing performance by not 
implementing one or the other in libstd. I think it's clear we need both 
forms of channels, and they should be first-class primitives.

Patrick


From pcwalton at mozilla.com  Mon Dec 30 21:16:22 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 30 Dec 2013 21:16:22 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C24EEF.2010104@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com>
Message-ID: <52C25326.3000807@mozilla.com>

Can someone address Simon Marlow's point here?

https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz

 > unbuffered channels are "synchronous" in the sense that both reader
 > and writer must be ready at the same time. It's easy to deadlock if
 > you're not careful. Buffered channels allow asynchronous writes, but
 > only up to the buffer size, so that doesn't actually make things
 > easier. Fully asynchronous channels, like you get in Erlang and
 > Haskell don't have this problem, but they are unbounded so you have
 > to be careful about filling them up (Erlang uses a clever scheduling
 > trick to mitigate that problem, though).?

I am concerned that we are only hearing one side of the argument here, 
and Haskell folks seem to have come down fairly strongly in favor of 
unbounded channels.

To reiterate: At this point I believe we should have both as first-class 
citizens, like `java.util.concurrent`. Choosing one or the other seems 
to be neglecting too many use cases.

Patrick


From james at mansionfamily.plus.com  Mon Dec 30 22:43:27 2013
From: james at mansionfamily.plus.com (james)
Date: Tue, 31 Dec 2013 06:43:27 +0000
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
Message-ID: <52C2678F.5030201@mansionfamily.plus.com>

On 30/12/2013 17:35, Patrick Walton wrote:
> We haven't discussed it, but I assume Rust 2.0 might break things. 
> That will presumably be a long way off though.

As an occasional Python programmer who really prefers Python 3, I'd suggest
that the experience there is that breaking change is not straightforward 
to deliver,
no matter how much goodness there is.

Do you really want to go there?


From carter.schonwald at gmail.com  Mon Dec 30 23:06:17 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 31 Dec 2013 02:06:17 -0500
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2678F.5030201@mansionfamily.plus.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
	<52C2678F.5030201@mansionfamily.plus.com>
Message-ID: <CAHYVw0wfx-_MbV3FQ9FxamKeXvX7MuOdFS-ebWtMwBjPWsuwTw@mail.gmail.com>

as a counter point, in strongly typed languages (of which rust is one), the
type checker is a great aid in fixing breaking changes :). In fact it makes
addressing such breakages quite easy.

This is pretty notable in other strongly typed langs like haskell, when
theres been breaking changes, its usually less than 30 minutes of work to
fix any breakages in an entire code base, with the exception of libraries
that (ab)use exotic experimental features in ways that are tricky to write
otherwise.  IN fact, one breaking change that is scheduled for next year in
haskell actually had the most vocal support from industrial users,
including several organizations that have financial trading systems using
the language.

point being, in a strongly statically typed language, when making (small/
thoughtful) breaking changes to core apis or type system details, its quite
manageable to identify all the points of breakage in client code, and the
main issue is moreso the quality of the error messages. (and theres always
room for better error messages :) ).

admittedly its always ideal to get the design right the first time, but
sometimes its worth it to improve a tool at the expense of its users
(happily) spending half an hour or so placating the type checker after the
language update.

happy new year!
-Carter




On Tue, Dec 31, 2013 at 1:43 AM, james <james at mansionfamily.plus.com> wrote:

> On 30/12/2013 17:35, Patrick Walton wrote:
>
>> We haven't discussed it, but I assume Rust 2.0 might break things. That
>> will presumably be a long way off though.
>>
>
> As an occasional Python programmer who really prefers Python 3, I'd suggest
> that the experience there is that breaking change is not straightforward
> to deliver,
> no matter how much goodness there is.
>
> Do you really want to go there?
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/abb21f2c/attachment-0001.html>

From jeanpierreda at gmail.com  Mon Dec 30 23:15:57 2013
From: jeanpierreda at gmail.com (Devin Jeanpierre)
Date: Mon, 30 Dec 2013 23:15:57 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2678F.5030201@mansionfamily.plus.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
	<52C2678F.5030201@mansionfamily.plus.com>
Message-ID: <CABicbJKe6KJVEcg+O1OirX8wCuT9O-kGF-_GJAHQVXdDpRuSEA@mail.gmail.com>

On Mon, Dec 30, 2013 at 10:43 PM, james <james at mansionfamily.plus.com> wrote:
> As an occasional Python programmer who really prefers Python 3, I'd suggest
> that the experience there is that breaking change is not straightforward to
> deliver,
> no matter how much goodness there is.
>
> Do you really want to go there?

As an occasional Python programmer who really prefers Python 2.6+, I'd
suggest that the experience there is that breaking changes are
reasonably straightforward to deliver as long as they're small enough
and have a sane deprecation window. 2.6 introduced the `with` and `as`
keywords, which broke some code dating from the 2.4 and below era, and
changed strings to not be throwable, with the same effect. Thanks to a
warning in Python 2.5 and a good period of time to effect change, the
migration was made smoothly enough that barely anyone noticed. The
only change in 2.6 I remember causing actual harm to users was
object.__init__ (the constructor of the root class) being changed to
take no parameters. If there had been a deprecation process with
runtime warnings for that too, it might not have broken that one IRC
bot.

Python 2.6 is widely used and adoption didn't suffer, despite
unusually many seriously backwards-incompatible changes. It wasn't all
sunshine and rainbows for everybody, but it wasn't impossible or even
actually particularly difficult for anyone. Backwards incompatible
changes can be made in an organized way that gives time for proper
preparations and ensures a smooth transition. I don't think
Python 3 is the only and most useful example of backwards
compatibility breakage.

-- Devin

From jurily at gmail.com  Tue Dec 31 00:54:46 2013
From: jurily at gmail.com (=?windows-1252?Q?Gy=F6rgy_Andrasek?=)
Date: Tue, 31 Dec 2013 09:54:46 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<52BA5210.2080100@mozilla.com>
	<CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>
Message-ID: <52C28656.4070908@gmail.com>

On 12/31/2013 05:46 AM, Christian Ohler wrote:
> The processing is sequential, so using two tasks seems rather
> contrived.

You're forgetting that Rust tasks are also the unit of isolation.

From denis.spir at gmail.com  Tue Dec 31 01:50:44 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 31 Dec 2013 10:50:44 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CAHYVw0wfx-_MbV3FQ9FxamKeXvX7MuOdFS-ebWtMwBjPWsuwTw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>	<52C2678F.5030201@mansionfamily.plus.com>
	<CAHYVw0wfx-_MbV3FQ9FxamKeXvX7MuOdFS-ebWtMwBjPWsuwTw@mail.gmail.com>
Message-ID: <52C29374.3030804@gmail.com>

On 12/31/2013 08:06 AM, Carter Schonwald wrote:
> as a counter point, in strongly typed languages (of which rust is one), the
> type checker is a great aid in fixing breaking changes :). In fact it makes
> addressing such breakages quite easy.
>
> This is pretty notable in other strongly typed langs like haskell, when
> theres been breaking changes, its usually less than 30 minutes of work to
> fix any breakages in an entire code base, with the exception of libraries
> that (ab)use exotic experimental features in ways that are tricky to write
> otherwise.  IN fact, one breaking change that is scheduled for next year in
> haskell actually had the most vocal support from industrial users,
> including several organizations that have financial trading systems using
> the language.
>
> point being, in a strongly statically typed language, when making (small/
> thoughtful) breaking changes to core apis or type system details, its quite
> manageable to identify all the points of breakage in client code, and the
> main issue is moreso the quality of the error messages. (and theres always
> room for better error messages :) ).
>
> admittedly its always ideal to get the design right the first time, but
> sometimes its worth it to improve a tool at the expense of its users
> (happily) spending half an hour or so placating the type checker after the
> language update.
>
> happy new year!
> -Carter

While I seriously doubt about "30 minutes" for an entire code base (even small) 
(if only because one does not always maintain one's own code, or it's several 
people's code, or one has switched to other projects in the meantime), I do 
otherwise agree because I often break my own code intentionnally after 
rethinking, rewriting or just cleaning low-level utilities (an app's inner lib 
so to say). Usually a quick and easy fix, actually even in dynamically-typed 
langs (even with rather weak typing like Lua).

I also share the last point "sometimes it's worth it to improve". I would not 
count backward compatibility as important as, less so having precedence over, 
language quality (same about libs and tools). Either an envisioned improvement 
makes a significant difference in quality and we _ought to_ do it; or not. In 
any case, this does not prevent making the life of maintainers of existing code 
as nice and easy as possible, but let us not engrave design error in marble ;-) 
as if they were natural laws. [*]
I know this is a very unpopular position thought ;-)

Denis

[*] Not to speak of design errors propagating from "successful" (lol!) languages 
to others. "=" for assignment and "==" for equality is still the source of my 
favorite syntactic mistake, after decades of programming mostly in mainstream 
languages that all implement that funny convention (let's use, say, "if" instead 
of "try", and then have, say, "switch" or "altern" [or "iff"!] mean "if" as a 
replacement).



From jurily at gmail.com  Tue Dec 31 01:53:47 2013
From: jurily at gmail.com (=?UTF-8?B?R3nDtnJneSBBbmRyYXNlaw==?=)
Date: Tue, 31 Dec 2013 10:53:47 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C25326.3000807@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>
	<52C25326.3000807@mozilla.com>
Message-ID: <52C2942B.2010608@gmail.com>

On 12/31/2013 06:16 AM, Patrick Walton wrote:
> I am concerned that we are only hearing one side of the argument here,
> and Haskell folks seem to have come down fairly strongly in favor of
> unbounded channels.

Haskell also has laziness, garbage collection and immutable shared data 
structures. They don't really care about memory usage before they've 
actually gone OOM.

Still, even STM has semaphores and bounded queues, and the user is 
expected to choose the right data structure for their needs. Also, it's 
trivial to write an STM function that can select on different channels 
if the write blocks.

From denis.spir at gmail.com  Tue Dec 31 03:56:39 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 31 Dec 2013 12:56:39 +0100
Subject: [rust-dev] on quality & success
Message-ID: <52C2B0F7.2000103@gmail.com>

Hol?!

[This is a rather personal and involved post. Press del if you feel like it...]
[also, it is long]
[copy to rust-dev mailing list: actually the post is inspired by a thread there 
"Thoughts on the Rust Roadmap"]

There is a point obvious to me; apparently most people including many language 
designers don't share it, or act as if they did not:

     a language should be successful iff it is of high quality

A kind of symmetric statement also holds;

     let us hope low quality languages have no success!

There are various reasons to hope this, the most stupid beeing that successful 
languages influence others, present & future. This is in my view a symptom of 
our civilisation's funny spirit (read: madness), and related to the actual 
points I intend to state (if, for once, I manage to express my thought).

Apparently, many language designers proceed more or less the following way: 
there are a few key points (for them) they consider mis-designed or missing or 
wrong in some way in existing languages (not all the same for every language). 
Thus, they want to make a language that repairs these points, all together. 
Then, certainly in fear that too many changes may repel potential adopters of 
their language, in hope to maximise its chances of success *despite* it breaking 
habits on the key points more important to them, they won't change anything 
else, or only the bare minimum they can. They want instead to remain as 
mainstream as possible on everything else. [4]

I consider this spirit bad; I mean, very bad. This is the way basic design 
errors propagate from successful languages to others, for instance. [1] 
Apparently, it takes a great dose of courage to break any existing practice in a 
_new_ language: tell me why, I do not understand.

Note that I am here talking of wrong design points in the opinion of a given 
language designer. Choices he (since it's mostly men) would not do if 
programming were a new field, open to all explorations. (There are indeed loads 
of subjective or ideological design points; see also [1] & [3]) However, while 
programming is not a new field anymore, it is indeed open to all explorations, 
for you, for me, if you or me wants it. Nothing blocks us but our own 
bloackages, our own fears, and, probably, wrong rationales, perhaps 
non-fully-conscious ones.

Deciding to reuse wrong, but mainstream, design decisions in one's own language 
is deciding to intentionally make it of lower quality. !!! Funny (read: mad), 
isn't it? It is thus also intentionally deciding to make it not worth success. 
This, apparently, to make its actual chances of success higher. (Isn't our 
culture funny?)
Then, why does one _actually_ make a new language? For the joy of making 
something good? To contribute to a better world, since languages and programming 
are a common good? [2] For the joy of offering something of as high a quality as 
humanly possible? Else, why? For fame, honour, status, money, power? To mentally 
masturbate on the idea of having made something "sucessful" (sic!)?

We are not in need of yet another language trying, or pretending, to improve on 
a handful of disparate points, leaving all the rest as is, meaning in bad state. 
And, as an example, we are not in need of yet another failed trial for a 
successor to C as major low-level lang.
Differences, thought of by their designer as significant quality improvements, 
are the *reasons* for programmers to adopt a new language. There are the _only_ 
(good) reasons to do so. Thinking that programmers may adopt a new language 
_despite_ its differences is thinking backwards; this, in addition to preventing 
oneself from working for the common good; by fear, probably; fear of truely 
thinking by oneself and/or of making one's true thinking public truely. (I can 
understand that, however: I often do not disclose my thinking by fear of the 
terrible level of violence, in my view, present in the programming "community" 
[hum!], and among geeks in general. This, rather than sharing and mutual help 
and cooperation, for the common wealth. Our civilisation... again.)

I have recently decided to adopt possible differences even if i am not that 
convinced of their betterness; to give alternatives a try; to give them at least 
a chance to show us (or just me) how good they actually are, or not, in 
practice, maybe on the long term [3].
This may go too far; it is a personal decision.

However, deciding not to change what one sees wrong is weird for the least. It 
means removing points of quality according to one's own views, removing chances 
to contrbute to a better world, removing sources of personal satisfaction, 
removing reasons for others to judge a language better, thus removing motivation 
for programmers to adopt it. Maybe, certainly, many programmers do not adopt a 
language on the base of its quality, only; however, this counts; people I wish 
would adopt my lang, if ever, are those people who judge first on quality, not 
hype followers or otherwise conservatives.
What I mean is, apart from working against the common wealth, in addition to 
preventing one's own enjoyment of doing what one does, such an attitude may also 
work against a language's potential success. Is this (a factor) why we have no 
successor to C yet, what do you think? because most designers kept most of its 
design bugs unchanged? [4] just to have a minimal chance, should a potential 
successor instead break as much as possible? (And not have a builtin interface 
to C? ???)

Also note that attitudes and spirits are psycho-sociologically contagious. In 
particular, fear and lack of courage and angst are highly contagious (in our 
world, with such a close to universal high level of anxiety...) What if more 
(would-be) language designers boldly thought by themselves and boldly assumed 
their thoughts?

Final note: isn't it weird that such conformism is _that_ prevalent among 
language designers? Precisely the ones who should be bearers of novelty? the one 
"milieu" which could & should be a network of interacting counter-cultures and 
individual iconoclasts (idol breakers)?

I do not expect anyone shares (all of) this. I just hope it may open new ways of 
thinking or questionning to a few.

Denis

[1] Including the funny usage of "=" for assignment and "==" for equality, after 
at least 5 decades, lol! Still my favorite syntactic error after dozens of 
thousands of hours of programming in languages which nearly all use this amusing 
convention. Why not use "if" to mean 'try' or 'switch' or 'foreach', and "ifif" 
to mean 'if'? What do you think?

[2] Actually, they are both communal and social. Better quality languages may 
contribute to a better world, at a communal level because we programmers share 
code and read others' code all the time, and at a social level because apps are 
a significant part of the world's state.

[3] As you certainly know, it takes time to unlearn, especially to stop judging 
something bad while it is just different. (Think at C programmers and their 
beloved code block {} braces. I for one have better usage for brace ;-.)

[4] As an anecdote, somewhat complementary, in the course of my explorations 
about programming languages, I often stepped on lists of C design bugs, at least 
a dozen of them. Typically endless lists that take a quarter of an hour to read 
in one go, without comments. There is space to works for a language lover :-). 
If not enough, usually such critics seems to agree on more than half of the 
points (and the remaining ones may not figure on some lists just because the 
critic not think at it or did not study this point) (but their solutions may 
diverge...).





From smadhueagle at outlook.com  Tue Dec 31 04:36:00 2013
From: smadhueagle at outlook.com (Madhu Srinivasan)
Date: Tue, 31 Dec 2013 12:36:00 +0000
Subject: [rust-dev] Using libgreen/libnative
In-Reply-To: <52BF77CA.3040302@mozilla.com>
References: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>,
	<52BF77CA.3040302@mozilla.com>
Message-ID: <DUB122-W354C5FDD8B68E11F42ACCCB0C90@phx.gbl>

This is great !!
Quick question - it seems like rustpkg is still unaware of libnative and libgreen ?
I am trying to compile the example code from alex (and some other examples) with rustpkg with the following error:








> rustpkg build test
WARNING: The Rust package manager is experimental and may be unstable
error: Package test depends on native, but I don't know how to find it
task '<unnamed>' failed at 'explicit failure', /private/tmp/rust-yVG2/src/librustpkg/util.rs:528
task '<unnamed>' failed at 'receiving on a closed channel', /private/tmp/rust-yVG2/src/libstd/comm/mod.rs:728
However, rustc does it just fine ... 
> rustc  -o bin/test src/test/main.rs >








Wondering if there is a pending issue with rustpkg ? I am happy (and prefer) to use rustc anyways!
Great work !!
Dr. Madhu Srinivasan

> Date: Sat, 28 Dec 2013 17:15:54 -0800
> From: banderson at mozilla.com
> To: rust-dev at mozilla.org
> Subject: Re: [rust-dev] Using libgreen/libnative
> 
> Thanks for writing this up, Alex. The improvements you've made to the 
> runtime recently are very impressive. Now we've got nearly complete and 
> reasonably fast I/O, fast message passing, a scheduler-agnostic standard 
> library, and very soon an embeddable runtime and a standard library that 
> can be used in almost any environment. After years of iteration I'm 
> hopeful that we're finally converging on a good design for the runtime.
> 
> 
> On 12/28/2013 10:37 AM, Alex Crichton wrote:
> > Greetings rusticians!
> >
> > Recently pull request #10965 landed, so the rust standard library no longer has
> > any scheduling baked into it, but rather it's refactored out into two libraries.
> > This means that if you want a 1:1 program, you can jettison all M:N support with
> > just a few `extern mod` statements. A brief overview of the current state of
> > things is:
> >
> > 1. All programs not using std::rt directly should still continue to operate as
> >     usual today
> > 2. All programs still start up in M:N mode, although this will likely change
> >     once 1:1 I/O work has been completed
> > 3. There are two more libraries available, libgreen and libnative, which allow
> >     custom fine-grained control over how programs run.
> > 4. Whenever a new task is spawned, it is by default spawned as a "sibling" which
> >     means that it is spawned in the same mode as the spawning thread. This means
> >     that if a green thread spawns a thread then it will also be a green thread,
> >     while a native thread will spawn another OS thread.
> >
> > With this migration, there have been a few changes in the public APIs, and
> > things still aren't quite where I'd like them to be. PR #11153 is the last major
> > step in this process as it allows you to link to both libnative and libgreen,
> > yet still choose which one is used to boot your program. Some breaking changes
> > you may notice are:
> >
> > * it's still not possible to easily start up in 1:1 mode - This is fixed by
> >    #11153. In the meantime, you can use #[start] with native::start in order to
> >    boot up in 1:1 mode. Be warned though that the majority of I/O is still
> >    missing from libnative (see PR #11159 for some progress)
> >
> >        https://gist.github.com/8162357
> >
> > * std::rt::{start, run} are gone - These are temporarily moved into green/native
> >    while #[boot] is getting sorted out. The green/native counterparts perform as
> >    you would expect.
> >
> >        https://gist.github.com/8162372
> >
> > * std::rt::start_on_main_thread is gone - This function has been removed with no
> >    direct counterpart. As a consequence of refactoring the green/native
> >    libraries, the "single threaded" spawn mode for a task has been removed (this
> >    doesn't make sense in 1:1 land). This behavior can be restored by directly
> >    using libnative and libgreen. You can use libgreen to spin up a pool of
> >    schedulers and then use libnative for the main task to do things like GUI
> >    management.
> >
> >        https://gist.github.com/8162399
> >
> > And of course with the removal of some features comes the addition of new ones!
> > Some new things you may notice are:
> >
> > * libstd is no longer burdened with libgreen and libnative! This means that the
> >    compile times for libstd should be a little faster, but most notably those
> >    applications only using libstd will have even less code pulled in than before,
> >    meaning that libstd is that much closer to being used in a "bare metal"
> >    context. It's still aways off, but we're getting closer every day!
> >
> > * libgreen has a full-fleged SchedPool type. You can see a bit of how it's used
> >    in gist I posted above. This type is meant to represent a dynamic pool of
> >    schedulers. Right now it's not possible to remove a scheduler from the pool
> >    (requires some more thought and possibly libuv modifications), but you can add
> >    new schedulers dynamically to the pool.
> >
> >    This type supercedes the ThreadPool type in libextra at this point, and
> >    management of a SchedPool should provide any fine-grained control needed over
> >    the 'M' number in an M:N runtime.
> >
> > * libgreen and libnative can be used directly to guarantee spawning a green or a
> >    native task, regardless of the flavor of task that is doing the spawning.
> >
> > In the coming months, I plan on filling out more native I/O to bring it up to
> > speed with the M:N implementation. I also plan on rewriting the core components
> > of extra::comm to be performant in both scheduling modes in order to bring the
> > extra::{comm, arc, sync} primitives up to date with their std::comm
> > counterparts.
> >
> > If there are any questions about any of this, feel free to ask me! This thread
> > is always available, and I'm also reachable as acrichto on IRC or alexcrichton
> > on github.
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/b4d11d80/attachment.html>

From till at tillschneidereit.net  Tue Dec 31 04:43:57 2013
From: till at tillschneidereit.net (Till Schneidereit)
Date: Tue, 31 Dec 2013 13:43:57 +0100
Subject: [rust-dev] on quality & success
In-Reply-To: <52C2B0F7.2000103@gmail.com>
References: <52C2B0F7.2000103@gmail.com>
Message-ID: <CAD0sBY5ESCepQ615H8s=FQydWCOMbnrxhLjHdOmR8GdKkBgOcQ@mail.gmail.com>

Without responding to everything in your message, two quick points:

For being written by someone afraid 'of the terrible level of violence, in
[your] view, present in the programming "community"', your message is
awfully condecending and dismissive of a huge amount of hard work by
curageous people. The Rust designers have made it very clear that they
don't share your views on how much the language should differ from
pre-existing widely-used languages. You seem to say that that necessarily
means that they're conformist cowards who only do their work for 'fame,
honour, status, money, power' or '[t]o mentally masturbate on the idea of
having made something "sucessful"'. Would you say that to someone's face?
If not (actually, regardless), please don't do it on a mailing list.

As for your main argument (as far as I understand it), that languages are
designed too timidly, I quite simply don't believe that you don't see the
argument that a language might not be adopted if it breaks with too many
conventions that people have gotten used to. You're saying that you'll
gladly try out languages that break with everything you learned before.
That's commendable, but not something a language designer can expect of
everyone in their target audience. Now you might disagree with the strategy
of introducing enough change to make the language clearly superior to its
competition, while keeping the learning curve bearable. Please don't
dismiss it as "madness" you don't even need to argue against, though.


On Tue, Dec 31, 2013 at 12:56 PM, spir <denis.spir at gmail.com> wrote:

> Hol?!
>
> [This is a rather personal and involved post. Press del if you feel like
> it...]
> [also, it is long]
> [copy to rust-dev mailing list: actually the post is inspired by a thread
> there "Thoughts on the Rust Roadmap"]
>
> There is a point obvious to me; apparently most people including many
> language designers don't share it, or act as if they did not:
>
>     a language should be successful iff it is of high quality
>
> A kind of symmetric statement also holds;
>
>     let us hope low quality languages have no success!
>
> There are various reasons to hope this, the most stupid beeing that
> successful languages influence others, present & future. This is in my view
> a symptom of our civilisation's funny spirit (read: madness), and related
> to the actual points I intend to state (if, for once, I manage to express
> my thought).
>
> Apparently, many language designers proceed more or less the following
> way: there are a few key points (for them) they consider mis-designed or
> missing or wrong in some way in existing languages (not all the same for
> every language). Thus, they want to make a language that repairs these
> points, all together. Then, certainly in fear that too many changes may
> repel potential adopters of their language, in hope to maximise its chances
> of success *despite* it breaking habits on the key points more important to
> them, they won't change anything else, or only the bare minimum they can.
> They want instead to remain as mainstream as possible on everything else.
> [4]
>
> I consider this spirit bad; I mean, very bad. This is the way basic design
> errors propagate from successful languages to others, for instance. [1]
> Apparently, it takes a great dose of courage to break any existing practice
> in a _new_ language: tell me why, I do not understand.
>
> Note that I am here talking of wrong design points in the opinion of a
> given language designer. Choices he (since it's mostly men) would not do if
> programming were a new field, open to all explorations. (There are indeed
> loads of subjective or ideological design points; see also [1] & [3])
> However, while programming is not a new field anymore, it is indeed open to
> all explorations, for you, for me, if you or me wants it. Nothing blocks us
> but our own bloackages, our own fears, and, probably, wrong rationales,
> perhaps non-fully-conscious ones.
>
> Deciding to reuse wrong, but mainstream, design decisions in one's own
> language is deciding to intentionally make it of lower quality. !!! Funny
> (read: mad), isn't it? It is thus also intentionally deciding to make it
> not worth success. This, apparently, to make its actual chances of success
> higher. (Isn't our culture funny?)
> Then, why does one _actually_ make a new language? For the joy of making
> something good? To contribute to a better world, since languages and
> programming are a common good? [2] For the joy of offering something of as
> high a quality as humanly possible? Else, why? For fame, honour, status,
> money, power? To mentally masturbate on the idea of having made something
> "sucessful" (sic!)?
>
> We are not in need of yet another language trying, or pretending, to
> improve on a handful of disparate points, leaving all the rest as is,
> meaning in bad state. And, as an example, we are not in need of yet another
> failed trial for a successor to C as major low-level lang.
> Differences, thought of by their designer as significant quality
> improvements, are the *reasons* for programmers to adopt a new language.
> There are the _only_ (good) reasons to do so. Thinking that programmers may
> adopt a new language _despite_ its differences is thinking backwards; this,
> in addition to preventing oneself from working for the common good; by
> fear, probably; fear of truely thinking by oneself and/or of making one's
> true thinking public truely. (I can understand that, however: I often do
> not disclose my thinking by fear of the terrible level of violence, in my
> view, present in the programming "community" [hum!], and among geeks in
> general. This, rather than sharing and mutual help and cooperation, for the
> common wealth. Our civilisation... again.)
>
> I have recently decided to adopt possible differences even if i am not
> that convinced of their betterness; to give alternatives a try; to give
> them at least a chance to show us (or just me) how good they actually are,
> or not, in practice, maybe on the long term [3].
> This may go too far; it is a personal decision.
>
> However, deciding not to change what one sees wrong is weird for the
> least. It means removing points of quality according to one's own views,
> removing chances to contrbute to a better world, removing sources of
> personal satisfaction, removing reasons for others to judge a language
> better, thus removing motivation for programmers to adopt it. Maybe,
> certainly, many programmers do not adopt a language on the base of its
> quality, only; however, this counts; people I wish would adopt my lang, if
> ever, are those people who judge first on quality, not hype followers or
> otherwise conservatives.
> What I mean is, apart from working against the common wealth, in addition
> to preventing one's own enjoyment of doing what one does, such an attitude
> may also work against a language's potential success. Is this (a factor)
> why we have no successor to C yet, what do you think? because most
> designers kept most of its design bugs unchanged? [4] just to have a
> minimal chance, should a potential successor instead break as much as
> possible? (And not have a builtin interface to C? ???)
>
> Also note that attitudes and spirits are psycho-sociologically contagious.
> In particular, fear and lack of courage and angst are highly contagious (in
> our world, with such a close to universal high level of anxiety...) What if
> more (would-be) language designers boldly thought by themselves and boldly
> assumed their thoughts?
>
> Final note: isn't it weird that such conformism is _that_ prevalent among
> language designers? Precisely the ones who should be bearers of novelty?
> the one "milieu" which could & should be a network of interacting
> counter-cultures and individual iconoclasts (idol breakers)?
>
> I do not expect anyone shares (all of) this. I just hope it may open new
> ways of thinking or questionning to a few.
>
> Denis
>
> [1] Including the funny usage of "=" for assignment and "==" for equality,
> after at least 5 decades, lol! Still my favorite syntactic error after
> dozens of thousands of hours of programming in languages which nearly all
> use this amusing convention. Why not use "if" to mean 'try' or 'switch' or
> 'foreach', and "ifif" to mean 'if'? What do you think?
>
> [2] Actually, they are both communal and social. Better quality languages
> may contribute to a better world, at a communal level because we
> programmers share code and read others' code all the time, and at a social
> level because apps are a significant part of the world's state.
>
> [3] As you certainly know, it takes time to unlearn, especially to stop
> judging something bad while it is just different. (Think at C programmers
> and their beloved code block {} braces. I for one have better usage for
> brace ;-.)
>
> [4] As an anecdote, somewhat complementary, in the course of my
> explorations about programming languages, I often stepped on lists of C
> design bugs, at least a dozen of them. Typically endless lists that take a
> quarter of an hour to read in one go, without comments. There is space to
> works for a language lover :-). If not enough, usually such critics seems
> to agree on more than half of the points (and the remaining ones may not
> figure on some lists just because the critic not think at it or did not
> study this point) (but their solutions may diverge...).
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/595619e7/attachment-0001.html>

From matthieu.monrocq at gmail.com  Tue Dec 31 05:33:35 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Tue, 31 Dec 2013 14:33:35 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C25326.3000807@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C25326.3000807@mozilla.com>
Message-ID: <CAKE6Rfj-UtXYud+LtBw05FoWWfwrzuBsvRXW1hPkbVU7TaNkyg@mail.gmail.com>

On Tue, Dec 31, 2013 at 6:16 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> Can someone address Simon Marlow's point here?
>
> https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz
>
> > unbuffered channels are "synchronous" in the sense that both reader
> > and writer must be ready at the same time. It's easy to deadlock if
> > you're not careful. Buffered channels allow asynchronous writes, but
> > only up to the buffer size, so that doesn't actually make things
> > easier. Fully asynchronous channels, like you get in Erlang and
> > Haskell don't have this problem, but they are unbounded so you have
> > to be careful about filling them up (Erlang uses a clever scheduling
> > trick to mitigate that problem, though).
>
>
I am concerned that we are only hearing one side of the argument here, and
> Haskell folks seem to have come down fairly strongly in favor of unbounded
> channels.
>
> It also seems to me that the argument is partial, and only consider
blocking sends. It would be interesting to know if they envisaged
non-blocking sends and if so why they seem to have been discarded.


> To reiterate: At this point I believe we should have both as first-class
> citizens, like `java.util.concurrent`. Choosing one or the other seems to
> be neglecting too many use cases.
>
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/7a26226c/attachment.html>

From armin.ronacher at active-4.com  Tue Dec 31 05:55:45 2013
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Tue, 31 Dec 2013 14:55:45 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C19F75.5090703@mozilla.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
Message-ID: <52C2CCE1.8050503@active-4.com>

Hi,

On 30/12/2013 17:29, Patrick Walton wrote:
> This is the first time I've heard of this as a missing feature, and I'm
> opposed. This would make typechecking significantly more complex.
I'm not saying someone should add decltype :)  Just that from using the 
iterators we have now it becomes quite obvious that there are missing 
tools to use them to the fullest extend.

> Is `proc` not sufficient? We could prioritize adding unboxed closures,
> but since they're backwards compatible as far as I know, I don't see a
> major need to add them before 1.0.
Procs can be called once.

> It'd be best to file specific issues here. I'm sympathetic to wanting to
> adding more features if they're necessary, but none of the *specific*
> things mentioned in this post seem like blockers to me.
I will surely file issues for things that i encounter.  It's just that I 
was a bit surprised to see that there are ambitions to stabilize the 
language quickly.  It just feels like that might be to early.

Being active in the Python community I can tell you that a Python 3.0 
was the worst decision ever.  It would be a shame if a Rust 2.0 suffers 
from the same problems.


Regards,
Armin


From dbau.pp at gmail.com  Tue Dec 31 06:09:31 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 01 Jan 2014 01:09:31 +1100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2CCE1.8050503@active-4.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
Message-ID: <52C2D01B.6050408@gmail.com>

On 01/01/14 00:55, Armin Ronacher wrote:
> Hi,
>
> On 30/12/2013 17:29, Patrick Walton wrote:
>> This is the first time I've heard of this as a missing feature, and I'm
>> opposed. This would make typechecking significantly more complex.
> I'm not saying someone should add decltype :)  Just that from using 
> the iterators we have now it becomes quite obvious that there are 
> missing tools to use them to the fullest extend.
>

If we were to have unboxed closures similar to C++, where each closure 
is an (implicit) unique type, we'd likely need something like decltype 
(well, decltype(auto)) to make it possible to return them and things 
containing them, e.g. higher-order iterators like .map and .filter.

(cc https://github.com/mozilla/rust/issues/3228 and 
https://github.com/mozilla/rust/issues/10448)



Huon

>> Is `proc` not sufficient? We could prioritize adding unboxed closures,
>> but since they're backwards compatible as far as I know, I don't see a
>> major need to add them before 1.0.
> Procs can be called once.
>
>> It'd be best to file specific issues here. I'm sympathetic to wanting to
>> adding more features if they're necessary, but none of the *specific*
>> things mentioned in this post seem like blockers to me.
> I will surely file issues for things that i encounter.  It's just that 
> I was a bit surprised to see that there are ambitions to stabilize the 
> language quickly.  It just feels like that might be to early.
>
> Being active in the Python community I can tell you that a Python 3.0 
> was the worst decision ever.  It would be a shame if a Rust 2.0 
> suffers from the same problems.
>
>
> Regards,
> Armin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From oren at ben-kiki.org  Tue Dec 31 06:15:17 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 31 Dec 2013 16:15:17 +0200
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2CCE1.8050503@active-4.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
Message-ID: <CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>

Not to re-ignite the thread about this, but one way `proc`s aren't
sufficient because they are send-able (that is, allocated on the heap).
Rust lacks a call-once stack-allocated closure types, which are immensely
useful for manipulating container elements, creating DSL-ish syntax, etc.

That's separate from the `decltype` issue, though.

On Tue, Dec 31, 2013 at 3:55 PM, Armin Ronacher <armin.ronacher at active-4.com
> wrote:

> Hi,
>
> On 30/12/2013 17:29, Patrick Walton wrote:
>
>> Is `proc` not sufficient? We could prioritize adding unboxed closures,
>>
> but since they're backwards compatible as far as I know, I don't see a
>> major need to add them before 1.0.
>>
> Procs can be called once.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/f57c0cd1/attachment.html>

From danielmicay at gmail.com  Tue Dec 31 06:20:49 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 31 Dec 2013 09:20:49 -0500
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
Message-ID: <CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>

On Tue, Dec 31, 2013 at 9:15 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> Not to re-ignite the thread about this, but one way `proc`s aren't
> sufficient because they are send-able (that is, allocated on the heap). Rust
> lacks a call-once stack-allocated closure types, which are immensely useful
> for manipulating container elements, creating DSL-ish syntax, etc.
>
> That's separate from the `decltype` issue, though.

Closures don't need to be heap-allocated to be `Send`. An unboxed
closure with only `Send` captures would be `Send` itself too.

From dbau.pp at gmail.com  Tue Dec 31 06:23:50 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 01 Jan 2014 01:23:50 +1100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
Message-ID: <52C2D376.8080409@gmail.com>

On 01/01/14 01:15, Oren Ben-Kiki wrote:
> Not to re-ignite the thread about this, but one way `proc`s aren't 
> sufficient because they are send-able (that is, allocated on the 
> heap). Rust lacks a call-once stack-allocated closure types, which are 
> immensely useful for manipulating container elements, creating DSL-ish 
> syntax, etc.
>

(Nitpick, being sendable and being allocated on the heap are independent 
in general. e.g. int is sendable, but isn't heap allocated (if we get 
unboxed closures that capture things by value, we'll likely be able to 
send them too despite not necessarily being heap allocated), and ~(@int) 
is heap allocated, but isn't sendable.)

> That's separate from the `decltype` issue, though.
>
> On Tue, Dec 31, 2013 at 3:55 PM, Armin Ronacher 
> <armin.ronacher at active-4.com <mailto:armin.ronacher at active-4.com>> wrote:
>
>     Hi,
>
>     On 30/12/2013 17:29, Patrick Walton wrote:
>
>         Is `proc` not sufficient? We could prioritize adding unboxed
>         closures,
>
>         but since they're backwards compatible as far as I know, I
>         don't see a
>         major need to add them before 1.0.
>
>     Procs can be called once.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140101/588f75a7/attachment-0001.html>

From oren at ben-kiki.org  Tue Dec 31 06:26:34 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 31 Dec 2013 16:26:34 +0200
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
Message-ID: <CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>

The point is that sometimes you really *don't* want the closure to be
send-able, because you want it to access from the surrounding context both
owned pointers (-> be called-once) _and also_ borrowed pointers (-> be
stack-allocated). This is vital for some use cases and is impossible today
(ok, possible by painfully wrapping a cell around each owned pointer and
taking its value in the stack closure).


On Tue, Dec 31, 2013 at 4:20 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Dec 31, 2013 at 9:15 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> > Not to re-ignite the thread about this, but one way `proc`s aren't
> > sufficient because they are send-able (that is, allocated on the heap).
> Rust
> > lacks a call-once stack-allocated closure types, which are immensely
> useful
> > for manipulating container elements, creating DSL-ish syntax, etc.
> >
> > That's separate from the `decltype` issue, though.
>
> Closures don't need to be heap-allocated to be `Send`. An unboxed
> closure with only `Send` captures would be `Send` itself too.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/19f334c4/attachment.html>

From pcwalton at mozilla.com  Tue Dec 31 06:27:52 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 06:27:52 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2678F.5030201@mansionfamily.plus.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<CAPoegsxs7X3E8v884842NzUK_LEdoEW=OmqqwHyTsLYZ7-GgOg@mail.gmail.com>
	<36437c7a-ae2c-48a8-bd6e-366ca41ca98b@email.android.com>
	<52C2678F.5030201@mansionfamily.plus.com>
Message-ID: <52C2D468.9070706@mozilla.com>

On 12/30/13 10:43 PM, james wrote:
> On 30/12/2013 17:35, Patrick Walton wrote:
>> We haven't discussed it, but I assume Rust 2.0 might break things.
>> That will presumably be a long way off though.
>
> As an occasional Python programmer who really prefers Python 3, I'd suggest
> that the experience there is that breaking change is not straightforward
> to deliver,
> no matter how much goodness there is.
>
> Do you really want to go there?
>

To be honest, we literally haven't ever talked about what Rust 2.0 would 
or wouldn't break, as far as I recall. It might well not break anything. 
Consider that a throwaway comment and don't read too much into it :)

Patrick


From pcwalton at mozilla.com  Tue Dec 31 06:29:27 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 06:29:27 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>
Message-ID: <52C2D4C7.80807@mozilla.com>

On 12/31/13 6:26 AM, Oren Ben-Kiki wrote:
> The point is that sometimes you really *don't* want the closure to be
> send-able, because you want it to access from the surrounding context
> both owned pointers (-> be called-once) _and also_ borrowed pointers (->
> be stack-allocated). This is vital for some use cases and is impossible
> today (ok, possible by painfully wrapping a cell around each owned
> pointer and taking its value in the stack closure).

You can do all of that with unboxed closures.

Patrick


From oren at ben-kiki.org  Tue Dec 31 06:39:39 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 31 Dec 2013 16:39:39 +0200
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2D4C7.80807@mozilla.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>
	<52C2D4C7.80807@mozilla.com>
Message-ID: <CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>

Great news... I'll admit I have no idea what "unboxed closures" are,
exactly, google wasn't helpful finding out a post clearly describing them.
The example in
http://www.mail-archive.com/rust-dev at mozilla.org/msg07569.html shows
passing a closure to a map, so it obviously isn't a call-once so it can't
consume an owned pointer. E.g., if it was `|&x| x +
f(move-some-owned-pointer-from-the-context-to-be-consumed-by-f)`, then it
wouldn't - and shouldn't - work.

But writing something like my_container.modify_value_of_existing_key(key,
|&old| f(old, move-some-owned-pointer-from-context))` should work - I don't
see how both closures can have the same type.


On Tue, Dec 31, 2013 at 4:29 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/31/13 6:26 AM, Oren Ben-Kiki wrote:
>
>> The point is that sometimes you really *don't* want the closure to be
>> send-able, because you want it to access from the surrounding context
>> both owned pointers (-> be called-once) _and also_ borrowed pointers (->
>> be stack-allocated). This is vital for some use cases and is impossible
>> today (ok, possible by painfully wrapping a cell around each owned
>> pointer and taking its value in the stack closure).
>>
>
> You can do all of that with unboxed closures.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/8f8683d5/attachment.html>

From pcwalton at mozilla.com  Tue Dec 31 06:42:39 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 06:42:39 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com>	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>	<52C2D4C7.80807@mozilla.com>
	<CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>
Message-ID: <52C2D7DF.80200@mozilla.com>

On 12/31/13 6:39 AM, Oren Ben-Kiki wrote:
> Great news... I'll admit I have no idea what "unboxed closures" are,
> exactly, google wasn't helpful finding out a post clearly describing
> them. The example in
> http://www.mail-archive.com/rust-dev at mozilla.org/msg07569.html shows
> passing a closure to a map, so it obviously isn't a call-once so it
> can't consume an owned pointer. E.g., if it was `|&x| x +
> f(move-some-owned-pointer-from-the-context-to-be-consumed-by-f)`, then
> it wouldn't - and shouldn't - work.

Presumably along with `Fn<T,U>` there will be something like `OnceFn<T,U>`:

     trait OnceFn<Ret,Args...> {
         fn call(self, args: Args) -> Ret;
         //      ^^^^ note by-value self; this is what makes it one-shot
     }

Note: This is just a strawman sketch of the idea; it may well not work, 
no promises, etc.

Patrick


From danielmicay at gmail.com  Tue Dec 31 06:43:02 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 31 Dec 2013 09:43:02 -0500
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>
	<52C2D4C7.80807@mozilla.com>
	<CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>
Message-ID: <CA+DvKQ+1fnC7MhOHc4Fi08QKwqOeNc5jFsRWwL86AG=PRNr+cg@mail.gmail.com>

It's the same as the difference between static dispatch via generics
and dynamic dispatch via boxed trait objects. At the moment, Rust only
has an equivalent to `&mut Trait` for closures and no uniquely typed
unboxed closures like C++.

From pcwalton at mozilla.com  Tue Dec 31 06:43:37 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 06:43:37 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2D01B.6050408@gmail.com>
References: <52C16E6E.6090603@active-4.com>
	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>
	<52C2D01B.6050408@gmail.com>
Message-ID: <52C2D819.4020100@mozilla.com>

On 12/31/13 6:09 AM, Huon Wilson wrote:
> On 01/01/14 00:55, Armin Ronacher wrote:
>> Hi,
>>
>> On 30/12/2013 17:29, Patrick Walton wrote:
>>> This is the first time I've heard of this as a missing feature, and I'm
>>> opposed. This would make typechecking significantly more complex.
>> I'm not saying someone should add decltype :)  Just that from using
>> the iterators we have now it becomes quite obvious that there are
>> missing tools to use them to the fullest extend.

The question in my mind is whether all these things that we want are 
backwards compatible, not whether they're nice to have. Anything 
backwards compatible that is not already in the language is probably 
post-1.0 at this point. *This is not because we don't want to add new 
features*?it's OK to add new features to the language. Version 1.0 
doesn't mean we are done and the language is frozen for all time. It 
just means we're going to stop making breaking language changes.

> If we were to have unboxed closures similar to C++, where each closure
> is an (implicit) unique type, we'd likely need something like decltype
> (well, decltype(auto)) to make it possible to return them and things
> containing them, e.g. higher-order iterators like .map and .filter.
>
> (cc https://github.com/mozilla/rust/issues/3228 and
> https://github.com/mozilla/rust/issues/10448)

Returning unboxed closures doesn't strike me as all that useful at the 
moment, unless we add back capture clauses to allow values to be moved 
in. Otherwise all you can refer to as upvars are passed-in parameters 
(due to lifetime restrictions).

In the event that you want to return closures that move in values, I 
would say just use an explicit struct and a trait for now. We can 
revisit this decision backwards compatibly if we need to in the future.

Returning an iterator containing an unboxed closure that was passed in 
doesn't require that feature, I don't think:

     pub fn map<T,F:Fn<T>>(x: &[T], f: F) -> MapIterator<F> { ... }

Patrick


From dbau.pp at gmail.com  Tue Dec 31 06:52:00 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 01 Jan 2014 01:52:00 +1100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2D819.4020100@mozilla.com>
References: <52C16E6E.6090603@active-4.com>	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<52C2D01B.6050408@gmail.com>
	<52C2D819.4020100@mozilla.com>
Message-ID: <52C2DA10.7070201@gmail.com>

On 01/01/14 01:43, Patrick Walton wrote:
> On 12/31/13 6:09 AM, Huon Wilson wrote:
>> On 01/01/14 00:55, Armin Ronacher wrote:
>>> Hi,
>>>
>>> On 30/12/2013 17:29, Patrick Walton wrote:
>>>> This is the first time I've heard of this as a missing feature, and 
>>>> I'm
>>>> opposed. This would make typechecking significantly more complex.
>>> I'm not saying someone should add decltype :)  Just that from using
>>> the iterators we have now it becomes quite obvious that there are
>>> missing tools to use them to the fullest extend.
>
> The question in my mind is whether all these things that we want are 
> backwards compatible, not whether they're nice to have. Anything 
> backwards compatible that is not already in the language is probably 
> post-1.0 at this point. *This is not because we don't want to add new 
> features*?it's OK to add new features to the language. Version 1.0 
> doesn't mean we are done and the language is frozen for all time. It 
> just means we're going to stop making breaking language changes.
>
>> If we were to have unboxed closures similar to C++, where each closure
>> is an (implicit) unique type, we'd likely need something like decltype
>> (well, decltype(auto)) to make it possible to return them and things
>> containing them, e.g. higher-order iterators like .map and .filter.
>>
>> (cc https://github.com/mozilla/rust/issues/3228 and
>> https://github.com/mozilla/rust/issues/10448)
>
> Returning unboxed closures doesn't strike me as all that useful at the 
> moment, unless we add back capture clauses to allow values to be moved 
> in. Otherwise all you can refer to as upvars are passed-in parameters 
> (due to lifetime restrictions).
>
> In the event that you want to return closures that move in values, I 
> would say just use an explicit struct and a trait for now. We can 
> revisit this decision backwards compatibly if we need to in the future.
>
> Returning an iterator containing an unboxed closure that was passed in 
> doesn't require that feature, I don't think:
>
>     pub fn map<T,F:Fn<T>>(x: &[T], f: F) -> MapIterator<F> { ... }

I mean

     fn my_pipeline<I: Iterator<T>>(x: I) -> 
MapIterator<FilterIterator<I, 
what_do_I_write_for_the_function_type_here>, and_again> {
          x.filter(|un| boxed).map(|also| unboxed)
     }

(where the function/closure is the second param to {Map,Filter}Iterator.)

Huon
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From oren at ben-kiki.org  Tue Dec 31 06:56:18 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 31 Dec 2013 16:56:18 +0200
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2D7DF.80200@mozilla.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com>
	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>
	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>
	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>
	<52C2D4C7.80807@mozilla.com>
	<CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>
	<52C2D7DF.80200@mozilla.com>
Message-ID: <CADJiDhtyT7n6gr_byVP_pb41ioL2F-UKwg-WUAshNaXd7ZQdcA@mail.gmail.com>

Thanks for the explanation. Of course, the point is that you'd meed two
types, `OnceFn` which is stack-allocated (non-send-able, can take borrowed
pointers from its context) and `SendFn` which is heap-allocated (send-able,
can't take borrowed pointers from its context). Both would be able to
consume an owned pointer.

I guess we'll see how this ends up when it evolves past being a sketch of
an idea :-)


On Tue, Dec 31, 2013 at 4:42 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/31/13 6:39 AM, Oren Ben-Kiki wrote:
>
>> Great news... I'll admit I have no idea what "unboxed closures" are,
>> exactly, google wasn't helpful finding out a post clearly describing
>> them. The example in
>> http://www.mail-archive.com/rust-dev at mozilla.org/msg07569.html shows
>> passing a closure to a map, so it obviously isn't a call-once so it
>> can't consume an owned pointer. E.g., if it was `|&x| x +
>> f(move-some-owned-pointer-from-the-context-to-be-consumed-by-f)`, then
>> it wouldn't - and shouldn't - work.
>>
>
> Presumably along with `Fn<T,U>` there will be something like `OnceFn<T,U>`:
>
>     trait OnceFn<Ret,Args...> {
>         fn call(self, args: Args) -> Ret;
>         //      ^^^^ note by-value self; this is what makes it one-shot
>     }
>
> Note: This is just a strawman sketch of the idea; it may well not work, no
> promises, etc.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/ef117cdf/attachment.html>

From denis.spir at gmail.com  Tue Dec 31 07:02:34 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 31 Dec 2013 16:02:34 +0100
Subject: [rust-dev] on quality & success
In-Reply-To: <CAD0sBY5ESCepQ615H8s=FQydWCOMbnrxhLjHdOmR8GdKkBgOcQ@mail.gmail.com>
References: <52C2B0F7.2000103@gmail.com>
	<CAD0sBY5ESCepQ615H8s=FQydWCOMbnrxhLjHdOmR8GdKkBgOcQ@mail.gmail.com>
Message-ID: <52C2DC8A.6060303@gmail.com>

On 12/31/2013 01:43 PM, Till Schneidereit wrote:
> Without responding to everything in your message, two quick points:
>
> For being written by someone afraid 'of the terrible level of violence, in
> [your] view, present in the programming "community"', your message is
> awfully condecending and dismissive of a huge amount of hard work by
> curageous people. The Rust designers have made it very clear that they
> don't share your views on how much the language should differ from
> pre-existing widely-used languages. You seem to say that that necessarily
> means that they're conformist cowards who only do their work for 'fame,
> honour, status, money, power' or '[t]o mentally masturbate on the idea of
> having made something "sucessful"'. Would you say that to someone's face?
> If not (actually, regardless), please don't do it on a mailing list.
>
> As for your main argument (as far as I understand it), that languages are
> designed too timidly, I quite simply don't believe that you don't see the
> argument that a language might not be adopted if it breaks with too many
> conventions that people have gotten used to. You're saying that you'll
> gladly try out languages that break with everything you learned before.
> That's commendable, but not something a language designer can expect of
> everyone in their target audience. Now you might disagree with the strategy
> of introducing enough change to make the language clearly superior to its
> competition, while keeping the learning curve bearable. Please don't
> dismiss it as "madness" you don't even need to argue against, though.

You seem to reply to another message than mine. Or maybe it is (as often) my 
failure in expressing my thought.

"two quick points", as you say

* This post is not about Rust, not at all in fact: it's sent to a mailing list 
about PL-design in general. I indicate (at start of post) that the reason for a 
copy here is the reflexion "is inspired by a thread" on rust-dev. (Also, I 
imagined some here may be interested.)

* I don't have the impression to give the impression to be condescending or 
whatnot; in fact, instead of excluding myself (and though it was not done in 
purpose, rather just an illustration) I explicitely state not beeing brave enough.

Anyway, anyone may receive anything as they will.

Denis

PS: As for the quotes you take, indeed they look agressive out of context. But 
they are questions in the original text and, at least I hope so, they mean 
something different in context, and with a different spirit as the one you expose.
Also, again, this post is not about Rust's development (if it were so, I would 
not be interested in this language... why do I follow the mailing list rust-dev 
if I do not regard it as a good project?)
Finally, since you attack me on this point: yes, I speak that way to people face 
to face (and they don't take it as you do, rather most people are grateful when 
one speaks truly; never mind).

From carter.schonwald at gmail.com  Tue Dec 31 07:20:54 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 31 Dec 2013 10:20:54 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C2942B.2010608@gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C25326.3000807@mozilla.com>
	<52C2942B.2010608@gmail.com>
Message-ID: <CAHYVw0zmwm=SDrN4dygwFGXTVa65YJ5EdTPqPmnBeZ2MKvzbxA@mail.gmail.com>

In fact most haskellers building distributed/concurrent systems are
emphatically in favor of only bounded channels.

On Tuesday, December 31, 2013, Gy?rgy Andrasek wrote:

> On 12/31/2013 06:16 AM, Patrick Walton wrote:
>
>> I am concerned that we are only hearing one side of the argument here,
>> and Haskell folks seem to have come down fairly strongly in favor of
>> unbounded channels.
>>
>
> Haskell also has laziness, garbage collection and immutable shared data
> structures. They don't really care about memory usage before they've
> actually gone OOM.
>
> Still, even STM has semaphores and bounded queues, and the user is
> expected to choose the right data structure for their needs. Also, it's
> trivial to write an STM function that can select on different channels if
> the write blocks.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/2ad4978f/attachment.html>

From glaebhoerl at gmail.com  Tue Dec 31 07:39:00 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 31 Dec 2013 16:39:00 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2DA10.7070201@gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com> <52C2D01B.6050408@gmail.com>
	<52C2D819.4020100@mozilla.com> <52C2DA10.7070201@gmail.com>
Message-ID: <CAPoegswyvd74CZGibaYKvtoqGk-ex26Vr8c4iVaXj+Zcg34Zzw@mail.gmail.com>

The other day on IRC `mitsuhiko` (who I believe is actually Armin, the OP
in this thread) wrote that he would like to be able to write something like

    fn my_pipeline<I: Iterator<T>>(x: I) -> Iterator<T> { ... }

and that got stuck in my head: maybe it's not such a crazy idea. The
objections to having type inference at the API level seem sound to me:
besides implementation difficulty, if an inferred return type can
potentially be a local or anonymous type from the body of the `fn`, how are
you supposed to know, from the outside, what you can *do* with that type? I
don't really like `decltype` solution either: it solves a problem, but
working with it everywhere is just painful, and it ties the exposed
interface too closely to the implementation. If you specify a trait, these
problems are solved: it's still an unknown type from the body of the `fn`,
but now the interface you are allowed to use with it is clear. This is what
traits are for in the first place. There's still the big question of what
this syntax would actually *mean*, however, and there are some things, like
the actual representation (incl. size and alignment) of the type, which
still wouldn't be determined by the function signature, and would depend on
the body of the function, and I don't know how problematic that is. I think
this also might be intimately related to the DST/SST discussion, because
it's basically an unboxed existential.

Speaking of which: I completely agree with Patrick that there's no point to
blocking Rust 1.0 on backwards compatible features. The reason I'm
nonetheless wary of a drive to finalize the language too soon is that there
are still some really huge things outstanding, such as DST/SST, that we
still need to figure out, let alone implement, and ideally after
implementation there should also be a cooling-off period to see if
everything's working well, and that there aren't further issues that end up
getting raised as a consequence (or if there are, how to address them), and
so forth.


On Tue, Dec 31, 2013 at 3:52 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 01/01/14 01:43, Patrick Walton wrote:
>
>> On 12/31/13 6:09 AM, Huon Wilson wrote:
>>
>>> On 01/01/14 00:55, Armin Ronacher wrote:
>>>
>>>> Hi,
>>>>
>>>> On 30/12/2013 17:29, Patrick Walton wrote:
>>>>
>>>>> This is the first time I've heard of this as a missing feature, and I'm
>>>>> opposed. This would make typechecking significantly more complex.
>>>>>
>>>> I'm not saying someone should add decltype :)  Just that from using
>>>> the iterators we have now it becomes quite obvious that there are
>>>> missing tools to use them to the fullest extend.
>>>>
>>>
>> The question in my mind is whether all these things that we want are
>> backwards compatible, not whether they're nice to have. Anything backwards
>> compatible that is not already in the language is probably post-1.0 at this
>> point. *This is not because we don't want to add new features*?it's OK to
>> add new features to the language. Version 1.0 doesn't mean we are done and
>> the language is frozen for all time. It just means we're going to stop
>> making breaking language changes.
>>
>>  If we were to have unboxed closures similar to C++, where each closure
>>> is an (implicit) unique type, we'd likely need something like decltype
>>> (well, decltype(auto)) to make it possible to return them and things
>>> containing them, e.g. higher-order iterators like .map and .filter.
>>>
>>> (cc https://github.com/mozilla/rust/issues/3228 and
>>> https://github.com/mozilla/rust/issues/10448)
>>>
>>
>> Returning unboxed closures doesn't strike me as all that useful at the
>> moment, unless we add back capture clauses to allow values to be moved in.
>> Otherwise all you can refer to as upvars are passed-in parameters (due to
>> lifetime restrictions).
>>
>> In the event that you want to return closures that move in values, I
>> would say just use an explicit struct and a trait for now. We can revisit
>> this decision backwards compatibly if we need to in the future.
>>
>> Returning an iterator containing an unboxed closure that was passed in
>> doesn't require that feature, I don't think:
>>
>>     pub fn map<T,F:Fn<T>>(x: &[T], f: F) -> MapIterator<F> { ... }
>>
>
> I mean
>
>     fn my_pipeline<I: Iterator<T>>(x: I) -> MapIterator<FilterIterator<I,
> what_do_I_write_for_the_function_type_here>, and_again> {
>          x.filter(|un| boxed).map(|also| unboxed)
>     }
>
> (where the function/closure is the second param to {Map,Filter}Iterator.)
>
> Huon
>
>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/2201df6f/attachment-0001.html>

From thadguidry at gmail.com  Tue Dec 31 07:40:00 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 31 Dec 2013 09:40:00 -0600
Subject: [rust-dev] on quality & success
In-Reply-To: <52C2B0F7.2000103@gmail.com>
References: <52C2B0F7.2000103@gmail.com>
Message-ID: <CAChbWaNEc3fZerEHM1rfiYeS-hukFG5n0ud3wuBWFOjF8tRbaQ@mail.gmail.com>

Denis,

Long form email is not the best method of communication or to express your
design thoughts...I would suggest a blog link instead.

Also note that Patrick has asked the community numerous times...

Give specific alternative solutions of where you think Rust has made design
mistakes, preferably in bullet form so they can be addressed one at a time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/e22bd6e2/attachment.html>

From danielmicay at gmail.com  Tue Dec 31 07:41:39 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 31 Dec 2013 10:41:39 -0500
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CAPoegswyvd74CZGibaYKvtoqGk-ex26Vr8c4iVaXj+Zcg34Zzw@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com> <52C2D01B.6050408@gmail.com>
	<52C2D819.4020100@mozilla.com> <52C2DA10.7070201@gmail.com>
	<CAPoegswyvd74CZGibaYKvtoqGk-ex26Vr8c4iVaXj+Zcg34Zzw@mail.gmail.com>
Message-ID: <CA+DvKQK2TaZ9Luo6DGp6PYs7op3VL2a1fNZ01LNEXC0UV_p74w@mail.gmail.com>

On Tue, Dec 31, 2013 at 10:39 AM, G?bor Lehel <glaebhoerl at gmail.com> wrote:
>
> Speaking of which: I completely agree with Patrick that there's no point to
> blocking Rust 1.0 on backwards compatible features. The reason I'm
> nonetheless wary of a drive to finalize the language too soon is that there
> are still some really huge things outstanding, such as DST/SST, that we
> still need to figure out, let alone implement, and ideally after
> implementation there should also be a cooling-off period to see if
> everything's working well, and that there aren't further issues that end up
> getting raised as a consequence (or if there are, how to address them), and
> so forth.

Adding a backwards compatible feature can completely change the idioms
of the language. Of course, if we're not worried about stabilizing the
standard library then it doesn't matter.

From glaebhoerl at gmail.com  Tue Dec 31 07:46:12 2013
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 31 Dec 2013 16:46:12 +0100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CA+DvKQK2TaZ9Luo6DGp6PYs7op3VL2a1fNZ01LNEXC0UV_p74w@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com> <52C19F75.5090703@mozilla.com>
	<52C2CCE1.8050503@active-4.com> <52C2D01B.6050408@gmail.com>
	<52C2D819.4020100@mozilla.com> <52C2DA10.7070201@gmail.com>
	<CAPoegswyvd74CZGibaYKvtoqGk-ex26Vr8c4iVaXj+Zcg34Zzw@mail.gmail.com>
	<CA+DvKQK2TaZ9Luo6DGp6PYs7op3VL2a1fNZ01LNEXC0UV_p74w@mail.gmail.com>
Message-ID: <CAPoegsxXfv8jPcyRXducK5XyfowOUJC_Kv14tCoO+Lozk7ErOw@mail.gmail.com>

On Tue, Dec 31, 2013 at 4:41 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Dec 31, 2013 at 10:39 AM, G?bor Lehel <glaebhoerl at gmail.com>
> wrote:
> >
> > Speaking of which: I completely agree with Patrick that there's no point
> to
> > blocking Rust 1.0 on backwards compatible features. The reason I'm
> > nonetheless wary of a drive to finalize the language too soon is that
> there
> > are still some really huge things outstanding, such as DST/SST, that we
> > still need to figure out, let alone implement, and ideally after
> > implementation there should also be a cooling-off period to see if
> > everything's working well, and that there aren't further issues that end
> up
> > getting raised as a consequence (or if there are, how to address them),
> and
> > so forth.
>
> Adding a backwards compatible feature can completely change the idioms
> of the language. Of course, if we're not worried about stabilizing the
> standard library then it doesn't matter.
>

Right. It was my understanding that we aren't.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/88b6901a/attachment.html>

From pcwalton at mozilla.com  Tue Dec 31 09:32:08 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 09:32:08 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2DA10.7070201@gmail.com>
References: <52C16E6E.6090603@active-4.com>	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<52C2D01B.6050408@gmail.com>	<52C2D819.4020100@mozilla.com>
	<52C2DA10.7070201@gmail.com>
Message-ID: <52C2FF98.6030004@mozilla.com>

On 12/31/13 6:52 AM, Huon Wilson wrote:
>      fn my_pipeline<I: Iterator<T>>(x: I) ->
> MapIterator<FilterIterator<I,
> what_do_I_write_for_the_function_type_here>, and_again> {
>           x.filter(|un| boxed).map(|also| unboxed)
>      }
>
> (where the function/closure is the second param to {Map,Filter}Iterator.)

Ah, OK. You're right -- in that case you would need to use a struct and 
implement `call` manually, unless we had `-> _`.

Patrick


From pcwalton at mozilla.com  Tue Dec 31 09:34:08 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 09:34:08 -0800
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <CADJiDhtyT7n6gr_byVP_pb41ioL2F-UKwg-WUAshNaXd7ZQdcA@mail.gmail.com>
References: <52C16E6E.6090603@active-4.com>	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<CADJiDhsBsR6WYhBj6or_0zwyoL-LR8FtFC7-O9om72W4g1XSSw@mail.gmail.com>	<CA+DvKQKtS5OPCspP1cBxCqEUkjqa_NDeCNZPzVEiyU=O_Zm2DA@mail.gmail.com>	<CADJiDhvqm_uOzMm2aNdj=kea=eBjacDUwC4D91u7w3NU174hxg@mail.gmail.com>	<52C2D4C7.80807@mozilla.com>	<CADJiDhu1+JUA8u_PcVsvxMij3W14AWvtOXBejSu6dGr4uhV=sw@mail.gmail.com>	<52C2D7DF.80200@mozilla.com>
	<CADJiDhtyT7n6gr_byVP_pb41ioL2F-UKwg-WUAshNaXd7ZQdcA@mail.gmail.com>
Message-ID: <52C30010.8020103@mozilla.com>

On 12/31/13 6:56 AM, Oren Ben-Kiki wrote:
> Thanks for the explanation. Of course, the point is that you'd meed two
> types, `OnceFn` which is stack-allocated (non-send-able, can take
> borrowed pointers from its context) and `SendFn` which is heap-allocated
> (send-able, can't take borrowed pointers from its context). Both would
> be able to consume an owned pointer.

Well, they're just two *traits*. That's the nice thing about this 
proposal, in my view: it doesn't require adding any new syntax to the 
language, only a couple more lang items, which feels like a smaller 
cognitive burden to me. (It's similar to how our operator overloading 
feels simpler than C++'s operator overloading, at least to me, because 
we don't have unique syntax for it.)

Patrick


From pcwalton at mozilla.com  Tue Dec 31 09:35:07 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 09:35:07 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0zmwm=SDrN4dygwFGXTVa65YJ5EdTPqPmnBeZ2MKvzbxA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>
	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>
	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>
	<52C25326.3000807@mozilla.com>	<52C2942B.2010608@gmail.com>
	<CAHYVw0zmwm=SDrN4dygwFGXTVa65YJ5EdTPqPmnBeZ2MKvzbxA@mail.gmail.com>
Message-ID: <52C3004B.2030805@mozilla.com>

On 12/31/13 7:20 AM, Carter Schonwald wrote:
> In fact most haskellers building distributed/concurrent systems are
> emphatically in favor of only bounded channels.

Do you have a citation? Simon Marlow seemed to be firmly in the opposite 
camp.

Patrick


From pcwalton at mozilla.com  Tue Dec 31 09:36:43 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 09:36:43 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C2942B.2010608@gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>	<52C25326.3000807@mozilla.com>
	<52C2942B.2010608@gmail.com>
Message-ID: <52C300AB.2090403@mozilla.com>

On 12/31/13 1:53 AM, Gy?rgy Andrasek wrote:
> Still, even STM has semaphores and bounded queues, and the user is
> expected to choose the right data structure for their needs.

This is what I'm advocating here.

Patrick

From pcwalton at mozilla.com  Tue Dec 31 09:46:38 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 09:46:38 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<52BA5210.2080100@mozilla.com>
	<CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>
Message-ID: <52C302FE.1030808@mozilla.com>

On 12/30/13 8:46 PM, Christian Ohler wrote:
> To address the last sentence ? bounded channels with default size 0
> _do_ minimize the fallout of this design: The program would reliably
> deadlock every time it is tested with a nonzero number of images,
> since A will try to write to "Images" while B is blocked receiving
> from "Done", not listening on "Images" yet.  I don't see this deadlock
> as a nasty hazard ? the code wouldn't work at all, and the programmer
> would immediately notice.  If the programmer uses a non-zero buffer
> size for the channel, it's a magic number that they came up with, so
> they should know to test inputs around that magnitude.

I suspect a lot of programmers in systems with bounded channels just 
come up with some round number (like 10) and forget about it. Similar to 
the argument to listen(2)...

Patrick


From matthieu.monrocq at gmail.com  Tue Dec 31 10:03:03 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Tue, 31 Dec 2013 19:03:03 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C302FE.1030808@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CADd11yUmoKRQ0wC+o2j3F8iTD0_knuk6cV=2omiKcKAnQbA8uw@mail.gmail.com>
	<3ee4e401-4da9-4224-beac-19183ef80e1e@email.android.com>
	<CA+DvKQJJrthE3gCNKZWZVqNuJKupXbuy97+XigWgFu2kL8Hiiw@mail.gmail.com>
	<CAHYVw0wjt8sNr3MOYh3uvuo4uHx5EHUtk1pwuZ4LOJ5xXw4Ucw@mail.gmail.com>
	<CABq6+adVixi92FbsP0VjFdS-3xDM-1HXvy=UWzJnZVNQy9Pe1g@mail.gmail.com>
	<CA+DvKQL-xpa5mBrejMwG=VyLfxEy9z9b6MHLVQ6hvKNp23b=zw@mail.gmail.com>
	<52BA4761.7040304@mozilla.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<52BA5210.2080100@mozilla.com>
	<CAPzKZDzcZnrNOTGmNh_Da7xhcuuvqiq7KZwKPxy4mnNNBW+FtQ@mail.gmail.com>
	<52C302FE.1030808@mozilla.com>
Message-ID: <CAKE6RficqVGk7rR3TqHd59V9ZVg1PV0a37dJH2zF=TvOjz1uZA@mail.gmail.com>

On Tue, Dec 31, 2013 at 6:46 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/30/13 8:46 PM, Christian Ohler wrote:
>
>> To address the last sentence ? bounded channels with default size 0
>> _do_ minimize the fallout of this design: The program would reliably
>> deadlock every time it is tested with a nonzero number of images,
>> since A will try to write to "Images" while B is blocked receiving
>> from "Done", not listening on "Images" yet.  I don't see this deadlock
>> as a nasty hazard ? the code wouldn't work at all, and the programmer
>> would immediately notice.  If the programmer uses a non-zero buffer
>> size for the channel, it's a magic number that they came up with, so
>> they should know to test inputs around that magnitude.
>>
>
> I suspect a lot of programmers in systems with bounded channels just come
> up with some round number (like 10) and forget about it. Similar to the
> argument to listen(2)...
>
> Patrick
>
>
Anecdotal evidence: I work with distributed systems, and most of our
"limits" are in fact completely winged and rarely if ever touched... except
after an issue where we realize we could do better.

This is the kind of things where you don't have enough experience with the
system as you first write it, so you put some "reasonable" limits, and then
just forget that you needed to come back it and check if it really
worked... but then, on the other hand, if it passes the testing isn't it
that it works well enough ?


> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/1fc4fc19/attachment-0001.html>

From kevin at sb.org  Tue Dec 31 10:03:13 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 31 Dec 2013 13:03:13 -0500
Subject: [rust-dev] on quality & success
In-Reply-To: <52C2B0F7.2000103@gmail.com>
References: <52C2B0F7.2000103@gmail.com>
Message-ID: <7E11FCD0-31D5-4C18-9F81-A71015B1F317@sb.org>

Some of what you said I agree with, and some I don?t. But in particular, I disagree with your thesis. A language is successful if it attracts enough programmers. It may very well be true that the best way to do that is to produce a high-quality language, but the ineffable ?quality? of a language is not the only thing that attracts programmers.

You make a good point that programmers check out new languages because of the differences, rather than in spite of them. But I think that you?ve turned this into thinking that differences are inherently good (for example, in your suggestion "Why not use "if" to mean 'try' or 'switch' or 'foreach', and "ifif" to mean 'if'? What do you think??), and that?s simply not true. Differences can be good, they can be bad, and they can also be meaningless. And I would argue that meaningless differences are bad, because it?s yet one more thing for a programmer to have to learn when switching from an existing language.

There is an important balancing act going on when creating a new language. If you make it too different, even if you believe every single change is for the good, then the alien nature of the language will serve to make it harder for existing programmers to jump to your new language, and therefore you will get fewer programmers making the attempt. And too few programmers will, of course, render your language unsuccessful.

-Kevin

On Dec 31, 2013, at 6:56 AM, spir <denis.spir at gmail.com> wrote:

> Hol?!
> 
> [This is a rather personal and involved post. Press del if you feel like it...]
> [also, it is long]
> [copy to rust-dev mailing list: actually the post is inspired by a thread there "Thoughts on the Rust Roadmap"]
> 
> There is a point obvious to me; apparently most people including many language designers don't share it, or act as if they did not:
> 
>    a language should be successful iff it is of high quality
> 
> A kind of symmetric statement also holds;
> 
>    let us hope low quality languages have no success!
> 
> There are various reasons to hope this, the most stupid beeing that successful languages influence others, present & future. This is in my view a symptom of our civilisation's funny spirit (read: madness), and related to the actual points I intend to state (if, for once, I manage to express my thought).
> 
> Apparently, many language designers proceed more or less the following way: there are a few key points (for them) they consider mis-designed or missing or wrong in some way in existing languages (not all the same for every language). Thus, they want to make a language that repairs these points, all together. Then, certainly in fear that too many changes may repel potential adopters of their language, in hope to maximise its chances of success *despite* it breaking habits on the key points more important to them, they won't change anything else, or only the bare minimum they can. They want instead to remain as mainstream as possible on everything else. [4]
> 
> I consider this spirit bad; I mean, very bad. This is the way basic design errors propagate from successful languages to others, for instance. [1] Apparently, it takes a great dose of courage to break any existing practice in a _new_ language: tell me why, I do not understand.
> 
> Note that I am here talking of wrong design points in the opinion of a given language designer. Choices he (since it's mostly men) would not do if programming were a new field, open to all explorations. (There are indeed loads of subjective or ideological design points; see also [1] & [3]) However, while programming is not a new field anymore, it is indeed open to all explorations, for you, for me, if you or me wants it. Nothing blocks us but our own bloackages, our own fears, and, probably, wrong rationales, perhaps non-fully-conscious ones.
> 
> Deciding to reuse wrong, but mainstream, design decisions in one's own language is deciding to intentionally make it of lower quality. !!! Funny (read: mad), isn't it? It is thus also intentionally deciding to make it not worth success. This, apparently, to make its actual chances of success higher. (Isn't our culture funny?)
> Then, why does one _actually_ make a new language? For the joy of making something good? To contribute to a better world, since languages and programming are a common good? [2] For the joy of offering something of as high a quality as humanly possible? Else, why? For fame, honour, status, money, power? To mentally masturbate on the idea of having made something "sucessful" (sic!)?
> 
> We are not in need of yet another language trying, or pretending, to improve on a handful of disparate points, leaving all the rest as is, meaning in bad state. And, as an example, we are not in need of yet another failed trial for a successor to C as major low-level lang.
> Differences, thought of by their designer as significant quality improvements, are the *reasons* for programmers to adopt a new language. There are the _only_ (good) reasons to do so. Thinking that programmers may adopt a new language _despite_ its differences is thinking backwards; this, in addition to preventing oneself from working for the common good; by fear, probably; fear of truely thinking by oneself and/or of making one's true thinking public truely. (I can understand that, however: I often do not disclose my thinking by fear of the terrible level of violence, in my view, present in the programming "community" [hum!], and among geeks in general. This, rather than sharing and mutual help and cooperation, for the common wealth. Our civilisation... again.)
> 
> I have recently decided to adopt possible differences even if i am not that convinced of their betterness; to give alternatives a try; to give them at least a chance to show us (or just me) how good they actually are, or not, in practice, maybe on the long term [3].
> This may go too far; it is a personal decision.
> 
> However, deciding not to change what one sees wrong is weird for the least. It means removing points of quality according to one's own views, removing chances to contrbute to a better world, removing sources of personal satisfaction, removing reasons for others to judge a language better, thus removing motivation for programmers to adopt it. Maybe, certainly, many programmers do not adopt a language on the base of its quality, only; however, this counts; people I wish would adopt my lang, if ever, are those people who judge first on quality, not hype followers or otherwise conservatives.
> What I mean is, apart from working against the common wealth, in addition to preventing one's own enjoyment of doing what one does, such an attitude may also work against a language's potential success. Is this (a factor) why we have no successor to C yet, what do you think? because most designers kept most of its design bugs unchanged? [4] just to have a minimal chance, should a potential successor instead break as much as possible? (And not have a builtin interface to C? ???)
> 
> Also note that attitudes and spirits are psycho-sociologically contagious. In particular, fear and lack of courage and angst are highly contagious (in our world, with such a close to universal high level of anxiety...) What if more (would-be) language designers boldly thought by themselves and boldly assumed their thoughts?
> 
> Final note: isn't it weird that such conformism is _that_ prevalent among language designers? Precisely the ones who should be bearers of novelty? the one "milieu" which could & should be a network of interacting counter-cultures and individual iconoclasts (idol breakers)?
> 
> I do not expect anyone shares (all of) this. I just hope it may open new ways of thinking or questionning to a few.
> 
> Denis
> 
> [1] Including the funny usage of "=" for assignment and "==" for equality, after at least 5 decades, lol! Still my favorite syntactic error after dozens of thousands of hours of programming in languages which nearly all use this amusing convention. Why not use "if" to mean 'try' or 'switch' or 'foreach', and "ifif" to mean 'if'? What do you think?
> 
> [2] Actually, they are both communal and social. Better quality languages may contribute to a better world, at a communal level because we programmers share code and read others' code all the time, and at a social level because apps are a significant part of the world's state.
> 
> [3] As you certainly know, it takes time to unlearn, especially to stop judging something bad while it is just different. (Think at C programmers and their beloved code block {} braces. I for one have better usage for brace ;-.)
> 
> [4] As an anecdote, somewhat complementary, in the course of my explorations about programming languages, I often stepped on lists of C design bugs, at least a dozen of them. Typically endless lists that take a quarter of an hour to read in one go, without comments. There is space to works for a language lover :-). If not enough, usually such critics seems to agree on more than half of the points (and the remaining ones may not figure on some lists just because the critic not think at it or did not study this point) (but their solutions may diverge...).
> 
> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From carter.schonwald at gmail.com  Tue Dec 31 10:39:21 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 31 Dec 2013 13:39:21 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C3004B.2030805@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C25326.3000807@mozilla.com>
	<52C2942B.2010608@gmail.com>
	<CAHYVw0zmwm=SDrN4dygwFGXTVa65YJ5EdTPqPmnBeZ2MKvzbxA@mail.gmail.com>
	<52C3004B.2030805@mozilla.com>
Message-ID: <CAHYVw0x5=PTxpoRRNita9uYa7_O=7xbbL0E-dVyg77oUCBnr2w@mail.gmail.com>

Patrick, the example simon marlow remarks you've alluded to (i believe its
this one https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz)
are a bit more nuanced than I feel you make it out to be

as a counter point, can point to steve severance's tweets at you and me
https://twitter.com/sseveran/status/413565213762674688
"unbounded queues in haskell can lead to weird failures. I would rather
crash..."
and " Yes?people who build distributed systems that they are pretty sure
work"


either way, I think we all agree that both abstractions are useful, though
perhaps to different people, though how to do them really well is open to
some refinement perhaps


On Tue, Dec 31, 2013 at 12:35 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/31/13 7:20 AM, Carter Schonwald wrote:
>
>> In fact most haskellers building distributed/concurrent systems are
>> emphatically in favor of only bounded channels.
>>
>
> Do you have a citation? Simon Marlow seemed to be firmly in the opposite
> camp.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/c1bfa2fa/attachment.html>

From alex at crichton.co  Tue Dec 31 11:22:33 2013
From: alex at crichton.co (Alex Crichton)
Date: Tue, 31 Dec 2013 13:22:33 -0600
Subject: [rust-dev] Using libgreen/libnative
In-Reply-To: <DUB122-W354C5FDD8B68E11F42ACCCB0C90@phx.gbl>
References: <CAFnh-mfEUsyV5WtS8+sjz+e_8+Op9kHgMcoSzpcg-YS8PbsF2w@mail.gmail.com>
	<52BF77CA.3040302@mozilla.com>
	<DUB122-W354C5FDD8B68E11F42ACCCB0C90@phx.gbl>
Message-ID: <CAFnh-mcTN4xosHPcwW1CvLtOmaeoHMoy60wqs5+WdR0_nhGC3A@mail.gmail.com>

This is currently a bug in rustpkg, and I've opened up
https://github.com/mozilla/rust/issues/11243 about this bug.

On Tue, Dec 31, 2013 at 6:36 AM, Madhu Srinivasan
<smadhueagle at outlook.com> wrote:
> This is great !!
>
> Quick question - it seems like rustpkg is still unaware of libnative and
> libgreen ?
>
> I am trying to compile the example code from alex (and some other examples)
> with rustpkg with the following error:
>
>> rustpkg build test
>
> WARNING: The Rust package manager is experimental and may be unstable
>
> error: Package test depends on native, but I don't know how to find it
>
> task '<unnamed>' failed at 'explicit failure',
> /private/tmp/rust-yVG2/src/librustpkg/util.rs:528
>
> task '<unnamed>' failed at 'receiving on a closed channel',
> /private/tmp/rust-yVG2/src/libstd/comm/mod.rs:728
>
>
> However, rustc does it just fine ...
>
>
>> rustc  -o bin/test src/test/main.rs
>
>>
>
>
> Wondering if there is a pending issue with rustpkg ? I am happy (and prefer)
> to use rustc anyways!
>
> Great work !!
>
> Dr. Madhu Srinivasan
>
>
>> Date: Sat, 28 Dec 2013 17:15:54 -0800
>> From: banderson at mozilla.com
>> To: rust-dev at mozilla.org
>> Subject: Re: [rust-dev] Using libgreen/libnative
>
>>
>> Thanks for writing this up, Alex. The improvements you've made to the
>> runtime recently are very impressive. Now we've got nearly complete and
>> reasonably fast I/O, fast message passing, a scheduler-agnostic standard
>> library, and very soon an embeddable runtime and a standard library that
>> can be used in almost any environment. After years of iteration I'm
>> hopeful that we're finally converging on a good design for the runtime.
>>
>>
>> On 12/28/2013 10:37 AM, Alex Crichton wrote:
>> > Greetings rusticians!
>> >
>> > Recently pull request #10965 landed, so the rust standard library no
>> > longer has
>> > any scheduling baked into it, but rather it's refactored out into two
>> > libraries.
>> > This means that if you want a 1:1 program, you can jettison all M:N
>> > support with
>> > just a few `extern mod` statements. A brief overview of the current
>> > state of
>> > things is:
>> >
>> > 1. All programs not using std::rt directly should still continue to
>> > operate as
>> > usual today
>> > 2. All programs still start up in M:N mode, although this will likely
>> > change
>> > once 1:1 I/O work has been completed
>> > 3. There are two more libraries available, libgreen and libnative, which
>> > allow
>> > custom fine-grained control over how programs run.
>> > 4. Whenever a new task is spawned, it is by default spawned as a
>> > "sibling" which
>> > means that it is spawned in the same mode as the spawning thread. This
>> > means
>> > that if a green thread spawns a thread then it will also be a green
>> > thread,
>> > while a native thread will spawn another OS thread.
>> >
>> > With this migration, there have been a few changes in the public APIs,
>> > and
>> > things still aren't quite where I'd like them to be. PR #11153 is the
>> > last major
>> > step in this process as it allows you to link to both libnative and
>> > libgreen,
>> > yet still choose which one is used to boot your program. Some breaking
>> > changes
>> > you may notice are:
>> >
>> > * it's still not possible to easily start up in 1:1 mode - This is fixed
>> > by
>> > #11153. In the meantime, you can use #[start] with native::start in
>> > order to
>> > boot up in 1:1 mode. Be warned though that the majority of I/O is still
>> > missing from libnative (see PR #11159 for some progress)
>> >
>> > https://gist.github.com/8162357
>> >
>> > * std::rt::{start, run} are gone - These are temporarily moved into
>> > green/native
>> > while #[boot] is getting sorted out. The green/native counterparts
>> > perform as
>> > you would expect.
>> >
>> > https://gist.github.com/8162372
>> >
>> > * std::rt::start_on_main_thread is gone - This function has been removed
>> > with no
>> > direct counterpart. As a consequence of refactoring the green/native
>> > libraries, the "single threaded" spawn mode for a task has been removed
>> > (this
>> > doesn't make sense in 1:1 land). This behavior can be restored by
>> > directly
>> > using libnative and libgreen. You can use libgreen to spin up a pool of
>> > schedulers and then use libnative for the main task to do things like
>> > GUI
>> > management.
>> >
>> > https://gist.github.com/8162399
>> >
>> > And of course with the removal of some features comes the addition of
>> > new ones!
>> > Some new things you may notice are:
>> >
>> > * libstd is no longer burdened with libgreen and libnative! This means
>> > that the
>> > compile times for libstd should be a little faster, but most notably
>> > those
>> > applications only using libstd will have even less code pulled in than
>> > before,
>> > meaning that libstd is that much closer to being used in a "bare metal"
>> > context. It's still aways off, but we're getting closer every day!
>> >
>> > * libgreen has a full-fleged SchedPool type. You can see a bit of how
>> > it's used
>> > in gist I posted above. This type is meant to represent a dynamic pool
>> > of
>> > schedulers. Right now it's not possible to remove a scheduler from the
>> > pool
>> > (requires some more thought and possibly libuv modifications), but you
>> > can add
>> > new schedulers dynamically to the pool.
>> >
>> > This type supercedes the ThreadPool type in libextra at this point, and
>> > management of a SchedPool should provide any fine-grained control needed
>> > over
>> > the 'M' number in an M:N runtime.
>> >
>> > * libgreen and libnative can be used directly to guarantee spawning a
>> > green or a
>> > native task, regardless of the flavor of task that is doing the
>> > spawning.
>> >
>> > In the coming months, I plan on filling out more native I/O to bring it
>> > up to
>> > speed with the M:N implementation. I also plan on rewriting the core
>> > components
>> > of extra::comm to be performant in both scheduling modes in order to
>> > bring the
>> > extra::{comm, arc, sync} primitives up to date with their std::comm
>> > counterparts.
>> >
>> > If there are any questions about any of this, feel free to ask me! This
>> > thread
>> > is always available, and I'm also reachable as acrichto on IRC or
>> > alexcrichton
>> > on github.
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From ncm at cantrip.org  Tue Dec 31 13:33:39 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Tue, 31 Dec 2013 13:33:39 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C24EEF.2010104@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<52BA4761.7040304@mozilla.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>
	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>
	<52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com>
Message-ID: <52C33833.90203@cantrip.org>

On 12/30/2013 08:58 PM, Patrick Walton wrote:
> I'm not particularly interested in sacrificing performance by not
> implementing one or the other in libstd. I think it's clear we need
> both forms of channels, and they should be first-class primitives.

It's clear there are people who *want* both kinds of channels. It
does not follow that they should both be first-class primitives.
The possibility of precisely defining the behavior of a bounded
channel in all circumstances is what makes it suitable as a
first-class primitive. (The other, practical, requirement on
primitives is that their number be minimal.)

To implement an unbounded channel requires inherently more complex
operations -- re-allocations or segmented storage, response to failure
-- and corresponding choices that leak consequences visible to users.
In an application with extreme constraints on performance, the
arbitrary choices that must be taken implementing any particular
unbounded-channel design are likely not to match requirements, with
the typical result that such an application uses a private
re-implementation.  In the remaining, less demanding applications,
there is no penalty for using an unbounded channel constructed from
other, first-class primitives.

Nathan Myers

From pcwalton at mozilla.com  Tue Dec 31 13:41:27 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 13:41:27 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C33833.90203@cantrip.org>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>
	<52C33833.90203@cantrip.org>
Message-ID: <52C33A07.3040002@mozilla.com>

On 12/31/13 1:33 PM, Nathan Myers wrote:
> On 12/30/2013 08:58 PM, Patrick Walton wrote:
>> I'm not particularly interested in sacrificing performance by not
>> implementing one or the other in libstd. I think it's clear we need
>> both forms of channels, and they should be first-class primitives.
>
> It's clear there are people who *want* both kinds of channels. It
> does not follow that they should both be first-class primitives.
> The possibility of precisely defining the behavior of a bounded
> channel in all circumstances is what makes it suitable as a
> first-class primitive. (The other, practical, requirement on
> primitives is that their number be minimal.)

Unbounded channels have defined behavior as well. Undefined behavior has 
a precise definition and OOM is not undefined behavior.

> To implement an unbounded channel requires inherently more complex
> operations -- re-allocations or segmented storage, response to failure
> -- and corresponding choices that leak consequences visible to users.

I don't think that a fixed size buffer is necessarily the right 
implementation strategy for a bounded channel. There are cases in which 
you want a bounded channel so that you don't OOM, but with a large 
bound. Those use cases are not well served by always allocating the 
maximum size up front (see Alex's slides for how slow implementations 
based on fixed-size channels can get during channel creation with a 
large bound).

> In an application with extreme constraints on performance, the
> arbitrary choices that must be taken implementing any particular
> unbounded-channel design are likely not to match requirements, with
> the typical result that such an application uses a private
> re-implementation.  In the remaining, less demanding applications,
> there is no penalty for using an unbounded channel constructed from
> other, first-class primitives.

Bounded channels can be constructed from unbounded channels as well, so 
I don't see how this is an argument for making bounded channels the 
primitive.

Patrick

From carter.schonwald at gmail.com  Tue Dec 31 13:50:57 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 31 Dec 2013 16:50:57 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C33A07.3040002@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com>
Message-ID: <CAHYVw0w7EZfzvEb4kmaUKnjmS=uns4xWP=zLQ0hBBU0F9qnAvw@mail.gmail.com>

what are some candidate data structures in that case? i'm happy to try and
hack out some prototypes for that.


On Tue, Dec 31, 2013 at 4:41 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 12/31/13 1:33 PM, Nathan Myers wrote:
>
>> On 12/30/2013 08:58 PM, Patrick Walton wrote:
>>
>>> I'm not particularly interested in sacrificing performance by not
>>> implementing one or the other in libstd. I think it's clear we need
>>> both forms of channels, and they should be first-class primitives.
>>>
>>
>> It's clear there are people who *want* both kinds of channels. It
>> does not follow that they should both be first-class primitives.
>> The possibility of precisely defining the behavior of a bounded
>> channel in all circumstances is what makes it suitable as a
>> first-class primitive. (The other, practical, requirement on
>> primitives is that their number be minimal.)
>>
>
> Unbounded channels have defined behavior as well. Undefined behavior has a
> precise definition and OOM is not undefined behavior.
>
>
>  To implement an unbounded channel requires inherently more complex
>> operations -- re-allocations or segmented storage, response to failure
>> -- and corresponding choices that leak consequences visible to users.
>>
>
> I don't think that a fixed size buffer is necessarily the right
> implementation strategy for a bounded channel. There are cases in which you
> want a bounded channel so that you don't OOM, but with a large bound. Those
> use cases are not well served by always allocating the maximum size up
> front (see Alex's slides for how slow implementations based on fixed-size
> channels can get during channel creation with a large bound).
>
>
>  In an application with extreme constraints on performance, the
>> arbitrary choices that must be taken implementing any particular
>> unbounded-channel design are likely not to match requirements, with
>> the typical result that such an application uses a private
>> re-implementation.  In the remaining, less demanding applications,
>> there is no penalty for using an unbounded channel constructed from
>> other, first-class primitives.
>>
>
> Bounded channels can be constructed from unbounded channels as well, so I
> don't see how this is an argument for making bounded channels the primitive.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/42afdc68/attachment.html>

From dbau.pp at gmail.com  Tue Dec 31 14:46:59 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 01 Jan 2014 09:46:59 +1100
Subject: [rust-dev] Thoughts on the Rust Roadmap
In-Reply-To: <52C2FF98.6030004@mozilla.com>
References: <52C16E6E.6090603@active-4.com>	<52C19F75.5090703@mozilla.com>	<52C2CCE1.8050503@active-4.com>	<52C2D01B.6050408@gmail.com>	<52C2D819.4020100@mozilla.com>	<52C2DA10.7070201@gmail.com>
	<52C2FF98.6030004@mozilla.com>
Message-ID: <52C34963.4070203@gmail.com>

On 01/01/14 04:32, Patrick Walton wrote:
> On 12/31/13 6:52 AM, Huon Wilson wrote:
>>      fn my_pipeline<I: Iterator<T>>(x: I) ->
>> MapIterator<FilterIterator<I,
>> what_do_I_write_for_the_function_type_here>, and_again> {
>>           x.filter(|un| boxed).map(|also| unboxed)
>>      }
>>
>> (where the function/closure is the second param to 
>> {Map,Filter}Iterator.)
>
> Ah, OK. You're right -- in that case you would need to use a struct 
> and implement `call` manually, unless we had `-> _`.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Random thought: if we do get some form of -> _, but people dislike 
general return value inference a lot, we could restrict _ in return 
values to just anonymous types that can't be written explicitly, e.g.

     -> MapIterator<FilterIterator<I, _>, _>

in this case.


Huon

From jurily at gmail.com  Tue Dec 31 15:15:55 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Wed, 01 Jan 2014 00:15:55 +0100
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C33A07.3040002@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>	<52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com>
Message-ID: <52C3502B.9000207@gmail.com>

On 12/31/2013 10:41 PM, Patrick Walton wrote:
> Unbounded channels have defined behavior as well. Undefined behavior has
> a precise definition and OOM is not undefined behavior.

OOM is not a behavior. It's a DoS attack on the rest of the system.

From pcwalton at mozilla.com  Tue Dec 31 15:17:43 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 31 Dec 2013 15:17:43 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C3502B.9000207@gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>	<52C33833.90203@cantrip.org>	<52C33A07.3040002@mozilla.com>
	<52C3502B.9000207@gmail.com>
Message-ID: <52C35097.5030105@mozilla.com>

On 12/31/13 3:15 PM, Gy?rgy Andrasek wrote:
> On 12/31/2013 10:41 PM, Patrick Walton wrote:
>> Unbounded channels have defined behavior as well. Undefined behavior has
>> a precise definition and OOM is not undefined behavior.
>
> OOM is not a behavior. It's a DoS attack on the rest of the system.

When we speak of eliminating undefined behavior in Rust, we aren't 
speaking of taming code like:

     let mut v = ~[];
     loop {
         v.push(1)
     }

Eliminating this hazard simply isn't one of the goals of the language.

Patrick


From bascule at gmail.com  Tue Dec 31 15:38:45 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 31 Dec 2013 15:38:45 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0w7EZfzvEb4kmaUKnjmS=uns4xWP=zLQ0hBBU0F9qnAvw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CA+DvKQJFLZ+asyQrzGCaSSK8EUhKkwfc1cJGDSygXpboKbFO9Q@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com>
	<CAHYVw0w7EZfzvEb4kmaUKnjmS=uns4xWP=zLQ0hBBU0F9qnAvw@mail.gmail.com>
Message-ID: <CAHOTMVJ0QmSPfTbjfAHP9dauHhbtLXe+-dnvqgvu8J3DCtur9g@mail.gmail.com>

On Tue, Dec 31, 2013 at 1:50 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> what are some candidate data structures in that case? i'm happy to try and
> hack out some prototypes for that.
>

Can I talk about the counterpoint? What if we want to accept and handle
bounds to the messaging system? What data structure could we use for a
system which is willing to accept this constraint?

A particularly interesting data structure for this case is the RingBuffer
implemented as part of Disruptor:

http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-whats-so-special.html

In this setup, we have a single fixed-sized buffer which represents the
total number of messages in flight throughout the entire system (at least
if we're trying to emulate CSP atop Disruptor. This is something we've
played around with in Celluloid). This RingBuffer is implemented as a
lock-free/wait-free data structure which is specifically designed to be
cache-friendly (i.e. false sharing is specifically avoided).

On Tue, Dec 31, 2013 at 1:33 PM, Nathan Myers <ncm at cantrip.org> wrote:

> It's clear there are people who *want* both kinds of channels. It
> does not follow that they should both be first-class primitives.


Crazy idea: push channels out of the standard library ala
libgreen/libnative, and provide a trait for channel-alikes. Come up with a
least common denominator protocol, and ensure all channel-alikes support it.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/249b526d/attachment.html>

From jfager at gmail.com  Tue Dec 31 16:40:28 2013
From: jfager at gmail.com (Jason Fager)
Date: Tue, 31 Dec 2013 19:40:28 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C35097.5030105@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com> <52C3502B.9000207@gmail.com>
	<52C35097.5030105@mozilla.com>
Message-ID: <CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>

If you're pushing to an unbounded vec in a tight loop you've got
fundamental design issues.  If you're pushing to a channel, you've got
something like a server under load.  Use cases matter.

About the deadlock scenario, why aren't non-blocking sends sufficient to
address that concern? I'd personally argue just as strenuously as for
bounded channels that robust systems shouldn't have
senders that block indefinitely (nothing like waking up to a production
server that's hung on a socket someone removed the timeout from).

Also, again:  unbounded channels aren't, their bound is just arbitrary and
they fail catastrophically when it's hit.

Even if you don't OOM, channels that are too large are themselves a major
problem.  If you actually use your hardware you only have so much capacity.
 If your channel's getting backed up it's probably for a reason; when that
reason gets resolved you're going to need to go back to handling your
normal load plus everything you've been back-logging on your unbounded
channels.  That's one of the main things you tune with bounded channels:
how backed up can this reasonably be before I just can't catch up anymore?

In a browser, users might not want you to throw away events, but they
probably don't want to deal with their browser OOMing, or pausing for five
minutes and then machine-gun responding, either.  Again, anytime consumers
lag producers, you're screwed.  The question is, how can you respond to
mitigate?



On Tuesday, December 31, 2013, Patrick Walton wrote:

> On 12/31/13 3:15 PM, Gy?rgy Andrasek wrote:
>
>> On 12/31/2013 10:41 PM, Patrick Walton wrote:
>>
>>> Unbounded channels have defined behavior as well. Undefined behavior has
>>> a precise definition and OOM is not undefined behavior.
>>>
>>
>> OOM is not a behavior. It's a DoS attack on the rest of the system.
>>
>
> When we speak of eliminating undefined behavior in Rust, we aren't
> speaking of taming code like:
>
>     let mut v = ~[];
>     loop {
>         v.push(1)
>     }
>
> Eliminating this hazard simply isn't one of the goals of the language.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/77505423/attachment.html>

From jeanpierreda at gmail.com  Tue Dec 31 18:57:04 2013
From: jeanpierreda at gmail.com (Devin Jeanpierre)
Date: Tue, 31 Dec 2013 18:57:04 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com> <52C3502B.9000207@gmail.com>
	<52C35097.5030105@mozilla.com>
	<CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
Message-ID: <CABicbJLMtO9fmSf9CHKz0a6YxZ1RoUUctPAQPYhFpb1BbnwwXA@mail.gmail.com>

On Tue, Dec 31, 2013 at 4:40 PM, Jason Fager <jfager at gmail.com> wrote:
> About the deadlock scenario, why aren't non-blocking sends sufficient to
> address that concern? I'd personally argue just as strenuously as for
> bounded channels that robust systems shouldn't have senders that block
> indefinitely (nothing like waking up to a production server that's hung on a
> socket someone removed the timeout from).

They are clearly sufficient to eliminate deadlock, since nothing
blocks anymore. (Livelock is still possible, though.)

> Even if you don't OOM, channels that are too large are themselves a major
> problem.  If you actually use your hardware you only have so much capacity.
> If your channel's getting backed up it's probably for a reason; when that
> reason gets resolved you're going to need to go back to handling your normal
> load plus everything you've been back-logging on your unbounded channels.
> That's one of the main things you tune with bounded channels: how backed up
> can this reasonably be before I just can't catch up anymore?

Such a bound only exists in predictable environments. Most of the time
I would expect people to ask a different question, like "how backed up
can this be before I can conclude something has gone wrong?" or "how
backed up can this be before I just don't care anymore?"

-- Devin

From carter.schonwald at gmail.com  Tue Dec 31 19:07:59 2013
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 31 Dec 2013 22:07:59 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CABicbJLMtO9fmSf9CHKz0a6YxZ1RoUUctPAQPYhFpb1BbnwwXA@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com> <52C3502B.9000207@gmail.com>
	<52C35097.5030105@mozilla.com>
	<CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
	<CABicbJLMtO9fmSf9CHKz0a6YxZ1RoUUctPAQPYhFpb1BbnwwXA@mail.gmail.com>
Message-ID: <CAHYVw0wCyh_gK6rBZMTJsBeu7cZpL9q2u=eMz9m0wAEyd_PSFw@mail.gmail.com>

For the sake of concreteness, what would be an example of the live lock
scenario?

On Tuesday, December 31, 2013, Devin Jeanpierre wrote:

> On Tue, Dec 31, 2013 at 4:40 PM, Jason Fager <jfager at gmail.com<javascript:;>>
> wrote:
> > About the deadlock scenario, why aren't non-blocking sends sufficient to
> > address that concern? I'd personally argue just as strenuously as for
> > bounded channels that robust systems shouldn't have senders that block
> > indefinitely (nothing like waking up to a production server that's hung
> on a
> > socket someone removed the timeout from).
>
> They are clearly sufficient to eliminate deadlock, since nothing
> blocks anymore. (Livelock is still possible, though.)
>
> > Even if you don't OOM, channels that are too large are themselves a major
> > problem.  If you actually use your hardware you only have so much
> capacity.
> > If your channel's getting backed up it's probably for a reason; when that
> > reason gets resolved you're going to need to go back to handling your
> normal
> > load plus everything you've been back-logging on your unbounded channels.
> > That's one of the main things you tune with bounded channels: how backed
> up
> > can this reasonably be before I just can't catch up anymore?
>
> Such a bound only exists in predictable environments. Most of the time
> I would expect people to ask a different question, like "how backed up
> can this be before I can conclude something has gone wrong?" or "how
> backed up can this be before I just don't care anymore?"
>
> -- Devin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131231/2e37031f/attachment-0001.html>

From jeanpierreda at gmail.com  Tue Dec 31 19:27:10 2013
From: jeanpierreda at gmail.com (Devin Jeanpierre)
Date: Tue, 31 Dec 2013 19:27:10 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAHYVw0wCyh_gK6rBZMTJsBeu7cZpL9q2u=eMz9m0wAEyd_PSFw@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com> <52C3502B.9000207@gmail.com>
	<52C35097.5030105@mozilla.com>
	<CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
	<CABicbJLMtO9fmSf9CHKz0a6YxZ1RoUUctPAQPYhFpb1BbnwwXA@mail.gmail.com>
	<CAHYVw0wCyh_gK6rBZMTJsBeu7cZpL9q2u=eMz9m0wAEyd_PSFw@mail.gmail.com>
Message-ID: <CABicbJLc+FxcZw0k=Zj1TquK1yufqCFEBVn4ARZZULiLcGOupQ@mail.gmail.com>

On Tue, Dec 31, 2013 at 7:07 PM, Carter Schonwald
<carter.schonwald at gmail.com> wrote:
> For the sake of concreteness, what would be an example of the live lock
> scenario?

Suppose we have two channels, c1 and c2, and they are both full. The
deadlock scenario is where task 1 won't read from c2 until it can send
to c1, and task 2 won't read from c1 until it can send to c2. So both
of them won't read until they write, but they can't write until the
other reads.

The livelock scenario replaces foo.send() in the blocking model, with
while foo.send() {} (i.e. continuously retries sending until success).

Probably in real life the livelock is much more subtle than this. I've
personally never encountered a deadlock that was subtle (finding out
which thread is blocking on what is trivial, and deducing the deadlock
from that is just a matter of understanding the relationships between
the semaphores), so I'm not sure that it's actually better to replace
blocking channels because of deadlocks. However, I'm not a Serious
Programmer who deals a lot with concurrency, so maybe my intuition is
wrong or I haven't seen the right problems yet.

-- Devin

