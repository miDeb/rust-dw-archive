From ncm at cantrip.org  Wed Jan  1 01:51:04 2014
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 01 Jan 2014 01:51:04 -0800
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <52C33A07.3040002@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>
	<52C33833.90203@cantrip.org> <52C33A07.3040002@mozilla.com>
Message-ID: <52C3E508.7000303@cantrip.org>

On 12/31/2013 01:41 PM, Patrick Walton wrote:
 > Bounded channels can be constructed from unbounded channels as well,
 > so I don't see how this is an argument for making bounded channels
 > the primitive.

Sometimes we need an indefinite-precision integer, other times a
fixed-size integer. Sometimes we need a variable-sized array, others
a compile-time fixed-size array. A range-limited integer or array
can be constructed using the unrestricted type, but would lack exactly
those properties it needs in order to usable where you need one.

It should be clear that in each case one type is more fundamental,
implementation-wise, than the other, and can be used in circumstances
where the other is entirely unaffordable. One is necessarily primitive,
while the other can be constructed from primitives with no performance
penalty or restrictions.

There are many languages that offer indefinite-precision integers
and variable-sized arrays as primitives. No one uses them for
system coding.

Nathan Myers


From ncm at cantrip.org  Wed Jan  1 02:06:42 2014
From: ncm at cantrip.org (Nathan Myers)
Date: Wed, 01 Jan 2014 02:06:42 -0800
Subject: [rust-dev] Defined, precisely defined, and undefined
In-Reply-To: <52C33A07.3040002@mozilla.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>	<52BCD80F.2000806@cantrip.org>	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>	<52BDF2AD.9070605@mozilla.com>	<52BE411B.3040100@cantrip.org>	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>	<52BE5D16.40100@mozilla.com>	<52BE7AF7.3050306@cantrip.org>	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>	<52C24EEF.2010104@mozilla.com>
	<52C33833.90203@cantrip.org> <52C33A07.3040002@mozilla.com>
Message-ID: <52C3E8B2.2030503@cantrip.org>

On 12/31/2013 01:41 PM, Patrick Walton wrote:
> On 12/31/13 1:33 PM, Nathan Myers wrote:
 >>
>> The possibility of precisely defining the behavior of a bounded
>> channel in all circumstances is what makes it suitable as a
>> first-class primitive.
>
> Unbounded channels have defined behavior as well. Undefined behavior
 > has a precise definition and OOM is not undefined behavior.

Undefined is not the opposite of precisely defined.  OOM can not
be part of precisely defined behavior, because it isn't.

Nathan Myers

From kevin at sb.org  Wed Jan  1 09:46:10 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 1 Jan 2014 12:46:10 -0500
Subject: [rust-dev] Unbounded channels: Good idea/bad idea?
In-Reply-To: <CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
References: <CAHOTMVKmgUyBfcYwGMGmFrVL5FpdL67YnokMVej2hWr9n7Dnhw@mail.gmail.com>
	<CAPM5UJ0LJ8j2=WsGgL57XSRgqgjPnpjMkmB6mGyytataUe9ZSA@mail.gmail.com>
	<CA+DvKQJUcY0R-H+g+ZhA7-HLPT=PcXe=jo6htoDG5TbWg-rRcQ@mail.gmail.com>
	<CAPM5UJ3CTrNFhE4hX_VZrwD_pZ+cscV9b=eBYzPstzLLjno2DQ@mail.gmail.com>
	<CA+DvKQJXa_YDJgVHj93ReRBh5E4P9zN=Yq41mhhcVWstiGDb-w@mail.gmail.com>
	<CA+DvKQJ-qVcqoVYHMC_Lj2Lqn_R-xJssw8tU18cs6K_ak7wiVw@mail.gmail.com>
	<52BCD80F.2000806@cantrip.org>
	<CAHOTMVKXvtBHu9GXhenmBUfDQR9kq=4rQfRNT3_ug3vnAtF=nA@mail.gmail.com>
	<CA+DvKQJkN3qfm_r7CS2vHPjrR6s+--OqHaY63b1KKY3rN_phmA@mail.gmail.com>
	<52BDF2AD.9070605@mozilla.com> <52BE411B.3040100@cantrip.org>
	<CA+DvKQKaHrYC=Q8fGGRChM2dQOytvbAaD4VF9xy0toUhq4PiaA@mail.gmail.com>
	<52BE5D16.40100@mozilla.com> <52BE7AF7.3050306@cantrip.org>
	<CAPzKZDzyRxxj_GVWXMPDegd_LS0WJSgAoibq-6yL7jzNrfYAfg@mail.gmail.com>
	<52C24EEF.2010104@mozilla.com> <52C33833.90203@cantrip.org>
	<52C33A07.3040002@mozilla.com> <52C3502B.9000207@gmail.com>
	<52C35097.5030105@mozilla.com>
	<CAFEbTaW7n-_tCE7nAVoYsrrTq2d8X3qFanhfgjX1Of9juo+N9g@mail.gmail.com>
Message-ID: <E4A20B9B-3164-4498-BCBC-781148B35A41@sb.org>

On Dec 31, 2013, at 7:40 PM, Jason Fager <jfager at gmail.com> wrote:

> If you're pushing to an unbounded vec in a tight loop you've got fundamental design issues.

Or you?re processing user input. A rather trivial example here is parsing a file into lines. If I have 2GB of RAM and I throw a 4GB file at that parser, I?m going to have issues.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140101/5ca9903a/attachment.html>

From martin at minimum.se  Wed Jan  1 15:49:29 2014
From: martin at minimum.se (Martin Olsson)
Date: Thu, 02 Jan 2014 00:49:29 +0100
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call site?
Message-ID: <52C4A989.5010201@minimum.se>

Short version of my question:

Why doesn't rust require "mut" param prefix at call sites? i.e. to 
avoid "non-const ref badness" that C++ has?



Longer version of my question:

Since this question was asked recently by vadim and not really 
answered clearly (imo), I'm also including this longer verbose version 
of my question.

For example in C the call "f(a,&b);" might modify "b" but not "a" so 
the "&" token acts as a "call site heads-up flag" when reading the 
code. In C# the "out/ref" keywords are mandatory at the call site if 
the callee uses them in its param declaration so there you also get a 
little in hint when reading the code near the call site. C++ of course 
has non-const references so "f(a,&b);" might modify both "a" and "b" 
so the hint is missing and I really have to look up the code for "f()" 
to be sure. If some function foo() passes "a" to a bunch of functions 
then I have to find each such function and check if "a" can be 
modified or not, so potentially I have to open a bunch of files and 
read code there before I can fully understand the code near the call 
sites.

Because of this many large C++ projects have coding styles that 
disallow non-const refs. See for example the google C++ coding style 
guide:
http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Reference_Arguments#Reference_Arguments

Right now, it seems that rust works similar to C++ in this regard, 
meaning that there is no hint at the call site that a parameter may or 
may not be modified by the function.

In the snippet below, if I'm reading foo() in main.rs and I wonder 
which lines in foo() could possibly change the value of "i", then I 
have to open up 4 additional files and find the relevant source 
locations to double check which functions might mutate their arguments.

Why isn't it a good idea to require some parameter prefix like "mut" 
at the call site so that when I read main.rs I immediately will know 
which lines among the calls to funcA()..funcD() that might change the 
value of "i" ?


// ---[ funcA.rs ]-----------------------
fn funcA(i: &int) -> int{
     return 2**i;
}
// ---[ funcB.rs ]-----------------------
fn funcB(i: &mut int) -> int {
     *i += 1;
     return 0;
}
// ---[ funcC.rs ]-----------------------
fn funcC(i: &int) -> int {
     return 3**i;
}
// ---[ funcD.rs ]-----------------------
fn funcD(i: &int) -> int{
     return 2**i;
}
// ---[ main.rs ]-----------------------
fn foo(i: &mut int) {
     *i += 1;
     funcA(i);
     funcB(i); // no mut!
     funcC(i);
     funcD(i);
}
fn main() {
     let mut i: int = 0;
     foo(&mut i);
     println!("{}", i);
}



		Martin

From pcwalton at mozilla.com  Wed Jan  1 15:55:10 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 15:55:10 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <52C4A989.5010201@minimum.se>
References: <52C4A989.5010201@minimum.se>
Message-ID: <52C4AADE.3000602@mozilla.com>

On 1/1/14 3:49 PM, Martin Olsson wrote:
> For example in C the call "f(a,&b);" might modify "b" but not "a" so the
> "&" token acts as a "call site heads-up flag" when reading the code.

Same in Rust.

> In
> C# the "out/ref" keywords are mandatory at the call site if the callee
> uses them in its param declaration so there you also get a little in
> hint when reading the code near the call site.

C# has neither first-class pointers nor first-class references, so it 
isn't really a comparison.

> C++ of course has
> non-const references so "f(a,&b);" might modify both "a" and "b" so the
> hint is missing and I really have to look up the code for "f()" to be
> sure. If some function foo() passes "a" to a bunch of functions then I
> have to find each such function and check if "a" can be modified or not,
> so potentially I have to open a bunch of files and read code there
> before I can fully understand the code near the call sites.

That's right, and that's why Rust doesn't do this.

> Because of this many large C++ projects have coding styles that disallow
> non-const refs. See for example the google C++ coding style guide:
> http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Reference_Arguments#Reference_Arguments

Google's style guide allows mutable pointers, which are more like Rust 
references in this regard (except that pointers can be null in C++ and 
can't in Rust).

>
> Right now, it seems that rust works similar to C++ in this regard,
> meaning that there is no hint at the call site that a parameter may or
> may not be modified by the function.

No, Rust works like *C*, where if you pass a mutable *pointer* that was 
already mutable down a call chain then the callee can mutate it.

What C++ allows you to do that these style guides are trying to forbid 
is to pass an *lvalue* to a function and to have that function able to 
mutate that lvalue. That is not allowed in Rust.

> In the snippet below, if I'm reading foo() in main.rs and I wonder which
> lines in foo() could possibly change the value of "i", then I have to
> open up 4 additional files and find the relevant source locations to
> double check which functions might mutate their arguments.

You already had a mutable pointer; you can pass that mutable pointer 
down the call chain.

> Why isn't it a good idea to require some parameter prefix like "mut" at
> the call site so that when I read main.rs I immediately will know which
> lines among the calls to funcA()..funcD() that might change the value of
> "i" ?

Because that would work completely like any other language with pointers 
that I know of.

Patrick


From pcwalton at mozilla.com  Wed Jan  1 15:55:50 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 15:55:50 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <52C4AADE.3000602@mozilla.com>
References: <52C4A989.5010201@minimum.se> <52C4AADE.3000602@mozilla.com>
Message-ID: <52C4AB06.9010106@mozilla.com>

On 1/1/14 3:55 PM, Patrick Walton wrote:
> Because that would work completely like any other language with pointers
> that I know of.

Err, I mean "unlike".

Patrick


From comexk at gmail.com  Wed Jan  1 17:07:53 2014
From: comexk at gmail.com (comex)
Date: Wed, 1 Jan 2014 20:07:53 -0500
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <52C4A989.5010201@minimum.se>
References: <52C4A989.5010201@minimum.se>
Message-ID: <CAPM5UJ1FmzoOGm0MJ1Jb-s-SGW8HTXuvAt_FCv7oHC81iTeabw@mail.gmail.com>

On Wed, Jan 1, 2014 at 6:49 PM, Martin Olsson <martin at minimum.se> wrote:
> Short version of my question:
>
> Why doesn't rust require "mut" param prefix at call sites? i.e. to avoid
> "non-const ref badness" that C++ has?

Well, to be somewhat extreme, in a function like

struct S { a: &mut int, b: &mut int }
fn f(s: &mut &mut S) ...
fn g(s: &mut &mut S) { f(s) }

what sort of "mut"s does g need?

From slabode at aim.com  Wed Jan  1 20:26:42 2014
From: slabode at aim.com (SiegeLord)
Date: Wed, 01 Jan 2014 23:26:42 -0500
Subject: [rust-dev] Using CMake with Rust
Message-ID: <52C4EA82.1050706@aim.com>

(Posting this here as I think it might be useful for some but I don't 
feel like getting a Reddit account and there's no rust-announce).

I've been experimenting with building Rust crates using some established 
build systems, focusing on SCons and CMake due to their popularity. 
Neither turned out to be a perfect fit for Rust, but CMake was 
marginally less bad so I chose it in the end. To that end I created some 
CMake modules that make that integration be as painless as possible. 
Here's what a minimal CMakeLists.txt would look like for a single 
library crate project:

~~~
cmake_minimum_required(VERSION 2.8)
project(testlib NONE)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
find_package(rustc)
find_package(rustdoc)
include(Rust)

set(RUSTC_FLAGS "-L${CMAKE_BINARY_DIR}/lib")

rust_crate_auto(src/lib.rs TARGET_NAME TESTLIB)

add_custom_target(library_target
                   ALL
                   DEPENDS ${TESTLIB_FULL_TARGET})

install(FILES ${TESTLIB_ARTIFACTS}
         DESTINATION lib)
~~~

And then you'd do the usual out-of-source build. It will reconfigure the 
build system if any of the files referenced by src/lib.rs (as reported 
by rustc --dep-info) get changed. A more complete example that shows 
building several inter-dependent crates, documentation and tests can be 
seen here: https://github.com/SiegeLord/RustCMake . The modules for this 
to work are also found there.

Caveats: CMake doesn't know what Rust is, so it has to reconfigure the 
entire build system whenever you change any of the source files needed 
for *ANY* crate in your project (it doesn't need to do that with C/C++ 
because it has an internal dependency scanner). This won't be a big deal 
in small projects, and I find the convenience of using CMake to be worth 
it, but it does suggest that CMake is not the ultimate solution to 
building Rust projects.

-SL

From pcwalton at mozilla.com  Wed Jan  1 20:31:30 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 20:31:30 -0800
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <52C4EA82.1050706@aim.com>
References: <52C4EA82.1050706@aim.com>
Message-ID: <52C4EBA2.6070506@mozilla.com>

On 1/1/14 8:26 PM, SiegeLord wrote:
> (Posting this here as I think it might be useful for some but I don't
> feel like getting a Reddit account and there's no rust-announce).
>
> I've been experimenting with building Rust crates using some established
> build systems, focusing on SCons and CMake due to their popularity.
> Neither turned out to be a perfect fit for Rust, but CMake was
> marginally less bad so I chose it in the end. To that end I created some
> CMake modules that make that integration be as painless as possible.
> Here's what a minimal CMakeLists.txt would look like for a single
> library crate project:

Cool! Experimentation with build systems for Rust is awesome.

(To be honest?and these are just my own personal thoughts, and I do not 
speak for the entire team here?I'm beginning to wonder if we should just 
find which third-party build system works best, bless it, and build 
high-quality tooling around it rather than create another build system 
of our own.)

Patrick


From vadimcn at gmail.com  Wed Jan  1 20:41:34 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 1 Jan 2014 20:41:34 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <52C4A989.5010201@minimum.se>
References: <52C4A989.5010201@minimum.se>
Message-ID: <CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>

I think the real answer is "at this point nobody wants to tweak basic Rust
syntax yet again".   See the other thread about Rust roadmap, etc.  Oh
well...


On Wed, Jan 1, 2014 at 3:49 PM, Martin Olsson <martin at minimum.se> wrote:

> Short version of my question:
>
> Why doesn't rust require "mut" param prefix at call sites? i.e. to avoid
> "non-const ref badness" that C++ has?
>
>
>
> Longer version of my question:
>
> Since this question was asked recently by vadim and not really answered
> clearly (imo), I'm also including this longer verbose version of my
> question.
>
> For example in C the call "f(a,&b);" might modify "b" but not "a" so the
> "&" token acts as a "call site heads-up flag" when reading the code. In C#
> the "out/ref" keywords are mandatory at the call site if the callee uses
> them in its param declaration so there you also get a little in hint when
> reading the code near the call site. C++ of course has non-const references
> so "f(a,&b);" might modify both "a" and "b" so the hint is missing and I
> really have to look up the code for "f()" to be sure. If some function
> foo() passes "a" to a bunch of functions then I have to find each such
> function and check if "a" can be modified or not, so potentially I have to
> open a bunch of files and read code there before I can fully understand the
> code near the call sites.
>
> Because of this many large C++ projects have coding styles that disallow
> non-const refs. See for example the google C++ coding style guide:
> http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=
> Reference_Arguments#Reference_Arguments
>
> Right now, it seems that rust works similar to C++ in this regard, meaning
> that there is no hint at the call site that a parameter may or may not be
> modified by the function.
>
> In the snippet below, if I'm reading foo() in main.rs and I wonder which
> lines in foo() could possibly change the value of "i", then I have to open
> up 4 additional files and find the relevant source locations to double
> check which functions might mutate their arguments.
>
> Why isn't it a good idea to require some parameter prefix like "mut" at
> the call site so that when I read main.rs I immediately will know which
> lines among the calls to funcA()..funcD() that might change the value of
> "i" ?
>
>
> // ---[ funcA.rs ]-----------------------
> fn funcA(i: &int) -> int{
>     return 2**i;
> }
> // ---[ funcB.rs ]-----------------------
> fn funcB(i: &mut int) -> int {
>     *i += 1;
>     return 0;
> }
> // ---[ funcC.rs ]-----------------------
> fn funcC(i: &int) -> int {
>     return 3**i;
> }
> // ---[ funcD.rs ]-----------------------
> fn funcD(i: &int) -> int{
>     return 2**i;
> }
> // ---[ main.rs ]-----------------------
> fn foo(i: &mut int) {
>     *i += 1;
>     funcA(i);
>     funcB(i); // no mut!
>     funcC(i);
>     funcD(i);
> }
> fn main() {
>     let mut i: int = 0;
>     foo(&mut i);
>     println!("{}", i);
> }
>
>
>
>                 Martin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140101/04b9feb9/attachment-0001.html>

From jurily at gmail.com  Wed Jan  1 21:05:27 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Thu, 02 Jan 2014 06:05:27 +0100
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <52C4EA82.1050706@aim.com>
References: <52C4EA82.1050706@aim.com>
Message-ID: <52C4F397.3070104@gmail.com>

The proper way to support a language in CMake is outlined in
`Modules/CMakeAddNewLanguage.txt`:

> This file provides a few notes to CMake developers about how to add
> support for a new language to CMake.  It is also possible to place
> these files in CMAKE_MODULE_PATH within an outside project to add
> languages not supported by upstream CMake.  However, this is not
> a fully supported use case.
>
> The implementation behind the scenes of project/enable_language,
> including the compiler/platform modules, is an *internal* API that
> does not make any compatibility guarantees.  It is not covered in the
> official reference documentation that is versioned with the source code.
> Maintainers of external language support are responsible for porting
> it to each version of CMake as upstream changes are made.  Since
> the API is internal we will not necessarily include notice of any
> changes in release notes.
>
>
> CMakeDetermine(LANG)Compiler.cmake  -> this should find the compiler for LANG and configure CMake(LANG)Compiler.cmake.in
>
> CMake(LANG)Compiler.cmake.in  -> used by CMakeDetermine(LANG)Compiler.cmake
>     This file is used to store compiler information and is copied down into try
>     compile directories so that try compiles do not need to re-determine and test the LANG
>
> CMakeTest(LANG)Compiler.cmake -> test the compiler and set:
>     SET(CMAKE_(LANG)_COMPILER_WORKS 1 CACHE INTERNAL "")
>
> CMake(LANG)Information.cmake  -> set up rule variables for LANG :
> CMAKE_(LANG)_CREATE_SHARED_LIBRARY
> CMAKE_(LANG)_CREATE_SHARED_MODULE
> CMAKE_(LANG)_CREATE_STATIC_LIBRARY
> CMAKE_(LANG)_COMPILE_OBJECT
> CMAKE_(LANG)_LINK_EXECUTABLE


I've been playing around with it, but so far I haven't been able to get 
a test case off the ground. I have no idea how to actually make this 
format string expand for example, or where to find documentation.

>   set(CMAKE_Java_COMPILE_OBJECT
>     "<CMAKE_Java_COMPILER> <FLAGS> <SOURCE> -d <OBJECT_DIR>")




From pwalton at mozilla.com  Wed Jan  1 21:12:30 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 21:12:30 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at
	call	site?
In-Reply-To: <CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>
	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
Message-ID: <2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>

There is no "real answer" beyond the one I already gave: that we are already precisely as explicit as C, that Rust references do not actually have the hidden mutation hazard of C++ references, and that changing would place the language in a different space entirely. Please don't suggest that I am (or that anyone else on the list is) being dishonest.

Patrick

Vadim <vadimcn at gmail.com> wrote:
>I think the real answer is "at this point nobody wants to tweak basic
>Rust
>syntax yet again".   See the other thread about Rust roadmap, etc.  Oh
>well...
>
>
>On Wed, Jan 1, 2014 at 3:49 PM, Martin Olsson <martin at minimum.se>
>wrote:
>
>> Short version of my question:
>>
>> Why doesn't rust require "mut" param prefix at call sites? i.e. to
>avoid
>> "non-const ref badness" that C++ has?
>>
>>
>>
>> Longer version of my question:
>>
>> Since this question was asked recently by vadim and not really
>answered
>> clearly (imo), I'm also including this longer verbose version of my
>> question.
>>
>> For example in C the call "f(a,&b);" might modify "b" but not "a" so
>the
>> "&" token acts as a "call site heads-up flag" when reading the code.
>In C#
>> the "out/ref" keywords are mandatory at the call site if the callee
>uses
>> them in its param declaration so there you also get a little in hint
>when
>> reading the code near the call site. C++ of course has non-const
>references
>> so "f(a,&b);" might modify both "a" and "b" so the hint is missing
>and I
>> really have to look up the code for "f()" to be sure. If some
>function
>> foo() passes "a" to a bunch of functions then I have to find each
>such
>> function and check if "a" can be modified or not, so potentially I
>have to
>> open a bunch of files and read code there before I can fully
>understand the
>> code near the call sites.
>>
>> Because of this many large C++ projects have coding styles that
>disallow
>> non-const refs. See for example the google C++ coding style guide:
>>
>http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=
>> Reference_Arguments#Reference_Arguments
>>
>> Right now, it seems that rust works similar to C++ in this regard,
>meaning
>> that there is no hint at the call site that a parameter may or may
>not be
>> modified by the function.
>>
>> In the snippet below, if I'm reading foo() in main.rs and I wonder
>which
>> lines in foo() could possibly change the value of "i", then I have to
>open
>> up 4 additional files and find the relevant source locations to
>double
>> check which functions might mutate their arguments.
>>
>> Why isn't it a good idea to require some parameter prefix like "mut"
>at
>> the call site so that when I read main.rs I immediately will know
>which
>> lines among the calls to funcA()..funcD() that might change the value
>of
>> "i" ?
>>
>>
>> // ---[ funcA.rs ]-----------------------
>> fn funcA(i: &int) -> int{
>>     return 2**i;
>> }
>> // ---[ funcB.rs ]-----------------------
>> fn funcB(i: &mut int) -> int {
>>     *i += 1;
>>     return 0;
>> }
>> // ---[ funcC.rs ]-----------------------
>> fn funcC(i: &int) -> int {
>>     return 3**i;
>> }
>> // ---[ funcD.rs ]-----------------------
>> fn funcD(i: &int) -> int{
>>     return 2**i;
>> }
>> // ---[ main.rs ]-----------------------
>> fn foo(i: &mut int) {
>>     *i += 1;
>>     funcA(i);
>>     funcB(i); // no mut!
>>     funcC(i);
>>     funcD(i);
>> }
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>>
>>
>>
>>                 Martin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140101/0f19722b/attachment.html>

From palmercox at gmail.com  Wed Jan  1 21:13:55 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Thu, 2 Jan 2014 00:13:55 -0500
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>
	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
Message-ID: <CAPZendzqYMWGO7q7Yb_Ed7TtmTUuytZcaQ3J4Dvu82t9D33LiA@mail.gmail.com>

I could be pretty wrong, so if I am, I apologize and please ignore. Anyway,
I thought I once read somewhere that when you call a function defined like:

fn foo(a: &mut int) { ... }

with code that looks like

fn bar(b: &mut int) {
    foo(b);
}

that despite what it looks like, you aren't really passing the value b into
the function foo(). My understanding, is that when you pass a reference to
foo(), that it takes ownership of that reference making it inaccessible to
any following code. Since this is generally not what anyone wants, Rust
silently re-borrows b and passes that re-borrowed version of the reference
to foo() which takes ownership of it. Since b wasn't actually passed to
foo(), code after the call to foo() can continue to use b since bar() still
owns b.

Anyway, if that is all correct, and I'm not sure how likely that is all to
be correct, it feels like what this email thread really boils down to is a
proposal to eliminate automatic re-borrowing of a &mut to &mut when
invoking a function. I'm may be wrong, but, I'm also under the impression
that manually re-borrowing would look something like:

foo(&mut (*b))

which is extremely unpleasant, so, I'd imagine that the 2nd part of the
proposal is to make some sort of nicer syntax for that.

To me, this doesn't sound as much like a proposal for a change in syntax as
a proposal to remove a bit of magic that Rust is currently doing. I don't
know that I'm necessarily in favor or that though, since it would certainly
make code more wordy. That wordiness might be nice, however, if it makes it
clearer where variables might be mutated (eg: imagine that foo() is
originally defined to take a & ,so bar() assumed that the variable won't be
mutated. However foo() is later redefined to take a &mut which silently
breaks bar()'s assumption about foo()).

-Palmer Cox





On Wed, Jan 1, 2014 at 11:41 PM, Vadim <vadimcn at gmail.com> wrote:

> I think the real answer is "at this point nobody wants to tweak basic Rust
> syntax yet again".   See the other thread about Rust roadmap, etc.  Oh
> well...
>
>
> On Wed, Jan 1, 2014 at 3:49 PM, Martin Olsson <martin at minimum.se> wrote:
>
>> Short version of my question:
>>
>> Why doesn't rust require "mut" param prefix at call sites? i.e. to avoid
>> "non-const ref badness" that C++ has?
>>
>>
>>
>> Longer version of my question:
>>
>> Since this question was asked recently by vadim and not really answered
>> clearly (imo), I'm also including this longer verbose version of my
>> question.
>>
>> For example in C the call "f(a,&b);" might modify "b" but not "a" so the
>> "&" token acts as a "call site heads-up flag" when reading the code. In C#
>> the "out/ref" keywords are mandatory at the call site if the callee uses
>> them in its param declaration so there you also get a little in hint when
>> reading the code near the call site. C++ of course has non-const references
>> so "f(a,&b);" might modify both "a" and "b" so the hint is missing and I
>> really have to look up the code for "f()" to be sure. If some function
>> foo() passes "a" to a bunch of functions then I have to find each such
>> function and check if "a" can be modified or not, so potentially I have to
>> open a bunch of files and read code there before I can fully understand the
>> code near the call sites.
>>
>> Because of this many large C++ projects have coding styles that disallow
>> non-const refs. See for example the google C++ coding style guide:
>> http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=
>> Reference_Arguments#Reference_Arguments
>>
>> Right now, it seems that rust works similar to C++ in this regard,
>> meaning that there is no hint at the call site that a parameter may or may
>> not be modified by the function.
>>
>> In the snippet below, if I'm reading foo() in main.rs and I wonder which
>> lines in foo() could possibly change the value of "i", then I have to open
>> up 4 additional files and find the relevant source locations to double
>> check which functions might mutate their arguments.
>>
>> Why isn't it a good idea to require some parameter prefix like "mut" at
>> the call site so that when I read main.rs I immediately will know which
>> lines among the calls to funcA()..funcD() that might change the value of
>> "i" ?
>>
>>
>> // ---[ funcA.rs ]-----------------------
>> fn funcA(i: &int) -> int{
>>     return 2**i;
>> }
>> // ---[ funcB.rs ]-----------------------
>> fn funcB(i: &mut int) -> int {
>>     *i += 1;
>>     return 0;
>> }
>> // ---[ funcC.rs ]-----------------------
>> fn funcC(i: &int) -> int {
>>     return 3**i;
>> }
>> // ---[ funcD.rs ]-----------------------
>> fn funcD(i: &int) -> int{
>>     return 2**i;
>> }
>> // ---[ main.rs ]-----------------------
>> fn foo(i: &mut int) {
>>     *i += 1;
>>     funcA(i);
>>     funcB(i); // no mut!
>>     funcC(i);
>>     funcD(i);
>> }
>> fn main() {
>>     let mut i: int = 0;
>>     foo(&mut i);
>>     println!("{}", i);
>> }
>>
>>
>>
>>                 Martin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/5f3c7026/attachment-0001.html>

From pcwalton at mozilla.com  Wed Jan  1 21:25:58 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 21:25:58 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <CAPZendzqYMWGO7q7Yb_Ed7TtmTUuytZcaQ3J4Dvu82t9D33LiA@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
	<CAPZendzqYMWGO7q7Yb_Ed7TtmTUuytZcaQ3J4Dvu82t9D33LiA@mail.gmail.com>
Message-ID: <52C4F866.1010007@mozilla.com>

On 1/1/14 9:13 PM, Palmer Cox wrote:
> To me, this doesn't sound as much like a proposal for a change in syntax
> as a proposal to remove a bit of magic that Rust is currently doing. I
> don't know that I'm necessarily in favor or that though, since it would
> certainly make code more wordy. That wordiness might be nice, however,
> if it makes it clearer where variables might be mutated (eg: imagine
> that foo() is originally defined to take a & ,so bar() assumed that the
> variable won't be mutated. However foo() is later redefined to take a
> &mut which silently breaks bar()'s assumption about foo()).

That's a much more interesting question. I do worry about the verbosity 
though, as you said.

In general I feel like we should either have autoborrowing in as many 
places as reasonably possible or autoborrowing nowhere.

Patrick

From slabode at aim.com  Wed Jan  1 21:32:18 2014
From: slabode at aim.com (SiegeLord)
Date: Thu, 02 Jan 2014 00:32:18 -0500
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <52C4F397.3070104@gmail.com>
References: <52C4EA82.1050706@aim.com> <52C4F397.3070104@gmail.com>
Message-ID: <52C4F9E2.1070702@aim.com>

On 01/02/2014 12:05 AM, Gy?rgy Andrasek wrote:
> The proper way to support a language in CMake is outlined in
> `Modules/CMakeAddNewLanguage.txt`:

I was guided away from that method by this email: 
http://www.cmake.org/pipermail/cmake/2011-March/043444.html . My 
approach is amenable to generating files for alternative build systems, 
like ninja. If you are aware that that email is incorrect, I'm glad to 
be corrected. Independently of that email, I have looked into doing it 
that way, but I found that it just did not mesh with the Rust 
compilation model, and I saw no clear way to using the information given 
by 'rustc --dep-info' to inform the build system. Additionally, my 
macros allow an easy way of doing documentation generation, which that 
method doesn't clearly allow.

I'll be glad to be corrected on all those points though.

-SL


From sh4.seo at samsung.com  Wed Jan  1 21:57:46 2014
From: sh4.seo at samsung.com (Sanghyeon Seo)
Date: Thu, 02 Jan 2014 05:57:46 +0000 (GMT)
Subject: [rust-dev] on quality & success
Message-ID: <14244309.214971388642265762.JavaMail.weblogic@epml24>

> Deciding to reuse wrong, but mainstream, design decisions in one's own language
> is deciding to intentionally make it of lower quality. !!! Funny (read: mad),
> isn't it? It is thus also intentionally deciding to make it not worth success.
> This, apparently, to make its actual chances of success higher. (Isn't our
> culture funny?)

First, thank you for bringing up the important point.

While I agree that many language designers do decide to intentionally make it of
lower quality according to their subjective measure of quality, this is in no way new,
mad, or funny. Your error seems to be thinking that such decisions make the language
not worth success -- but in actuality such decisions make the language *less* worth
success, and worth rarely reaches zero. Abstractly, if such decisions raise the chance
of success higher, it can increases the expected worth of success.

I consider creating a new programming language analogous to forming a new political
party. (I pity you if you live in a two-party system.) For any given party, its platform is
distinctly inferior to any of its supporter's ideal platform. In other words, party supporters
are compromising in order to cooperate. People compromise in order to cooperate,
because, even if compromising on your ideal is painful, cooperation is often much better
way to change the world. Of course, one is free to conduct political activism alone,
but such people usually do not consider political parties mad or funny.

Thanks.

From vadimcn at gmail.com  Wed Jan  1 22:06:14 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 1 Jan 2014 22:06:14 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
References: <52C4A989.5010201@minimum.se>
	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
Message-ID: <CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>

On Wed, Jan 1, 2014 at 9:12 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> There is no "real answer" beyond the one I already gave: that we are
> already precisely as explicit as C, that Rust references do not actually
> have the hidden mutation hazard of C++ references, and that changing would
> place the language in a different space entirely.
>

Patrick, I disagree with this point.  Rust references *do* have hidden
mutation hazard, as do C's and C++'s pointers.  In all three, mutation
hazard is only obvious when you take an address of a stack variable.
After that, when you already have a pointer, you pass it around, and never
know who might mutate the underlying object.  And let's not forget about
the heap-allocated objects, which start out as pointers in the first place.

Well, since requiring '&' at the original borrow site doesn't really
prevent the "unexpected mutability" problem, why not drop it and eliminate
a bunch of noise from Rust sources?   And, again, if "unexpected
mutability" is what concerns people, "mut" annotation is the better way to
fix that, IMHO.


>  Please don't suggest that I am (or that anyone else on the list is) being
> dishonest.
>

My apologies, I didn't mean to imply that.

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140101/c26235b5/attachment.html>

From palmercox at gmail.com  Wed Jan  1 22:13:58 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Thu, 2 Jan 2014 01:13:58 -0500
Subject: [rust-dev] on quality & success
In-Reply-To: <52C2B0F7.2000103@gmail.com>
References: <52C2B0F7.2000103@gmail.com>
Message-ID: <CAPZendxCbUgutJ80Cd5c6cPcb7piocfROD3OhB8NGRmgXRppbQ@mail.gmail.com>

Everyone is entitled to their own opinions. However, those opinions should
be expressed in a polite manner. Phrases such as "Choice he (since its
mostly men)" and "mentally masturbate" do not seem to foster a welcoming,
inclusive environment. Quoting from
https://github.com/mozilla/rust/wiki/Note-development-policy#conduct:

* We are committed to providing a friendly, safe and welcoming environment
for all, regardless of gender, sexual orientation, disability, ethnicity,
religion, or similar personal characteristic

Thanks,
-Palmer Cox




On Tue, Dec 31, 2013 at 6:56 AM, spir <denis.spir at gmail.com> wrote:

> Hol?!
>
> [This is a rather personal and involved post. Press del if you feel like
> it...]
> [also, it is long]
> [copy to rust-dev mailing list: actually the post is inspired by a thread
> there "Thoughts on the Rust Roadmap"]
>
> There is a point obvious to me; apparently most people including many
> language designers don't share it, or act as if they did not:
>
>     a language should be successful iff it is of high quality
>
> A kind of symmetric statement also holds;
>
>     let us hope low quality languages have no success!
>
> There are various reasons to hope this, the most stupid beeing that
> successful languages influence others, present & future. This is in my view
> a symptom of our civilisation's funny spirit (read: madness), and related
> to the actual points I intend to state (if, for once, I manage to express
> my thought).
>
> Apparently, many language designers proceed more or less the following
> way: there are a few key points (for them) they consider mis-designed or
> missing or wrong in some way in existing languages (not all the same for
> every language). Thus, they want to make a language that repairs these
> points, all together. Then, certainly in fear that too many changes may
> repel potential adopters of their language, in hope to maximise its chances
> of success *despite* it breaking habits on the key points more important to
> them, they won't change anything else, or only the bare minimum they can.
> They want instead to remain as mainstream as possible on everything else.
> [4]
>
> I consider this spirit bad; I mean, very bad. This is the way basic design
> errors propagate from successful languages to others, for instance. [1]
> Apparently, it takes a great dose of courage to break any existing practice
> in a _new_ language: tell me why, I do not understand.
>
> Note that I am here talking of wrong design points in the opinion of a
> given language designer. Choices he (since it's mostly men) would not do if
> programming were a new field, open to all explorations. (There are indeed
> loads of subjective or ideological design points; see also [1] & [3])
> However, while programming is not a new field anymore, it is indeed open to
> all explorations, for you, for me, if you or me wants it. Nothing blocks us
> but our own bloackages, our own fears, and, probably, wrong rationales,
> perhaps non-fully-conscious ones.
>
> Deciding to reuse wrong, but mainstream, design decisions in one's own
> language is deciding to intentionally make it of lower quality. !!! Funny
> (read: mad), isn't it? It is thus also intentionally deciding to make it
> not worth success. This, apparently, to make its actual chances of success
> higher. (Isn't our culture funny?)
> Then, why does one _actually_ make a new language? For the joy of making
> something good? To contribute to a better world, since languages and
> programming are a common good? [2] For the joy of offering something of as
> high a quality as humanly possible? Else, why? For fame, honour, status,
> money, power? To mentally masturbate on the idea of having made something
> "sucessful" (sic!)?
>
> We are not in need of yet another language trying, or pretending, to
> improve on a handful of disparate points, leaving all the rest as is,
> meaning in bad state. And, as an example, we are not in need of yet another
> failed trial for a successor to C as major low-level lang.
> Differences, thought of by their designer as significant quality
> improvements, are the *reasons* for programmers to adopt a new language.
> There are the _only_ (good) reasons to do so. Thinking that programmers may
> adopt a new language _despite_ its differences is thinking backwards; this,
> in addition to preventing oneself from working for the common good; by
> fear, probably; fear of truely thinking by oneself and/or of making one's
> true thinking public truely. (I can understand that, however: I often do
> not disclose my thinking by fear of the terrible level of violence, in my
> view, present in the programming "community" [hum!], and among geeks in
> general. This, rather than sharing and mutual help and cooperation, for the
> common wealth. Our civilisation... again.)
>
> I have recently decided to adopt possible differences even if i am not
> that convinced of their betterness; to give alternatives a try; to give
> them at least a chance to show us (or just me) how good they actually are,
> or not, in practice, maybe on the long term [3].
> This may go too far; it is a personal decision.
>
> However, deciding not to change what one sees wrong is weird for the
> least. It means removing points of quality according to one's own views,
> removing chances to contrbute to a better world, removing sources of
> personal satisfaction, removing reasons for others to judge a language
> better, thus removing motivation for programmers to adopt it. Maybe,
> certainly, many programmers do not adopt a language on the base of its
> quality, only; however, this counts; people I wish would adopt my lang, if
> ever, are those people who judge first on quality, not hype followers or
> otherwise conservatives.
> What I mean is, apart from working against the common wealth, in addition
> to preventing one's own enjoyment of doing what one does, such an attitude
> may also work against a language's potential success. Is this (a factor)
> why we have no successor to C yet, what do you think? because most
> designers kept most of its design bugs unchanged? [4] just to have a
> minimal chance, should a potential successor instead break as much as
> possible? (And not have a builtin interface to C? ???)
>
> Also note that attitudes and spirits are psycho-sociologically contagious.
> In particular, fear and lack of courage and angst are highly contagious (in
> our world, with such a close to universal high level of anxiety...) What if
> more (would-be) language designers boldly thought by themselves and boldly
> assumed their thoughts?
>
> Final note: isn't it weird that such conformism is _that_ prevalent among
> language designers? Precisely the ones who should be bearers of novelty?
> the one "milieu" which could & should be a network of interacting
> counter-cultures and individual iconoclasts (idol breakers)?
>
> I do not expect anyone shares (all of) this. I just hope it may open new
> ways of thinking or questionning to a few.
>
> Denis
>
> [1] Including the funny usage of "=" for assignment and "==" for equality,
> after at least 5 decades, lol! Still my favorite syntactic error after
> dozens of thousands of hours of programming in languages which nearly all
> use this amusing convention. Why not use "if" to mean 'try' or 'switch' or
> 'foreach', and "ifif" to mean 'if'? What do you think?
>
> [2] Actually, they are both communal and social. Better quality languages
> may contribute to a better world, at a communal level because we
> programmers share code and read others' code all the time, and at a social
> level because apps are a significant part of the world's state.
>
> [3] As you certainly know, it takes time to unlearn, especially to stop
> judging something bad while it is just different. (Think at C programmers
> and their beloved code block {} braces. I for one have better usage for
> brace ;-.)
>
> [4] As an anecdote, somewhat complementary, in the course of my
> explorations about programming languages, I often stepped on lists of C
> design bugs, at least a dozen of them. Typically endless lists that take a
> quarter of an hour to read in one go, without comments. There is space to
> works for a language lover :-). If not enough, usually such critics seems
> to agree on more than half of the points (and the remaining ones may not
> figure on some lists just because the critic not think at it or did not
> study this point) (but their solutions may diverge...).
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/6c35a5d9/attachment-0001.html>

From pcwalton at mozilla.com  Wed Jan  1 22:18:02 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 01 Jan 2014 22:18:02 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
Message-ID: <52C5049A.9080705@mozilla.com>

On 1/1/14 10:06 PM, Vadim wrote:
> Well, since requiring '&' at the original borrow site doesn't really
> prevent the "unexpected mutability" problem, why not drop it and
> eliminate a bunch of noise from Rust sources?

But it does eliminate mutation of lvalues.

> And, again, if
> "unexpected mutability" is what concerns people, "mut" annotation is the
> better way to fix that, IMHO.

I don't know if it's a coherent proposal. Consider these four function 
signatures, each of which might mutate their arguments:

     fn f(x: &mut int) { ... }

     fn g(x: (&mut int, &mut int)) { ... }

     struct S<'a> {
         a: &'a mut int,
         b: &'a mut uint,
     }
     fn h(x: S) { ... }

     fn i<T>(x: T, f: |T|) { f(x) }

How might `i` mutate its argument? Consider function `j`:

     fn j() {
         let mut x = 3;
         i(&mut x, |ptr| *ptr = 5);
     }

So `i` mutated its argument. So how should you be forced to notate that? 
Should you have to write:

     fn i<T>(x: T, f: |T|) { f(mut x) }

     ... i(&mut x, |ptr| *ptr = 5);

Or:

     fn i<T>(x: T, f: |T|) { f(x) }

     ... i(mut &mut x, |ptr| *ptr = 5);

Or:

     fn i<T>(x: T, f: |T|) { f(mut x) }

     ... i(mut &mut x, |ptr| *ptr = 5);

And that's just a simple example: start throwing in existential types 
like traits and it becomes clear that you really can't tell from the 
program where mutation could possibly happen, because the types are 
hiding mutability from you. And that's fine--existential types and 
generics deliberately permit that abstraction. But it does mean, I 
think, that we can't meaningfully talk about a sound and complete "mut" 
annotation at call sites.

Patrick


From danielmicay at gmail.com  Wed Jan  1 22:21:07 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 2 Jan 2014 01:21:07 -0500
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>
	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
Message-ID: <CA+DvKQK5Pjj1kHhbfNPTq_Gv0MUvO95aH25R4xWRAYpmuPg9zg@mail.gmail.com>

On Thu, Jan 2, 2014 at 1:06 AM, Vadim <vadimcn at gmail.com> wrote:
>
> And let's not forget about the heap-allocated objects, which start out as pointers in the first place.

Unique pointers have value semantics so this shouldn't be relevant to
the visibility of mutation. The consensus is already to remove the
auto-coercion of `~T` to `&mut T` because it doesn't make any sense.
The auto-coercion to `&T` will probably either be removed or extended
to `T` too, but that hasn't been decided (or discussed much).

From martin at minimum.se  Thu Jan  2 03:37:01 2014
From: martin at minimum.se (martin at minimum.se)
Date: Thu, 02 Jan 2014 12:37:01 +0100
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <52C5049A.9080705@mozilla.com>
Message-ID: <9a32a43bac33d83337bf0d8ce7db73e5192ff321@mail.glesys.se>

Thanks, that explains it.Martin?
----- Original Message -----
From: "Patrick Walton" 
And that's just a simple example: start throwing in existential types 
 like traits and it becomes clear that you really can't tell from the 
 program where mutation could possibly happen, because the types are 
 hiding mutability from you. And that's fine--existential types and 
 generics deliberately permit that abstraction But it does mean, I 
 think, that we can't meaningfully talk about a sound and complete
"mut" 
 annotation at call sites.

 Patrick


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/cc067b00/attachment.html>

From gaetan at xeberon.net  Thu Jan  2 07:09:48 2014
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 2 Jan 2014 16:09:48 +0100
Subject: [rust-dev] on quality & success
In-Reply-To: <CAPZendxCbUgutJ80Cd5c6cPcb7piocfROD3OhB8NGRmgXRppbQ@mail.gmail.com>
References: <52C2B0F7.2000103@gmail.com>
	<CAPZendxCbUgutJ80Cd5c6cPcb7piocfROD3OhB8NGRmgXRppbQ@mail.gmail.com>
Message-ID: <CANK7tAFZ32ZUJC+ukKBzFvmGgvhydOGZpDh8OtXcU65HtPgLaQ@mail.gmail.com>

I also agree this thread doesn't add grist to the mill. Let's cut it.

-----
Gaetan



2014/1/2 Palmer Cox <palmercox at gmail.com>

> Everyone is entitled to their own opinions. However, those opinions should
> be expressed in a polite manner. Phrases such as "Choice he (since its
> mostly men)" and "mentally masturbate" do not seem to foster a welcoming,
> inclusive environment. Quoting from
> https://github.com/mozilla/rust/wiki/Note-development-policy#conduct:
>
> * We are committed to providing a friendly, safe and welcoming
> environment for all, regardless of gender, sexual orientation, disability,
> ethnicity, religion, or similar personal characteristic
>
> Thanks,
> -Palmer Cox
>
>
>
>
> On Tue, Dec 31, 2013 at 6:56 AM, spir <denis.spir at gmail.com> wrote:
>
>> Hol?!
>>
>> [This is a rather personal and involved post. Press del if you feel like
>> it...]
>> [also, it is long]
>> [copy to rust-dev mailing list: actually the post is inspired by a thread
>> there "Thoughts on the Rust Roadmap"]
>>
>> There is a point obvious to me; apparently most people including many
>> language designers don't share it, or act as if they did not:
>>
>>     a language should be successful iff it is of high quality
>>
>> A kind of symmetric statement also holds;
>>
>>     let us hope low quality languages have no success!
>>
>> There are various reasons to hope this, the most stupid beeing that
>> successful languages influence others, present & future. This is in my view
>> a symptom of our civilisation's funny spirit (read: madness), and related
>> to the actual points I intend to state (if, for once, I manage to express
>> my thought).
>>
>> Apparently, many language designers proceed more or less the following
>> way: there are a few key points (for them) they consider mis-designed or
>> missing or wrong in some way in existing languages (not all the same for
>> every language). Thus, they want to make a language that repairs these
>> points, all together. Then, certainly in fear that too many changes may
>> repel potential adopters of their language, in hope to maximise its chances
>> of success *despite* it breaking habits on the key points more important to
>> them, they won't change anything else, or only the bare minimum they can.
>> They want instead to remain as mainstream as possible on everything else.
>> [4]
>>
>> I consider this spirit bad; I mean, very bad. This is the way basic
>> design errors propagate from successful languages to others, for instance.
>> [1] Apparently, it takes a great dose of courage to break any existing
>> practice in a _new_ language: tell me why, I do not understand.
>>
>> Note that I am here talking of wrong design points in the opinion of a
>> given language designer. Choices he (since it's mostly men) would not do if
>> programming were a new field, open to all explorations. (There are indeed
>> loads of subjective or ideological design points; see also [1] & [3])
>> However, while programming is not a new field anymore, it is indeed open to
>> all explorations, for you, for me, if you or me wants it. Nothing blocks us
>> but our own bloackages, our own fears, and, probably, wrong rationales,
>> perhaps non-fully-conscious ones.
>>
>> Deciding to reuse wrong, but mainstream, design decisions in one's own
>> language is deciding to intentionally make it of lower quality. !!! Funny
>> (read: mad), isn't it? It is thus also intentionally deciding to make it
>> not worth success. This, apparently, to make its actual chances of success
>> higher. (Isn't our culture funny?)
>> Then, why does one _actually_ make a new language? For the joy of making
>> something good? To contribute to a better world, since languages and
>> programming are a common good? [2] For the joy of offering something of as
>> high a quality as humanly possible? Else, why? For fame, honour, status,
>> money, power? To mentally masturbate on the idea of having made something
>> "sucessful" (sic!)?
>>
>> We are not in need of yet another language trying, or pretending, to
>> improve on a handful of disparate points, leaving all the rest as is,
>> meaning in bad state. And, as an example, we are not in need of yet another
>> failed trial for a successor to C as major low-level lang.
>> Differences, thought of by their designer as significant quality
>> improvements, are the *reasons* for programmers to adopt a new language.
>> There are the _only_ (good) reasons to do so. Thinking that programmers may
>> adopt a new language _despite_ its differences is thinking backwards; this,
>> in addition to preventing oneself from working for the common good; by
>> fear, probably; fear of truely thinking by oneself and/or of making one's
>> true thinking public truely. (I can understand that, however: I often do
>> not disclose my thinking by fear of the terrible level of violence, in my
>> view, present in the programming "community" [hum!], and among geeks in
>> general. This, rather than sharing and mutual help and cooperation, for the
>> common wealth. Our civilisation... again.)
>>
>> I have recently decided to adopt possible differences even if i am not
>> that convinced of their betterness; to give alternatives a try; to give
>> them at least a chance to show us (or just me) how good they actually are,
>> or not, in practice, maybe on the long term [3].
>> This may go too far; it is a personal decision.
>>
>> However, deciding not to change what one sees wrong is weird for the
>> least. It means removing points of quality according to one's own views,
>> removing chances to contrbute to a better world, removing sources of
>> personal satisfaction, removing reasons for others to judge a language
>> better, thus removing motivation for programmers to adopt it. Maybe,
>> certainly, many programmers do not adopt a language on the base of its
>> quality, only; however, this counts; people I wish would adopt my lang, if
>> ever, are those people who judge first on quality, not hype followers or
>> otherwise conservatives.
>> What I mean is, apart from working against the common wealth, in addition
>> to preventing one's own enjoyment of doing what one does, such an attitude
>> may also work against a language's potential success. Is this (a factor)
>> why we have no successor to C yet, what do you think? because most
>> designers kept most of its design bugs unchanged? [4] just to have a
>> minimal chance, should a potential successor instead break as much as
>> possible? (And not have a builtin interface to C? ???)
>>
>> Also note that attitudes and spirits are psycho-sociologically
>> contagious. In particular, fear and lack of courage and angst are highly
>> contagious (in our world, with such a close to universal high level of
>> anxiety...) What if more (would-be) language designers boldly thought by
>> themselves and boldly assumed their thoughts?
>>
>> Final note: isn't it weird that such conformism is _that_ prevalent among
>> language designers? Precisely the ones who should be bearers of novelty?
>> the one "milieu" which could & should be a network of interacting
>> counter-cultures and individual iconoclasts (idol breakers)?
>>
>> I do not expect anyone shares (all of) this. I just hope it may open new
>> ways of thinking or questionning to a few.
>>
>> Denis
>>
>> [1] Including the funny usage of "=" for assignment and "==" for
>> equality, after at least 5 decades, lol! Still my favorite syntactic error
>> after dozens of thousands of hours of programming in languages which nearly
>> all use this amusing convention. Why not use "if" to mean 'try' or 'switch'
>> or 'foreach', and "ifif" to mean 'if'? What do you think?
>>
>> [2] Actually, they are both communal and social. Better quality languages
>> may contribute to a better world, at a communal level because we
>> programmers share code and read others' code all the time, and at a social
>> level because apps are a significant part of the world's state.
>>
>> [3] As you certainly know, it takes time to unlearn, especially to stop
>> judging something bad while it is just different. (Think at C programmers
>> and their beloved code block {} braces. I for one have better usage for
>> brace ;-.)
>>
>> [4] As an anecdote, somewhat complementary, in the course of my
>> explorations about programming languages, I often stepped on lists of C
>> design bugs, at least a dozen of them. Typically endless lists that take a
>> quarter of an hour to read in one go, without comments. There is space to
>> works for a language lover :-). If not enough, usually such critics seems
>> to agree on more than half of the points (and the remaining ones may not
>> figure on some lists just because the critic not think at it or did not
>> study this point) (but their solutions may diverge...).
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/fab41107/attachment-0001.html>

From gaetan at xeberon.net  Thu Jan  2 07:22:17 2014
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 2 Jan 2014 16:22:17 +0100
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <52C4F9E2.1070702@aim.com>
References: <52C4EA82.1050706@aim.com> <52C4F397.3070104@gmail.com>
	<52C4F9E2.1070702@aim.com>
Message-ID: <CANK7tAFm0M=bndQB9gvGKA6rqH5rwQx7iRaSB34cn57EYTxe4w@mail.gmail.com>

I used cmake for years and was quite happy with it, so a support of cmake
is welcomed. I recommend have it "officially" integrated into rust, along
with some other popular toolsets (scon, bare makefiles, visual studio,...).
Even if VS can derive from cmake. This is a strategic added value to have
it provided by the language.

I also would like to add I find this complementary to rust-pkg. For simple
project, this latter might do the job, but for very complex projects, a
full featured build system might be used, so let's have it seamlessly
integrated into rust.

-----
Gaetan



2014/1/2 SiegeLord <slabode at aim.com>

> On 01/02/2014 12:05 AM, Gy?rgy Andrasek wrote:
>
>> The proper way to support a language in CMake is outlined in
>> `Modules/CMakeAddNewLanguage.txt`:
>>
>
> I was guided away from that method by this email: http://www.cmake.org/
> pipermail/cmake/2011-March/043444.html . My approach is amenable to
> generating files for alternative build systems, like ninja. If you are
> aware that that email is incorrect, I'm glad to be corrected. Independently
> of that email, I have looked into doing it that way, but I found that it
> just did not mesh with the Rust compilation model, and I saw no clear way
> to using the information given by 'rustc --dep-info' to inform the build
> system. Additionally, my macros allow an easy way of doing documentation
> generation, which that method doesn't clearly allow.
>
> I'll be glad to be corrected on all those points though.
>
> -SL
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/214173a7/attachment.html>

From bytemr at gmail.com  Thu Jan  2 12:42:59 2014
From: bytemr at gmail.com (Joshua Rodgers)
Date: Thu, 2 Jan 2014 13:42:59 -0700
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <CANK7tAFm0M=bndQB9gvGKA6rqH5rwQx7iRaSB34cn57EYTxe4w@mail.gmail.com>
References: <52C4EA82.1050706@aim.com> <52C4F397.3070104@gmail.com>
	<52C4F9E2.1070702@aim.com>
	<CANK7tAFm0M=bndQB9gvGKA6rqH5rwQx7iRaSB34cn57EYTxe4w@mail.gmail.com>
Message-ID: <CANYWgQA23t7Hk+yvO0UnOYKwhT9e7BhvP2PEQiNMwAnvgWmZ7g@mail.gmail.com>

As an active user of CMake for several C++ projects that I maintain I would
be fully on board with first class CMake support by rust. I know a lot of
people want rustpkg to be the primary tool, but I feel like it is better
fit for small projects and libraries. Rustpkg is definitely useful for
smaller projects and for libraries. What I'd like to see is something for
managing project dependencies that can be used with any build system like
CMake or rustpkg.


On Thu, Jan 2, 2014 at 8:22 AM, Gaetan <gaetan at xeberon.net> wrote:

> I used cmake for years and was quite happy with it, so a support of cmake
> is welcomed. I recommend have it "officially" integrated into rust, along
> with some other popular toolsets (scon, bare makefiles, visual studio,...).
> Even if VS can derive from cmake. This is a strategic added value to have
> it provided by the language.
>
> I also would like to add I find this complementary to rust-pkg. For simple
> project, this latter might do the job, but for very complex projects, a
> full featured build system might be used, so let's have it seamlessly
> integrated into rust.
>
> -----
> Gaetan
>
>
>
> 2014/1/2 SiegeLord <slabode at aim.com>
>
>> On 01/02/2014 12:05 AM, Gy?rgy Andrasek wrote:
>>
>>> The proper way to support a language in CMake is outlined in
>>> `Modules/CMakeAddNewLanguage.txt`:
>>>
>>
>> I was guided away from that method by this email: http://www.cmake.org/
>> pipermail/cmake/2011-March/043444.html . My approach is amenable to
>> generating files for alternative build systems, like ninja. If you are
>> aware that that email is incorrect, I'm glad to be corrected. Independently
>> of that email, I have looked into doing it that way, but I found that it
>> just did not mesh with the Rust compilation model, and I saw no clear way
>> to using the information given by 'rustc --dep-info' to inform the build
>> system. Additionally, my macros allow an easy way of doing documentation
>> generation, which that method doesn't clearly allow.
>>
>> I'll be glad to be corrected on all those points though.
>>
>> -SL
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/c7bf5873/attachment.html>

From philippe.delrieu at free.fr  Thu Jan  2 13:40:04 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 02 Jan 2014 22:40:04 +0100
Subject: [rust-dev] error: can't find crate for `std`
Message-ID: <52C5DCB4.50000@free.fr>

I update with the master and now I have this error with a code that was 
compiling before.
... rs:1:1: 1:1 error: can't find crate for `std`

The error is at the first line which ever was the first line. Not all 
crate have the problem.

Philippe Delrieu



From vadimcn at gmail.com  Thu Jan  2 14:49:53 2014
From: vadimcn at gmail.com (Vadim)
Date: Thu, 2 Jan 2014 14:49:53 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <52C5049A.9080705@mozilla.com>
References: <52C4A989.5010201@minimum.se>
	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>
	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
	<52C5049A.9080705@mozilla.com>
Message-ID: <CADecdi+mvO9hy2BGx5RxhZd1_i_=qL5Np8q4Xn7wZJvv23nysg@mail.gmail.com>

I'd say it should be i(mut x, ...), though in this case inferring borrow is
not possible because of the lambda.   But if this were a standalone
function, e.g. the f() above, one could write "i(mut x, f);"

Regarding mutation-polymorphic generics, yes, it may not be possible to
mut-annotate them.  I would just let it slide for "pass-through" types like
T, but require annotations in non-generic code.
Not the best solution, but it just bothers me that we worry about the
"mutability hazard" at the top level of the call chain, but then completely
forget about it inside the callee.

Vadim




On Wed, Jan 1, 2014 at 10:18 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/1/14 10:06 PM, Vadim wrote:
>
>> Well, since requiring '&' at the original borrow site doesn't really
>> prevent the "unexpected mutability" problem, why not drop it and
>> eliminate a bunch of noise from Rust sources?
>>
>
> But it does eliminate mutation of lvalues.
>
>  And, again, if
>> "unexpected mutability" is what concerns people, "mut" annotation is the
>> better way to fix that, IMHO.
>>
>
> I don't know if it's a coherent proposal. Consider these four function
> signatures, each of which might mutate their arguments:
>
>     fn f(x: &mut int) { ... }
>
>     fn g(x: (&mut int, &mut int)) { ... }
>
>     struct S<'a> {
>         a: &'a mut int,
>         b: &'a mut uint,
>     }
>     fn h(x: S) { ... }
>
>     fn i<T>(x: T, f: |T|) { f(x) }
>
> How might `i` mutate its argument? Consider function `j`:
>
>     fn j() {
>         let mut x = 3;
>         i(&mut x, |ptr| *ptr = 5);
>     }
>
> So `i` mutated its argument. So how should you be forced to notate that?
> Should you have to write:
>
>     fn i<T>(x: T, f: |T|) { f(mut x) }
>
>     ... i(&mut x, |ptr| *ptr = 5);
>
> Or:
>
>     fn i<T>(x: T, f: |T|) { f(x) }
>
>     ... i(mut &mut x, |ptr| *ptr = 5);
>
> Or:
>
>     fn i<T>(x: T, f: |T|) { f(mut x) }
>
>     ... i(mut &mut x, |ptr| *ptr = 5);
>
> And that's just a simple example: start throwing in existential types like
> traits and it becomes clear that you really can't tell from the program
> where mutation could possibly happen, because the types are hiding
> mutability from you. And that's fine--existential types and generics
> deliberately permit that abstraction. But it does mean, I think, that we
> can't meaningfully talk about a sound and complete "mut" annotation at call
> sites.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/9e193259/attachment.html>

From pcwalton at mozilla.com  Thu Jan  2 14:51:24 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 02 Jan 2014 14:51:24 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <CADecdi+mvO9hy2BGx5RxhZd1_i_=qL5Np8q4Xn7wZJvv23nysg@mail.gmail.com>
References: <52C4A989.5010201@minimum.se>	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>	<52C5049A.9080705@mozilla.com>
	<CADecdi+mvO9hy2BGx5RxhZd1_i_=qL5Np8q4Xn7wZJvv23nysg@mail.gmail.com>
Message-ID: <52C5ED6C.6090303@mozilla.com>

On 1/2/14 2:49 PM, Vadim wrote:
> I'd say it should be i(mut x, ...), though in this case inferring borrow
> is not possible because of the lambda.   But if this were a standalone
> function, e.g. the f() above, one could write "i(mut x, f);"
>
> Regarding mutation-polymorphic generics, yes, it may not be possible to
> mut-annotate them.  I would just let it slide for "pass-through" types
> like T, but require annotations in non-generic code.
> Not the best solution, but it just bothers me that we worry about the
> "mutability hazard" at the top level of the call chain, but then
> completely forget about it inside the callee.

I'd rather do something principled and easy to understand than to have 
ad-hoc rules that a user has to memorize. What current Rust does is easy 
to understand IMO: it's the same as C.

Patrick


From banderson at mozilla.com  Thu Jan  2 15:04:22 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 02 Jan 2014 15:04:22 -0800
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <52C1E17F.2010809@mozilla.com>
References: <52C1E17F.2010809@mozilla.com>
Message-ID: <52C5F076.9000206@mozilla.com>

On 12/30/2013 01:11 PM, Patrick Walton wrote:
> I've been thinking that to future-proof unboxed closures in the future 
> we should maybe limit `|x| x+1` lambda syntax to either (a) require 
> `&` in front or (b) in function position.
>
> So today you would write:
>
>     let f = |x| x+1;
>
> But tomorrow you would write:
>
>     let f = &|x| x+1;
>
> But it would always work here:
>
>     v.map(|&x| x+1);
>
> The reason is simply that we'd like `|x| x+1` to become an unboxed 
> closure in the future and it's easier in the language semantics to 
> future-proof for it this way: we simply special-case the function 
> argument position.

Why special case it in argument position instead of just requiring & 
everywhere? Also, why couldn't you pass the closure by value to another 
function?

>
> Alternatively we can do it with assignability: say that `|x| x+1` is 
> an anonymous type (an error today) that is assignable to the type 
> `|int|->int`. That might be cleaner than special-casing the function 
> argument position.
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From carter.schonwald at gmail.com  Thu Jan  2 15:44:40 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 2 Jan 2014 18:44:40 -0500
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <CANYWgQA23t7Hk+yvO0UnOYKwhT9e7BhvP2PEQiNMwAnvgWmZ7g@mail.gmail.com>
References: <52C4EA82.1050706@aim.com> <52C4F397.3070104@gmail.com>
	<52C4F9E2.1070702@aim.com>
	<CANK7tAFm0M=bndQB9gvGKA6rqH5rwQx7iRaSB34cn57EYTxe4w@mail.gmail.com>
	<CANYWgQA23t7Hk+yvO0UnOYKwhT9e7BhvP2PEQiNMwAnvgWmZ7g@mail.gmail.com>
Message-ID: <CAHYVw0yCe9nezFqhs2gdXaGcpi3bSBpdT-OA5BBtm0EAwh02bg@mail.gmail.com>

question: is there any reason why cmake integration / support couldn't be
mediated via some improvements to rustpkg?

I had a first look at the current rustpkg api yesterday, and i ran away
screaming about the the many angled stringy typed ones that inhabit the
gaps in configuration space.

I emphatically agree that there should be some flexiblity in build tooling
support, and any dogmatic approach "all in rust" or "use X" will fail for
some use case. Is there any reason why that couldn't be via making it easy
to use an external build system via some rustpkg api improvement?
(seriously!)




On Thu, Jan 2, 2014 at 3:42 PM, Joshua Rodgers <bytemr at gmail.com> wrote:

> As an active user of CMake for several C++ projects that I maintain I
> would be fully on board with first class CMake support by rust. I know a
> lot of people want rustpkg to be the primary tool, but I feel like it is
> better fit for small projects and libraries. Rustpkg is definitely useful
> for smaller projects and for libraries. What I'd like to see is something
> for managing project dependencies that can be used with any build system
> like CMake or rustpkg.
>
>
> On Thu, Jan 2, 2014 at 8:22 AM, Gaetan <gaetan at xeberon.net> wrote:
>
>> I used cmake for years and was quite happy with it, so a support of cmake
>> is welcomed. I recommend have it "officially" integrated into rust, along
>> with some other popular toolsets (scon, bare makefiles, visual studio,...).
>> Even if VS can derive from cmake. This is a strategic added value to have
>> it provided by the language.
>>
>> I also would like to add I find this complementary to rust-pkg. For
>> simple project, this latter might do the job, but for very complex
>> projects, a full featured build system might be used, so let's have it
>> seamlessly integrated into rust.
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2014/1/2 SiegeLord <slabode at aim.com>
>>
>>> On 01/02/2014 12:05 AM, Gy?rgy Andrasek wrote:
>>>
>>>> The proper way to support a language in CMake is outlined in
>>>> `Modules/CMakeAddNewLanguage.txt`:
>>>>
>>>
>>> I was guided away from that method by this email: http://www.cmake.org/
>>> pipermail/cmake/2011-March/043444.html . My approach is amenable to
>>> generating files for alternative build systems, like ninja. If you are
>>> aware that that email is incorrect, I'm glad to be corrected. Independently
>>> of that email, I have looked into doing it that way, but I found that it
>>> just did not mesh with the Rust compilation model, and I saw no clear way
>>> to using the information given by 'rustc --dep-info' to inform the build
>>> system. Additionally, my macros allow an easy way of doing documentation
>>> generation, which that method doesn't clearly allow.
>>>
>>> I'll be glad to be corrected on all those points though.
>>>
>>> -SL
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140102/93660679/attachment-0001.html>

From philippe.delrieu at free.fr  Fri Jan  3 02:07:54 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 03 Jan 2014 11:07:54 +0100
Subject: [rust-dev] error: can't find crate for `std`
In-Reply-To: <52C5DCB4.50000@free.fr>
References: <52C5DCB4.50000@free.fr>
Message-ID: <52C68BFA.3070708@free.fr>

I found the problem. I had to rebuild all my external C binding that was 
compiled with the old version of rustc.
Before rustc were crashing. Now I have this error.

Philippe


Le 02/01/2014 22:40, Philippe Delrieu a ?crit :
> I update with the master and now I have this error with a code that 
> was compiling before.
> ... rs:1:1: 1:1 error: can't find crate for `std`
>
> The error is at the first line which ever was the first line. Not all 
> crate have the problem.
>
> Philippe Delrieu
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From stefan.plantikow at gmail.com  Fri Jan  3 02:25:48 2014
From: stefan.plantikow at gmail.com (Stefan Plantikow)
Date: Fri, 3 Jan 2014 11:25:48 +0100
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
	site?
In-Reply-To: <52C5049A.9080705@mozilla.com>
References: <52C4A989.5010201@minimum.se>	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
	<52C5049A.9080705@mozilla.com>
Message-ID: <EFD566F3-8A79-48DB-8327-123AA17BA988@googlemail.com>

Hi,

Am 02.01.2014 um 07:18 schrieb Patrick Walton <pcwalton at mozilla.com>:
> 
> 
> And that's just a simple example: start throwing in existential types like traits and it becomes clear that you really can't tell from the program where mutation could possibly happen, because the types are hiding mutability from you. And that's fine--existential types and generics deliberately permit that abstraction. But it does mean, I think, that we can't meaningfully talk about a sound and complete "mut" annotation at call sites.
> 

Maybe completely off here but why is mutability not tracked by the region system? Wouldn?t that help solve this issue? i.e. assignment to a mutable lvalue would only be allowed from an rvalue in a mutable region.   Haven?t thought about how that relates to freezing/thawing.


Cheers,


Stefan



From pcwalton at mozilla.com  Fri Jan  3 09:02:45 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 03 Jan 2014 09:02:45 -0800
Subject: [rust-dev] Why doesn't rust require "mut" param prefix at call
 site?
In-Reply-To: <EFD566F3-8A79-48DB-8327-123AA17BA988@googlemail.com>
References: <52C4A989.5010201@minimum.se>	<CADecdiJHG2B3hp9ooq22GFnKHi7HtUtsuxXtJEKZMxYMW_NpPA@mail.gmail.com>	<2e15dceb-ff7d-4350-8857-69d3c7b1b287@email.android.com>
	<CADecdiKvG3fEX5Y06aDrZ815Q=2p_7g5KLyNG9=eV19P9BHMNw@mail.gmail.com>
	<52C5049A.9080705@mozilla.com>
	<EFD566F3-8A79-48DB-8327-123AA17BA988@googlemail.com>
Message-ID: <52C6ED35.5020106@mozilla.com>

On 1/3/14 2:25 AM, Stefan Plantikow wrote:
> Maybe completely off here but why is mutability not tracked by the
> region system? Wouldn?t that help solve this issue? i.e. assignment
> to a mutable lvalue would only be allowed from an rvalue in a mutable
> region.   Haven?t thought about how that relates to
> freezing/thawing.

It kind of is, in that mutation generally requires a unique ownership 
path. See the comments in the borrow checker for more details.

Patrick


From palmercox at gmail.com  Fri Jan  3 20:33:04 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Fri, 3 Jan 2014 23:33:04 -0500
Subject: [rust-dev] RFC: Iterator naming convention
In-Reply-To: <CAPZendwdYOYyfTu-fQbKxbkX5gYUannU4iRm_W5-PY7+XYTj_A@mail.gmail.com>
References: <CAPZendye_zErL=gwJhjc1smoSQhjNifF9541ia-=EEd2b3apcA@mail.gmail.com>
	<CAH8Jz7g8Cf6zDp+izCOmMwPXbXwTBwv2mhWHHhi-x5yy8m8ZZQ@mail.gmail.com>
	<CABq6+acg-MQMcNvezFrwvxPbnpByYJ4RvdTWzdsVWuE44a4M5A@mail.gmail.com>
	<CAPZendwf8BAs-mVgyWXX_nWzsVitXd=b1e=KMH=G=4N7Wb8TjQ@mail.gmail.com>
	<CABq6+adwUuCDRFJpwYZptdZj9DWASK0O5oi9ZzG+5n0uZ=_8QA@mail.gmail.com>
	<CAPZendx_6niS2AKe4FVYcJLqGwxFzu752u=z3ZqDC5iJ+k3FtA@mail.gmail.com>
	<CABq6+aea6KCd6VMFmyL26d1EiXRCZxH7+Sf_v1vE+C8JbTRmig@mail.gmail.com>
	<CANbMr6E9cE3n+T6DMZ0EHaUG89esNiLCyzK3LEA8tVjXXs3rPA@mail.gmail.com>
	<CAPZendwWU2e9H8+oDOEvJGWN6=H1vLFhePkTWszwnWmEe5SCCA@mail.gmail.com>
	<CAPZendwdYOYyfTu-fQbKxbkX5gYUannU4iRm_W5-PY7+XYTj_A@mail.gmail.com>
Message-ID: <CAPZendx_Wgnupb0OWFxuq5jtq85ZkE1nxFLObXPzp9KfZdzR1g@mail.gmail.com>

I said I was giving up on this in my last message. However, I decided to
give it one more go. Details are at
https://github.com/mozilla/rust/pull/11001.

-Palmer Cox


On Fri, Dec 27, 2013 at 1:50 AM, Palmer Cox <palmercox at gmail.com> wrote:

> So,
>
> The rules that I tried to concoct don't really work. I don't know what to
> do with something like BitvIterator. Rename it to BitvElements? Anyway, I'm
> thinking of amending my pull request to just rename the *Iter structs to
> *Iterator and leave the rest alone.
>
> Thoughts?
>
> I pulled together what I believe is the full list of iterators in Rust as
> of f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9. If someone has a better
> suggestion of how to unify their naming, I'm happy to do it.
>
> +------------------------------------------+---------------------------+
> | File                                     | Name                      |
> +------------------------------------------+---------------------------+
> | src/libextra/bitv.rs                     | BitvIterator              |
> +------------------------------------------+---------------------------+
> | src/libextra/bitv.rs                     | BitvSetIterator           |
> +------------------------------------------+---------------------------+
> | src/libextra/dlist.rs                    | DListIterator             |
> +------------------------------------------+---------------------------+
> | src/libextra/dlist.rs                    | MutDListIterator          |
> +------------------------------------------+---------------------------+
> | src/libextra/dlist.rs                    | MoveIterator              |
> +------------------------------------------+---------------------------+
> | src/libextra/enum_set.rs                 | EnumSetIterator           |
> +------------------------------------------+---------------------------+
> | src/libextra/glob.rs                     | GlobIterator              |
> +------------------------------------------+---------------------------+
> | src/libextra/priority_queue.rs           | PriorityQueueIterator     |
> +------------------------------------------+---------------------------+
> | src/libextra/ringbuf.rs                  | RingBufIterator           |
> +------------------------------------------+---------------------------+
> | src/libextra/ringbuf.rs                  | RingBufMutIterator        |
> +------------------------------------------+---------------------------+
> | src/libextra/smallintmap.rs              | SmallIntMapIterator       |
> +------------------------------------------+---------------------------+
> | src/libextra/smallintmap.rs              | SmallIntMapMutIterator    |
> +------------------------------------------+---------------------------+
> | src/libextra/smallintmap.rs              | SmallIntMapRevIterator    |
> +------------------------------------------+---------------------------+
> | src/libextra/smallintmap.rs              | SmallIntMapMutRevIterator |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | TreeMapIterator           |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | TreeMapRevIterator        |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | TreeMapMoveIterator       |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | TreeSetIterator           |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | TreeSetRevIterator        |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | Difference                |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | SymDifference             |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | Intersection              |
> +------------------------------------------+---------------------------+
> | src/libextra/treemap.rs                  | Union                     |
> +------------------------------------------+---------------------------+
> | src/librustc/middle/trans/basic_block.rs | PredIterator              |
> +------------------------------------------+---------------------------+
> | src/librustc/middle/trans/value.rs       | UserIterator              |
> +------------------------------------------+---------------------------+
> | src/librustpkg/package_id.rs             | Prefixes                  |
> +------------------------------------------+---------------------------+
> | src/libstd/c_str.rs                      | CStringIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/comm/mod.rs                   | PortIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/comm/select.rs                | PacketIterator            |
> +------------------------------------------+---------------------------+
> | src/libstd/either.rs                     | Lefts                     |
> +------------------------------------------+---------------------------+
> | src/libstd/either.rs                     | Rights                    |
> +------------------------------------------+---------------------------+
> | src/libstd/fmt/parse.rs                  | Parser                    |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | HashMapIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | HashMapMutIterator        |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | HashMapMoveIterator       |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | HashSetIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | HashSetMoveIterator       |
> +------------------------------------------+---------------------------+
> | src/libstd/hashmap.rs                    | SetAlgebraIter            |
> +------------------------------------------+---------------------------+
> | src/libstd/io/extensions.rs              | ByteIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/io/fs.rs                      | WalkIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/io/mod.rs                     | LineIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/io/mod.rs                     | IncomingIterator          |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Invert                    |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | ByRef                     |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Cycle                     |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Chain                     |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Zip                       |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Map                       |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Filter                    |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | FilterMap                 |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Enumerate                 |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Peekable                  |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | SkipWhile                 |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | TakeWhile                 |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Skip                      |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Take                      |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Scan                      |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | FlatMap                   |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Fuse                      |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Inspect                   |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Unfold                    |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Counter                   |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Range                     |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | RangeInclusive            |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | RangeStep                 |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | RangeStepInclusive        |
> +------------------------------------------+---------------------------+
> | src/libstd/iter.rs                       | Repeat                    |
> +------------------------------------------+---------------------------+
> | src/libstd/option.rs                     | OptionIterator            |
> +------------------------------------------+---------------------------+
> | src/libstd/path/posix.rs                 | ComponentIter             |
> +------------------------------------------+---------------------------+
> | src/libstd/path/posix.rs                 | RevComponentIter          |
> +------------------------------------------+---------------------------+
> | src/libstd/path/posix.rs                 | StrComponentIter          |
> +------------------------------------------+---------------------------+
> | src/libstd/path/posix.rs                 | RevStrComponentIter       |
> +------------------------------------------+---------------------------+
> | src/libstd/path/windows.rs               | StrComponentIter          |
> +------------------------------------------+---------------------------+
> | src/libstd/path/windows.rs               | RevStrComponentIter       |
> +------------------------------------------+---------------------------+
> | src/libstd/path/windows.rs               | ComponentIter             |
> +------------------------------------------+---------------------------+
> | src/libstd/path/windows.rs               | RevComponentIter          |
> +------------------------------------------+---------------------------+
> | src/libstd/rt/task.rs                    | BlockedTaskIterator       |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharOffsetIterator        |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharSplitIterator         |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharSplitNIterator        |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | MatchesIndexIterator      |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | StrSplitIterator          |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | NormalizationIterator     |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharRevIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharOffsetRevIterator     |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | ByteIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | ByteRevIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | CharRSplitIterator        |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | WordIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/str.rs                        | AnyLineIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/trie.rs                       | TrieMapIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/trie.rs                       | TrieSetIterator           |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | SplitIterator             |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | RSplitIterator            |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | ElementSwaps              |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | Permutations              |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | WindowIter                |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | ChunkIter                 |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | VecIterator               |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | VecMutIterator            |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | MutSplitIterator          |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | MutChunkIter              |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | MoveIterator              |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | RevIterator               |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | MutRevIterator            |
> +------------------------------------------+---------------------------+
> | src/libstd/vec.rs                        | MoveRevIterator           |
> +------------------------------------------+---------------------------+
> | src/libsyntax/opt_vec.rs                 | OptVecIterator            |
> +------------------------------------------+---------------------------+
> | src/libsyntax/util/small_vector.rs       | SmallVectorMoveIterator   |
> +------------------------------------------+---------------------------+
>
> Thanks,
> -Palmer Cox
>
>
>
> On Sat, Dec 21, 2013 at 11:35 PM, Palmer Cox <palmercox at gmail.com> wrote:
>
>> Due to type inference, my assumption is that in many cases the only
>> people that see the actual type names are the developers creating them and
>> people reading the docs. I hadn't though about the Reader / Port cases, but
>> those do seem like pretty reasonable places where you might want to have an
>> object implement Iterator in addition to other traits.
>>
>> So, if the decision is no suffixes, what do we do with all of the
>> existing Iterators that have suffixes? Strip them? Maybe the rule of thumb
>> should look something like this:
>>
>> 1. If you are implementing a struct that only implements the Iterator
>> trait, make the name plural, but don't use the Iterator suffix. eg: Chunks
>> 2. If you are implementing a struct that implements traits in addition to
>> Iterator, there is no need to make it plural. eg: Port / Reader
>>
>> If that's the general rule of thumb, then SplitIterator becomes Splits
>> and MutChunkIter becomes MutChunks. I guess that means that
>> DoubleEndedIterator also becomes just DoubledEnded. That seems reasonable
>> to me, since it fits it better with the ExactSize trait also defined in the
>> iter module. That doesn't really directly solve my issue with Map from the
>> iter module being confusing. If its referenced as iter::Map, its
>> not confusing of course, but at least some of the current code doesn't do
>> that and there isn't any way to force future code to do so. Its probably
>> not a huge deal, though.
>>
>> Does that sound like the general opinion?
>>
>> -Palmer Cox
>>
>>
>>
>>
>>
>> On Sat, Dec 21, 2013 at 8:43 PM, Eric Reed <ecreed at cs.washington.edu>wrote:
>>
>>> I prefer the 'no suffix' option and generally agree with Alex.
>>> Iterators aren't special and their iterator behavior is already denoted
>>> by implementing the Iterator trait.
>>>
>>> Frankly, aside from documentation where it is clear that something is an
>>> iterator, I'm not sure when a user would even see concrete iterator types.
>>> I can't think of a reason why you'd ever want to restrict the type of a
>>> variable to a specific kind of iterator (i.e. Map or Union).
>>>
>>> Acceptor and Port could implement Iterator directly, but currently they
>>> create a struct containing only a mutable borrow of themselves to prevent
>>> anything else from using the socket/channel in the meantime.
>>> Reader could directly implement an Iterator that does one byte reads,
>>> but currently it does the same trick as Acceptor and Port.
>>> You only need a separate Iterator object if you actually require
>>> additional state or if you want to prevent others from changing the
>>> underlying source (mutable borrow of self).
>>>
>>>
>>>
>>> On Sat, Dec 21, 2013 at 4:35 PM, Kevin Cantu <me at kevincantu.org> wrote:
>>>
>>>> Rust's standard libs are still pretty thin on their trait hierarchies,
>>>> but I'm sure this will change.
>>>>
>>>> Kevin
>>>>
>>>> On Sat, Dec 21, 2013 at 1:30 PM, Palmer Cox <palmercox at gmail.com>
>>>> wrote:
>>>> > Are there examples of structs that implement Iterator that also
>>>> implement
>>>> > other non-Iterator related traits? Although its possible to do that,
>>>> I can't
>>>> > think of a use case for it off the top of my head. An Iterator
>>>> basically
>>>> > represents the state of an ongoing computation and once that
>>>> computation is
>>>> > completed, the object is mostly uselss. It seems like it would be
>>>> awkward to
>>>> > implement other traits for such an object. Maybe I'm not thinking of
>>>> > something, however.
>>>> >
>>>> > -Palmer Cox
>>>> >
>>>> >
>>>> >
>>>> > On Sat, Dec 21, 2013 at 4:24 PM, Kevin Cantu <me at kevincantu.org>
>>>> wrote:
>>>> >>
>>>> >> Iterators are just structs which implement the "Iterator" or a
>>>> related
>>>> >> trait, right?
>>>> >>
>>>> >> These structs which do can also implement lots of other traits, too:
>>>> >> no reason to make -Iter special.
>>>> >>
>>>> >>
>>>> >> Kevin
>>>> >>
>>>> >>
>>>> >>
>>>> >> On Sat, Dec 21, 2013 at 12:50 PM, Palmer Cox <palmercox at gmail.com>
>>>> wrote:
>>>> >> > I'm not a big fan of Hungarian notation either. I'm not sure that
>>>> having
>>>> >> > a
>>>> >> > naming convention for Iterators is Hungarian notation, however. For
>>>> >> > example,
>>>> >> > if you are doing Windows programming, you'll see stuff like:
>>>> >> >
>>>> >> > DWORD dwFoo = 0;
>>>> >> >
>>>> >> > In this case, the "dw" prefix on the variable indicates that we
>>>> have a
>>>> >> > DWORD
>>>> >> > variable. However, the Iterator suffix that I'm proposing here is a
>>>> >> > suffix
>>>> >> > on the type names, not the actual variable names. So, if you are
>>>> writing
>>>> >> > Rust code, you'd write something like this:
>>>> >> >
>>>> >> > let chunks = some_vector.chunks(50);
>>>> >> >
>>>> >> > So, the actual variable name doesn't have the Hungarian notation
>>>> and the
>>>> >> > types aren't even generally visible since the compiler infers much
>>>> of
>>>> >> > that.
>>>> >> > However, someone reading through the documentation and/or code
>>>> will see
>>>> >> > a
>>>> >> > struct named ChunkIterator and instance know how the struct
>>>> behaves - as
>>>> >> > an
>>>> >> > Iterator. So, I think the suffix serves less to describe the
>>>> datatype
>>>> >> > and
>>>> >> > more to describe class of behavior that the struct implements.
>>>> >> >
>>>> >> > Anyway, as I said, I prefer #1. But, I also have done lots of Java
>>>> >> > programming so I'm probably much more used to verbosity than
>>>> others. I'm
>>>> >> > not
>>>> >> > horribly against some sort of other naming convention, either, of
>>>> >> > course,
>>>> >> > but I would like to see some consistency.
>>>> >> >
>>>> >> > My main motivation for opening the request was because I created
>>>> >> > MutChunkIter and then realized that it was named differently than
>>>> >> > majority
>>>> >> > of other Iterators. I don't want to be responsible for someone
>>>> reading
>>>> >> > through the docs and seeing something thats inconsistent for no
>>>> good
>>>> >> > reason!
>>>> >> > Also, I was reading through some code and happened upon a "Map"
>>>> and was
>>>> >> > exceptionally confused about it, until I realized it was iter::Map
>>>> as
>>>> >> > opposed to container::Map. I figured I probably wasn't the only
>>>> person
>>>> >> > that
>>>> >> > was going to be confused by something like this.
>>>> >> >
>>>> >> > -Palmer Cox
>>>> >> >
>>>> >> >
>>>> >> >
>>>> >> >
>>>> >> >
>>>> >> > On Sat, Dec 21, 2013 at 3:14 PM, Kevin Cantu <me at kevincantu.org>
>>>> wrote:
>>>> >> >>
>>>> >> >> IMHO Hungarian notation is for things the type system and tooling
>>>> >> >> cannot deal with.  I'm not sure this is one of them...
>>>> >> >>
>>>> >> >>
>>>> >> >> Kevin
>>>> >> >
>>>> >> >
>>>> >
>>>> >
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140103/5c297ac0/attachment-0001.html>

From flaper87 at gmail.com  Sat Jan  4 06:01:28 2014
From: flaper87 at gmail.com (Flaper87)
Date: Sat, 4 Jan 2014 15:01:28 +0100
Subject: [rust-dev] Configuration files library for Rust
Message-ID: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>

Hi Guys,

I was looking around and I couldn't find a config file parser library for
Rust. Getopt support seems to be pretty complete and stable, which would
make the development of such library easier.

Since I've some experience on this area, I thought about doing some work on
it for Rust.

My current plan is to do something along the lines of oslo.config[0] -
which I've been contributing to - and take advantage of the existing getopt
module, just as we do in oslo.config.

The config file format parsed by oslo.config follows the INI[1] files
format but with some changes to support list options and other types. One
of the advantages of this library is that the config options registration
is explicit and simple.

However, before starting to work on this, I'd like to know what folks on
this list think about the library, if there's been some work on this area
that I'm not aware of, what the preferences are, etc.

Cheers,
FF

[0] https://github.com/openstack/oslo.config
[1] http://en.wikipedia.org/wiki/INI_file

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/1786f39c/attachment.html>

From mneumann at ntecs.de  Sat Jan  4 08:14:28 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sat, 04 Jan 2014 17:14:28 +0100
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
Message-ID: <52C83364.7020500@ntecs.de>

Hi all,

rust-redis: A Redis client library written in pure Rust. Thanks to the 
new rust runtime
it is pretty fast, despite being only 200 lines of code.

rust-msgpack: Fully featured and high performance msgpack implementation 
for Rust.

Both work with rust 0.9-pre.

Regards,

   Michael

From mneumann at ntecs.de  Sat Jan  4 08:16:13 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sat, 04 Jan 2014 17:16:13 +0100
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
In-Reply-To: <52C83364.7020500@ntecs.de>
References: <52C83364.7020500@ntecs.de>
Message-ID: <52C833CD.5030303@ntecs.de>


Am 04.01.2014 17:14, schrieb Michael Neumann:
> Hi all,
>
> rust-redis: A Redis client library written in pure Rust. Thanks to the 
> new rust runtime
> it is pretty fast, despite being only 200 lines of code.
>
> rust-msgpack: Fully featured and high performance msgpack 
> implementation for Rust.
>
> Both work with rust 0.9-pre.

Too stupid/sleepy that I forgot the links:

http://github.com/mneumann/rust-redis
http://github.com/mneumann/rust-msgpack

Regards,

   Michael

From corey at octayn.net  Sat Jan  4 09:38:24 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 4 Jan 2014 12:38:24 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
Message-ID: <CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>

oslo.config looks decent. On some projects I've worked on, we started
out using INI files but found them severely lacking once we wanted to
extend the options. We ended up using libconfig[0], which I think is
an excellent library. In multibuilder[1], we use extra::serialize to
load a config directly into the struct we'll be using. It's super
convenient, but a bit unfortunate in that it's impossible to make a
field truly optional (Option<T> requires the field to be null, iirc).

[0] http://www.hyperrealm.com/libconfig/
[1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68

On Sat, Jan 4, 2014 at 9:01 AM, Flaper87 <flaper87 at gmail.com> wrote:
> Hi Guys,
>
> I was looking around and I couldn't find a config file parser library for
> Rust. Getopt support seems to be pretty complete and stable, which would
> make the development of such library easier.
>
> Since I've some experience on this area, I thought about doing some work on
> it for Rust.
>
> My current plan is to do something along the lines of oslo.config[0] - which
> I've been contributing to - and take advantage of the existing getopt
> module, just as we do in oslo.config.
>
> The config file format parsed by oslo.config follows the INI[1] files format
> but with some changes to support list options and other types. One of the
> advantages of this library is that the config options registration is
> explicit and simple.
>
> However, before starting to work on this, I'd like to know what folks on
> this list think about the library, if there's been some work on this area
> that I'm not aware of, what the preferences are, etc.
>
> Cheers,
> FF
>
> [0] https://github.com/openstack/oslo.config
> [1] http://en.wikipedia.org/wiki/INI_file
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From corey at octayn.net  Sat Jan  4 09:44:08 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 4 Jan 2014 12:44:08 -0500
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
In-Reply-To: <52C833CD.5030303@ntecs.de>
References: <52C83364.7020500@ntecs.de>
	<52C833CD.5030303@ntecs.de>
Message-ID: <CA++BO6RHRb627yEfFR8DFqPy_ZkKZh_sQSLEk+cEY8Cr=N1=8w@mail.gmail.com>

If you slap a #[no_uv]; on the benchmark, it will use libnative, which
is threads

On Sat, Jan 4, 2014 at 11:16 AM, Michael Neumann <mneumann at ntecs.de> wrote:
>
> Am 04.01.2014 17:14, schrieb Michael Neumann:
>
>> Hi all,
>>
>> rust-redis: A Redis client library written in pure Rust. Thanks to the new
>> rust runtime
>> it is pretty fast, despite being only 200 lines of code.
>>
>> rust-msgpack: Fully featured and high performance msgpack implementation
>> for Rust.
>>
>> Both work with rust 0.9-pre.
>
>
> Too stupid/sleepy that I forgot the links:
>
> http://github.com/mneumann/rust-redis
> http://github.com/mneumann/rust-msgpack
>
>
> Regards,
>
>   Michael
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From mneumann at ntecs.de  Sat Jan  4 10:00:27 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sat, 04 Jan 2014 19:00:27 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
Message-ID: <52C84C3B.2020304@ntecs.de>


Am 04.01.2014 18:38, schrieb Corey Richardson:
> oslo.config looks decent. On some projects I've worked on, we started
> out using INI files but found them severely lacking once we wanted to
> extend the options. We ended up using libconfig[0], which I think is
> an excellent library. In multibuilder[1], we use extra::serialize to
> load a config directly into the struct we'll be using. It's super
> convenient, but a bit unfortunate in that it's impossible to make a
> field truly optional (Option<T> requires the field to be null, iirc).
>
> [0] http://www.hyperrealm.com/libconfig/
> [1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68

There is also TOML [1], an extended version of the INI config file format,
which is used by a variety of languages.

[1]: https://github.com/mojombo/toml

Regards,

   Michael


From flaper87 at gmail.com  Sat Jan  4 10:00:18 2014
From: flaper87 at gmail.com (Flaper87)
Date: Sat, 4 Jan 2014 19:00:18 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
Message-ID: <CAMOT3C28PP40Cir3wyLGEohSPE07dM7jpwJ1zfD2USsafZOUdQ@mail.gmail.com>

2014/1/4 Corey Richardson <corey at octayn.net>

> oslo.config looks decent. On some projects I've worked on, we started
> out using INI files but found them severely lacking once we wanted to
> extend the options. We ended up using libconfig[0], which I think is
> an excellent library. In multibuilder[1], we use extra::serialize to
> load a config directly into the struct we'll be using. It's super
> convenient, but a bit unfortunate in that it's impossible to make a
> field truly optional (Option<T> requires the field to be null, iirc).
>
> [0] http://www.hyperrealm.com/libconfig/
> [1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68


I'm also considering to have support for several parsers. It should be
pretty simple / straightforward to do so.

We could have a default parser based on INI files and then allow people to
specify a different parser in case INI files are not what they want to use.
I'll dive into libconfig and pick things from there as well.

Also, I agree INI files could be a bit limited, which is why we ended up
having our own INI parser in oslo.config.

Thoughts?
FF


>
>
> On Sat, Jan 4, 2014 at 9:01 AM, Flaper87 <flaper87 at gmail.com> wrote:
> > Hi Guys,
> >
> > I was looking around and I couldn't find a config file parser library for
> > Rust. Getopt support seems to be pretty complete and stable, which would
> > make the development of such library easier.
> >
> > Since I've some experience on this area, I thought about doing some work
> on
> > it for Rust.
> >
> > My current plan is to do something along the lines of oslo.config[0] -
> which
> > I've been contributing to - and take advantage of the existing getopt
> > module, just as we do in oslo.config.
> >
> > The config file format parsed by oslo.config follows the INI[1] files
> format
> > but with some changes to support list options and other types. One of the
> > advantages of this library is that the config options registration is
> > explicit and simple.
> >
> > However, before starting to work on this, I'd like to know what folks on
> > this list think about the library, if there's been some work on this area
> > that I'm not aware of, what the preferences are, etc.
> >
> > Cheers,
> > FF
> >
> > [0] https://github.com/openstack/oslo.config
> > [1] http://en.wikipedia.org/wiki/INI_file
> >
> > --
> > Flavio (@flaper87) Percoco
> > http://www.flaper87.com
> > http://github.com/FlaPer87
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>



-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/fa745680/attachment-0001.html>

From pcwalton at mozilla.com  Sat Jan  4 10:11:25 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 04 Jan 2014 10:11:25 -0800
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
In-Reply-To: <52C833CD.5030303@ntecs.de>
References: <52C83364.7020500@ntecs.de> <52C833CD.5030303@ntecs.de>
Message-ID: <52C84ECD.1090709@mozilla.com>

On 1/4/14 8:16 AM, Michael Neumann wrote:
>> rust-msgpack: Fully featured and high performance msgpack
>> implementation for Rust.
>>
>> Both work with rust 0.9-pre.
>
> Too stupid/sleepy that I forgot the links:
>
> http://github.com/mneumann/rust-redis
> http://github.com/mneumann/rust-msgpack

Sweet! msgpack might be a good IPC format for Servo.

Patrick


From gaetan at xeberon.net  Sat Jan  4 10:17:54 2014
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 4 Jan 2014 19:17:54 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAMOT3C28PP40Cir3wyLGEohSPE07dM7jpwJ1zfD2USsafZOUdQ@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<CAMOT3C28PP40Cir3wyLGEohSPE07dM7jpwJ1zfD2USsafZOUdQ@mail.gmail.com>
Message-ID: <CANK7tAGbpKmNvKv0cNh8aYFjQQLRx1=kMzjXO4nXF1Jt43L1rw@mail.gmail.com>

I m also interessed in writing a YAML loader/dumper for rust but i m still
learning the language...
Le 4 janv. 2014 19:00, "Flaper87" <flaper87 at gmail.com> a ?crit :

>
>
>
> 2014/1/4 Corey Richardson <corey at octayn.net>
>
>> oslo.config looks decent. On some projects I've worked on, we started
>> out using INI files but found them severely lacking once we wanted to
>> extend the options. We ended up using libconfig[0], which I think is
>> an excellent library. In multibuilder[1], we use extra::serialize to
>> load a config directly into the struct we'll be using. It's super
>> convenient, but a bit unfortunate in that it's impossible to make a
>> field truly optional (Option<T> requires the field to be null, iirc).
>>
>> [0] http://www.hyperrealm.com/libconfig/
>> [1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68
>
>
> I'm also considering to have support for several parsers. It should be
> pretty simple / straightforward to do so.
>
> We could have a default parser based on INI files and then allow people to
> specify a different parser in case INI files are not what they want to use.
> I'll dive into libconfig and pick things from there as well.
>
> Also, I agree INI files could be a bit limited, which is why we ended up
> having our own INI parser in oslo.config.
>
> Thoughts?
> FF
>
>
>>
>>
>> On Sat, Jan 4, 2014 at 9:01 AM, Flaper87 <flaper87 at gmail.com> wrote:
>> > Hi Guys,
>> >
>> > I was looking around and I couldn't find a config file parser library
>> for
>> > Rust. Getopt support seems to be pretty complete and stable, which would
>> > make the development of such library easier.
>> >
>> > Since I've some experience on this area, I thought about doing some
>> work on
>> > it for Rust.
>> >
>> > My current plan is to do something along the lines of oslo.config[0] -
>> which
>> > I've been contributing to - and take advantage of the existing getopt
>> > module, just as we do in oslo.config.
>> >
>> > The config file format parsed by oslo.config follows the INI[1] files
>> format
>> > but with some changes to support list options and other types. One of
>> the
>> > advantages of this library is that the config options registration is
>> > explicit and simple.
>> >
>> > However, before starting to work on this, I'd like to know what folks on
>> > this list think about the library, if there's been some work on this
>> area
>> > that I'm not aware of, what the preferences are, etc.
>> >
>> > Cheers,
>> > FF
>> >
>> > [0] https://github.com/openstack/oslo.config
>> > [1] http://en.wikipedia.org/wiki/INI_file
>> >
>> > --
>> > Flavio (@flaper87) Percoco
>> > http://www.flaper87.com
>> > http://github.com/FlaPer87
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>
>
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/8246d796/attachment.html>

From pnathan at vandals.uidaho.edu  Sat Jan  4 10:28:05 2014
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Sat, 4 Jan 2014 10:28:05 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <52C84C3B.2020304@ntecs.de>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de>
Message-ID: <52C852B5.1020803@vandals.uidaho.edu>

On 1/4/14 10:00 AM, Michael Neumann wrote:
> 
> Am 04.01.2014 18:38, schrieb Corey Richardson:
>> oslo.config looks decent. On some projects I've worked on, we started
>> out using INI files but found them severely lacking once we wanted to
>> extend the options. We ended up using libconfig[0], which I think is
>> an excellent library. In multibuilder[1], we use extra::serialize to
>> load a config directly into the struct we'll be using. It's super
>> convenient, but a bit unfortunate in that it's impossible to make a
>> field truly optional (Option<T> requires the field to be null, iirc).
>>
>> [0] http://www.hyperrealm.com/libconfig/
>> [1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68
> 
> There is also TOML [1], an extended version of the INI config file format,
> which is used by a variety of languages.
> 
> [1]: https://github.com/mojombo/toml
> 
> Regards,
> 
>   Michael
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> .
> 

I've used YAML, JSON, and INI extensively for configuration, and I
confess that each have their problems.

I agree that TOML is an excellent idea (I wrote the Common Lisp TOML
parser).  I just don't know off-hand how widely its been picked up in
the past year.

-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/99b013ad/attachment.sig>

From gaetan at xeberon.net  Sat Jan  4 12:26:23 2014
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 4 Jan 2014 21:26:23 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <52C852B5.1020803@vandals.uidaho.edu>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
Message-ID: <CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>

I m interessed on having your feedback on json and yaml vs toml for
instance.
Le 4 janv. 2014 19:28, "Paul Nathan" <pnathan at vandals.uidaho.edu> a ?crit :

> On 1/4/14 10:00 AM, Michael Neumann wrote:
> >
> > Am 04.01.2014 18:38, schrieb Corey Richardson:
> >> oslo.config looks decent. On some projects I've worked on, we started
> >> out using INI files but found them severely lacking once we wanted to
> >> extend the options. We ended up using libconfig[0], which I think is
> >> an excellent library. In multibuilder[1], we use extra::serialize to
> >> load a config directly into the struct we'll be using. It's super
> >> convenient, but a bit unfortunate in that it's impossible to make a
> >> field truly optional (Option<T> requires the field to be null, iirc).
> >>
> >> [0] http://www.hyperrealm.com/libconfig/
> >> [1] https://github.com/huonw/multibuilder/blob/master/main.rs#L68
> >
> > There is also TOML [1], an extended version of the INI config file
> format,
> > which is used by a variety of languages.
> >
> > [1]: https://github.com/mojombo/toml
> >
> > Regards,
> >
> >   Michael
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> > .
> >
>
> I've used YAML, JSON, and INI extensively for configuration, and I
> confess that each have their problems.
>
> I agree that TOML is an excellent idea (I wrote the Common Lisp TOML
> parser).  I just don't know off-hand how widely its been picked up in
> the past year.
>
> --
> Regards,
> Paul
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/8d25215d/attachment.html>

From bascule at gmail.com  Sat Jan  4 12:30:34 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 4 Jan 2014 12:30:34 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
Message-ID: <CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>

On Sat, Jan 4, 2014 at 12:26 PM, Gaetan <gaetan at xeberon.net> wrote:

> I m interessed on having your feedback on json and yaml vs toml for
> instance.
>
JSON is ugly and token-ridden for configuration files. Having worked with
tools that use it for this purpose, I find the configuration hard to read.
Then there's the issue of comments, which are particularly important for
configuration files. Some things have adopted JS-style comments for this
purpose, but that's technically not standard JSON.

YAML's problem is indentation errors can turn into configuration errors,
and they're incredibly tricky to spot. I've run into cases where we didn't
spot problems until we deployed to production because the "production"
section of a configuration file was misindented.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/c5ba8245/attachment.html>

From mneumann at ntecs.de  Sat Jan  4 12:32:54 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sat, 04 Jan 2014 21:32:54 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>	<52C84C3B.2020304@ntecs.de>
	<52C852B5.1020803@vandals.uidaho.edu>	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
Message-ID: <52C86FF6.8030106@ntecs.de>


Am 04.01.2014 21:30, schrieb Tony Arcieri:
> On Sat, Jan 4, 2014 at 12:26 PM, Gaetan <gaetan at xeberon.net 
> <mailto:gaetan at xeberon.net>> wrote:
>
>     I m interessed on having your feedback on json and yaml vs toml
>     for instance.
>
> JSON is ugly and token-ridden for configuration files. Having worked 
> with tools that use it for this purpose, I find the configuration hard 
> to read. Then there's the issue of comments, which are particularly 
> important for configuration files. Some things have adopted JS-style 
> comments for this purpose, but that's technically not standard JSON.
>
> YAML's problem is indentation errors can turn into configuration 
> errors, and they're incredibly tricky to spot. I've run into cases 
> where we didn't spot problems until we deployed to production because 
> the "production" section of a configuration file was misindented.

And, I think it's pretty hard to write a YAML parser. The spec is pretty 
extensive. Whereas a TOML or INI parser, you can hack within a few hours.

Regards,

   Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/f065104b/attachment.html>

From danielmicay at gmail.com  Sat Jan  4 12:35:11 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 4 Jan 2014 15:35:11 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
Message-ID: <CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>

On Sat, Jan 4, 2014 at 3:30 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
> YAML's problem is indentation errors can turn into configuration errors, and
> they're incredibly tricky to spot. I've run into cases where we didn't spot
> problems until we deployed to production because the "production" section of
> a configuration file was misindented.

I don't buy that. A text editor should be more than capable enough to
stop you from slipping in tabs. If there's a separate untested
configuration for production then you have a problem.

YAML is really complex though and I think the ability to extend it is overkill.

From bascule at gmail.com  Sat Jan  4 12:39:23 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 4 Jan 2014 12:39:23 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
Message-ID: <CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>

On Sat, Jan 4, 2014 at 12:35 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> I don't buy that. A text editor should be more than capable enough to
>  stop you from slipping in tabs. If there's a separate untested
> configuration for production then you have a problem.


This isn't just a single offhand incident. It's something I've seen a
pattern of happening dozens of times over the course of my career. It's
happened to me personally, and I've seen it happen to others.

Having separate configuration sections for different environments is a
rather common convention in the Rails world. Is it a bad idea? Offhand I
can't say: what would you replace it with?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/46e3e25f/attachment.html>

From christopher.meiklejohn at gmail.com  Sat Jan  4 12:41:50 2014
From: christopher.meiklejohn at gmail.com (Christopher Meiklejohn)
Date: Sat, 4 Jan 2014 15:41:50 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
Message-ID: <FAE29893-93B5-4F17-A0C7-2F61A7884632@gmail.com>

On Jan 4, 2014, at 3:39 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Sat, Jan 4, 2014 at 12:35 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> I don't buy that. A text editor should be more than capable enough to
> stop you from slipping in tabs. If there's a separate untested
> configuration for production then you have a problem.
> 
> This isn't just a single offhand incident. It's something I've seen a pattern of happening dozens of times over the course of my career. It's happened to me personally, and I've seen it happen to others.
> 
> Having separate configuration sections for different environments is a rather common convention in the Rails world. Is it a bad idea? Offhand I can't say: what would you replace it with? 

Why not something that looks like sysctl [1] syntax?

http://www5.us.freebsd.org/doc/handbook/configtuning-sysctl.html

- Chris

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/63f8bbfb/attachment-0001.html>

From pwalton at mozilla.com  Sat Jan  4 12:45:12 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 04 Jan 2014 12:45:12 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <52C86FF6.8030106@ntecs.de>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<52C86FF6.8030106@ntecs.de>
Message-ID: <4e1a6e6c-737f-43a1-aa34-d71b9914b148@email.android.com>

I would love to have a TOML parser. I've always had a bit of a fondness for the INI format, despite its limitations, and TOML looks like the best of both worlds (the expressivity of JSON and the simplicity and readability of INI).

Benchmarks of TOML parsing would be fun too :)

Patrick

Michael Neumann <mneumann at ntecs.de> wrote:
>
>Am 04.01.2014 21:30, schrieb Tony Arcieri:
>> On Sat, Jan 4, 2014 at 12:26 PM, Gaetan <gaetan at xeberon.net 
>> <mailto:gaetan at xeberon.net>> wrote:
>>
>>     I m interessed on having your feedback on json and yaml vs toml
>>     for instance.
>>
>> JSON is ugly and token-ridden for configuration files. Having worked 
>> with tools that use it for this purpose, I find the configuration
>hard 
>> to read. Then there's the issue of comments, which are particularly 
>> important for configuration files. Some things have adopted JS-style 
>> comments for this purpose, but that's technically not standard JSON.
>>
>> YAML's problem is indentation errors can turn into configuration 
>> errors, and they're incredibly tricky to spot. I've run into cases 
>> where we didn't spot problems until we deployed to production because
>
>> the "production" section of a configuration file was misindented.
>
>And, I think it's pretty hard to write a YAML parser. The spec is
>pretty 
>extensive. Whereas a TOML or INI parser, you can hack within a few
>hours.
>
>Regards,
>
>   Michael
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/dffa2509/attachment.html>

From chris at cmoz.me  Sat Jan  4 12:59:22 2014
From: chris at cmoz.me (Chris Molozian)
Date: Sat, 4 Jan 2014 20:59:22 +0000
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <FAE29893-93B5-4F17-A0C7-2F61A7884632@gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<FAE29893-93B5-4F17-A0C7-2F61A7884632@gmail.com>
Message-ID: <etPan.52c8762a.74b0dc51.55f4@christophersair>

I second the sysctl syntax it?s very easy to grep through configuration files in this format. The ?key? prefix contains the context for the information which is useful.

i.e. ?riak_kv.anti_entropy_leveldb_opts.write_buffer_size?

Riak, a distributed KV dynamo store has recently been moving to the sysctl format from the traditional Erlang `app.config` ?format".

Cheers.

--?
Chris Molozian
Software Engineer

On 4 January 2014 at 20:41:59, Christopher Meiklejohn (christopher.meiklejohn at gmail.com) wrote:

On Jan 4, 2014, at 3:39 PM, Tony Arcieri <bascule at gmail.com> wrote:

On Sat, Jan 4, 2014 at 12:35 PM, Daniel Micay <danielmicay at gmail.com> wrote:
I don't buy that. A text editor should be more than capable enough to
stop you from slipping in tabs. If there's a separate untested
configuration for production then you have a problem.

This isn't just a single offhand incident. It's something I've seen a pattern of happening dozens of times over the course of my career. It's happened to me personally, and I've seen it happen to others.

Having separate configuration sections for different environments is a rather common convention in the Rails world. Is it a bad idea? Offhand I can't say: what would you replace it with??

Why not something that looks like sysctl [1] syntax?

http://www5.us.freebsd.org/doc/handbook/configtuning-sysctl.html

- Chris

_______________________________________________  
Rust-dev mailing list  
Rust-dev at mozilla.org  
https://mail.mozilla.org/listinfo/rust-dev  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/98817e2d/attachment.html>

From masklinn at masklinn.net  Sat Jan  4 12:59:30 2014
From: masklinn at masklinn.net (Masklinn)
Date: Sat, 4 Jan 2014 21:59:30 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <4e1a6e6c-737f-43a1-aa34-d71b9914b148@email.android.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<52C86FF6.8030106@ntecs.de>
	<4e1a6e6c-737f-43a1-aa34-d71b9914b148@email.android.com>
Message-ID: <3AD65D18-E74A-43A8-95C8-098A07EA1E16@masklinn.net>

On 2014-01-04, at 21:45 , Patrick Walton <pwalton at mozilla.com> wrote:

> I would love to have a TOML parser. I've always had a bit of a fondness for the INI format, despite its limitations, and TOML looks like the best of both worlds (the expressivity of JSON and the simplicity and readability of INI).

Well IIRC "ini" is undefined and basically a wild west aside from having
bracket-enclosed section names. So for all intents and purposes TOML is
a strict and well-defined ini dialect (compared to most ini dialects
anyway). In fact I believe its original tagline was "TOML is like INI,
only better".

> Benchmarks of TOML parsing would be fun too :)
> 
> Patrick


From danielmicay at gmail.com  Sat Jan  4 13:25:43 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 4 Jan 2014 16:25:43 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
Message-ID: <CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>

On Sat, Jan 4, 2014 at 3:39 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Sat, Jan 4, 2014 at 12:35 PM, Daniel Micay
>
> This isn't just a single offhand incident. It's something I've seen a
> pattern of happening dozens of times over the course of my career. It's
> happened to me personally, and I've seen it happen to others.

I can believe that people are using poor tooling, as I can't
understand how a tab character would sneak in otherwise. It can be
easily prevented at both the text editor and version control layers.
Git can be asked to prevent commits with whitespace problems by
enabling the default pre-commit hook and setting either tabs or space
(and the width) in gitattributes.

> Having separate configuration sections for different environments is a
> rather common convention in the Rails world. Is it a bad idea? Offhand I
> can't say: what would you replace it with?

Testing what you plan on deploying, instead of something else.

From bascule at gmail.com  Sat Jan  4 13:35:00 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 4 Jan 2014 13:35:00 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
Message-ID: <CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>

On Sat, Jan 4, 2014 at 1:25 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> I can believe that people are using poor tooling, as I can't
>  understand how a tab character would sneak in otherwise. It can be
> easily prevented at both the text editor and version control layers.
> Git can be asked to prevent commits with whitespace problems by
> enabling the default pre-commit hook and setting either tabs or space
> (and the width) in gitattributes.
>

Believe it or not, not all problems of this nature can be caught by
automatic tools, and this is particularly problematic in YAML. Let's look
at a particular one, which is a *semantic* error in the structure of YAML
which I don't think any automated tools can catch, but please, correct me
if I'm wrong.

What if the programmer intended to write:

stuff:
  one:
    foo:
      - a
      - b
    bar:
      - c
      - d
  two:
    foo:
      - e
      - f
    bar:
      - g
      - h

But instead wrote:

stuff:
  one:
    foo:
      - a
      - b
    bar:
      - c
      - d
  two:
    foo:
      - e
      - f
  bar:
    - g
    - h

?

How exactly would an automated tool spot this error?



> Testing what you plan on deploying, instead of something else.
>

So if we're talking to a payment gateway, our automated tests should run
against the live payment gateway? Surely you see there are many cases where
this simply doesn't work.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/7f663ca1/attachment-0001.html>

From danielmicay at gmail.com  Sat Jan  4 13:44:13 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 4 Jan 2014 16:44:13 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
	<CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
Message-ID: <CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>

On Sat, Jan 4, 2014 at 4:35 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Sat, Jan 4, 2014 at 1:25 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>>
>> I can believe that people are using poor tooling, as I can't
>> understand how a tab character would sneak in otherwise. It can be
>> easily prevented at both the text editor and version control layers.
>> Git can be asked to prevent commits with whitespace problems by
>> enabling the default pre-commit hook and setting either tabs or space
>> (and the width) in gitattributes.
>
>
> Believe it or not, not all problems of this nature can be caught by
> automatic tools, and this is particularly problematic in YAML. Let's look at
> a particular one, which is a *semantic* error in the structure of YAML which
> I don't think any automated tools can catch, but please, correct me if I'm
> wrong.
>
> What if the programmer intended to write:
>
> stuff:
>   one:
>     foo:
>       - a
>       - b
>     bar:
>       - c
>       - d
>   two:
>     foo:
>       - e
>       - f
>     bar:
>       - g
>       - h
>
> But instead wrote:
>
> stuff:
>   one:
>     foo:
>       - a
>       - b
>     bar:
>       - c
>       - d
>   two:
>     foo:
>       - e
>       - f
>   bar:
>     - g
>     - h
>
> ?

Not much of a problem with 8-space indents. This is not really any
different than messing up brace nesting. If you go out of the way to
obfuscate the code with 2-space indents then it's a problem.

> So if we're talking to a payment gateway, our automated tests should run
> against the live payment gateway? Surely you see there are many cases where
> this simply doesn't work.

I don't really. Wouldn't you want to test that it works with some
dummy accounts after you've done testing against a mocked one?

From bascule at gmail.com  Sat Jan  4 13:47:57 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 4 Jan 2014 13:47:57 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
	<CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
	<CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>
Message-ID: <CAHOTMVLq7zrgETXrAcSPGkMKssU1Yh9LWPrF=mAiWUwPb8pQnw@mail.gmail.com>

On Sat, Jan 4, 2014 at 1:44 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> This is not really any different than messing up brace nesting.
>

Except brace nesting gives you more tokens from which someone reviewing
your configuration can spot the error. A strict superset, at that, if
you're indenting your code correctly anyway.

Anyway, that's my two cents. I am not a fan of whitespace sensitivity.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/3da6f8c7/attachment.html>

From pnathan at vandals.uidaho.edu  Sat Jan  4 13:52:52 2014
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Sat, 4 Jan 2014 13:52:52 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
Message-ID: <52C882B4.3050006@vandals.uidaho.edu>

On 1/4/14 12:30 PM, Tony Arcieri wrote:
> On Sat, Jan 4, 2014 at 12:26 PM, Gaetan <gaetan at xeberon.net
> <mailto:gaetan at xeberon.net>> wrote:
> 
>     I m interessed on having your feedback on json and yaml vs toml for
>     instance.
> 
> JSON is ugly and token-ridden for configuration files. Having worked
> with tools that use it for this purpose, I find the configuration hard
> to read. Then there's the issue of comments, which are particularly
> important for configuration files. Some things have adopted JS-style
> comments for this purpose, but that's technically not standard JSON.
> 

All of this is true. Further, JSON is very fiddly and sensitive to typos
(e.g., spare " and ,) , which is something that does not play well with
many users, who are not used to or comfortable with that level of syntax
rigor.

> YAML's problem is indentation errors can turn into configuration errors,
> and they're incredibly tricky to spot. I've run into cases where we
> didn't spot problems until we deployed to production because the
> "production" section of a configuration file was misindented.

This is also my experience: making or using a tool to do special-purpose
editing of plaintext files sits ill with me.


TOML is very like INI, but includes hierarchical capabilities, which is
one of the cardinal problems with INI.  TOML has a spec, unlike INI,
which is nice.

 TOML is also similar in concept to YAML, but has certain variances -
It is not whitespace-delimited (unlike YAML), which makes it simple to
parse and visually edit by hand.  YAML is reputed to be fairly insecure,
something which would be good to avoid even the possibility of out of
the gate[1].

TOML also specifies types out of the gate and covers certain gaps in
JSON capabilities in this regards (I don't remember YAML here one way or
another).


And a final word - IMO it's better to have a system where it's harder to
shoot yourself in the foot. TOML and INI are roughly at the same level
here. JSON and YAML are a little easier to make mistakes with IME.


[1] http://blogs.teamb.com/craigstuntz/2013/02/04/38738/
-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/5836f9c2/attachment.sig>

From danielmicay at gmail.com  Sat Jan  4 13:53:45 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 4 Jan 2014 16:53:45 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMVLq7zrgETXrAcSPGkMKssU1Yh9LWPrF=mAiWUwPb8pQnw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
	<CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
	<CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>
	<CAHOTMVLq7zrgETXrAcSPGkMKssU1Yh9LWPrF=mAiWUwPb8pQnw@mail.gmail.com>
Message-ID: <CA+DvKQLzxpDV4WyAorQVs1Xk+CF2780KC2ho-cMQXnab7adecA@mail.gmail.com>

On Sat, Jan 4, 2014 at 4:47 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Sat, Jan 4, 2014 at 1:44 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>>
>> This is not really any different than messing up brace nesting.
>
> Except brace nesting gives you more tokens from which someone reviewing your
> configuration can spot the error. A strict superset, at that, if you're
> indenting your code correctly anyway.

The problem being that only the braces matter, not the indentation.
Perhaps a missing brace is easier to see than a missing 8 space indent
or tab for some people, but not for me.

From bascule at gmail.com  Sat Jan  4 14:00:21 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 4 Jan 2014 14:00:21 -0800
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CA+DvKQLzxpDV4WyAorQVs1Xk+CF2780KC2ho-cMQXnab7adecA@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
	<CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
	<CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>
	<CAHOTMVLq7zrgETXrAcSPGkMKssU1Yh9LWPrF=mAiWUwPb8pQnw@mail.gmail.com>
	<CA+DvKQLzxpDV4WyAorQVs1Xk+CF2780KC2ho-cMQXnab7adecA@mail.gmail.com>
Message-ID: <CAHOTMVJMzurCsuAoo8mBhgLEO1FrCQHjWt+E-KXmKHNHgDiBdw@mail.gmail.com>

On Sat, Jan 4, 2014 at 1:53 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> The problem being that only the braces matter, not the indentation.
>  Perhaps a missing brace is easier to see than a missing 8 space indent
> or tab for some people, but not for me.
>

And what do you do if you're editing another YAML file that someone started
with 2-space tabs? Do you convert everything to 8? Use 8-space tabs just
for your stuff and leave the rest of the file with 2-space tabs?

I would venture to guess that 8-space YAML files are exceedingly uncommon.

I'd also say 8-space tabs are ugly.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140104/db277b16/attachment.html>

From danielmicay at gmail.com  Sat Jan  4 14:04:38 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 4 Jan 2014 17:04:38 -0500
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAHOTMVJMzurCsuAoo8mBhgLEO1FrCQHjWt+E-KXmKHNHgDiBdw@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<CA+DvKQJZh0DATK+jaR8KEEzj33TSQeuBZ_NO4n2Ymw8S=TOUaA@mail.gmail.com>
	<CAHOTMVKvo2Q-sCo7vw8gkRd+_H=mJRrz=xLLqPynQUq41yAa1w@mail.gmail.com>
	<CA+DvKQLh4zi-5vj7kFbKvWf6923NQCahvNwh_Q62Oc7r9UkuXw@mail.gmail.com>
	<CAHOTMVLq7zrgETXrAcSPGkMKssU1Yh9LWPrF=mAiWUwPb8pQnw@mail.gmail.com>
	<CA+DvKQLzxpDV4WyAorQVs1Xk+CF2780KC2ho-cMQXnab7adecA@mail.gmail.com>
	<CAHOTMVJMzurCsuAoo8mBhgLEO1FrCQHjWt+E-KXmKHNHgDiBdw@mail.gmail.com>
Message-ID: <CA+DvKQ+pXM1VS=MeR=dAY4rMm7OF7VQLGC5kYZGEDSzrQGJsiA@mail.gmail.com>

On Sat, Jan 4, 2014 at 5:00 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Sat, Jan 4, 2014 at 1:53 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>>
>> The problem being that only the braces matter, not the indentation.
>> Perhaps a missing brace is easier to see than a missing 8 space indent
>> or tab for some people, but not for me.
>
>
> And what do you do if you're editing another YAML file that someone started
> with 2-space tabs? Do you convert everything to 8? Use 8-space tabs just for
> your stuff and leave the rest of the file with 2-space tabs?

About as useful as saying non-YAML formats are less common, so all
hope is lost because you don't like YAML.

> I would venture to guess that 8-space YAML files are exceedingly uncommon.
>
> I'd also say 8-space tabs are ugly.

I'd say that they're far nicer than braces and encourage splitting up
the code/data sanely. Lots of nesting is hard to deal with, and
8-space indents discourage it.

From gaetan at xeberon.net  Sat Jan  4 16:39:45 2014
From: gaetan at xeberon.net (Gaetan)
Date: Sun, 5 Jan 2014 01:39:45 +0100
Subject: [rust-dev]  Configuration files library for Rust
In-Reply-To: <etPan.52c8762a.74b0dc51.55f4@christophersair>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<CA++BO6T4bAY-enGMFGmuFautBOMhUHG6fX6ffcQQFjYuBtGQXQ@mail.gmail.com>
	<52C84C3B.2020304@ntecs.de> <52C852B5.1020803@vandals.uidaho.edu>
	<CANK7tAEm4CfF-mD7OSDCSaahoP5AGAx_Reou2dhXcsFghfFoUA@mail.gmail.com>
	<CAHOTMV+qZYfE2C9FC02Hwpu5XZK5zZEM7UnbzO=_y8gizZtJHw@mail.gmail.com>
	<CA+DvKQ+VhX99EHxTbuB+RT0ihxAZmg-KAaVes2nGE4_xHc6qYQ@mail.gmail.com>
	<CAHOTMV+cAd+ASzfuUuqHHRD4VD3V+EGos9Ot_H8CZCpNPG6O6Q@mail.gmail.com>
	<FAE29893-93B5-4F17-A0C7-2F61A7884632@gmail.com>
	<etPan.52c8762a.74b0dc51.55f4@christophersair>
Message-ID: <CANK7tAEXNybaSetfBQjTds8yMXOOHHGy4S2Gw1do+Ws+RWizDA@mail.gmail.com>

Thanks for your answer.

I think having reference parsers for majors format is a top feature for the
rust standard lib. Json is pretty standard in web world, and yaml is pretty
simple replacement for XML but lack schema standard.

So if rust provides Json, yaml, ini, toml and why not other config
storage/exchange standards, that will surely attack many developpers, but i
recommend to have a certain homogeneity in the API.

I ve used yaml for quite long time, and indeed indentation can be an issue,
but that the same with Python code.... I am not fan with indentation
meaning nesting, but yaml is much simpler for me to use than Json.
Le 4 janv. 2014 21:59, "Chris Molozian" <chris at cmoz.me> a ?crit :

> I second the sysctl syntax it?s very easy to grep through configuration
> files in this format. The ?key? prefix contains the context for the
> information which is useful.
>
> i.e. ?riak_kv.anti_entropy_leveldb_opts.write_buffer_size?
>
> Riak, a distributed KV dynamo store has recently been moving to the sysctl
> format from the traditional Erlang `app.config` ?format".
>
> Cheers.
>
> --
> Chris Molozian
> Software Engineer
>
> On 4 January 2014 at 20:41:59, Christopher Meiklejohn (
> christopher.meiklejohn at gmail.com) wrote:
>
> On Jan 4, 2014, at 3:39 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
>   On Sat, Jan 4, 2014 at 12:35 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> I don't buy that. A text editor should be more than capable enough to
>> stop you from slipping in tabs. If there's a separate untested
>> configuration for production then you have a problem.
>
>
> This isn't just a single offhand incident. It's something I've seen a
> pattern of happening dozens of times over the course of my career. It's
> happened to me personally, and I've seen it happen to others.
>
> Having separate configuration sections for different environments is a
> rather common convention in the Rails world. Is it a bad idea? Offhand I
> can't say: what would you replace it with?
>
>
> Why not something that looks like sysctl [1] syntax?
>
> http://www5.us.freebsd.org/doc/handbook/configtuning-sysctl.html
>
> - Chris
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>

-- 
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/85ca23a4/attachment.html>

From mneumann at ntecs.de  Sun Jan  5 17:45:01 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Mon, 06 Jan 2014 02:45:01 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
Message-ID: <52CA0A9D.20404@ntecs.de>


Am 04.01.2014 15:01, schrieb Flaper87:
> Hi Guys,
>
> I was looking around and I couldn't find a config file parser library 
> for Rust. Getopt support seems to be pretty complete and stable, which 
> would make the development of such library easier.

There is now a TOML parser for Rust [1] :)

[1]: https://github.com/mneumann/rust-toml

Regards,

     Michael

From greg at kinostudios.com  Sun Jan  5 18:11:16 2014
From: greg at kinostudios.com (Greg)
Date: Sun, 5 Jan 2014 21:11:16 -0500
Subject: [rust-dev] Emscripten for Rust?
Message-ID: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>

I'd happy chip in for a Kickstarter-type project to automatically convert C/C++ to Rust.

Anything like this exists or anyone planning on making this type of announcement?

- Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/cf7a3144/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/cf7a3144/attachment.sig>

From corey at octayn.net  Sun Jan  5 18:21:03 2014
From: corey at octayn.net (Corey Richardson)
Date: Sun, 5 Jan 2014 21:21:03 -0500
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
Message-ID: <CA++BO6Qt0-cCkwrj_NPdxA9i23_4kOt+FR23Nb6qG3T4vCoVMw@mail.gmail.com>

Any such conversion is going to be lossy enough as to be worthless.
It's only acceptable for emscripten because the web platform can't run
native code. But any use of Rust is already going to be  targetting
something that can run C.

On Sun, Jan 5, 2014 at 9:11 PM, Greg <greg at kinostudios.com> wrote:
> I'd happy chip in for a Kickstarter-type project to automatically convert
> C/C++ to Rust.
>
> Anything like this exists or anyone planning on making this type of
> announcement?
>
> - Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From ben.striegel at gmail.com  Sun Jan  5 18:21:09 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sun, 5 Jan 2014 21:21:09 -0500
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
Message-ID: <CAAvrL-kc7W4ZC-zF3KFPv9UW=+t7nOpXYsaXVKRWSb+9ty5TQg@mail.gmail.com>

I'm not sure if this is generally feasible! If memory-unsafe C/C++ code
could be automatically and mechanically converted to memory-safe Rust code,
then that would imply the existence of static analysis tools for C/C++ code
that could themselves guarantee memory safety without requiring Rust at all.


On Sun, Jan 5, 2014 at 9:11 PM, Greg <greg at kinostudios.com> wrote:

> I'd happy chip in for a Kickstarter-type project to automatically convert
> C/C++ to Rust.
>
> Anything like this exists or anyone planning on making this type of
> announcement?
>
> - Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing with
> the NSA.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/c53da4cd/attachment.html>

From dbau.pp at gmail.com  Sun Jan  5 18:25:41 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 06 Jan 2014 13:25:41 +1100
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <CA++BO6Qt0-cCkwrj_NPdxA9i23_4kOt+FR23Nb6qG3T4vCoVMw@mail.gmail.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CA++BO6Qt0-cCkwrj_NPdxA9i23_4kOt+FR23Nb6qG3T4vCoVMw@mail.gmail.com>
Message-ID: <52CA1425.4080009@gmail.com>

On first glance it seems like C -> Rust would be very feasible via a lot 
of `unsafe`, * and *mut.


On 06/01/14 13:21, Corey Richardson wrote:
> Any such conversion is going to be lossy enough as to be worthless.
> It's only acceptable for emscripten because the web platform can't run
> native code. But any use of Rust is already going to be  targetting
> something that can run C.
>
> On Sun, Jan 5, 2014 at 9:11 PM, Greg <greg at kinostudios.com> wrote:
>> I'd happy chip in for a Kickstarter-type project to automatically convert
>> C/C++ to Rust.
>>
>> Anything like this exists or anyone planning on making this type of
>> announcement?
>>
>> - Greg
>>
>> --
>> Please do not email me anything that you are not comfortable also sharing
>> with the NSA.
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From corey at octayn.net  Sun Jan  5 18:28:47 2014
From: corey at octayn.net (Corey Richardson)
Date: Sun, 5 Jan 2014 21:28:47 -0500
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <52CA1425.4080009@gmail.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CA++BO6Qt0-cCkwrj_NPdxA9i23_4kOt+FR23Nb6qG3T4vCoVMw@mail.gmail.com>
	<52CA1425.4080009@gmail.com>
Message-ID: <CA++BO6Qx=UMQ-Z7wR0kjf35bRoENcMXw5CDRWjnGxpdU=egsaA@mail.gmail.com>

Much of it would be. But why?

On Sun, Jan 5, 2014 at 9:25 PM, Huon Wilson <dbau.pp at gmail.com> wrote:
> On first glance it seems like C -> Rust would be very feasible via a lot of
> `unsafe`, * and *mut.
>
>
>
> On 06/01/14 13:21, Corey Richardson wrote:
>>
>> Any such conversion is going to be lossy enough as to be worthless.
>> It's only acceptable for emscripten because the web platform can't run
>> native code. But any use of Rust is already going to be  targetting
>> something that can run C.
>>
>> On Sun, Jan 5, 2014 at 9:11 PM, Greg <greg at kinostudios.com> wrote:
>>>
>>> I'd happy chip in for a Kickstarter-type project to automatically convert
>>> C/C++ to Rust.
>>>
>>> Anything like this exists or anyone planning on making this type of
>>> announcement?
>>>
>>> - Greg
>>>
>>> --
>>> Please do not email me anything that you are not comfortable also sharing
>>> with the NSA.
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From me at kevincantu.org  Sun Jan  5 19:47:09 2014
From: me at kevincantu.org (Kevin Cantu)
Date: Sun, 5 Jan 2014 19:47:09 -0800
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <CA++BO6Qx=UMQ-Z7wR0kjf35bRoENcMXw5CDRWjnGxpdU=egsaA@mail.gmail.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CA++BO6Qt0-cCkwrj_NPdxA9i23_4kOt+FR23Nb6qG3T4vCoVMw@mail.gmail.com>
	<52CA1425.4080009@gmail.com>
	<CA++BO6Qx=UMQ-Z7wR0kjf35bRoENcMXw5CDRWjnGxpdU=egsaA@mail.gmail.com>
Message-ID: <CABq6+ac7cEu30cTdtSr-PpiqjFhpcZ9iHt3O-L4V8LvQ93kcaQ@mail.gmail.com>

It would provide a nice migration path.  And a way to guarantee that
your nice Rust program had some terrible unsupported legacy C for the
next decade or two.  ;D

Kevin

On Sun, Jan 5, 2014 at 6:28 PM, Corey Richardson <corey at octayn.net> wrote:
> Much of it would be. But why?
>
> On Sun, Jan 5, 2014 at 9:25 PM, Huon Wilson <dbau.pp at gmail.com> wrote:
>> On first glance it seems like C -> Rust would be very feasible via a lot of
>> `unsafe`, * and *mut.
>>
>>
>>
>> On 06/01/14 13:21, Corey Richardson wrote:
>>>
>>> Any such conversion is going to be lossy enough as to be worthless.
>>> It's only acceptable for emscripten because the web platform can't run
>>> native code. But any use of Rust is already going to be  targetting
>>> something that can run C.
>>>
>>> On Sun, Jan 5, 2014 at 9:11 PM, Greg <greg at kinostudios.com> wrote:
>>>>
>>>> I'd happy chip in for a Kickstarter-type project to automatically convert
>>>> C/C++ to Rust.
>>>>
>>>> Anything like this exists or anyone planning on making this type of
>>>> announcement?
>>>>
>>>> - Greg
>>>>
>>>> --
>>>> Please do not email me anything that you are not comfortable also sharing
>>>> with the NSA.
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From bascule at gmail.com  Sun Jan  5 20:07:11 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Sun, 5 Jan 2014 20:07:11 -0800
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
Message-ID: <CAHOTMVL6H1xKdw+xFxU8P2pa3F+3jq7LC2CmHRHe9cDo+G64DA@mail.gmail.com>

Just wait until they write RustMonkey for Servo, then you can run your
Emscriptened C++ inside of that


On Sun, Jan 5, 2014 at 6:11 PM, Greg <greg at kinostudios.com> wrote:

> I'd happy chip in for a Kickstarter-type project to automatically convert
> C/C++ to Rust.
>
> Anything like this exists or anyone planning on making this type of
> announcement?
>
> - Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing with
> the NSA.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/570dc29a/attachment.html>

From j.boggiano at seld.be  Sun Jan  5 23:49:58 2014
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Mon, 06 Jan 2014 08:49:58 +0100
Subject: [rust-dev] Configuration files library for Rust
In-Reply-To: <52CA0A9D.20404@ntecs.de>
References: <CAMOT3C15a-fbGneXM_Hr-6nA=N5HhpHPJ8pdtOaCWYFiD1Nc2w@mail.gmail.com>
	<52CA0A9D.20404@ntecs.de>
Message-ID: <52CA6026.60402@seld.be>

On 06/01/2014 02:45, Michael Neumann wrote:
>> I was looking around and I couldn't find a config file parser library
>> for Rust. Getopt support seems to be pretty complete and stable, which
>> would make the development of such library easier.
>
> There is now a TOML parser for Rust [1] :)

Thanks!

/me crosses item off the todo list

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From mneumann at ntecs.de  Mon Jan  6 06:57:50 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Mon, 06 Jan 2014 15:57:50 +0100
Subject: [rust-dev] [ANN] rust-toml - TOML configuration file parser
Message-ID: <52CAC46E.3030004@ntecs.de>

Hi all,

rust-toml [1] is TOML [2] configuration file parser :)

Regards,

    Michael

[1]: https://github.com/mneumann/rust-toml
[2]: https://github.com/mojombo/toml

From chris at cmoz.me  Mon Jan  6 07:29:04 2014
From: chris at cmoz.me (Chris Molozian)
Date: Mon, 6 Jan 2014 08:29:04 -0700
Subject: [rust-dev] [ANN] rust-toml - TOML configuration file parser
In-Reply-To: <52CAC46E.3030004@ntecs.de>
References: <52CAC46E.3030004@ntecs.de>
Message-ID: <etPan.52cacbc1.74b0dc51.6737@Christophers-MacBook-Air.local>

Nice work! :)

FWIW, the license text in the README talks about a different project:

??"
rust-redis is under the MIT license, see LICENSE-MIT for details.

Copyright (c) 2014 by Michael Neumann.
???

Also, it?d be nice to get this on Rust CI:?http://www.rust-ci.org/

Cheers,

Chris

--?
Chris Molozian
Software Engineer


On 6 January 2014 at 07:58:01, Michael Neumann (mneumann at ntecs.de) wrote:

Hi all,  

rust-toml [1] is TOML [2] configuration file parser :)  

Regards,  

Michael  

[1]: https://github.com/mneumann/rust-toml  
[2]: https://github.com/mojombo/toml  
_______________________________________________  
Rust-dev mailing list  
Rust-dev at mozilla.org  
https://mail.mozilla.org/listinfo/rust-dev  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140106/1b895e97/attachment.html>

From armin.ronacher at active-4.com  Mon Jan  6 07:56:34 2014
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Mon, 06 Jan 2014 15:56:34 +0000
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
In-Reply-To: <52C833CD.5030303@ntecs.de>
References: <52C83364.7020500@ntecs.de> <52C833CD.5030303@ntecs.de>
Message-ID: <52CAD232.7070908@active-4.com>

Hi,

On 04/01/2014 16:16, Michael Neumann wrote:
>> rust-redis: A Redis client library written in pure Rust. Thanks to the new
>> rust runtime
>> it is pretty fast, despite being only 200 lines of code.
Just compared that with the one I'm working on 
(https://github.com/mitsuhiko/redis-rs/) and maybe we can unify those two into 
one.  I plan on continue maintaining mine for a long time to come as I'm using 
redis very frequently.

My biggest issue currently with continue working on it, is that I want to 
replicate the pipeline functionality from the Python and JavaScript 
implementation but I can't see a way of doing that in Rust without having to 
manually generate code.  Macros are not going to be particularly useful.

Primarily the issue is that on the client you want this:

     fn get(&mut self, key: ~str) -> ~str {
         value_as_string(self.execute("GET", [StrArg(key)]))
     }

but on the pipeline you want this behavior:

     let rv = client.pipeline()
           .get("my_key")
           .tap(|s| println!("I got a string: {}", s)
           .get("another_key")
           .execute();

     for result in rv {
         println!("I got result: {}", result);
     }

I am not sure yet how to do this nicely without repeating a lot of code (also I 
have no idea how to make .tap() work).


Regards,
Armin


From mneumann at ntecs.de  Mon Jan  6 09:00:29 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Mon, 06 Jan 2014 18:00:29 +0100
Subject: [rust-dev] [ANN] rust-redis and rust-msgpack
In-Reply-To: <52C84ECD.1090709@mozilla.com>
References: <52C83364.7020500@ntecs.de> <52C833CD.5030303@ntecs.de>
	<52C84ECD.1090709@mozilla.com>
Message-ID: <52CAE12D.1090003@ntecs.de>


Am 04.01.2014 19:11, schrieb Patrick Walton:
> On 1/4/14 8:16 AM, Michael Neumann wrote:
>>> rust-msgpack: Fully featured and high performance msgpack
>>> implementation for Rust.
>>>
>>> Both work with rust 0.9-pre.
>>
>> Too stupid/sleepy that I forgot the links:
>>
>> http://github.com/mneumann/rust-redis
>> http://github.com/mneumann/rust-msgpack
>
> Sweet! msgpack might be a good IPC format for Servo.

Give it a try :)

It's very efficient, both in storage and speed.

Regards,

   Michael

From greg at kinostudios.com  Mon Jan  6 09:21:23 2014
From: greg at kinostudios.com (Greg)
Date: Mon, 6 Jan 2014 12:21:23 -0500
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <CAHOTMVL6H1xKdw+xFxU8P2pa3F+3jq7LC2CmHRHe9cDo+G64DA@mail.gmail.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CAHOTMVL6H1xKdw+xFxU8P2pa3F+3jq7LC2CmHRHe9cDo+G64DA@mail.gmail.com>
Message-ID: <1C24BF95-E8AB-4D03-A676-59A3C3F6DCFC@kinostudios.com>

Hmm. I don't think that's quite what I'm looking for. I'm not interested in converting C++ to JS, but C++ to Rust.

I think the skepticism expressed in other replies is unwarranted. Between the sort of static analysis that LLVM & Xcode do, along with feedback from a human developer, something could definitely be done to greatly speed up the porting of C++ programs to Rust, and I think many people would love to have that, including the wonderful folks at Mozilla. :-)

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

On Jan 5, 2014, at 11:07 PM, Tony Arcieri <bascule at gmail.com> wrote:

> Just wait until they write RustMonkey for Servo, then you can run your Emscriptened C++ inside of that
> 
> 
> On Sun, Jan 5, 2014 at 6:11 PM, Greg <greg at kinostudios.com> wrote:
> I'd happy chip in for a Kickstarter-type project to automatically convert C/C++ to Rust.
> 
> Anything like this exists or anyone planning on making this type of announcement?
> 
> - Greg
> 
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> 
> -- 
> Tony Arcieri

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140106/f88f742c/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140106/f88f742c/attachment-0001.sig>

From douglas.linder at gmail.com  Sat Jan  4 22:13:28 2014
From: douglas.linder at gmail.com (Doug)
Date: Sun, 5 Jan 2014 14:13:28 +0800
Subject: [rust-dev] Using CMake with Rust
In-Reply-To: <52C4F9E2.1070702@aim.com>
References: <52C4EA82.1050706@aim.com> <52C4F397.3070104@gmail.com>
	<52C4F9E2.1070702@aim.com>
Message-ID: <CADbLNrHK-34jivhpCYNJ9EjHkaBWTy9nGeLNOyoA4gBBAcjPqA@mail.gmail.com>

For what it's worth, your rust cmake example currently seems to work with
ninja, which is brilliant. My vote definitely goes for your current
approach; I tried to implement a C# module for cmake some time ago using
the other method, and ran into similar sorts of issues (specifically with
various variables only being supported by Makefile builds in cmake).

~
Doug.


On Thu, Jan 2, 2014 at 1:32 PM, SiegeLord <slabode at aim.com> wrote:

> On 01/02/2014 12:05 AM, Gy?rgy Andrasek wrote:
>
>> The proper way to support a language in CMake is outlined in
>> `Modules/CMakeAddNewLanguage.txt`:
>>
>
> I was guided away from that method by this email: http://www.cmake.org/
> pipermail/cmake/2011-March/043444.html . My approach is amenable to
> generating files for alternative build systems, like ninja. If you are
> aware that that email is incorrect, I'm glad to be corrected. Independently
> of that email, I have looked into doing it that way, but I found that it
> just did not mesh with the Rust compilation model, and I saw no clear way
> to using the information given by 'rustc --dep-info' to inform the build
> system. Additionally, my macros allow an easy way of doing documentation
> generation, which that method doesn't clearly allow.
>
> I'll be glad to be corrected on all those points though.
>
> -SL
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140105/e164b10a/attachment.html>

From greg at kinostudios.com  Mon Jan  6 11:45:43 2014
From: greg at kinostudios.com (Greg)
Date: Mon, 6 Jan 2014 14:45:43 -0500
Subject: [rust-dev] C/C++ to Rust cross-compiler [Re: Emscripten for Rust?]
In-Reply-To: <1C24BF95-E8AB-4D03-A676-59A3C3F6DCFC@kinostudios.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CAHOTMVL6H1xKdw+xFxU8P2pa3F+3jq7LC2CmHRHe9cDo+G64DA@mail.gmail.com>
	<1C24BF95-E8AB-4D03-A676-59A3C3F6DCFC@kinostudios.com>
Message-ID: <42CDE7DB-446E-4285-AE0B-4E48873A90FF@kinostudios.com>

Someone very helpfully pointed out the following to me offlist, and so I've changed the subject of the thread:

The word you're looking for is a 'cross compiler' or 'transpiler.'
Saying "emscripten" calls forth an image of a transpiler _to_
JavaScript.

I think this would be super neat, but as was previously said, possibly
too lossy to be useful.

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

On Jan 6, 2014, at 12:21 PM, Greg <greg at kinostudios.com> wrote:

> Hmm. I don't think that's quite what I'm looking for. I'm not interested in converting C++ to JS, but C++ to Rust.
> 
> I think the skepticism expressed in other replies is unwarranted. Between the sort of static analysis that LLVM & Xcode do, along with feedback from a human developer, something could definitely be done to greatly speed up the porting of C++ programs to Rust, and I think many people would love to have that, including the wonderful folks at Mozilla. :-)
> 
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
> 
> On Jan 5, 2014, at 11:07 PM, Tony Arcieri <bascule at gmail.com> wrote:
> 
>> Just wait until they write RustMonkey for Servo, then you can run your Emscriptened C++ inside of that
>> 
>> 
>> On Sun, Jan 5, 2014 at 6:11 PM, Greg <greg at kinostudios.com> wrote:
>> I'd happy chip in for a Kickstarter-type project to automatically convert C/C++ to Rust.
>> 
>> Anything like this exists or anyone planning on making this type of announcement?
>> 
>> - Greg
>> 
>> --
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 
>> 
>> 
>> -- 
>> Tony Arcieri
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140106/a2c52482/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140106/a2c52482/attachment.sig>

From martindemello at gmail.com  Mon Jan  6 11:46:59 2014
From: martindemello at gmail.com (Martin DeMello)
Date: Mon, 6 Jan 2014 11:46:59 -0800
Subject: [rust-dev] Emscripten for Rust?
In-Reply-To: <1C24BF95-E8AB-4D03-A676-59A3C3F6DCFC@kinostudios.com>
References: <D1BE9BF7-CDB8-4AE5-A663-A443437A0143@kinostudios.com>
	<CAHOTMVL6H1xKdw+xFxU8P2pa3F+3jq7LC2CmHRHe9cDo+G64DA@mail.gmail.com>
	<1C24BF95-E8AB-4D03-A676-59A3C3F6DCFC@kinostudios.com>
Message-ID: <CAFrFfuE20qPYzSPE9fBsLuFxUA6OZPgM6gkn2Khi1qiATX8coA@mail.gmail.com>

I think it would be more useful to extend rust-bindgen to support c++,
and work from there. dobkeratops has done some work on this already:
https://github.com/dobkeratops/rust-bindgen/tree/cpptemplate

martin

On Mon, Jan 6, 2014 at 9:21 AM, Greg <greg at kinostudios.com> wrote:
> Hmm. I don't think that's quite what I'm looking for. I'm not interested in
> converting C++ to JS, but C++ to Rust.
>
> I think the skepticism expressed in other replies is unwarranted. Between
> the sort of static analysis that LLVM & Xcode do, along with feedback from a
> human developer, something could definitely be done to greatly speed up the
> porting of C++ programs to Rust, and I think many people would love to have
> that, including the wonderful folks at Mozilla. :-)
>
> --
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> On Jan 5, 2014, at 11:07 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
> Just wait until they write RustMonkey for Servo, then you can run your
> Emscriptened C++ inside of that
>
>
> On Sun, Jan 5, 2014 at 6:11 PM, Greg <greg at kinostudios.com> wrote:
>>
>> I'd happy chip in for a Kickstarter-type project to automatically convert
>> C/C++ to Rust.
>>
>> Anything like this exists or anyone planning on making this type of
>> announcement?
>>
>> - Greg
>>
>> --
>> Please do not email me anything that you are not comfortable also sharing
>> with the NSA.
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> --
> Tony Arcieri
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From mneumann at ntecs.de  Tue Jan  7 07:37:36 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Tue, 07 Jan 2014 16:37:36 +0100
Subject: [rust-dev] Porting rust to DragonFlyBSD
Message-ID: <52CC1F40.4010602@ntecs.de>

Hi there,

At the moment rust "only" supports Linux/FreeBSD/Windows/MacOSX. I'd 
like to be
able to compile it on DragonFlyBSD [1].

I am trying to get the FreeBSD stage0/bin/rustc to run on DragonFly, yet 
with no success.
Is it possible to generate a static rustc binary somehow? Or what in 
general is the procedure
to "port" rustc to a different platform?

Regards,

     Michael

[1]: http://www.dragonflybsd.org/

From alex at crichton.co  Tue Jan  7 08:10:22 2014
From: alex at crichton.co (Alex Crichton)
Date: Tue, 7 Jan 2014 08:10:22 -0800
Subject: [rust-dev] Porting rust to DragonFlyBSD
In-Reply-To: <52CC1F40.4010602@ntecs.de>
References: <52CC1F40.4010602@ntecs.de>
Message-ID: <CAFnh-me2gZWxGLAiw+Hq3vwVfUz=HJ6bg2wwL4OusQWj5H0mFg@mail.gmail.com>

The snapshots themselves are all "static binaries" in the sense that
they have no dynamic rust dependencies and only the "necessary" system
dependencies. Rustc does not generate 0-dependency static binaries
right now that depend on libstd (as that would involve rewriting libc
and writing a syscall interface for all platforms).

When porting to a new architecture, the general idea is to add support
in the compiler and standard libraries, then use cross compilation
from a supported platform to generate a snapshot for the target
platform, then take the snapshot and bootstrap on the target platform.

A new platform hasn't shown up in awhile, but this sounds pretty cool!

On Tue, Jan 7, 2014 at 7:37 AM, Michael Neumann <mneumann at ntecs.de> wrote:
> Hi there,
>
> At the moment rust "only" supports Linux/FreeBSD/Windows/MacOSX. I'd like to
> be
> able to compile it on DragonFlyBSD [1].
>
> I am trying to get the FreeBSD stage0/bin/rustc to run on DragonFly, yet
> with no success.
> Is it possible to generate a static rustc binary somehow? Or what in general
> is the procedure
> to "port" rustc to a different platform?
>
> Regards,
>
>     Michael
>
> [1]: http://www.dragonflybsd.org/
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From lists at ncameron.org  Tue Jan  7 11:30:44 2014
From: lists at ncameron.org (Nick Cameron)
Date: Wed, 8 Jan 2014 08:30:44 +1300
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <52A23660.5040500@exyr.org>
References: <52A23660.5040500@exyr.org>
Message-ID: <CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>

I agree with Simon that doubling the API is inelegant. I think the solution
is adding sugar to make working with Option/Result easier -
(semi-)independent of the foo/foo_opt issue, I find working with Option
pretty painful.

I prefer the Haskell do sugar to refutable patterns in let. Similar in
spirit is the ? operator from Groovy, which I think is elegant and simple,
it is an alternative to the . operator for field access/method call. In
Rust it would have the following type and semantics:

\Gamma e : Option<T'>
fType(T', f) = T
------------------------------------
\Gamma e?f : Option<T>

e?f ~~> match e { Some<e> => Some<e.f>, None => None }

and similarly for method call.

The ? operator has the same advantages and disadvantages as Haskell's do,
but is more concise.

Just another alternative to consider.


On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org> wrote:

> We have some functions and methods such as [std::str::from_utf8](http://
> static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may
> succeed and give a result, or fail when the input is invalid.
>
> 1. Sometimes we assume the input is valid and don?t want to deal with the
> error case. Task failure works nicely.
>
> 2. Sometimes we do want to do something different on invalid input, so
> returning an `Option<T>` works best.
>
> And so we end up with both `from_utf8` and `from_utf8`. This particular
> case is worse because we also have `from_utf8_owned` and
> `from_utf8_owned_opt`, to cover everything.
>
> Multiplying names like this is just not good design. I?d like to reduce
> this pattern.
>
> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on the
> Option. I think we should rename every `foo_opt()` function or method to
> just `foo`, remove the old `foo()` behavior, and tell people (through
> documentation) to use `foo().unwrap()` if they want it back?
>
> The downsides are that unwrap is more verbose and gives less helpful error
> messages on task failure. But I think it?s worth it.
>
> What do you think?
>
> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
> this before sending pull requests with invasive API changes.)
>
> --
> Simon Sapin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/d45d54f8/attachment.html>

From thadguidry at gmail.com  Tue Jan  7 11:35:30 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 7 Jan 2014 13:35:30 -0600
Subject: [rust-dev] Porting rust to DragonFlyBSD
In-Reply-To: <CAFnh-me2gZWxGLAiw+Hq3vwVfUz=HJ6bg2wwL4OusQWj5H0mFg@mail.gmail.com>
References: <52CC1F40.4010602@ntecs.de>
	<CAFnh-me2gZWxGLAiw+Hq3vwVfUz=HJ6bg2wwL4OusQWj5H0mFg@mail.gmail.com>
Message-ID: <CAChbWaP=Pxp6ZjPDqZiT+RKnqxHFQcxm4iJP+-qhPC_FfFHuTw@mail.gmail.com>

I am VERY interested in the support of this platform, DragonFlyBSD.  Which
is a great "Systems OS" in and of itself.

Thanks for your future efforts on it, Michael !

(BTW, in particular, I am interested in access to the HAMMER File System on
DragonFlyBSD to begin my experiments)



On Tue, Jan 7, 2014 at 10:10 AM, Alex Crichton <alex at crichton.co> wrote:

> The snapshots themselves are all "static binaries" in the sense that
> they have no dynamic rust dependencies and only the "necessary" system
> dependencies. Rustc does not generate 0-dependency static binaries
> right now that depend on libstd (as that would involve rewriting libc
> and writing a syscall interface for all platforms).
>
> When porting to a new architecture, the general idea is to add support
> in the compiler and standard libraries, then use cross compilation
> from a supported platform to generate a snapshot for the target
> platform, then take the snapshot and bootstrap on the target platform.
>
> A new platform hasn't shown up in awhile, but this sounds pretty cool!
>
> On Tue, Jan 7, 2014 at 7:37 AM, Michael Neumann <mneumann at ntecs.de> wrote:
> > Hi there,
> >
> > At the moment rust "only" supports Linux/FreeBSD/Windows/MacOSX. I'd
> like to
> > be
> > able to compile it on DragonFlyBSD [1].
> >
> > I am trying to get the FreeBSD stage0/bin/rustc to run on DragonFly, yet
> > with no success.
> > Is it possible to generate a static rustc binary somehow? Or what in
> general
> > is the procedure
> > to "port" rustc to a different platform?
> >
> > Regards,
> >
> >     Michael
> >
> > [1]: http://www.dragonflybsd.org/
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140107/1e8235f3/attachment.html>

From vadimcn at gmail.com  Tue Jan  7 16:42:49 2014
From: vadimcn at gmail.com (Vadim)
Date: Tue, 7 Jan 2014 16:42:49 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
Message-ID: <CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>

I can see how '?.' would work when foo() returns a struct, but what about
non-struct types, e.g. Option<i32> ?   Also, you'd still have to deal with
'None' at the end of the chain.   I think in most cases I'd rather have it
fail.

I also don't really like refutable let-patterns proposal, because stuff
like "let Some(x) = foo();" does not work with chaining when foo() returns
a struct (and is still pretty wordy).

Maybe we need an operator for "getting wrapped value"?   This would be
similar to "deref" for [smart]pointers, except I think it should be a
postfix operator to allow for easy chaining.   Let's say we chose '^' for
this purpose, and implemented its' trait for Option, Result, etc.  Then one
could write:
    let x = foo()^;
or
    let y = foo()^.field;

Vadim



On Tue, Jan 7, 2014 at 11:30 AM, Nick Cameron <lists at ncameron.org> wrote:

> I agree with Simon that doubling the API is inelegant. I think the
> solution is adding sugar to make working with Option/Result easier -
> (semi-)independent of the foo/foo_opt issue, I find working with Option
> pretty painful.
>
> I prefer the Haskell do sugar to refutable patterns in let. Similar in
> spirit is the ? operator from Groovy, which I think is elegant and simple,
> it is an alternative to the . operator for field access/method call. In
> Rust it would have the following type and semantics:
>
> \Gamma e : Option<T'>
> fType(T', f) = T
> ------------------------------------
> \Gamma e?f : Option<T>
>
> e?f ~~> match e { Some<e> => Some<e.f>, None => None }
>
> and similarly for method call.
>
> The ? operator has the same advantages and disadvantages as Haskell's do,
> but is more concise.
>
> Just another alternative to consider.
>
>
> On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org> wrote:
>
>> We have some functions and methods such as [std::str::from_utf8](http://
>> static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may
>> succeed and give a result, or fail when the input is invalid.
>>
>> 1. Sometimes we assume the input is valid and don?t want to deal with the
>> error case. Task failure works nicely.
>>
>> 2. Sometimes we do want to do something different on invalid input, so
>> returning an `Option<T>` works best.
>>
>> And so we end up with both `from_utf8` and `from_utf8`. This particular
>> case is worse because we also have `from_utf8_owned` and
>> `from_utf8_owned_opt`, to cover everything.
>>
>> Multiplying names like this is just not good design. I?d like to reduce
>> this pattern.
>>
>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on
>> the Option. I think we should rename every `foo_opt()` function or method
>> to just `foo`, remove the old `foo()` behavior, and tell people (through
>> documentation) to use `foo().unwrap()` if they want it back?
>>
>> The downsides are that unwrap is more verbose and gives less helpful
>> error messages on task failure. But I think it?s worth it.
>>
>> What do you think?
>>
>> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
>> this before sending pull requests with invasive API changes.)
>>
>> --
>> Simon Sapin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140107/62b9fc50/attachment.html>

From lists at ncameron.org  Tue Jan  7 18:39:24 2014
From: lists at ncameron.org (Nick Cameron)
Date: Wed, 8 Jan 2014 15:39:24 +1300
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
	<CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
Message-ID: <CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>

I think that you eventually have to deal with the Some or None-ness of an
expression is an advantage of the ? operator, it means you can't ignore
failure, but you don't have to deal with it at every step of a compound
expression. Using an operator for unwrap has the same disadvantage as plain
unwrap - it lets you ignore the failure case.


On Wed, Jan 8, 2014 at 1:42 PM, Vadim <vadimcn at gmail.com> wrote:

> I can see how '?.' would work when foo() returns a struct, but what about
> non-struct types, e.g. Option<i32> ?   Also, you'd still have to deal with
> 'None' at the end of the chain.   I think in most cases I'd rather have it
> fail.
>
> I also don't really like refutable let-patterns proposal, because stuff
> like "let Some(x) = foo();" does not work with chaining when foo() returns
> a struct (and is still pretty wordy).
>
> Maybe we need an operator for "getting wrapped value"?   This would be
> similar to "deref" for [smart]pointers, except I think it should be a
> postfix operator to allow for easy chaining.   Let's say we chose '^' for
> this purpose, and implemented its' trait for Option, Result, etc.  Then one
> could write:
>     let x = foo()^;
> or
>     let y = foo()^.field;
>
> Vadim
>
>
>
> On Tue, Jan 7, 2014 at 11:30 AM, Nick Cameron <lists at ncameron.org> wrote:
>
>> I agree with Simon that doubling the API is inelegant. I think the
>> solution is adding sugar to make working with Option/Result easier -
>> (semi-)independent of the foo/foo_opt issue, I find working with Option
>> pretty painful.
>>
>> I prefer the Haskell do sugar to refutable patterns in let. Similar in
>> spirit is the ? operator from Groovy, which I think is elegant and simple,
>> it is an alternative to the . operator for field access/method call. In
>> Rust it would have the following type and semantics:
>>
>> \Gamma e : Option<T'>
>> fType(T', f) = T
>> ------------------------------------
>> \Gamma e?f : Option<T>
>>
>> e?f ~~> match e { Some<e> => Some<e.f>, None => None }
>>
>> and similarly for method call.
>>
>> The ? operator has the same advantages and disadvantages as Haskell's do,
>> but is more concise.
>>
>> Just another alternative to consider.
>>
>>
>> On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org> wrote:
>>
>>> We have some functions and methods such as [std::str::from_utf8](http://
>>> static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may
>>> succeed and give a result, or fail when the input is invalid.
>>>
>>> 1. Sometimes we assume the input is valid and don?t want to deal with
>>> the error case. Task failure works nicely.
>>>
>>> 2. Sometimes we do want to do something different on invalid input, so
>>> returning an `Option<T>` works best.
>>>
>>> And so we end up with both `from_utf8` and `from_utf8`. This particular
>>> case is worse because we also have `from_utf8_owned` and
>>> `from_utf8_owned_opt`, to cover everything.
>>>
>>> Multiplying names like this is just not good design. I?d like to reduce
>>> this pattern.
>>>
>>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on
>>> the Option. I think we should rename every `foo_opt()` function or method
>>> to just `foo`, remove the old `foo()` behavior, and tell people (through
>>> documentation) to use `foo().unwrap()` if they want it back?
>>>
>>> The downsides are that unwrap is more verbose and gives less helpful
>>> error messages on task failure. But I think it?s worth it.
>>>
>>> What do you think?
>>>
>>> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
>>> this before sending pull requests with invasive API changes.)
>>>
>>> --
>>> Simon Sapin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/01b277ac/attachment.html>

From vadimcn at gmail.com  Tue Jan  7 19:31:16 2014
From: vadimcn at gmail.com (Vadim)
Date: Tue, 7 Jan 2014 19:31:16 -0800
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
	<CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
	<CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>
Message-ID: <CADecdiLC9TuDNedJSSXS3S2SM=RCiPS1uxqW9HgUwV2beeokxA@mail.gmail.com>

On Tue, Jan 7, 2014 at 6:39 PM, Nick Cameron <lists at ncameron.org> wrote:

> I think that you eventually have to deal with the Some or None-ness of an
> expression is an advantage of the ? operator, it means you can't ignore
> failure, but you don't have to deal with it at every step of a compound
> expression. Using an operator for unwrap has the same disadvantage as plain
> unwrap - it lets you ignore the failure case.
>

First of all, it does not let me ignore errors - if I try to unwrap() a
None, it will kill my program (or at least the current task).   Whether
this is what I want, depends on the use case.   In my experience, more
often than not, an error returned by an API represents a bug in the
program.  So what am I gonna do when I see that something has error'ed
out?  I will probably just call fail!().

Anyways, I think this thread was about how to avoid having both foo() and
foo_opt() versions of every API, and many people (including myself),
consider unwrap() too noisy.  So...

Vadim



>
> On Wed, Jan 8, 2014 at 1:42 PM, Vadim <vadimcn at gmail.com> wrote:
>
>> I can see how '?.' would work when foo() returns a struct, but what about
>> non-struct types, e.g. Option<i32> ?   Also, you'd still have to deal with
>> 'None' at the end of the chain.   I think in most cases I'd rather have it
>> fail.
>>
>> I also don't really like refutable let-patterns proposal, because stuff
>> like "let Some(x) = foo();" does not work with chaining when foo() returns
>> a struct (and is still pretty wordy).
>>
>> Maybe we need an operator for "getting wrapped value"?   This would be
>> similar to "deref" for [smart]pointers, except I think it should be a
>> postfix operator to allow for easy chaining.   Let's say we chose '^' for
>> this purpose, and implemented its' trait for Option, Result, etc.  Then one
>> could write:
>>     let x = foo()^;
>> or
>>     let y = foo()^.field;
>>
>> Vadim
>>
>>
>>
>> On Tue, Jan 7, 2014 at 11:30 AM, Nick Cameron <lists at ncameron.org> wrote:
>>
>>> I agree with Simon that doubling the API is inelegant. I think the
>>> solution is adding sugar to make working with Option/Result easier -
>>> (semi-)independent of the foo/foo_opt issue, I find working with Option
>>> pretty painful.
>>>
>>> I prefer the Haskell do sugar to refutable patterns in let. Similar in
>>> spirit is the ? operator from Groovy, which I think is elegant and simple,
>>> it is an alternative to the . operator for field access/method call. In
>>> Rust it would have the following type and semantics:
>>>
>>> \Gamma e : Option<T'>
>>> fType(T', f) = T
>>> ------------------------------------
>>> \Gamma e?f : Option<T>
>>>
>>> e?f ~~> match e { Some<e> => Some<e.f>, None => None }
>>>
>>> and similarly for method call.
>>>
>>> The ? operator has the same advantages and disadvantages as Haskell's
>>> do, but is more concise.
>>>
>>> Just another alternative to consider.
>>>
>>>
>>> On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org>wrote:
>>>
>>>> We have some functions and methods such as [std::str::from_utf8](
>>>> http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that
>>>> may succeed and give a result, or fail when the input is invalid.
>>>>
>>>> 1. Sometimes we assume the input is valid and don?t want to deal with
>>>> the error case. Task failure works nicely.
>>>>
>>>> 2. Sometimes we do want to do something different on invalid input, so
>>>> returning an `Option<T>` works best.
>>>>
>>>> And so we end up with both `from_utf8` and `from_utf8`. This particular
>>>> case is worse because we also have `from_utf8_owned` and
>>>> `from_utf8_owned_opt`, to cover everything.
>>>>
>>>> Multiplying names like this is just not good design. I?d like to reduce
>>>> this pattern.
>>>>
>>>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on
>>>> the Option. I think we should rename every `foo_opt()` function or method
>>>> to just `foo`, remove the old `foo()` behavior, and tell people (through
>>>> documentation) to use `foo().unwrap()` if they want it back?
>>>>
>>>> The downsides are that unwrap is more verbose and gives less helpful
>>>> error messages on task failure. But I think it?s worth it.
>>>>
>>>> What do you think?
>>>>
>>>> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
>>>> this before sending pull requests with invasive API changes.)
>>>>
>>>> --
>>>> Simon Sapin
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140107/8579ca1a/attachment-0001.html>

From git at zimothy.com  Tue Jan  7 21:46:30 2014
From: git at zimothy.com (Timothy Jones)
Date: Wed, 8 Jan 2014 18:46:30 +1300
Subject: [rust-dev]
 =?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
 =?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
	<CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
	<CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>
Message-ID: <A7FA3BE3-66AC-4BD1-B6D1-FEFF25B58563@zimothy.com>

On 8/01/2014, at 3:39 pm, Nick Cameron <lists at ncameron.org> wrote:

> I think that you eventually have to deal with the Some or None-ness of an expression is an advantage of the ? operator, it means you can't ignore failure, but you don't have to deal with it at every step of a compound expression. Using an operator for unwrap has the same disadvantage as plain unwrap - it lets you ignore the failure case.

It's also worth pointing out that ? and do-notation solve different problems. ? is addressing that there's no partial application of the dot operator, so you can't write `maybe.and_then(.next)`. In do-notation, you'd still have to name the value inside the option.

You can produce a limited form of the refutable do-notation with a macro:

macro_rules! refute (
    (let $bind:pat = $val:expr; $(let $rbind:pat = $rval:expr);+; $result:expr) =>
    (match $val {
        $bind => refute!($(let $rbind = $rval);+; $result),
        fail => fail
    });
    (let $bind:pat = $val:expr; $result:expr) =>
    (match $val {
        $bind => $result,
        fail => fail
    });
)

fn add_opts(x: Option<int>, y: Option<int>) -> Option<int> {
    refute!(
        let Some(a) = x;
        let Some(b) = y;
        Some(a + b)
    )
}

Chaining the ? operator can't really be done in a tidy manner without having it be part of the language. `?.` has been really useful in CoffeeScript, and Rust has the advantage of being able to tie it into a trait and allow any relevant type to use it.

-- 
Tim

From carter.schonwald at gmail.com  Tue Jan  7 22:12:37 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Wed, 8 Jan 2014 01:12:37 -0500
Subject: [rust-dev]
	=?utf-8?q?Let=E2=80=99s_avoid_having_both_foo=28=29_an?=
	=?utf-8?b?ZCBmb29fb3B0KCk=?=
In-Reply-To: <CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
	<CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
Message-ID: <CAHYVw0yXH9zp2g+6J7jh4VKarRgeJcAOtcXjn+sOu+xm=+gpew@mail.gmail.com>

 I realized something. A good near term working solution could make use of
the pending procedural macros to make a nicer syntax for the and_then
procedures!

(or could the current syntax rules style macros work with that even?). Not
sure If i'll have the time to do that experiment,
but throwing the idea out there.




On Tuesday, January 7, 2014, Vadim wrote:

>  I can see how '?.' would work when foo() returns a struct, but what
> about non-struct types, e.g. Option<i32> ?   Also, you'd still have to deal
> with 'None' at the end of the chain.   I think in most cases I'd rather
> have it fail.
>
> I also don't really like refutable let-patterns proposal, because stuff
> like "let Some(x) = foo();" does not work with chaining when foo() returns
> a struct (and is still pretty wordy).
>
> Maybe we need an operator for "getting wrapped value"?   This would be
> similar to "deref" for [smart]pointers, except I think it should be a
> postfix operator to allow for easy chaining.   Let's say we chose '^' for
> this purpose, and implemented its' trait for Option, Result, etc.  Then one
> could write:
>     let x = foo()^;
> or
>     let y = foo()^.field;
>
> Vadim
>
>
>
> On Tue, Jan 7, 2014 at 11:30 AM, Nick Cameron <lists at ncameron.org> wrote:
>
>> I agree with Simon that doubling the API is inelegant. I think the
>> solution is adding sugar to make working with Option/Result easier -
>> (semi-)independent of the foo/foo_opt issue, I find working with Option
>> pretty painful.
>>
>> I prefer the Haskell do sugar to refutable patterns in let. Similar in
>> spirit is the ? operator from Groovy, which I think is elegant and simple,
>> it is an alternative to the . operator for field access/method call. In
>> Rust it would have the following type and semantics:
>>
>> \Gamma e : Option<T'>
>> fType(T', f) = T
>> ------------------------------------
>> \Gamma e?f : Option<T>
>>
>> e?f ~~> match e { Some<e> => Some<e.f>, None => None }
>>
>> and similarly for method call.
>>
>> The ? operator has the same advantages and disadvantages as Haskell's do,
>> but is more concise.
>>
>> Just another alternative to consider.
>>
>>
>> On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org> wrote:
>>
>>> We have some functions and methods such as [std::str::from_utf8](http://
>>> static.rust-lang.org/doc/master/std/str/fn.from_utf8.html) that may
>>> succeed and give a result, or fail when the input is invalid.
>>>
>>> 1. Sometimes we assume the input is valid and don?t want to deal with
>>> the error case. Task failure works nicely.
>>>
>>> 2. Sometimes we do want to do something different on invalid input, so
>>> returning an `Option<T>` works best.
>>>
>>> And so we end up with both `from_utf8` and `from_utf8`. This particular
>>> case is worse because we also have `from_utf8_owned` and
>>> `from_utf8_owned_opt`, to cover everything.
>>>
>>> Multiplying names like this is just not good design. I?d like to reduce
>>> this pattern.
>>>
>>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on
>>> the Option. I think we should rename every `foo_opt()` function or method
>>> to just `foo`, remove the old `foo()` behavior, and tell people (through
>>> documentation) to use `foo().unwrap()` if they want it back?
>>>
>>> The downsides are that unwrap is more verbose and gives less helpful
>>> error messages on task failure. But I think it?s worth it.
>>>
>>> What do you think?
>>>
>>> (PS: I?m guilty of making this worse in #10828, but I?d like to discuss
>>> this before sending pull requests with invasive API changes.)
>>>
>>> --
>>> Simon Sapin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/98b47f59/attachment.html>

From lists at ncameron.org  Tue Jan  7 22:37:33 2014
From: lists at ncameron.org (Nick Cameron)
Date: Wed, 8 Jan 2014 19:37:33 +1300
Subject: [rust-dev]
	=?windows-1252?q?Let=92s_avoid_having_both_foo=28=29_a?=
	=?windows-1252?q?nd_foo=5Fopt=28=29?=
In-Reply-To: <CADecdiLC9TuDNedJSSXS3S2SM=RCiPS1uxqW9HgUwV2beeokxA@mail.gmail.com>
References: <52A23660.5040500@exyr.org>
	<CAA5tgF3rtO1xBLD3ZzbRkuQX8sY2kA6u7b=pLyj6T-GHrvufdA@mail.gmail.com>
	<CADecdiKU_Lah4LgBf5b9M0tStRsk=eya8N4n_c4a_h3KZRx75g@mail.gmail.com>
	<CAA5tgF2CMCjf4dciAQPzq9XrJgqiw1KreLMy41_igoS7C8g_yg@mail.gmail.com>
	<CADecdiLC9TuDNedJSSXS3S2SM=RCiPS1uxqW9HgUwV2beeokxA@mail.gmail.com>
Message-ID: <CAA5tgF3QQDR6JUzbAhbhtz8tQATAhrbfkiPOffTr4xM8=XXmxw@mail.gmail.com>

Sorry, I didn't mean ignore errors as in unsafe, I meant that it allows the
programmer to write code without having the error case be explicit. This is
the (well, one of the) problems with null pointers in C and Java.

You make a good point about errors from the API, and I guess this
highlights a worthwhile difference between expected None (e.g., a fn which
returns the age of a user, but the user could leave the field unspecified)
and an exceptional None (the same method fails to connect to the database).
It is perhaps worth having different mechanisms to deal with the two cases.


Cheers, Nick


On Wed, Jan 8, 2014 at 4:31 PM, Vadim <vadimcn at gmail.com> wrote:

> On Tue, Jan 7, 2014 at 6:39 PM, Nick Cameron <lists at ncameron.org> wrote:
>
>> I think that you eventually have to deal with the Some or None-ness of an
>> expression is an advantage of the ? operator, it means you can't ignore
>> failure, but you don't have to deal with it at every step of a compound
>> expression. Using an operator for unwrap has the same disadvantage as plain
>> unwrap - it lets you ignore the failure case.
>>
>
> First of all, it does not let me ignore errors - if I try to unwrap() a
> None, it will kill my program (or at least the current task).   Whether
> this is what I want, depends on the use case.   In my experience, more
> often than not, an error returned by an API represents a bug in the
> program.  So what am I gonna do when I see that something has error'ed
> out?  I will probably just call fail!().
>
> Anyways, I think this thread was about how to avoid having both foo() and
> foo_opt() versions of every API, and many people (including myself),
> consider unwrap() too noisy.  So...
>
> Vadim
>
>
>
>>
>> On Wed, Jan 8, 2014 at 1:42 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>>> I can see how '?.' would work when foo() returns a struct, but what
>>> about non-struct types, e.g. Option<i32> ?   Also, you'd still have to deal
>>> with 'None' at the end of the chain.   I think in most cases I'd rather
>>> have it fail.
>>>
>>> I also don't really like refutable let-patterns proposal, because stuff
>>> like "let Some(x) = foo();" does not work with chaining when foo() returns
>>> a struct (and is still pretty wordy).
>>>
>>> Maybe we need an operator for "getting wrapped value"?   This would be
>>> similar to "deref" for [smart]pointers, except I think it should be a
>>> postfix operator to allow for easy chaining.   Let's say we chose '^' for
>>> this purpose, and implemented its' trait for Option, Result, etc.  Then one
>>> could write:
>>>     let x = foo()^;
>>> or
>>>     let y = foo()^.field;
>>>
>>> Vadim
>>>
>>>
>>>
>>> On Tue, Jan 7, 2014 at 11:30 AM, Nick Cameron <lists at ncameron.org>wrote:
>>>
>>>> I agree with Simon that doubling the API is inelegant. I think the
>>>> solution is adding sugar to make working with Option/Result easier -
>>>> (semi-)independent of the foo/foo_opt issue, I find working with Option
>>>> pretty painful.
>>>>
>>>> I prefer the Haskell do sugar to refutable patterns in let. Similar in
>>>> spirit is the ? operator from Groovy, which I think is elegant and simple,
>>>> it is an alternative to the . operator for field access/method call. In
>>>> Rust it would have the following type and semantics:
>>>>
>>>> \Gamma e : Option<T'>
>>>> fType(T', f) = T
>>>> ------------------------------------
>>>> \Gamma e?f : Option<T>
>>>>
>>>> e?f ~~> match e { Some<e> => Some<e.f>, None => None }
>>>>
>>>> and similarly for method call.
>>>>
>>>> The ? operator has the same advantages and disadvantages as Haskell's
>>>> do, but is more concise.
>>>>
>>>> Just another alternative to consider.
>>>>
>>>>
>>>> On Sat, Dec 7, 2013 at 9:41 AM, Simon Sapin <simon.sapin at exyr.org>wrote:
>>>>
>>>>> We have some functions and methods such as [std::str::from_utf8](
>>>>> http://static.rust-lang.org/doc/master/std/str/fn.from_utf8.html)
>>>>> that may succeed and give a result, or fail when the input is invalid.
>>>>>
>>>>> 1. Sometimes we assume the input is valid and don?t want to deal with
>>>>> the error case. Task failure works nicely.
>>>>>
>>>>> 2. Sometimes we do want to do something different on invalid input, so
>>>>> returning an `Option<T>` works best.
>>>>>
>>>>> And so we end up with both `from_utf8` and `from_utf8`. This
>>>>> particular case is worse because we also have `from_utf8_owned` and
>>>>> `from_utf8_owned_opt`, to cover everything.
>>>>>
>>>>> Multiplying names like this is just not good design. I?d like to
>>>>> reduce this pattern.
>>>>>
>>>>> Getting behavior 1. when you have 2. is easy: just call `.unwrap()` on
>>>>> the Option. I think we should rename every `foo_opt()` function or method
>>>>> to just `foo`, remove the old `foo()` behavior, and tell people (through
>>>>> documentation) to use `foo().unwrap()` if they want it back?
>>>>>
>>>>> The downsides are that unwrap is more verbose and gives less helpful
>>>>> error messages on task failure. But I think it?s worth it.
>>>>>
>>>>> What do you think?
>>>>>
>>>>> (PS: I?m guilty of making this worse in #10828, but I?d like to
>>>>> discuss this before sending pull requests with invasive API changes.)
>>>>>
>>>>> --
>>>>> Simon Sapin
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/a791dd73/attachment-0001.html>

From erick.tryzelaar at gmail.com  Wed Jan  8 07:58:42 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Wed, 8 Jan 2014 07:58:42 -0800
Subject: [rust-dev] 1/28 Bay Area Rust meetup: Rust 0.9 and DST
Message-ID: <CALdfqQJ9=NZD0V_sKOfGN+7ZeUOq=SSHy3tgtV9WwwUZ01U4Bg@mail.gmail.com>

Hello Rusticians!

I'm happy to announce the next Bay Area Rust meetup on 1/28! You can sign
up for it here:

http://www.meetup.com/Rust-Bay-Area/events/153909222/

On January 28 at 7:00pm at Mozilla SF, we have 4 great presenters lined up:

Presenters:

? Brian Anderson: Will present about the soon-to-be-released Rust 0.9.

? Niko Matsakis: Will present his current plans for the long awaited
Dynamically Sized Types, or DST.

? Kevin Ballard: Will present his safe Lua bindings:
https://github.com/kballard/rust-lua

? Corey Richardson: Will present remotely on something yet-to-be-determined.

This event will be catered and filmed by Air Mozilla if you cannot attend.

*Location*

This event will be held at the Mozilla San Francisco headquarters, at 2
Harrison St, San Francisco, CA 94105. Look for the building with the big
"Hills Coffee" sign on the roof.

Please sign in to the visitor log at the first floor reception desk when
you arrive.


I hope you can make it!
-Erick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/9dd90d05/attachment.html>

From marcianx at gmail.com  Wed Jan  8 19:08:02 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Wed, 8 Jan 2014 22:08:02 -0500
Subject: [rust-dev]  What type to put for index when impl-ing Index?
Message-ID: <CAEsTQVOzHVcRfRNm3BEihwNvxV+Co1JtT4Ex5N6erOr9XJbTmw@mail.gmail.com>

The following implementation of Index for Foo works fine.

struct Foo([f64, ..3]);
impl Index<uint, f64> for Foo {
    fn index(&self, index: &uint) -> f64 {
        match self {
            &Foo(ref v) => v[*index].clone()
        }
    }
}
fn main() {
    let tmp : uint = 0;
    let foo = Foo([1.0, 2.0, 3.0]);
    println!("{:?}", foo[tmp]);
}

But if tmp is of type int, then I get an int-uint type mismatch failure. So
I tried the following.

use std::num::Int;
...
impl<Idx : Int> Index<Idx, f64> for Foo {
    fn index(&self, index: &Idx) -> f64 {
        match self {
            &Foo(ref v) => v[*index].clone()
        }
    }
}

But I get
    error: mismatched types: expected integral type but found `Idx`
with the error pointing at *index above.  What's the right way to go about
implementing generic operator indexing?  Or does one always require
conversion to uint (in the first case above) on the caller's side?

Ashish
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/a3ff41ad/attachment.html>

From bjzaba at yahoo.com.au  Wed Jan  8 20:21:40 2014
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 9 Jan 2014 15:21:40 +1100
Subject: [rust-dev] What type to put for index when impl-ing Index?
In-Reply-To: <CAEsTQVOzHVcRfRNm3BEihwNvxV+Co1JtT4Ex5N6erOr9XJbTmw@mail.gmail.com>
References: <CAEsTQVOzHVcRfRNm3BEihwNvxV+Co1JtT4Ex5N6erOr9XJbTmw@mail.gmail.com>
Message-ID: <5684E882-6D8F-485D-A660-30DDBADB0B13@yahoo.com.au>

struct Foo([f64, ..3]);

impl<I: Int> Index<I, f64> for Foo {
    fn index(&self, index: &I) -> f64 {
        let index = index.to_uint().unwrap();
        match self {
            &Foo(ref v) => v[index].clone()
        }
    }
}

fn main() {
    let tmp : uint = 0;
    let foo = Foo([1.0, 2.0, 3.0]);
    println!("{:?}", foo[tmp]);
}

On 9 Jan 2014, at 2:08 pm, Ashish Myles <marcianx at gmail.com> wrote:

> The following implementation of Index for Foo works fine.
> 
> struct Foo([f64, ..3]);
> impl Index<uint, f64> for Foo {
>     fn index(&self, index: &uint) -> f64 {
>         match self {
>             &Foo(ref v) => v[*index].clone()
>         }
>     }
> }
> fn main() {
>     let tmp : uint = 0;
>     let foo = Foo([1.0, 2.0, 3.0]);
>     println!("{:?}", foo[tmp]);
> }
> 
> But if tmp is of type int, then I get an int-uint type mismatch failure. So I tried the following.
> 
> use std::num::Int;
> ...
> impl<Idx : Int> Index<Idx, f64> for Foo {
>     fn index(&self, index: &Idx) -> f64 {
>         match self {
>             &Foo(ref v) => v[*index].clone()
>         }
>     }
> }
> 
> But I get
>     error: mismatched types: expected integral type but found `Idx`
> with the error pointing at *index above.  What's the right way to go about implementing generic operator indexing?  Or does one always require conversion to uint (in the first case above) on the caller's side?
> 
> Ashish
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From marcianx at gmail.com  Wed Jan  8 20:43:42 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Wed, 8 Jan 2014 23:43:42 -0500
Subject: [rust-dev] What type to put for index when impl-ing Index?
In-Reply-To: <5684E882-6D8F-485D-A660-30DDBADB0B13@yahoo.com.au>
References: <CAEsTQVOzHVcRfRNm3BEihwNvxV+Co1JtT4Ex5N6erOr9XJbTmw@mail.gmail.com>
	<5684E882-6D8F-485D-A660-30DDBADB0B13@yahoo.com.au>
Message-ID: <CAEsTQVNeOLK+Sa8dXFZ8x_dsdmeHGCoZ-fY2h3CwiNEG+=0aKQ@mail.gmail.com>

That'll do it, thanks! :)

Here's to hoping that the compiler is smart enough to remove the
bounds-checks and the None pathway for when I is one of the unsigned
integer primitives.

Ashish


On Wed, Jan 8, 2014 at 11:21 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:

> struct Foo([f64, ..3]);
>
> impl<I: Int> Index<I, f64> for Foo {
>     fn index(&self, index: &I) -> f64 {
>         let index = index.to_uint().unwrap();
>         match self {
>             &Foo(ref v) => v[index].clone()
>         }
>     }
> }
>
> fn main() {
>     let tmp : uint = 0;
>     let foo = Foo([1.0, 2.0, 3.0]);
>     println!("{:?}", foo[tmp]);
> }
>
> On 9 Jan 2014, at 2:08 pm, Ashish Myles <marcianx at gmail.com> wrote:
>
> > The following implementation of Index for Foo works fine.
> >
> > struct Foo([f64, ..3]);
> > impl Index<uint, f64> for Foo {
> >     fn index(&self, index: &uint) -> f64 {
> >         match self {
> >             &Foo(ref v) => v[*index].clone()
> >         }
> >     }
> > }
> > fn main() {
> >     let tmp : uint = 0;
> >     let foo = Foo([1.0, 2.0, 3.0]);
> >     println!("{:?}", foo[tmp]);
> > }
> >
> > But if tmp is of type int, then I get an int-uint type mismatch failure.
> So I tried the following.
> >
> > use std::num::Int;
> > ...
> > impl<Idx : Int> Index<Idx, f64> for Foo {
> >     fn index(&self, index: &Idx) -> f64 {
> >         match self {
> >             &Foo(ref v) => v[*index].clone()
> >         }
> >     }
> > }
> >
> > But I get
> >     error: mismatched types: expected integral type but found `Idx`
> > with the error pointing at *index above.  What's the right way to go
> about implementing generic operator indexing?  Or does one always require
> conversion to uint (in the first case above) on the caller's side?
> >
> > Ashish
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140108/ab304b32/attachment.html>

From banderson at mozilla.com  Wed Jan  8 22:39:26 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 08 Jan 2014 22:39:26 -0800
Subject: [rust-dev] 0.9 prerelease testing
Message-ID: <52CE441E.7040208@mozilla.com>

Hey there, Rusticians!

We've got a little 0.9 release candidate here. I've given it the most 
cursory test, but if you have the inclination go ahead and install these 
on your system of choice and see how it fares. These days we generally 
claim to support Mac OS X 10.6+, Windows 7 and 2008 RC2, a variety of 
Linuxes, and Android, but the intrepid may have luck on other platforms 
as well. If things go reasonably well with this RC then we'll sign and 
tag and release it to the world tomorrow.

commit: 7613b15fdbbb9bf770a2c731f4135886b0ff3cf0
http://static.rust-lang.org/dist/rust-0.9.tar.gz
c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1 
rust-0.9.tar.gz
http://static.rust-lang.org/dist/rust-0.9-install.exe
6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90 
rust-0.9-install.exe

This is going to be the best release yet!

Regards,
Brian

From jack at metajack.im  Wed Jan  8 22:53:30 2014
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 8 Jan 2014 23:53:30 -0700
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <52CE441E.7040208@mozilla.com>
References: <52CE441E.7040208@mozilla.com>
Message-ID: <CAP7VpsXz-_D5qmx4mFHKSdCmbMe0zJ2hJw5UJocdpDv-7ksrXw@mail.gmail.com>

> We've got a little 0.9 release candidate here. I've given it the most
> cursory test, but if you have the inclination go ahead and install these on
> your system of choice and see how it fares. These days we generally claim to
> support Mac OS X 10.6+, Windows 7 and 2008 RC2, a variety of Linuxes, and
> Android, but the intrepid may have luck on other platforms as well. If
> things go reasonably well with this RC then we'll sign and tag and release
> it to the world tomorrow.

Servo is moving almost to this version and it's been working pretty
well even with lightly mixed native and green tasks. Debugging in
particular seems much improved (except on OS X 10.9 where Apple has
removed gdb).

Some of my favorite things from 0.9 are the dead code warnings and the
almost total removal of the option dance. Servo's code gets a little
cleaner every time we move Rust forward.

Happy testing!
jack.

From j.boggiano at seld.be  Thu Jan  9 03:06:45 2014
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Thu, 09 Jan 2014 12:06:45 +0100
Subject: [rust-dev] 1/28 Bay Area Rust meetup: Rust 0.9 and DST
In-Reply-To: <CALdfqQJ9=NZD0V_sKOfGN+7ZeUOq=SSHy3tgtV9WwwUZ01U4Bg@mail.gmail.com>
References: <CALdfqQJ9=NZD0V_sKOfGN+7ZeUOq=SSHy3tgtV9WwwUZ01U4Bg@mail.gmail.com>
Message-ID: <52CE82C5.8030509@seld.be>

On 08/01/2014 16:58, Erick Tryzelaar wrote:
> Hello Rusticians!
>
> I'm happy to announce the next Bay Area Rust meetup on 1/28! You can
> sign up for it here:
>
> http://www.meetup.com/Rust-Bay-Area/events/153909222/

If possible it'd be awesome to post recordings here after the meetup, 
for those that can't physically make it.

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From a.stavonin at gmail.com  Thu Jan  9 04:04:12 2014
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Thu, 9 Jan 2014 16:04:12 +0400
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <CAP7VpsXz-_D5qmx4mFHKSdCmbMe0zJ2hJw5UJocdpDv-7ksrXw@mail.gmail.com>
References: <52CE441E.7040208@mozilla.com>
	<CAP7VpsXz-_D5qmx4mFHKSdCmbMe0zJ2hJw5UJocdpDv-7ksrXw@mail.gmail.com>
Message-ID: <CAErP+amDF6__W6=SK+O=4kfVEzdfzmtADL3WguDCXemTHYoXMQ@mail.gmail.com>

FYI. Apple doesn't remove GDB in 10.9. They has removed symlink for it So,
you can find GDB in
/Applications/Xcode.app/Contents/Developer/usr/libexec/gdb/gdb-i386-apple-darwin
and create symlink manually.

Best,
Alex


2014/1/9 Jack Moffitt <jack at metajack.im>

> > We've got a little 0.9 release candidate here. I've given it the most
> > cursory test, but if you have the inclination go ahead and install these
> on
> > your system of choice and see how it fares. These days we generally
> claim to
> > support Mac OS X 10.6+, Windows 7 and 2008 RC2, a variety of Linuxes, and
> > Android, but the intrepid may have luck on other platforms as well. If
> > things go reasonably well with this RC then we'll sign and tag and
> release
> > it to the world tomorrow.
>
> Servo is moving almost to this version and it's been working pretty
> well even with lightly mixed native and green tasks. Debugging in
> particular seems much improved (except on OS X 10.9 where Apple has
> removed gdb).
>
> Some of my favorite things from 0.9 are the dead code warnings and the
> almost total removal of the option dance. Servo's code gets a little
> cleaner every time we move Rust forward.
>
> Happy testing!
> jack.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/601612cd/attachment-0001.html>

From erick.tryzelaar at gmail.com  Thu Jan  9 06:37:55 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 9 Jan 2014 06:37:55 -0800
Subject: [rust-dev] 1/28 Bay Area Rust meetup: Rust 0.9 and DST
In-Reply-To: <52CE82C5.8030509@seld.be>
References: <CALdfqQJ9=NZD0V_sKOfGN+7ZeUOq=SSHy3tgtV9WwwUZ01U4Bg@mail.gmail.com>
	<52CE82C5.8030509@seld.be>
Message-ID: <CALdfqQLH_20m1V00SzycMMipPPabu8+g=zCwzJzcw44i7_iWAQ@mail.gmail.com>

You are in luck. They all are posted on air.mozilla.org. You can find all
the other meetup presentations here:

https://air.mozilla.org/search/?q=Rust

On Thursday, January 9, 2014, Jordi Boggiano wrote:

> On 08/01/2014 16:58, Erick Tryzelaar wrote:
>
>> Hello Rusticians!
>>
>> I'm happy to announce the next Bay Area Rust meetup on 1/28! You can
>> sign up for it here:
>>
>> http://www.meetup.com/Rust-Bay-Area/events/153909222/
>>
>
> If possible it'd be awesome to post recordings here after the meetup, for
> those that can't physically make it.
>
> Cheers
>
> --
> Jordi Boggiano
> @seldaek - http://nelm.io/jordi
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/2fe31682/attachment.html>

From kevin at sb.org  Thu Jan  9 09:58:10 2014
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 9 Jan 2014 09:58:10 -0800
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <CAErP+amDF6__W6=SK+O=4kfVEzdfzmtADL3WguDCXemTHYoXMQ@mail.gmail.com>
References: <52CE441E.7040208@mozilla.com>
	<CAP7VpsXz-_D5qmx4mFHKSdCmbMe0zJ2hJw5UJocdpDv-7ksrXw@mail.gmail.com>
	<CAErP+amDF6__W6=SK+O=4kfVEzdfzmtADL3WguDCXemTHYoXMQ@mail.gmail.com>
Message-ID: <72F3941D-6691-4A17-BF74-2DCCB0491947@sb.org>

That path does not exist in Xcode 5.0 or Xcode 5.1 DP3. Are you sure you aren't looking at an older Xcode (say, Xcode 4.6)?

-Kevin

On Jan 9, 2014, at 4:04 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:

> FYI. Apple doesn't remove GDB in 10.9. They has removed symlink for it So, you can find GDB in /Applications/Xcode.app/Contents/Developer/usr/libexec/gdb/gdb-i386-apple-darwin and create symlink manually.
> 
> Best,
> Alex
> 
> 
> 2014/1/9 Jack Moffitt <jack at metajack.im>
> > We've got a little 0.9 release candidate here. I've given it the most
> > cursory test, but if you have the inclination go ahead and install these on
> > your system of choice and see how it fares. These days we generally claim to
> > support Mac OS X 10.6+, Windows 7 and 2008 RC2, a variety of Linuxes, and
> > Android, but the intrepid may have luck on other platforms as well. If
> > things go reasonably well with this RC then we'll sign and tag and release
> > it to the world tomorrow.
> 
> Servo is moving almost to this version and it's been working pretty
> well even with lightly mixed native and green tasks. Debugging in
> particular seems much improved (except on OS X 10.9 where Apple has
> removed gdb).
> 
> Some of my favorite things from 0.9 are the dead code warnings and the
> almost total removal of the option dance. Servo's code gets a little
> cleaner every time we move Rust forward.
> 
> Happy testing!
> jack.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/019e73d8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/019e73d8/attachment.p7s>

From a.stavonin at gmail.com  Thu Jan  9 11:00:48 2014
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Thu, 9 Jan 2014 23:00:48 +0400
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <72F3941D-6691-4A17-BF74-2DCCB0491947@sb.org>
References: <52CE441E.7040208@mozilla.com>
	<CAP7VpsXz-_D5qmx4mFHKSdCmbMe0zJ2hJw5UJocdpDv-7ksrXw@mail.gmail.com>
	<CAErP+amDF6__W6=SK+O=4kfVEzdfzmtADL3WguDCXemTHYoXMQ@mail.gmail.com>
	<72F3941D-6691-4A17-BF74-2DCCB0491947@sb.org>
Message-ID: <CE5CF30A-8E58-4556-BAF1-63C4A5389CED@gmail.com>

Very strange. I?ve checked the folder on my personal notebook and yes, there is not gdb. Looks like I was wrong.

Best regards,
Alexander



On 09 Jan 2014, at 21:58, Kevin Ballard <kevin at sb.org> wrote:

> That path does not exist in Xcode 5.0 or Xcode 5.1 DP3. Are you sure you aren't looking at an older Xcode (say, Xcode 4.6)?
> 
> -Kevin
> 
> On Jan 9, 2014, at 4:04 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:
> 
>> FYI. Apple doesn't remove GDB in 10.9. They has removed symlink for it So, you can find GDB in /Applications/Xcode.app/Contents/Developer/usr/libexec/gdb/gdb-i386-apple-darwin and create symlink manually.
>> 
>> Best,
>> Alex
>> 
>> 
>> 2014/1/9 Jack Moffitt <jack at metajack.im>
>> > We've got a little 0.9 release candidate here. I've given it the most
>> > cursory test, but if you have the inclination go ahead and install these on
>> > your system of choice and see how it fares. These days we generally claim to
>> > support Mac OS X 10.6+, Windows 7 and 2008 RC2, a variety of Linuxes, and
>> > Android, but the intrepid may have luck on other platforms as well. If
>> > things go reasonably well with this RC then we'll sign and tag and release
>> > it to the world tomorrow.
>> 
>> Servo is moving almost to this version and it's been working pretty
>> well even with lightly mixed native and green tasks. Debugging in
>> particular seems much improved (except on OS X 10.9 where Apple has
>> removed gdb).
>> 
>> Some of my favorite things from 0.9 are the dead code warnings and the
>> almost total removal of the option dance. Servo's code gets a little
>> cleaner every time we move Rust forward.
>> 
>> Happy testing!
>> jack.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/df9d1904/attachment.html>

From banderson at mozilla.com  Thu Jan  9 12:59:21 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 12:59:21 -0800
Subject: [rust-dev] Rust 0.8 released
Message-ID: <52CF0DA9.70309@mozilla.com>

Mozilla and the Rust community are pleased to announce version 0.9 of the
Rust compiler and tools. Rust is a systems programming language with a
focus on safety, performance and concurrency.

This was another eventful release in which we made extensive improvements
to the runtime and I/O subsystem, introduced static linking and link-time
optimization, and reduced the variety of closures in the language. 0.9 also
begins a final series of planned changes to how pointers are treated in
Rust, starting with the deprecation of the built-in "managed pointer" type
and its accompanying `@` sigil, and the introduction of smart pointer types
to the standard library.

The brief release notes are included in this announcement, and there is
further explanation in the detailed release [notes] on the wiki.
Documentation and all the links in this email are available on the
[website]. As usual, version 0.9 should be considered an alpha release,
suitable for early adopters and language enthusiasts. Please file [bugs]
and join the [fun].

[website]: http://www.rust-lang.org
[notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
[bugs]: https://github.com/mozilla/rust/issues
[fun]: https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors

This release is available as both a tarball and a Windows installer:

* http://static.rust-lang.org/dist/rust-0.9.tar.gz
http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
SHA256 (of .tar.gz):
c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1

* http://static.rust-lang.org/dist/rust-0.9-install.exe
http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
SHA256 (of .exe):
6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90

Thanks to everyone who contributed!

Regards,
The Rust Team


Version 0.9 (January 2014)
--------------------------

* Language
* The `float` type has been removed. Use `f32` or `f64` instead.
* A new facility for enabling experimental features (feature gating)
has been added, using the crate-level `#[feature(foo)]` attribute.
* Managed boxes (@) are now behind a feature gate
(`#[feature(managed_boxes)]`) in preperation for future removal. Use
the standard library's `Gc` or `Rc` types instead.
* `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
* Jumping back to the top of a loop is now done with `continue` instead
of `loop`.
* Strings can no longer be mutated through index assignment.
* Raw strings can be created via the basic `r"foo"` syntax or with
matched hash delimiters, as in `r###"foo"###`.
* `~fn` is now written `proc (args) -> retval { ... }` and may only be
called once.
* The `&fn` type is now written `|args| -> ret` to match the literal
form.
* `@fn`s have been removed.
* `do` only works with procs in order to make it obvious what the cost
of `do` is.
* Single-element tuple-like structs can no longer be dereferenced to
obtain the inner value. A more comprehensive solution for overloading
the dereference operator will be provided in the future.
* The `#[link(...)]` attribute has been replaced with
`#[crate_id = "name#vers"]`.
* Empty `impl`s must be terminated with empty braces and may not be
terminated with a semicolon.
* Keywords are no longer allowed as lifetime names; the `self` lifetime
no longer has any special meaning.
* The old `fmt!` string formatting macro has been removed.
* `printf!` and `printfln!` (old-style formatting) removed in favor of
`print!` and `println!`.
* `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
* The `extern mod foo (name = "bar")` syntax has been removed. Use
`extern mod foo = "bar"` instead.
* New reserved keywords: `alignof`, `offsetof`, `sizeof`.
* Macros can have attributes.
* Macros can expand to items with attributes.
* Macros can expand to multiple items.
* The `asm!` macro is feature-gated (`#[feature(asm)]`).
* Comments may be nested.
* Values automatically coerce to trait objects they implement, without
an explicit `as`.
* Enum discriminants are no longer an entire word but as small as needed
to contain all the variants. The `repr` attribute can be used to
override the discriminant size, as in `#[repr(int)]` for integer-sized,
and `#[repr(C)]` to match C enums.
* Non-string literals are not allowed in attributes (they never worked).
* The FFI now supports variadic functions.
* Octal numeric literals, as in `0o7777`.
* The `concat!` syntax extension performs compile-time string
concatenation.
* The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
removed as Rust no longer uses segmented stacks.
* Non-ascii identifiers are feature-gated
(`#[feature(non_ascii_idents)]`).
* Ignoring all fields of an enum variant or tuple-struct is done with
`..`, not `*`; ignoring remaining fields of a struct is also done
with `..`, not `_`; ignoring a slice of a vector is done with `..`,
not `.._`.
* `rustc` supports the "win64" calling convention via `extern "win64"`.
* `rustc` supports the "system" calling convention, which defaults to
the preferred convention for the target platform, "stdcall" on 32-bit
Windows, "C" elsewhere.
* The `type_overflow` lint (default: warn) checks literals for overflow.
* The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
* The `attribute_usage` lint (default: warn) warns about unknown
attributes.
* The `unknown_features` lint (default: warn) warns about unknown
feature gates.
* The `dead_code` lint (default: warn) checks for dead code.
* Rust libraries can be linked statically to one another
* `#[link_args]` is behind the `link_args` feature gate.
* Native libraries are now linked with `#[link(name = "foo")]`
* Native libraries can be statically linked to a rust crate
(`#[link(name = "foo", kind = "static")]`).
* Native OS X frameworks are now officially supported
(`#[link(name = "foo", kind = "framework")]`).
* The `#[thread_local]` attribute creates thread-local (not task-local)
variables. Currently behind the `thread_local` feature gate.
* The `return` keyword may be used in closures.
* Types that can be copied via a memcpy implement the `Pod` kind.
* The `cfg` attribute can now be used on struct fields and enum variants.

* Libraries
* std: The `option` and `result` API's have been overhauled to make them
simpler, more consistent, and more composable.
* std: The entire `std::io` module has been replaced with one that is
more comprehensive and that properly interfaces with the underlying
scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
implemented.
* std: `io::util` contains a number of useful implementations of
`Reader` and `Writer`, including `NullReader`, `NullWriter`,
`ZeroReader`, `TeeReader`.
* std: The reference counted pointer type `extra::rc` moved into std.
* std: The `Gc` type in the `gc` module will replace `@` (it is currently
just a wrapper around it).
* std: The `Either` type has been removed.
* std: `fmt::Default` can be implemented for any type to provide default
formatting to the `format!` macro, as in `format!("{}", myfoo)`.
* std: The `rand` API continues to be tweaked.
* std: The `rust_begin_unwind` function, useful for inserting
breakpoints on failure in gdb, is now named `rust_fail`.
* std: The `each_key` and `each_value` methods on `HashMap` have been
replaced by the `keys` and `values` iterators.
* std: Functions dealing with type size and alignment have moved from
the `sys` module to the `mem` module.
* std: The `path` module was written and API changed.
* std: `str::from_utf8` has been changed to cast instead of allocate.
* std: `starts_with` and `ends_with` methods added to vectors via the
`ImmutableEqVector` trait, which is in the prelude.
* std: Vectors can be indexed with the `get_opt` method, which returns
`None` if the index is out of bounds.
* std: Task failure no longer propagates between tasks, as the model
was complex, expensive, and incompatible with thread-based tasks.
* std: The `Any` type can be used for dynamic typing.
* std: `~Any` can be passed to the `fail!` macro and retrieved via
`task::try`.
* std: Methods that produce iterators generally do not have an `_iter`
suffix now.
* std: `cell::Cell` and `cell::RefCell` can be used to introduc
mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
* std: `util::ignore` renamed to `prelude::drop`.
* std: Slices have `sort` and `sort_by` methods via the `MutableVector`
trait.
* std: `vec::raw` has seen a lot of cleanup and API changes.
* std: The standard library no longer includes any C++ code, and very
minimal C, eliminating the dependency on libstdc++.
* std: Runtime scheduling and I/O functionality has been factored out
into extensible interfaces and is now implemented by two different
crates: libnative, for native threading and I/O; and libgreen, for
green threading and I/O. This paves the way for using the standard
library in more limited embeded environments.
* std: The `comm` module has been rewritten to be much faster, have a
simpler, more consistent API, and to work for both native and green
threading.
* std: All libuv dependencies have been moved into the rustuv crate.
* native: New implementations of runtime scheduling on top of OS
threads.
* native: New native implementations of TCP, UDP, file I/O, process
spawning, and other I/O.
* green: The green thread scheduler and message passing types are
almost entirely lock-free.
* extra: The `flatpipes` module had bitrotted and was removed.
* extra: All crypto functions have been removed and Rust now has a
policy of not reimplementing crypto in the standard library. In the
future crypto will be provided by external crates with bindings to
established libraries.
* extra: `c_vec` has been modernized.
* extra: The `sort` module has been removed. Use the `sort` method on
mutable slices.

* Tooling
* The `rust` and `rusti` commands have been removed, due to lack of
maintenance.
* `rustdoc` was completely rewritten.
* `rustdoc` can test code examples in documentation.
* `rustpkg` can test packages with the argument, 'test'.
* `rustpkg` supports arbitrary dependencies, including C libraries.
* `rustc`'s support for generating debug info is improved again.
* `rustc` has better error reporting for unbalanced delimiters.
* `rustc`'s JIT support was removed due to bitrot.
* Executables and static libraries can be built with LTO (-Z lto)
* `rustc` adds a `--dep-info` flag for communicating dependencies to
build tools.


Contributors to Rust 0.9
------------------------

Adrien T?tar <adri-from-59 at hotmail.fr>
Alan Andrade <alan.andradec at gmail.com>
Alexandros Tasos <sdi1100085 at di.uoa.gr>
Alex Crichton <alex at alexcrichton.com>
a_m0d <damien.schoof at gmail.com>
Andreas Neuhaus <zargony at zargony.com>
Andreas Ots <andreasots at gmail.com>
Andrei Formiga <archimedes_siracusa at hotmail.com>
Benjamin Herr <ben at 0x539.de>
Benjamin Peterson <benjamin at python.org>
Birunthan Mohanathas <birunthan at mohanathas.com>
blake2-ppc <blake2-ppc>
Branimir <branimir at volomp.com>
Brendan Zabarauskas <bjzaba at yahoo.com.au>
Brian Anderson <banderson at mozilla.com>
Brian <brian.t.dawn at gmail.com>
Cadence Marseille <cadencemarseille at gmail.com>
Carl-Anton Ingmarsson <mail at carlanton.se>
Carol Willing <carolcode at willingconsulting.com>
Carter Tazio Schonwald <carter.schonwald at gmail.com>
chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
Chris Morgan <me at chrismorgan.info>
Chris Sainty <csainty at hotmail.com>
Corey Richardson <corey at octayn.net>
Dan Connolly <dckc at madmode.com>
Daniel Micay <danielmicay at gmail.com>
Dan Luu <danluu at gmail.com>
Dave Hodder <dmh at dmh.org.uk>
David Creswick <dcrewi at gyrae.net>
David Renshaw <dwrenshaw at gmail.com>
Diego Ongaro <ongaro at cs.stanford.edu>
Dirkjan Bussink <d.bussink at gmail.com>
Dmitry Ermolov <epdmitry at yandex.ru>
Do Nhat Minh <mrordinaire at gmail.com>
Eduard Burtescu <edy.burt at gmail.com>
Edward Z. Yang <ezyang at cs.stanford.edu>
eliovir <eliovir at gmail.com>
Eric Biggers <ebiggers3 at gmail.com>
Eric Holk <eric.holk at gmail.com>
Erick Tryzelaar <erick.tryzelaar at gmail.com>
Erik Lyon <elyon001 at local.fake>
Erik Price <erik.price16 at gmail.com>
Fabrice Desr? <fabrice at desre.org>
Felix S. Klock II <pnkfelix at pnkfx.org>
Flavio Percoco <flaper87 at gmail.com>
flo-l <lacknerflo at gmail.com>
Florian Gilcher <florian.gilcher at asquera.de>
Florian Hahn <flo at fhahn.com>
Florian Zeitz <florob at babelmonkeys.de>
g3xzh <g3xzh at yahoo.com>
Gareth Smith <garethdanielsmith at gmail.com>
Geoff Hill <geoff at geoffhill.org>
Geoffroy Couprie <geo.couprie at gmail.com>
Georges Dubus <georges.dubus at compiletoi.net>
gifnksm <makoto.nksm+github at gmail.com>
Guillaume Pinot <texitoi at texitoi.eu>
Gyorgy Andrasek <jurily at gmail.com>
Harry Marr <harry.marr at gmail.com>
Heather <heather at cynede.net>
Huon Wilson <dbau.pp+github at gmail.com>
Ian Daniher <it.daniher at gmail.com>
Igor Bukanov <igor at mir2.org>
Isaac Dupree <antispam at idupree.com>
Jack Moffitt <jack at metajack.im>
Jaemin Moon <jaemin.moon at samsung.com>
Jan Niklas Hasse <jhasse at gmail.com>
Jannis Harder <jix at jixco.de>
Jason Orendorff <jason.orendorff at gmail.com>
Jason Toffaletti <jason at topsy.com>
Jay Anderson <jayanderson0 at gmail.com>
Jed Davis <jld at panix.com>
Jeff Olson <olson.jeffery at gmail.com>
Joe Schafer <joe at jschaf.com>
John Louis Walker <injyuw at gmail.com>
Jordi Boggiano <j.boggiano at seld.be>
Joshua Yanovski <pythonesque at gmail.com>
Julia Evans <julia at jvns.ca>
Jyun-Yan You <jyyou at cs.nctu.edu.tw>
Keegan McAllister <kmcallister at mozilla.com>
Kevin Ballard <kevin at sb.org>
Kiet Tran <ktt3ja at gmail.com>
klutzy <klutzytheklutzy at gmail.com>
kud1ing <github at kudling.de>
Leah Hanson <astrieanna at gmail.com>
LEE Wondong <wdlee91 at gmail.com>
Le?o Testard <leo.testard at gmail.com>
Lindsey Kuper <lindsey at composition.al>
Luca Bruno <lucab at debian.org>
Luis de Bethencourt <luis at debethencourt.com>
Luqman Aden <laden at csclub.uwaterloo.ca>
lyuts <dioxinu at gmail.com>
Mark Rowe <mrowe at bdash.net.nz>
Marvin L?bel <loebel.marvin at gmail.com>
Matt Carberry <carberry.matt at gmail.com>
Matthew Auld <matthew.auld at intel.com>
Matthew Iselin <matthew at theiselins.net>
Micah Chalmer <micah at micahchalmer.net>
Michael 'devbug' Williams <m.t.williams at live.com>
Michael Letterle <michael.letterle at gmail.com>
Michael Woerister <michaelwoerister at gmail>
niftynif <nif.ward at gmail.com>
Niko Matsakis <niko at alum.mit.edu>
Noufal Ibrahim <noufal at nibrahim.net.in>
Olivier Saut <osaut at airpost.net>
osa1 <omeragacan at gmail.com>
Palmer Cox <p at lmercox.com>
Patrick Walton <pcwalton at mimiga.net>
Peter Zotov <whitequark at whitequark.org>
Philipp Br?schweiler <blei42 at gmail.com>
Raphael Speyer <rspeyer at gmail.com>
reedlepee <reedlepee123 at gmail.com>
Richard Diamond <wichard at vitalitystudios.com>
Robert Irelan <rirelan at gmail.com>
Scott Lawrence <bytbox at gmail.com>
S?bastien Chauvel <eichi237 at mailoo.org>
S?bastien Crozet <developer at crozet.re>
S?bastien Paolacci <sebastien.paolacci at gmail.com>
Seo Sanghyeon <sanxiyn at gmail.com>
sh8281.kim <sh8281.kim at samsung.com>
SiegeLord <slabode at aim.com>
sp3d <sp3d at github>
S Pradeep Kumar <gohanpra at gmail.com>
Steve Klabnik <steve at steveklabnik.com>
Steven Fackler <sfackler at gmail.com>
Strahinja Val Markovic <val at markovic.io>
Tim Chevalier <chevalier at alum.wellesley.edu>
Tomas Sedovic <tomas at sedovic.cz>
Vadim Chugunov <vadimcn at gmail.com>
Vijay Korapaty <rust at korapaty.com>
Volker Mische <volker.mische at gmail.com>
Young-il Choi <duddlf.choi at samsung.com>
Zach Kamsler <smoo.master at gmail.com>
Zack Corr <zack at z0w0.me>
Ziad Hatahet <hatahet at gmail.com>


From banderson at mozilla.com  Thu Jan  9 12:59:48 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 12:59:48 -0800
Subject: [rust-dev] Rust 0.8 released
In-Reply-To: <52CF0DA9.70309@mozilla.com>
References: <52CF0DA9.70309@mozilla.com>
Message-ID: <52CF0DC4.1000707@mozilla.com>

0.9....

On 01/09/2014 12:59 PM, Brian Anderson wrote:
> Mozilla and the Rust community are pleased to announce version 0.9 of the
> Rust compiler and tools. Rust is a systems programming language with a
> focus on safety, performance and concurrency.
>
> This was another eventful release in which we made extensive improvements
> to the runtime and I/O subsystem, introduced static linking and link-time
> optimization, and reduced the variety of closures in the language. 0.9 
> also
> begins a final series of planned changes to how pointers are treated in
> Rust, starting with the deprecation of the built-in "managed pointer" 
> type
> and its accompanying `@` sigil, and the introduction of smart pointer 
> types
> to the standard library.
>
> The brief release notes are included in this announcement, and there is
> further explanation in the detailed release [notes] on the wiki.
> Documentation and all the links in this email are available on the
> [website]. As usual, version 0.9 should be considered an alpha release,
> suitable for early adopters and language enthusiasts. Please file [bugs]
> and join the [fun].
>
> [website]: http://www.rust-lang.org
> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
> [bugs]: https://github.com/mozilla/rust/issues
> [fun]: 
> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>
> This release is available as both a tarball and a Windows installer:
>
> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
> SHA256 (of .tar.gz):
> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>
> * http://static.rust-lang.org/dist/rust-0.9-install.exe
> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
> SHA256 (of .exe):
> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>
> Thanks to everyone who contributed!
>
> Regards,
> The Rust Team
>
>
> Version 0.9 (January 2014)
> --------------------------
>
> * Language
> * The `float` type has been removed. Use `f32` or `f64` instead.
> * A new facility for enabling experimental features (feature gating)
> has been added, using the crate-level `#[feature(foo)]` attribute.
> * Managed boxes (@) are now behind a feature gate
> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
> the standard library's `Gc` or `Rc` types instead.
> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
> * Jumping back to the top of a loop is now done with `continue` instead
> of `loop`.
> * Strings can no longer be mutated through index assignment.
> * Raw strings can be created via the basic `r"foo"` syntax or with
> matched hash delimiters, as in `r###"foo"###`.
> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
> called once.
> * The `&fn` type is now written `|args| -> ret` to match the literal
> form.
> * `@fn`s have been removed.
> * `do` only works with procs in order to make it obvious what the cost
> of `do` is.
> * Single-element tuple-like structs can no longer be dereferenced to
> obtain the inner value. A more comprehensive solution for overloading
> the dereference operator will be provided in the future.
> * The `#[link(...)]` attribute has been replaced with
> `#[crate_id = "name#vers"]`.
> * Empty `impl`s must be terminated with empty braces and may not be
> terminated with a semicolon.
> * Keywords are no longer allowed as lifetime names; the `self` lifetime
> no longer has any special meaning.
> * The old `fmt!` string formatting macro has been removed.
> * `printf!` and `printfln!` (old-style formatting) removed in favor of
> `print!` and `println!`.
> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
> * The `extern mod foo (name = "bar")` syntax has been removed. Use
> `extern mod foo = "bar"` instead.
> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
> * Macros can have attributes.
> * Macros can expand to items with attributes.
> * Macros can expand to multiple items.
> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
> * Comments may be nested.
> * Values automatically coerce to trait objects they implement, without
> an explicit `as`.
> * Enum discriminants are no longer an entire word but as small as needed
> to contain all the variants. The `repr` attribute can be used to
> override the discriminant size, as in `#[repr(int)]` for integer-sized,
> and `#[repr(C)]` to match C enums.
> * Non-string literals are not allowed in attributes (they never worked).
> * The FFI now supports variadic functions.
> * Octal numeric literals, as in `0o7777`.
> * The `concat!` syntax extension performs compile-time string
> concatenation.
> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
> removed as Rust no longer uses segmented stacks.
> * Non-ascii identifiers are feature-gated
> (`#[feature(non_ascii_idents)]`).
> * Ignoring all fields of an enum variant or tuple-struct is done with
> `..`, not `*`; ignoring remaining fields of a struct is also done
> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
> not `.._`.
> * `rustc` supports the "win64" calling convention via `extern "win64"`.
> * `rustc` supports the "system" calling convention, which defaults to
> the preferred convention for the target platform, "stdcall" on 32-bit
> Windows, "C" elsewhere.
> * The `type_overflow` lint (default: warn) checks literals for overflow.
> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
> * The `attribute_usage` lint (default: warn) warns about unknown
> attributes.
> * The `unknown_features` lint (default: warn) warns about unknown
> feature gates.
> * The `dead_code` lint (default: warn) checks for dead code.
> * Rust libraries can be linked statically to one another
> * `#[link_args]` is behind the `link_args` feature gate.
> * Native libraries are now linked with `#[link(name = "foo")]`
> * Native libraries can be statically linked to a rust crate
> (`#[link(name = "foo", kind = "static")]`).
> * Native OS X frameworks are now officially supported
> (`#[link(name = "foo", kind = "framework")]`).
> * The `#[thread_local]` attribute creates thread-local (not task-local)
> variables. Currently behind the `thread_local` feature gate.
> * The `return` keyword may be used in closures.
> * Types that can be copied via a memcpy implement the `Pod` kind.
> * The `cfg` attribute can now be used on struct fields and enum variants.
>
> * Libraries
> * std: The `option` and `result` API's have been overhauled to make them
> simpler, more consistent, and more composable.
> * std: The entire `std::io` module has been replaced with one that is
> more comprehensive and that properly interfaces with the underlying
> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
> implemented.
> * std: `io::util` contains a number of useful implementations of
> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
> `ZeroReader`, `TeeReader`.
> * std: The reference counted pointer type `extra::rc` moved into std.
> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
> just a wrapper around it).
> * std: The `Either` type has been removed.
> * std: `fmt::Default` can be implemented for any type to provide default
> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
> * std: The `rand` API continues to be tweaked.
> * std: The `rust_begin_unwind` function, useful for inserting
> breakpoints on failure in gdb, is now named `rust_fail`.
> * std: The `each_key` and `each_value` methods on `HashMap` have been
> replaced by the `keys` and `values` iterators.
> * std: Functions dealing with type size and alignment have moved from
> the `sys` module to the `mem` module.
> * std: The `path` module was written and API changed.
> * std: `str::from_utf8` has been changed to cast instead of allocate.
> * std: `starts_with` and `ends_with` methods added to vectors via the
> `ImmutableEqVector` trait, which is in the prelude.
> * std: Vectors can be indexed with the `get_opt` method, which returns
> `None` if the index is out of bounds.
> * std: Task failure no longer propagates between tasks, as the model
> was complex, expensive, and incompatible with thread-based tasks.
> * std: The `Any` type can be used for dynamic typing.
> * std: `~Any` can be passed to the `fail!` macro and retrieved via
> `task::try`.
> * std: Methods that produce iterators generally do not have an `_iter`
> suffix now.
> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
> * std: `util::ignore` renamed to `prelude::drop`.
> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
> trait.
> * std: `vec::raw` has seen a lot of cleanup and API changes.
> * std: The standard library no longer includes any C++ code, and very
> minimal C, eliminating the dependency on libstdc++.
> * std: Runtime scheduling and I/O functionality has been factored out
> into extensible interfaces and is now implemented by two different
> crates: libnative, for native threading and I/O; and libgreen, for
> green threading and I/O. This paves the way for using the standard
> library in more limited embeded environments.
> * std: The `comm` module has been rewritten to be much faster, have a
> simpler, more consistent API, and to work for both native and green
> threading.
> * std: All libuv dependencies have been moved into the rustuv crate.
> * native: New implementations of runtime scheduling on top of OS
> threads.
> * native: New native implementations of TCP, UDP, file I/O, process
> spawning, and other I/O.
> * green: The green thread scheduler and message passing types are
> almost entirely lock-free.
> * extra: The `flatpipes` module had bitrotted and was removed.
> * extra: All crypto functions have been removed and Rust now has a
> policy of not reimplementing crypto in the standard library. In the
> future crypto will be provided by external crates with bindings to
> established libraries.
> * extra: `c_vec` has been modernized.
> * extra: The `sort` module has been removed. Use the `sort` method on
> mutable slices.
>
> * Tooling
> * The `rust` and `rusti` commands have been removed, due to lack of
> maintenance.
> * `rustdoc` was completely rewritten.
> * `rustdoc` can test code examples in documentation.
> * `rustpkg` can test packages with the argument, 'test'.
> * `rustpkg` supports arbitrary dependencies, including C libraries.
> * `rustc`'s support for generating debug info is improved again.
> * `rustc` has better error reporting for unbalanced delimiters.
> * `rustc`'s JIT support was removed due to bitrot.
> * Executables and static libraries can be built with LTO (-Z lto)
> * `rustc` adds a `--dep-info` flag for communicating dependencies to
> build tools.
>
>
> Contributors to Rust 0.9
> ------------------------
>
> Adrien T?tar <adri-from-59 at hotmail.fr>
> Alan Andrade <alan.andradec at gmail.com>
> Alexandros Tasos <sdi1100085 at di.uoa.gr>
> Alex Crichton <alex at alexcrichton.com>
> a_m0d <damien.schoof at gmail.com>
> Andreas Neuhaus <zargony at zargony.com>
> Andreas Ots <andreasots at gmail.com>
> Andrei Formiga <archimedes_siracusa at hotmail.com>
> Benjamin Herr <ben at 0x539.de>
> Benjamin Peterson <benjamin at python.org>
> Birunthan Mohanathas <birunthan at mohanathas.com>
> blake2-ppc <blake2-ppc>
> Branimir <branimir at volomp.com>
> Brendan Zabarauskas <bjzaba at yahoo.com.au>
> Brian Anderson <banderson at mozilla.com>
> Brian <brian.t.dawn at gmail.com>
> Cadence Marseille <cadencemarseille at gmail.com>
> Carl-Anton Ingmarsson <mail at carlanton.se>
> Carol Willing <carolcode at willingconsulting.com>
> Carter Tazio Schonwald <carter.schonwald at gmail.com>
> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
> Chris Morgan <me at chrismorgan.info>
> Chris Sainty <csainty at hotmail.com>
> Corey Richardson <corey at octayn.net>
> Dan Connolly <dckc at madmode.com>
> Daniel Micay <danielmicay at gmail.com>
> Dan Luu <danluu at gmail.com>
> Dave Hodder <dmh at dmh.org.uk>
> David Creswick <dcrewi at gyrae.net>
> David Renshaw <dwrenshaw at gmail.com>
> Diego Ongaro <ongaro at cs.stanford.edu>
> Dirkjan Bussink <d.bussink at gmail.com>
> Dmitry Ermolov <epdmitry at yandex.ru>
> Do Nhat Minh <mrordinaire at gmail.com>
> Eduard Burtescu <edy.burt at gmail.com>
> Edward Z. Yang <ezyang at cs.stanford.edu>
> eliovir <eliovir at gmail.com>
> Eric Biggers <ebiggers3 at gmail.com>
> Eric Holk <eric.holk at gmail.com>
> Erick Tryzelaar <erick.tryzelaar at gmail.com>
> Erik Lyon <elyon001 at local.fake>
> Erik Price <erik.price16 at gmail.com>
> Fabrice Desr? <fabrice at desre.org>
> Felix S. Klock II <pnkfelix at pnkfx.org>
> Flavio Percoco <flaper87 at gmail.com>
> flo-l <lacknerflo at gmail.com>
> Florian Gilcher <florian.gilcher at asquera.de>
> Florian Hahn <flo at fhahn.com>
> Florian Zeitz <florob at babelmonkeys.de>
> g3xzh <g3xzh at yahoo.com>
> Gareth Smith <garethdanielsmith at gmail.com>
> Geoff Hill <geoff at geoffhill.org>
> Geoffroy Couprie <geo.couprie at gmail.com>
> Georges Dubus <georges.dubus at compiletoi.net>
> gifnksm <makoto.nksm+github at gmail.com>
> Guillaume Pinot <texitoi at texitoi.eu>
> Gyorgy Andrasek <jurily at gmail.com>
> Harry Marr <harry.marr at gmail.com>
> Heather <heather at cynede.net>
> Huon Wilson <dbau.pp+github at gmail.com>
> Ian Daniher <it.daniher at gmail.com>
> Igor Bukanov <igor at mir2.org>
> Isaac Dupree <antispam at idupree.com>
> Jack Moffitt <jack at metajack.im>
> Jaemin Moon <jaemin.moon at samsung.com>
> Jan Niklas Hasse <jhasse at gmail.com>
> Jannis Harder <jix at jixco.de>
> Jason Orendorff <jason.orendorff at gmail.com>
> Jason Toffaletti <jason at topsy.com>
> Jay Anderson <jayanderson0 at gmail.com>
> Jed Davis <jld at panix.com>
> Jeff Olson <olson.jeffery at gmail.com>
> Joe Schafer <joe at jschaf.com>
> John Louis Walker <injyuw at gmail.com>
> Jordi Boggiano <j.boggiano at seld.be>
> Joshua Yanovski <pythonesque at gmail.com>
> Julia Evans <julia at jvns.ca>
> Jyun-Yan You <jyyou at cs.nctu.edu.tw>
> Keegan McAllister <kmcallister at mozilla.com>
> Kevin Ballard <kevin at sb.org>
> Kiet Tran <ktt3ja at gmail.com>
> klutzy <klutzytheklutzy at gmail.com>
> kud1ing <github at kudling.de>
> Leah Hanson <astrieanna at gmail.com>
> LEE Wondong <wdlee91 at gmail.com>
> Le?o Testard <leo.testard at gmail.com>
> Lindsey Kuper <lindsey at composition.al>
> Luca Bruno <lucab at debian.org>
> Luis de Bethencourt <luis at debethencourt.com>
> Luqman Aden <laden at csclub.uwaterloo.ca>
> lyuts <dioxinu at gmail.com>
> Mark Rowe <mrowe at bdash.net.nz>
> Marvin L?bel <loebel.marvin at gmail.com>
> Matt Carberry <carberry.matt at gmail.com>
> Matthew Auld <matthew.auld at intel.com>
> Matthew Iselin <matthew at theiselins.net>
> Micah Chalmer <micah at micahchalmer.net>
> Michael 'devbug' Williams <m.t.williams at live.com>
> Michael Letterle <michael.letterle at gmail.com>
> Michael Woerister <michaelwoerister at gmail>
> niftynif <nif.ward at gmail.com>
> Niko Matsakis <niko at alum.mit.edu>
> Noufal Ibrahim <noufal at nibrahim.net.in>
> Olivier Saut <osaut at airpost.net>
> osa1 <omeragacan at gmail.com>
> Palmer Cox <p at lmercox.com>
> Patrick Walton <pcwalton at mimiga.net>
> Peter Zotov <whitequark at whitequark.org>
> Philipp Br?schweiler <blei42 at gmail.com>
> Raphael Speyer <rspeyer at gmail.com>
> reedlepee <reedlepee123 at gmail.com>
> Richard Diamond <wichard at vitalitystudios.com>
> Robert Irelan <rirelan at gmail.com>
> Scott Lawrence <bytbox at gmail.com>
> S?bastien Chauvel <eichi237 at mailoo.org>
> S?bastien Crozet <developer at crozet.re>
> S?bastien Paolacci <sebastien.paolacci at gmail.com>
> Seo Sanghyeon <sanxiyn at gmail.com>
> sh8281.kim <sh8281.kim at samsung.com>
> SiegeLord <slabode at aim.com>
> sp3d <sp3d at github>
> S Pradeep Kumar <gohanpra at gmail.com>
> Steve Klabnik <steve at steveklabnik.com>
> Steven Fackler <sfackler at gmail.com>
> Strahinja Val Markovic <val at markovic.io>
> Tim Chevalier <chevalier at alum.wellesley.edu>
> Tomas Sedovic <tomas at sedovic.cz>
> Vadim Chugunov <vadimcn at gmail.com>
> Vijay Korapaty <rust at korapaty.com>
> Volker Mische <volker.mische at gmail.com>
> Young-il Choi <duddlf.choi at samsung.com>
> Zach Kamsler <smoo.master at gmail.com>
> Zack Corr <zack at z0w0.me>
> Ziad Hatahet <hatahet at gmail.com>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Thu Jan  9 13:04:13 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 13:04:13 -0800
Subject: [rust-dev] Rust 0.9 released
Message-ID: <52CF0ECD.5050405@mozilla.com>

Mozilla and the Rust community are pleased to announce version 0.9 of the
Rust compiler and tools. Rust is a systems programming language with a
focus on safety, performance and concurrency.

This was another eventful release in which we made extensive improvements
to the runtime and I/O subsystem, introduced static linking and link-time
optimization, and reduced the variety of closures in the language. 0.9 also
begins a final series of planned changes to how pointers are treated in
Rust, starting with the deprecation of the built-in "managed pointer" type
and its accompanying `@` sigil, and the introduction of smart pointer types
to the standard library.

The brief release notes are included in this announcement, and there is
further explanation in the detailed release [notes] on the wiki.
Documentation and all the links in this email are available on the
[website]. As usual, version 0.9 should be considered an alpha release,
suitable for early adopters and language enthusiasts. Please file [bugs]
and join the [fun].

[website]: http://www.rust-lang.org
[notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
[bugs]: https://github.com/mozilla/rust/issues
[fun]: https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors

This release is available as both a tarball and a Windows installer:

* http://static.rust-lang.org/dist/rust-0.9.tar.gz
http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
SHA256 (of .tar.gz):
c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1

* http://static.rust-lang.org/dist/rust-0.9-install.exe
http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
SHA256 (of .exe):
6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90

Thanks to everyone who contributed!

Regards,
The Rust Team


Version 0.9 (January 2014)
--------------------------

* Language
* The `float` type has been removed. Use `f32` or `f64` instead.
* A new facility for enabling experimental features (feature gating)
has been added, using the crate-level `#[feature(foo)]` attribute.
* Managed boxes (@) are now behind a feature gate
(`#[feature(managed_boxes)]`) in preperation for future removal. Use
the standard library's `Gc` or `Rc` types instead.
* `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
* Jumping back to the top of a loop is now done with `continue` instead
of `loop`.
* Strings can no longer be mutated through index assignment.
* Raw strings can be created via the basic `r"foo"` syntax or with
matched hash delimiters, as in `r###"foo"###`.
* `~fn` is now written `proc (args) -> retval { ... }` and may only be
called once.
* The `&fn` type is now written `|args| -> ret` to match the literal
form.
* `@fn`s have been removed.
* `do` only works with procs in order to make it obvious what the cost
of `do` is.
* Single-element tuple-like structs can no longer be dereferenced to
obtain the inner value. A more comprehensive solution for overloading
the dereference operator will be provided in the future.
* The `#[link(...)]` attribute has been replaced with
`#[crate_id = "name#vers"]`.
* Empty `impl`s must be terminated with empty braces and may not be
terminated with a semicolon.
* Keywords are no longer allowed as lifetime names; the `self` lifetime
no longer has any special meaning.
* The old `fmt!` string formatting macro has been removed.
* `printf!` and `printfln!` (old-style formatting) removed in favor of
`print!` and `println!`.
* `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
* The `extern mod foo (name = "bar")` syntax has been removed. Use
`extern mod foo = "bar"` instead.
* New reserved keywords: `alignof`, `offsetof`, `sizeof`.
* Macros can have attributes.
* Macros can expand to items with attributes.
* Macros can expand to multiple items.
* The `asm!` macro is feature-gated (`#[feature(asm)]`).
* Comments may be nested.
* Values automatically coerce to trait objects they implement, without
an explicit `as`.
* Enum discriminants are no longer an entire word but as small as needed
to contain all the variants. The `repr` attribute can be used to
override the discriminant size, as in `#[repr(int)]` for integer-sized,
and `#[repr(C)]` to match C enums.
* Non-string literals are not allowed in attributes (they never worked).
* The FFI now supports variadic functions.
* Octal numeric literals, as in `0o7777`.
* The `concat!` syntax extension performs compile-time string
concatenation.
* The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
removed as Rust no longer uses segmented stacks.
* Non-ascii identifiers are feature-gated
(`#[feature(non_ascii_idents)]`).
* Ignoring all fields of an enum variant or tuple-struct is done with
`..`, not `*`; ignoring remaining fields of a struct is also done
with `..`, not `_`; ignoring a slice of a vector is done with `..`,
not `.._`.
* `rustc` supports the "win64" calling convention via `extern "win64"`.
* `rustc` supports the "system" calling convention, which defaults to
the preferred convention for the target platform, "stdcall" on 32-bit
Windows, "C" elsewhere.
* The `type_overflow` lint (default: warn) checks literals for overflow.
* The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
* The `attribute_usage` lint (default: warn) warns about unknown
attributes.
* The `unknown_features` lint (default: warn) warns about unknown
feature gates.
* The `dead_code` lint (default: warn) checks for dead code.
* Rust libraries can be linked statically to one another
* `#[link_args]` is behind the `link_args` feature gate.
* Native libraries are now linked with `#[link(name = "foo")]`
* Native libraries can be statically linked to a rust crate
(`#[link(name = "foo", kind = "static")]`).
* Native OS X frameworks are now officially supported
(`#[link(name = "foo", kind = "framework")]`).
* The `#[thread_local]` attribute creates thread-local (not task-local)
variables. Currently behind the `thread_local` feature gate.
* The `return` keyword may be used in closures.
* Types that can be copied via a memcpy implement the `Pod` kind.
* The `cfg` attribute can now be used on struct fields and enum variants.

* Libraries
* std: The `option` and `result` API's have been overhauled to make them
simpler, more consistent, and more composable.
* std: The entire `std::io` module has been replaced with one that is
more comprehensive and that properly interfaces with the underlying
scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
implemented.
* std: `io::util` contains a number of useful implementations of
`Reader` and `Writer`, including `NullReader`, `NullWriter`,
`ZeroReader`, `TeeReader`.
* std: The reference counted pointer type `extra::rc` moved into std.
* std: The `Gc` type in the `gc` module will replace `@` (it is currently
just a wrapper around it).
* std: The `Either` type has been removed.
* std: `fmt::Default` can be implemented for any type to provide default
formatting to the `format!` macro, as in `format!("{}", myfoo)`.
* std: The `rand` API continues to be tweaked.
* std: The `rust_begin_unwind` function, useful for inserting
breakpoints on failure in gdb, is now named `rust_fail`.
* std: The `each_key` and `each_value` methods on `HashMap` have been
replaced by the `keys` and `values` iterators.
* std: Functions dealing with type size and alignment have moved from
the `sys` module to the `mem` module.
* std: The `path` module was written and API changed.
* std: `str::from_utf8` has been changed to cast instead of allocate.
* std: `starts_with` and `ends_with` methods added to vectors via the
`ImmutableEqVector` trait, which is in the prelude.
* std: Vectors can be indexed with the `get_opt` method, which returns
`None` if the index is out of bounds.
* std: Task failure no longer propagates between tasks, as the model
was complex, expensive, and incompatible with thread-based tasks.
* std: The `Any` type can be used for dynamic typing.
* std: `~Any` can be passed to the `fail!` macro and retrieved via
`task::try`.
* std: Methods that produce iterators generally do not have an `_iter`
suffix now.
* std: `cell::Cell` and `cell::RefCell` can be used to introduc
mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
* std: `util::ignore` renamed to `prelude::drop`.
* std: Slices have `sort` and `sort_by` methods via the `MutableVector`
trait.
* std: `vec::raw` has seen a lot of cleanup and API changes.
* std: The standard library no longer includes any C++ code, and very
minimal C, eliminating the dependency on libstdc++.
* std: Runtime scheduling and I/O functionality has been factored out
into extensible interfaces and is now implemented by two different
crates: libnative, for native threading and I/O; and libgreen, for
green threading and I/O. This paves the way for using the standard
library in more limited embeded environments.
* std: The `comm` module has been rewritten to be much faster, have a
simpler, more consistent API, and to work for both native and green
threading.
* std: All libuv dependencies have been moved into the rustuv crate.
* native: New implementations of runtime scheduling on top of OS
threads.
* native: New native implementations of TCP, UDP, file I/O, process
spawning, and other I/O.
* green: The green thread scheduler and message passing types are
almost entirely lock-free.
* extra: The `flatpipes` module had bitrotted and was removed.
* extra: All crypto functions have been removed and Rust now has a
policy of not reimplementing crypto in the standard library. In the
future crypto will be provided by external crates with bindings to
established libraries.
* extra: `c_vec` has been modernized.
* extra: The `sort` module has been removed. Use the `sort` method on
mutable slices.

* Tooling
* The `rust` and `rusti` commands have been removed, due to lack of
maintenance.
* `rustdoc` was completely rewritten.
* `rustdoc` can test code examples in documentation.
* `rustpkg` can test packages with the argument, 'test'.
* `rustpkg` supports arbitrary dependencies, including C libraries.
* `rustc`'s support for generating debug info is improved again.
* `rustc` has better error reporting for unbalanced delimiters.
* `rustc`'s JIT support was removed due to bitrot.
* Executables and static libraries can be built with LTO (-Z lto)
* `rustc` adds a `--dep-info` flag for communicating dependencies to
build tools.


Contributors to Rust 0.9
------------------------

Adrien T?tar <adri-from-59 at hotmail.fr>
Alan Andrade <alan.andradec at gmail.com>
Alexandros Tasos <sdi1100085 at di.uoa.gr>
Alex Crichton <alex at alexcrichton.com>
a_m0d <damien.schoof at gmail.com>
Andreas Neuhaus <zargony at zargony.com>
Andreas Ots <andreasots at gmail.com>
Andrei Formiga <archimedes_siracusa at hotmail.com>
Benjamin Herr <ben at 0x539.de>
Benjamin Peterson <benjamin at python.org>
Birunthan Mohanathas <birunthan at mohanathas.com>
blake2-ppc <blake2-ppc>
Branimir <branimir at volomp.com>
Brendan Zabarauskas <bjzaba at yahoo.com.au>
Brian Anderson <banderson at mozilla.com>
Brian <brian.t.dawn at gmail.com>
Cadence Marseille <cadencemarseille at gmail.com>
Carl-Anton Ingmarsson <mail at carlanton.se>
Carol Willing <carolcode at willingconsulting.com>
Carter Tazio Schonwald <carter.schonwald at gmail.com>
chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
Chris Morgan <me at chrismorgan.info>
Chris Sainty <csainty at hotmail.com>
Corey Richardson <corey at octayn.net>
Dan Connolly <dckc at madmode.com>
Daniel Micay <danielmicay at gmail.com>
Dan Luu <danluu at gmail.com>
Dave Hodder <dmh at dmh.org.uk>
David Creswick <dcrewi at gyrae.net>
David Renshaw <dwrenshaw at gmail.com>
Diego Ongaro <ongaro at cs.stanford.edu>
Dirkjan Bussink <d.bussink at gmail.com>
Dmitry Ermolov <epdmitry at yandex.ru>
Do Nhat Minh <mrordinaire at gmail.com>
Eduard Burtescu <edy.burt at gmail.com>
Edward Z. Yang <ezyang at cs.stanford.edu>
eliovir <eliovir at gmail.com>
Eric Biggers <ebiggers3 at gmail.com>
Eric Holk <eric.holk at gmail.com>
Erick Tryzelaar <erick.tryzelaar at gmail.com>
Erik Lyon <elyon001 at local.fake>
Erik Price <erik.price16 at gmail.com>
Fabrice Desr? <fabrice at desre.org>
Felix S. Klock II <pnkfelix at pnkfx.org>
Flavio Percoco <flaper87 at gmail.com>
flo-l <lacknerflo at gmail.com>
Florian Gilcher <florian.gilcher at asquera.de>
Florian Hahn <flo at fhahn.com>
Florian Zeitz <florob at babelmonkeys.de>
g3xzh <g3xzh at yahoo.com>
Gareth Smith <garethdanielsmith at gmail.com>
Geoff Hill <geoff at geoffhill.org>
Geoffroy Couprie <geo.couprie at gmail.com>
Georges Dubus <georges.dubus at compiletoi.net>
gifnksm <makoto.nksm+github at gmail.com>
Guillaume Pinot <texitoi at texitoi.eu>
Gyorgy Andrasek <jurily at gmail.com>
Harry Marr <harry.marr at gmail.com>
Heather <heather at cynede.net>
Huon Wilson <dbau.pp+github at gmail.com>
Ian Daniher <it.daniher at gmail.com>
Igor Bukanov <igor at mir2.org>
Isaac Dupree <antispam at idupree.com>
Jack Moffitt <jack at metajack.im>
Jaemin Moon <jaemin.moon at samsung.com>
Jan Niklas Hasse <jhasse at gmail.com>
Jannis Harder <jix at jixco.de>
Jason Orendorff <jason.orendorff at gmail.com>
Jason Toffaletti <jason at topsy.com>
Jay Anderson <jayanderson0 at gmail.com>
Jed Davis <jld at panix.com>
Jeff Olson <olson.jeffery at gmail.com>
Joe Schafer <joe at jschaf.com>
John Louis Walker <injyuw at gmail.com>
Jordi Boggiano <j.boggiano at seld.be>
Joshua Yanovski <pythonesque at gmail.com>
Julia Evans <julia at jvns.ca>
Jyun-Yan You <jyyou at cs.nctu.edu.tw>
Keegan McAllister <kmcallister at mozilla.com>
Kevin Ballard <kevin at sb.org>
Kiet Tran <ktt3ja at gmail.com>
klutzy <klutzytheklutzy at gmail.com>
kud1ing <github at kudling.de>
Leah Hanson <astrieanna at gmail.com>
LEE Wondong <wdlee91 at gmail.com>
Le?o Testard <leo.testard at gmail.com>
Lindsey Kuper <lindsey at composition.al>
Luca Bruno <lucab at debian.org>
Luis de Bethencourt <luis at debethencourt.com>
Luqman Aden <laden at csclub.uwaterloo.ca>
lyuts <dioxinu at gmail.com>
Mark Rowe <mrowe at bdash.net.nz>
Marvin L?bel <loebel.marvin at gmail.com>
Matt Carberry <carberry.matt at gmail.com>
Matthew Auld <matthew.auld at intel.com>
Matthew Iselin <matthew at theiselins.net>
Micah Chalmer <micah at micahchalmer.net>
Michael 'devbug' Williams <m.t.williams at live.com>
Michael Letterle <michael.letterle at gmail.com>
Michael Woerister <michaelwoerister at gmail>
niftynif <nif.ward at gmail.com>
Niko Matsakis <niko at alum.mit.edu>
Noufal Ibrahim <noufal at nibrahim.net.in>
Olivier Saut <osaut at airpost.net>
osa1 <omeragacan at gmail.com>
Palmer Cox <p at lmercox.com>
Patrick Walton <pcwalton at mimiga.net>
Peter Zotov <whitequark at whitequark.org>
Philipp Br?schweiler <blei42 at gmail.com>
Raphael Speyer <rspeyer at gmail.com>
reedlepee <reedlepee123 at gmail.com>
Richard Diamond <wichard at vitalitystudios.com>
Robert Irelan <rirelan at gmail.com>
Scott Lawrence <bytbox at gmail.com>
S?bastien Chauvel <eichi237 at mailoo.org>
S?bastien Crozet <developer at crozet.re>
S?bastien Paolacci <sebastien.paolacci at gmail.com>
Seo Sanghyeon <sanxiyn at gmail.com>
sh8281.kim <sh8281.kim at samsung.com>
SiegeLord <slabode at aim.com>
sp3d <sp3d at github>
S Pradeep Kumar <gohanpra at gmail.com>
Steve Klabnik <steve at steveklabnik.com>
Steven Fackler <sfackler at gmail.com>
Strahinja Val Markovic <val at markovic.io>
Tim Chevalier <chevalier at alum.wellesley.edu>
Tomas Sedovic <tomas at sedovic.cz>
Vadim Chugunov <vadimcn at gmail.com>
Vijay Korapaty <rust at korapaty.com>
Volker Mische <volker.mische at gmail.com>
Young-il Choi <duddlf.choi at samsung.com>
Zach Kamsler <smoo.master at gmail.com>
Zack Corr <zack at z0w0.me>
Ziad Hatahet <hatahet at gmail.com>

_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/89618030/attachment-0001.html>

From banderson at mozilla.com  Thu Jan  9 13:04:35 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 13:04:35 -0800
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <52CF0ECD.5050405@mozilla.com>
References: <52CF0ECD.5050405@mozilla.com>
Message-ID: <52CF0EE3.20404@mozilla.com>

Just in case somebody wants one with the correct title. So sad.

On 01/09/2014 01:04 PM, Brian Anderson wrote:
> Mozilla and the Rust community are pleased to announce version 0.9 of the
> Rust compiler and tools. Rust is a systems programming language with a
> focus on safety, performance and concurrency.
>
> This was another eventful release in which we made extensive improvements
> to the runtime and I/O subsystem, introduced static linking and link-time
> optimization, and reduced the variety of closures in the language. 0.9 
> also
> begins a final series of planned changes to how pointers are treated in
> Rust, starting with the deprecation of the built-in "managed pointer" 
> type
> and its accompanying `@` sigil, and the introduction of smart pointer 
> types
> to the standard library.
>
> The brief release notes are included in this announcement, and there is
> further explanation in the detailed release [notes] on the wiki.
> Documentation and all the links in this email are available on the
> [website]. As usual, version 0.9 should be considered an alpha release,
> suitable for early adopters and language enthusiasts. Please file [bugs]
> and join the [fun].
>
> [website]: http://www.rust-lang.org
> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
> [bugs]: https://github.com/mozilla/rust/issues
> [fun]: 
> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>
> This release is available as both a tarball and a Windows installer:
>
> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
> SHA256 (of .tar.gz):
> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>
> * http://static.rust-lang.org/dist/rust-0.9-install.exe
> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
> SHA256 (of .exe):
> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>
> Thanks to everyone who contributed!
>
> Regards,
> The Rust Team
>
>
> Version 0.9 (January 2014)
> --------------------------
>
> * Language
> * The `float` type has been removed. Use `f32` or `f64` instead.
> * A new facility for enabling experimental features (feature gating)
> has been added, using the crate-level `#[feature(foo)]` attribute.
> * Managed boxes (@) are now behind a feature gate
> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
> the standard library's `Gc` or `Rc` types instead.
> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
> * Jumping back to the top of a loop is now done with `continue` instead
> of `loop`.
> * Strings can no longer be mutated through index assignment.
> * Raw strings can be created via the basic `r"foo"` syntax or with
> matched hash delimiters, as in `r###"foo"###`.
> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
> called once.
> * The `&fn` type is now written `|args| -> ret` to match the literal
> form.
> * `@fn`s have been removed.
> * `do` only works with procs in order to make it obvious what the cost
> of `do` is.
> * Single-element tuple-like structs can no longer be dereferenced to
> obtain the inner value. A more comprehensive solution for overloading
> the dereference operator will be provided in the future.
> * The `#[link(...)]` attribute has been replaced with
> `#[crate_id = "name#vers"]`.
> * Empty `impl`s must be terminated with empty braces and may not be
> terminated with a semicolon.
> * Keywords are no longer allowed as lifetime names; the `self` lifetime
> no longer has any special meaning.
> * The old `fmt!` string formatting macro has been removed.
> * `printf!` and `printfln!` (old-style formatting) removed in favor of
> `print!` and `println!`.
> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
> * The `extern mod foo (name = "bar")` syntax has been removed. Use
> `extern mod foo = "bar"` instead.
> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
> * Macros can have attributes.
> * Macros can expand to items with attributes.
> * Macros can expand to multiple items.
> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
> * Comments may be nested.
> * Values automatically coerce to trait objects they implement, without
> an explicit `as`.
> * Enum discriminants are no longer an entire word but as small as needed
> to contain all the variants. The `repr` attribute can be used to
> override the discriminant size, as in `#[repr(int)]` for integer-sized,
> and `#[repr(C)]` to match C enums.
> * Non-string literals are not allowed in attributes (they never worked).
> * The FFI now supports variadic functions.
> * Octal numeric literals, as in `0o7777`.
> * The `concat!` syntax extension performs compile-time string
> concatenation.
> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
> removed as Rust no longer uses segmented stacks.
> * Non-ascii identifiers are feature-gated
> (`#[feature(non_ascii_idents)]`).
> * Ignoring all fields of an enum variant or tuple-struct is done with
> `..`, not `*`; ignoring remaining fields of a struct is also done
> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
> not `.._`.
> * `rustc` supports the "win64" calling convention via `extern "win64"`.
> * `rustc` supports the "system" calling convention, which defaults to
> the preferred convention for the target platform, "stdcall" on 32-bit
> Windows, "C" elsewhere.
> * The `type_overflow` lint (default: warn) checks literals for overflow.
> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
> * The `attribute_usage` lint (default: warn) warns about unknown
> attributes.
> * The `unknown_features` lint (default: warn) warns about unknown
> feature gates.
> * The `dead_code` lint (default: warn) checks for dead code.
> * Rust libraries can be linked statically to one another
> * `#[link_args]` is behind the `link_args` feature gate.
> * Native libraries are now linked with `#[link(name = "foo")]`
> * Native libraries can be statically linked to a rust crate
> (`#[link(name = "foo", kind = "static")]`).
> * Native OS X frameworks are now officially supported
> (`#[link(name = "foo", kind = "framework")]`).
> * The `#[thread_local]` attribute creates thread-local (not task-local)
> variables. Currently behind the `thread_local` feature gate.
> * The `return` keyword may be used in closures.
> * Types that can be copied via a memcpy implement the `Pod` kind.
> * The `cfg` attribute can now be used on struct fields and enum variants.
>
> * Libraries
> * std: The `option` and `result` API's have been overhauled to make them
> simpler, more consistent, and more composable.
> * std: The entire `std::io` module has been replaced with one that is
> more comprehensive and that properly interfaces with the underlying
> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
> implemented.
> * std: `io::util` contains a number of useful implementations of
> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
> `ZeroReader`, `TeeReader`.
> * std: The reference counted pointer type `extra::rc` moved into std.
> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
> just a wrapper around it).
> * std: The `Either` type has been removed.
> * std: `fmt::Default` can be implemented for any type to provide default
> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
> * std: The `rand` API continues to be tweaked.
> * std: The `rust_begin_unwind` function, useful for inserting
> breakpoints on failure in gdb, is now named `rust_fail`.
> * std: The `each_key` and `each_value` methods on `HashMap` have been
> replaced by the `keys` and `values` iterators.
> * std: Functions dealing with type size and alignment have moved from
> the `sys` module to the `mem` module.
> * std: The `path` module was written and API changed.
> * std: `str::from_utf8` has been changed to cast instead of allocate.
> * std: `starts_with` and `ends_with` methods added to vectors via the
> `ImmutableEqVector` trait, which is in the prelude.
> * std: Vectors can be indexed with the `get_opt` method, which returns
> `None` if the index is out of bounds.
> * std: Task failure no longer propagates between tasks, as the model
> was complex, expensive, and incompatible with thread-based tasks.
> * std: The `Any` type can be used for dynamic typing.
> * std: `~Any` can be passed to the `fail!` macro and retrieved via
> `task::try`.
> * std: Methods that produce iterators generally do not have an `_iter`
> suffix now.
> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
> * std: `util::ignore` renamed to `prelude::drop`.
> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
> trait.
> * std: `vec::raw` has seen a lot of cleanup and API changes.
> * std: The standard library no longer includes any C++ code, and very
> minimal C, eliminating the dependency on libstdc++.
> * std: Runtime scheduling and I/O functionality has been factored out
> into extensible interfaces and is now implemented by two different
> crates: libnative, for native threading and I/O; and libgreen, for
> green threading and I/O. This paves the way for using the standard
> library in more limited embeded environments.
> * std: The `comm` module has been rewritten to be much faster, have a
> simpler, more consistent API, and to work for both native and green
> threading.
> * std: All libuv dependencies have been moved into the rustuv crate.
> * native: New implementations of runtime scheduling on top of OS
> threads.
> * native: New native implementations of TCP, UDP, file I/O, process
> spawning, and other I/O.
> * green: The green thread scheduler and message passing types are
> almost entirely lock-free.
> * extra: The `flatpipes` module had bitrotted and was removed.
> * extra: All crypto functions have been removed and Rust now has a
> policy of not reimplementing crypto in the standard library. In the
> future crypto will be provided by external crates with bindings to
> established libraries.
> * extra: `c_vec` has been modernized.
> * extra: The `sort` module has been removed. Use the `sort` method on
> mutable slices.
>
> * Tooling
> * The `rust` and `rusti` commands have been removed, due to lack of
> maintenance.
> * `rustdoc` was completely rewritten.
> * `rustdoc` can test code examples in documentation.
> * `rustpkg` can test packages with the argument, 'test'.
> * `rustpkg` supports arbitrary dependencies, including C libraries.
> * `rustc`'s support for generating debug info is improved again.
> * `rustc` has better error reporting for unbalanced delimiters.
> * `rustc`'s JIT support was removed due to bitrot.
> * Executables and static libraries can be built with LTO (-Z lto)
> * `rustc` adds a `--dep-info` flag for communicating dependencies to
> build tools.
>
>
> Contributors to Rust 0.9
> ------------------------
>
> Adrien T?tar <adri-from-59 at hotmail.fr>
> Alan Andrade <alan.andradec at gmail.com>
> Alexandros Tasos <sdi1100085 at di.uoa.gr>
> Alex Crichton <alex at alexcrichton.com>
> a_m0d <damien.schoof at gmail.com>
> Andreas Neuhaus <zargony at zargony.com>
> Andreas Ots <andreasots at gmail.com>
> Andrei Formiga <archimedes_siracusa at hotmail.com>
> Benjamin Herr <ben at 0x539.de>
> Benjamin Peterson <benjamin at python.org>
> Birunthan Mohanathas <birunthan at mohanathas.com>
> blake2-ppc <blake2-ppc>
> Branimir <branimir at volomp.com>
> Brendan Zabarauskas <bjzaba at yahoo.com.au>
> Brian Anderson <banderson at mozilla.com>
> Brian <brian.t.dawn at gmail.com>
> Cadence Marseille <cadencemarseille at gmail.com>
> Carl-Anton Ingmarsson <mail at carlanton.se>
> Carol Willing <carolcode at willingconsulting.com>
> Carter Tazio Schonwald <carter.schonwald at gmail.com>
> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
> Chris Morgan <me at chrismorgan.info>
> Chris Sainty <csainty at hotmail.com>
> Corey Richardson <corey at octayn.net>
> Dan Connolly <dckc at madmode.com>
> Daniel Micay <danielmicay at gmail.com>
> Dan Luu <danluu at gmail.com>
> Dave Hodder <dmh at dmh.org.uk>
> David Creswick <dcrewi at gyrae.net>
> David Renshaw <dwrenshaw at gmail.com>
> Diego Ongaro <ongaro at cs.stanford.edu>
> Dirkjan Bussink <d.bussink at gmail.com>
> Dmitry Ermolov <epdmitry at yandex.ru>
> Do Nhat Minh <mrordinaire at gmail.com>
> Eduard Burtescu <edy.burt at gmail.com>
> Edward Z. Yang <ezyang at cs.stanford.edu>
> eliovir <eliovir at gmail.com>
> Eric Biggers <ebiggers3 at gmail.com>
> Eric Holk <eric.holk at gmail.com>
> Erick Tryzelaar <erick.tryzelaar at gmail.com>
> Erik Lyon <elyon001 at local.fake>
> Erik Price <erik.price16 at gmail.com>
> Fabrice Desr? <fabrice at desre.org>
> Felix S. Klock II <pnkfelix at pnkfx.org>
> Flavio Percoco <flaper87 at gmail.com>
> flo-l <lacknerflo at gmail.com>
> Florian Gilcher <florian.gilcher at asquera.de>
> Florian Hahn <flo at fhahn.com>
> Florian Zeitz <florob at babelmonkeys.de>
> g3xzh <g3xzh at yahoo.com>
> Gareth Smith <garethdanielsmith at gmail.com>
> Geoff Hill <geoff at geoffhill.org>
> Geoffroy Couprie <geo.couprie at gmail.com>
> Georges Dubus <georges.dubus at compiletoi.net>
> gifnksm <makoto.nksm+github at gmail.com>
> Guillaume Pinot <texitoi at texitoi.eu>
> Gyorgy Andrasek <jurily at gmail.com>
> Harry Marr <harry.marr at gmail.com>
> Heather <heather at cynede.net>
> Huon Wilson <dbau.pp+github at gmail.com>
> Ian Daniher <it.daniher at gmail.com>
> Igor Bukanov <igor at mir2.org>
> Isaac Dupree <antispam at idupree.com>
> Jack Moffitt <jack at metajack.im>
> Jaemin Moon <jaemin.moon at samsung.com>
> Jan Niklas Hasse <jhasse at gmail.com>
> Jannis Harder <jix at jixco.de>
> Jason Orendorff <jason.orendorff at gmail.com>
> Jason Toffaletti <jason at topsy.com>
> Jay Anderson <jayanderson0 at gmail.com>
> Jed Davis <jld at panix.com>
> Jeff Olson <olson.jeffery at gmail.com>
> Joe Schafer <joe at jschaf.com>
> John Louis Walker <injyuw at gmail.com>
> Jordi Boggiano <j.boggiano at seld.be>
> Joshua Yanovski <pythonesque at gmail.com>
> Julia Evans <julia at jvns.ca>
> Jyun-Yan You <jyyou at cs.nctu.edu.tw>
> Keegan McAllister <kmcallister at mozilla.com>
> Kevin Ballard <kevin at sb.org>
> Kiet Tran <ktt3ja at gmail.com>
> klutzy <klutzytheklutzy at gmail.com>
> kud1ing <github at kudling.de>
> Leah Hanson <astrieanna at gmail.com>
> LEE Wondong <wdlee91 at gmail.com>
> Le?o Testard <leo.testard at gmail.com>
> Lindsey Kuper <lindsey at composition.al>
> Luca Bruno <lucab at debian.org>
> Luis de Bethencourt <luis at debethencourt.com>
> Luqman Aden <laden at csclub.uwaterloo.ca>
> lyuts <dioxinu at gmail.com>
> Mark Rowe <mrowe at bdash.net.nz>
> Marvin L?bel <loebel.marvin at gmail.com>
> Matt Carberry <carberry.matt at gmail.com>
> Matthew Auld <matthew.auld at intel.com>
> Matthew Iselin <matthew at theiselins.net>
> Micah Chalmer <micah at micahchalmer.net>
> Michael 'devbug' Williams <m.t.williams at live.com>
> Michael Letterle <michael.letterle at gmail.com>
> Michael Woerister <michaelwoerister at gmail>
> niftynif <nif.ward at gmail.com>
> Niko Matsakis <niko at alum.mit.edu>
> Noufal Ibrahim <noufal at nibrahim.net.in>
> Olivier Saut <osaut at airpost.net>
> osa1 <omeragacan at gmail.com>
> Palmer Cox <p at lmercox.com>
> Patrick Walton <pcwalton at mimiga.net>
> Peter Zotov <whitequark at whitequark.org>
> Philipp Br?schweiler <blei42 at gmail.com>
> Raphael Speyer <rspeyer at gmail.com>
> reedlepee <reedlepee123 at gmail.com>
> Richard Diamond <wichard at vitalitystudios.com>
> Robert Irelan <rirelan at gmail.com>
> Scott Lawrence <bytbox at gmail.com>
> S?bastien Chauvel <eichi237 at mailoo.org>
> S?bastien Crozet <developer at crozet.re>
> S?bastien Paolacci <sebastien.paolacci at gmail.com>
> Seo Sanghyeon <sanxiyn at gmail.com>
> sh8281.kim <sh8281.kim at samsung.com>
> SiegeLord <slabode at aim.com>
> sp3d <sp3d at github>
> S Pradeep Kumar <gohanpra at gmail.com>
> Steve Klabnik <steve at steveklabnik.com>
> Steven Fackler <sfackler at gmail.com>
> Strahinja Val Markovic <val at markovic.io>
> Tim Chevalier <chevalier at alum.wellesley.edu>
> Tomas Sedovic <tomas at sedovic.cz>
> Vadim Chugunov <vadimcn at gmail.com>
> Vijay Korapaty <rust at korapaty.com>
> Volker Mische <volker.mische at gmail.com>
> Young-il Choi <duddlf.choi at samsung.com>
> Zach Kamsler <smoo.master at gmail.com>
> Zack Corr <zack at z0w0.me>
> Ziad Hatahet <hatahet at gmail.com>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/de8e95bc/attachment-0001.html>

From ben.striegel at gmail.com  Thu Jan  9 13:10:37 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 9 Jan 2014 16:10:37 -0500
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <52CF0ECD.5050405@mozilla.com>
References: <52CF0ECD.5050405@mozilla.com>
Message-ID: <CAAvrL-n+E7cEMbN3T-VqKG3r09Mnu3J=GtRt6oAed+7T_N5x5g@mail.gmail.com>

Congrats everyone! Here's to 0.10. :)


On Thu, Jan 9, 2014 at 4:04 PM, Brian Anderson <banderson at mozilla.com>wrote:

>  Mozilla and the Rust community are pleased to announce version 0.9 of the
> Rust compiler and tools. Rust is a systems programming language with a
> focus on safety, performance and concurrency.
>
> This was another eventful release in which we made extensive improvements
> to the runtime and I/O subsystem, introduced static linking and link-time
> optimization, and reduced the variety of closures in the language. 0.9
> also
> begins a final series of planned changes to how pointers are treated in
> Rust, starting with the deprecation of the built-in "managed pointer" type
> and its accompanying `@` sigil, and the introduction of smart pointer
> types
> to the standard library.
>
> The brief release notes are included in this announcement, and there is
> further explanation in the detailed release [notes] on the wiki.
> Documentation and all the links in this email are available on the
> [website]. As usual, version 0.9 should be considered an alpha release,
> suitable for early adopters and language enthusiasts. Please file [bugs]
> and join the [fun].
>
> [website]: http://www.rust-lang.org
> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
> [bugs]: https://github.com/mozilla/rust/issues
> [fun]:
> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>
> This release is available as both a tarball and a Windows installer:
>
> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
> SHA256 (of .tar.gz):
> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>
> * http://static.rust-lang.org/dist/rust-0.9-install.exe
> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
> SHA256 (of .exe):
> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>
> Thanks to everyone who contributed!
>
> Regards,
> The Rust Team
>
>
> Version 0.9 (January 2014)
> --------------------------
>
> * Language
> * The `float` type has been removed. Use `f32` or `f64` instead.
> * A new facility for enabling experimental features (feature gating)
> has been added, using the crate-level `#[feature(foo)]` attribute.
> * Managed boxes (@) are now behind a feature gate
> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
> the standard library's `Gc` or `Rc` types instead.
> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
> * Jumping back to the top of a loop is now done with `continue` instead
> of `loop`.
> * Strings can no longer be mutated through index assignment.
> * Raw strings can be created via the basic `r"foo"` syntax or with
> matched hash delimiters, as in `r###"foo"###`.
> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
> called once.
> * The `&fn` type is now written `|args| -> ret` to match the literal
> form.
> * `@fn`s have been removed.
> * `do` only works with procs in order to make it obvious what the cost
> of `do` is.
> * Single-element tuple-like structs can no longer be dereferenced to
> obtain the inner value. A more comprehensive solution for overloading
> the dereference operator will be provided in the future.
> * The `#[link(...)]` attribute has been replaced with
> `#[crate_id = "name#vers"]`.
> * Empty `impl`s must be terminated with empty braces and may not be
> terminated with a semicolon.
> * Keywords are no longer allowed as lifetime names; the `self` lifetime
> no longer has any special meaning.
> * The old `fmt!` string formatting macro has been removed.
> * `printf!` and `printfln!` (old-style formatting) removed in favor of
> `print!` and `println!`.
> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
> * The `extern mod foo (name = "bar")` syntax has been removed. Use
> `extern mod foo = "bar"` instead.
> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
> * Macros can have attributes.
> * Macros can expand to items with attributes.
> * Macros can expand to multiple items.
> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
> * Comments may be nested.
> * Values automatically coerce to trait objects they implement, without
> an explicit `as`.
> * Enum discriminants are no longer an entire word but as small as needed
> to contain all the variants. The `repr` attribute can be used to
> override the discriminant size, as in `#[repr(int)]` for integer-sized,
> and `#[repr(C)]` to match C enums.
> * Non-string literals are not allowed in attributes (they never worked).
> * The FFI now supports variadic functions.
> * Octal numeric literals, as in `0o7777`.
> * The `concat!` syntax extension performs compile-time string
> concatenation.
> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
> removed as Rust no longer uses segmented stacks.
> * Non-ascii identifiers are feature-gated
> (`#[feature(non_ascii_idents)]`).
> * Ignoring all fields of an enum variant or tuple-struct is done with
> `..`, not `*`; ignoring remaining fields of a struct is also done
> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
> not `.._`.
> * `rustc` supports the "win64" calling convention via `extern "win64"`.
> * `rustc` supports the "system" calling convention, which defaults to
> the preferred convention for the target platform, "stdcall" on 32-bit
> Windows, "C" elsewhere.
> * The `type_overflow` lint (default: warn) checks literals for overflow.
> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
> * The `attribute_usage` lint (default: warn) warns about unknown
> attributes.
> * The `unknown_features` lint (default: warn) warns about unknown
> feature gates.
> * The `dead_code` lint (default: warn) checks for dead code.
> * Rust libraries can be linked statically to one another
> * `#[link_args]` is behind the `link_args` feature gate.
> * Native libraries are now linked with `#[link(name = "foo")]`
> * Native libraries can be statically linked to a rust crate
> (`#[link(name = "foo", kind = "static")]`).
> * Native OS X frameworks are now officially supported
> (`#[link(name = "foo", kind = "framework")]`).
> * The `#[thread_local]` attribute creates thread-local (not task-local)
> variables. Currently behind the `thread_local` feature gate.
> * The `return` keyword may be used in closures.
> * Types that can be copied via a memcpy implement the `Pod` kind.
> * The `cfg` attribute can now be used on struct fields and enum variants.
>
> * Libraries
> * std: The `option` and `result` API's have been overhauled to make them
> simpler, more consistent, and more composable.
> * std: The entire `std::io` module has been replaced with one that is
> more comprehensive and that properly interfaces with the underlying
> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
> implemented.
> * std: `io::util` contains a number of useful implementations of
> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
> `ZeroReader`, `TeeReader`.
> * std: The reference counted pointer type `extra::rc` moved into std.
> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
> just a wrapper around it).
> * std: The `Either` type has been removed.
> * std: `fmt::Default` can be implemented for any type to provide default
> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
> * std: The `rand` API continues to be tweaked.
> * std: The `rust_begin_unwind` function, useful for inserting
> breakpoints on failure in gdb, is now named `rust_fail`.
> * std: The `each_key` and `each_value` methods on `HashMap` have been
> replaced by the `keys` and `values` iterators.
> * std: Functions dealing with type size and alignment have moved from
> the `sys` module to the `mem` module.
> * std: The `path` module was written and API changed.
> * std: `str::from_utf8` has been changed to cast instead of allocate.
> * std: `starts_with` and `ends_with` methods added to vectors via the
> `ImmutableEqVector` trait, which is in the prelude.
> * std: Vectors can be indexed with the `get_opt` method, which returns
> `None` if the index is out of bounds.
> * std: Task failure no longer propagates between tasks, as the model
> was complex, expensive, and incompatible with thread-based tasks.
> * std: The `Any` type can be used for dynamic typing.
> * std: `~Any` can be passed to the `fail!` macro and retrieved via
> `task::try`.
> * std: Methods that produce iterators generally do not have an `_iter`
> suffix now.
> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
> * std: `util::ignore` renamed to `prelude::drop`.
> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
> trait.
> * std: `vec::raw` has seen a lot of cleanup and API changes.
> * std: The standard library no longer includes any C++ code, and very
> minimal C, eliminating the dependency on libstdc++.
> * std: Runtime scheduling and I/O functionality has been factored out
> into extensible interfaces and is now implemented by two different
> crates: libnative, for native threading and I/O; and libgreen, for
> green threading and I/O. This paves the way for using the standard
> library in more limited embeded environments.
> * std: The `comm` module has been rewritten to be much faster, have a
> simpler, more consistent API, and to work for both native and green
> threading.
> * std: All libuv dependencies have been moved into the rustuv crate.
> * native: New implementations of runtime scheduling on top of OS
> threads.
> * native: New native implementations of TCP, UDP, file I/O, process
> spawning, and other I/O.
> * green: The green thread scheduler and message passing types are
> almost entirely lock-free.
> * extra: The `flatpipes` module had bitrotted and was removed.
> * extra: All crypto functions have been removed and Rust now has a
> policy of not reimplementing crypto in the standard library. In the
> future crypto will be provided by external crates with bindings to
> established libraries.
> * extra: `c_vec` has been modernized.
> * extra: The `sort` module has been removed. Use the `sort` method on
> mutable slices.
>
> * Tooling
> * The `rust` and `rusti` commands have been removed, due to lack of
> maintenance.
> * `rustdoc` was completely rewritten.
> * `rustdoc` can test code examples in documentation.
> * `rustpkg` can test packages with the argument, 'test'.
> * `rustpkg` supports arbitrary dependencies, including C libraries.
> * `rustc`'s support for generating debug info is improved again.
> * `rustc` has better error reporting for unbalanced delimiters.
> * `rustc`'s JIT support was removed due to bitrot.
> * Executables and static libraries can be built with LTO (-Z lto)
> * `rustc` adds a `--dep-info` flag for communicating dependencies to
> build tools.
>
>
> Contributors to Rust 0.9
> ------------------------
>
> Adrien T?tar <adri-from-59 at hotmail.fr> <adri-from-59 at hotmail.fr>
> Alan Andrade <alan.andradec at gmail.com> <alan.andradec at gmail.com>
> Alexandros Tasos <sdi1100085 at di.uoa.gr> <sdi1100085 at di.uoa.gr>
> Alex Crichton <alex at alexcrichton.com> <alex at alexcrichton.com>
> a_m0d <damien.schoof at gmail.com> <damien.schoof at gmail.com>
> Andreas Neuhaus <zargony at zargony.com> <zargony at zargony.com>
> Andreas Ots <andreasots at gmail.com> <andreasots at gmail.com>
> Andrei Formiga <archimedes_siracusa at hotmail.com><archimedes_siracusa at hotmail.com>
> Benjamin Herr <ben at 0x539.de> <ben at 0x539.de>
> Benjamin Peterson <benjamin at python.org> <benjamin at python.org>
> Birunthan Mohanathas <birunthan at mohanathas.com> <birunthan at mohanathas.com>
> blake2-ppc <blake2-ppc>
> Branimir <branimir at volomp.com> <branimir at volomp.com>
> Brendan Zabarauskas <bjzaba at yahoo.com.au> <bjzaba at yahoo.com.au>
> Brian Anderson <banderson at mozilla.com> <banderson at mozilla.com>
> Brian <brian.t.dawn at gmail.com> <brian.t.dawn at gmail.com>
> Cadence Marseille <cadencemarseille at gmail.com><cadencemarseille at gmail.com>
> Carl-Anton Ingmarsson <mail at carlanton.se> <mail at carlanton.se>
> Carol Willing <carolcode at willingconsulting.com><carolcode at willingconsulting.com>
> Carter Tazio Schonwald <carter.schonwald at gmail.com><carter.schonwald at gmail.com>
> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)><chitra at chitra-HP-Pavilion-g6-Notebook-PC.%28none%29>
> Chris Morgan <me at chrismorgan.info> <me at chrismorgan.info>
> Chris Sainty <csainty at hotmail.com> <csainty at hotmail.com>
> Corey Richardson <corey at octayn.net> <corey at octayn.net>
> Dan Connolly <dckc at madmode.com> <dckc at madmode.com>
> Daniel Micay <danielmicay at gmail.com> <danielmicay at gmail.com>
> Dan Luu <danluu at gmail.com> <danluu at gmail.com>
> Dave Hodder <dmh at dmh.org.uk> <dmh at dmh.org.uk>
> David Creswick <dcrewi at gyrae.net> <dcrewi at gyrae.net>
> David Renshaw <dwrenshaw at gmail.com> <dwrenshaw at gmail.com>
> Diego Ongaro <ongaro at cs.stanford.edu> <ongaro at cs.stanford.edu>
> Dirkjan Bussink <d.bussink at gmail.com> <d.bussink at gmail.com>
> Dmitry Ermolov <epdmitry at yandex.ru> <epdmitry at yandex.ru>
> Do Nhat Minh <mrordinaire at gmail.com> <mrordinaire at gmail.com>
> Eduard Burtescu <edy.burt at gmail.com> <edy.burt at gmail.com>
> Edward Z. Yang <ezyang at cs.stanford.edu> <ezyang at cs.stanford.edu>
> eliovir <eliovir at gmail.com> <eliovir at gmail.com>
> Eric Biggers <ebiggers3 at gmail.com> <ebiggers3 at gmail.com>
> Eric Holk <eric.holk at gmail.com> <eric.holk at gmail.com>
> Erick Tryzelaar <erick.tryzelaar at gmail.com> <erick.tryzelaar at gmail.com>
> Erik Lyon <elyon001 at local.fake> <elyon001 at local.fake>
> Erik Price <erik.price16 at gmail.com> <erik.price16 at gmail.com>
> Fabrice Desr? <fabrice at desre.org> <fabrice at desre.org>
> Felix S. Klock II <pnkfelix at pnkfx.org> <pnkfelix at pnkfx.org>
> Flavio Percoco <flaper87 at gmail.com> <flaper87 at gmail.com>
> flo-l <lacknerflo at gmail.com> <lacknerflo at gmail.com>
> Florian Gilcher <florian.gilcher at asquera.de> <florian.gilcher at asquera.de>
> Florian Hahn <flo at fhahn.com> <flo at fhahn.com>
> Florian Zeitz <florob at babelmonkeys.de> <florob at babelmonkeys.de>
> g3xzh <g3xzh at yahoo.com> <g3xzh at yahoo.com>
> Gareth Smith <garethdanielsmith at gmail.com> <garethdanielsmith at gmail.com>
> Geoff Hill <geoff at geoffhill.org> <geoff at geoffhill.org>
> Geoffroy Couprie <geo.couprie at gmail.com> <geo.couprie at gmail.com>
> Georges Dubus <georges.dubus at compiletoi.net><georges.dubus at compiletoi.net>
> gifnksm <makoto.nksm+github at gmail.com> <makoto.nksm+github at gmail.com>
> Guillaume Pinot <texitoi at texitoi.eu> <texitoi at texitoi.eu>
> Gyorgy Andrasek <jurily at gmail.com> <jurily at gmail.com>
> Harry Marr <harry.marr at gmail.com> <harry.marr at gmail.com>
> Heather <heather at cynede.net> <heather at cynede.net>
> Huon Wilson <dbau.pp+github at gmail.com> <dbau.pp+github at gmail.com>
> Ian Daniher <it.daniher at gmail.com> <it.daniher at gmail.com>
> Igor Bukanov <igor at mir2.org> <igor at mir2.org>
> Isaac Dupree <antispam at idupree.com> <antispam at idupree.com>
> Jack Moffitt <jack at metajack.im> <jack at metajack.im>
> Jaemin Moon <jaemin.moon at samsung.com> <jaemin.moon at samsung.com>
> Jan Niklas Hasse <jhasse at gmail.com> <jhasse at gmail.com>
> Jannis Harder <jix at jixco.de> <jix at jixco.de>
> Jason Orendorff <jason.orendorff at gmail.com> <jason.orendorff at gmail.com>
> Jason Toffaletti <jason at topsy.com> <jason at topsy.com>
> Jay Anderson <jayanderson0 at gmail.com> <jayanderson0 at gmail.com>
> Jed Davis <jld at panix.com> <jld at panix.com>
> Jeff Olson <olson.jeffery at gmail.com> <olson.jeffery at gmail.com>
> Joe Schafer <joe at jschaf.com> <joe at jschaf.com>
> John Louis Walker <injyuw at gmail.com> <injyuw at gmail.com>
> Jordi Boggiano <j.boggiano at seld.be> <j.boggiano at seld.be>
> Joshua Yanovski <pythonesque at gmail.com> <pythonesque at gmail.com>
> Julia Evans <julia at jvns.ca> <julia at jvns.ca>
> Jyun-Yan You <jyyou at cs.nctu.edu.tw> <jyyou at cs.nctu.edu.tw>
> Keegan McAllister <kmcallister at mozilla.com> <kmcallister at mozilla.com>
> Kevin Ballard <kevin at sb.org> <kevin at sb.org>
> Kiet Tran <ktt3ja at gmail.com> <ktt3ja at gmail.com>
> klutzy <klutzytheklutzy at gmail.com> <klutzytheklutzy at gmail.com>
> kud1ing <github at kudling.de> <github at kudling.de>
> Leah Hanson <astrieanna at gmail.com> <astrieanna at gmail.com>
> LEE Wondong <wdlee91 at gmail.com> <wdlee91 at gmail.com>
> Le?o Testard <leo.testard at gmail.com> <leo.testard at gmail.com>
> Lindsey Kuper <lindsey at composition.al> <lindsey at composition.al>
> Luca Bruno <lucab at debian.org> <lucab at debian.org>
> Luis de Bethencourt <luis at debethencourt.com> <luis at debethencourt.com>
> Luqman Aden <laden at csclub.uwaterloo.ca> <laden at csclub.uwaterloo.ca>
> lyuts <dioxinu at gmail.com> <dioxinu at gmail.com>
> Mark Rowe <mrowe at bdash.net.nz> <mrowe at bdash.net.nz>
> Marvin L?bel <loebel.marvin at gmail.com> <loebel.marvin at gmail.com>
> Matt Carberry <carberry.matt at gmail.com> <carberry.matt at gmail.com>
> Matthew Auld <matthew.auld at intel.com> <matthew.auld at intel.com>
> Matthew Iselin <matthew at theiselins.net> <matthew at theiselins.net>
> Micah Chalmer <micah at micahchalmer.net> <micah at micahchalmer.net>
> Michael 'devbug' Williams <m.t.williams at live.com> <m.t.williams at live.com>
> Michael Letterle <michael.letterle at gmail.com> <michael.letterle at gmail.com>
> Michael Woerister <michaelwoerister at gmail>
> niftynif <nif.ward at gmail.com> <nif.ward at gmail.com>
> Niko Matsakis <niko at alum.mit.edu> <niko at alum.mit.edu>
> Noufal Ibrahim <noufal at nibrahim.net.in> <noufal at nibrahim.net.in>
> Olivier Saut <osaut at airpost.net> <osaut at airpost.net>
> osa1 <omeragacan at gmail.com> <omeragacan at gmail.com>
> Palmer Cox <p at lmercox.com> <p at lmercox.com>
> Patrick Walton <pcwalton at mimiga.net> <pcwalton at mimiga.net>
> Peter Zotov <whitequark at whitequark.org> <whitequark at whitequark.org>
> Philipp Br?schweiler <blei42 at gmail.com> <blei42 at gmail.com>
> Raphael Speyer <rspeyer at gmail.com> <rspeyer at gmail.com>
> reedlepee <reedlepee123 at gmail.com> <reedlepee123 at gmail.com>
> Richard Diamond <wichard at vitalitystudios.com><wichard at vitalitystudios.com>
> Robert Irelan <rirelan at gmail.com> <rirelan at gmail.com>
> Scott Lawrence <bytbox at gmail.com> <bytbox at gmail.com>
> S?bastien Chauvel <eichi237 at mailoo.org> <eichi237 at mailoo.org>
> S?bastien Crozet <developer at crozet.re> <developer at crozet.re>
> S?bastien Paolacci <sebastien.paolacci at gmail.com><sebastien.paolacci at gmail.com>
> Seo Sanghyeon <sanxiyn at gmail.com> <sanxiyn at gmail.com>
> sh8281.kim <sh8281.kim at samsung.com> <sh8281.kim at samsung.com>
> SiegeLord <slabode at aim.com> <slabode at aim.com>
> sp3d <sp3d at github>
> S Pradeep Kumar <gohanpra at gmail.com> <gohanpra at gmail.com>
> Steve Klabnik <steve at steveklabnik.com> <steve at steveklabnik.com>
> Steven Fackler <sfackler at gmail.com> <sfackler at gmail.com>
> Strahinja Val Markovic <val at markovic.io> <val at markovic.io>
> Tim Chevalier <chevalier at alum.wellesley.edu><chevalier at alum.wellesley.edu>
> Tomas Sedovic <tomas at sedovic.cz> <tomas at sedovic.cz>
> Vadim Chugunov <vadimcn at gmail.com> <vadimcn at gmail.com>
> Vijay Korapaty <rust at korapaty.com> <rust at korapaty.com>
> Volker Mische <volker.mische at gmail.com> <volker.mische at gmail.com>
> Young-il Choi <duddlf.choi at samsung.com> <duddlf.choi at samsung.com>
> Zach Kamsler <smoo.master at gmail.com> <smoo.master at gmail.com>
> Zack Corr <zack at z0w0.me> <zack at z0w0.me>
> Ziad Hatahet <hatahet at gmail.com> <hatahet at gmail.com>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/5def7b79/attachment-0001.html>

From mozilla at mcpherrin.ca  Thu Jan  9 13:35:36 2014
From: mozilla at mcpherrin.ca (Matthew McPherrin)
Date: Thu, 9 Jan 2014 13:35:36 -0800
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <CAAvrL-n+E7cEMbN3T-VqKG3r09Mnu3J=GtRt6oAed+7T_N5x5g@mail.gmail.com>
References: <52CF0ECD.5050405@mozilla.com>
	<CAAvrL-n+E7cEMbN3T-VqKG3r09Mnu3J=GtRt6oAed+7T_N5x5g@mail.gmail.com>
Message-ID: <CAMYrfjLvf8gGz0C4MwF+QNYieZu=BGZE6L9+wJ-0c72yyPv6Kw@mail.gmail.com>

Fantastic release!  I think Rust is really becoming a usable language
for "real" projects.  Great work from everyone involved!

I look forward to future releases, and to building some great products in Rust!

On Thu, Jan 9, 2014 at 1:10 PM, Benjamin Striegel
<ben.striegel at gmail.com> wrote:
> Congrats everyone! Here's to 0.10. :)
>
>
> On Thu, Jan 9, 2014 at 4:04 PM, Brian Anderson <banderson at mozilla.com>
> wrote:
>>
>> Mozilla and the Rust community are pleased to announce version 0.9 of the
>> Rust compiler and tools. Rust is a systems programming language with a
>> focus on safety, performance and concurrency.
>>
>> This was another eventful release in which we made extensive improvements
>> to the runtime and I/O subsystem, introduced static linking and link-time
>> optimization, and reduced the variety of closures in the language. 0.9
>> also
>> begins a final series of planned changes to how pointers are treated in
>> Rust, starting with the deprecation of the built-in "managed pointer" type
>> and its accompanying `@` sigil, and the introduction of smart pointer
>> types
>> to the standard library.
>>
>> The brief release notes are included in this announcement, and there is
>> further explanation in the detailed release [notes] on the wiki.
>> Documentation and all the links in this email are available on the
>> [website]. As usual, version 0.9 should be considered an alpha release,
>> suitable for early adopters and language enthusiasts. Please file [bugs]
>> and join the [fun].
>>
>> [website]: http://www.rust-lang.org
>> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
>> [bugs]: https://github.com/mozilla/rust/issues
>> [fun]:
>> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>>
>> This release is available as both a tarball and a Windows installer:
>>
>> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
>> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
>> SHA256 (of .tar.gz):
>> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>>
>> * http://static.rust-lang.org/dist/rust-0.9-install.exe
>> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
>> SHA256 (of .exe):
>> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>>
>> Thanks to everyone who contributed!
>>
>> Regards,
>> The Rust Team
>>
>>
>> Version 0.9 (January 2014)
>> --------------------------
>>
>> * Language
>> * The `float` type has been removed. Use `f32` or `f64` instead.
>> * A new facility for enabling experimental features (feature gating)
>> has been added, using the crate-level `#[feature(foo)]` attribute.
>> * Managed boxes (@) are now behind a feature gate
>> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
>> the standard library's `Gc` or `Rc` types instead.
>> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
>> * Jumping back to the top of a loop is now done with `continue` instead
>> of `loop`.
>> * Strings can no longer be mutated through index assignment.
>> * Raw strings can be created via the basic `r"foo"` syntax or with
>> matched hash delimiters, as in `r###"foo"###`.
>> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
>> called once.
>> * The `&fn` type is now written `|args| -> ret` to match the literal
>> form.
>> * `@fn`s have been removed.
>> * `do` only works with procs in order to make it obvious what the cost
>> of `do` is.
>> * Single-element tuple-like structs can no longer be dereferenced to
>> obtain the inner value. A more comprehensive solution for overloading
>> the dereference operator will be provided in the future.
>> * The `#[link(...)]` attribute has been replaced with
>> `#[crate_id = "name#vers"]`.
>> * Empty `impl`s must be terminated with empty braces and may not be
>> terminated with a semicolon.
>> * Keywords are no longer allowed as lifetime names; the `self` lifetime
>> no longer has any special meaning.
>> * The old `fmt!` string formatting macro has been removed.
>> * `printf!` and `printfln!` (old-style formatting) removed in favor of
>> `print!` and `println!`.
>> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
>> * The `extern mod foo (name = "bar")` syntax has been removed. Use
>> `extern mod foo = "bar"` instead.
>> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
>> * Macros can have attributes.
>> * Macros can expand to items with attributes.
>> * Macros can expand to multiple items.
>> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
>> * Comments may be nested.
>> * Values automatically coerce to trait objects they implement, without
>> an explicit `as`.
>> * Enum discriminants are no longer an entire word but as small as needed
>> to contain all the variants. The `repr` attribute can be used to
>> override the discriminant size, as in `#[repr(int)]` for integer-sized,
>> and `#[repr(C)]` to match C enums.
>> * Non-string literals are not allowed in attributes (they never worked).
>> * The FFI now supports variadic functions.
>> * Octal numeric literals, as in `0o7777`.
>> * The `concat!` syntax extension performs compile-time string
>> concatenation.
>> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
>> removed as Rust no longer uses segmented stacks.
>> * Non-ascii identifiers are feature-gated
>> (`#[feature(non_ascii_idents)]`).
>> * Ignoring all fields of an enum variant or tuple-struct is done with
>> `..`, not `*`; ignoring remaining fields of a struct is also done
>> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
>> not `.._`.
>> * `rustc` supports the "win64" calling convention via `extern "win64"`.
>> * `rustc` supports the "system" calling convention, which defaults to
>> the preferred convention for the target platform, "stdcall" on 32-bit
>> Windows, "C" elsewhere.
>> * The `type_overflow` lint (default: warn) checks literals for overflow.
>> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
>> * The `attribute_usage` lint (default: warn) warns about unknown
>> attributes.
>> * The `unknown_features` lint (default: warn) warns about unknown
>> feature gates.
>> * The `dead_code` lint (default: warn) checks for dead code.
>> * Rust libraries can be linked statically to one another
>> * `#[link_args]` is behind the `link_args` feature gate.
>> * Native libraries are now linked with `#[link(name = "foo")]`
>> * Native libraries can be statically linked to a rust crate
>> (`#[link(name = "foo", kind = "static")]`).
>> * Native OS X frameworks are now officially supported
>> (`#[link(name = "foo", kind = "framework")]`).
>> * The `#[thread_local]` attribute creates thread-local (not task-local)
>> variables. Currently behind the `thread_local` feature gate.
>> * The `return` keyword may be used in closures.
>> * Types that can be copied via a memcpy implement the `Pod` kind.
>> * The `cfg` attribute can now be used on struct fields and enum variants.
>>
>> * Libraries
>> * std: The `option` and `result` API's have been overhauled to make them
>> simpler, more consistent, and more composable.
>> * std: The entire `std::io` module has been replaced with one that is
>> more comprehensive and that properly interfaces with the underlying
>> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
>> implemented.
>> * std: `io::util` contains a number of useful implementations of
>> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
>> `ZeroReader`, `TeeReader`.
>> * std: The reference counted pointer type `extra::rc` moved into std.
>> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
>> just a wrapper around it).
>> * std: The `Either` type has been removed.
>> * std: `fmt::Default` can be implemented for any type to provide default
>> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
>> * std: The `rand` API continues to be tweaked.
>> * std: The `rust_begin_unwind` function, useful for inserting
>> breakpoints on failure in gdb, is now named `rust_fail`.
>> * std: The `each_key` and `each_value` methods on `HashMap` have been
>> replaced by the `keys` and `values` iterators.
>> * std: Functions dealing with type size and alignment have moved from
>> the `sys` module to the `mem` module.
>> * std: The `path` module was written and API changed.
>> * std: `str::from_utf8` has been changed to cast instead of allocate.
>> * std: `starts_with` and `ends_with` methods added to vectors via the
>> `ImmutableEqVector` trait, which is in the prelude.
>> * std: Vectors can be indexed with the `get_opt` method, which returns
>> `None` if the index is out of bounds.
>> * std: Task failure no longer propagates between tasks, as the model
>> was complex, expensive, and incompatible with thread-based tasks.
>> * std: The `Any` type can be used for dynamic typing.
>> * std: `~Any` can be passed to the `fail!` macro and retrieved via
>> `task::try`.
>> * std: Methods that produce iterators generally do not have an `_iter`
>> suffix now.
>> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
>> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
>> * std: `util::ignore` renamed to `prelude::drop`.
>> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
>> trait.
>> * std: `vec::raw` has seen a lot of cleanup and API changes.
>> * std: The standard library no longer includes any C++ code, and very
>> minimal C, eliminating the dependency on libstdc++.
>> * std: Runtime scheduling and I/O functionality has been factored out
>> into extensible interfaces and is now implemented by two different
>> crates: libnative, for native threading and I/O; and libgreen, for
>> green threading and I/O. This paves the way for using the standard
>> library in more limited embeded environments.
>> * std: The `comm` module has been rewritten to be much faster, have a
>> simpler, more consistent API, and to work for both native and green
>> threading.
>> * std: All libuv dependencies have been moved into the rustuv crate.
>> * native: New implementations of runtime scheduling on top of OS
>> threads.
>> * native: New native implementations of TCP, UDP, file I/O, process
>> spawning, and other I/O.
>> * green: The green thread scheduler and message passing types are
>> almost entirely lock-free.
>> * extra: The `flatpipes` module had bitrotted and was removed.
>> * extra: All crypto functions have been removed and Rust now has a
>> policy of not reimplementing crypto in the standard library. In the
>> future crypto will be provided by external crates with bindings to
>> established libraries.
>> * extra: `c_vec` has been modernized.
>> * extra: The `sort` module has been removed. Use the `sort` method on
>> mutable slices.
>>
>> * Tooling
>> * The `rust` and `rusti` commands have been removed, due to lack of
>> maintenance.
>> * `rustdoc` was completely rewritten.
>> * `rustdoc` can test code examples in documentation.
>> * `rustpkg` can test packages with the argument, 'test'.
>> * `rustpkg` supports arbitrary dependencies, including C libraries.
>> * `rustc`'s support for generating debug info is improved again.
>> * `rustc` has better error reporting for unbalanced delimiters.
>> * `rustc`'s JIT support was removed due to bitrot.
>> * Executables and static libraries can be built with LTO (-Z lto)
>> * `rustc` adds a `--dep-info` flag for communicating dependencies to
>> build tools.
>>
>>
>> Contributors to Rust 0.9
>> ------------------------
>>
>> Adrien T?tar <adri-from-59 at hotmail.fr>
>> Alan Andrade <alan.andradec at gmail.com>
>> Alexandros Tasos <sdi1100085 at di.uoa.gr>
>> Alex Crichton <alex at alexcrichton.com>
>> a_m0d <damien.schoof at gmail.com>
>> Andreas Neuhaus <zargony at zargony.com>
>> Andreas Ots <andreasots at gmail.com>
>> Andrei Formiga <archimedes_siracusa at hotmail.com>
>> Benjamin Herr <ben at 0x539.de>
>> Benjamin Peterson <benjamin at python.org>
>> Birunthan Mohanathas <birunthan at mohanathas.com>
>> blake2-ppc <blake2-ppc>
>> Branimir <branimir at volomp.com>
>> Brendan Zabarauskas <bjzaba at yahoo.com.au>
>> Brian Anderson <banderson at mozilla.com>
>> Brian <brian.t.dawn at gmail.com>
>> Cadence Marseille <cadencemarseille at gmail.com>
>> Carl-Anton Ingmarsson <mail at carlanton.se>
>> Carol Willing <carolcode at willingconsulting.com>
>> Carter Tazio Schonwald <carter.schonwald at gmail.com>
>> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
>> Chris Morgan <me at chrismorgan.info>
>> Chris Sainty <csainty at hotmail.com>
>> Corey Richardson <corey at octayn.net>
>> Dan Connolly <dckc at madmode.com>
>> Daniel Micay <danielmicay at gmail.com>
>> Dan Luu <danluu at gmail.com>
>> Dave Hodder <dmh at dmh.org.uk>
>> David Creswick <dcrewi at gyrae.net>
>> David Renshaw <dwrenshaw at gmail.com>
>> Diego Ongaro <ongaro at cs.stanford.edu>
>> Dirkjan Bussink <d.bussink at gmail.com>
>> Dmitry Ermolov <epdmitry at yandex.ru>
>> Do Nhat Minh <mrordinaire at gmail.com>
>> Eduard Burtescu <edy.burt at gmail.com>
>> Edward Z. Yang <ezyang at cs.stanford.edu>
>> eliovir <eliovir at gmail.com>
>> Eric Biggers <ebiggers3 at gmail.com>
>> Eric Holk <eric.holk at gmail.com>
>> Erick Tryzelaar <erick.tryzelaar at gmail.com>
>> Erik Lyon <elyon001 at local.fake>
>> Erik Price <erik.price16 at gmail.com>
>> Fabrice Desr? <fabrice at desre.org>
>> Felix S. Klock II <pnkfelix at pnkfx.org>
>> Flavio Percoco <flaper87 at gmail.com>
>> flo-l <lacknerflo at gmail.com>
>> Florian Gilcher <florian.gilcher at asquera.de>
>> Florian Hahn <flo at fhahn.com>
>> Florian Zeitz <florob at babelmonkeys.de>
>> g3xzh <g3xzh at yahoo.com>
>> Gareth Smith <garethdanielsmith at gmail.com>
>> Geoff Hill <geoff at geoffhill.org>
>> Geoffroy Couprie <geo.couprie at gmail.com>
>> Georges Dubus <georges.dubus at compiletoi.net>
>> gifnksm <makoto.nksm+github at gmail.com>
>> Guillaume Pinot <texitoi at texitoi.eu>
>> Gyorgy Andrasek <jurily at gmail.com>
>> Harry Marr <harry.marr at gmail.com>
>> Heather <heather at cynede.net>
>> Huon Wilson <dbau.pp+github at gmail.com>
>> Ian Daniher <it.daniher at gmail.com>
>> Igor Bukanov <igor at mir2.org>
>> Isaac Dupree <antispam at idupree.com>
>> Jack Moffitt <jack at metajack.im>
>> Jaemin Moon <jaemin.moon at samsung.com>
>> Jan Niklas Hasse <jhasse at gmail.com>
>> Jannis Harder <jix at jixco.de>
>> Jason Orendorff <jason.orendorff at gmail.com>
>> Jason Toffaletti <jason at topsy.com>
>> Jay Anderson <jayanderson0 at gmail.com>
>> Jed Davis <jld at panix.com>
>> Jeff Olson <olson.jeffery at gmail.com>
>> Joe Schafer <joe at jschaf.com>
>> John Louis Walker <injyuw at gmail.com>
>> Jordi Boggiano <j.boggiano at seld.be>
>> Joshua Yanovski <pythonesque at gmail.com>
>> Julia Evans <julia at jvns.ca>
>> Jyun-Yan You <jyyou at cs.nctu.edu.tw>
>> Keegan McAllister <kmcallister at mozilla.com>
>> Kevin Ballard <kevin at sb.org>
>> Kiet Tran <ktt3ja at gmail.com>
>> klutzy <klutzytheklutzy at gmail.com>
>> kud1ing <github at kudling.de>
>> Leah Hanson <astrieanna at gmail.com>
>> LEE Wondong <wdlee91 at gmail.com>
>> Le?o Testard <leo.testard at gmail.com>
>> Lindsey Kuper <lindsey at composition.al>
>> Luca Bruno <lucab at debian.org>
>> Luis de Bethencourt <luis at debethencourt.com>
>> Luqman Aden <laden at csclub.uwaterloo.ca>
>> lyuts <dioxinu at gmail.com>
>> Mark Rowe <mrowe at bdash.net.nz>
>> Marvin L?bel <loebel.marvin at gmail.com>
>> Matt Carberry <carberry.matt at gmail.com>
>> Matthew Auld <matthew.auld at intel.com>
>> Matthew Iselin <matthew at theiselins.net>
>> Micah Chalmer <micah at micahchalmer.net>
>> Michael 'devbug' Williams <m.t.williams at live.com>
>> Michael Letterle <michael.letterle at gmail.com>
>> Michael Woerister <michaelwoerister at gmail>
>> niftynif <nif.ward at gmail.com>
>> Niko Matsakis <niko at alum.mit.edu>
>> Noufal Ibrahim <noufal at nibrahim.net.in>
>> Olivier Saut <osaut at airpost.net>
>> osa1 <omeragacan at gmail.com>
>> Palmer Cox <p at lmercox.com>
>> Patrick Walton <pcwalton at mimiga.net>
>> Peter Zotov <whitequark at whitequark.org>
>> Philipp Br?schweiler <blei42 at gmail.com>
>> Raphael Speyer <rspeyer at gmail.com>
>> reedlepee <reedlepee123 at gmail.com>
>> Richard Diamond <wichard at vitalitystudios.com>
>> Robert Irelan <rirelan at gmail.com>
>> Scott Lawrence <bytbox at gmail.com>
>> S?bastien Chauvel <eichi237 at mailoo.org>
>> S?bastien Crozet <developer at crozet.re>
>> S?bastien Paolacci <sebastien.paolacci at gmail.com>
>> Seo Sanghyeon <sanxiyn at gmail.com>
>> sh8281.kim <sh8281.kim at samsung.com>
>> SiegeLord <slabode at aim.com>
>> sp3d <sp3d at github>
>> S Pradeep Kumar <gohanpra at gmail.com>
>> Steve Klabnik <steve at steveklabnik.com>
>> Steven Fackler <sfackler at gmail.com>
>> Strahinja Val Markovic <val at markovic.io>
>> Tim Chevalier <chevalier at alum.wellesley.edu>
>> Tomas Sedovic <tomas at sedovic.cz>
>> Vadim Chugunov <vadimcn at gmail.com>
>> Vijay Korapaty <rust at korapaty.com>
>> Volker Mische <volker.mische at gmail.com>
>> Young-il Choi <duddlf.choi at samsung.com>
>> Zach Kamsler <smoo.master at gmail.com>
>> Zack Corr <zack at z0w0.me>
>> Ziad Hatahet <hatahet at gmail.com>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From hatahet at gmail.com  Thu Jan  9 13:35:56 2014
From: hatahet at gmail.com (Ziad Hatahet)
Date: Thu, 9 Jan 2014 13:35:56 -0800
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <CAAvrL-n+E7cEMbN3T-VqKG3r09Mnu3J=GtRt6oAed+7T_N5x5g@mail.gmail.com>
References: <52CF0ECD.5050405@mozilla.com>
	<CAAvrL-n+E7cEMbN3T-VqKG3r09Mnu3J=GtRt6oAed+7T_N5x5g@mail.gmail.com>
Message-ID: <CAN1rdEzfWneZqXcJv7=6isORSYVO74D3_5KAMpg4Ua6bP=t2Sg@mail.gmail.com>

Awesome job! Keep up the good work.

--
Ziad


On Thu, Jan 9, 2014 at 1:10 PM, Benjamin Striegel <ben.striegel at gmail.com>wrote:

> Congrats everyone! Here's to 0.10. :)
>
>
> On Thu, Jan 9, 2014 at 4:04 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>>  Mozilla and the Rust community are pleased to announce version 0.9 of
>> the
>> Rust compiler and tools. Rust is a systems programming language with a
>> focus on safety, performance and concurrency.
>>
>> This was another eventful release in which we made extensive improvements
>> to the runtime and I/O subsystem, introduced static linking and link-time
>> optimization, and reduced the variety of closures in the language. 0.9
>> also
>> begins a final series of planned changes to how pointers are treated in
>> Rust, starting with the deprecation of the built-in "managed pointer"
>> type
>> and its accompanying `@` sigil, and the introduction of smart pointer
>> types
>> to the standard library.
>>
>> The brief release notes are included in this announcement, and there is
>> further explanation in the detailed release [notes] on the wiki.
>> Documentation and all the links in this email are available on the
>> [website]. As usual, version 0.9 should be considered an alpha release,
>> suitable for early adopters and language enthusiasts. Please file [bugs]
>> and join the [fun].
>>
>> [website]: http://www.rust-lang.org
>> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
>> [bugs]: https://github.com/mozilla/rust/issues
>> [fun]:
>> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>>
>> This release is available as both a tarball and a Windows installer:
>>
>> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
>> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
>> SHA256 (of .tar.gz):
>> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>>
>> * http://static.rust-lang.org/dist/rust-0.9-install.exe
>> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
>> SHA256 (of .exe):
>> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>>
>> Thanks to everyone who contributed!
>>
>> Regards,
>> The Rust Team
>>
>>
>> Version 0.9 (January 2014)
>> --------------------------
>>
>> * Language
>> * The `float` type has been removed. Use `f32` or `f64` instead.
>> * A new facility for enabling experimental features (feature gating)
>> has been added, using the crate-level `#[feature(foo)]` attribute.
>> * Managed boxes (@) are now behind a feature gate
>> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
>> the standard library's `Gc` or `Rc` types instead.
>> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
>> * Jumping back to the top of a loop is now done with `continue` instead
>> of `loop`.
>> * Strings can no longer be mutated through index assignment.
>> * Raw strings can be created via the basic `r"foo"` syntax or with
>> matched hash delimiters, as in `r###"foo"###`.
>> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
>> called once.
>> * The `&fn` type is now written `|args| -> ret` to match the literal
>> form.
>> * `@fn`s have been removed.
>> * `do` only works with procs in order to make it obvious what the cost
>> of `do` is.
>> * Single-element tuple-like structs can no longer be dereferenced to
>> obtain the inner value. A more comprehensive solution for overloading
>> the dereference operator will be provided in the future.
>> * The `#[link(...)]` attribute has been replaced with
>> `#[crate_id = "name#vers"]`.
>> * Empty `impl`s must be terminated with empty braces and may not be
>> terminated with a semicolon.
>> * Keywords are no longer allowed as lifetime names; the `self` lifetime
>> no longer has any special meaning.
>> * The old `fmt!` string formatting macro has been removed.
>> * `printf!` and `printfln!` (old-style formatting) removed in favor of
>> `print!` and `println!`.
>> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
>> * The `extern mod foo (name = "bar")` syntax has been removed. Use
>> `extern mod foo = "bar"` instead.
>> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
>> * Macros can have attributes.
>> * Macros can expand to items with attributes.
>> * Macros can expand to multiple items.
>> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
>> * Comments may be nested.
>> * Values automatically coerce to trait objects they implement, without
>> an explicit `as`.
>> * Enum discriminants are no longer an entire word but as small as needed
>> to contain all the variants. The `repr` attribute can be used to
>> override the discriminant size, as in `#[repr(int)]` for integer-sized,
>> and `#[repr(C)]` to match C enums.
>> * Non-string literals are not allowed in attributes (they never worked).
>> * The FFI now supports variadic functions.
>> * Octal numeric literals, as in `0o7777`.
>> * The `concat!` syntax extension performs compile-time string
>> concatenation.
>> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
>> removed as Rust no longer uses segmented stacks.
>> * Non-ascii identifiers are feature-gated
>> (`#[feature(non_ascii_idents)]`).
>> * Ignoring all fields of an enum variant or tuple-struct is done with
>> `..`, not `*`; ignoring remaining fields of a struct is also done
>> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
>> not `.._`.
>> * `rustc` supports the "win64" calling convention via `extern "win64"`.
>> * `rustc` supports the "system" calling convention, which defaults to
>> the preferred convention for the target platform, "stdcall" on 32-bit
>> Windows, "C" elsewhere.
>> * The `type_overflow` lint (default: warn) checks literals for overflow.
>> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
>> * The `attribute_usage` lint (default: warn) warns about unknown
>> attributes.
>> * The `unknown_features` lint (default: warn) warns about unknown
>> feature gates.
>> * The `dead_code` lint (default: warn) checks for dead code.
>> * Rust libraries can be linked statically to one another
>> * `#[link_args]` is behind the `link_args` feature gate.
>> * Native libraries are now linked with `#[link(name = "foo")]`
>> * Native libraries can be statically linked to a rust crate
>> (`#[link(name = "foo", kind = "static")]`).
>> * Native OS X frameworks are now officially supported
>> (`#[link(name = "foo", kind = "framework")]`).
>> * The `#[thread_local]` attribute creates thread-local (not task-local)
>> variables. Currently behind the `thread_local` feature gate.
>> * The `return` keyword may be used in closures.
>> * Types that can be copied via a memcpy implement the `Pod` kind.
>> * The `cfg` attribute can now be used on struct fields and enum variants.
>>
>> * Libraries
>> * std: The `option` and `result` API's have been overhauled to make them
>> simpler, more consistent, and more composable.
>> * std: The entire `std::io` module has been replaced with one that is
>> more comprehensive and that properly interfaces with the underlying
>> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
>> implemented.
>> * std: `io::util` contains a number of useful implementations of
>> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
>> `ZeroReader`, `TeeReader`.
>> * std: The reference counted pointer type `extra::rc` moved into std.
>> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
>> just a wrapper around it).
>> * std: The `Either` type has been removed.
>> * std: `fmt::Default` can be implemented for any type to provide default
>> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
>> * std: The `rand` API continues to be tweaked.
>> * std: The `rust_begin_unwind` function, useful for inserting
>> breakpoints on failure in gdb, is now named `rust_fail`.
>> * std: The `each_key` and `each_value` methods on `HashMap` have been
>> replaced by the `keys` and `values` iterators.
>> * std: Functions dealing with type size and alignment have moved from
>> the `sys` module to the `mem` module.
>> * std: The `path` module was written and API changed.
>> * std: `str::from_utf8` has been changed to cast instead of allocate.
>> * std: `starts_with` and `ends_with` methods added to vectors via the
>> `ImmutableEqVector` trait, which is in the prelude.
>> * std: Vectors can be indexed with the `get_opt` method, which returns
>> `None` if the index is out of bounds.
>> * std: Task failure no longer propagates between tasks, as the model
>> was complex, expensive, and incompatible with thread-based tasks.
>> * std: The `Any` type can be used for dynamic typing.
>> * std: `~Any` can be passed to the `fail!` macro and retrieved via
>> `task::try`.
>> * std: Methods that produce iterators generally do not have an `_iter`
>> suffix now.
>> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
>> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
>> * std: `util::ignore` renamed to `prelude::drop`.
>> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
>> trait.
>> * std: `vec::raw` has seen a lot of cleanup and API changes.
>> * std: The standard library no longer includes any C++ code, and very
>> minimal C, eliminating the dependency on libstdc++.
>> * std: Runtime scheduling and I/O functionality has been factored out
>> into extensible interfaces and is now implemented by two different
>> crates: libnative, for native threading and I/O; and libgreen, for
>> green threading and I/O. This paves the way for using the standard
>> library in more limited embeded environments.
>> * std: The `comm` module has been rewritten to be much faster, have a
>> simpler, more consistent API, and to work for both native and green
>> threading.
>> * std: All libuv dependencies have been moved into the rustuv crate.
>> * native: New implementations of runtime scheduling on top of OS
>> threads.
>> * native: New native implementations of TCP, UDP, file I/O, process
>> spawning, and other I/O.
>> * green: The green thread scheduler and message passing types are
>> almost entirely lock-free.
>> * extra: The `flatpipes` module had bitrotted and was removed.
>> * extra: All crypto functions have been removed and Rust now has a
>> policy of not reimplementing crypto in the standard library. In the
>> future crypto will be provided by external crates with bindings to
>> established libraries.
>> * extra: `c_vec` has been modernized.
>> * extra: The `sort` module has been removed. Use the `sort` method on
>> mutable slices.
>>
>> * Tooling
>> * The `rust` and `rusti` commands have been removed, due to lack of
>> maintenance.
>> * `rustdoc` was completely rewritten.
>> * `rustdoc` can test code examples in documentation.
>> * `rustpkg` can test packages with the argument, 'test'.
>> * `rustpkg` supports arbitrary dependencies, including C libraries.
>> * `rustc`'s support for generating debug info is improved again.
>> * `rustc` has better error reporting for unbalanced delimiters.
>> * `rustc`'s JIT support was removed due to bitrot.
>> * Executables and static libraries can be built with LTO (-Z lto)
>> * `rustc` adds a `--dep-info` flag for communicating dependencies to
>> build tools.
>>
>>
>> Contributors to Rust 0.9
>> ------------------------
>>
>> Adrien T?tar <adri-from-59 at hotmail.fr> <adri-from-59 at hotmail.fr>
>> Alan Andrade <alan.andradec at gmail.com> <alan.andradec at gmail.com>
>> Alexandros Tasos <sdi1100085 at di.uoa.gr> <sdi1100085 at di.uoa.gr>
>> Alex Crichton <alex at alexcrichton.com> <alex at alexcrichton.com>
>> a_m0d <damien.schoof at gmail.com> <damien.schoof at gmail.com>
>> Andreas Neuhaus <zargony at zargony.com> <zargony at zargony.com>
>> Andreas Ots <andreasots at gmail.com> <andreasots at gmail.com>
>> Andrei Formiga <archimedes_siracusa at hotmail.com><archimedes_siracusa at hotmail.com>
>> Benjamin Herr <ben at 0x539.de> <ben at 0x539.de>
>> Benjamin Peterson <benjamin at python.org> <benjamin at python.org>
>> Birunthan Mohanathas <birunthan at mohanathas.com><birunthan at mohanathas.com>
>> blake2-ppc <blake2-ppc>
>> Branimir <branimir at volomp.com> <branimir at volomp.com>
>> Brendan Zabarauskas <bjzaba at yahoo.com.au> <bjzaba at yahoo.com.au>
>> Brian Anderson <banderson at mozilla.com> <banderson at mozilla.com>
>> Brian <brian.t.dawn at gmail.com> <brian.t.dawn at gmail.com>
>> Cadence Marseille <cadencemarseille at gmail.com><cadencemarseille at gmail.com>
>> Carl-Anton Ingmarsson <mail at carlanton.se> <mail at carlanton.se>
>> Carol Willing <carolcode at willingconsulting.com><carolcode at willingconsulting.com>
>> Carter Tazio Schonwald <carter.schonwald at gmail.com><carter.schonwald at gmail.com>
>> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)><chitra at chitra-HP-Pavilion-g6-Notebook-PC.%28none%29>
>> Chris Morgan <me at chrismorgan.info> <me at chrismorgan.info>
>> Chris Sainty <csainty at hotmail.com> <csainty at hotmail.com>
>> Corey Richardson <corey at octayn.net> <corey at octayn.net>
>> Dan Connolly <dckc at madmode.com> <dckc at madmode.com>
>> Daniel Micay <danielmicay at gmail.com> <danielmicay at gmail.com>
>> Dan Luu <danluu at gmail.com> <danluu at gmail.com>
>> Dave Hodder <dmh at dmh.org.uk> <dmh at dmh.org.uk>
>> David Creswick <dcrewi at gyrae.net> <dcrewi at gyrae.net>
>> David Renshaw <dwrenshaw at gmail.com> <dwrenshaw at gmail.com>
>> Diego Ongaro <ongaro at cs.stanford.edu> <ongaro at cs.stanford.edu>
>> Dirkjan Bussink <d.bussink at gmail.com> <d.bussink at gmail.com>
>> Dmitry Ermolov <epdmitry at yandex.ru> <epdmitry at yandex.ru>
>> Do Nhat Minh <mrordinaire at gmail.com> <mrordinaire at gmail.com>
>> Eduard Burtescu <edy.burt at gmail.com> <edy.burt at gmail.com>
>> Edward Z. Yang <ezyang at cs.stanford.edu> <ezyang at cs.stanford.edu>
>> eliovir <eliovir at gmail.com> <eliovir at gmail.com>
>> Eric Biggers <ebiggers3 at gmail.com> <ebiggers3 at gmail.com>
>> Eric Holk <eric.holk at gmail.com> <eric.holk at gmail.com>
>> Erick Tryzelaar <erick.tryzelaar at gmail.com> <erick.tryzelaar at gmail.com>
>> Erik Lyon <elyon001 at local.fake> <elyon001 at local.fake>
>> Erik Price <erik.price16 at gmail.com> <erik.price16 at gmail.com>
>> Fabrice Desr? <fabrice at desre.org> <fabrice at desre.org>
>> Felix S. Klock II <pnkfelix at pnkfx.org> <pnkfelix at pnkfx.org>
>> Flavio Percoco <flaper87 at gmail.com> <flaper87 at gmail.com>
>> flo-l <lacknerflo at gmail.com> <lacknerflo at gmail.com>
>> Florian Gilcher <florian.gilcher at asquera.de> <florian.gilcher at asquera.de>
>> Florian Hahn <flo at fhahn.com> <flo at fhahn.com>
>> Florian Zeitz <florob at babelmonkeys.de> <florob at babelmonkeys.de>
>> g3xzh <g3xzh at yahoo.com> <g3xzh at yahoo.com>
>> Gareth Smith <garethdanielsmith at gmail.com> <garethdanielsmith at gmail.com>
>> Geoff Hill <geoff at geoffhill.org> <geoff at geoffhill.org>
>> Geoffroy Couprie <geo.couprie at gmail.com> <geo.couprie at gmail.com>
>> Georges Dubus <georges.dubus at compiletoi.net><georges.dubus at compiletoi.net>
>> gifnksm <makoto.nksm+github at gmail.com> <makoto.nksm+github at gmail.com>
>> Guillaume Pinot <texitoi at texitoi.eu> <texitoi at texitoi.eu>
>> Gyorgy Andrasek <jurily at gmail.com> <jurily at gmail.com>
>> Harry Marr <harry.marr at gmail.com> <harry.marr at gmail.com>
>> Heather <heather at cynede.net> <heather at cynede.net>
>> Huon Wilson <dbau.pp+github at gmail.com> <dbau.pp+github at gmail.com>
>> Ian Daniher <it.daniher at gmail.com> <it.daniher at gmail.com>
>> Igor Bukanov <igor at mir2.org> <igor at mir2.org>
>> Isaac Dupree <antispam at idupree.com> <antispam at idupree.com>
>> Jack Moffitt <jack at metajack.im> <jack at metajack.im>
>> Jaemin Moon <jaemin.moon at samsung.com> <jaemin.moon at samsung.com>
>> Jan Niklas Hasse <jhasse at gmail.com> <jhasse at gmail.com>
>> Jannis Harder <jix at jixco.de> <jix at jixco.de>
>> Jason Orendorff <jason.orendorff at gmail.com> <jason.orendorff at gmail.com>
>> Jason Toffaletti <jason at topsy.com> <jason at topsy.com>
>> Jay Anderson <jayanderson0 at gmail.com> <jayanderson0 at gmail.com>
>> Jed Davis <jld at panix.com> <jld at panix.com>
>> Jeff Olson <olson.jeffery at gmail.com> <olson.jeffery at gmail.com>
>> Joe Schafer <joe at jschaf.com> <joe at jschaf.com>
>> John Louis Walker <injyuw at gmail.com> <injyuw at gmail.com>
>> Jordi Boggiano <j.boggiano at seld.be> <j.boggiano at seld.be>
>> Joshua Yanovski <pythonesque at gmail.com> <pythonesque at gmail.com>
>> Julia Evans <julia at jvns.ca> <julia at jvns.ca>
>> Jyun-Yan You <jyyou at cs.nctu.edu.tw> <jyyou at cs.nctu.edu.tw>
>> Keegan McAllister <kmcallister at mozilla.com> <kmcallister at mozilla.com>
>> Kevin Ballard <kevin at sb.org> <kevin at sb.org>
>> Kiet Tran <ktt3ja at gmail.com> <ktt3ja at gmail.com>
>> klutzy <klutzytheklutzy at gmail.com> <klutzytheklutzy at gmail.com>
>> kud1ing <github at kudling.de> <github at kudling.de>
>> Leah Hanson <astrieanna at gmail.com> <astrieanna at gmail.com>
>> LEE Wondong <wdlee91 at gmail.com> <wdlee91 at gmail.com>
>> Le?o Testard <leo.testard at gmail.com> <leo.testard at gmail.com>
>> Lindsey Kuper <lindsey at composition.al> <lindsey at composition.al>
>> Luca Bruno <lucab at debian.org> <lucab at debian.org>
>> Luis de Bethencourt <luis at debethencourt.com> <luis at debethencourt.com>
>> Luqman Aden <laden at csclub.uwaterloo.ca> <laden at csclub.uwaterloo.ca>
>> lyuts <dioxinu at gmail.com> <dioxinu at gmail.com>
>> Mark Rowe <mrowe at bdash.net.nz> <mrowe at bdash.net.nz>
>> Marvin L?bel <loebel.marvin at gmail.com> <loebel.marvin at gmail.com>
>> Matt Carberry <carberry.matt at gmail.com> <carberry.matt at gmail.com>
>> Matthew Auld <matthew.auld at intel.com> <matthew.auld at intel.com>
>> Matthew Iselin <matthew at theiselins.net> <matthew at theiselins.net>
>> Micah Chalmer <micah at micahchalmer.net> <micah at micahchalmer.net>
>> Michael 'devbug' Williams <m.t.williams at live.com> <m.t.williams at live.com>
>> Michael Letterle <michael.letterle at gmail.com><michael.letterle at gmail.com>
>> Michael Woerister <michaelwoerister at gmail>
>> niftynif <nif.ward at gmail.com> <nif.ward at gmail.com>
>> Niko Matsakis <niko at alum.mit.edu> <niko at alum.mit.edu>
>> Noufal Ibrahim <noufal at nibrahim.net.in> <noufal at nibrahim.net.in>
>> Olivier Saut <osaut at airpost.net> <osaut at airpost.net>
>> osa1 <omeragacan at gmail.com> <omeragacan at gmail.com>
>> Palmer Cox <p at lmercox.com> <p at lmercox.com>
>> Patrick Walton <pcwalton at mimiga.net> <pcwalton at mimiga.net>
>> Peter Zotov <whitequark at whitequark.org> <whitequark at whitequark.org>
>> Philipp Br?schweiler <blei42 at gmail.com> <blei42 at gmail.com>
>> Raphael Speyer <rspeyer at gmail.com> <rspeyer at gmail.com>
>> reedlepee <reedlepee123 at gmail.com> <reedlepee123 at gmail.com>
>> Richard Diamond <wichard at vitalitystudios.com><wichard at vitalitystudios.com>
>> Robert Irelan <rirelan at gmail.com> <rirelan at gmail.com>
>> Scott Lawrence <bytbox at gmail.com> <bytbox at gmail.com>
>> S?bastien Chauvel <eichi237 at mailoo.org> <eichi237 at mailoo.org>
>> S?bastien Crozet <developer at crozet.re> <developer at crozet.re>
>> S?bastien Paolacci <sebastien.paolacci at gmail.com><sebastien.paolacci at gmail.com>
>> Seo Sanghyeon <sanxiyn at gmail.com> <sanxiyn at gmail.com>
>> sh8281.kim <sh8281.kim at samsung.com> <sh8281.kim at samsung.com>
>> SiegeLord <slabode at aim.com> <slabode at aim.com>
>> sp3d <sp3d at github>
>> S Pradeep Kumar <gohanpra at gmail.com> <gohanpra at gmail.com>
>> Steve Klabnik <steve at steveklabnik.com> <steve at steveklabnik.com>
>> Steven Fackler <sfackler at gmail.com> <sfackler at gmail.com>
>> Strahinja Val Markovic <val at markovic.io> <val at markovic.io>
>> Tim Chevalier <chevalier at alum.wellesley.edu><chevalier at alum.wellesley.edu>
>> Tomas Sedovic <tomas at sedovic.cz> <tomas at sedovic.cz>
>> Vadim Chugunov <vadimcn at gmail.com> <vadimcn at gmail.com>
>> Vijay Korapaty <rust at korapaty.com> <rust at korapaty.com>
>> Volker Mische <volker.mische at gmail.com> <volker.mische at gmail.com>
>> Young-il Choi <duddlf.choi at samsung.com> <duddlf.choi at samsung.com>
>> Zach Kamsler <smoo.master at gmail.com> <smoo.master at gmail.com>
>> Zack Corr <zack at z0w0.me> <zack at z0w0.me>
>> Ziad Hatahet <hatahet at gmail.com> <hatahet at gmail.com>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140109/7dbb890f/attachment-0001.html>

From ncm at cantrip.org  Thu Jan  9 16:47:35 2014
From: ncm at cantrip.org (Nathan Myers)
Date: Thu, 09 Jan 2014 16:47:35 -0800
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <52CF0EE3.20404@mozilla.com>
References: <52CF0ECD.5050405@mozilla.com> <52CF0EE3.20404@mozilla.com>
Message-ID: <52CF4327.7080605@cantrip.org>

Much blush

Congratulations, this looks like a big step in a right direction,
and in a very short time.

When I build on Debian amd64 with g++-4.8.2, I get internal C++
compiler failures in stage 0.  I run "make" again, and it builds
OK for a while, and then dies on another file.  It does finish
stage 0 after a few cycles of this.  Should I be using the "other"
C++ compiler?

Also, running "make -j4", I get failures like:

/bin/mv: cannot stat 
`/tmp/rust-0.9/x86_64-unknown-linux-gnu/llvm/utils/TableGen/Release+Asserts/AsmMatcherEmitter.d.tmp': 
No such file or directory

I haven't seen these when building with just "make".

(0.8 built without hiccups on g++-4.7 and "make -j3".)

Nathan Myers

On 01/09/2014 01:04 PM, Brian Anderson wrote:
> Just in case somebody wants one with the correct title. So sad.
>
> On 01/09/2014 01:04 PM, Brian Anderson wrote:
>> Mozilla and the Rust community are pleased to announce version 0.9 of the
>> Rust compiler and tools. Rust is a systems programming language with a
>> focus on safety, performance and concurrency.
>>
>> This was another eventful release in which we made extensive improvements
>> to the runtime and I/O subsystem, introduced static linking and link-time
>> optimization, and reduced the variety of closures in the language. 0.9
>> also
>> begins a final series of planned changes to how pointers are treated in
>> Rust, starting with the deprecation of the built-in "managed pointer"
>> type
>> and its accompanying `@` sigil, and the introduction of smart pointer
>> types
>> to the standard library.
>>
>> The brief release notes are included in this announcement, and there is
>> further explanation in the detailed release [notes] on the wiki.
>> Documentation and all the links in this email are available on the
>> [website]. As usual, version 0.9 should be considered an alpha release,
>> suitable for early adopters and language enthusiasts. Please file [bugs]
>> and join the [fun].
>>
>> [website]: http://www.rust-lang.org
>> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
>> [bugs]: https://github.com/mozilla/rust/issues
>> [fun]:
>> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>>
>> This release is available as both a tarball and a Windows installer:
>>
>> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
>> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
>> SHA256 (of .tar.gz):
>> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>>
>> * http://static.rust-lang.org/dist/rust-0.9-install.exe
>> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
>> SHA256 (of .exe):
>> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>>
>> Thanks to everyone who contributed!
>>
>> Regards,
>> The Rust Team
>>
>>
>> Version 0.9 (January 2014)
>> --------------------------
>>
>> * Language
>> * The `float` type has been removed. Use `f32` or `f64` instead.
>> * A new facility for enabling experimental features (feature gating)
>> has been added, using the crate-level `#[feature(foo)]` attribute.
>> * Managed boxes (@) are now behind a feature gate
>> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
>> the standard library's `Gc` or `Rc` types instead.
>> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
>> * Jumping back to the top of a loop is now done with `continue` instead
>> of `loop`.
>> * Strings can no longer be mutated through index assignment.
>> * Raw strings can be created via the basic `r"foo"` syntax or with
>> matched hash delimiters, as in `r###"foo"###`.
>> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
>> called once.
>> * The `&fn` type is now written `|args| -> ret` to match the literal
>> form.
>> * `@fn`s have been removed.
>> * `do` only works with procs in order to make it obvious what the cost
>> of `do` is.
>> * Single-element tuple-like structs can no longer be dereferenced to
>> obtain the inner value. A more comprehensive solution for overloading
>> the dereference operator will be provided in the future.
>> * The `#[link(...)]` attribute has been replaced with
>> `#[crate_id = "name#vers"]`.
>> * Empty `impl`s must be terminated with empty braces and may not be
>> terminated with a semicolon.
>> * Keywords are no longer allowed as lifetime names; the `self` lifetime
>> no longer has any special meaning.
>> * The old `fmt!` string formatting macro has been removed.
>> * `printf!` and `printfln!` (old-style formatting) removed in favor of
>> `print!` and `println!`.
>> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
>> * The `extern mod foo (name = "bar")` syntax has been removed. Use
>> `extern mod foo = "bar"` instead.
>> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
>> * Macros can have attributes.
>> * Macros can expand to items with attributes.
>> * Macros can expand to multiple items.
>> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
>> * Comments may be nested.
>> * Values automatically coerce to trait objects they implement, without
>> an explicit `as`.
>> * Enum discriminants are no longer an entire word but as small as needed
>> to contain all the variants. The `repr` attribute can be used to
>> override the discriminant size, as in `#[repr(int)]` for integer-sized,
>> and `#[repr(C)]` to match C enums.
>> * Non-string literals are not allowed in attributes (they never worked).
>> * The FFI now supports variadic functions.
>> * Octal numeric literals, as in `0o7777`.
>> * The `concat!` syntax extension performs compile-time string
>> concatenation.
>> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
>> removed as Rust no longer uses segmented stacks.
>> * Non-ascii identifiers are feature-gated
>> (`#[feature(non_ascii_idents)]`).
>> * Ignoring all fields of an enum variant or tuple-struct is done with
>> `..`, not `*`; ignoring remaining fields of a struct is also done
>> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
>> not `.._`.
>> * `rustc` supports the "win64" calling convention via `extern "win64"`.
>> * `rustc` supports the "system" calling convention, which defaults to
>> the preferred convention for the target platform, "stdcall" on 32-bit
>> Windows, "C" elsewhere.
>> * The `type_overflow` lint (default: warn) checks literals for overflow.
>> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
>> * The `attribute_usage` lint (default: warn) warns about unknown
>> attributes.
>> * The `unknown_features` lint (default: warn) warns about unknown
>> feature gates.
>> * The `dead_code` lint (default: warn) checks for dead code.
>> * Rust libraries can be linked statically to one another
>> * `#[link_args]` is behind the `link_args` feature gate.
>> * Native libraries are now linked with `#[link(name = "foo")]`
>> * Native libraries can be statically linked to a rust crate
>> (`#[link(name = "foo", kind = "static")]`).
>> * Native OS X frameworks are now officially supported
>> (`#[link(name = "foo", kind = "framework")]`).
>> * The `#[thread_local]` attribute creates thread-local (not task-local)
>> variables. Currently behind the `thread_local` feature gate.
>> * The `return` keyword may be used in closures.
>> * Types that can be copied via a memcpy implement the `Pod` kind.
>> * The `cfg` attribute can now be used on struct fields and enum variants.
>>
>> * Libraries
>> * std: The `option` and `result` API's have been overhauled to make them
>> simpler, more consistent, and more composable.
>> * std: The entire `std::io` module has been replaced with one that is
>> more comprehensive and that properly interfaces with the underlying
>> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
>> implemented.
>> * std: `io::util` contains a number of useful implementations of
>> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
>> `ZeroReader`, `TeeReader`.
>> * std: The reference counted pointer type `extra::rc` moved into std.
>> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
>> just a wrapper around it).
>> * std: The `Either` type has been removed.
>> * std: `fmt::Default` can be implemented for any type to provide default
>> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
>> * std: The `rand` API continues to be tweaked.
>> * std: The `rust_begin_unwind` function, useful for inserting
>> breakpoints on failure in gdb, is now named `rust_fail`.
>> * std: The `each_key` and `each_value` methods on `HashMap` have been
>> replaced by the `keys` and `values` iterators.
>> * std: Functions dealing with type size and alignment have moved from
>> the `sys` module to the `mem` module.
>> * std: The `path` module was written and API changed.
>> * std: `str::from_utf8` has been changed to cast instead of allocate.
>> * std: `starts_with` and `ends_with` methods added to vectors via the
>> `ImmutableEqVector` trait, which is in the prelude.
>> * std: Vectors can be indexed with the `get_opt` method, which returns
>> `None` if the index is out of bounds.
>> * std: Task failure no longer propagates between tasks, as the model
>> was complex, expensive, and incompatible with thread-based tasks.
>> * std: The `Any` type can be used for dynamic typing.
>> * std: `~Any` can be passed to the `fail!` macro and retrieved via
>> `task::try`.
>> * std: Methods that produce iterators generally do not have an `_iter`
>> suffix now.
>> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
>> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
>> * std: `util::ignore` renamed to `prelude::drop`.
>> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
>> trait.
>> * std: `vec::raw` has seen a lot of cleanup and API changes.
>> * std: The standard library no longer includes any C++ code, and very
>> minimal C, eliminating the dependency on libstdc++.
>> * std: Runtime scheduling and I/O functionality has been factored out
>> into extensible interfaces and is now implemented by two different
>> crates: libnative, for native threading and I/O; and libgreen, for
>> green threading and I/O. This paves the way for using the standard
>> library in more limited embeded environments.
>> * std: The `comm` module has been rewritten to be much faster, have a
>> simpler, more consistent API, and to work for both native and green
>> threading.
>> * std: All libuv dependencies have been moved into the rustuv crate.
>> * native: New implementations of runtime scheduling on top of OS
>> threads.
>> * native: New native implementations of TCP, UDP, file I/O, process
>> spawning, and other I/O.
>> * green: The green thread scheduler and message passing types are
>> almost entirely lock-free.
>> * extra: The `flatpipes` module had bitrotted and was removed.
>> * extra: All crypto functions have been removed and Rust now has a
>> policy of not reimplementing crypto in the standard library. In the
>> future crypto will be provided by external crates with bindings to
>> established libraries.
>> * extra: `c_vec` has been modernized.
>> * extra: The `sort` module has been removed. Use the `sort` method on
>> mutable slices.
>>
>> * Tooling
>> * The `rust` and `rusti` commands have been removed, due to lack of
>> maintenance.
>> * `rustdoc` was completely rewritten.
>> * `rustdoc` can test code examples in documentation.
>> * `rustpkg` can test packages with the argument, 'test'.
>> * `rustpkg` supports arbitrary dependencies, including C libraries.
>> * `rustc`'s support for generating debug info is improved again.
>> * `rustc` has better error reporting for unbalanced delimiters.
>> * `rustc`'s JIT support was removed due to bitrot.
>> * Executables and static libraries can be built with LTO (-Z lto)
>> * `rustc` adds a `--dep-info` flag for communicating dependencies to
>> build tools.
>>
>>
>> Contributors to Rust 0.9
>> ------------------------
>>
>> Adrien T?tar <adri-from-59 at hotmail.fr>
>> Alan Andrade <alan.andradec at gmail.com>
>> Alexandros Tasos <sdi1100085 at di.uoa.gr>
>> Alex Crichton <alex at alexcrichton.com>
>> a_m0d <damien.schoof at gmail.com>
>> Andreas Neuhaus <zargony at zargony.com>
>> Andreas Ots <andreasots at gmail.com>
>> Andrei Formiga <archimedes_siracusa at hotmail.com>
>> Benjamin Herr <ben at 0x539.de>
>> Benjamin Peterson <benjamin at python.org>
>> Birunthan Mohanathas <birunthan at mohanathas.com>
>> blake2-ppc <blake2-ppc>
>> Branimir <branimir at volomp.com>
>> Brendan Zabarauskas <bjzaba at yahoo.com.au>
>> Brian Anderson <banderson at mozilla.com>
>> Brian <brian.t.dawn at gmail.com>
>> Cadence Marseille <cadencemarseille at gmail.com>
>> Carl-Anton Ingmarsson <mail at carlanton.se>
>> Carol Willing <carolcode at willingconsulting.com>
>> Carter Tazio Schonwald <carter.schonwald at gmail.com>
>> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)>
>> Chris Morgan <me at chrismorgan.info>
>> Chris Sainty <csainty at hotmail.com>
>> Corey Richardson <corey at octayn.net>
>> Dan Connolly <dckc at madmode.com>
>> Daniel Micay <danielmicay at gmail.com>
>> Dan Luu <danluu at gmail.com>
>> Dave Hodder <dmh at dmh.org.uk>
>> David Creswick <dcrewi at gyrae.net>
>> David Renshaw <dwrenshaw at gmail.com>
>> Diego Ongaro <ongaro at cs.stanford.edu>
>> Dirkjan Bussink <d.bussink at gmail.com>
>> Dmitry Ermolov <epdmitry at yandex.ru>
>> Do Nhat Minh <mrordinaire at gmail.com>
>> Eduard Burtescu <edy.burt at gmail.com>
>> Edward Z. Yang <ezyang at cs.stanford.edu>
>> eliovir <eliovir at gmail.com>
>> Eric Biggers <ebiggers3 at gmail.com>
>> Eric Holk <eric.holk at gmail.com>
>> Erick Tryzelaar <erick.tryzelaar at gmail.com>
>> Erik Lyon <elyon001 at local.fake>
>> Erik Price <erik.price16 at gmail.com>
>> Fabrice Desr? <fabrice at desre.org>
>> Felix S. Klock II <pnkfelix at pnkfx.org>
>> Flavio Percoco <flaper87 at gmail.com>
>> flo-l <lacknerflo at gmail.com>
>> Florian Gilcher <florian.gilcher at asquera.de>
>> Florian Hahn <flo at fhahn.com>
>> Florian Zeitz <florob at babelmonkeys.de>
>> g3xzh <g3xzh at yahoo.com>
>> Gareth Smith <garethdanielsmith at gmail.com>
>> Geoff Hill <geoff at geoffhill.org>
>> Geoffroy Couprie <geo.couprie at gmail.com>
>> Georges Dubus <georges.dubus at compiletoi.net>
>> gifnksm <makoto.nksm+github at gmail.com>
>> Guillaume Pinot <texitoi at texitoi.eu>
>> Gyorgy Andrasek <jurily at gmail.com>
>> Harry Marr <harry.marr at gmail.com>
>> Heather <heather at cynede.net>
>> Huon Wilson <dbau.pp+github at gmail.com>
>> Ian Daniher <it.daniher at gmail.com>
>> Igor Bukanov <igor at mir2.org>
>> Isaac Dupree <antispam at idupree.com>
>> Jack Moffitt <jack at metajack.im>
>> Jaemin Moon <jaemin.moon at samsung.com>
>> Jan Niklas Hasse <jhasse at gmail.com>
>> Jannis Harder <jix at jixco.de>
>> Jason Orendorff <jason.orendorff at gmail.com>
>> Jason Toffaletti <jason at topsy.com>
>> Jay Anderson <jayanderson0 at gmail.com>
>> Jed Davis <jld at panix.com>
>> Jeff Olson <olson.jeffery at gmail.com>
>> Joe Schafer <joe at jschaf.com>
>> John Louis Walker <injyuw at gmail.com>
>> Jordi Boggiano <j.boggiano at seld.be>
>> Joshua Yanovski <pythonesque at gmail.com>
>> Julia Evans <julia at jvns.ca>
>> Jyun-Yan You <jyyou at cs.nctu.edu.tw>
>> Keegan McAllister <kmcallister at mozilla.com>
>> Kevin Ballard <kevin at sb.org>
>> Kiet Tran <ktt3ja at gmail.com>
>> klutzy <klutzytheklutzy at gmail.com>
>> kud1ing <github at kudling.de>
>> Leah Hanson <astrieanna at gmail.com>
>> LEE Wondong <wdlee91 at gmail.com>
>> Le?o Testard <leo.testard at gmail.com>
>> Lindsey Kuper <lindsey at composition.al>
>> Luca Bruno <lucab at debian.org>
>> Luis de Bethencourt <luis at debethencourt.com>
>> Luqman Aden <laden at csclub.uwaterloo.ca>
>> lyuts <dioxinu at gmail.com>
>> Mark Rowe <mrowe at bdash.net.nz>
>> Marvin L?bel <loebel.marvin at gmail.com>
>> Matt Carberry <carberry.matt at gmail.com>
>> Matthew Auld <matthew.auld at intel.com>
>> Matthew Iselin <matthew at theiselins.net>
>> Micah Chalmer <micah at micahchalmer.net>
>> Michael 'devbug' Williams <m.t.williams at live.com>
>> Michael Letterle <michael.letterle at gmail.com>
>> Michael Woerister <michaelwoerister at gmail>
>> niftynif <nif.ward at gmail.com>
>> Niko Matsakis <niko at alum.mit.edu>
>> Noufal Ibrahim <noufal at nibrahim.net.in>
>> Olivier Saut <osaut at airpost.net>
>> osa1 <omeragacan at gmail.com>
>> Palmer Cox <p at lmercox.com>
>> Patrick Walton <pcwalton at mimiga.net>
>> Peter Zotov <whitequark at whitequark.org>
>> Philipp Br?schweiler <blei42 at gmail.com>
>> Raphael Speyer <rspeyer at gmail.com>
>> reedlepee <reedlepee123 at gmail.com>
>> Richard Diamond <wichard at vitalitystudios.com>
>> Robert Irelan <rirelan at gmail.com>
>> Scott Lawrence <bytbox at gmail.com>
>> S?bastien Chauvel <eichi237 at mailoo.org>
>> S?bastien Crozet <developer at crozet.re>
>> S?bastien Paolacci <sebastien.paolacci at gmail.com>
>> Seo Sanghyeon <sanxiyn at gmail.com>
>> sh8281.kim <sh8281.kim at samsung.com>
>> SiegeLord <slabode at aim.com>
>> sp3d <sp3d at github>
>> S Pradeep Kumar <gohanpra at gmail.com>
>> Steve Klabnik <steve at steveklabnik.com>
>> Steven Fackler <sfackler at gmail.com>
>> Strahinja Val Markovic <val at markovic.io>
>> Tim Chevalier <chevalier at alum.wellesley.edu>
>> Tomas Sedovic <tomas at sedovic.cz>
>> Vadim Chugunov <vadimcn at gmail.com>
>> Vijay Korapaty <rust at korapaty.com>
>> Volker Mische <volker.mische at gmail.com>
>> Young-il Choi <duddlf.choi at samsung.com>
>> Zach Kamsler <smoo.master at gmail.com>
>> Zack Corr <zack at z0w0.me>
>> Ziad Hatahet <hatahet at gmail.com>


From lindsey at composition.al  Thu Jan  9 18:21:36 2014
From: lindsey at composition.al (Lindsey Kuper)
Date: Thu, 9 Jan 2014 21:21:36 -0500
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <52CE441E.7040208@mozilla.com>
References: <52CE441E.7040208@mozilla.com>
Message-ID: <CALnXJip89CWHgBFX8mXoNyCkdWQnq802a-_6zN+u7X-pbYwu6g@mail.gmail.com>

On Thu, Jan 9, 2014 at 1:39 AM, Brian Anderson <banderson at mozilla.com> wrote:
> These days we generally claim to
> support Mac OS X 10.6+

Do we still claim to support 10.6?  It's broken right now for me and
others (https://github.com/mozilla/rust/issues/10842).

Lindsey

From banderson at mozilla.com  Thu Jan  9 19:18:26 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 19:18:26 -0800
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <CALnXJip89CWHgBFX8mXoNyCkdWQnq802a-_6zN+u7X-pbYwu6g@mail.gmail.com>
References: <52CE441E.7040208@mozilla.com>
	<CALnXJip89CWHgBFX8mXoNyCkdWQnq802a-_6zN+u7X-pbYwu6g@mail.gmail.com>
Message-ID: <52CF6682.5040702@mozilla.com>

Then no :)

On 01/09/2014 06:21 PM, Lindsey Kuper wrote:
> On Thu, Jan 9, 2014 at 1:39 AM, Brian Anderson <banderson at mozilla.com> wrote:
>> These days we generally claim to
>> support Mac OS X 10.6+
> Do we still claim to support 10.6?  It's broken right now for me and
> others (https://github.com/mozilla/rust/issues/10842).
>
> Lindsey


From banderson at mozilla.com  Thu Jan  9 19:21:02 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 09 Jan 2014 19:21:02 -0800
Subject: [rust-dev] 0.9 prerelease testing
In-Reply-To: <52CF6682.5040702@mozilla.com>
References: <52CE441E.7040208@mozilla.com>	<CALnXJip89CWHgBFX8mXoNyCkdWQnq802a-_6zN+u7X-pbYwu6g@mail.gmail.com>
	<52CF6682.5040702@mozilla.com>
Message-ID: <52CF671E.9010804@mozilla.com>

I guess I should expand. It would be nice if we fixed this, since I 
don't think the TLS problem is a good reason to abandon 10.6, but 
neither are we too concerned with supporting very old Mac releases. My 
macbook is running 10.6 and I would like to continue using it, so I have 
some interest in seeing this fixed.

On 01/09/2014 07:18 PM, Brian Anderson wrote:
> Then no :)
>
> On 01/09/2014 06:21 PM, Lindsey Kuper wrote:
>> On Thu, Jan 9, 2014 at 1:39 AM, Brian Anderson 
>> <banderson at mozilla.com> wrote:
>>> These days we generally claim to
>>> support Mac OS X 10.6+
>> Do we still claim to support 10.6?  It's broken right now for me and
>> others (https://github.com/mozilla/rust/issues/10842).
>>
>> Lindsey
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From corey at octayn.net  Thu Jan  9 21:46:43 2014
From: corey at octayn.net (Corey Richardson)
Date: Fri, 10 Jan 2014 00:46:43 -0500
Subject: [rust-dev] RFC: Future of the Build System
Message-ID: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>

Hey all,

The build system has grown a fair bit of complexity, and is getting
hard to understand. I've been thinking about what could replace it
moving forward. Most of the complexity stems from having to self-host
(ie, staging) and cross compilation (which target are we compiling
for, and with which host?)

Our build system must:

1. Work on all the platforms we support
2. Be able to track dependencies.

Our ideal build system should:

1. Require minimal build-time dependencies
2. Allow ease of staging and cross compilation
3. Be easy to extend as we grow
4. Have readable build scripts
5. Have advanced configuration ability (NO_REBUILD, NO_BENCH, etc
should all be retained)

There are a few options:

1. Rework the current makefiles to be nicer.

I'm not sure if this is feasible. Some stuff certainly could be
easier, but the inherent problems of make (nested evals + calls, no
named parameters (what does $(1) mean here, etc), general ugliness)
make this unlikely to be a worthwhile effort, besides factoring out
some of the current boilerplate.

2. Use a different build system.

The major option here seems to be cmake[1], although I've heard
murmurings of tup[2] and some other obscure things. I'm unsure tup is
going to be of much help here. With our compilation model,
fine-grained file-based dependencies are not very useful. However,
it's awesome bottom-up dependency model could be neat. It's possible
that we could use it with a combination of:

3. Write a build system in Rust.

This would take care of everything for us, using ourselves. We'd have
a small script fetch the snapshot and build the build system, and then
hand off the rest of the build to it. This has the advantage of one
less build-time dependency, but the disadvantage that it's going to be
a lot of work. This could also potentially output tup, ninja[3], or
another form of build script after taking configuration options and
so-forth. It could also integrate with librustc for smart handling of
comments-or-test-only changes, an issue near to my heart[4]. This
build system could potentially be rustpkg, but as I understand it the
current idea is to *remove* rustpkg's ability as a build system and
keep it as a package manager. (At least, that is what I've understood
of recent discussion; this could be wrong.)

4. Write a build system in $LANG.

Python seems to be a good choice here, since we already depend on it
for fetching the snapshot etc. This still has the disadvantage of
being a lot of work, but would perhaps be easier than writing a build
system in Rust. We would definitely lose hacker points for doing so.

There are undoubtedly other options as well. Does anyone have good
ideas or opinions on what we should do? Personally I think that 3 is
going to be the best option, unless there's some super amazing build
system I haven't heard of it. Which is totally possible!

[1]: http://www.cmake.org/
[2]: http://gittup.org/tup/
[3]: http://martine.github.io/ninja/
[4]: https://github.com/mozilla/rust/issues/6522

From com.liigo at gmail.com  Thu Jan  9 22:20:00 2014
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Fri, 10 Jan 2014 14:20:00 +0800
Subject: [rust-dev] Rust 0.9 released
In-Reply-To: <52CF0ECD.5050405@mozilla.com>
References: <52CF0ECD.5050405@mozilla.com>
Message-ID: <CAH8Jz7j026+mSnkqKqGuCBNW6TqkMh6jv1Svq6OZhV=UgikryQ@mail.gmail.com>

Great work, thanks.
? 2014?1?10? ??5:04?"Brian Anderson" <banderson at mozilla.com>???

>  Mozilla and the Rust community are pleased to announce version 0.9 of the
> Rust compiler and tools. Rust is a systems programming language with a
> focus on safety, performance and concurrency.
>
> This was another eventful release in which we made extensive improvements
> to the runtime and I/O subsystem, introduced static linking and link-time
> optimization, and reduced the variety of closures in the language. 0.9
> also
> begins a final series of planned changes to how pointers are treated in
> Rust, starting with the deprecation of the built-in "managed pointer" type
> and its accompanying `@` sigil, and the introduction of smart pointer
> types
> to the standard library.
>
> The brief release notes are included in this announcement, and there is
> further explanation in the detailed release [notes] on the wiki.
> Documentation and all the links in this email are available on the
> [website]. As usual, version 0.9 should be considered an alpha release,
> suitable for early adopters and language enthusiasts. Please file [bugs]
> and join the [fun].
>
> [website]: http://www.rust-lang.org
> [notes]: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
> [bugs]: https://github.com/mozilla/rust/issues
> [fun]:
> https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
>
> This release is available as both a tarball and a Windows installer:
>
> * http://static.rust-lang.org/dist/rust-0.9.tar.gz
> http://static.rust-lang.org/dist/rust-0.9.tar.gz.asc
> SHA256 (of .tar.gz):
> c0911c3545b797a1ca16f3d76bf5ed234754b828efd1e22c182c7300ac7dd5d1
>
> * http://static.rust-lang.org/dist/rust-0.9-install.exe
> http://static.rust-lang.org/dist/rust-0.9-install.exe.asc
> SHA256 (of .exe):
> 6ab14e25761d61ba724c5f77403d09d566d3187a2e048e006036b960d938fe90
>
> Thanks to everyone who contributed!
>
> Regards,
> The Rust Team
>
>
> Version 0.9 (January 2014)
> --------------------------
>
> * Language
> * The `float` type has been removed. Use `f32` or `f64` instead.
> * A new facility for enabling experimental features (feature gating)
> has been added, using the crate-level `#[feature(foo)]` attribute.
> * Managed boxes (@) are now behind a feature gate
> (`#[feature(managed_boxes)]`) in preperation for future removal. Use
> the standard library's `Gc` or `Rc` types instead.
> * `@mut` has been removed. Use `std::cell::{Cell, RefCell}` instead.
> * Jumping back to the top of a loop is now done with `continue` instead
> of `loop`.
> * Strings can no longer be mutated through index assignment.
> * Raw strings can be created via the basic `r"foo"` syntax or with
> matched hash delimiters, as in `r###"foo"###`.
> * `~fn` is now written `proc (args) -> retval { ... }` and may only be
> called once.
> * The `&fn` type is now written `|args| -> ret` to match the literal
> form.
> * `@fn`s have been removed.
> * `do` only works with procs in order to make it obvious what the cost
> of `do` is.
> * Single-element tuple-like structs can no longer be dereferenced to
> obtain the inner value. A more comprehensive solution for overloading
> the dereference operator will be provided in the future.
> * The `#[link(...)]` attribute has been replaced with
> `#[crate_id = "name#vers"]`.
> * Empty `impl`s must be terminated with empty braces and may not be
> terminated with a semicolon.
> * Keywords are no longer allowed as lifetime names; the `self` lifetime
> no longer has any special meaning.
> * The old `fmt!` string formatting macro has been removed.
> * `printf!` and `printfln!` (old-style formatting) removed in favor of
> `print!` and `println!`.
> * `mut` works in patterns now, as in `let (mut x, y) = (1, 2);`.
> * The `extern mod foo (name = "bar")` syntax has been removed. Use
> `extern mod foo = "bar"` instead.
> * New reserved keywords: `alignof`, `offsetof`, `sizeof`.
> * Macros can have attributes.
> * Macros can expand to items with attributes.
> * Macros can expand to multiple items.
> * The `asm!` macro is feature-gated (`#[feature(asm)]`).
> * Comments may be nested.
> * Values automatically coerce to trait objects they implement, without
> an explicit `as`.
> * Enum discriminants are no longer an entire word but as small as needed
> to contain all the variants. The `repr` attribute can be used to
> override the discriminant size, as in `#[repr(int)]` for integer-sized,
> and `#[repr(C)]` to match C enums.
> * Non-string literals are not allowed in attributes (they never worked).
> * The FFI now supports variadic functions.
> * Octal numeric literals, as in `0o7777`.
> * The `concat!` syntax extension performs compile-time string
> concatenation.
> * The `#[fixed_stack_segment]` and `#[rust_stack]` attributes have been
> removed as Rust no longer uses segmented stacks.
> * Non-ascii identifiers are feature-gated
> (`#[feature(non_ascii_idents)]`).
> * Ignoring all fields of an enum variant or tuple-struct is done with
> `..`, not `*`; ignoring remaining fields of a struct is also done
> with `..`, not `_`; ignoring a slice of a vector is done with `..`,
> not `.._`.
> * `rustc` supports the "win64" calling convention via `extern "win64"`.
> * `rustc` supports the "system" calling convention, which defaults to
> the preferred convention for the target platform, "stdcall" on 32-bit
> Windows, "C" elsewhere.
> * The `type_overflow` lint (default: warn) checks literals for overflow.
> * The `unsafe_block` lint (default: allow) checks for usage of `unsafe`.
> * The `attribute_usage` lint (default: warn) warns about unknown
> attributes.
> * The `unknown_features` lint (default: warn) warns about unknown
> feature gates.
> * The `dead_code` lint (default: warn) checks for dead code.
> * Rust libraries can be linked statically to one another
> * `#[link_args]` is behind the `link_args` feature gate.
> * Native libraries are now linked with `#[link(name = "foo")]`
> * Native libraries can be statically linked to a rust crate
> (`#[link(name = "foo", kind = "static")]`).
> * Native OS X frameworks are now officially supported
> (`#[link(name = "foo", kind = "framework")]`).
> * The `#[thread_local]` attribute creates thread-local (not task-local)
> variables. Currently behind the `thread_local` feature gate.
> * The `return` keyword may be used in closures.
> * Types that can be copied via a memcpy implement the `Pod` kind.
> * The `cfg` attribute can now be used on struct fields and enum variants.
>
> * Libraries
> * std: The `option` and `result` API's have been overhauled to make them
> simpler, more consistent, and more composable.
> * std: The entire `std::io` module has been replaced with one that is
> more comprehensive and that properly interfaces with the underlying
> scheduler. File, TCP, UDP, Unix sockets, pipes, and timers are all
> implemented.
> * std: `io::util` contains a number of useful implementations of
> `Reader` and `Writer`, including `NullReader`, `NullWriter`,
> `ZeroReader`, `TeeReader`.
> * std: The reference counted pointer type `extra::rc` moved into std.
> * std: The `Gc` type in the `gc` module will replace `@` (it is currently
> just a wrapper around it).
> * std: The `Either` type has been removed.
> * std: `fmt::Default` can be implemented for any type to provide default
> formatting to the `format!` macro, as in `format!("{}", myfoo)`.
> * std: The `rand` API continues to be tweaked.
> * std: The `rust_begin_unwind` function, useful for inserting
> breakpoints on failure in gdb, is now named `rust_fail`.
> * std: The `each_key` and `each_value` methods on `HashMap` have been
> replaced by the `keys` and `values` iterators.
> * std: Functions dealing with type size and alignment have moved from
> the `sys` module to the `mem` module.
> * std: The `path` module was written and API changed.
> * std: `str::from_utf8` has been changed to cast instead of allocate.
> * std: `starts_with` and `ends_with` methods added to vectors via the
> `ImmutableEqVector` trait, which is in the prelude.
> * std: Vectors can be indexed with the `get_opt` method, which returns
> `None` if the index is out of bounds.
> * std: Task failure no longer propagates between tasks, as the model
> was complex, expensive, and incompatible with thread-based tasks.
> * std: The `Any` type can be used for dynamic typing.
> * std: `~Any` can be passed to the `fail!` macro and retrieved via
> `task::try`.
> * std: Methods that produce iterators generally do not have an `_iter`
> suffix now.
> * std: `cell::Cell` and `cell::RefCell` can be used to introduc
> mutability roots (mutable fields, etc.). Use instead of e.g. `@mut`.
> * std: `util::ignore` renamed to `prelude::drop`.
> * std: Slices have `sort` and `sort_by` methods via the `MutableVector`
> trait.
> * std: `vec::raw` has seen a lot of cleanup and API changes.
> * std: The standard library no longer includes any C++ code, and very
> minimal C, eliminating the dependency on libstdc++.
> * std: Runtime scheduling and I/O functionality has been factored out
> into extensible interfaces and is now implemented by two different
> crates: libnative, for native threading and I/O; and libgreen, for
> green threading and I/O. This paves the way for using the standard
> library in more limited embeded environments.
> * std: The `comm` module has been rewritten to be much faster, have a
> simpler, more consistent API, and to work for both native and green
> threading.
> * std: All libuv dependencies have been moved into the rustuv crate.
> * native: New implementations of runtime scheduling on top of OS
> threads.
> * native: New native implementations of TCP, UDP, file I/O, process
> spawning, and other I/O.
> * green: The green thread scheduler and message passing types are
> almost entirely lock-free.
> * extra: The `flatpipes` module had bitrotted and was removed.
> * extra: All crypto functions have been removed and Rust now has a
> policy of not reimplementing crypto in the standard library. In the
> future crypto will be provided by external crates with bindings to
> established libraries.
> * extra: `c_vec` has been modernized.
> * extra: The `sort` module has been removed. Use the `sort` method on
> mutable slices.
>
> * Tooling
> * The `rust` and `rusti` commands have been removed, due to lack of
> maintenance.
> * `rustdoc` was completely rewritten.
> * `rustdoc` can test code examples in documentation.
> * `rustpkg` can test packages with the argument, 'test'.
> * `rustpkg` supports arbitrary dependencies, including C libraries.
> * `rustc`'s support for generating debug info is improved again.
> * `rustc` has better error reporting for unbalanced delimiters.
> * `rustc`'s JIT support was removed due to bitrot.
> * Executables and static libraries can be built with LTO (-Z lto)
> * `rustc` adds a `--dep-info` flag for communicating dependencies to
> build tools.
>
>
> Contributors to Rust 0.9
> ------------------------
>
> Adrien T?tar <adri-from-59 at hotmail.fr> <adri-from-59 at hotmail.fr>
> Alan Andrade <alan.andradec at gmail.com> <alan.andradec at gmail.com>
> Alexandros Tasos <sdi1100085 at di.uoa.gr> <sdi1100085 at di.uoa.gr>
> Alex Crichton <alex at alexcrichton.com> <alex at alexcrichton.com>
> a_m0d <damien.schoof at gmail.com> <damien.schoof at gmail.com>
> Andreas Neuhaus <zargony at zargony.com> <zargony at zargony.com>
> Andreas Ots <andreasots at gmail.com> <andreasots at gmail.com>
> Andrei Formiga <archimedes_siracusa at hotmail.com><archimedes_siracusa at hotmail.com>
> Benjamin Herr <ben at 0x539.de> <ben at 0x539.de>
> Benjamin Peterson <benjamin at python.org> <benjamin at python.org>
> Birunthan Mohanathas <birunthan at mohanathas.com> <birunthan at mohanathas.com>
> blake2-ppc <blake2-ppc>
> Branimir <branimir at volomp.com> <branimir at volomp.com>
> Brendan Zabarauskas <bjzaba at yahoo.com.au> <bjzaba at yahoo.com.au>
> Brian Anderson <banderson at mozilla.com> <banderson at mozilla.com>
> Brian <brian.t.dawn at gmail.com> <brian.t.dawn at gmail.com>
> Cadence Marseille <cadencemarseille at gmail.com><cadencemarseille at gmail.com>
> Carl-Anton Ingmarsson <mail at carlanton.se> <mail at carlanton.se>
> Carol Willing <carolcode at willingconsulting.com><carolcode at willingconsulting.com>
> Carter Tazio Schonwald <carter.schonwald at gmail.com><carter.schonwald at gmail.com>
> chitra <chitra at chitra-HP-Pavilion-g6-Notebook-PC.(none)><chitra at chitra-HP-Pavilion-g6-Notebook-PC.%28none%29>
> Chris Morgan <me at chrismorgan.info> <me at chrismorgan.info>
> Chris Sainty <csainty at hotmail.com> <csainty at hotmail.com>
> Corey Richardson <corey at octayn.net> <corey at octayn.net>
> Dan Connolly <dckc at madmode.com> <dckc at madmode.com>
> Daniel Micay <danielmicay at gmail.com> <danielmicay at gmail.com>
> Dan Luu <danluu at gmail.com> <danluu at gmail.com>
> Dave Hodder <dmh at dmh.org.uk> <dmh at dmh.org.uk>
> David Creswick <dcrewi at gyrae.net> <dcrewi at gyrae.net>
> David Renshaw <dwrenshaw at gmail.com> <dwrenshaw at gmail.com>
> Diego Ongaro <ongaro at cs.stanford.edu> <ongaro at cs.stanford.edu>
> Dirkjan Bussink <d.bussink at gmail.com> <d.bussink at gmail.com>
> Dmitry Ermolov <epdmitry at yandex.ru> <epdmitry at yandex.ru>
> Do Nhat Minh <mrordinaire at gmail.com> <mrordinaire at gmail.com>
> Eduard Burtescu <edy.burt at gmail.com> <edy.burt at gmail.com>
> Edward Z. Yang <ezyang at cs.stanford.edu> <ezyang at cs.stanford.edu>
> eliovir <eliovir at gmail.com> <eliovir at gmail.com>
> Eric Biggers <ebiggers3 at gmail.com> <ebiggers3 at gmail.com>
> Eric Holk <eric.holk at gmail.com> <eric.holk at gmail.com>
> Erick Tryzelaar <erick.tryzelaar at gmail.com> <erick.tryzelaar at gmail.com>
> Erik Lyon <elyon001 at local.fake> <elyon001 at local.fake>
> Erik Price <erik.price16 at gmail.com> <erik.price16 at gmail.com>
> Fabrice Desr? <fabrice at desre.org> <fabrice at desre.org>
> Felix S. Klock II <pnkfelix at pnkfx.org> <pnkfelix at pnkfx.org>
> Flavio Percoco <flaper87 at gmail.com> <flaper87 at gmail.com>
> flo-l <lacknerflo at gmail.com> <lacknerflo at gmail.com>
> Florian Gilcher <florian.gilcher at asquera.de> <florian.gilcher at asquera.de>
> Florian Hahn <flo at fhahn.com> <flo at fhahn.com>
> Florian Zeitz <florob at babelmonkeys.de> <florob at babelmonkeys.de>
> g3xzh <g3xzh at yahoo.com> <g3xzh at yahoo.com>
> Gareth Smith <garethdanielsmith at gmail.com> <garethdanielsmith at gmail.com>
> Geoff Hill <geoff at geoffhill.org> <geoff at geoffhill.org>
> Geoffroy Couprie <geo.couprie at gmail.com> <geo.couprie at gmail.com>
> Georges Dubus <georges.dubus at compiletoi.net><georges.dubus at compiletoi.net>
> gifnksm <makoto.nksm+github at gmail.com> <makoto.nksm+github at gmail.com>
> Guillaume Pinot <texitoi at texitoi.eu> <texitoi at texitoi.eu>
> Gyorgy Andrasek <jurily at gmail.com> <jurily at gmail.com>
> Harry Marr <harry.marr at gmail.com> <harry.marr at gmail.com>
> Heather <heather at cynede.net> <heather at cynede.net>
> Huon Wilson <dbau.pp+github at gmail.com> <dbau.pp+github at gmail.com>
> Ian Daniher <it.daniher at gmail.com> <it.daniher at gmail.com>
> Igor Bukanov <igor at mir2.org> <igor at mir2.org>
> Isaac Dupree <antispam at idupree.com> <antispam at idupree.com>
> Jack Moffitt <jack at metajack.im> <jack at metajack.im>
> Jaemin Moon <jaemin.moon at samsung.com> <jaemin.moon at samsung.com>
> Jan Niklas Hasse <jhasse at gmail.com> <jhasse at gmail.com>
> Jannis Harder <jix at jixco.de> <jix at jixco.de>
> Jason Orendorff <jason.orendorff at gmail.com> <jason.orendorff at gmail.com>
> Jason Toffaletti <jason at topsy.com> <jason at topsy.com>
> Jay Anderson <jayanderson0 at gmail.com> <jayanderson0 at gmail.com>
> Jed Davis <jld at panix.com> <jld at panix.com>
> Jeff Olson <olson.jeffery at gmail.com> <olson.jeffery at gmail.com>
> Joe Schafer <joe at jschaf.com> <joe at jschaf.com>
> John Louis Walker <injyuw at gmail.com> <injyuw at gmail.com>
> Jordi Boggiano <j.boggiano at seld.be> <j.boggiano at seld.be>
> Joshua Yanovski <pythonesque at gmail.com> <pythonesque at gmail.com>
> Julia Evans <julia at jvns.ca> <julia at jvns.ca>
> Jyun-Yan You <jyyou at cs.nctu.edu.tw> <jyyou at cs.nctu.edu.tw>
> Keegan McAllister <kmcallister at mozilla.com> <kmcallister at mozilla.com>
> Kevin Ballard <kevin at sb.org> <kevin at sb.org>
> Kiet Tran <ktt3ja at gmail.com> <ktt3ja at gmail.com>
> klutzy <klutzytheklutzy at gmail.com> <klutzytheklutzy at gmail.com>
> kud1ing <github at kudling.de> <github at kudling.de>
> Leah Hanson <astrieanna at gmail.com> <astrieanna at gmail.com>
> LEE Wondong <wdlee91 at gmail.com> <wdlee91 at gmail.com>
> Le?o Testard <leo.testard at gmail.com> <leo.testard at gmail.com>
> Lindsey Kuper <lindsey at composition.al> <lindsey at composition.al>
> Luca Bruno <lucab at debian.org> <lucab at debian.org>
> Luis de Bethencourt <luis at debethencourt.com> <luis at debethencourt.com>
> Luqman Aden <laden at csclub.uwaterloo.ca> <laden at csclub.uwaterloo.ca>
> lyuts <dioxinu at gmail.com> <dioxinu at gmail.com>
> Mark Rowe <mrowe at bdash.net.nz> <mrowe at bdash.net.nz>
> Marvin L?bel <loebel.marvin at gmail.com> <loebel.marvin at gmail.com>
> Matt Carberry <carberry.matt at gmail.com> <carberry.matt at gmail.com>
> Matthew Auld <matthew.auld at intel.com> <matthew.auld at intel.com>
> Matthew Iselin <matthew at theiselins.net> <matthew at theiselins.net>
> Micah Chalmer <micah at micahchalmer.net> <micah at micahchalmer.net>
> Michael 'devbug' Williams <m.t.williams at live.com> <m.t.williams at live.com>
> Michael Letterle <michael.letterle at gmail.com> <michael.letterle at gmail.com>
> Michael Woerister <michaelwoerister at gmail>
> niftynif <nif.ward at gmail.com> <nif.ward at gmail.com>
> Niko Matsakis <niko at alum.mit.edu> <niko at alum.mit.edu>
> Noufal Ibrahim <noufal at nibrahim.net.in> <noufal at nibrahim.net.in>
> Olivier Saut <osaut at airpost.net> <osaut at airpost.net>
> osa1 <omeragacan at gmail.com> <omeragacan at gmail.com>
> Palmer Cox <p at lmercox.com> <p at lmercox.com>
> Patrick Walton <pcwalton at mimiga.net> <pcwalton at mimiga.net>
> Peter Zotov <whitequark at whitequark.org> <whitequark at whitequark.org>
> Philipp Br?schweiler <blei42 at gmail.com> <blei42 at gmail.com>
> Raphael Speyer <rspeyer at gmail.com> <rspeyer at gmail.com>
> reedlepee <reedlepee123 at gmail.com> <reedlepee123 at gmail.com>
> Richard Diamond <wichard at vitalitystudios.com><wichard at vitalitystudios.com>
> Robert Irelan <rirelan at gmail.com> <rirelan at gmail.com>
> Scott Lawrence <bytbox at gmail.com> <bytbox at gmail.com>
> S?bastien Chauvel <eichi237 at mailoo.org> <eichi237 at mailoo.org>
> S?bastien Crozet <developer at crozet.re> <developer at crozet.re>
> S?bastien Paolacci <sebastien.paolacci at gmail.com><sebastien.paolacci at gmail.com>
> Seo Sanghyeon <sanxiyn at gmail.com> <sanxiyn at gmail.com>
> sh8281.kim <sh8281.kim at samsung.com> <sh8281.kim at samsung.com>
> SiegeLord <slabode at aim.com> <slabode at aim.com>
> sp3d <sp3d at github>
> S Pradeep Kumar <gohanpra at gmail.com> <gohanpra at gmail.com>
> Steve Klabnik <steve at steveklabnik.com> <steve at steveklabnik.com>
> Steven Fackler <sfackler at gmail.com> <sfackler at gmail.com>
> Strahinja Val Markovic <val at markovic.io> <val at markovic.io>
> Tim Chevalier <chevalier at alum.wellesley.edu><chevalier at alum.wellesley.edu>
> Tomas Sedovic <tomas at sedovic.cz> <tomas at sedovic.cz>
> Vadim Chugunov <vadimcn at gmail.com> <vadimcn at gmail.com>
> Vijay Korapaty <rust at korapaty.com> <rust at korapaty.com>
> Volker Mische <volker.mische at gmail.com> <volker.mische at gmail.com>
> Young-il Choi <duddlf.choi at samsung.com> <duddlf.choi at samsung.com>
> Zach Kamsler <smoo.master at gmail.com> <smoo.master at gmail.com>
> Zack Corr <zack at z0w0.me> <zack at z0w0.me>
> Ziad Hatahet <hatahet at gmail.com> <hatahet at gmail.com>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/79499c48/attachment-0001.html>

From irrequietus at gmail.com  Thu Jan  9 22:46:07 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Fri, 10 Jan 2014 08:46:07 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
Message-ID: <abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>


Hello,

Having a build system entirely dependent of Rust alone, would make the entire experience in deploying the language extremely cohere. The only counter - argument is indeed that it would require some work to get this to fruition. I would like to know if this has any chance of getting priority soon enough.

G.

Corey Richardson <corey at octayn.net> wrote:
>Hey all,
>
>The build system has grown a fair bit of complexity, and is getting
>hard to understand. I've been thinking about what could replace it
>moving forward. Most of the complexity stems from having to self-host
>(ie, staging) and cross compilation (which target are we compiling
>for, and with which host?)

[...]

>3. Write a build system in Rust.
>
>This would take care of everything for us, using ourselves. We'd have
>a small script fetch the snapshot and build the build system, and then
>hand off the rest of the build to it. This has the advantage of one
>less build-time dependency, but the disadvantage that it's going to be
>a lot of work. This could also potentially output tup, ninja[3], or
>another form of build script after taking configuration options and
>so-forth. It could also integrate with librustc for smart handling of
>comments-or-test-only changes, an issue near to my heart[4]. This
>build system could potentially be rustpkg, but as I understand it the
>current idea is to *remove* rustpkg's ability as a build system and
>keep it as a package manager. (At least, that is what I've understood
>of recent discussion; this could be wrong.)

[...]

From carter.schonwald at gmail.com  Thu Jan  9 23:43:17 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Fri, 10 Jan 2014 02:43:17 -0500
Subject: [rust-dev]  RFC: Future of the Build System
In-Reply-To: <abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
Message-ID: <CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>

If the in rust approach is chosen, I warmly recommend checking out some of
the design ideas in Shake.  Shake has a pretty nice design that allows for
 dynamic build deps (in make systems the way around that is to use make to
make your make files), and a few other neat ideas, including but not
limited to playing nice with ninja files (which I believe cmake can
generate too).

http://community.haskell.org/~ndm/shake/
http://hackage.haskell.org/package/shake

On Friday, January 10, 2014, George Makrydakis wrote:

>
> Hello,
>
> Having a build system entirely dependent of Rust alone, would make the
> entire experience in deploying the language extremely cohere. The only
> counter - argument is indeed that it would require some work to get this to
> fruition. I would like to know if this has any chance of getting priority
> soon enough.
>
> G.
>
> Corey Richardson <corey at octayn.net> wrote:
> >Hey all,
> >
> >The build system has grown a fair bit of complexity, and is getting
> >hard to understand. I've been thinking about what could replace it
> >moving forward. Most of the complexity stems from having to self-host
> >(ie, staging) and cross compilation (which target are we compiling
> >for, and with which host?)
>
> [...]
>
> >3. Write a build system in Rust.
> >
> >This would take care of everything for us, using ourselves. We'd have
> >a small script fetch the snapshot and build the build system, and then
> >hand off the rest of the build to it. This has the advantage of one
> >less build-time dependency, but the disadvantage that it's going to be
> >a lot of work. This could also potentially output tup, ninja[3], or
> >another form of build script after taking configuration options and
> >so-forth. It could also integrate with librustc for smart handling of
> >comments-or-test-only changes, an issue near to my heart[4]. This
> >build system could potentially be rustpkg, but as I understand it the
> >current idea is to *remove* rustpkg's ability as a build system and
> >keep it as a package manager. (At least, that is what I've understood
> >of recent discussion; this could be wrong.)
>
> [...]
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/795a2095/attachment.html>

From gaetan at xeberon.net  Fri Jan 10 00:16:49 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 10 Jan 2014 09:16:49 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
Message-ID: <CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>

I am not in favor of a customized build system. For instance boost library
use their jam build system, and i never figured how to use it in my
projects.

I push to use standard and well proved build system like cmake or scons, at
least for major components. This would give a nice example of how to use it
in any projects.
 Le 10 janv. 2014 08:43, "Carter Schonwald" <carter.schonwald at gmail.com> a
?crit :

> If the in rust approach is chosen, I warmly recommend checking out some of
> the design ideas in Shake.  Shake has a pretty nice design that allows for
>  dynamic build deps (in make systems the way around that is to use make to
> make your make files), and a few other neat ideas, including but not
> limited to playing nice with ninja files (which I believe cmake can
> generate too).
>
> http://community.haskell.org/~ndm/shake/
> http://hackage.haskell.org/package/shake
>
> On Friday, January 10, 2014, George Makrydakis wrote:
>
>>
>> Hello,
>>
>> Having a build system entirely dependent of Rust alone, would make the
>> entire experience in deploying the language extremely cohere. The only
>> counter - argument is indeed that it would require some work to get this to
>> fruition. I would like to know if this has any chance of getting priority
>> soon enough.
>>
>> G.
>>
>> Corey Richardson <corey at octayn.net> wrote:
>> >Hey all,
>> >
>> >The build system has grown a fair bit of complexity, and is getting
>> >hard to understand. I've been thinking about what could replace it
>> >moving forward. Most of the complexity stems from having to self-host
>> >(ie, staging) and cross compilation (which target are we compiling
>> >for, and with which host?)
>>
>> [...]
>>
>> >3. Write a build system in Rust.
>> >
>> >This would take care of everything for us, using ourselves. We'd have
>> >a small script fetch the snapshot and build the build system, and then
>> >hand off the rest of the build to it. This has the advantage of one
>> >less build-time dependency, but the disadvantage that it's going to be
>> >a lot of work. This could also potentially output tup, ninja[3], or
>> >another form of build script after taking configuration options and
>> >so-forth. It could also integrate with librustc for smart handling of
>> >comments-or-test-only changes, an issue near to my heart[4]. This
>> >build system could potentially be rustpkg, but as I understand it the
>> >current idea is to *remove* rustpkg's ability as a build system and
>> >keep it as a package manager. (At least, that is what I've understood
>> >of recent discussion; this could be wrong.)
>>
>> [...]
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/983be2ae/attachment.html>

From leebraid at gmail.com  Fri Jan 10 00:34:32 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 10 Jan 2014 08:34:32 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
Message-ID: <52CFB098.8010100@gmail.com>

On 10/01/14 08:16, Gaetan wrote:
>
> I am not in favor of a customized build system. For instance boost 
> library use their jam build system, and i never figured how to use it 
> in my projects.
>
> I push to use standard and well proved build system like cmake or 
> scons, at least for major components. This would give a nice example 
> of how to use it in any projects.
>

I'd agree with that on both counts: the principle of using something 
standard, and the two recommendations.

CMake would probably get my vote, because it's not so much a build tool, 
as a meta tool for whichever system you prefer, so it would fit in well 
with various platform-specific IDEs, unusual platforms (android, 
embedded, ...), etc.  That said, scons is also a strong contender, and 
which of the two is more open to integrating patches and working with 
new languages is very much worth considering.

I think Rust will be contributing to the wider community by lending its 
support (and patches) to a common, modern build system, AND it will get 
something back in terms of users who already know the build system.


>     On Friday, January 10, 2014, George Makrydakis wrote:
>
>
>         Hello,
>
>         Having a build system entirely dependent of Rust alone, would
>         make the entire experience in deploying the language extremely
>         cohere. The only counter - argument is indeed that it would
>         require some work to get this to fruition. I would like to
>         know if this has any chance of getting priority soon enough.
>

Bear in mind that Debian are having a lot of issues packaging Rust 
already, because it self-compiles.  If the build tool also had a Rust 
pre-dependency, that would be a big step backwards.


-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/86d0a549/attachment-0001.html>

From jhasse at gmail.com  Fri Jan 10 00:54:21 2014
From: jhasse at gmail.com (Jan Niklas Hasse)
Date: Fri, 10 Jan 2014 09:54:21 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
Message-ID: <CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>

Have you heart about waf? http://code.google.com/p/waf/

It only depends on Python so this would not result in another dependency.
The python script (< 200 kB) can be included in the repository.

I am all for using rustpkg though. And I'm strongly against cmake, because
I don't know its language and don't like a build system which doesn't use
an already existing one (like scons is using Python). Also cmake still
depends on make (or even worse Visual Studio / Xcode).


2014/1/10 Corey Richardson <corey at octayn.net>

> Hey all,
>
> The build system has grown a fair bit of complexity, and is getting
> hard to understand. I've been thinking about what could replace it
> moving forward. Most of the complexity stems from having to self-host
> (ie, staging) and cross compilation (which target are we compiling
> for, and with which host?)
>
> Our build system must:
>
> 1. Work on all the platforms we support
> 2. Be able to track dependencies.
>
> Our ideal build system should:
>
> 1. Require minimal build-time dependencies
> 2. Allow ease of staging and cross compilation
> 3. Be easy to extend as we grow
> 4. Have readable build scripts
> 5. Have advanced configuration ability (NO_REBUILD, NO_BENCH, etc
> should all be retained)
>
> There are a few options:
>
> 1. Rework the current makefiles to be nicer.
>
> I'm not sure if this is feasible. Some stuff certainly could be
> easier, but the inherent problems of make (nested evals + calls, no
> named parameters (what does $(1) mean here, etc), general ugliness)
> make this unlikely to be a worthwhile effort, besides factoring out
> some of the current boilerplate.
>
> 2. Use a different build system.
>
> The major option here seems to be cmake[1], although I've heard
> murmurings of tup[2] and some other obscure things. I'm unsure tup is
> going to be of much help here. With our compilation model,
> fine-grained file-based dependencies are not very useful. However,
> it's awesome bottom-up dependency model could be neat. It's possible
> that we could use it with a combination of:
>
> 3. Write a build system in Rust.
>
> This would take care of everything for us, using ourselves. We'd have
> a small script fetch the snapshot and build the build system, and then
> hand off the rest of the build to it. This has the advantage of one
> less build-time dependency, but the disadvantage that it's going to be
> a lot of work. This could also potentially output tup, ninja[3], or
> another form of build script after taking configuration options and
> so-forth. It could also integrate with librustc for smart handling of
> comments-or-test-only changes, an issue near to my heart[4]. This
> build system could potentially be rustpkg, but as I understand it the
> current idea is to *remove* rustpkg's ability as a build system and
> keep it as a package manager. (At least, that is what I've understood
> of recent discussion; this could be wrong.)
>
> 4. Write a build system in $LANG.
>
> Python seems to be a good choice here, since we already depend on it
> for fetching the snapshot etc. This still has the disadvantage of
> being a lot of work, but would perhaps be easier than writing a build
> system in Rust. We would definitely lose hacker points for doing so.
>
> There are undoubtedly other options as well. Does anyone have good
> ideas or opinions on what we should do? Personally I think that 3 is
> going to be the best option, unless there's some super amazing build
> system I haven't heard of it. Which is totally possible!
>
> [1]: http://www.cmake.org/
> [2]: http://gittup.org/tup/
> [3]: http://martine.github.io/ninja/
> [4]: https://github.com/mozilla/rust/issues/6522
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/ce7c572c/attachment.html>

From gaetan at xeberon.net  Fri Jan 10 02:06:46 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 10 Jan 2014 11:06:46 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
Message-ID: <CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>

See this page that compares scons to other build system:
http://www.scons.org/wiki/SconsVsOtherBuildTools

I still personally recommend CMake. One of the major feature is that it is
NOT a build system, it a script factory that generates system dependant
build file: Makefile for GNU, Visual Studio for Windows, Eclipse
projects,...
It actually replaces all bash scripts we usually write on large projects to
trigger the builds.

-----
Gaetan



2014/1/10 Jan Niklas Hasse <jhasse at gmail.com>

>
> Have you heart about waf? http://code.google.com/p/waf/
>
> It only depends on Python so this would not result in another dependency.
> The python script (< 200 kB) can be included in the repository.
>
> I am all for using rustpkg though. And I'm strongly against cmake, because
> I don't know its language and don't like a build system which doesn't use
> an already existing one (like scons is using Python). Also cmake still
> depends on make (or even worse Visual Studio / Xcode).
>
>
> 2014/1/10 Corey Richardson <corey at octayn.net>
>
>> Hey all,
>>
>> The build system has grown a fair bit of complexity, and is getting
>> hard to understand. I've been thinking about what could replace it
>> moving forward. Most of the complexity stems from having to self-host
>> (ie, staging) and cross compilation (which target are we compiling
>> for, and with which host?)
>>
>> Our build system must:
>>
>> 1. Work on all the platforms we support
>> 2. Be able to track dependencies.
>>
>> Our ideal build system should:
>>
>> 1. Require minimal build-time dependencies
>> 2. Allow ease of staging and cross compilation
>> 3. Be easy to extend as we grow
>> 4. Have readable build scripts
>> 5. Have advanced configuration ability (NO_REBUILD, NO_BENCH, etc
>> should all be retained)
>>
>> There are a few options:
>>
>> 1. Rework the current makefiles to be nicer.
>>
>> I'm not sure if this is feasible. Some stuff certainly could be
>> easier, but the inherent problems of make (nested evals + calls, no
>> named parameters (what does $(1) mean here, etc), general ugliness)
>> make this unlikely to be a worthwhile effort, besides factoring out
>> some of the current boilerplate.
>>
>> 2. Use a different build system.
>>
>> The major option here seems to be cmake[1], although I've heard
>> murmurings of tup[2] and some other obscure things. I'm unsure tup is
>> going to be of much help here. With our compilation model,
>> fine-grained file-based dependencies are not very useful. However,
>> it's awesome bottom-up dependency model could be neat. It's possible
>> that we could use it with a combination of:
>>
>> 3. Write a build system in Rust.
>>
>> This would take care of everything for us, using ourselves. We'd have
>> a small script fetch the snapshot and build the build system, and then
>> hand off the rest of the build to it. This has the advantage of one
>> less build-time dependency, but the disadvantage that it's going to be
>> a lot of work. This could also potentially output tup, ninja[3], or
>> another form of build script after taking configuration options and
>> so-forth. It could also integrate with librustc for smart handling of
>> comments-or-test-only changes, an issue near to my heart[4]. This
>> build system could potentially be rustpkg, but as I understand it the
>> current idea is to *remove* rustpkg's ability as a build system and
>> keep it as a package manager. (At least, that is what I've understood
>> of recent discussion; this could be wrong.)
>>
>> 4. Write a build system in $LANG.
>>
>> Python seems to be a good choice here, since we already depend on it
>> for fetching the snapshot etc. This still has the disadvantage of
>> being a lot of work, but would perhaps be easier than writing a build
>> system in Rust. We would definitely lose hacker points for doing so.
>>
>> There are undoubtedly other options as well. Does anyone have good
>> ideas or opinions on what we should do? Personally I think that 3 is
>> going to be the best option, unless there's some super amazing build
>> system I haven't heard of it. Which is totally possible!
>>
>> [1]: http://www.cmake.org/
>> [2]: http://gittup.org/tup/
>> [3]: http://martine.github.io/ninja/
>> [4]: https://github.com/mozilla/rust/issues/6522
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/47e31bbd/attachment.html>

From robertknight at gmail.com  Fri Jan 10 03:19:26 2014
From: robertknight at gmail.com (Robert Knight)
Date: Fri, 10 Jan 2014 11:19:26 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
Message-ID: <CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>

Hello,

CMake does have a few things going for it:

- It is a popular choice for C++ projects, including LLVM, WebKit and
others, so this would provide familiarity from developers coming from
C++
- As mentioned, it is a meta-build system which can generate project
files for Xcode, Visual Studio, Ninja and others. This is very useful
for cross-platform development
- It has a good and sizable ecosystem (full time active maintainers,
documentation, user questions on StackOverflow etc.)
- It has a large collection of modules to find packages, detect
compiler versions etc.

Downsides for CMake include:

- The built script language is primitive and not a familiar language
like Python. It is easy enough to use for writing a build project file
but for more complex logic, I've found it easier to write separate
commands in Python/Ruby which CMake then invokes.
- CMakeLists.txt files are not declarative documents that can be
easily parsed by other tools for eg. IDE integration. Having said
that, the CMake developers are aware of the benefits of more
declarative ways of specifying things and there is a general trend in
that direction.
- Adds a non-rusty dependency to rust.

Regards,
Rob.

On 10 January 2014 10:06, Gaetan <gaetan at xeberon.net> wrote:
> See this page that compares scons to other build system:
> http://www.scons.org/wiki/SconsVsOtherBuildTools
>
> I still personally recommend CMake. One of the major feature is that it is
> NOT a build system, it a script factory that generates system dependant
> build file: Makefile for GNU, Visual Studio for Windows, Eclipse
> projects,...
> It actually replaces all bash scripts we usually write on large projects to
> trigger the builds.
>
> -----
> Gaetan
>
>
>
> 2014/1/10 Jan Niklas Hasse <jhasse at gmail.com>
>>
>>
>> Have you heart about waf? http://code.google.com/p/waf/
>>
>> It only depends on Python so this would not result in another dependency.
>> The python script (< 200 kB) can be included in the repository.
>>
>> I am all for using rustpkg though. And I'm strongly against cmake, because
>> I don't know its language and don't like a build system which doesn't use an
>> already existing one (like scons is using Python). Also cmake still depends
>> on make (or even worse Visual Studio / Xcode).
>>
>>
>> 2014/1/10 Corey Richardson <corey at octayn.net>
>>>
>>> Hey all,
>>>
>>> The build system has grown a fair bit of complexity, and is getting
>>> hard to understand. I've been thinking about what could replace it
>>> moving forward. Most of the complexity stems from having to self-host
>>> (ie, staging) and cross compilation (which target are we compiling
>>> for, and with which host?)
>>>
>>> Our build system must:
>>>
>>> 1. Work on all the platforms we support
>>> 2. Be able to track dependencies.
>>>
>>> Our ideal build system should:
>>>
>>> 1. Require minimal build-time dependencies
>>> 2. Allow ease of staging and cross compilation
>>> 3. Be easy to extend as we grow
>>> 4. Have readable build scripts
>>> 5. Have advanced configuration ability (NO_REBUILD, NO_BENCH, etc
>>> should all be retained)
>>>
>>> There are a few options:
>>>
>>> 1. Rework the current makefiles to be nicer.
>>>
>>> I'm not sure if this is feasible. Some stuff certainly could be
>>> easier, but the inherent problems of make (nested evals + calls, no
>>> named parameters (what does $(1) mean here, etc), general ugliness)
>>> make this unlikely to be a worthwhile effort, besides factoring out
>>> some of the current boilerplate.
>>>
>>> 2. Use a different build system.
>>>
>>> The major option here seems to be cmake[1], although I've heard
>>> murmurings of tup[2] and some other obscure things. I'm unsure tup is
>>> going to be of much help here. With our compilation model,
>>> fine-grained file-based dependencies are not very useful. However,
>>> it's awesome bottom-up dependency model could be neat. It's possible
>>> that we could use it with a combination of:
>>>
>>> 3. Write a build system in Rust.
>>>
>>> This would take care of everything for us, using ourselves. We'd have
>>> a small script fetch the snapshot and build the build system, and then
>>> hand off the rest of the build to it. This has the advantage of one
>>> less build-time dependency, but the disadvantage that it's going to be
>>> a lot of work. This could also potentially output tup, ninja[3], or
>>> another form of build script after taking configuration options and
>>> so-forth. It could also integrate with librustc for smart handling of
>>> comments-or-test-only changes, an issue near to my heart[4]. This
>>> build system could potentially be rustpkg, but as I understand it the
>>> current idea is to *remove* rustpkg's ability as a build system and
>>> keep it as a package manager. (At least, that is what I've understood
>>> of recent discussion; this could be wrong.)
>>>
>>> 4. Write a build system in $LANG.
>>>
>>> Python seems to be a good choice here, since we already depend on it
>>> for fetching the snapshot etc. This still has the disadvantage of
>>> being a lot of work, but would perhaps be easier than writing a build
>>> system in Rust. We would definitely lose hacker points for doing so.
>>>
>>> There are undoubtedly other options as well. Does anyone have good
>>> ideas or opinions on what we should do? Personally I think that 3 is
>>> going to be the best option, unless there's some super amazing build
>>> system I haven't heard of it. Which is totally possible!
>>>
>>> [1]: http://www.cmake.org/
>>> [2]: http://gittup.org/tup/
>>> [3]: http://martine.github.io/ninja/
>>> [4]: https://github.com/mozilla/rust/issues/6522
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From lists at dhardy.name  Fri Jan 10 07:06:01 2014
From: lists at dhardy.name (Diggory Hardy)
Date: Fri, 10 Jan 2014 16:06:01 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52CFB098.8010100@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
Message-ID: <1949520.i7MrgNSkXU@yoga.dhardy>

A further point in favour of CMake is that it would make multi-language 
projects easier to manage, in particular transitioning a "C-family" project to 
Rust.

On Friday 10 January 2014 08:34:32 Lee Braiden wrote:
> On 10/01/14 08:16, Gaetan wrote:
> > I am not in favor of a customized build system. For instance boost
> > library use their jam build system, and i never figured how to use it
> > in my projects.
> > 
> > I push to use standard and well proved build system like cmake or
> > scons, at least for major components. This would give a nice example
> > of how to use it in any projects.
> 
> I'd agree with that on both counts: the principle of using something
> standard, and the two recommendations.
> 
> CMake would probably get my vote, because it's not so much a build tool,
> as a meta tool for whichever system you prefer, so it would fit in well
> with various platform-specific IDEs, unusual platforms (android,
> embedded, ...), etc.  That said, scons is also a strong contender, and
> which of the two is more open to integrating patches and working with
> new languages is very much worth considering.
> 
> I think Rust will be contributing to the wider community by lending its
> support (and patches) to a common, modern build system, AND it will get
> something back in terms of users who already know the build system.
> 
> >     On Friday, January 10, 2014, George Makrydakis wrote:
> >         Hello,
> >         
> >         Having a build system entirely dependent of Rust alone, would
> >         make the entire experience in deploying the language extremely
> >         cohere. The only counter - argument is indeed that it would
> >         require some work to get this to fruition. I would like to
> >         know if this has any chance of getting priority soon enough.
> 
> Bear in mind that Debian are having a lot of issues packaging Rust
> already, because it self-compiles.  If the build tool also had a Rust
> pre-dependency, that would be a big step backwards.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/3d1ca79d/attachment.sig>

From corey at octayn.net  Fri Jan 10 07:08:09 2014
From: corey at octayn.net (Corey Richardson)
Date: Fri, 10 Jan 2014 10:08:09 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <1949520.i7MrgNSkXU@yoga.dhardy>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com> <1949520.i7MrgNSkXU@yoga.dhardy>
Message-ID: <CA++BO6QDSccftaJMtCcWO5oXS=wrde=2Yot5M3HZMk5bTUDF6g@mail.gmail.com>

This RFC isn't about using a single build system for everything, it's
the build system we use to build Rust itself.

On Fri, Jan 10, 2014 at 10:06 AM, Diggory Hardy <lists at dhardy.name> wrote:
> A further point in favour of CMake is that it would make multi-language
> projects easier to manage, in particular transitioning a "C-family" project to
> Rust.
>
> On Friday 10 January 2014 08:34:32 Lee Braiden wrote:
>> On 10/01/14 08:16, Gaetan wrote:
>> > I am not in favor of a customized build system. For instance boost
>> > library use their jam build system, and i never figured how to use it
>> > in my projects.
>> >
>> > I push to use standard and well proved build system like cmake or
>> > scons, at least for major components. This would give a nice example
>> > of how to use it in any projects.
>>
>> I'd agree with that on both counts: the principle of using something
>> standard, and the two recommendations.
>>
>> CMake would probably get my vote, because it's not so much a build tool,
>> as a meta tool for whichever system you prefer, so it would fit in well
>> with various platform-specific IDEs, unusual platforms (android,
>> embedded, ...), etc.  That said, scons is also a strong contender, and
>> which of the two is more open to integrating patches and working with
>> new languages is very much worth considering.
>>
>> I think Rust will be contributing to the wider community by lending its
>> support (and patches) to a common, modern build system, AND it will get
>> something back in terms of users who already know the build system.
>>
>> >     On Friday, January 10, 2014, George Makrydakis wrote:
>> >         Hello,
>> >
>> >         Having a build system entirely dependent of Rust alone, would
>> >         make the entire experience in deploying the language extremely
>> >         cohere. The only counter - argument is indeed that it would
>> >         require some work to get this to fruition. I would like to
>> >         know if this has any chance of getting priority soon enough.
>>
>> Bear in mind that Debian are having a lot of issues packaging Rust
>> already, because it self-compiles.  If the build tool also had a Rust
>> pre-dependency, that would be a big step backwards.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From slabode at aim.com  Fri Jan 10 07:17:00 2014
From: slabode at aim.com (SiegeLord)
Date: Fri, 10 Jan 2014 10:17:00 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
Message-ID: <52D00EEC.6090306@aim.com>

On 01/10/2014 06:19 AM, Robert Knight wrote:
> Hello,
>
> CMake does have a few things going for it:

One more consideration is that LLVM can be built with CMake afaik, so if 
we switch to CMake we may be able to drop the autotools dependency, 
which is a more annoying dependency to fulfill (on Windows) than CMake 
(I don't know if Rust has other components that require autotools though).

Along the same lines, we also require Python for whatever reason, so 
SCons would be a natural option too (it can't build LLVM though). I'd 
only use SCons conditional on it accepting a Rust dependency scanner 
into its source: using its current custom scanner infrastructure is not 
practical as I found out.

As for waf... they and Debian have been having a tiff (e.g. see 
http://waf-devel.blogspot.com/2012/01/debian.html , 
https://lists.debian.org/debian-devel/2012/02/msg00207.html ). I would 
not suggest it based on that.

-SL


From nnythm at gmail.com  Fri Jan 10 07:20:42 2014
From: nnythm at gmail.com (Nakamura)
Date: Fri, 10 Jan 2014 10:20:42 -0500
Subject: [rust-dev] returning functions in rust
Message-ID: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>

I'm new to rust, and tried going through some of the examples from the OS
class[0] that was taught in rust.  However, I got tripped up by the
exercise, "make a function that takes an integer n and another function |x|
-> x, and returns a function that is n applications of the original
function."

I've been trying to see what the limits of rust are if you are using it
without the runtime/managed pointers etc, and it seems like I stumble
against one of the limits when trying to return functions.  The big
question is where to allocate the new function I want to return.

Like other people who are new to rust, I made the mistake of thinking that
lifetime parameters actually affecting lifetimes[1].  If this were the
case, it would be sensible to write this as a recursive function which has
the same lifetime as the function that you pass in.

Is there a safe way other than using managed pointers to return functions?
 It looks like you can use externs and call it a day (or you can maybe use
unsafe?  I haven't explored it yet), but that doesn't seem satisfactory.  I
saw a thread that mentioned unboxed closures, but couldn't find any other
details about them.  Maybe that's what I'm looking for?

If I do end up having to use managed pointers to return functions, will the
runtime infect everything I do, or could I just designate certain threads
(green or otherwise) gc-threads and go about my day on threads which don't
need to worry about gc?

[0]: http://rust-class.org/
[1]:
http://stackoverflow.com/questions/19213494/lifetime-of-a-lambda-expression-in-rust/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/3becbdf5/attachment.html>

From gaetan at xeberon.net  Fri Jan 10 07:53:14 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 10 Jan 2014 16:53:14 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D00EEC.6090306@aim.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
	<52D00EEC.6090306@aim.com>
Message-ID: <CANK7tAFdm_DneBuOyN9eprE2ec=1raZY1z+psw69yKeQ724ufA@mail.gmail.com>

I also agree that the way waf works is quite weird to use, but this is
actually how most of the installers works under windows or some on MacOS:
the code of the installers is embedded into the distributed package. This
violates the debian packaging rules, and I think this will be the same with
rust.

I however really like this approach. You don't have a huge among of
dependencies to setup in order to build your package. This is not a problem
on debian where apt does to marveillous job, but on Windows/Mac/generic
linux/arm, .. this is a nightmare.

One more point in favor of CMake to build rust: you can build
android/arm/misc (thanks to Makefile) with the same CMakeList.txt files, or
with external module inclusion. I also agree that its syntax used to be
quite ugly (the famous if() / else() / endif()), but not so much in the
lastest versions...
But if you require python for building, scons is the perfect, natural
candidate.

-----
Gaetan



2014/1/10 SiegeLord <slabode at aim.com>

> On 01/10/2014 06:19 AM, Robert Knight wrote:
>
>> Hello,
>>
>> CMake does have a few things going for it:
>>
>
> One more consideration is that LLVM can be built with CMake afaik, so if
> we switch to CMake we may be able to drop the autotools dependency, which
> is a more annoying dependency to fulfill (on Windows) than CMake (I don't
> know if Rust has other components that require autotools though).
>
> Along the same lines, we also require Python for whatever reason, so SCons
> would be a natural option too (it can't build LLVM though). I'd only use
> SCons conditional on it accepting a Rust dependency scanner into its
> source: using its current custom scanner infrastructure is not practical as
> I found out.
>
> As for waf... they and Debian have been having a tiff (e.g. see
> http://waf-devel.blogspot.com/2012/01/debian.html ,
> https://lists.debian.org/debian-devel/2012/02/msg00207.html ). I would
> not suggest it based on that.
>
> -SL
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/d1619845/attachment-0001.html>

From jhasse at gmail.com  Fri Jan 10 08:53:56 2014
From: jhasse at gmail.com (Jan Niklas Hasse)
Date: Fri, 10 Jan 2014 17:53:56 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
Message-ID: <CALckf6j5y=CVOAowfyYX6TmFpOLq41H3j_1NcN_xfTG5k3AsOA@mail.gmail.com>

2014/1/10 Robert Knight <robertknight at gmail.com>
>
> Hello,
>
> CMake does have a few things going for it:
>
> - It is a popular choice for C++ projects, including LLVM, WebKit and
> others, so this would provide familiarity from developers coming from
> C++

Same for scons (Blender, MongoDB) and waf (Samba, node.js).

>
> - As mentioned, it is a meta-build system which can generate project
> files for Xcode, Visual Studio, Ninja and others. This is very useful
> for cross-platform development

I don't think this is useful for Rust itself as these IDEs don't
support Rust anyway and some things won't work (like copying files
around which is currently done in the Makefiles and seems to be hard
if not impossible to do in VC++/Xcode to me).

Some counter arguments for cmake (I haven't worked with many cmake
projects though, so these points are just my personal opinion, sorry
if I'm spreading FUD):

- Some projects [1] include handcrafted VC++ and Xcode project files
anyway, even if using cmake. Looks to me like cmake's generator isn't
worth it.
- To create Makefiles for MinGW you have to use `cmake -G "MinGW
Makefiles"` which I find rather ugly looking (I always have to look it
up).
- CMakeLists.txt often look ugly [2] and don't follow any particular
style (lower case vs. upper case, etc.).
- Using cmake on Windows wasn't as pleasant as scons or autotools
(when working with msys or cmd.exe and not Visual Studio).

I have to admit ccmake is nice though!

[1] https://github.com/slembcke/Chipmunk2D
[2] https://github.com/rougier/freetype-gl/blob/master/CMakeLists.txt

From thadguidry at gmail.com  Fri Jan 10 09:38:56 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Fri, 10 Jan 2014 11:38:56 -0600
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CALckf6j5y=CVOAowfyYX6TmFpOLq41H3j_1NcN_xfTG5k3AsOA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
	<CALckf6j5y=CVOAowfyYX6TmFpOLq41H3j_1NcN_xfTG5k3AsOA@mail.gmail.com>
Message-ID: <CAChbWaO0KJfwySMxUV-HQ7WC=oohYJmr-AksepLnZ2B5M1-Bnw@mail.gmail.com>

Best Reason ever for a Rust Build System = You Prove Rust Itself.

So get hacking on a Rust Build System.

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/602ab659/attachment.html>

From robertknight at gmail.com  Fri Jan 10 09:57:32 2014
From: robertknight at gmail.com (Robert Knight)
Date: Fri, 10 Jan 2014 17:57:32 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAChbWaO0KJfwySMxUV-HQ7WC=oohYJmr-AksepLnZ2B5M1-Bnw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
	<CALckf6j5y=CVOAowfyYX6TmFpOLq41H3j_1NcN_xfTG5k3AsOA@mail.gmail.com>
	<CAChbWaO0KJfwySMxUV-HQ7WC=oohYJmr-AksepLnZ2B5M1-Bnw@mail.gmail.com>
Message-ID: <CAJGrnh2_hdNgbCFNO+1FX=Pa17-DX5yzkH0BmKiTsMbmeTcE=A@mail.gmail.com>

> - CMakeLists.txt often look ugly [2] and don't follow any particular
> style (lower case vs. upper case, etc.).

A fair point, though a number of projects do have coding conventions
for CMakeLists.txt files, one of which could be adopted - eg.
http://techbase.kde.org/Policies/CMake_Coding_Style

Regards,
Rob.

On 10 January 2014 17:38, Thad Guidry <thadguidry at gmail.com> wrote:
> Best Reason ever for a Rust Build System = You Prove Rust Itself.
>
> So get hacking on a Rust Build System.
>
> --
> -Thad
> +ThadGuidry
> Thad on LinkedIn
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From pcwalton at mozilla.com  Fri Jan 10 10:18:36 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 10 Jan 2014 10:18:36 -0800
Subject: [rust-dev] returning functions in rust
In-Reply-To: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
References: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
Message-ID: <52D0397C.3010305@mozilla.com>

On 1/10/14 7:20 AM, Nakamura wrote:
> I'm new to rust, and tried going through some of the examples from the
> OS class[0] that was taught in rust.  However, I got tripped up by the
> exercise, "make a function that takes an integer n and another function
> |x| -> x, and returns a function that is n applications of the original
> function."
>
> I've been trying to see what the limits of rust are if you are using it
> without the runtime/managed pointers etc, and it seems like I stumble
> against one of the limits when trying to return functions.  The big
> question is where to allocate the new function I want to return.

Rust won't automatically allocate closed-over variables on the heap. 
This limits the ability to write code like this naturally, but you get 
the benefit that all allocations are immediately visible and under the 
control of the programmer.

I would not suggest trying to use managed pointers for this. Instead I 
would suggest `proc`, which is allocated on the exchange heap and can 
close over variables. This should be sufficient for the question as 
posed, as long as the "another function" has a `'static` bound (`'static 
|x| -> x`).

Patrick


From danielmicay at gmail.com  Fri Jan 10 10:27:11 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 10 Jan 2014 13:27:11 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52CFB098.8010100@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
Message-ID: <CA+DvKQKO_m0BR2n3a7naUqfU_+SQA_wi_tR+aCbfKxHMQ=0Oeg@mail.gmail.com>

On Fri, Jan 10, 2014 at 3:34 AM, Lee Braiden <leebraid at gmail.com> wrote:
> On 10/01/14 08:16, Gaetan wrote:
>
> Bear in mind that Debian are having a lot of issues packaging Rust already,
> because it self-compiles.  If the build tool also had a Rust pre-dependency,
> that would be a big step backwards.

What kind of issues? I've had close to zero issues maintaining a
package in the Arch repositories along with a nightly build. The only
difficulty has been the occasionally Makefile race with `-j8`.

It would be nice if it wasn't necessary to strip rpaths with chrpath too...

From kevin at sb.org  Fri Jan 10 10:28:04 2014
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 10 Jan 2014 10:28:04 -0800
Subject: [rust-dev] returning functions in rust
In-Reply-To: <52D0397C.3010305@mozilla.com>
References: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
	<52D0397C.3010305@mozilla.com>
Message-ID: <F34DD63D-9A12-4BD9-A33B-5EA6E43F9DCB@sb.org>

On Jan 10, 2014, at 10:18 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 1/10/14 7:20 AM, Nakamura wrote:
>> I'm new to rust, and tried going through some of the examples from the
>> OS class[0] that was taught in rust.  However, I got tripped up by the
>> exercise, "make a function that takes an integer n and another function
>> |x| -> x, and returns a function that is n applications of the original
>> function."
>> 
>> I've been trying to see what the limits of rust are if you are using it
>> without the runtime/managed pointers etc, and it seems like I stumble
>> against one of the limits when trying to return functions.  The big
>> question is where to allocate the new function I want to return.
> 
> Rust won't automatically allocate closed-over variables on the heap. This limits the ability to write code like this naturally, but you get the benefit that all allocations are immediately visible and under the control of the programmer.
> 
> I would not suggest trying to use managed pointers for this. Instead I would suggest `proc`, which is allocated on the exchange heap and can close over variables. This should be sufficient for the question as posed, as long as the "another function" has a `'static` bound (`'static |x| -> x`).

Procs can only be called once, though, which is a bit of a limitation.

Does ~|| -> T no longer exist?

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/a275ec44/attachment.html>

From erick.tryzelaar at gmail.com  Fri Jan 10 10:38:38 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Fri, 10 Jan 2014 10:38:38 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAFdm_DneBuOyN9eprE2ec=1raZY1z+psw69yKeQ724ufA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
	<52D00EEC.6090306@aim.com>
	<CANK7tAFdm_DneBuOyN9eprE2ec=1raZY1z+psw69yKeQ724ufA@mail.gmail.com>
Message-ID: <CALdfqQKikupoYutgBCKQWZPTX5A9BjyC1Q1BJHT58nT-XVsvhg@mail.gmail.com>

I'm personally in favor of us making our own build system, but I am
completely biased as I've already written one multistage cross-compiling
build system in Python:

https://github.com/felix-lang/fbuild

The reason why went crazy and built one was for a couple reasons. Before
Rust I worked on the Felix language, which had some complex needs for the
build system. First off, we wanted to support using MSVC without Cygwin.
Second, Building Felix used three languages as part of it's build. The
compiler was written in O'Caml, the runtime in C++, and the standard
library was in Felix. We also used a couple parser generators. Third, Felix
was a cross compiler, so we would configure and build 3 compilers. The
first generated a compiler for architecture A that could make a compiler
for architecture B who's output targeted architecture C.

As you can see, it was a complex problem. Before I started working on
FBuild, I evaluated a ton of other build systems, but they all had a bunch
of issues trying to support something like this. The biggest one was due to
the very nature of a declarative build system. There really are two phases
to these systems. First is a phase to gather up all the dependencies and
build a tree of work to do. Second is the evaluation of that tree. Things
get rather messy when you need to run a command and use it's output to
declare more dependencies. A simple example of this is using `gcc -M` to
get all the C file dependencies. This is typically supported by all build
systems. A more complex one is something like `doxygen`, which requires
manual inspection of the file system to determine dependencies.

When you combine the two phases with multiple stages it gets really
complicated. Code generators like Autoconf and CMake use macro
substitutions which can be very difficult to decipher. Systems like SCons
can be a little better because you can run arbitrary code at a given step
in the dependency tree, but there's some impedance mismatches with how you
define the build and run code. You can't do something like this:

print 'before'

Program('foo.c')

print 'after

And have the prints bracket the building of 'foo.c'. Futhermore, you need
to work with a shared environment to declare command options, and I found
that to be difficult to work with when doing a multistage build. Finally,
it still seems to be suffering from some poor performance issues:

http://blog.melski.net/2013/12/11/update-scons-is-still-really-slow/

Waf and Tup were still pretty new at the time I started FBuild, and if I
recall correctly, I think they still had trouble doing a simple multistage
build.

What I ended up doing with FBuild was to make a build system that was
centered around the idea of caching function calls. I made it in Python,
and it had a similar style to SCons, where you would write:

def build(ctx):
    c = fbuild.builders.c.guess_static(ctx)

    print 'before'

    lib = c.build_lib('static', ['lib.c'])
    exe = c.build_exe('exe', ['exe.c'], libs=[lib])

    print 'after'

But each function call actually built the output (or loaded the results
from the cache), and the printouts actually happen when they look to happen.

Doing multiple stages in this way was really simple. You just use functions:

def my_c_compiler(ctx, c):
    exe = c.build_exec('my-gcc', ['my_gcc.c'])
    return fbuild.builders.c.gcc.static(ctx, exe)

def build(ctx):
    c = fbuild.builders.c.guess_static(ctx)
    new_c = my_c_compiler(ctx, c)
    new_new_c = my_c_compiler(ctx, new_c)

It worked well, and was able to run on all our platforms and support some
nifty auto configuration support too for many c libraries. It could also
build in parallel, but there were some limitations to it because Python did
not play well with exceptions, threads, and signals.

I've been planning on reimplementing FBuild in rust for quite some time,
but I haven't had the time yet to do it beyond a couple experiments. We
already have some pieces of this approach in libextra though. Graydon took
my caching-of-functions idea and turned it into `extra::workcache`. It
wouldn't be *that* hard to port my ideas over from python though. When I
get home tonight I'll try to upload my work in progress somewhere.




On Fri, Jan 10, 2014 at 7:53 AM, Gaetan <gaetan at xeberon.net> wrote:

> I also agree that the way waf works is quite weird to use, but this is
> actually how most of the installers works under windows or some on MacOS:
> the code of the installers is embedded into the distributed package. This
> violates the debian packaging rules, and I think this will be the same with
> rust.
>
> I however really like this approach. You don't have a huge among of
> dependencies to setup in order to build your package. This is not a problem
> on debian where apt does to marveillous job, but on Windows/Mac/generic
> linux/arm, .. this is a nightmare.
>
> One more point in favor of CMake to build rust: you can build
> android/arm/misc (thanks to Makefile) with the same CMakeList.txt files, or
> with external module inclusion. I also agree that its syntax used to be
> quite ugly (the famous if() / else() / endif()), but not so much in the
> lastest versions...
> But if you require python for building, scons is the perfect, natural
> candidate.
>
> -----
> Gaetan
>
>
>
> 2014/1/10 SiegeLord <slabode at aim.com>
>
>> On 01/10/2014 06:19 AM, Robert Knight wrote:
>>
>>> Hello,
>>>
>>> CMake does have a few things going for it:
>>>
>>
>> One more consideration is that LLVM can be built with CMake afaik, so if
>> we switch to CMake we may be able to drop the autotools dependency, which
>> is a more annoying dependency to fulfill (on Windows) than CMake (I don't
>> know if Rust has other components that require autotools though).
>>
>> Along the same lines, we also require Python for whatever reason, so
>> SCons would be a natural option too (it can't build LLVM though). I'd only
>> use SCons conditional on it accepting a Rust dependency scanner into its
>> source: using its current custom scanner infrastructure is not practical as
>> I found out.
>>
>> As for waf... they and Debian have been having a tiff (e.g. see
>> http://waf-devel.blogspot.com/2012/01/debian.html ,
>> https://lists.debian.org/debian-devel/2012/02/msg00207.html ). I would
>> not suggest it based on that.
>>
>> -SL
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/fbc441de/attachment-0001.html>

From erick.tryzelaar at gmail.com  Fri Jan 10 10:43:43 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Fri, 10 Jan 2014 10:43:43 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52CFB098.8010100@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
Message-ID: <CALdfqQLckhhP-gEOnzQ9uEx0tWFXYY-YMT1_ymkdVs7Rs5uRHQ@mail.gmail.com>

Lee,

Can you go into more detail on the problems that Debian is having packaging
Rust? This sounds like a classic bootstrapping problem, and I'm sure other
languages are running into it. How does Debian handle that first build of
`make` or `bash` that I assume gcc depends on?



On Fri, Jan 10, 2014 at 12:34 AM, Lee Braiden <leebraid at gmail.com> wrote:

>  On 10/01/14 08:16, Gaetan wrote:
>
> I am not in favor of a customized build system. For instance boost library
> use their jam build system, and i never figured how to use it in my
> projects.
>
> I push to use standard and well proved build system like cmake or scons,
> at least for major components. This would give a nice example of how to use
> it in any projects.
>
>
> I'd agree with that on both counts: the principle of using something
> standard, and the two recommendations.
>
> CMake would probably get my vote, because it's not so much a build tool,
> as a meta tool for whichever system you prefer, so it would fit in well
> with various platform-specific IDEs, unusual platforms (android, embedded,
> ...), etc.  That said, scons is also a strong contender, and which of the
> two is more open to integrating patches and working with new languages is
> very much worth considering.
>
> I think Rust will be contributing to the wider community by lending its
> support (and patches) to a common, modern build system, AND it will get
> something back in terms of users who already know the build system.
>
>
>
>   On Friday, January 10, 2014, George Makrydakis wrote:
>>
>>>
>>> Hello,
>>>
>>> Having a build system entirely dependent of Rust alone, would make the
>>> entire experience in deploying the language extremely cohere. The only
>>> counter - argument is indeed that it would require some work to get this to
>>> fruition. I would like to know if this has any chance of getting priority
>>> soon enough.
>>>
>>
> Bear in mind that Debian are having a lot of issues packaging Rust
> already, because it self-compiles.  If the build tool also had a Rust
> pre-dependency, that would be a big step backwards.
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/8433b080/attachment.html>

From pwalton at mozilla.com  Fri Jan 10 10:57:43 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 10 Jan 2014 10:57:43 -0800
Subject: [rust-dev] returning functions in rust
In-Reply-To: <F34DD63D-9A12-4BD9-A33B-5EA6E43F9DCB@sb.org>
References: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
	<52D0397C.3010305@mozilla.com>
	<F34DD63D-9A12-4BD9-A33B-5EA6E43F9DCB@sb.org>
Message-ID: <4e49b135-fa55-49a6-96b5-d3c6270a8115@email.android.com>

It doesn't exist, outside of traits. Unboxed closures will probably make it possible to express once again though.

Patrick 

Kevin Ballard <kevin at sb.org> wrote:
>On Jan 10, 2014, at 10:18 AM, Patrick Walton <pcwalton at mozilla.com>
>wrote:
>
>> On 1/10/14 7:20 AM, Nakamura wrote:
>>> I'm new to rust, and tried going through some of the examples from
>the
>>> OS class[0] that was taught in rust.  However, I got tripped up by
>the
>>> exercise, "make a function that takes an integer n and another
>function
>>> |x| -> x, and returns a function that is n applications of the
>original
>>> function."
>>> 
>>> I've been trying to see what the limits of rust are if you are using
>it
>>> without the runtime/managed pointers etc, and it seems like I
>stumble
>>> against one of the limits when trying to return functions.  The big
>>> question is where to allocate the new function I want to return.
>> 
>> Rust won't automatically allocate closed-over variables on the heap.
>This limits the ability to write code like this naturally, but you get
>the benefit that all allocations are immediately visible and under the
>control of the programmer.
>> 
>> I would not suggest trying to use managed pointers for this. Instead
>I would suggest `proc`, which is allocated on the exchange heap and can
>close over variables. This should be sufficient for the question as
>posed, as long as the "another function" has a `'static` bound
>(`'static |x| -> x`).
>
>Procs can only be called once, though, which is a bit of a limitation.
>
>Does ~|| -> T no longer exist?
>
>-Kevin

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/c12338e7/attachment.html>

From pwalton at mozilla.com  Fri Jan 10 10:56:03 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 10 Jan 2014 10:56:03 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAChbWaO0KJfwySMxUV-HQ7WC=oohYJmr-AksepLnZ2B5M1-Bnw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<CANK7tAECa+iuP0howzDhYLgwNyRnYJgSE1Ujp0p4AUc2ePeMWA@mail.gmail.com>
	<CAJGrnh0aN145tGQO7kCjPBuZn--UEFxydeqVKFE=DqWzE8NPXQ@mail.gmail.com>
	<CALckf6j5y=CVOAowfyYX6TmFpOLq41H3j_1NcN_xfTG5k3AsOA@mail.gmail.com>
	<CAChbWaO0KJfwySMxUV-HQ7WC=oohYJmr-AksepLnZ2B5M1-Bnw@mail.gmail.com>
Message-ID: <dbe9485e-727e-40f9-9921-c590fcefdaf8@email.android.com>

I definitely encourage any sort of experimentation with build systems in Rust. But the most important criterion for Rust to adopt a build system in practice is going to be whether someone is available and willing to maintain it at a production quality level. That trumps all technical and language evangelism issues, in my mind.

Not saying we don't have the resources in the community, mind you, just establishing what is in my mind an important criterion.

Patrick

Thad Guidry <thadguidry at gmail.com> wrote:
>Best Reason ever for a Rust Build System = You Prove Rust Itself.
>
>So get hacking on a Rust Build System.
>
>-- 
>-Thad
>+ThadGuidry <https://www.google.com/+ThadGuidry>
>Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/f02e07fb/attachment.html>

From danielmicay at gmail.com  Fri Jan 10 11:01:15 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 10 Jan 2014 14:01:15 -0500
Subject: [rust-dev] returning functions in rust
In-Reply-To: <4e49b135-fa55-49a6-96b5-d3c6270a8115@email.android.com>
References: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
	<52D0397C.3010305@mozilla.com>
	<F34DD63D-9A12-4BD9-A33B-5EA6E43F9DCB@sb.org>
	<4e49b135-fa55-49a6-96b5-d3c6270a8115@email.android.com>
Message-ID: <CA+DvKQ+08rCAY0c7JAeit-fs1Gf1Je3RpO587JA6mN4DRJtA7g@mail.gmail.com>

On Fri, Jan 10, 2014 at 1:57 PM, Patrick Walton <pwalton at mozilla.com> wrote:
> It doesn't exist, outside of traits. Unboxed closures will probably make it
> possible to express once again though.
>
> Patrick

The tricky part is the need to infer the return type if it's defined
inside the function since it's different per-closure.

From banderson at mozilla.com  Fri Jan 10 11:13:32 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 10 Jan 2014 11:13:32 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
Message-ID: <52D0465C.5040509@mozilla.com>

I think we are going to end up doing a total rewrite. Here are my 
current concerns:

* We need to make a big change to the way bootstrapping works in order 
to cross-compile correctly: https://github.com/mozilla/rust/issues/11145
* Adding new crates to the current build system is very error-prone. We 
need all the logic for building them to be encapsulated into something 
simple.
* The build system that Rust uses should be the build system we are 
promoting as the defacto community build system, and as such it also 
needs to integrate with rustpkg.

My personal preference is to create a tool that can eventually integrate 
into rustpkg that generates ninja scripts, and package and distribute 
ninja ourselves (as rust-ninja or something).

On 01/09/2014 09:46 PM, Corey Richardson wrote:
> Hey all,
>
> The build system has grown a fair bit of complexity, and is getting
> hard to understand. I've been thinking about what could replace it
> moving forward. Most of the complexity stems from having to self-host
> (ie, staging) and cross compilation (which target are we compiling
> for, and with which host?)
>
> Our build system must:
>
> 1. Work on all the platforms we support
> 2. Be able to track dependencies.
>
> Our ideal build system should:
>
> 1. Require minimal build-time dependencies
> 2. Allow ease of staging and cross compilation
> 3. Be easy to extend as we grow
> 4. Have readable build scripts
> 5. Have advanced configuration ability (NO_REBUILD, NO_BENCH, etc
> should all be retained)
>
> There are a few options:
>
> 1. Rework the current makefiles to be nicer.
>
> I'm not sure if this is feasible. Some stuff certainly could be
> easier, but the inherent problems of make (nested evals + calls, no
> named parameters (what does $(1) mean here, etc), general ugliness)
> make this unlikely to be a worthwhile effort, besides factoring out
> some of the current boilerplate.
>
> 2. Use a different build system.
>
> The major option here seems to be cmake[1], although I've heard
> murmurings of tup[2] and some other obscure things. I'm unsure tup is
> going to be of much help here. With our compilation model,
> fine-grained file-based dependencies are not very useful. However,
> it's awesome bottom-up dependency model could be neat. It's possible
> that we could use it with a combination of:
>
> 3. Write a build system in Rust.
>
> This would take care of everything for us, using ourselves. We'd have
> a small script fetch the snapshot and build the build system, and then
> hand off the rest of the build to it. This has the advantage of one
> less build-time dependency, but the disadvantage that it's going to be
> a lot of work. This could also potentially output tup, ninja[3], or
> another form of build script after taking configuration options and
> so-forth. It could also integrate with librustc for smart handling of
> comments-or-test-only changes, an issue near to my heart[4]. This
> build system could potentially be rustpkg, but as I understand it the
> current idea is to *remove* rustpkg's ability as a build system and
> keep it as a package manager. (At least, that is what I've understood
> of recent discussion; this could be wrong.)
>
> 4. Write a build system in $LANG.
>
> Python seems to be a good choice here, since we already depend on it
> for fetching the snapshot etc. This still has the disadvantage of
> being a lot of work, but would perhaps be easier than writing a build
> system in Rust. We would definitely lose hacker points for doing so.
>
> There are undoubtedly other options as well. Does anyone have good
> ideas or opinions on what we should do? Personally I think that 3 is
> going to be the best option, unless there's some super amazing build
> system I haven't heard of it. Which is totally possible!
>
> [1]: http://www.cmake.org/
> [2]: http://gittup.org/tup/
> [3]: http://martine.github.io/ninja/
> [4]: https://github.com/mozilla/rust/issues/6522
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From leebraid at gmail.com  Fri Jan 10 11:18:32 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 10 Jan 2014 19:18:32 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CALdfqQLckhhP-gEOnzQ9uEx0tWFXYY-YMT1_ymkdVs7Rs5uRHQ@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<CALdfqQLckhhP-gEOnzQ9uEx0tWFXYY-YMT1_ymkdVs7Rs5uRHQ@mail.gmail.com>
Message-ID: <52D04788.5070203@gmail.com>

Hmm, after further reading, I think I've they're making more progress on 
it than I thought, from first impressions of the discussion.  They've 
had a lot of different issues to deal with, not just the 
self-dependency, but they got 0.7 packaged, at least.

More detail here, particularly in the last comment:

     http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=689207

You can see there that the debian packagers also referenced a list of 
issues that the fedora wrote up:

     https://github.com/mozilla/rust/wiki/Note-packaging

-- 
Lee

On 10/01/14 18:43, Erick Tryzelaar wrote:
> Lee,
>
> Can you go into more detail on the problems that Debian is having 
> packaging Rust? This sounds like a classic bootstrapping problem, and 
> I'm sure other languages are running into it. How does Debian handle 
> that first build of `make` or `bash` that I assume gcc depends on?
>
>
>
> On Fri, Jan 10, 2014 at 12:34 AM, Lee Braiden <leebraid at gmail.com 
> <mailto:leebraid at gmail.com>> wrote:
>
>     On 10/01/14 08:16, Gaetan wrote:
>>
>>     I am not in favor of a customized build system. For instance
>>     boost library use their jam build system, and i never figured how
>>     to use it in my projects.
>>
>>     I push to use standard and well proved build system like cmake or
>>     scons, at least for major components. This would give a nice
>>     example of how to use it in any projects.
>>
>
>     I'd agree with that on both counts: the principle of using
>     something standard, and the two recommendations.
>
>     CMake would probably get my vote, because it's not so much a build
>     tool, as a meta tool for whichever system you prefer, so it would
>     fit in well with various platform-specific IDEs, unusual platforms
>     (android, embedded, ...), etc.  That said, scons is also a strong
>     contender, and which of the two is more open to integrating
>     patches and working with new languages is very much worth considering.
>
>     I think Rust will be contributing to the wider community by
>     lending its support (and patches) to a common, modern build
>     system, AND it will get something back in terms of users who
>     already know the build system.
>
>
>
>>         On Friday, January 10, 2014, George Makrydakis wrote:
>>
>>
>>             Hello,
>>
>>             Having a build system entirely dependent of Rust alone,
>>             would make the entire experience in deploying the
>>             language extremely cohere. The only counter - argument is
>>             indeed that it would require some work to get this to
>>             fruition. I would like to know if this has any chance of
>>             getting priority soon enough.
>>
>
>     Bear in mind that Debian are having a lot of issues packaging Rust
>     already, because it self-compiles.  If the build tool also had a
>     Rust pre-dependency, that would be a big step backwards.
>
>
>     -- 
>     Lee
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/336380e1/attachment.html>

From bascule at gmail.com  Fri Jan 10 11:29:51 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 10 Jan 2014 11:29:51 -0800
Subject: [rust-dev] Ephemeral byte arrays for cryptographic keys/plaintexts
Message-ID: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>

Hi there Rustafarians,

There's a particular type I'd love to see in core Rust: a bytebuffer for
crypto purposes which automatically provides what I'd call "good crypto
hygiene". It'd do the following things:

- Avoid being paged out to swap by use of mlock/VirtualLock
- Ensure it's zeroed out (and munlocked) after use (via RAII-style
conventions?)
- Be able to interact directly with the I/O layer so it's easy to get data
in/out of these buffers without having to thunk it through a bunch of
intermediate types that won't have these properties, i.e. it should be
possible for me to read an encryption key from a file without going through
a [u8] that wouldn't get locked/zeroed automatically.

Why is it important to have a type like this in the Rust standard library?
IMO, so all the cryptographic libraries in Rust can use the same type for
this purpose and in doing so interoperate easily (i.e. I should be able to
get a cryptographic key read from TLS and decrypted into one of these
buffers and use it with another library while still ensuring everything
will get locked/zeroed)

It would also mean that anyone using Rust would have a lot easier time
writing code with good crypto hygiene, at least if all the crypto libraries
used it, because this type would take care of doing all of this sort of
thing for you automatically.

Most other languages completely punt on this problem. Can Rust do better?
Is this the sort of thing that belongs in the Rust standard library?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/b3c00bb6/attachment.html>

From kevin at sb.org  Fri Jan 10 12:27:31 2014
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 10 Jan 2014 12:27:31 -0800
Subject: [rust-dev] Ephemeral byte arrays for cryptographic
	keys/plaintexts
In-Reply-To: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
References: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
Message-ID: <0FBE528E-4261-4653-B242-B3D7EA01F4AF@sb.org>

Given that the crypto philosophy of the core Rust libraries is "don't put crypto in the core Rust libraries", I don't think a type like this needs to be in the core libraries. But I do think this is a good opportunity for a third-party library to create this type and promote itself as the set of building blocks for doing crypto in Rust. Furthermore, I could also imagine there being official Rust documentation that recommends this third-party library to anyone who wants to do crypto.

-Kevin

On Jan 10, 2014, at 11:29 AM, Tony Arcieri <bascule at gmail.com> wrote:

> Hi there Rustafarians,
> 
> There's a particular type I'd love to see in core Rust: a bytebuffer for crypto purposes which automatically provides what I'd call "good crypto hygiene". It'd do the following things:
> 
> - Avoid being paged out to swap by use of mlock/VirtualLock
> - Ensure it's zeroed out (and munlocked) after use (via RAII-style conventions?)
> - Be able to interact directly with the I/O layer so it's easy to get data in/out of these buffers without having to thunk it through a bunch of intermediate types that won't have these properties, i.e. it should be possible for me to read an encryption key from a file without going through a [u8] that wouldn't get locked/zeroed automatically. 
> 
> Why is it important to have a type like this in the Rust standard library? IMO, so all the cryptographic libraries in Rust can use the same type for this purpose and in doing so interoperate easily (i.e. I should be able to get a cryptographic key read from TLS and decrypted into one of these buffers and use it with another library while still ensuring everything will get locked/zeroed)
> 
> It would also mean that anyone using Rust would have a lot easier time writing code with good crypto hygiene, at least if all the crypto libraries used it, because this type would take care of doing all of this sort of thing for you automatically.
> 
> Most other languages completely punt on this problem. Can Rust do better? Is this the sort of thing that belongs in the Rust standard library?
> 
> -- 
> Tony Arcieri
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/5226e4fa/attachment.p7s>

From jurily at gmail.com  Fri Jan 10 12:39:47 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Fri, 10 Jan 2014 21:39:47 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6QDSccftaJMtCcWO5oXS=wrde=2Yot5M3HZMk5bTUDF6g@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>
	<1949520.i7MrgNSkXU@yoga.dhardy>
	<CA++BO6QDSccftaJMtCcWO5oXS=wrde=2Yot5M3HZMk5bTUDF6g@mail.gmail.com>
Message-ID: <52D05A93.50304@gmail.com>

On 01/10/2014 04:08 PM, Corey Richardson wrote:
> This RFC isn't about using a single build system for everything, it's
> the build system we use to build Rust itself.
>
> On Fri, Jan 10, 2014 at 10:06 AM, Diggory Hardy <lists at dhardy.name> wrote:
>> A further point in favour of CMake is that it would make multi-language
>> projects easier to manage, in particular transitioning a "C-family" project to
>> Rust.
>>
>> On Friday 10 January 2014 08:34:32 Lee Braiden wrote:
>
Both Rust and Servo are multi-language projects, and LLVM already uses 
CMake. Wouldn't it be a plus to bootstrap Rust with the Standard Rust 
Build System(tm)?

Also, CMake can use the Visual Studio toolchain on Windows.

From leebraid at gmail.com  Fri Jan 10 12:50:16 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 10 Jan 2014 20:50:16 +0000
Subject: [rust-dev] Ephemeral byte arrays for cryptographic
	keys/plaintexts
In-Reply-To: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
References: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
Message-ID: <52D05D08.1030000@gmail.com>

On 10/01/14 19:29, Tony Arcieri wrote:
> There's a particular type I'd love to see in core Rust: a bytebuffer 
> for crypto purposes which automatically provides what I'd call "good 
> crypto hygiene". It'd do the following things:
>
> - Avoid being paged out to swap by use of mlock/VirtualLock

This is a general memory setting, which is required for all sorts of 
use-cases: disk io buffers, device driver buffers, off-screen rendering, 
caching, important interactive elements (mouse pointers and application 
menus, for instance), which would hamper the user experience if they 
were paged in/out,  etc.  I'd go as far as to say that any system with 
swapping needs an easy way to lock memory like this.  It's not even 
really a crypto problem, since swap can (and probably should be) 
encrypted too, if you encrypt your filesystem(s).

I would like to see a platform-independent implementation in std::mem -- 
std::mem::lock(buf, len) and it's unlock() opposite, perhaps.


> - Ensure it's zeroed out (and munlocked) after use (via RAII-style 
> conventions?)

Isn't this just a dtor thing?


> - Be able to interact directly with the I/O layer so it's easy to get 
> data in/out of these buffers without having to thunk it through a 
> bunch of intermediate types that won't have these properties, i.e. it 
> should be possible for me to read an encryption key from a file 
> without going through a [u8] that wouldn't get locked/zeroed 
> automatically.

This sounds like a general IO optimisation, which virtually any 
block-based io use-case could benefit from.



-- 
Lee


From jurily at gmail.com  Fri Jan 10 13:26:09 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Fri, 10 Jan 2014 22:26:09 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
Message-ID: <52D06571.50109@gmail.com>

I'm all for CMake. Not so much for the technical merits, but the amount 
of infrastructure already built up around it. KDE has adopted it 
wholesale, meaning all the dependencies of the entire KDE project are 
supported out of the box, and also IDE support in KDevelop, Qt Creator, 
emacs/vi etc.

Bootstrapping comes to mind as a potential problem, but LLVM and Clang 
use it too.

From bill_myers at outlook.com  Fri Jan 10 14:15:38 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Fri, 10 Jan 2014 22:15:38 +0000
Subject: [rust-dev] Ephemeral byte arrays for cryptographic
 keys/plaintexts
In-Reply-To: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
References: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
Message-ID: <BAY170-W8002791D434EF8FF4E9F8FF8B30@phx.gbl>

This can be easily implemented in Rust as a struct doing exactly that.

There's no need to modify the I/O layer, since you'd simply borrow an &[u8] from the type and pass it, resulting in the I/O layer directly writing into the locked zeroed-on-destruction memory.

As for crypto, it seems the plan is to not implement it in Rust, but
 to bind to libraries such as OpenSSL, libgcrypt, Windows CryptoAPI, etc.

I guess patches would be welcome to implement this. 		 	   		  

From bill_myers at outlook.com  Fri Jan 10 14:25:30 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Fri, 10 Jan 2014 22:25:30 +0000
Subject: [rust-dev] Ephemeral byte arrays for cryptographic
 keys/plaintexts
In-Reply-To: <BAY170-W8002791D434EF8FF4E9F8FF8B30@phx.gbl>
References: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>,
	<BAY170-W8002791D434EF8FF4E9F8FF8B30@phx.gbl>
Message-ID: <BAY170-W594C5636C503C2C30F4400F8B30@phx.gbl>

At any rate, note that what you are trying to do only provides some mitigation and is far from a complete solution, because in practice you can't prevent leakage of all confidential data in this way (what about hibernation while the key is in memory? what about plaintext decrypted with the key?)

The only effective solution is to encrypt all storage including swap using full-disk encryption, as well as all internal network links using IPsec or similar, so that it doesn't matter if sensitive data is swapped, accidentally written to files or communicated between servers. 		 	   		  

From donquestion at rocketmail.com  Fri Jan 10 14:38:49 2014
From: donquestion at rocketmail.com (Don Question)
Date: Fri, 10 Jan 2014 23:38:49 +0100
Subject: [rust-dev] general onlookers questions on rust development
In-Reply-To: <mailman.38046.1389381214.24864.rust-dev@mozilla.org>
References: <mailman.38046.1389381214.24864.rust-dev@mozilla.org>
Message-ID: <52D07679.8040607@rocketmail.com>

Congrats to 0.9!

I'm coming from a C/C++/Python background and was loosely following the 
progress of Rust
for quite a while now, but never tried it until yesterday.

I must admit i'm quite pleased so far, but i have some question, which i 
hope you could
help to clarify.

1. I miss a search functionality on the mailing list. Am i just blind, 
or do i have to
use google with the "site:" option?

2. I'm used to curly braces, but every time i have to code in C or 
JavaScript i miss the
better readability of python's curly-free syntax. What was the reason to 
keep the (imho:
annoying) curly braces? I must confess i was a little bit taken aback by 
the first
sentence on rust-lang.org: "Rust is a curly-brace, ..."

3. If i wanted to use Rust instead of C for external Python-Modules, 
what would be my
options to achieve that? Could i use ctypes and Rust's "extern"?

4. Why is the BSD implementation almost 3 times faster then the linux 
and mac-versions ?
http://huonw.github.io/isrustfastyet/buildbot/

5. When will we see a Rust version of the Linux kernel? Just joking! ;-) 
Keep up the good
work!

Thx and regards,
Don
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/b88165f7/attachment-0001.html>

From alex at crichton.co  Fri Jan 10 14:44:35 2014
From: alex at crichton.co (Alex Crichton)
Date: Fri, 10 Jan 2014 14:44:35 -0800
Subject: [rust-dev] general onlookers questions on rust development
In-Reply-To: <52D07679.8040607@rocketmail.com>
References: <mailman.38046.1389381214.24864.rust-dev@mozilla.org>
	<52D07679.8040607@rocketmail.com>
Message-ID: <CAFnh-mctzj=CWLOmMUZfc0WHAxKdXwtNPWJW-bGDg9YCBP-ZmQ@mail.gmail.com>

> 1. I miss a search functionality on the mailing list. Am i just blind, or do
> i have to
> use google with the "site:" option?

The mailing list we use is pretty standard, and it's
archived/searchable on other mirrors (gmane I think mirrors our
mailing list)

> 2. I'm used to curly braces, but every time i have to code in C or
> JavaScript i miss the
> better readability of python's curly-free syntax. What was the reason to
> keep the (imho:
> annoying) curly braces? I must confess i was a little bit taken aback by the
> first
> sentence on rust-lang.org: "Rust is a curly-brace, ..."

This is certainly a subjective topic rather than an objective one, and
we have long since made this decision. There are many reasons as to
why we chose this, along with many other things that then fell out
because of this decision. At this point it would be a little difficult
to go back to the core reason, but it's not too interesting any more
because this is pretty much set in stone at this point.

> 3. If i wanted to use Rust instead of C for external Python-Modules, what
> would be my
> options to achieve that? Could i use ctypes and Rust's "extern"?

You certainly can! You can build dynamic or static rust libraries with
functions tagged with `#[no_mangle]` so python can see the symbols.
There's at least one (and I think a few more) ruby extension which is
using rust to power it.

> 4. Why is the BSD implementation almost 3 times faster then the linux and
> mac-versions ?
> http://huonw.github.io/isrustfastyet/buildbot/

This is just an artifact of BSD running a vastly stripped down version
of the test suite (it's running on a very slow AWS bot). The BSD
implementation is not actually 3x faster than everything else.

> 5. When will we see a Rust version of the Linux kernel? Just joking! ;-)
> Keep up the good
> work!

In all seriousness, there are actually a fairly large and growing
number of kernels written in rust! Most of them are "demo quality" in
the sense that they're not production kernels, but Rust is turning out
to be a good language to write kernels in.

From corey at octayn.net  Fri Jan 10 14:44:58 2014
From: corey at octayn.net (Corey Richardson)
Date: Fri, 10 Jan 2014 17:44:58 -0500
Subject: [rust-dev] general onlookers questions on rust development
In-Reply-To: <52D07679.8040607@rocketmail.com>
References: <mailman.38046.1389381214.24864.rust-dev@mozilla.org>
	<52D07679.8040607@rocketmail.com>
Message-ID: <CA++BO6T1iMdPW1thDbNG_BJ8-4mh65FoHstatu2eukAatbVb=A@mail.gmail.com>

On Fri, Jan 10, 2014 at 5:38 PM, Don Question
<donquestion at rocketmail.com> wrote:
> Congrats to 0.9!
>
> I'm coming from a C/C++/Python background and was loosely following the
> progress of Rust
> for quite a while now, but never tried it until yesterday.
>
> I must admit i'm quite pleased so far, but i have some question, which i
> hope you could
> help to clarify.
>
> 1. I miss a search functionality on the mailing list. Am i just blind, or do
> i have to
> use google with the "site:" option?
>

You're not blind. But, there's also a searchable gmane mirror:
http://blog.gmane.org/gmane.comp.lang.rust.devel

> 2. I'm used to curly braces, but every time i have to code in C or
> JavaScript i miss the
> better readability of python's curly-free syntax. What was the reason to
> keep the (imho:
> annoying) curly braces? I must confess i was a little bit taken aback by the
> first
> sentence on rust-lang.org: "Rust is a curly-brace, ..."
>

I'm not 100% sure but afaik it's to keep syntactical familiarity.

> 3. If i wanted to use Rust instead of C for external Python-Modules, what
> would be my
> options to achieve that? Could i use ctypes and Rust's "extern"?
>

Devin Jeanpierre (aka ssbr) has Python bindings:
https://bitbucket.org/devin.jeanpierre/pyrite. They might need
updating. But yes, you'd want to use `extern "C"` and then use it the
same way you'd use a C module.

> 4. Why is the BSD implementation almost 3 times faster then the linux and
> mac-versions ?
> http://huonw.github.io/isrustfastyet/buildbot/
>

It isn't. It's running a stripped down version of the test suite (make
check-fast).

From dpx.infinity at gmail.com  Fri Jan 10 14:46:54 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sat, 11 Jan 2014 02:46:54 +0400
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
Message-ID: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>

Hi,

As far as I understand, the current way to export macros is to
annotate the module with macro_rules definition with #[macro_escape]
annotation. But I just can't get it right, and my macro is not visible
in other module :(

Here is what I have:

----- START -----
/lib.rs:
#[feature(macro_rules)];

pub mod m1;

--
/m1/mod.rs:
#[macro_escape];

pub mod submod;

macro_rules! example_rule(
    () => (mod test;)
)

--
/m1/submod.rs:
use m1;

example_rule!()
----- END -----

I have assumed that putting #[macro_escape] annotation to a module
makes all macros from that module available in all modules which
import this module, but apparently I'm wrong because the code above
does not work with 'macro undefined' error.

Could please someone explain how #[macro_escape] works in detail? I
couldn't find any documentation on it, and looking through standard
libs was not helpful.

Thanks,
Vladimir.

From me at chrismorgan.info  Fri Jan 10 15:44:51 2014
From: me at chrismorgan.info (Chris Morgan)
Date: Sat, 11 Jan 2014 10:44:51 +1100
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
Message-ID: <CAMF4WehB-y16a=dpkgE_OYOFpMOsykuVRMdO92jSanLAC6+dKA@mail.gmail.com>

The macro is being defined after the module is defined. You need to move
the macro definition before the "pub mod submod;" line. Also due to the
scoping rules of macros, you don't need #[macro_escape] there---it's a
child, so it gets the macro. Only siblings, parents, uncles, aunts,
cousins, &c. would need it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/aebe37f2/attachment.html>

From bjzaba at yahoo.com.au  Fri Jan 10 16:02:51 2014
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 11 Jan 2014 11:02:51 +1100
Subject: [rust-dev] general onlookers questions on rust development
In-Reply-To: <A230C5CB-B4B7-476B-8EC5-0E6FD643E8B5@yahoo.com.au>
References: <mailman.38046.1389381214.24864.rust-dev@mozilla.org>
	<52D07679.8040607@rocketmail.com>
	<18367033-4628-4312-9E3F-42075246C2D2@yahoo.com.au>
	<A230C5CB-B4B7-476B-8EC5-0E6FD643E8B5@yahoo.com.au>
Message-ID: <288CEE8A-FF50-4241-9058-45230490A7AA@yahoo.com.au>

On 11 Jan 2014, at 9:38 am, Don Question <donquestion at rocketmail.com> wrote:

> 2. I'm used to curly braces, but every time i have to code in C or JavaScript i miss the
> better readability of python's curly-free syntax. What was the reason to keep the (imho:
> annoying) curly braces? I must confess i was a little bit taken aback by the first 
> sentence on rust-lang.org: "Rust is a curly-brace, ..."

I?m pretty sure it was for familiarity?s sake. I?m not the biggest fan of curly bracket syntax, but it?s a) too far down the road to change it easily, and b) far less important to me than the semantics that Rust brings to the table.

~Brendan


From bascule at gmail.com  Fri Jan 10 16:23:11 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 10 Jan 2014 16:23:11 -0800
Subject: [rust-dev] Ephemeral byte arrays for cryptographic
	keys/plaintexts
In-Reply-To: <BAY170-W594C5636C503C2C30F4400F8B30@phx.gbl>
References: <CAHOTMVLKC4ewm0YJGREDb_NpZdY2nnu9LBDpq2w7=GgwfXk-Ww@mail.gmail.com>
	<BAY170-W8002791D434EF8FF4E9F8FF8B30@phx.gbl>
	<BAY170-W594C5636C503C2C30F4400F8B30@phx.gbl>
Message-ID: <CAHOTMVKOLH6Gad=taSotPQFiL-H=MkAAd4G2oWThDKVHFubk+w@mail.gmail.com>

Okay, first, I'm glad to hear that people are interested in general
solutions to the problems that I posed which are orthogonal to crypto but
could still benefit crypto applications.

On Fri, Jan 10, 2014 at 2:25 PM, Bill Myers <bill_myers at outlook.com> wrote:

> At any rate, note that what you are trying to do only provides some
> mitigation and is far from a complete solution


Hence "best crypto hygiene" not "crypto-safe memory type for Rust!"


> in practice you can't prevent leakage of all confidential data in this way


You mean attackers could potentially reach /dev/kmem? Yes, at that point,
all bets are off ;)


> what about hibernation while the key is in memory?


Seems useful actually! But clearly the way memory is being saved (encrypted
or not) is important.


> what about plaintext decrypted with the key?


I guess you're vicariously attempting to ask what the threat model is here,
and spelling out some potential compromises. I'd say what about:

1) hardware-attached DMA devices, i.e. firewire memory inspection via tools
like Inception: http://www.breaknenter.org/projects/inception/
2) Cold-boot attacks: https://en.wikipedia.org/wiki/Cold_boot_attack

We really need to back up here and get back to what I was really talking
about, which is best crypto hygiene. This isn't about building a virtual
safe with 4" thick steel walls for cryptographic applications. This is
about using the language to enforce cryptographic best practices, which do
NOT provide any guarantees about securing cryptosystems, they merely make
the attacker's job harder.

But we should back up even further yet:

On Fri, Jan 10, 2014 at 12:50 PM, Lee Braiden <leebraid at gmail.com> wrote:

> This is a general memory setting, which is required for all sorts of
> use-cases: disk io buffers, device driver buffers, off-screen rendering,
> caching, important interactive elements (mouse pointers and application
> menus, for instance), which would hamper the user experience if they were
> paged in/out,  etc.  I'd go as far as to say that any system with swapping
> needs an easy way to lock memory like this.  It's not even really a crypto
> problem, since swap can (and probably should be) encrypted too, if you
> encrypt your filesystem(s).
>

Yes, this isn't just a crypto problem. I want to solve my crypto-problems,
but if there are bigger fish to fry here, then cool ;)

Isn't this just a dtor thing?
>

YES!

This sounds like a general IO optimisation, which virtually any block-based
> io use-case could benefit from.
>

Yup! Can we solve it? ;)

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/7b325e58/attachment-0001.html>

From chris.morganiser at gmail.com  Fri Jan 10 15:39:24 2014
From: chris.morganiser at gmail.com (Chris Morgan)
Date: Sat, 11 Jan 2014 10:39:24 +1100
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
Message-ID: <CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>

The macro is being defined after the module is defined. You need to move
the macro definition before the "pub mod submod;" line. Also due to the
scoping rules of macros, you don't need #[macro_escape] there---it's a
child, so it gets the macro. Only siblings, parents, uncles, aunts,
cousins, &c. would need it.
On Jan 11, 2014 9:46 AM, "Vladimir Matveev" <dpx.infinity at gmail.com> wrote:

> Hi,
>
> As far as I understand, the current way to export macros is to
> annotate the module with macro_rules definition with #[macro_escape]
> annotation. But I just can't get it right, and my macro is not visible
> in other module :(
>
> Here is what I have:
>
> ----- START -----
> /lib.rs:
> #[feature(macro_rules)];
>
> pub mod m1;
>
> --
> /m1/mod.rs:
> #[macro_escape];
>
> pub mod submod;
>
> macro_rules! example_rule(
>     () => (mod test;)
> )
>
> --
> /m1/submod.rs:
> use m1;
>
> example_rule!()
> ----- END -----
>
> I have assumed that putting #[macro_escape] annotation to a module
> makes all macros from that module available in all modules which
> import this module, but apparently I'm wrong because the code above
> does not work with 'macro undefined' error.
>
> Could please someone explain how #[macro_escape] works in detail? I
> couldn't find any documentation on it, and looking through standard
> libs was not helpful.
>
> Thanks,
> Vladimir.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/fecbc55d/attachment.html>

From banderson at mozilla.com  Fri Jan 10 19:44:24 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 10 Jan 2014 19:44:24 -0800
Subject: [rust-dev] Properly licensing Rust documentation and wiki
Message-ID: <52D0BE18.2070106@mozilla.com>

Hey.

Time for more legal stuff. Per 
https://github.com/mozilla/rust/issues/5831 the licensing of our 
documentation is not clear. Like all things Rust we want to make our doc 
license as permissive as possible, so after getting some legal advice 
here is what I intend to do:

* Rust documentation will be MIT/ASL2 licensed like everything else.
* Add the license as a *footer* to existing in-tree documentation, under 
the argument that it is already licensed according to the same terms as 
the rest of the repo.
* Gather new statements from wiki contributors asserting that they 
contrtibuted under the MIT/ASL2, as we did when we relicensed Rust.
* Put the license as footers on all pages of the wiki.

For the most part this should not affect anybody, though if you've ever 
touched the wiki you may recieve an email from me about this in the future.

Regards,
Brian

From leebraid at gmail.com  Fri Jan 10 21:15:49 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Sat, 11 Jan 2014 05:15:49 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math, pre-1.0
Message-ID: <52D0D385.1080200@gmail.com>

This may be go nowhere, especially so late in Rust's development, but I 
feel like this is an important, relatively small change (though a 
high-profile one).  I believe it could have a large, positive impact in 
terms of targeting new developer communities, gaining more libraries and 
applications, giving a better impression of the language, AND on 
performance and futureproofing.

However, a lot of people who are interested in performance will probably 
baulk at this, on first sight.  If you're in that group, let me 
encourage you to keep reading, at least until the points on performance 
/improvements/.  Then baulk, if you like ;)

Also, I said it in the post as well, but it's late here, so apologies 
for any readability / editing issues.  I tried, but sleep beckons ;)


http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/


-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/b71e0441/attachment.html>

From corey at octayn.net  Fri Jan 10 21:41:07 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 11 Jan 2014 00:41:07 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0D385.1080200@gmail.com>
References: <52D0D385.1080200@gmail.com>
Message-ID: <CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>

The current consensus on this subject, afaik, is the rename int/uint
to intptr/uintptr. They're awful names, but it frees up int for a
*fast* bigint type. Fast here is key. We can't have a suboptimal
numeric type be the recommended default. We need to perform at least
as well as GMP for me to even consider it. Additionally we'd have
generic numeric literals. I don't think anyone wants what we current
have for *numerics*. Fixed-size integers are necessary for some tasks,
but numerics is not one of them.

As long as we rename int/uint to intptr/uintptr and leave int etc
reserved, I think we can defer the language issues to post-1.0. It
should be entirely backwards compatible. Development of robust
numerics can happen outside the standard library. Talk to bjz about
this, he has some ideas :)

As an aside, you mention a "real" in your blog post like it's
something that exists. Rust does not have any such type.

On Sat, Jan 11, 2014 at 12:15 AM, Lee Braiden <leebraid at gmail.com> wrote:
> This may be go nowhere, especially so late in Rust's development, but I feel
> like this is an important, relatively small change (though a high-profile
> one).  I believe it could have a large, positive impact in terms of
> targeting new developer communities, gaining more libraries and
> applications, giving a better impression of the language, AND on performance
> and futureproofing.
>
> However, a lot of people who are interested in performance will probably
> baulk at this, on first sight.  If you're in that group, let me encourage
> you to keep reading, at least until the points on performance improvements.
> Then baulk, if you like ;)
>
> Also, I said it in the post as well, but it's late here, so apologies for
> any readability / editing issues.  I tried, but sleep beckons ;)
>
>
>
> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From pcwalton at mozilla.com  Fri Jan 10 21:48:40 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 10 Jan 2014 21:48:40 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
Message-ID: <52D0DB38.4030001@mozilla.com>

On 1/10/14 9:41 PM, Corey Richardson wrote:
> The current consensus on this subject, afaik, is the rename int/uint
> to intptr/uintptr. They're awful names, but it frees up int for a
> *fast* bigint type. Fast here is key. We can't have a suboptimal
> numeric type be the recommended default. We need to perform at least
> as well as GMP for me to even consider it. Additionally we'd have
> generic numeric literals. I don't think anyone wants what we current
> have for *numerics*. Fixed-size integers are necessary for some tasks,
> but numerics is not one of them.

I wasn't aware of this consensus. I'm not sure what I think; int and 
uint as they are is pretty nice for array indexing.

Patrick


From bob at redivi.com  Fri Jan 10 21:50:02 2014
From: bob at redivi.com (Bob Ippolito)
Date: Fri, 10 Jan 2014 21:50:02 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0D385.1080200@gmail.com>
References: <52D0D385.1080200@gmail.com>
Message-ID: <CACwMPm_1JnkdWnrdyEBrLViVownhh-bgdtA1oQaAbZrS1+mf9Q@mail.gmail.com>

On Friday, January 10, 2014, Lee Braiden wrote:

>  This may be go nowhere, especially so late in Rust's development, but I
> feel like this is an important, relatively small change (though a
> high-profile one).  I believe it could have a large, positive impact in
> terms of targeting new developer communities, gaining more libraries and
> applications, giving a better impression of the language, AND on
> performance and futureproofing.
>
> However, a lot of people who are interested in performance will probably
> baulk at this, on first sight.  If you're in that group, let me encourage
> you to keep reading, at least until the points on performance
> *improvements*.  Then baulk, if you like ;)
>
> Also, I said it in the post as well, but it's late here, so apologies for
> any readability / editing issues.  I tried, but sleep beckons ;)
>
>
>
> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/
>

I think a pragmatic approach is to do what Haskell does and allow number
literals to be used for any type that implements the right typeclasses. You
can implement what you need to as a library, and if it solves problems then
people will use it.

(rant below, feel free to ignore)

Floats aren't horrible, you just have to know a little bit of numerical
analysis in order to use them properly (regardless of what base they are
in!). Most of the science and finance computations that I know of fit just
fine into the domain of fixed size floating point. The numbers have finite
precision to begin with, and there's often a ton of them so performance
matters. Having some arbitrary precision type where adding a really small
number to a really big one can take up an arbitrarily large amount of
memory and/or time probably isn't going to help much. Also, good luck
actually supporting real numbers unless you intend for this type to work
symbolically, and then you are building a computer algebra system. That's
not likely the right course for a systems programming language.

-bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/5652b37c/attachment-0001.html>

From dbau.pp at gmail.com  Fri Jan 10 21:50:43 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 11 Jan 2014 16:50:43 +1100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0DB38.4030001@mozilla.com>
References: <52D0D385.1080200@gmail.com>	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<52D0DB38.4030001@mozilla.com>
Message-ID: <52D0DBB3.2040005@gmail.com>

On 11/01/14 16:48, Patrick Walton wrote:
> On 1/10/14 9:41 PM, Corey Richardson wrote:
>> The current consensus on this subject, afaik, is the rename int/uint
>> to intptr/uintptr. They're awful names, but it frees up int for a
>> *fast* bigint type. Fast here is key. We can't have a suboptimal
>> numeric type be the recommended default. We need to perform at least
>> as well as GMP for me to even consider it. Additionally we'd have
>> generic numeric literals. I don't think anyone wants what we current
>> have for *numerics*. Fixed-size integers are necessary for some tasks,
>> but numerics is not one of them.
>
> I wasn't aware of this consensus. I'm not sure what I think; int and 
> uint as they are is pretty nice for array indexing.

The RFC/issue is https://github.com/mozilla/rust/issues/9940


Huon

>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From ml at isaac.cedarswampstudios.org  Fri Jan 10 21:58:59 2014
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Sat, 11 Jan 2014 00:58:59 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0D385.1080200@gmail.com>
References: <52D0D385.1080200@gmail.com>
Message-ID: <52D0DDA3.8040501@isaac.cedarswampstudios.org>

Scheme's numeric tower is one of the best in extant languages.  Take a 
look at it.  Of course, its dynamic typing is poorly suited for Rust.

Arbitrary-precision arithmetic can get you mathematically perfect 
integers and rational numbers, but not real numbers.  There are an 
uncountably infinite number of real numbers and sophisticated computer 
algebra systems are devoted the problem (or estimates are used, or you 
become unable to compare two real numbers for equality).  The MPFR C 
library implements arbitrarily high precision floating point, but that 
still has all the pitfalls of floating-point that you complain about. 
For starters, try representing sqrt(2) and testing its equality with 
e^(0.5 ln 2).

In general, Rust is a systems language, so fixed-size integral types are 
important to have.  They are better-behaved than in C and C++ in that 
signed types are modulo, not undefined behaviour, on overflow.  It could 
be nice to have integral types that are task-failure on overflow as an 
option too.  As you note, bignum integers are important too; it's good 
they're available.  I think bignum rationals would be a fine additional 
choice to have (Haskell and GMP offer them, for example).

-Isaac


On 01/11/2014 12:15 AM, Lee Braiden wrote:
> This may be go nowhere, especially so late in Rust's development, but I
> feel like this is an important, relatively small change (though a
> high-profile one).  I believe it could have a large, positive impact in
> terms of targeting new developer communities, gaining more libraries and
> applications, giving a better impression of the language, AND on
> performance and futureproofing.
>
> However, a lot of people who are interested in performance will probably
> baulk at this, on first sight.  If you're in that group, let me
> encourage you to keep reading, at least until the points on performance
> /improvements/.  Then baulk, if you like ;)
>
> Also, I said it in the post as well, but it's late here, so apologies
> for any readability / editing issues.  I tried, but sleep beckons ;)
>
>
> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/
>
>
> --
> Lee
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>


From danielmicay at gmail.com  Fri Jan 10 22:01:29 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:01:29 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0D385.1080200@gmail.com>
References: <52D0D385.1080200@gmail.com>
Message-ID: <CA+DvKQLEXoDqX_aXn5QKJYQ0JJZD81Gir9+-sfNeTM5GF9N2Vg@mail.gmail.com>

On Sat, Jan 11, 2014 at 12:15 AM, Lee Braiden <leebraid at gmail.com> wrote:
> This may be go nowhere, especially so late in Rust's development, but I feel
> like this is an important, relatively small change (though a high-profile
> one).  I believe it could have a large, positive impact in terms of
> targeting new developer communities, gaining more libraries and
> applications, giving a better impression of the language, AND on performance
> and futureproofing.
>
> However, a lot of people who are interested in performance will probably
> baulk at this, on first sight.  If you're in that group, let me encourage
> you to keep reading, at least until the points on performance improvements.
> Then baulk, if you like ;)
>
> Also, I said it in the post as well, but it's late here, so apologies for
> any readability / editing issues.  I tried, but sleep beckons ;)
>
>
>
> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/
>
>
> --
> Lee

> The wrongness of float

There is no lossless implementation of real numbers on a computer. You
assume arbitrary precision floating point can cover every real number,
but there's no such thing. Arbitrary precision means you can choose
the precision used by the numbers. It's certainly no replacement for
hardware floating point because it's many orders of magnitude slower.
You may not understand IEEE754 floating point arithmetic, but it's
certainly not *wrong*.

> The wrongness of machine ints

Big integers are many orders of magnitude slower than hardware integer
arithmetic. It's not a replacement for it, but rather an alternative
when you need a larger range. You still need to validate inputs
because it's very easy to go out-of-memory, and that's going to bring
down the whole process or even other processes on the system.

> For those looking to reject this idea on the basis of optimisation: consider that abstracting away from 32-bit integers or 64-bit floats, or 256-bit ints, can potentially lead to better optimisation, if the compiler can then figure out that it?s on a 256-bit machine (or indeed, is targeting a 256-bit GPU) and is free to optimise accordingly.

This isn't how hardware works. Smaller floating point numbers are
faster than higher precision, because they're smaller. An array of
32-bit floating point numbers will always be half the size as the same
array of 64-bit floating point numbers. Double the amount of data can
fit into the layers of caches, and you can fit twice as many into SIMD
registers so there's double the amount of theoretical throughput.

> real becomes, not a 32-bit float (as I understand it currently is), but what it sounds like: a real number, covering all numbers in the real number range, using an arbitrary precision type.

Rust doesn't have a `real` type. It has `f32` and `f64`, which are an
explicit opt-in to IEEE754 binary floating point. If you don't want
this, you don't have to use them. Anyway, covering all numbers in the
real number range isn't possible. You can have the user pass the
desired precision in the constructor and then handle two inputs of
varying precision in a sensible way.

> int is not (misleadingly) a machine word, but represents what it sounds like: the entire range of integers, using a bigint type. The Big int type in extra would probably be fine, if it were optimised more. I noticed that there were pull requests for large performance improvements in bigint, but they were rejected for lack of comments. I suspect, if it where given its rightful place as the only fully capable integer type in the libraries, then it would rapidly gain performance through patches, too.

A pointer-size integer type is required. A big integer type cannot be
implemented without library support, and will always be significantly
slower than hardware integer types. A Rust big integer implementation
is not going to be competitive with libraries like `gmp` for at least
a decade. An enormous amount of work is required to implement the
whole range of algorithms with better asymptomatic performance, then
optimize with per-platform assembly and figure out the heuristics for
selecting the algorithms.

Placing a huge performance burden on all Rust code and pushing it far
behind Java in performance is not going to result in a fantasy world
where big integers are the same speed.

> Range checking be implemented in debug and optimisation compiler modes, to support the above, and for the general (ada-like) safety benefits that range-checking of numbers would provide. If it?s REALLY such a compilation-speed turn-off, it could be enabled with specific compiler flags.

Range checking also results in significant performance overhead. Two's
complement arithmetic is also often desired, especially in
cryptography and hashing algorithms. Checked overflow is already
provided in the standard library and alternate types handling overflow
in a different way than two's complement arithmetic could be added.
Pretty much the only useful thing here would be implementing an enum
using a hardware integer for small values, and overflowing to a big
integer.

> Rust compilers can optimise int to i32 etc. _automatically_, iff it knows there are no problems doing so, because of the number ranges involved in calculations.

This isn't going to happen in the real-world. Compilers are not magic,
and can't just go changing the size of a type across the program and
somehow figure out where all of the pointers go.

> Likewise, f64, etc. are considered optimisations of real, and can either be optimised by hand, or ? potentially, if the compiler work is done ? automatically.

Real number precision is always going to be a compromise. There is no
such thing as perfect precision, and Rust doesn't need to choose a
default. The only time I can imagine you would be able to lower the
precision is if someone casts a 32-bit floating point number to
64-bit, performs an operation and then stores it back as a 32-bit
number. It's not going to scale.

> equality comparisons are accurate for math by default

They are already accurate.

> number range checking would be available, either by default or as an optional compiler feature / optimisation flag

It's already available and you can write an integer type with checked
overflow. The performance is not impressive, and there's nothing Rust
can do about it. It's outputting the checked overflow intrinsics and
you can choose to handle the overflow flag however you wish.

> New x86_64 CPUs will (may already) implement decimal types in hardware ? in a way that?s compatible with C++?s new decimal types

AFAIK this isn't implemented in hardware. Anyway, IEEE754 decimal
floats have the same caveats as binary floats except that they won't
have lower precision than literals written as decimals.

> Slower math by default. A compiler flag could override this, or people could manually specify a faster f32/f64/i64 type, for example, if they care. I do not think this is a significant problem.

This isn't a significant problem? Rust is a systems language, and as a
systems language it is going to expose the fast low-level primitive
types. If it doesn't offer C level performance, then it's not a very
useful language. Brushing aside performance issues by pretending
optimizing compilers are omnipresent, magical tools does not work. The
language you're looking for isn't Rust, because you don't care at all
about performance.

# What can actually be done?

I have already opened an issue about removing the fallback of integer
literals to `int` when another type can be inferred. If there's no
fallback, then it's only a matter of adding support for generic
literals like Haskell to have all integer types as first-class
citizens. Rust doesn't need a default integer type.

It doesn't need to make any choices about this at all. It can offer
32-bit, 64-bit and eventually 128-bit IEEE754 floating point numbers.
It can offer 8-bit, 16-bit, 32-bit and 64-bit variants of two's
complement arithmetic integers. It can offer big integers, rational
numbers, arbitrary precision binary floats and arbitrary precision
decimal floats. You can use the suitable tool for the job without
burdening everyone with significant performance overhead and turning
Rust into something that's not a systems language.

From dbau.pp at gmail.com  Fri Jan 10 22:05:17 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 11 Jan 2014 17:05:17 +1100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0DDA3.8040501@isaac.cedarswampstudios.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
Message-ID: <52D0DF1D.1080805@gmail.com>

On 11/01/14 16:58, Isaac Dupree wrote:
> Scheme's numeric tower is one of the best in extant languages.  Take a 
> look at it.  Of course, its dynamic typing is poorly suited for Rust.
>
> Arbitrary-precision arithmetic can get you mathematically perfect 
> integers and rational numbers, but not real numbers.  There are an 
> uncountably infinite number of real numbers and sophisticated computer 
> algebra systems are devoted the problem (or estimates are used, or you 
> become unable to compare two real numbers for equality).  The MPFR C 
> library implements arbitrarily high precision floating point, but that 
> still has all the pitfalls of floating-point that you complain about. 
> For starters, try representing sqrt(2) and testing its equality with 
> e^(0.5 ln 2).
>
> In general, Rust is a systems language, so fixed-size integral types 
> are important to have.  They are better-behaved than in C and C++ in 
> that signed types are modulo, not undefined behaviour, on overflow.  
> It could be nice to have integral types that are task-failure on 
> overflow as an option too. 

We do already have some Checked* traits (using the LLVM intrinsics 
internally), which let you have task failure as one possibility on 
overflow. e.g. 
http://static.rust-lang.org/doc/master/std/num/trait.CheckedAdd.html 
(and Mul, Sub, Div too).


Huon


> As you note, bignum integers are important too; it's good they're 
> available.  I think bignum rationals would be a fine additional choice 
> to have (Haskell and GMP offer them, for example).
>
> -Isaac
>
>
> On 01/11/2014 12:15 AM, Lee Braiden wrote:
>> This may be go nowhere, especially so late in Rust's development, but I
>> feel like this is an important, relatively small change (though a
>> high-profile one).  I believe it could have a large, positive impact in
>> terms of targeting new developer communities, gaining more libraries and
>> applications, giving a better impression of the language, AND on
>> performance and futureproofing.
>>
>> However, a lot of people who are interested in performance will probably
>> baulk at this, on first sight.  If you're in that group, let me
>> encourage you to keep reading, at least until the points on performance
>> /improvements/.  Then baulk, if you like ;)
>>
>> Also, I said it in the post as well, but it's late here, so apologies
>> for any readability / editing issues.  I tried, but sleep beckons ;)
>>
>>
>> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/ 
>>
>>
>>
>> -- 
>> Lee
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Fri Jan 10 22:05:34 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:05:34 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0DB38.4030001@mozilla.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<52D0DB38.4030001@mozilla.com>
Message-ID: <CA+DvKQLTpZ=zf3pb0U-Ss+UqkJ+YekBhXGgQJDez6J9ozKDE1w@mail.gmail.com>

On Sat, Jan 11, 2014 at 12:48 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 1/10/14 9:41 PM, Corey Richardson wrote:
>>
>> The current consensus on this subject, afaik, is the rename int/uint
>> to intptr/uintptr. They're awful names, but it frees up int for a
>> *fast* bigint type. Fast here is key. We can't have a suboptimal
>> numeric type be the recommended default. We need to perform at least
>> as well as GMP for me to even consider it. Additionally we'd have
>> generic numeric literals. I don't think anyone wants what we current
>> have for *numerics*. Fixed-size integers are necessary for some tasks,
>> but numerics is not one of them.
>
> I wasn't aware of this consensus. I'm not sure what I think; int and uint as
> they are is pretty nice for array indexing.
>
> Patrick

I think it's very important to remove the default fallback to `int` so
Rust can leave this as an explicit choice for the programmer. It's too
easy to accidentally fall back to a fixed-size signed integer and
since the length varies based on the pointer-size, you may not run
into the bugs on the platform you're developing on.

It would be nice to name them based on what they are instead of making
them out as good defaults, because this should really be an explicit
choice. High-level logic will often (but not always) want a big
integer type, and it's too easy to just use `int` because it's the
"default".

From danielmicay at gmail.com  Fri Jan 10 22:08:15 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:08:15 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0DF1D.1080805@gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
Message-ID: <CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>

On Sat, Jan 11, 2014 at 1:05 AM, Huon Wilson <dbau.pp at gmail.com> wrote:
> On 11/01/14 16:58, Isaac Dupree wrote:
>>
>> Scheme's numeric tower is one of the best in extant languages.  Take a
>> look at it.  Of course, its dynamic typing is poorly suited for Rust.
>>
>> Arbitrary-precision arithmetic can get you mathematically perfect integers
>> and rational numbers, but not real numbers.  There are an uncountably
>> infinite number of real numbers and sophisticated computer algebra systems
>> are devoted the problem (or estimates are used, or you become unable to
>> compare two real numbers for equality).  The MPFR C library implements
>> arbitrarily high precision floating point, but that still has all the
>> pitfalls of floating-point that you complain about. For starters, try
>> representing sqrt(2) and testing its equality with e^(0.5 ln 2).
>>
>> In general, Rust is a systems language, so fixed-size integral types are
>> important to have.  They are better-behaved than in C and C++ in that signed
>> types are modulo, not undefined behaviour, on overflow.  It could be nice to
>> have integral types that are task-failure on overflow as an option too.
>
>
> We do already have some Checked* traits (using the LLVM intrinsics
> internally), which let you have task failure as one possibility on overflow.
> e.g. http://static.rust-lang.org/doc/master/std/num/trait.CheckedAdd.html
> (and Mul, Sub, Div too).

I don't think failure on overflow is very useful. It's still a bug if
you overflow when you don't intend it. If we did have a fast big
integer type, it would make sense to wrap it with an enum heading down
a separate branch for small and large integers, and branching on the
overflow flag to expand to a big integer. I think this is how Python's
integers are implemented.

From banderson at mozilla.com  Fri Jan 10 22:18:12 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 10 Jan 2014 22:18:12 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>	<52D0DDA3.8040501@isaac.cedarswampstudios.org>	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
Message-ID: <52D0E224.7060103@mozilla.com>

On 01/10/2014 10:08 PM, Daniel Micay wrote:
> On Sat, Jan 11, 2014 at 1:05 AM, Huon Wilson <dbau.pp at gmail.com> wrote:
>> On 11/01/14 16:58, Isaac Dupree wrote:
>>> Scheme's numeric tower is one of the best in extant languages.  Take a
>>> look at it.  Of course, its dynamic typing is poorly suited for Rust.
>>>
>>> Arbitrary-precision arithmetic can get you mathematically perfect integers
>>> and rational numbers, but not real numbers.  There are an uncountably
>>> infinite number of real numbers and sophisticated computer algebra systems
>>> are devoted the problem (or estimates are used, or you become unable to
>>> compare two real numbers for equality).  The MPFR C library implements
>>> arbitrarily high precision floating point, but that still has all the
>>> pitfalls of floating-point that you complain about. For starters, try
>>> representing sqrt(2) and testing its equality with e^(0.5 ln 2).
>>>
>>> In general, Rust is a systems language, so fixed-size integral types are
>>> important to have.  They are better-behaved than in C and C++ in that signed
>>> types are modulo, not undefined behaviour, on overflow.  It could be nice to
>>> have integral types that are task-failure on overflow as an option too.
>>
>> We do already have some Checked* traits (using the LLVM intrinsics
>> internally), which let you have task failure as one possibility on overflow.
>> e.g. http://static.rust-lang.org/doc/master/std/num/trait.CheckedAdd.html
>> (and Mul, Sub, Div too).
> I don't think failure on overflow is very useful. It's still a bug if
> you overflow when you don't intend it. If we did have a fast big
> integer type, it would make sense to wrap it with an enum heading down
> a separate branch for small and large integers, and branching on the
> overflow flag to expand to a big integer. I think this is how Python's
> integers are implemented.

I do think it's useful and is potentially a good compromise for the 
performance of the default integer type. Overflow with failure is a bug 
that tells you there's a bug. Wrapping is a bug that pretends it's not a 
bug.

Hitting a slow path unexpectedly on overflow seems to me like a recipe 
for unpredictable performance, which doesn't seem inline with Rust's 
usual goals.

From danielmicay at gmail.com  Fri Jan 10 22:20:52 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:20:52 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0E224.7060103@mozilla.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
Message-ID: <CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>

On Sat, Jan 11, 2014 at 1:18 AM, Brian Anderson <banderson at mozilla.com> wrote:
> On 01/10/2014 10:08 PM, Daniel Micay wrote:
>>
>> On Sat, Jan 11, 2014 at 1:05 AM, Huon Wilson <dbau.pp at gmail.com> wrote:
>>>
>>> On 11/01/14 16:58, Isaac Dupree wrote:
>>>>
>>>> Scheme's numeric tower is one of the best in extant languages.  Take a
>>>> look at it.  Of course, its dynamic typing is poorly suited for Rust.
>>>>
>>>> Arbitrary-precision arithmetic can get you mathematically perfect
>>>> integers
>>>> and rational numbers, but not real numbers.  There are an uncountably
>>>> infinite number of real numbers and sophisticated computer algebra
>>>> systems
>>>> are devoted the problem (or estimates are used, or you become unable to
>>>> compare two real numbers for equality).  The MPFR C library implements
>>>> arbitrarily high precision floating point, but that still has all the
>>>> pitfalls of floating-point that you complain about. For starters, try
>>>> representing sqrt(2) and testing its equality with e^(0.5 ln 2).
>>>>
>>>> In general, Rust is a systems language, so fixed-size integral types are
>>>> important to have.  They are better-behaved than in C and C++ in that
>>>> signed
>>>> types are modulo, not undefined behaviour, on overflow.  It could be
>>>> nice to
>>>> have integral types that are task-failure on overflow as an option too.
>>>
>>>
>>> We do already have some Checked* traits (using the LLVM intrinsics
>>> internally), which let you have task failure as one possibility on
>>> overflow.
>>> e.g. http://static.rust-lang.org/doc/master/std/num/trait.CheckedAdd.html
>>> (and Mul, Sub, Div too).
>>
>> I don't think failure on overflow is very useful. It's still a bug if
>> you overflow when you don't intend it. If we did have a fast big
>> integer type, it would make sense to wrap it with an enum heading down
>> a separate branch for small and large integers, and branching on the
>> overflow flag to expand to a big integer. I think this is how Python's
>> integers are implemented.
>
>
> I do think it's useful and is potentially a good compromise for the
> performance of the default integer type. Overflow with failure is a bug that
> tells you there's a bug. Wrapping is a bug that pretends it's not a bug.
>
> Hitting a slow path unexpectedly on overflow seems to me like a recipe for
> unpredictable performance, which doesn't seem inline with Rust's usual
> goals.

The branch on the overflow flag results in a very significant loss in
performance. For example, I had to carefully write the vector `push`
method for my `Vec<T>` type to only perform one overflow check. With
two checks, it's over 5 times slower due to failed branch predictions.

From pnathan at vandals.uidaho.edu  Fri Jan 10 22:21:16 2014
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Fri, 10 Jan 2014 22:21:16 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQLTpZ=zf3pb0U-Ss+UqkJ+YekBhXGgQJDez6J9ozKDE1w@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>	<52D0DB38.4030001@mozilla.com>
	<CA+DvKQLTpZ=zf3pb0U-Ss+UqkJ+YekBhXGgQJDez6J9ozKDE1w@mail.gmail.com>
Message-ID: <52D0E2DC.3090209@vandals.uidaho.edu>

On 1/10/14 10:05 PM, Daniel Micay wrote:
> On Sat, Jan 11, 2014 at 12:48 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
>> On 1/10/14 9:41 PM, Corey Richardson wrote:
>>>
>>> The current consensus on this subject, afaik, is the rename int/uint
>>> to intptr/uintptr. They're awful names, but it frees up int for a
>>> *fast* bigint type. Fast here is key. We can't have a suboptimal
>>> numeric type be the recommended default. We need to perform at least
>>> as well as GMP for me to even consider it. Additionally we'd have
>>> generic numeric literals. I don't think anyone wants what we current
>>> have for *numerics*. Fixed-size integers are necessary for some tasks,
>>> but numerics is not one of them.
>>
>> I wasn't aware of this consensus. I'm not sure what I think; int and uint as
>> they are is pretty nice for array indexing.
>>
>> Patrick
> 
> I think it's very important to remove the default fallback to `int` so
> Rust can leave this as an explicit choice for the programmer. It's too
> easy to accidentally fall back to a fixed-size signed integer and
> since the length varies based on the pointer-size, you may not run
> into the bugs on the platform you're developing on.
> 
> It would be nice to name them based on what they are instead of making
> them out as good defaults, because this should really be an explicit
> choice. High-level logic will often (but not always) want a big
> integer type, and it's too easy to just use `int` because it's the
> "default".
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> .
> 


One of the common style rules in C/C++ codebases (IME and from what I've
read) is to have an explicit typedef'd int<intsize> type:

i.e.,

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long uint32;
// and so forth.

This way it's clearly seen what the width is in the code.

It would seem to me to be an obvious choice of "optimize for the correct
case" to remove "int" and require choosing the width as part of the type
declaration (much like has been done for floats).


Note - I have zero experience in numerical analysis; my experience here
largely lies in the embedded/low-level space. A numerical analyst may
disagree 100% and prefer a generic "bigint" type for correctness of
computation. No idea. Not my area so far.

-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/e15775fc/attachment.sig>

From danielmicay at gmail.com  Fri Jan 10 22:23:29 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:23:29 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
Message-ID: <CA+DvKQLcRisWPstri9H9x16cu-AmnQtcOLgmk18MYoJcKvaDkQ@mail.gmail.com>

On Sat, Jan 11, 2014 at 12:41 AM, Corey Richardson <corey at octayn.net> wrote:
>
> We need to perform at least as well as GMP for me to even consider it.

The only realistic way to accomplish this is using GMP. Lots of other
big integer implementations exist with lots of work put into them and
the performance is not even in the same ballpark. It's difficult just
to implement all of the required algorithms:

https://gmplib.org/manual/Division-Algorithms.html#Division-Algorithms

Then, consider that you're going to need to write the low-level code
by hand in assembly so you're going to need domain experts for several
architectures. Processors and compilers are terrible at dealing with
the side effects like carry/overflow flags and can't deal with this
kind of code well.

You'll need versions for different revisions of the CPU instruction
set too, since useful features are added all of the time. For example,
Haswell introduces the `MULX` instruction (among others) and Broadwell
will introduce `ADCX` and `ADOX`.

From danielmicay at gmail.com  Fri Jan 10 22:26:07 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 01:26:07 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0E2DC.3090209@vandals.uidaho.edu>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<52D0DB38.4030001@mozilla.com>
	<CA+DvKQLTpZ=zf3pb0U-Ss+UqkJ+YekBhXGgQJDez6J9ozKDE1w@mail.gmail.com>
	<52D0E2DC.3090209@vandals.uidaho.edu>
Message-ID: <CA+DvKQJmZRgiG36zjK332+eze_di0U7VGA4bUccJK6axsEfwpw@mail.gmail.com>

C and C++ have a `stdint.h` header defining fixed-size integers.

Rust doesn't have any arbitrarily defined integer types like C. It has
8/16/32/64-bit variants of both signed and unsigned integers, along
with pointer-size integers covering the address space (int and uint).

From corey at octayn.net  Fri Jan 10 22:27:26 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 11 Jan 2014 01:27:26 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQLcRisWPstri9H9x16cu-AmnQtcOLgmk18MYoJcKvaDkQ@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CA+DvKQLcRisWPstri9H9x16cu-AmnQtcOLgmk18MYoJcKvaDkQ@mail.gmail.com>
Message-ID: <CA++BO6R1S1j5r_TvGoM74ZFUviPsoOzqsEfTm=kuY9ocbk2Ykg@mail.gmail.com>

Simple answer: then it shouldn't be our default numeric type. You say
earlier that we don't need a default, and that is a case I hadn't
considered before. But I'm growing to like it.

On Sat, Jan 11, 2014 at 1:23 AM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Sat, Jan 11, 2014 at 12:41 AM, Corey Richardson <corey at octayn.net> wrote:
>>
>> We need to perform at least as well as GMP for me to even consider it.
>
> The only realistic way to accomplish this is using GMP. Lots of other
> big integer implementations exist with lots of work put into them and
> the performance is not even in the same ballpark. It's difficult just
> to implement all of the required algorithms:
>
> https://gmplib.org/manual/Division-Algorithms.html#Division-Algorithms
>
> Then, consider that you're going to need to write the low-level code
> by hand in assembly so you're going to need domain experts for several
> architectures. Processors and compilers are terrible at dealing with
> the side effects like carry/overflow flags and can't deal with this
> kind of code well.
>
> You'll need versions for different revisions of the CPU instruction
> set too, since useful features are added all of the time. For example,
> Haswell introduces the `MULX` instruction (among others) and Broadwell
> will introduce `ADCX` and `ADOX`.

From vadimcn at gmail.com  Fri Jan 10 22:44:37 2014
From: vadimcn at gmail.com (Vadim)
Date: Fri, 10 Jan 2014 22:44:37 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
Message-ID: <CADecdiJb9tO_OuA__76afh=3OLW9Q04yZb7iCSX8o3_=4Yra8Q@mail.gmail.com>

> The branch on the overflow flag results in a very significant loss in
> performance. For example, I had to carefully write the vector `push`
> method for my `Vec<T>` type to only perform one overflow check. With
> two checks, it's over 5 times slower due to failed branch predictions.
>

Huh, that's a bit surprising.   I'd have expected branch predictor to learn
really quick that the branch is never taken.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140110/6c1d1338/attachment.html>

From carter.schonwald at gmail.com  Fri Jan 10 23:06:25 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sat, 11 Jan 2014 02:06:25 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
Message-ID: <CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>

corey, those would be very very nice refinments and a healthy progressive
yet conservative stance that leaves the room for evolving healthy defaults
(I've a slow boil program to bring breaking changes to fix numerical warts
in haskell over the next 2-3 years, )

@corey, one example of a "Real" number type can be found in mpfr
http://www.mpfr.org/ (C library for multiple-precision floating-point
computations with *correct rounding*), though note its LGPL,

on the rational number front, i believe theres 1-2 decent bsd/mit style
such libs, and i know in haskell, GHC devs are evaluating how to move away
from GMP (though this may not have any impact till whenver ghc 7.10 happens)

@patrick
yes, (u)int types that are the same size as pointers are good for indexing
into in memory arrays!

 What int type is suitable for indexing into larger than ram sized arrays
that are memmapped in regions in a demand driven way?
 (this is actually a problem i'm trying to figure out generally for some of
my own engineering work currently, and it really needs a way that lets one
talk about larger than ram arrays on 16, 32 and 64 bit systems, because
those exist! Also similar problems come up when working with distributed
arrays too! The latter perhaps using something like openmpi or infiniband
as the management layer)

@Bob, well said! Even ignoring floating point imprecision, numerical
computing still has to deal with rounding, well conditioned /
wellposed-ness of the problem being solved, and  to some extent
performance! Any "exact real" type either is unbounded (and thus provides
unbounded performance woes if used carelessly) or bounded and will
eventually suffer some precision issues in some example along with being
several orders of slower.

@bob also good point about generic support for integer/rational/floating
point literal support. Providing good literal support for those via a
suitable trait would probably help this become a much less contentious
issue (though if done poorly it does create some lockin woes)

anyways: numerical library design is very hard, and all i can say is I hope
that at least for the near term that rust errs on the side of avoiding
lockin on a bad design. And any call to action needs to have very concrete
worked out details, because the devil is in those details (well,
recursively even!)

keep up the great work!
-Carter



On Sat, Jan 11, 2014 at 12:41 AM, Corey Richardson <corey at octayn.net> wrote:

> The current consensus on this subject, afaik, is the rename int/uint
> to intptr/uintptr. They're awful names, but it frees up int for a
> *fast* bigint type. Fast here is key. We can't have a suboptimal
> numeric type be the recommended default. We need to perform at least
> as well as GMP for me to even consider it. Additionally we'd have
> generic numeric literals. I don't think anyone wants what we current
> have for *numerics*. Fixed-size integers are necessary for some tasks,
> but numerics is not one of them.
>
> As long as we rename int/uint to intptr/uintptr and leave int etc
> reserved, I think we can defer the language issues to post-1.0. It
> should be entirely backwards compatible. Development of robust
> numerics can happen outside the standard library. Talk to bjz about
> this, he has some ideas :)
>
> As an aside, you mention a "real" in your blog post like it's
> something that exists. Rust does not have any such type.
>
> On Sat, Jan 11, 2014 at 12:15 AM, Lee Braiden <leebraid at gmail.com> wrote:
> > This may be go nowhere, especially so late in Rust's development, but I
> feel
> > like this is an important, relatively small change (though a high-profile
> > one).  I believe it could have a large, positive impact in terms of
> > targeting new developer communities, gaining more libraries and
> > applications, giving a better impression of the language, AND on
> performance
> > and futureproofing.
> >
> > However, a lot of people who are interested in performance will probably
> > baulk at this, on first sight.  If you're in that group, let me encourage
> > you to keep reading, at least until the points on performance
> improvements.
> > Then baulk, if you like ;)
> >
> > Also, I said it in the post as well, but it's late here, so apologies for
> > any readability / editing issues.  I tried, but sleep beckons ;)
> >
> >
> >
> >
> http://blog.irukado.org/2014/01/an-appeal-for-correct-capable-future-proof-math-in-nascent-programming-languages/
> >
> >
> > --
> > Lee
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/d5747c74/attachment.html>

From danielmicay at gmail.com  Fri Jan 10 23:27:16 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 02:27:16 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
Message-ID: <CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>

On Sat, Jan 11, 2014 at 2:06 AM, Carter Schonwald
<carter.schonwald at gmail.com> wrote:
> corey, those would be very very nice refinments and a healthy progressive
> yet conservative stance that leaves the room for evolving healthy defaults
> (I've a slow boil program to bring breaking changes to fix numerical warts
> in haskell over the next 2-3 years, )
>
> @corey, one example of a "Real" number type can be found in mpfr
> http://www.mpfr.org/ (C library for multiple-precision floating-point
> computations with correct rounding), though note its LGPL,

You choose a precision upon construction of a floating point value.
You also have to choose the precision for the output values. The
correct rounding is in comparison to the raw `mpf_t` offered by GMP
that I think it uses under the hood.

> on the rational number front, i believe theres 1-2 decent bsd/mit style such
> libs, and i know in haskell, GHC devs are evaluating how to move away from
> GMP (though this may not have any impact till whenver ghc 7.10 happens)

None of which are comparable in performance for anything but small
integers. LGPL isn't really that big a deal, because the implication
for closed-source projects is that they have to ship linkable object
files.
>
> @Bob, well said! Even ignoring floating point imprecision, numerical
> computing still has to deal with rounding, well conditioned / wellposed-ness
> of the problem being solved, and  to some extent performance! Any "exact
> real" type either is unbounded (and thus provides unbounded performance woes
> if used carelessly) or bounded and will eventually suffer some precision
> issues in some example along with being several orders of slower.

No real number type has unbounded precision. Arbitrary precision means
the user passes the precision they desire up-front.

On the other hand, a rational number type implemented with big
integers will never lose any precision. However, you don't get `sqrt`,
`sin`, `cos`, etc.

From carter.schonwald at gmail.com  Fri Jan 10 23:52:09 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sat, 11 Jan 2014 02:52:09 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
	<CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
Message-ID: <CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>

sounds like we agree!  (and thanks for clarifying some of the detail points
i neglected)


On Sat, Jan 11, 2014 at 2:27 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 11, 2014 at 2:06 AM, Carter Schonwald
> <carter.schonwald at gmail.com> wrote:
> > corey, those would be very very nice refinments and a healthy progressive
> > yet conservative stance that leaves the room for evolving healthy
> defaults
> > (I've a slow boil program to bring breaking changes to fix numerical
> warts
> > in haskell over the next 2-3 years, )
> >
> > @corey, one example of a "Real" number type can be found in mpfr
> > http://www.mpfr.org/ (C library for multiple-precision floating-point
> > computations with correct rounding), though note its LGPL,
>
> You choose a precision upon construction of a floating point value.
> You also have to choose the precision for the output values. The
> correct rounding is in comparison to the raw `mpf_t` offered by GMP
> that I think it uses under the hood.
>
> > on the rational number front, i believe theres 1-2 decent bsd/mit style
> such
> > libs, and i know in haskell, GHC devs are evaluating how to move away
> from
> > GMP (though this may not have any impact till whenver ghc 7.10 happens)
>
> None of which are comparable in performance for anything but small
> integers. LGPL isn't really that big a deal, because the implication
> for closed-source projects is that they have to ship linkable object
> files.
> >
> > @Bob, well said! Even ignoring floating point imprecision, numerical
> > computing still has to deal with rounding, well conditioned /
> wellposed-ness
> > of the problem being solved, and  to some extent performance! Any "exact
> > real" type either is unbounded (and thus provides unbounded performance
> woes
> > if used carelessly) or bounded and will eventually suffer some precision
> > issues in some example along with being several orders of slower.
>
> No real number type has unbounded precision. Arbitrary precision means
> the user passes the precision they desire up-front.
>
> On the other hand, a rational number type implemented with big
> integers will never lose any precision. However, you don't get `sqrt`,
> `sin`, `cos`, etc.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/be469f54/attachment-0001.html>

From irrequietus at gmail.com  Fri Jan 10 23:56:46 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Sat, 11 Jan 2014 09:56:46 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52CFB098.8010100@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
Message-ID: <3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>

There is little reason to believe that having a build system in Rust would make It harder for people to package.

I do understand the predependecy argument, but the Rust compiler itself in order to compile has predependencies anyway, as does any similar project. Therefore the decisional weight of choosing a non - rust based solution over a rust one because Debian packagers have problems packaging a compiler is not adequately justified.

Using a well known build system as a means to appeal to programmers is seemingly an advantage, but it does not exonerate them from having to be competent in Rust before they write useful programs. And that has a learning curve superior to that of a build system.

As for boost's jam I have nothing to say other than boost having its own build system makes it easy for boost first; this does not mean that their needs are those of everybody else and boost is a library, not a programming language itself. So, again, a decision based on picking a popular solution on the basis of such a comparison, has flawed background.

Lastly, imagine the irony of Rust proposing to use python, c, c++ based build tools for simple packages. That would make packagers more frustrated because of a wider set of dependecies. While end users would have to also deal with a known system, its eventual inadequacies could not be met directly by Rust devs unless they start amending that system in order to deal with them. Therefore, maintenance overhead is inescapable either way, with the pessimization of relying in another nom - Rust project in order to make it worth your while to enjoy programming in Rust.

The only valid argument against having a build system proposed as the official, defacto, cross - platform way of building rust packages written in rust is its development and maintenance overhead for the rust core team itself.

That problem is easily circumvented by not proposing one right now and letting it to the end developer decide. If however an official build system is to be proposed, Rust developers merit having it done on their own platform, thus proving rust's worth. It is 2014 after all.

G.



Lee Braiden <leebraid at gmail.com> wrote:
>On 10/01/14 08:16, Gaetan wrote:
>>
>> I am not in favor of a customized build system. For instance boost 
>> library use their jam build system, and i never figured how to use it
>
>> in my projects.
>>
>> I push to use standard and well proved build system like cmake or 
>> scons, at least for major components. This would give a nice example 
>> of how to use it in any projects.
>>
>
>I'd agree with that on both counts: the principle of using something 
>standard, and the two recommendations.
>
>CMake would probably get my vote, because it's not so much a build
>tool, 
>as a meta tool for whichever system you prefer, so it would fit in well
>
>with various platform-specific IDEs, unusual platforms (android, 
>embedded, ...), etc.  That said, scons is also a strong contender, and 
>which of the two is more open to integrating patches and working with 
>new languages is very much worth considering.
>
>I think Rust will be contributing to the wider community by lending its
>
>support (and patches) to a common, modern build system, AND it will get
>
>something back in terms of users who already know the build system.
>
>
>>     On Friday, January 10, 2014, George Makrydakis wrote:
>>
>>
>>         Hello,
>>
>>         Having a build system entirely dependent of Rust alone, would
>>         make the entire experience in deploying the language
>extremely
>>         cohere. The only counter - argument is indeed that it would
>>         require some work to get this to fruition. I would like to
>>         know if this has any chance of getting priority soon enough.
>>
>
>Bear in mind that Debian are having a lot of issues packaging Rust 
>already, because it self-compiles.  If the build tool also had a Rust 
>pre-dependency, that would be a big step backwards.


From dpx.infinity at gmail.com  Sat Jan 11 00:15:39 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sat, 11 Jan 2014 12:15:39 +0400
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
	<CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>
Message-ID: <CA+jWdBgz53T+KnSDPxmoQFbBHzz5eZ7EoRekK5rN3Hg-f9R6Kg@mail.gmail.com>

Oh, thanks. It does work now. Are macro scoping rules documented
somewhere except the compiler source code?

2014/1/11 Chris Morgan <chris.morganiser at gmail.com>:
> The macro is being defined after the module is defined. You need to move the
> macro definition before the "pub mod submod;" line. Also due to the scoping
> rules of macros, you don't need #[macro_escape] there---it's a child, so it
> gets the macro. Only siblings, parents, uncles, aunts, cousins, &c. would
> need it.
>
> On Jan 11, 2014 9:46 AM, "Vladimir Matveev" <dpx.infinity at gmail.com> wrote:
>>
>> Hi,
>>
>> As far as I understand, the current way to export macros is to
>> annotate the module with macro_rules definition with #[macro_escape]
>> annotation. But I just can't get it right, and my macro is not visible
>> in other module :(
>>
>> Here is what I have:
>>
>> ----- START -----
>> /lib.rs:
>> #[feature(macro_rules)];
>>
>> pub mod m1;
>>
>> --
>> /m1/mod.rs:
>> #[macro_escape];
>>
>> pub mod submod;
>>
>> macro_rules! example_rule(
>>     () => (mod test;)
>> )
>>
>> --
>> /m1/submod.rs:
>> use m1;
>>
>> example_rule!()
>> ----- END -----
>>
>> I have assumed that putting #[macro_escape] annotation to a module
>> makes all macros from that module available in all modules which
>> import this module, but apparently I'm wrong because the code above
>> does not work with 'macro undefined' error.
>>
>> Could please someone explain how #[macro_escape] works in detail? I
>> couldn't find any documentation on it, and looking through standard
>> libs was not helpful.
>>
>> Thanks,
>> Vladimir.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

From marijnh at gmail.com  Sat Jan 11 02:18:41 2014
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Sat, 11 Jan 2014 11:18:41 +0100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
	<CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
	<CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
Message-ID: <CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>

I am not aware of an efficient way to provide
automatic-overflow-to-bignum semantics in a non-garbage-collected
language, without also imposing the burden of references/move
semantics/etc on users of small integers. I.e. integers, if they may
hold references to allocated memory can no longer sanely be considered
a simple value type, which doesn't seem like it'd be a good idea for
Rust.

If there is a good solution to this, I'd love to find out about it.

From mneumann at ntecs.de  Sat Jan 11 02:42:21 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sat, 11 Jan 2014 11:42:21 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
Message-ID: <52D1200D.8050600@ntecs.de>

rustc is "just" another regular Rust application. So use the tools that 
any other Rust application (will) use ;-)

I think at some point in time there will be a capable build tool written 
in Rust (like there is for all the other languages). Then it would make
sense to switch using it for the compiler as well.

Michael

Am 11.01.2014 08:56, schrieb George Makrydakis:
> There is little reason to believe that having a build system in Rust would make It harder for people to package.
>
> I do understand the predependecy argument, but the Rust compiler itself in order to compile has predependencies anyway, as does any similar project. Therefore the decisional weight of choosing a non - rust based solution over a rust one because Debian packagers have problems packaging a compiler is not adequately justified.
>
> Using a well known build system as a means to appeal to programmers is seemingly an advantage, but it does not exonerate them from having to be competent in Rust before they write useful programs. And that has a learning curve superior to that of a build system.
>
> As for boost's jam I have nothing to say other than boost having its own build system makes it easy for boost first; this does not mean that their needs are those of everybody else and boost is a library, not a programming language itself. So, again, a decision based on picking a popular solution on the basis of such a comparison, has flawed background.
>
> Lastly, imagine the irony of Rust proposing to use python, c, c++ based build tools for simple packages. That would make packagers more frustrated because of a wider set of dependecies. While end users would have to also deal with a known system, its eventual inadequacies could not be met directly by Rust devs unless they start amending that system in order to deal with them. Therefore, maintenance overhead is inescapable either way, with the pessimization of relying in another nom - Rust project in order to make it worth your while to enjoy programming in Rust.
>
> The only valid argument against having a build system proposed as the official, defacto, cross - platform way of building rust packages written in rust is its development and maintenance overhead for the rust core team itself.
>
> That problem is easily circumvented by not proposing one right now and letting it to the end developer decide. If however an official build system is to be proposed, Rust developers merit having it done on their own platform, thus proving rust's worth. It is 2014 after all.
>
> G.
>
>
>
> Lee Braiden <leebraid at gmail.com> wrote:
>> On 10/01/14 08:16, Gaetan wrote:
>>> I am not in favor of a customized build system. For instance boost
>>> library use their jam build system, and i never figured how to use it
>>> in my projects.
>>>
>>> I push to use standard and well proved build system like cmake or
>>> scons, at least for major components. This would give a nice example
>>> of how to use it in any projects.
>>>
>> I'd agree with that on both counts: the principle of using something
>> standard, and the two recommendations.
>>
>> CMake would probably get my vote, because it's not so much a build
>> tool,
>> as a meta tool for whichever system you prefer, so it would fit in well
>>
>> with various platform-specific IDEs, unusual platforms (android,
>> embedded, ...), etc.  That said, scons is also a strong contender, and
>> which of the two is more open to integrating patches and working with
>> new languages is very much worth considering.
>>
>> I think Rust will be contributing to the wider community by lending its
>>
>> support (and patches) to a common, modern build system, AND it will get
>>
>> something back in terms of users who already know the build system.
>>
>>
>>>      On Friday, January 10, 2014, George Makrydakis wrote:
>>>
>>>
>>>          Hello,
>>>
>>>          Having a build system entirely dependent of Rust alone, would
>>>          make the entire experience in deploying the language
>> extremely
>>>          cohere. The only counter - argument is indeed that it would
>>>          require some work to get this to fruition. I would like to
>>>          know if this has any chance of getting priority soon enough.
>>>
>> Bear in mind that Debian are having a lot of issues packaging Rust
>> already, because it self-compiles.  If the build tool also had a Rust
>> pre-dependency, that would be a big step backwards.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From irrequietus at gmail.com  Sat Jan 11 03:26:23 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Sat, 11 Jan 2014 13:26:23 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D1200D.8050600@ntecs.de>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<52D1200D.8050600@ntecs.de>
Message-ID: <bdaa5ce3-6d92-4c90-9887-341f6744790c@email.android.com>

Indeed. I fully agree with your apt foreshadowing of events.

If it is not feasible to have a rust based tool now, as long as any other tool is not given priviledged status formally speaking, using whatever ready means appropriate is a strategy that scales well within a limited time period.

>From this thread it seems a reasonably acceptable compromise - until a rust tool is given priority; but it is not clear if this is the actual plan. I think that discussing about the merits of other build systems should not be transmuted into an agenda of using them as the blessed defaults.

Specifying this is very important for rust to be a modern, cohere platform - level solution with easy exchange of libraries among users, relying on a common environment that is compatible with the goals of Rust itself. This is why it should be fully controlled by the Rust community, thus written in Rust.

Think about the merit of having such a system in rust, eventually deployed by other projects, unrelated to rust, because it ends up being *that* good.

This is a matter that should be definitively discussed after Rust 1.0, when the language starts being backwards - reliable to a considerable extent.

G.

Michael Neumann <mneumann at ntecs.de> wrote:
>rustc is "just" another regular Rust application. So use the tools that
>
>any other Rust application (will) use ;-)
>
>I think at some point in time there will be a capable build tool
>written 
>in Rust (like there is for all the other languages). Then it would make
>sense to switch using it for the compiler as well.
>
>Michael
>
>Am 11.01.2014 08:56, schrieb George Makrydakis:
>> There is little reason to believe that having a build system in Rust
>would make It harder for people to package.
>>
>> I do understand the predependecy argument, but the Rust compiler
>itself in order to compile has predependencies anyway, as does any
>similar project. Therefore the decisional weight of choosing a non -
>rust based solution over a rust one because Debian packagers have
>problems packaging a compiler is not adequately justified.
>>
>> Using a well known build system as a means to appeal to programmers
>is seemingly an advantage, but it does not exonerate them from having
>to be competent in Rust before they write useful programs. And that has
>a learning curve superior to that of a build system.
>>
>> As for boost's jam I have nothing to say other than boost having its
>own build system makes it easy for boost first; this does not mean that
>their needs are those of everybody else and boost is a library, not a
>programming language itself. So, again, a decision based on picking a
>popular solution on the basis of such a comparison, has flawed
>background.
>>
>> Lastly, imagine the irony of Rust proposing to use python, c, c++
>based build tools for simple packages. That would make packagers more
>frustrated because of a wider set of dependecies. While end users would
>have to also deal with a known system, its eventual inadequacies could
>not be met directly by Rust devs unless they start amending that system
>in order to deal with them. Therefore, maintenance overhead is
>inescapable either way, with the pessimization of relying in another
>nom - Rust project in order to make it worth your while to enjoy
>programming in Rust.
>>
>> The only valid argument against having a build system proposed as the
>official, defacto, cross - platform way of building rust packages
>written in rust is its development and maintenance overhead for the
>rust core team itself.
>>
>> That problem is easily circumvented by not proposing one right now
>and letting it to the end developer decide. If however an official
>build system is to be proposed, Rust developers merit having it done on
>their own platform, thus proving rust's worth. It is 2014 after all.
>>
>> G.
>>
>>
>>
>> Lee Braiden <leebraid at gmail.com> wrote:
>>> On 10/01/14 08:16, Gaetan wrote:
>>>> I am not in favor of a customized build system. For instance boost
>>>> library use their jam build system, and i never figured how to use
>it
>>>> in my projects.
>>>>
>>>> I push to use standard and well proved build system like cmake or
>>>> scons, at least for major components. This would give a nice
>example
>>>> of how to use it in any projects.
>>>>
>>> I'd agree with that on both counts: the principle of using something
>>> standard, and the two recommendations.
>>>
>>> CMake would probably get my vote, because it's not so much a build
>>> tool,
>>> as a meta tool for whichever system you prefer, so it would fit in
>well
>>>
>>> with various platform-specific IDEs, unusual platforms (android,
>>> embedded, ...), etc.  That said, scons is also a strong contender,
>and
>>> which of the two is more open to integrating patches and working
>with
>>> new languages is very much worth considering.
>>>
>>> I think Rust will be contributing to the wider community by lending
>its
>>>
>>> support (and patches) to a common, modern build system, AND it will
>get
>>>
>>> something back in terms of users who already know the build system.
>>>
>>>
>>>>      On Friday, January 10, 2014, George Makrydakis wrote:
>>>>
>>>>
>>>>          Hello,
>>>>
>>>>          Having a build system entirely dependent of Rust alone,
>would
>>>>          make the entire experience in deploying the language
>>> extremely
>>>>          cohere. The only counter - argument is indeed that it
>would
>>>>          require some work to get this to fruition. I would like to
>>>>          know if this has any chance of getting priority soon
>enough.
>>>>
>>> Bear in mind that Debian are having a lot of issues packaging Rust
>>> already, because it self-compiles.  If the build tool also had a
>Rust
>>> pre-dependency, that would be a big step backwards.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/d5d5c3c4/attachment-0001.html>

From lists at dhardy.name  Sat Jan 11 03:51:57 2014
From: lists at dhardy.name (Diggory Hardy)
Date: Sat, 11 Jan 2014 12:51:57 +0100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
	<CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
Message-ID: <4727130.mmVhLcRl2C@yoga.dhardy>

There is static analysis (i.e. determine ahead of time exactly what values 
variables may take), but it's certainly not a panacea: the analysis step is 
slow (probably too slow to fully integrate into a compiler), not everything 
can be solved, and most existing solvers are not free software as far as I am 
aware.

It could perhaps be used for a little optimisation and for proofs that overflow 
doesn't occur in some cases, but integrating a static analysis system with a 
compiler would be no easy task. Leon is the most advanced version I'm aware of 
(though it's not really my field): http://lara.epfl.ch/w/leon

On Saturday 11 January 2014 11:18:41 Marijn Haverbeke wrote:
> I am not aware of an efficient way to provide
> automatic-overflow-to-bignum semantics in a non-garbage-collected
> language, without also imposing the burden of references/move
> semantics/etc on users of small integers. I.e. integers, if they may
> hold references to allocated memory can no longer sanely be considered
> a simple value type, which doesn't seem like it'd be a good idea for
> Rust.
> 
> If there is a good solution to this, I'd love to find out about it.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/22fe5c56/attachment.sig>

From james at mansionfamily.plus.com  Sat Jan 11 03:59:59 2014
From: james at mansionfamily.plus.com (james)
Date: Sat, 11 Jan 2014 11:59:59 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
Message-ID: <52D1323F.1030505@mansionfamily.plus.com>

On 11/01/2014 07:56, George Makrydakis wrote:
> There is little reason to believe that having a build system in Rust would make It harder for people to package.
Surely you just need an alternate that is a script generated as a 
from-clean dry run with -j1?  It gives you the commands needed, in an 
order that works.


From james at mansionfamily.plus.com  Sat Jan 11 04:03:54 2014
From: james at mansionfamily.plus.com (james)
Date: Sat, 11 Jan 2014 12:03:54 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
Message-ID: <52D1332A.1000300@mansionfamily.plus.com>

On 10/01/2014 08:54, Jan Niklas Hasse wrote:
> Also cmake still depends on make (or even worse Visual Studio / Xcode).
We use cmake with ninja at work, and that seems to work pretty well.

I suggest if you want to write a tool, then you first write something 
that generates ninja files.  Then you immediately have a bootstrap 
mechanism, plus something that will do builds rather quickly 
thereafter.  scons can be (very) slow.  My experience with waf was 
better, but I think generating a nnja script is superior and there are 
several tools to do that.  You could look at gyp, for example.


From glaebhoerl at gmail.com  Sat Jan 11 06:03:09 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 11 Jan 2014 15:03:09 +0100
Subject: [rust-dev] returning functions in rust
In-Reply-To: <CA+DvKQ+08rCAY0c7JAeit-fs1Gf1Je3RpO587JA6mN4DRJtA7g@mail.gmail.com>
References: <CAEYWR9v_RxW8ZMrdJ5k0oPf8e-UfPFaPT+heX4m1kTBiAwUUow@mail.gmail.com>
	<52D0397C.3010305@mozilla.com>
	<F34DD63D-9A12-4BD9-A33B-5EA6E43F9DCB@sb.org>
	<4e49b135-fa55-49a6-96b5-d3c6270a8115@email.android.com>
	<CA+DvKQ+08rCAY0c7JAeit-fs1Gf1Je3RpO587JA6mN4DRJtA7g@mail.gmail.com>
Message-ID: <CAPoegswvE3wvA9VWhTZO6tAjvf0KedDjR=NVSr45rXAbpS-SLg@mail.gmail.com>

On Fri, Jan 10, 2014 at 8:01 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Fri, Jan 10, 2014 at 1:57 PM, Patrick Walton <pwalton at mozilla.com>
> wrote:
> > It doesn't exist, outside of traits. Unboxed closures will probably make
> it
> > possible to express once again though.
> >
> > Patrick
>
> The tricky part is the need to infer the return type if it's defined
> inside the function since it's different per-closure.
>

I wrote up a small proposal for a feature that could help with this:

https://github.com/mozilla/rust/issues/11455



> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/f2ebd7d7/attachment.html>

From irrequietus at gmail.com  Sat Jan 11 08:53:54 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Sat, 11 Jan 2014 18:53:54 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D1332A.1000300@mansionfamily.plus.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CALckf6jOJvK9doA1eDXfQWfCagwHYRA4qtnE3iWai8Fbh_TpDw@mail.gmail.com>
	<52D1332A.1000300@mansionfamily.plus.com>
Message-ID: <CAPkOUVg=79C0A-RRM_SH=98Z1XVQVzphd+3YQLiVr_=4=3vuKQ@mail.gmail.com>

I would not exclude ninja from the candidates of an in - between solution
for the time being. Imagine the power of ninja but implementing its
conceptual machinery in expressive Rust code. It would be an interesting
combination indeed. That could bring even more advantages since it would be
implemented in Rust.


On Sat, Jan 11, 2014 at 2:03 PM, james <james at mansionfamily.plus.com> wrote:

> On 10/01/2014 08:54, Jan Niklas Hasse wrote:
>
>> Also cmake still depends on make (or even worse Visual Studio / Xcode).
>>
> We use cmake with ninja at work, and that seems to work pretty well.
>
> I suggest if you want to write a tool, then you first write something that
> generates ninja files.  Then you immediately have a bootstrap mechanism,
> plus something that will do builds rather quickly thereafter.  scons can be
> (very) slow.  My experience with waf was better, but I think generating a
> nnja script is superior and there are several tools to do that.  You could
> look at gyp, for example.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/49b632b2/attachment.html>

From owen.shepherd at e43.eu  Sat Jan 11 08:54:41 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sat, 11 Jan 2014 16:54:41 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
Message-ID: <CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>

On 11 January 2014 06:20, Daniel Micay <danielmicay at gmail.com> wrote:

> The branch on the overflow flag results in a very significant loss in
> performance. For example, I had to carefully write the vector `push`
> method for my `Vec<T>` type to only perform one overflow check. With
> two checks, it's over 5 times slower due to failed branch predictions.
>

What did the generated code look like? I suspect that LLVM wasn't
generating optimal code, perhaps because Rust wasn't giving it appropriate
hints or because of optimizer bugs. For reference, on AMD64 the code should
look something like the following hypothetical code:

vec_allocate:
MOV $SIZE, %eax
MUL %rsi
JC Lerror
ADD $HEADER_SIZE, %rax
JC Lerror
MOV %rax, %rsi
JMP malloc
Lerror:
// Code to raise error here

Note that the ordering is EXTREMELY important! x86 doesn't give you any
separate branch hints (excluding two obsolete ones which only the Pentium
IV ever cared about) so your only clue to the optimizer is the branch
direction.

I suspect your generated code had forward branches for the no overflow
case. Thats absolutely no good (codegen inerting "islands" of failure case
code); it will screw up the branch predictor.

x86 defaults to predicting all (conditional) forward jumps not taken, all
conditional backwards jumps taken (Loops!). If the optimizer wasn't
informed correctly, it will probably not have obeyed that.

Being as the overflow case should basically be never hit, there is no
reason for it to ever be loaded into the optimizer, so that is good

(P.S. If the rust compiler is really good it'll convince LLVM to put the
error case branch code in a separate section so it can all be packed
together far away from useful cache lines and TLB entries)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/3e9efb21/attachment-0001.html>

From irrequietus at gmail.com  Sat Jan 11 09:08:56 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Sat, 11 Jan 2014 19:08:56 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D1323F.1030505@mansionfamily.plus.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<52D1323F.1030505@mansionfamily.plus.com>
Message-ID: <CAPkOUVjUEdOM9hknkknOLQEWt5P8trezjAH0m3CVgjr8GuNDTA@mail.gmail.com>

Which is why the argument of easier packaging because tool X is used by
person Y advocating it, is meaningless from both a theoretical and
practical point of view. In the end, it is just an application of graph
theory, which is widely used in dependency resolution. Another option would
be a sat solver producing the same result as for example is the case for
libzypp in openSuSE.

Again, it is a matter of combining any of these solutions with a reliable
and simple to understand format in order to produce a build system that is
consistent first, fool - proof most of the time. Surely, doing this in Rust
should be quite easily doable, given the fact that it is designed to be a
systems language. Handling entire package life cycles would be a natural
fit for a language with Rust's problem domain, even beyond the purposes of
Rust itself. Think big, then bigger.

G.



On Sat, Jan 11, 2014 at 1:59 PM, james <james at mansionfamily.plus.com> wrote:

> On 11/01/2014 07:56, George Makrydakis wrote:
>
>> There is little reason to believe that having a build system in Rust
>> would make It harder for people to package.
>>
> Surely you just need an alternate that is a script generated as a
> from-clean dry run with -j1?  It gives you the commands needed, in an order
> that works.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/30993623/attachment.html>

From rexlen at gmail.com  Sat Jan 11 09:17:21 2014
From: rexlen at gmail.com (Renato Lenzi)
Date: Sat, 11 Jan 2014 18:17:21 +0100
Subject: [rust-dev] Failure
Message-ID: <CAM0XVgsGvEd0LT23r=8WYquV+b2MvczgZ2gbo_YbTinROJWAKw@mail.gmail.com>

The code is trivial:

fn main()
{
let x = 3;
println(x.to_str());
}

the error is this (on Win7)

d:\Rust09\bin>rustc 00025.rs
00025.rs:4:11: 4:22 error: multiple applicable methods in scope
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #1 is `std::int::ToStr$int::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #2 is `std::i8::ToStr$i8::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #3 is `std::i16::ToStr$i16::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #4 is `std::i32::ToStr$i32::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #5 is `std::i64::ToStr$i64::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #6 is `std::uint::ToStr$uint::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #7 is `std::u8::ToStr$u8::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #8 is `std::u16::ToStr$u16::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #9 is `std::u32::ToStr$u32::to_str`
00025.rs:4              println(x.to_str());
                                ^~~~~~~~~~~
00025.rs:4:11: 4:22 note: candidate #10 is `std::u64::ToStr$u64::to_str`
00025.rs:4              println(x.to_str());

                              ^~~~~~~~~~~
error: aborting due to previous error
task 'rustc' failed at 'explicit failure',
C:\bot\slave\dist2-win\build\src\libs
yntax\diagnostic.rs:75
task '<main>' failed at 'explicit failure',
C:\bot\slave\dist2-win\build\src\lib
rustc\lib.rs:453

any idea?
thanks.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/8e0524a6/attachment.html>

From corey at octayn.net  Sat Jan 11 09:21:56 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 11 Jan 2014 12:21:56 -0500
Subject: [rust-dev] Failure
In-Reply-To: <CAM0XVgsGvEd0LT23r=8WYquV+b2MvczgZ2gbo_YbTinROJWAKw@mail.gmail.com>
References: <CAM0XVgsGvEd0LT23r=8WYquV+b2MvczgZ2gbo_YbTinROJWAKw@mail.gmail.com>
Message-ID: <CA++BO6QL4P8g-d8zq=L3jTk-n4w8cWbuKL0awLVx+r6ykzzOxA@mail.gmail.com>

What type is `3`? There's know way to know. Use `3i` for int, `3u` for
uint, etc.

On Sat, Jan 11, 2014 at 12:17 PM, Renato Lenzi <rexlen at gmail.com> wrote:
> The code is trivial:
>
> fn main()
> {
> let x = 3;
> println(x.to_str());
> }
>
> the error is this (on Win7)
>
> d:\Rust09\bin>rustc 00025.rs
> 00025.rs:4:11: 4:22 error: multiple applicable methods in scope
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #1 is `std::int::ToStr$int::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #2 is `std::i8::ToStr$i8::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #3 is `std::i16::ToStr$i16::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #4 is `std::i32::ToStr$i32::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #5 is `std::i64::ToStr$i64::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #6 is `std::uint::ToStr$uint::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #7 is `std::u8::ToStr$u8::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #8 is `std::u16::ToStr$u16::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #9 is `std::u32::ToStr$u32::to_str`
> 00025.rs:4              println(x.to_str());
>                                 ^~~~~~~~~~~
> 00025.rs:4:11: 4:22 note: candidate #10 is `std::u64::ToStr$u64::to_str`
> 00025.rs:4              println(x.to_str());
>
>                               ^~~~~~~~~~~
> error: aborting due to previous error
> task 'rustc' failed at 'explicit failure',
> C:\bot\slave\dist2-win\build\src\libs
> yntax\diagnostic.rs:75
> task '<main>' failed at 'explicit failure',
> C:\bot\slave\dist2-win\build\src\lib
> rustc\lib.rs:453
>
> any idea?
> thanks.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From danielmicay at gmail.com  Sat Jan 11 11:33:02 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 14:33:02 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
Message-ID: <CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>

On Sat, Jan 11, 2014 at 11:54 AM, Owen Shepherd <owen.shepherd at e43.eu> wrote:
> On 11 January 2014 06:20, Daniel Micay <danielmicay at gmail.com> wrote:
>>
>> The branch on the overflow flag results in a very significant loss in
>> performance. For example, I had to carefully write the vector `push`
>> method for my `Vec<T>` type to only perform one overflow check. With
>> two checks, it's over 5 times slower due to failed branch predictions.
>
>
> What did the generated code look like? I suspect that LLVM wasn't generating
> optimal code, perhaps because Rust wasn't giving it appropriate hints or
> because of optimizer bugs. For reference, on AMD64 the code should look
> something like the following hypothetical code:
>
> vec_allocate:
> MOV $SIZE, %eax
> MUL %rsi
> JC Lerror
> ADD $HEADER_SIZE, %rax
> JC Lerror
> MOV %rax, %rsi
> JMP malloc
> Lerror:
> // Code to raise error here
>
> Note that the ordering is EXTREMELY important! x86 doesn't give you any
> separate branch hints (excluding two obsolete ones which only the Pentium IV
> ever cared about) so your only clue to the optimizer is the branch
> direction.
>
> I suspect your generated code had forward branches for the no overflow case.
> Thats absolutely no good (codegen inerting "islands" of failure case code);
> it will screw up the branch predictor.
>
> x86 defaults to predicting all (conditional) forward jumps not taken, all
> conditional backwards jumps taken (Loops!). If the optimizer wasn't informed
> correctly, it will probably not have obeyed that.
>
> Being as the overflow case should basically be never hit, there is no reason
> for it to ever be loaded into the optimizer, so that is good
>
> (P.S. If the rust compiler is really good it'll convince LLVM to put the
> error case branch code in a separate section so it can all be packed
> together far away from useful cache lines and TLB entries)

Rust directly exposes the checked overflow intrinsics so these are
what was used. It already considers branches calling a `noreturn`
function to be colder, so adding an explicit branch hint (which is
easy enough via `llvm.expect` doesn't help). Feel free to implement it
yourself if you think you can do better. The compiler work is already
implemented.  I doubt you'll get something performing in the same
ballpark as plain integers.

From danielmicay at gmail.com  Sat Jan 11 11:43:25 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 14:43:25 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0E224.7060103@mozilla.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
Message-ID: <CA+DvKQ+tCjmqgGKXHPdoyTg7jJWCzqxPmABYDhfvWLigt7wqXg@mail.gmail.com>

On Sat, Jan 11, 2014 at 1:18 AM, Brian Anderson <banderson at mozilla.com> wrote:
> On 01/10/2014 10:08 PM, Daniel Micay wrote:
>>
>> On Sat, Jan 11, 2014 at 1:05 AM, Huon Wilson <dbau.pp at gmail.com> wrote:
>>>
>>> On 11/01/14 16:58, Isaac Dupree wrote:
>>>>
>>>> Scheme's numeric tower is one of the best in extant languages.  Take a
>>>> look at it.  Of course, its dynamic typing is poorly suited for Rust.
>>>>
>>>> Arbitrary-precision arithmetic can get you mathematically perfect
>>>> integers
>>>> and rational numbers, but not real numbers.  There are an uncountably
>>>> infinite number of real numbers and sophisticated computer algebra
>>>> systems
>>>> are devoted the problem (or estimates are used, or you become unable to
>>>> compare two real numbers for equality).  The MPFR C library implements
>>>> arbitrarily high precision floating point, but that still has all the
>>>> pitfalls of floating-point that you complain about. For starters, try
>>>> representing sqrt(2) and testing its equality with e^(0.5 ln 2).
>>>>
>>>> In general, Rust is a systems language, so fixed-size integral types are
>>>> important to have.  They are better-behaved than in C and C++ in that
>>>> signed
>>>> types are modulo, not undefined behaviour, on overflow.  It could be
>>>> nice to
>>>> have integral types that are task-failure on overflow as an option too.
>>>
>>>
>>> We do already have some Checked* traits (using the LLVM intrinsics
>>> internally), which let you have task failure as one possibility on
>>> overflow.
>>> e.g. http://static.rust-lang.org/doc/master/std/num/trait.CheckedAdd.html
>>> (and Mul, Sub, Div too).
>>
>> I don't think failure on overflow is very useful. It's still a bug if
>> you overflow when you don't intend it. If we did have a fast big
>> integer type, it would make sense to wrap it with an enum heading down
>> a separate branch for small and large integers, and branching on the
>> overflow flag to expand to a big integer. I think this is how Python's
>> integers are implemented.
>
>
> I do think it's useful and is potentially a good compromise for the
> performance of the default integer type. Overflow with failure is a bug that
> tells you there's a bug. Wrapping is a bug that pretends it's not a bug.

This is why `clang` exposes sanitize options for integer overflow. You
could use `-ftrapv` in production... but why bother using C if you're
taking a significant performance hit like that?

> Hitting a slow path unexpectedly on overflow seems to me like a recipe for
> unpredictable performance, which doesn't seem inline with Rust's usual
> goals.

It's certainly better than the process exiting, which is what's going
to happen in real systems when failure occurs. Either that, or they're
going to lose a bunch of data from the task it caused to unwind. The
only way to make overflow not a bug is to expand to a big integer or
use a big integer from the start.

From vadimcn at gmail.com  Sat Jan 11 13:06:34 2014
From: vadimcn at gmail.com (Vadim)
Date: Sat, 11 Jan 2014 13:06:34 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQ+tCjmqgGKXHPdoyTg7jJWCzqxPmABYDhfvWLigt7wqXg@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+tCjmqgGKXHPdoyTg7jJWCzqxPmABYDhfvWLigt7wqXg@mail.gmail.com>
Message-ID: <CADecdi+sQ_AOj1w5LVddvLCt=t0SUikvAejgnzJs56oQq9GYiA@mail.gmail.com>

> > Hitting a slow path unexpectedly on overflow seems to me like a recipe
> for
> > unpredictable performance, which doesn't seem inline with Rust's usual
> > goals.
>
> It's certainly better than the process exiting, which is what's going
> to happen in real systems when failure occurs. Either that, or they're
> going to lose a bunch of data from the task it caused to unwind. The
> only way to make overflow not a bug is to expand to a big integer or
> use a big integer from the start.
>

IMHO, integer overflow detection should be considered strictly a security
feature.   I can think of very few cases, when after expansion to a bigint,
the program wouldn't have bombed out anyways a few lines later - on some
array access or a system API call.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/34d0e1da/attachment.html>

From owen.shepherd at e43.eu  Sat Jan 11 13:31:00 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sat, 11 Jan 2014 21:31:00 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
Message-ID: <CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>

So I just did a test. Took the following rust code:
pub fn test_wrap(x : u32, y : u32) -> u32 {
    return x.checked_mul(&y).unwrap().checked_add(&16).unwrap();
}

And got the following blob of assembly out. What we have there, my friends,
is a complete failure of the optimizer (N.B. it works for the simple case
of checked_add alone)

Preamble:

__ZN9test_wrap19hc4c136f599917215af4v0.0E:
    .cfi_startproc
    cmpl    %fs:20, %esp
    ja    LBB0_2
    pushl    $12
    pushl    $20
    calll    ___morestack
    ret
LBB0_2:
    pushl    %ebp
Ltmp2:
    .cfi_def_cfa_offset 8
Ltmp3:
    .cfi_offset %ebp, -8
    movl    %esp, %ebp
Ltmp4:
    .cfi_def_cfa_register %ebp

Align stack (for what? We don't do any SSE)

    andl    $-8, %esp
    subl    $16, %esp

Multiply x * y

    movl    12(%ebp), %eax
    mull    16(%ebp)
    jno    LBB0_4

If it didn't overflow, stash a 0 at top of stack

    movb    $0, (%esp)
    jmp    LBB0_5

If it did overflow, stash a 1 at top of stack (we are building an
Option<u32> here)
LBB0_4:
    movb    $1, (%esp)
    movl    %eax, 4(%esp)

Take pointer to &this for __thiscall:
LBB0_5:
    leal    (%esp), %ecx
    calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E

Do the addition to the result

    addl    $16, %eax

Repeat the previous circus

    jae    LBB0_7
    movb    $0, 8(%esp)
    jmp    LBB0_8
LBB0_7:
    movb    $1, 8(%esp)
    movl    %eax, 12(%esp)
LBB0_8:
    leal    8(%esp), %ecx
    calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
    movl    %ebp, %esp
    popl    %ebp
    ret
    .cfi_endproc


Yeah. Its' not fast because its' not inlining through option::unwrap.


I'm not sure what can be done for this, and whether its' on the LLVM side
or the Rust side of things. My first instinct: find out what happens when
fail! is moved out-of-line from unwrap() into its' own function (especially
if that function can be marked noinline!), because optimizers often choke
around EH.



I tried to test the "optimal" situation in a synthetic benchmark:
https://gist.github.com/oshepherd/8376705
(In C for expediency. N.B. you must set core affinity before running this
benchmark because I hackishly just read the TSC. i386 only.)


but the results are really bizzare and seem to have a multitude of
affecting factors (For example, if you minimally unroll and have the JCs
jump straight to abort, you get vastly different performance from jumping
to a closer location and then onwards to abort. Bear in mind that the
overflow case never happens during the test). It would be interesting to do
a test in which a "trivial" implementation of trap-on-overflow is added to
rustc (read: the overflow case just jumps straight to abort or similar, to
minimize optimizer influence and variability) to see how defaulting to
trapping ints affects real world workloads.

I wonder what level of performance impact would be considered "acceptable"
for improved safety by default?

Mind you, I think that what I'd propose is that i32 = Trapping, i32w =
wrapping, i32s = saturating, or something similar

Owen Shepherd
http://owenshepherd.net | owen.shepherd at e43.eu


On 11 January 2014 19:33, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 11, 2014 at 11:54 AM, Owen Shepherd <owen.shepherd at e43.eu>
> wrote:
> > On 11 January 2014 06:20, Daniel Micay <danielmicay at gmail.com> wrote:
> >>
> >> The branch on the overflow flag results in a very significant loss in
> >> performance. For example, I had to carefully write the vector `push`
> >> method for my `Vec<T>` type to only perform one overflow check. With
> >> two checks, it's over 5 times slower due to failed branch predictions.
> >
> >
> > What did the generated code look like? I suspect that LLVM wasn't
> generating
> > optimal code, perhaps because Rust wasn't giving it appropriate hints or
> > because of optimizer bugs. For reference, on AMD64 the code should look
> > something like the following hypothetical code:
> >
> > vec_allocate:
> > MOV $SIZE, %eax
> > MUL %rsi
> > JC Lerror
> > ADD $HEADER_SIZE, %rax
> > JC Lerror
> > MOV %rax, %rsi
> > JMP malloc
> > Lerror:
> > // Code to raise error here
> >
> > Note that the ordering is EXTREMELY important! x86 doesn't give you any
> > separate branch hints (excluding two obsolete ones which only the
> Pentium IV
> > ever cared about) so your only clue to the optimizer is the branch
> > direction.
> >
> > I suspect your generated code had forward branches for the no overflow
> case.
> > Thats absolutely no good (codegen inerting "islands" of failure case
> code);
> > it will screw up the branch predictor.
> >
> > x86 defaults to predicting all (conditional) forward jumps not taken, all
> > conditional backwards jumps taken (Loops!). If the optimizer wasn't
> informed
> > correctly, it will probably not have obeyed that.
> >
> > Being as the overflow case should basically be never hit, there is no
> reason
> > for it to ever be loaded into the optimizer, so that is good
> >
> > (P.S. If the rust compiler is really good it'll convince LLVM to put the
> > error case branch code in a separate section so it can all be packed
> > together far away from useful cache lines and TLB entries)
>
> Rust directly exposes the checked overflow intrinsics so these are
> what was used. It already considers branches calling a `noreturn`
> function to be colder, so adding an explicit branch hint (which is
> easy enough via `llvm.expect` doesn't help). Feel free to implement it
> yourself if you think you can do better. The compiler work is already
> implemented.  I doubt you'll get something performing in the same
> ballpark as plain integers.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/24d52dbd/attachment.html>

From danielmicay at gmail.com  Sat Jan 11 13:42:40 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 16:42:40 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
Message-ID: <CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>

On Sat, Jan 11, 2014 at 4:31 PM, Owen Shepherd <owen.shepherd at e43.eu> wrote:
> So I just did a test. Took the following rust code:
> pub fn test_wrap(x : u32, y : u32) -> u32 {
>     return x.checked_mul(&y).unwrap().checked_add(&16).unwrap();
> }
>
> And got the following blob of assembly out. What we have there, my friends,
> is a complete failure of the optimizer (N.B. it works for the simple case of
> checked_add alone)
>
> Preamble:
>
> __ZN9test_wrap19hc4c136f599917215af4v0.0E:
>     .cfi_startproc
>     cmpl    %fs:20, %esp
>     ja    LBB0_2
>     pushl    $12
>     pushl    $20
>     calll    ___morestack
>     ret
> LBB0_2:
>     pushl    %ebp
> Ltmp2:
>     .cfi_def_cfa_offset 8
> Ltmp3:
>     .cfi_offset %ebp, -8
>     movl    %esp, %ebp
> Ltmp4:
>     .cfi_def_cfa_register %ebp
>
> Align stack (for what? We don't do any SSE)
>
>     andl    $-8, %esp
>     subl    $16, %esp

The compiler aligns the stack for performance.

> Multiply x * y
>
>     movl    12(%ebp), %eax
>     mull    16(%ebp)
>     jno    LBB0_4
>
> If it didn't overflow, stash a 0 at top of stack
>
>     movb    $0, (%esp)
>     jmp    LBB0_5
>
> If it did overflow, stash a 1 at top of stack (we are building an
> Option<u32> here)
> LBB0_4:
>     movb    $1, (%esp)
>     movl    %eax, 4(%esp)
>
> Take pointer to &this for __thiscall:
> LBB0_5:
>     leal    (%esp), %ecx
>     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
>
> Do the addition to the result
>
>     addl    $16, %eax
>
> Repeat the previous circus
>
>     jae    LBB0_7
>     movb    $0, 8(%esp)
>     jmp    LBB0_8
> LBB0_7:
>     movb    $1, 8(%esp)
>     movl    %eax, 12(%esp)
> LBB0_8:
>     leal    8(%esp), %ecx
>     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
>     movl    %ebp, %esp
>     popl    %ebp
>     ret
>     .cfi_endproc
>
>
> Yeah. Its' not fast because its' not inlining through option::unwrap.

The code to initiate failure is gigantic and LLVM doesn't do partial
inlining by default. It's likely far above the inlining threshold.

> I'm not sure what can be done for this, and whether its' on the LLVM side or
> the Rust side of things. My first instinct: find out what happens when fail!
> is moved out-of-line from unwrap() into its' own function (especially if
> that function can be marked noinline!), because optimizers often choke
> around EH.

I was testing with `rust-core` and calling `abort`, as it doesn't use unwinding.

> I tried to test the "optimal" situation in a synthetic benchmark:
> https://gist.github.com/oshepherd/8376705
> (In C for expediency. N.B. you must set core affinity before running this
> benchmark because I hackishly just read the TSC. i386 only.)
>
>
> but the results are really bizzare and seem to have a multitude of affecting
> factors (For example, if you minimally unroll and have the JCs jump straight
> to abort, you get vastly different performance from jumping to a closer
> location and then onwards to abort. Bear in mind that the overflow case
> never happens during the test). It would be interesting to do a test in
> which a "trivial" implementation of trap-on-overflow is added to rustc
> (read: the overflow case just jumps straight to abort or similar, to
> minimize optimizer influence and variability) to see how defaulting to
> trapping ints affects real world workloads.
>
> I wonder what level of performance impact would be considered "acceptable"
> for improved safety by default?
>
> Mind you, I think that what I'd propose is that i32 = Trapping, i32w =
> wrapping, i32s = saturating, or something similar

A purely synthetic benchmark only executing the unchecked or checked
instruction isn't interesting. You need to include several
optimizations in the loop as real code would use, and you will often
see a massive drop in performance from the serialization of the
pipeline. Register renaming is not as clever as you'd expect.

The impact of trapping is known, because `clang` and `gcc` expose `-ftrapv`.
 Integer-heavy workloads like cryptography and video codecs are
several times slower with the checks.

From adamson.benjamin at gmail.com  Sat Jan 11 14:03:53 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Sat, 11 Jan 2014 14:03:53 -0800
Subject: [rust-dev] NewType change in 0.9
Message-ID: <CAHzuJ30CgO9Mf0X0uqMXsJYeWa=ccjTk869Qcu95oHgeha4p6g@mail.gmail.com>

Hello Rust community!

I've been busying myself over the past few weeks learning the different
features of rust, and I have been working on an implementation of Conway's
game of life (while trying to explore different features of rust.

In 0.9, it was changed so that you cannot dereference haskell-like
"NewTypes" with the * operator. In the 0.9 documentation, it says we can
use pattern matching to extract the underlying type.

Right here in my 0.8 code I dererenced the row parameter here:
https://github.com/ShortStomp/ConwayGameOfLife-RUST/blob/master/grid.rs#L42

which is a simple 'NewType', with underlying type uint.

My question is, instead of dereferencing the 'Row' and 'Column' types, how
can I use pattern matching here, to get the underlying uint to index the
array with the code I just linked?

Thanks in advance! :)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/61e65933/attachment.html>

From sfackler at gmail.com  Sat Jan 11 14:06:37 2014
From: sfackler at gmail.com (Steven Fackler)
Date: Sat, 11 Jan 2014 14:06:37 -0800
Subject: [rust-dev] NewType change in 0.9
In-Reply-To: <CAHzuJ30CgO9Mf0X0uqMXsJYeWa=ccjTk869Qcu95oHgeha4p6g@mail.gmail.com>
References: <CAHzuJ30CgO9Mf0X0uqMXsJYeWa=ccjTk869Qcu95oHgeha4p6g@mail.gmail.com>
Message-ID: <CANb7cF6dKgHYQQ1XGLh6krRaAWUsunNzvughnBgb4hiCcY6UYQ@mail.gmail.com>

Something like this should work:

pub fn cell_alive(&self, Row(row): Row, Column(column): Column) -> uint {
  return match self.inner[row][column].value {
   dead  => 0,

   alive => 1
  };
}


Steven Fackler


On Sat, Jan 11, 2014 at 2:03 PM, benjamin adamson <
adamson.benjamin at gmail.com> wrote:

> Hello Rust community!
>
> I've been busying myself over the past few weeks learning the different
> features of rust, and I have been working on an implementation of Conway's
> game of life (while trying to explore different features of rust.
>
> In 0.9, it was changed so that you cannot dereference haskell-like
> "NewTypes" with the * operator. In the 0.9 documentation, it says we can
> use pattern matching to extract the underlying type.
>
> Right here in my 0.8 code I dererenced the row parameter here:
> https://github.com/ShortStomp/ConwayGameOfLife-RUST/blob/master/grid.rs#L42
>
> which is a simple 'NewType', with underlying type uint.
>
> My question is, instead of dereferencing the 'Row' and 'Column' types, how
> can I use pattern matching here, to get the underlying uint to index the
> array with the code I just linked?
>
> Thanks in advance! :)
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/1333336b/attachment.html>

From adamson.benjamin at gmail.com  Sat Jan 11 14:13:07 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Sat, 11 Jan 2014 14:13:07 -0800
Subject: [rust-dev] NewType change in 0.9
In-Reply-To: <CANb7cF6dKgHYQQ1XGLh6krRaAWUsunNzvughnBgb4hiCcY6UYQ@mail.gmail.com>
References: <CAHzuJ30CgO9Mf0X0uqMXsJYeWa=ccjTk869Qcu95oHgeha4p6g@mail.gmail.com>
	<CANb7cF6dKgHYQQ1XGLh6krRaAWUsunNzvughnBgb4hiCcY6UYQ@mail.gmail.com>
Message-ID: <CAHzuJ31o2Ow0+t6QjuuxXPf2mnXwJvi=RNe0m9Sy-jEAPfWqKw@mail.gmail.com>

Thanks! That did work. However I have no idea what this is doing:
Row(row): Row, Column(column): Column
The way I understood variable declaration, is that it goes:

name : type.

What does wrapping the 'name' of the variable with it's type on the LHS of
the : as well as having it on the RHS? Is this some special syntax related
to 'NewTypes' ??




On Sat, Jan 11, 2014 at 2:06 PM, Steven Fackler <sfackler at gmail.com> wrote:

> Something like this should work:
>
>
> pub fn cell_alive(&self, Row(row): Row, Column(column): Column) -> uint {
>
>
>   return match self.inner[row][column].value {
>
>
>    dead  => 0,
>
>
>    alive => 1
>   };
>
> }
>
>
> Steven Fackler
>
>
> On Sat, Jan 11, 2014 at 2:03 PM, benjamin adamson <
> adamson.benjamin at gmail.com> wrote:
>
>> Hello Rust community!
>>
>> I've been busying myself over the past few weeks learning the different
>> features of rust, and I have been working on an implementation of Conway's
>> game of life (while trying to explore different features of rust.
>>
>> In 0.9, it was changed so that you cannot dereference haskell-like
>> "NewTypes" with the * operator. In the 0.9 documentation, it says we can
>> use pattern matching to extract the underlying type.
>>
>> Right here in my 0.8 code I dererenced the row parameter here:
>>
>> https://github.com/ShortStomp/ConwayGameOfLife-RUST/blob/master/grid.rs#L42
>>
>> which is a simple 'NewType', with underlying type uint.
>>
>> My question is, instead of dereferencing the 'Row' and 'Column' types,
>> how can I use pattern matching here, to get the underlying uint to index
>> the array with the code I just linked?
>>
>> Thanks in advance! :)
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/59bbd02b/attachment.html>

From owen.shepherd at e43.eu  Sat Jan 11 14:13:39 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sat, 11 Jan 2014 22:13:39 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
Message-ID: <CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>

On 11 January 2014 21:42, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 11, 2014 at 4:31 PM, Owen Shepherd <owen.shepherd at e43.eu>
> wrote:
> > So I just did a test. Took the following rust code:
> > pub fn test_wrap(x : u32, y : u32) -> u32 {
> >     return x.checked_mul(&y).unwrap().checked_add(&16).unwrap();
> > }
> >
> > And got the following blob of assembly out. What we have there, my
> friends,
> > is a complete failure of the optimizer (N.B. it works for the simple
> case of
> > checked_add alone)
> >
> > Preamble:
> >
> > __ZN9test_wrap19hc4c136f599917215af4v0.0E:
> >     .cfi_startproc
> >     cmpl    %fs:20, %esp
> >     ja    LBB0_2
> >     pushl    $12
> >     pushl    $20
> >     calll    ___morestack
> >     ret
> > LBB0_2:
> >     pushl    %ebp
> > Ltmp2:
> >     .cfi_def_cfa_offset 8
> > Ltmp3:
> >     .cfi_offset %ebp, -8
> >     movl    %esp, %ebp
> > Ltmp4:
> >     .cfi_def_cfa_register %ebp
> >
> > Align stack (for what? We don't do any SSE)
> >
> >     andl    $-8, %esp
> >     subl    $16, %esp
>
> The compiler aligns the stack for performance.
>
>

Oops, I misread and thought there was 16 byte alignment going on there, not
8.


> > Multiply x * y
> >
> >     movl    12(%ebp), %eax
> >     mull    16(%ebp)
> >     jno    LBB0_4
> >
> > If it didn't overflow, stash a 0 at top of stack
> >
> >     movb    $0, (%esp)
> >     jmp    LBB0_5
> >
> > If it did overflow, stash a 1 at top of stack (we are building an
> > Option<u32> here)
> > LBB0_4:
> >     movb    $1, (%esp)
> >     movl    %eax, 4(%esp)
> >
> > Take pointer to &this for __thiscall:
> > LBB0_5:
> >     leal    (%esp), %ecx
> >     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
> >
> > Do the addition to the result
> >
> >     addl    $16, %eax
> >
> > Repeat the previous circus
> >
> >     jae    LBB0_7
> >     movb    $0, 8(%esp)
> >     jmp    LBB0_8
> > LBB0_7:
> >     movb    $1, 8(%esp)
> >     movl    %eax, 12(%esp)
> > LBB0_8:
> >     leal    8(%esp), %ecx
> >     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
> >     movl    %ebp, %esp
> >     popl    %ebp
> >     ret
> >     .cfi_endproc
> >
> >
> > Yeah. Its' not fast because its' not inlining through option::unwrap.
>
> The code to initiate failure is gigantic and LLVM doesn't do partial
> inlining by default. It's likely far above the inlining threshold.
>
>
Right, why I suggested explicitly moving the failure code out of line into
a separate function.


> A purely synthetic benchmark only executing the unchecked or checked
> instruction isn't interesting. You need to include several
> optimizations in the loop as real code would use, and you will often
> see a massive drop in performance from the serialization of the
> pipeline. Register renaming is not as clever as you'd expect.
>
>
Agreed. The variability within that tiny benchmark tells me that it can't
really glean any valuable information.


> The impact of trapping is known, because `clang` and `gcc` expose
> `-ftrapv`.
>  Integer-heavy workloads like cryptography and video codecs are
> several times slower with the checks.
>

What about other workloads?

As I mentioned: What I'd propose is trapping by default, with non-trapping
math along the lines of a single additonal character on a type declaration
away.

Also, I did manage to convince Rust + LLVM to optimize things cleanly, by
defining an unwrap which invoked libc's abort() -> !, so there's that.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/ba184b24/attachment-0001.html>

From danielmicay at gmail.com  Sat Jan 11 14:22:37 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 17:22:37 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
Message-ID: <CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>

On Sat, Jan 11, 2014 at 5:13 PM, Owen Shepherd <owen.shepherd at e43.eu> wrote:
>
> What about other workloads?

It just depends on how much of it is doing integer arithmetic. Many
applications are bounded by I/O and memory bandwidth and wouldn't be
hurt by integer arithmetic resulting in significantly slower code.

> As I mentioned: What I'd propose is trapping by default, with non-trapping math along the lines of a single additonal character on a type declaration away.

Why would it be a language feature? It's not an operation Rust needs
to expose at a language level because it can be implemented as a
library type.

From marijnh at gmail.com  Sat Jan 11 14:33:15 2014
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Sat, 11 Jan 2014 23:33:15 +0100
Subject: [rust-dev] NewType change in 0.9
In-Reply-To: <CAHzuJ31o2Ow0+t6QjuuxXPf2mnXwJvi=RNe0m9Sy-jEAPfWqKw@mail.gmail.com>
References: <CAHzuJ30CgO9Mf0X0uqMXsJYeWa=ccjTk869Qcu95oHgeha4p6g@mail.gmail.com>
	<CANb7cF6dKgHYQQ1XGLh6krRaAWUsunNzvughnBgb4hiCcY6UYQ@mail.gmail.com>
	<CAHzuJ31o2Ow0+t6QjuuxXPf2mnXwJvi=RNe0m9Sy-jEAPfWqKw@mail.gmail.com>
Message-ID: <CAJnHWXuuJW_YKW1ZinCjn6ngOQFXQnByx2F4JPcDPQ1mb=5t2w@mail.gmail.com>

> What does wrapping the 'name' of the variable with it's type on the LHS of
> the : as well as having it on the RHS?

It's a destructuring pattern, extracting the content of the Row/Column
values and binding a variable to it.

From owen.shepherd at e43.eu  Sat Jan 11 14:38:48 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sat, 11 Jan 2014 22:38:48 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
Message-ID: <CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>

 On 11 January 2014 22:22, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 11, 2014 at 5:13 PM, Owen Shepherd <owen.shepherd at e43.eu>
> wrote:
> >
> > What about other workloads?
>
> It just depends on how much of it is doing integer arithmetic. Many
> applications are bounded by I/O and memory bandwidth and wouldn't be
> hurt by integer arithmetic resulting in significantly slower code.
>
> > As I mentioned: What I'd propose is trapping by default, with
> non-trapping math along the lines of a single additonal character on a type
> declaration away.
>
> Why would it be a language feature? It's not an operation Rust needs
> to expose at a language level because it can be implemented as a
> library type.
>

I agree, however, I feel that the names like "i32" and "u32" should be
trap-on-overflow types. The non overflow ones should be "i32w" (wrapping)
or similar.

Why? Because I expect that otherwise people will default to the wrapping
types. Less typing. "It'll never be a security issue", or "Looks safe to
me", etc, etc. Secure by default is a good thing, IMO.

So I agree, no reason it couldn't be implemented in libstd. Just... there
are currently type names in the way.

(I note that there has been a mixed opinion in this thread each way)

Owen Shepherd
http://owenshepherd.net | owen.shepherd at e43.eu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/8bb52dee/attachment.html>

From carter.schonwald at gmail.com  Sat Jan 11 14:50:30 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sat, 11 Jan 2014 17:50:30 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
	<CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
Message-ID: <CAHYVw0xCutcHAQHkTNom--Snrk31dO9ttS1fMdu8dKQkomXOjQ@mail.gmail.com>

excellent point owen. I'd agree myself, seeing how that exact same platform
dependent int/uint size gotchas (wrapping style semantics) are a recurrent
source of surprise in GHC Haskell, and other languages. In my own
applications I like wrapping semantics, but for most people, a signed
counter wrapping into negative numbers isn't a welcome suprise!


On Sat, Jan 11, 2014 at 5:38 PM, Owen Shepherd <owen.shepherd at e43.eu> wrote:

> On 11 January 2014 22:22, Daniel Micay <danielmicay at gmail.com> wrote:
>
>> On Sat, Jan 11, 2014 at 5:13 PM, Owen Shepherd <owen.shepherd at e43.eu>
>> wrote:
>> >
>> > What about other workloads?
>>
>> It just depends on how much of it is doing integer arithmetic. Many
>> applications are bounded by I/O and memory bandwidth and wouldn't be
>> hurt by integer arithmetic resulting in significantly slower code.
>>
>> > As I mentioned: What I'd propose is trapping by default, with
>> non-trapping math along the lines of a single additonal character on a type
>> declaration away.
>>
>> Why would it be a language feature? It's not an operation Rust needs
>> to expose at a language level because it can be implemented as a
>> library type.
>>
>
> I agree, however, I feel that the names like "i32" and "u32" should be
> trap-on-overflow types. The non overflow ones should be "i32w" (wrapping)
> or similar.
>
> Why? Because I expect that otherwise people will default to the wrapping
> types. Less typing. "It'll never be a security issue", or "Looks safe to
> me", etc, etc. Secure by default is a good thing, IMO.
>
> So I agree, no reason it couldn't be implemented in libstd. Just... there
> are currently type names in the way.
>
> (I note that there has been a mixed opinion in this thread each way)
>
> Owen Shepherd
> http://owenshepherd.net | owen.shepherd at e43.eu
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/8205e45d/attachment.html>

From ncm at cantrip.org  Sat Jan 11 15:06:26 2014
From: ncm at cantrip.org (Nathan Myers)
Date: Sat, 11 Jan 2014 15:06:26 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
Message-ID: <52D1CE72.8070003@cantrip.org>

On 01/10/2014 10:08 PM, Daniel Micay wrote:
> I don't think failure on overflow is very useful. It's still a bug if
> you overflow when you don't intend it. If we did have a fast big
> integer type, it would make sense to wrap it with an enum heading down
> a separate branch for small and large integers, and branching on the
> overflow flag to expand to a big integer. I think this is how Python's
> integers are implemented.

Failure on overflow *can* be useful in production code, using
tasks to encapsulate suspect computations.  Big-integer types
can be useful, too.  A big-integer type that uses small-integer
arithmetic until overflow is a clever trick, but it's purely
an implementation trick.  Architecturally, it makes no sense
to expose the trick to users.

The fundamental error in the original posting was saying machine
word types are somehow not "CORRECT".  Such types have perfectly
defined behavior and performance in all conditions. They just
don't pretend to model what a mathematician calls an "integer".
They *do* model what actual machines actually do. It makes
sense to call them something else than "integer", but "i32"
*is* something else.

It also makes sense to make a library that tries to emulate
an actual integer type.  That belongs in a library because it's
purely a construct: nothing in any physical machine resembles
an actual integer.  Furthermore, since it is an emulation,
details vary for practical reasons. No single big-integer or
overflow-trapping type can meet all needs. (If you try, you
fail users who need it simple.)  That's OK, because anyone
can code another, and a simple default can satisfy most users.

In fact, i64 satisifies almost all users almost all the time.

Nathan Myers

From pwalton at mozilla.com  Sat Jan 11 15:10:05 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 11 Jan 2014 15:10:05 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
Message-ID: <63a21691-7299-49e6-b5c9-e7dca0feeaea@email.android.com>

I think failure may have quite different inlining costs once we move to libunwind-based backtraces instead of hardcoding file/line number information into the generated code. The file and line number information tends to pollute generated code a lot and it's basically unnecessary with proper DWARF info and a functioning set of libunwind bindings, which we now have thanks to a couple of awesome contributions from you all. :)

Patrick

Owen Shepherd <owen.shepherd at e43.eu> wrote:
>On 11 January 2014 21:42, Daniel Micay <danielmicay at gmail.com> wrote:
>
>> On Sat, Jan 11, 2014 at 4:31 PM, Owen Shepherd <owen.shepherd at e43.eu>
>> wrote:
>> > So I just did a test. Took the following rust code:
>> > pub fn test_wrap(x : u32, y : u32) -> u32 {
>> >     return x.checked_mul(&y).unwrap().checked_add(&16).unwrap();
>> > }
>> >
>> > And got the following blob of assembly out. What we have there, my
>> friends,
>> > is a complete failure of the optimizer (N.B. it works for the
>simple
>> case of
>> > checked_add alone)
>> >
>> > Preamble:
>> >
>> > __ZN9test_wrap19hc4c136f599917215af4v0.0E:
>> >     .cfi_startproc
>> >     cmpl    %fs:20, %esp
>> >     ja    LBB0_2
>> >     pushl    $12
>> >     pushl    $20
>> >     calll    ___morestack
>> >     ret
>> > LBB0_2:
>> >     pushl    %ebp
>> > Ltmp2:
>> >     .cfi_def_cfa_offset 8
>> > Ltmp3:
>> >     .cfi_offset %ebp, -8
>> >     movl    %esp, %ebp
>> > Ltmp4:
>> >     .cfi_def_cfa_register %ebp
>> >
>> > Align stack (for what? We don't do any SSE)
>> >
>> >     andl    $-8, %esp
>> >     subl    $16, %esp
>>
>> The compiler aligns the stack for performance.
>>
>>
>
>Oops, I misread and thought there was 16 byte alignment going on there,
>not
>8.
>
>
>> > Multiply x * y
>> >
>> >     movl    12(%ebp), %eax
>> >     mull    16(%ebp)
>> >     jno    LBB0_4
>> >
>> > If it didn't overflow, stash a 0 at top of stack
>> >
>> >     movb    $0, (%esp)
>> >     jmp    LBB0_5
>> >
>> > If it did overflow, stash a 1 at top of stack (we are building an
>> > Option<u32> here)
>> > LBB0_4:
>> >     movb    $1, (%esp)
>> >     movl    %eax, 4(%esp)
>> >
>> > Take pointer to &this for __thiscall:
>> > LBB0_5:
>> >     leal    (%esp), %ecx
>> >     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
>> >
>> > Do the addition to the result
>> >
>> >     addl    $16, %eax
>> >
>> > Repeat the previous circus
>> >
>> >     jae    LBB0_7
>> >     movb    $0, 8(%esp)
>> >     jmp    LBB0_8
>> > LBB0_7:
>> >     movb    $1, 8(%esp)
>> >     movl    %eax, 12(%esp)
>> > LBB0_8:
>> >     leal    8(%esp), %ecx
>> >     calll    __ZN6option6Option6unwrap21h05c5cb6c47a61795Zcat4v0.0E
>> >     movl    %ebp, %esp
>> >     popl    %ebp
>> >     ret
>> >     .cfi_endproc
>> >
>> >
>> > Yeah. Its' not fast because its' not inlining through
>option::unwrap.
>>
>> The code to initiate failure is gigantic and LLVM doesn't do partial
>> inlining by default. It's likely far above the inlining threshold.
>>
>>
>Right, why I suggested explicitly moving the failure code out of line
>into
>a separate function.
>
>
>> A purely synthetic benchmark only executing the unchecked or checked
>> instruction isn't interesting. You need to include several
>> optimizations in the loop as real code would use, and you will often
>> see a massive drop in performance from the serialization of the
>> pipeline. Register renaming is not as clever as you'd expect.
>>
>>
>Agreed. The variability within that tiny benchmark tells me that it
>can't
>really glean any valuable information.
>
>
>> The impact of trapping is known, because `clang` and `gcc` expose
>> `-ftrapv`.
>>  Integer-heavy workloads like cryptography and video codecs are
>> several times slower with the checks.
>>
>
>What about other workloads?
>
>As I mentioned: What I'd propose is trapping by default, with
>non-trapping
>math along the lines of a single additonal character on a type
>declaration
>away.
>
>Also, I did manage to convince Rust + LLVM to optimize things cleanly,
>by
>defining an unwrap which invoked libc's abort() -> !, so there's that.
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/870bd8ca/attachment-0001.html>

From danielmicay at gmail.com  Sat Jan 11 15:14:50 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 11 Jan 2014 18:14:50 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D1CE72.8070003@cantrip.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1CE72.8070003@cantrip.org>
Message-ID: <CA+DvKQJWNBz39cY7e__tqJbn+QERh0RLOX6jhKcQx3xiPGjkMw@mail.gmail.com>

On Sat, Jan 11, 2014 at 6:06 PM, Nathan Myers <ncm at cantrip.org> wrote:
> On 01/10/2014 10:08 PM, Daniel Micay wrote:
>>
>> I don't think failure on overflow is very useful. It's still a bug if
>> you overflow when you don't intend it. If we did have a fast big
>> integer type, it would make sense to wrap it with an enum heading down
>> a separate branch for small and large integers, and branching on the
>> overflow flag to expand to a big integer. I think this is how Python's
>> integers are implemented.
>
> Failure on overflow *can* be useful in production code, using
> tasks to encapsulate suspect computations.  Big-integer types
> can be useful, too.  A big-integer type that uses small-integer
> arithmetic until overflow is a clever trick, but it's purely
> an implementation trick.  Architecturally, it makes no sense
> to expose the trick to users.

I didn't suggest exposing it to users. I suggested defining a wrapper
around the big integer type with better performance characteristics
for small integers.

> The fundamental error in the original posting was saying machine
> word types are somehow not "CORRECT".  Such types have perfectly
> defined behavior and performance in all conditions. They just
> don't pretend to model what a mathematician calls an "integer".
> They *do* model what actual machines actually do. It makes
> sense to call them something else than "integer", but "i32"
> *is* something else.

Rings, fields and modular arithmetic are certainly very real
mathematical concepts. Unsigned fixed-size integers behave as a
mathematician would model them, while signed ones do not really have
sane high-level semantics.

> It also makes sense to make a library that tries to emulate
> an actual integer type.  That belongs in a library because it's
> purely a construct: nothing in any physical machine resembles
> an actual integer.  Furthermore, since it is an emulation,
> details vary for practical reasons. No single big-integer or
> overflow-trapping type can meet all needs. (If you try, you
> fail users who need it simple.)  That's OK, because anyone
> can code another, and a simple default can satisfy most users.

What do you mean by default? If you don't know the bounds, a big
integer is clearly the only correct choice. If you do know the bounds,
you can use a fixed-size integer. I don't think any default other than
a big integer is sane, so I don't think Rust needs a default inference
fallback.

From pcwalton at mozilla.com  Sat Jan 11 15:59:17 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 11 Jan 2014 15:59:17 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>	<52D0DDA3.8040501@isaac.cedarswampstudios.org>	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
Message-ID: <52D1DAD5.2080308@mozilla.com>

On 1/10/14 10:08 PM, Daniel Micay wrote:
> I don't think failure on overflow is very useful. It's still a bug if
> you overflow when you don't intend it.

Of course it's useful. It prevents attackers from weaponizing 
out-of-bounds reads and writes in unsafe code.

Patrick


From thadguidry at gmail.com  Sat Jan 11 17:24:44 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Sat, 11 Jan 2014 19:24:44 -0600
Subject: [rust-dev] Properly licensing Rust documentation and wiki
In-Reply-To: <52D0BE18.2070106@mozilla.com>
References: <52D0BE18.2070106@mozilla.com>
Message-ID: <CAChbWaMk_Ou3q6LvNoeT5iAokAp+NApvW107yZm_afOdLNLt=g@mail.gmail.com>

I touched the wiki.  All "Thad Guidry" edits are Public Domain, of course.
 Or MIT/ASL2 license if you so desire.


On Fri, Jan 10, 2014 at 9:44 PM, Brian Anderson <banderson at mozilla.com>wrote:

> Hey.
>
> Time for more legal stuff. Per https://github.com/mozilla/rust/issues/5831the licensing of our documentation is not clear. Like all things Rust we
> want to make our doc license as permissive as possible, so after getting
> some legal advice here is what I intend to do:
>
> * Rust documentation will be MIT/ASL2 licensed like everything else.
> * Add the license as a *footer* to existing in-tree documentation, under
> the argument that it is already licensed according to the same terms as the
> rest of the repo.
> * Gather new statements from wiki contributors asserting that they
> contrtibuted under the MIT/ASL2, as we did when we relicensed Rust.
> * Put the license as footers on all pages of the wiki.
>
> For the most part this should not affect anybody, though if you've ever
> touched the wiki you may recieve an email from me about this in the future.
>
> Regards,
> Brian
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/9bf8ff6b/attachment.html>

From ncm at cantrip.org  Sat Jan 11 17:49:44 2014
From: ncm at cantrip.org (Nathan Myers)
Date: Sat, 11 Jan 2014 17:49:44 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQJWNBz39cY7e__tqJbn+QERh0RLOX6jhKcQx3xiPGjkMw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1CE72.8070003@cantrip.org>
	<CA+DvKQJWNBz39cY7e__tqJbn+QERh0RLOX6jhKcQx3xiPGjkMw@mail.gmail.com>
Message-ID: <52D1F4B8.7040805@cantrip.org>

On 01/11/2014 03:14 PM, Daniel Micay wrote:
> On Sat, Jan 11, 2014 at 6:06 PM, Nathan Myers <ncm at cantrip.org> wrote:
>> A big-integer type that uses small-integer
>> arithmetic until overflow is a clever trick, but it's purely
>> an implementation trick.  Architecturally, it makes no sense
>> to expose the trick to users.
>
> I didn't suggest exposing it to users. I suggested defining a wrapper
> around the big integer type with better performance characteristics
> for small integers.

Your wrapper sounds to me like THE big-integer type.  The thing you
called a "big integer" doesn't need a name.

>> No single big-integer or
>> overflow-trapping type can meet all needs. (If you try, you
>> fail users who need it simple.)  That's OK, because anyone
>> can code another, and a simple default can satisfy most users.
>
> What do you mean by default? If you don't know the bounds, a big
> integer is clearly the only correct choice. If you do know the
> bounds,you can use a fixed-size integer. I don't think any default
> other than a big integer is sane, so I don't think Rust needs a
 > default inference fallback.

As I said,

 >> In fact, i64 satisifies almost all users almost all the time.

No one would complain about a built-in "i128" type.  The thing
about a fixed-size type is that there are no implementation
choices to leak out.  Overflowing an i128 variable is quite
difficult, and 128-bit operations are still lots faster than on
any variable-precision type. I could live with "int" == "i128".

Nathan Myers

From marcianx at gmail.com  Sat Jan 11 18:40:26 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 11 Jan 2014 21:40:26 -0500
Subject: [rust-dev]  Macros expanding to multiple statements
Message-ID: <CAEsTQVMjMt+PtBpQVS_goWZJL3fg4sy0kbo_gt5Mv1jDSsXFXQ@mail.gmail.com>

Rust 0.9 indicates that support for expansion of macros into multiple
statements is now supported, and the following example from the test suite
works for me.
https://github.com/mozilla/rust/blob/master/src/test/run-pass/macro-multiple-items.rs

However, I receive an error for the following code

#[feature(macro_rules)];

macro_rules! my_print(
    ($a:expr, $b:expr) => (
        println!("{:?}", a);
        println!("{:?}", b);
    );
)

fn main() {
    let a = 1;
    let b = 2;
    my_print!(a, b);
}

(Note that the ^~~~~~~ below points at println.)

$ rustc macro_ignores_second_line.rs
macro_ignores_second_line.rs:6:9: 6:16 error: macro expansion ignores token
`println` and any following
macro_ignores_second_line.rs:6         println!("{:?}", b);
                                       ^~~~~~~
error: aborting due to previous error
task 'rustc' failed at 'explicit failure',
/home/marcianx/devel/rust/checkout/rust/src/libsyntax/diagnostic.rs:75
task '<main>' failed at 'explicit failure',
/home/marcianx/devel/rust/checkout/rust/src/librustc/lib.rs:453


What's the right way to do this?

Ashish
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/6a355fbf/attachment.html>

From dbau.pp at gmail.com  Sat Jan 11 18:43:54 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 12 Jan 2014 13:43:54 +1100
Subject: [rust-dev] Macros expanding to multiple statements
In-Reply-To: <CAEsTQVMjMt+PtBpQVS_goWZJL3fg4sy0kbo_gt5Mv1jDSsXFXQ@mail.gmail.com>
References: <CAEsTQVMjMt+PtBpQVS_goWZJL3fg4sy0kbo_gt5Mv1jDSsXFXQ@mail.gmail.com>
Message-ID: <52D2016A.6030605@gmail.com>

That test is for multiple *items*, not statements.

For the moment, you just have to wrap the interior of a macro expanding 
to an expression in a set of braces, so that it becomes a single statement.

macro_rules! my_print(
     ($a:expr, $b:expr) => (
         {
             println!("{:?}", a);
             println!("{:?}", b);
         }
     );
)

Multi-statement macros are covered by 
https://github.com/mozilla/rust/issues/10681 .


Huon


On 12/01/14 13:40, Ashish Myles wrote:
> Rust 0.9 indicates that support for expansion of macros into multiple 
> statements is now supported, and the following example from the test 
> suite works for me.
> https://github.com/mozilla/rust/blob/master/src/test/run-pass/macro-multiple-items.rs
>
> However, I receive an error for the following code
>
> #[feature(macro_rules)];
>
> macro_rules! my_print(
>     ($a:expr, $b:expr) => (
>         println!("{:?}", a);
>         println!("{:?}", b);
>     );
> )
>
> fn main() {
>     let a = 1;
>     let b = 2;
>     my_print!(a, b);
> }
>
> (Note that the ^~~~~~~ below points at println.)
>
> $ rustc macro_ignores_second_line.rs <http://macro_ignores_second_line.rs>
> macro_ignores_second_line.rs:6:9: 6:16 error: macro expansion ignores 
> token `println` and any following
> macro_ignores_second_line.rs:6 <http://macro_ignores_second_line.rs:6> 
> println!("{:?}", b);
>                                        ^~~~~~~
> error: aborting due to previous error
> task 'rustc' failed at 'explicit failure', 
> /home/marcianx/devel/rust/checkout/rust/src/libsyntax/diagnostic.rs:75 
> <http://diagnostic.rs:75>
> task '<main>' failed at 'explicit failure', 
> /home/marcianx/devel/rust/checkout/rust/src/librustc/lib.rs:453 
> <http://lib.rs:453>
>
>
> What's the right way to do this?
>
> Ashish
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/ead65d13/attachment-0001.html>

From marcianx at gmail.com  Sat Jan 11 19:13:59 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 11 Jan 2014 22:13:59 -0500
Subject: [rust-dev] Macros expanding to multiple statements
In-Reply-To: <52D2016A.6030605@gmail.com>
References: <CAEsTQVMjMt+PtBpQVS_goWZJL3fg4sy0kbo_gt5Mv1jDSsXFXQ@mail.gmail.com>
	<52D2016A.6030605@gmail.com>
Message-ID: <CAEsTQVMV0mnEeFcna_pgugfbFnMKS6XgQb1P+xCu3KU5Cz66jw@mail.gmail.com>

Ah, I didn't realize the distinction.  I am comparing the code in the first
comment in the bug you linked against the test suite example I linked.  I
guess the distinction between items and statements is that items correspond
to code outside any method, whereas statements are defined as code within a
method, and macro expansions in the latter case seem to be broken even in
the case of a single statement.  Please correct me if I am wrong.

Ashish



On Sat, Jan 11, 2014 at 9:43 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  That test is for multiple *items*, not statements.
>
> For the moment, you just have to wrap the interior of a macro expanding to
> an expression in a set of braces, so that it becomes a single statement.
>
>
> macro_rules! my_print(
>     ($a:expr, $b:expr) => (
>         {
>             println!("{:?}", a);
>             println!("{:?}", b);
>         }
>     );
> )
>
> Multi-statement macros are covered by
> https://github.com/mozilla/rust/issues/10681 .
>
>
> Huon
>
>
>
> On 12/01/14 13:40, Ashish Myles wrote:
>
>  Rust 0.9 indicates that support for expansion of macros into multiple
> statements is now supported, and the following example from the test suite
> works for me.
>
> https://github.com/mozilla/rust/blob/master/src/test/run-pass/macro-multiple-items.rs
>
>  However, I receive an error for the following code
>
> #[feature(macro_rules)];
>
> macro_rules! my_print(
>     ($a:expr, $b:expr) => (
>         println!("{:?}", a);
>         println!("{:?}", b);
>     );
> )
>
> fn main() {
>     let a = 1;
>     let b = 2;
>     my_print!(a, b);
> }
>
>  (Note that the ^~~~~~~ below points at println.)
>
> $ rustc macro_ignores_second_line.rs
> macro_ignores_second_line.rs:6:9: 6:16 error: macro expansion ignores
> token `println` and any following
> macro_ignores_second_line.rs:6         println!("{:?}", b);
>                                        ^~~~~~~
> error: aborting due to previous error
> task 'rustc' failed at 'explicit failure',
> /home/marcianx/devel/rust/checkout/rust/src/libsyntax/diagnostic.rs:75
> task '<main>' failed at 'explicit failure',
> /home/marcianx/devel/rust/checkout/rust/src/librustc/lib.rs:453
>
>
>  What's the right way to do this?
>
> Ashish
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140111/e37709c2/attachment.html>

From andrew at du.nham.ca  Sun Jan 12 00:08:29 2014
From: andrew at du.nham.ca (Andrew Dunham)
Date: Sun, 12 Jan 2014 00:08:29 -0800
Subject: [rust-dev] Properly licensing Rust documentation and wiki
In-Reply-To: <CAChbWaMk_Ou3q6LvNoeT5iAokAp+NApvW107yZm_afOdLNLt=g@mail.gmail.com>
References: <52D0BE18.2070106@mozilla.com>
	<CAChbWaMk_Ou3q6LvNoeT5iAokAp+NApvW107yZm_afOdLNLt=g@mail.gmail.com>
Message-ID: <CADSBmCBj5GxwDDV-rFUog0im+k_kds75MUP5UXfaPr2D5rthuA@mail.gmail.com>

I think I touched one of the installation instruction pages at one point.
 Either way, all my edits are in the public domain or in whatever license
Mozilla requests.

--Andrew D


On Sat, Jan 11, 2014 at 5:24 PM, Thad Guidry <thadguidry at gmail.com> wrote:

> I touched the wiki.  All "Thad Guidry" edits are Public Domain, of course.
>  Or MIT/ASL2 license if you so desire.
>
>
> On Fri, Jan 10, 2014 at 9:44 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>> Hey.
>>
>> Time for more legal stuff. Per https://github.com/mozilla/
>> rust/issues/5831 the licensing of our documentation is not clear. Like
>> all things Rust we want to make our doc license as permissive as possible,
>> so after getting some legal advice here is what I intend to do:
>>
>> * Rust documentation will be MIT/ASL2 licensed like everything else.
>> * Add the license as a *footer* to existing in-tree documentation, under
>> the argument that it is already licensed according to the same terms as the
>> rest of the repo.
>> * Gather new statements from wiki contributors asserting that they
>> contrtibuted under the MIT/ASL2, as we did when we relicensed Rust.
>> * Put the license as footers on all pages of the wiki.
>>
>> For the most part this should not affect anybody, though if you've ever
>> touched the wiki you may recieve an email from me about this in the future.
>>
>> Regards,
>> Brian
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/8493badf/attachment.html>

From abe.egnor at gmail.com  Sun Jan 12 05:09:13 2014
From: abe.egnor at gmail.com (Abraham Egnor)
Date: Sun, 12 Jan 2014 08:09:13 -0500
Subject: [rust-dev] Questions from a newcomer
Message-ID: <CAFVLdicuuOD0-jPVyq6-NUqz6x+fmJ9twNBz9TXwxDwDKhpn-g@mail.gmail.com>

Hello!  The 0.9 release prompted me to poke at my nascent rust code.  Very
impressed with the language and the progress since I last looked (0.4
maybe?).

Some questions that I wasn't able to find answers for:

* Is there any built-in way to iterate over all values of a C-like enum?
 It's not hard to define an iterator method that implements this for any
given type, but it's tedious boilerplate that seems better left to the
compiler.

* Is it possible to express "if a type implements trait A, here is a
default implementation of trait B"?  I tried the obvious way ("impl<T:
TraitA> TraitB for T"), but it looks like the rust compiler can't
disambiguate between that impl and type-specific impls.

Thanks!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/40dfadd6/attachment.html>

From abe.egnor at gmail.com  Sun Jan 12 05:16:33 2014
From: abe.egnor at gmail.com (Abraham Egnor)
Date: Sun, 12 Jan 2014 08:16:33 -0500
Subject: [rust-dev] Questions from a newcomer
In-Reply-To: <CAFVLdicuuOD0-jPVyq6-NUqz6x+fmJ9twNBz9TXwxDwDKhpn-g@mail.gmail.com>
References: <CAFVLdicuuOD0-jPVyq6-NUqz6x+fmJ9twNBz9TXwxDwDKhpn-g@mail.gmail.com>
Message-ID: <CAFVLdiciAj+qMA2U0GztKX34dx1=5oA27eMdW-XNvN4ZRmvhjQ@mail.gmail.com>

Oh yes, and one more:

* Why does the do-notation require a function that takes a proc()?  Given
that || is the recommended type for HOFs it seems like it would be much
more convenient if it worked with functions expecting a proc() or a ||.


On Sun, Jan 12, 2014 at 8:09 AM, Abraham Egnor <abe.egnor at gmail.com> wrote:

> Hello!  The 0.9 release prompted me to poke at my nascent rust code.  Very
> impressed with the language and the progress since I last looked (0.4
> maybe?).
>
> Some questions that I wasn't able to find answers for:
>
> * Is there any built-in way to iterate over all values of a C-like enum?
>  It's not hard to define an iterator method that implements this for any
> given type, but it's tedious boilerplate that seems better left to the
> compiler.
>
> * Is it possible to express "if a type implements trait A, here is a
> default implementation of trait B"?  I tried the obvious way ("impl<T:
> TraitA> TraitB for T"), but it looks like the rust compiler can't
> disambiguate between that impl and type-specific impls.
>
> Thanks!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/867eee7e/attachment.html>

From james at mansionfamily.plus.com  Sun Jan 12 05:23:57 2014
From: james at mansionfamily.plus.com (james)
Date: Sun, 12 Jan 2014 13:23:57 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
	<CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
Message-ID: <52D2976D.60808@mansionfamily.plus.com>

On 11/01/2014 22:38, Owen Shepherd wrote:
> I agree, however, I feel that the names like "i32" and "u32" should be 
> trap-on-overflow types. The non overflow ones should be "i32w" 
> (wrapping) or similar.
>
> Why? Because I expect that otherwise people will default to the 
> wrapping types. Less typing. "It'll never be a security issue", or 
> "Looks safe to me", etc, etc. Secure by default is a good thing, IMO
I don't think making 'i32' have different semantics by default from 
int32_t (or from the 'i32' typedef most of us will have used for years) 
is a good idea in a wannabe systems programming language.  It is too 
surprising.

There might be a good case for having a pragma control some 'check for 
overflow' in a paranoid test mode, but i think that most programmers, 
most of the time, will expect 2s complement arithmetic 'as usual'.


From dbau.pp at gmail.com  Sun Jan 12 05:27:33 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 13 Jan 2014 00:27:33 +1100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D2976D.60808@mansionfamily.plus.com>
References: <52D0D385.1080200@gmail.com>	<52D0DDA3.8040501@isaac.cedarswampstudios.org>	<52D0DF1D.1080805@gmail.com>	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>	<52D0E224.7060103@mozilla.com>	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>	<CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
	<52D2976D.60808@mansionfamily.plus.com>
Message-ID: <52D29845.6060403@gmail.com>

On 13/01/14 00:23, james wrote:
> On 11/01/2014 22:38, Owen Shepherd wrote:
>> I agree, however, I feel that the names like "i32" and "u32" should 
>> be trap-on-overflow types. The non overflow ones should be "i32w" 
>> (wrapping) or similar.
>>
>> Why? Because I expect that otherwise people will default to the 
>> wrapping types. Less typing. "It'll never be a security issue", or 
>> "Looks safe to me", etc, etc. Secure by default is a good thing, IMO
> I don't think making 'i32' have different semantics by default from 
> int32_t (or from the 'i32' typedef most of us will have used for 
> years) is a good idea in a wannabe systems programming language.  It 
> is too surprising.
>
> There might be a good case for having a pragma control some 'check for 
> overflow' in a paranoid test mode, but i think that most programmers, 
> most of the time, will expect 2s complement arithmetic 'as usual'.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Coincidentally, i32 already has different semantics to int32_t: overflow 
of signed types is undefined behaviour in C, but is defined (as 
wrap-around) in Rust.


Huon

From owen.shepherd at e43.eu  Sun Jan 12 05:34:32 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sun, 12 Jan 2014 13:34:32 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D2976D.60808@mansionfamily.plus.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
	<CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
	<52D2976D.60808@mansionfamily.plus.com>
Message-ID: <CAHUXVy5v6FX-ya78NVzA4Lf6tYkUnrt_iH4MEaROpERKGVPvww@mail.gmail.com>

On 12 January 2014 13:23, james <james at mansionfamily.plus.com> wrote:

> On 11/01/2014 22:38, Owen Shepherd wrote:
>
>> I agree, however, I feel that the names like "i32" and "u32" should be
>> trap-on-overflow types. The non overflow ones should be "i32w" (wrapping)
>> or similar.
>>
>> Why? Because I expect that otherwise people will default to the wrapping
>> types. Less typing. "It'll never be a security issue", or "Looks safe to
>> me", etc, etc. Secure by default is a good thing, IMO
>>
> I don't think making 'i32' have different semantics by default from
> int32_t (or from the 'i32' typedef most of us will have used for years) is
> a good idea in a wannabe systems programming language.  It is too
> surprising.
>
> There might be a good case for having a pragma control some 'check for
> overflow' in a paranoid test mode, but i think that most programmers, most
> of the time, will expect 2s complement arithmetic 'as usual'.
>

Signd integers have no defined behavior on overflow in C or C++.

Go on, compile this program with optimizations enabled:

#include <stdio.h>
#include <limits.h>

int main() {
    for(int i = INT_MAX; i > 0; i++) {
        printf("Hello\n");
    }
}

Watch it loop endlessly, because since UB is undefined, the compiler
assumes it never occurs, and therefore i will always be greater than 0
since it starts higher.

I think defined behavior by default is better than undefined behavior, and
I also think that overflow detection by default is better than random
wrapping by default.

There are applications where wrapping is useful, or where checking for
overflow is too expensive. For those, unchecked integers should be only a
short distance away.

But I also feel that by making the unchecked ones the shorter name, the
language would be implicitly sending a message that they're preferred.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/af8c7015/attachment.html>

From bjzaba at yahoo.com.au  Sun Jan 12 08:29:00 2014
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Mon, 13 Jan 2014 03:29:00 +1100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy5v6FX-ya78NVzA4Lf6tYkUnrt_iH4MEaROpERKGVPvww@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D0E224.7060103@mozilla.com>
	<CA+DvKQ+Xxwf3ZdiFZpXc=foN4i5j5kyump8GM+F3qtKLg6r0rg@mail.gmail.com>
	<CAHUXVy4e32qgghjwJjV2qNbjdk23=p0K8_MExApmRrb5GTmFQw@mail.gmail.com>
	<CA+DvKQK6HmXNFr5q9-gBvnhsHswi0zzg8QBiOp1hGxnCtdJJbA@mail.gmail.com>
	<CAHUXVy5eMD0w+fKH45mqvko-LG-ELdrGoxhAu9-45i8Mwpk4yA@mail.gmail.com>
	<CA+DvKQJO9AZmWBEAqgtRFvA9=7v9mRD66XRzYApLt=ts26XRrw@mail.gmail.com>
	<CAHUXVy4=w=n12+zxpPEAEtYFLBr7DFLL-PdsfT9OVi6ZsTyD1Q@mail.gmail.com>
	<CA+DvKQKrTUdw4xqNsW2uh6qhKLw8jApZqrssO_39+naAj0o7Xw@mail.gmail.com>
	<CAHUXVy5Wsk96Vhb0MPjF5bfUU9h2H4YVMs8uVfkVakmOVnodxQ@mail.gmail.com>
	<52D2976D.60808@mansionfamily.plus.com>
	<CAHUXVy5v6FX-ya78NVzA4Lf6tYkUnrt_iH4MEaROpERKGVPvww@mail.gmail.com>
Message-ID: <2B63D70F-15CA-454B-8333-16AFADBE27E3@yahoo.com.au>


On 13 Jan 2014, at 12:34 am, Owen Shepherd <owen.shepherd at e43.eu> wrote:

> But I also feel that by making the unchecked ones the shorter name, the language would be implicitly sending a message that they're preferred.

Custom operator time!

Say hello to our checked operators:

    trait CheckedAdd {
        fn infix +| (a: &Self, b: &Self) -> Self;
    }

    trait CheckedSub {
        fn infix -| (a: &Self, b: &Self) -> Self;
    }

    trait CheckedMul {
        fn infix *| (a: &Self, b: &Self) -> Self;
    }

xD

~Brendan

From rexlen at gmail.com  Sun Jan 12 08:48:42 2014
From: rexlen at gmail.com (Renato Lenzi)
Date: Sun, 12 Jan 2014 17:48:42 +0100
Subject: [rust-dev] line params
Message-ID: <CAM0XVgsXg_N-CttRiKH-JzH0BKJVnFe63WdymzWD+PHijQoUuw@mail.gmail.com>

If i want to access line command params i used code like this:

fn main() {
  let args: ~[~str] = ::std::os::args();
  println(args[0]);
}


Is this the best way to play with such params or the best is using
print_args? i've found no examples using print_args....

thanks, regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/25d7a9cf/attachment.html>

From corey at octayn.net  Sun Jan 12 09:00:29 2014
From: corey at octayn.net (Corey Richardson)
Date: Sun, 12 Jan 2014 12:00:29 -0500
Subject: [rust-dev] line params
In-Reply-To: <CAM0XVgsXg_N-CttRiKH-JzH0BKJVnFe63WdymzWD+PHijQoUuw@mail.gmail.com>
References: <CAM0XVgsXg_N-CttRiKH-JzH0BKJVnFe63WdymzWD+PHijQoUuw@mail.gmail.com>
Message-ID: <CA++BO6S3Ok74uE7J7_RbBJhYDiY+mBgXFUJPuycfmFZzRxGHGA@mail.gmail.com>

I don't know what print_args is, but there's a getopt-alike in extra::getopts

On Sun, Jan 12, 2014 at 11:48 AM, Renato Lenzi <rexlen at gmail.com> wrote:
> If i want to access line command params i used code like this:
>
> fn main() {
>   let args: ~[~str] = ::std::os::args();
>   println(args[0]);
> }
>
>
> Is this the best way to play with such params or the best is using
> print_args? i've found no examples using print_args....
>
> thanks, regards.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From thadguidry at gmail.com  Sun Jan 12 09:14:24 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Sun, 12 Jan 2014 11:14:24 -0600
Subject: [rust-dev] Fast inverse square root in Rust
Message-ID: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>

Where is the fast inverse square root function in Rust ?
http://en.wikipedia.org/wiki/Fast_inverse_square_root

Anyone know if this semi-accurate function is at a hardware level and built
in to Intel chipsets since MMX ?

How does this affect LLVM and Rust compilation on 64 bit ?

Thanks in advance,

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/4395a485/attachment-0001.html>

From corey at octayn.net  Sun Jan 12 09:16:09 2014
From: corey at octayn.net (Corey Richardson)
Date: Sun, 12 Jan 2014 12:16:09 -0500
Subject: [rust-dev] Questions from a newcomer
In-Reply-To: <CAFVLdiciAj+qMA2U0GztKX34dx1=5oA27eMdW-XNvN4ZRmvhjQ@mail.gmail.com>
References: <CAFVLdicuuOD0-jPVyq6-NUqz6x+fmJ9twNBz9TXwxDwDKhpn-g@mail.gmail.com>
	<CAFVLdiciAj+qMA2U0GztKX34dx1=5oA27eMdW-XNvN4ZRmvhjQ@mail.gmail.com>
Message-ID: <CA++BO6T6d-ugUd6TORXdx-s0EjFUzDymEeapvxa=XdS3+5qO9g@mail.gmail.com>

Hi Abraham,

> * Is there any built-in way to iterate over all values of a C-like enum?
> It's not hard to define an iterator method that implements this for any
> given type, but it's tedious boilerplate that seems better left to the
> compiler.
>

Not really. What is your usecase? One boilerplate-avoiding workaround
is to use FromPrimitive[1] and put `#[deriving(FromPrimitive)]` on
your enum. Then, to iterate over the valid discriminants, you can use:

range(0, std::uint::max_value).filter_map(|x|
FromPrimitive::from_uint(x).map(|y| y as uint))

Note that this iterates over the entire range of uint. This is
required for an enum like:

enum WhatAPain {
    A,
    B = 42,
    C = 12312455
}

Needless to say this is not going to perform well. You can substitute
the variant whose discriminant is the largest to make it cheaper:

range(0, C as uint).filter_map(|x| FromPrimitive::from_uint(x).map(|y|
y as uint))

> * Is it possible to express "if a type implements trait A, here is a
> default implementation of trait B"?  I tried the obvious way ("impl<T:
> TraitA> TraitB for T"), but it looks like the rust compiler can't
> disambiguate between that impl and type-specific impls.
>

You are doing it correctly. There is an issue open about this:
https://github.com/mozilla/rust/issues/10601

> * Why does the do-notation require a function that takes a proc()?  Given
> that || is the recommended type for HOFs it seems like it would be much more
> convenient if it worked with functions expecting a proc() or a ||.
>

`do` previously applied to any closure type but that was removed
because the meaning of `do` can change wildly depending on what you
apply it to. In particular, using the old syntax, do applied to a
`fn(~fn())` will have an allocation, whereas `fn(&fn())` will not. To
make such costs obvious, `do` no longer works with `&fn()` (now
written `||`). `proc()` corresponds to `~once fn()`, that is, a
closure which may be called once and whose environment is allocated on
the heap. The advantage of this is that it allows for moving values
into the body of `do`.

[1]: http://static.rust-lang.org/doc/0.9/std/num/trait.FromPrimitive.html

From carter.schonwald at gmail.com  Sun Jan 12 09:31:59 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sun, 12 Jan 2014 12:31:59 -0500
Subject: [rust-dev] Fast inverse square root in Rust
In-Reply-To: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
References: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
Message-ID: <CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>

http://static.rust-lang.org/doc/0.9/std/num/trait.Algebraic.html

On Sunday, January 12, 2014, Thad Guidry wrote:

> Where is the fast inverse square root function in Rust ?
> http://en.wikipedia.org/wiki/Fast_inverse_square_root
>
> Anyone know if this semi-accurate function is at a hardware level and
> built in to Intel chipsets since MMX ?
>
> How does this affect LLVM and Rust compilation on 64 bit ?
>
> Thanks in advance,
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/5fed1bbd/attachment.html>

From owen.shepherd at e43.eu  Sun Jan 12 09:51:14 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sun, 12 Jan 2014 17:51:14 +0000
Subject: [rust-dev] Fast inverse square root in Rust
In-Reply-To: <CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
References: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
	<CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
Message-ID: <CAHUXVy5dNZ2SE+xTM005t49EZe5=95gHfYSvccq2u17vKRqcEQ@mail.gmail.com>

The "Fast inverse square root" is no longer fast. SSE implements accurate
square root which is faster.

Owen Shepherd
http://owenshepherd.net | owen.shepherd at e43.eu


On 12 January 2014 17:31, Carter Schonwald <carter.schonwald at gmail.com>wrote:

>
> http://static.rust-lang.org/doc/0.9/std/num/trait.Algebraic.html
>
> On Sunday, January 12, 2014, Thad Guidry wrote:
>
>> Where is the fast inverse square root function in Rust ?
>> http://en.wikipedia.org/wiki/Fast_inverse_square_root
>>
>> Anyone know if this semi-accurate function is at a hardware level and
>> built in to Intel chipsets since MMX ?
>>
>> How does this affect LLVM and Rust compilation on 64 bit ?
>>
>> Thanks in advance,
>>
>> --
>> -Thad
>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/e65577ce/attachment.html>

From me at kevincantu.org  Sun Jan 12 10:00:14 2014
From: me at kevincantu.org (Kevin Cantu)
Date: Sun, 12 Jan 2014 18:00:14 +0000
Subject: [rust-dev] 1/28 Bay Area Rust meetup: Rust 0.9 and DST
In-Reply-To: <CALdfqQLH_20m1V00SzycMMipPPabu8+g=zCwzJzcw44i7_iWAQ@mail.gmail.com>
References: <CALdfqQJ9=NZD0V_sKOfGN+7ZeUOq=SSHy3tgtV9WwwUZ01U4Bg@mail.gmail.com>
	<52CE82C5.8030509@seld.be>
	<CALdfqQLH_20m1V00SzycMMipPPabu8+g=zCwzJzcw44i7_iWAQ@mail.gmail.com>
Message-ID: <CABq6+aeWZp6jawVm+BG8u7j4CPq+YYfFyYRDdH4xdTeuyP6HsA@mail.gmail.com>

If anybody else on the list is in Cambridge, UK, we whould get together
someplace and watch the video later that day!

Kevin
On Jan 9, 2014 2:38 PM, "Erick Tryzelaar" <erick.tryzelaar at gmail.com> wrote:

> You are in luck. They all are posted on air.mozilla.org. You can find all
> the other meetup presentations here:
>
> https://air.mozilla.org/search/?q=Rust
>
> On Thursday, January 9, 2014, Jordi Boggiano wrote:
>
>> On 08/01/2014 16:58, Erick Tryzelaar wrote:
>>
>>> Hello Rusticians!
>>>
>>> I'm happy to announce the next Bay Area Rust meetup on 1/28! You can
>>> sign up for it here:
>>>
>>> http://www.meetup.com/Rust-Bay-Area/events/153909222/
>>>
>>
>> If possible it'd be awesome to post recordings here after the meetup, for
>> those that can't physically make it.
>>
>> Cheers
>>
>> --
>> Jordi Boggiano
>> @seldaek - http://nelm.io/jordi
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/b3072d01/attachment.html>

From thadguidry at gmail.com  Sun Jan 12 10:19:11 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Sun, 12 Jan 2014 12:19:11 -0600
Subject: [rust-dev] Fast inverse square root in Rust
In-Reply-To: <CAHUXVy5dNZ2SE+xTM005t49EZe5=95gHfYSvccq2u17vKRqcEQ@mail.gmail.com>
References: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
	<CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
	<CAHUXVy5dNZ2SE+xTM005t49EZe5=95gHfYSvccq2u17vKRqcEQ@mail.gmail.com>
Message-ID: <CAChbWaNP+uXydfFe99om_mY+9XVk16CyN=nKh6SwdFx3OUOX4A@mail.gmail.com>

Is that implemented through LLVM at
http://llvm.org/docs/doxygen/html/TargetTransformInfo_8h_source.html

00265   /// haveFastSqrt -- Return true if the hardware has a fast
square-root00266   /// instruction.00267   virtual bool haveFastSqrt
<http://llvm.org/docs/doxygen/html/classllvm_1_1TargetTransformInfo.html#a01138d480dc0f9e11216e65d676a5bb9>(Type
<http://llvm.org/docs/doxygen/html/classllvm_1_1Type.html> *Ty) const;


How does that pass from Rust ???

On Sun, Jan 12, 2014 at 11:51 AM, Owen Shepherd <owen.shepherd at e43.eu>wrote:

> The "Fast inverse square root" is no longer fast. SSE implements accurate
> square root which is faster.
>
> Owen Shepherd
> http://owenshepherd.net | owen.shepherd at e43.eu
>
>
> On 12 January 2014 17:31, Carter Schonwald <carter.schonwald at gmail.com>wrote:
>
>>
>> http://static.rust-lang.org/doc/0.9/std/num/trait.Algebraic.html
>>
>> On Sunday, January 12, 2014, Thad Guidry wrote:
>>
>>> Where is the fast inverse square root function in Rust ?
>>> http://en.wikipedia.org/wiki/Fast_inverse_square_root
>>>
>>> Anyone know if this semi-accurate function is at a hardware level and
>>> built in to Intel chipsets since MMX ?
>>>
>>> How does this affect LLVM and Rust compilation on 64 bit ?
>>>
>>> Thanks in advance,
>>>
>>> --
>>> -Thad
>>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>


-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/eca0c204/attachment-0001.html>

From troplin at bluewin.ch  Sun Jan 12 10:23:46 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Sun, 12 Jan 2014 18:23:46 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
Message-ID: <1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>

Isaac Dupree
<ml at isaac.cedarswampstudios.org> wrote:
> In general, Rust is a systems language, so fixed-size integral types are 
> important to have.  They are better-behaved than in C and C++ in that 
> signed types are modulo, not undefined behaviour, on overflow.  It could 
> be nice to have integral types that are task-failure on overflow as an 
> option too.  As you note, bignum integers are important too; it's good 
> they're available.  I think bignum rationals would be a fine additional 
> choice to have (Haskell and GMP offer them, for example).

Wrapping overflow is just as bad as undefined behavior IMO. I cannot
remember a single case of using signed integers where wrapping would make
any sense.
And you lose some optimization opportunities.

Trapping overflow is a bit better security wise, but performance is worse.
Also IIRC it does not play nicely with existing code that assumes
otherwise.
Checking only at runtime is also not optimal. 

Bigints are secure but IMO not suited as default for a systems PL.

So why not take the path of the rust memory management and enforce bounds
statically? It would need annotations on the types, like lifetimes, but it
would be very rusty. Like C but safe.

Tobi


From ml at isaac.cedarswampstudios.org  Sun Jan 12 11:02:02 2014
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Sun, 12 Jan 2014 14:02:02 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D0DDA3.8040501@isaac.cedarswampstudios.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
Message-ID: <52D2E6AA.7070403@isaac.cedarswampstudios.org>

Another sweet spot for a few applications is larger-than-word-sized 
fixed-width types, such as a 128 or 192 bit (u)int.  This is useful for 
code that has to deal with values larger than 64 bits but within, say, 
256 or 512 bits (above this, I think the costs of dynamic allocation and 
non-inlined numeric code become cheap-ish compared to the numeric 
computation and storage costs).  I've done this with C++ templates; it 
works pretty okay; it sure makes GCC/LLVM's register allocator work hard!

-Isaac

From carter.schonwald at gmail.com  Sun Jan 12 11:06:38 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sun, 12 Jan 2014 14:06:38 -0500
Subject: [rust-dev] Fast inverse square root in Rust
In-Reply-To: <CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
References: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
	<CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
Message-ID: <CAHYVw0xUKO93Hp-=th0pDmiMYSH59Y4YoLgC3sHS=ct8Acfi_w@mail.gmail.com>

Note that on modern hardware the fast inv trick, which is a very specific
trick indeed, is just one approach.  Modern intel CPUs do have some special
instructions support that's related.  Note that many of these tricks /
primops do not provide the full available representable precision.

That actually raises a good point: for finite precision real number types
like f64 /f32 etc, what are the desired precision/numerical stability
guarantees of routines included I the std lib?  For operations on IEEE
floating point types, how do these guarantees carry  these composite
operations in the presence of rounding modes?

These are nuanced questions.  And maybe there should different types /
traits depending on the assumptions needed. (A fun question is: "when is
multiplication commutative and associative?", because it's not for
matrices, floats and groups)


Anyways, numerical computation is subtle :-)



On Sunday, January 12, 2014, Carter Schonwald wrote:

>
> http://static.rust-lang.org/doc/0.9/std/num/trait.Algebraic.html
>
> On Sunday, January 12, 2014, Thad Guidry wrote:
>
>> Where is the fast inverse square root function in Rust ?
>> http://en.wikipedia.org/wiki/Fast_inverse_square_root
>>
>> Anyone know if this semi-accurate function is at a hardware level and
>> built in to Intel chipsets since MMX ?
>>
>> How does this affect LLVM and Rust compilation on 64 bit ?
>>
>> Thanks in advance,
>>
>> --
>> -Thad
>> +ThadGuidry <https://www.google.com/+ThadGuidry>
>> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/56c67ce4/attachment.html>

From owen.shepherd at e43.eu  Sun Jan 12 11:09:37 2014
From: owen.shepherd at e43.eu (Owen Shepherd)
Date: Sun, 12 Jan 2014 19:09:37 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D2E6AA.7070403@isaac.cedarswampstudios.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D2E6AA.7070403@isaac.cedarswampstudios.org>
Message-ID: <CAHUXVy7s1CwmK_iQRSi9Pa6ZC32BiBfFk7B-hafUnkwznuSRnQ@mail.gmail.com>

On 12 January 2014 19:02, Isaac Dupree <ml at isaac.cedarswampstudios.org>wrote:

> Another sweet spot for a few applications is larger-than-word-sized
> fixed-width types, such as a 128 or 192 bit (u)int.  This is useful for
> code that has to deal with values larger than 64 bits but within, say, 256
> or 512 bits (above this, I think the costs of dynamic allocation and
> non-inlined numeric code become cheap-ish compared to the numeric
> computation and storage costs).  I've done this with C++ templates; it
> works pretty okay; it sure makes GCC/LLVM's register allocator work hard!
>

-Isaac
>
>
A minor variation of "checked_add" (i.e. add_with_carry) would take care of
this. Obviously also need a multiply which returns the two result halves
also.

For implementing bignum arithmetic, this is obviously a point where a
"natural int" type would be best (probably the biggest which fits a single
register)

Owen Shepherd
http://owenshepherd.net | owen.shepherd at e43.eu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/5c9d103f/attachment.html>

From danielmicay at gmail.com  Sun Jan 12 12:24:08 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 12 Jan 2014 15:24:08 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
Message-ID: <CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>

On Sun, Jan 12, 2014 at 1:23 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
> Isaac Dupree
> <ml at isaac.cedarswampstudios.org> wrote:
>> In general, Rust is a systems language, so fixed-size integral types are
>> important to have.  They are better-behaved than in C and C++ in that
>> signed types are modulo, not undefined behaviour, on overflow.  It could
>> be nice to have integral types that are task-failure on overflow as an
>> option too.  As you note, bignum integers are important too; it's good
>> they're available.  I think bignum rationals would be a fine additional
>> choice to have (Haskell and GMP offer them, for example).
>
> Wrapping overflow is just as bad as undefined behavior IMO.

Do you know what undefined behavior is? It doesn't mean unspecified.

> I cannot remember a single case of using signed integers where wrapping would make any sense.

It often makes sense in codecs, hashing algorithms and cryptography.
If you don't have clear bounds and don't want modular arithmetic, you
need big integers.

> And you lose some optimization opportunities.

It's treated as undefined because there are more optimization
opportunities that way.

> So why not take the path of the rust memory management and enforce bounds
> statically? It would need annotations on the types, like lifetimes, but it
> would be very rusty. Like C but safe.

Rust isn't supposed to be really hard to write. Complex dependent typing would

From danielmicay at gmail.com  Sun Jan 12 12:25:40 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 12 Jan 2014 15:25:40 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAHUXVy7s1CwmK_iQRSi9Pa6ZC32BiBfFk7B-hafUnkwznuSRnQ@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D2E6AA.7070403@isaac.cedarswampstudios.org>
	<CAHUXVy7s1CwmK_iQRSi9Pa6ZC32BiBfFk7B-hafUnkwznuSRnQ@mail.gmail.com>
Message-ID: <CA+DvKQKX8ReCHW2CWMro0ai92KOLz9kmfwGt8-S31wqgdC6KTg@mail.gmail.com>

On Sun, Jan 12, 2014 at 2:09 PM, Owen Shepherd <owen.shepherd at e43.eu> wrote:
>
> For implementing bignum arithmetic, this is obviously a point where a
> "natural int" type would be best (probably the biggest which fits a single
> register)

If you plan on writing a competitive big integer library, then the
integer size is the least of your worries. You're going to be using
specialized instructions per-revision of different platforms not
provided outside of inline assembly or per-platform LLVM intrinsics.

From glaebhoerl at gmail.com  Sun Jan 12 12:55:17 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 12 Jan 2014 21:55:17 +0100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
	<CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
	<CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
	<CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
Message-ID: <CAPoegsxxh+OmkMtwRr1v1h4cH7KrU4riJwSUix2uAQXBM9q6xg@mail.gmail.com>

On Sat, Jan 11, 2014 at 11:18 AM, Marijn Haverbeke <marijnh at gmail.com>wrote:

> I am not aware of an efficient way to provide
> automatic-overflow-to-bignum semantics in a non-garbage-collected
> language, without also imposing the burden of references/move
> semantics/etc on users of small integers. I.e. integers, if they may
> hold references to allocated memory can no longer sanely be considered
> a simple value type, which doesn't seem like it'd be a good idea for
> Rust.
>
> If there is a good solution to this, I'd love to find out about it.
>


This is a very good point. My thinking w.r.t. checking for overflow used to
be that if you're taking the performance hit for it, you might as well
expand to a big integer instead of failing, because if the use case is
indexing into an array, then the bounds check will catch it, and in other
use cases it's likely preferable.

But checked integers are POD and big/expanding ones aren't, which is a big
advantage for the former.

All of this really makes me wish hardware supported overflow checking in an
efficient manner natively. If it can throw an exception for divide by zero,
then why not overflow? (...I expect someone will actually have an answer
for this.)



> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/50889a9b/attachment.html>

From danielmicay at gmail.com  Sun Jan 12 13:08:22 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 12 Jan 2014 16:08:22 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAPoegsxxh+OmkMtwRr1v1h4cH7KrU4riJwSUix2uAQXBM9q6xg@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
	<CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
	<CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
	<CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
	<CAPoegsxxh+OmkMtwRr1v1h4cH7KrU4riJwSUix2uAQXBM9q6xg@mail.gmail.com>
Message-ID: <CA+DvKQK_vh7KFwrkOm=1g0gUTX7OONTYi74pYC1=OGGANot7Bw@mail.gmail.com>

On Sun, Jan 12, 2014 at 3:55 PM, G?bor Lehel <glaebhoerl at gmail.com> wrote:
>
>
>
> On Sat, Jan 11, 2014 at 11:18 AM, Marijn Haverbeke <marijnh at gmail.com>
> wrote:
>>
>> I am not aware of an efficient way to provide
>> automatic-overflow-to-bignum semantics in a non-garbage-collected
>> language, without also imposing the burden of references/move
>> semantics/etc on users of small integers. I.e. integers, if they may
>> hold references to allocated memory can no longer sanely be considered
>> a simple value type, which doesn't seem like it'd be a good idea for
>> Rust.
>>
>> If there is a good solution to this, I'd love to find out about it.
>
> This is a very good point. My thinking w.r.t. checking for overflow used to
> be that if you're taking the performance hit for it, you might as well
> expand to a big integer instead of failing, because if the use case is
> indexing into an array, then the bounds check will catch it, and in other
> use cases it's likely preferable.

An overflow check adds a branch and the pipeline serialization from
reading the carry/overflow flag. Expanding to a big integer requires another
branch.

Both can be compiled in such a way that they are always predicted
correctly, but it still adds very significant overhead.

> But checked integers are POD and big/expanding ones aren't, which is a big
> advantage for the former.

In almost every case, the overflow-checked integer hitting the bound
is still going to be a bug. An expanding type is actually
higher-level.

> All of this really makes me wish hardware supported overflow checking in an
> efficient manner natively. If it can throw an exception for divide by zero,
> then why not overflow? (...I expect someone will actually have an answer for
> this.)

Rust can't make use of this kind of CPU support, since it wants to use
(Rust-specific) unwinding.

From pwalton at mozilla.com  Sun Jan 12 14:08:31 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Sun, 12 Jan 2014 14:08:31 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQK_vh7KFwrkOm=1g0gUTX7OONTYi74pYC1=OGGANot7Bw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<CA++BO6RkXc5kRWg0kCjWxp+ntTigCHcshuPTL-iO7xYy_mNh7A@mail.gmail.com>
	<CAHYVw0xWbTmpUYsefNVkwcLkKLceqOi_pb5bs7XoGZi-_F=aeQ@mail.gmail.com>
	<CA+DvKQ+xhKEK0O_uG2cf6Lrads-qh5Pd-OTV=wz13mMq_EsRRA@mail.gmail.com>
	<CAHYVw0xYPDJqDthcy7UR6JTy5EYa3r7vYeS=Qb701CTXgRUbNA@mail.gmail.com>
	<CAJnHWXv=DBS2omXqdP5bAxzoe=1JOghfZ79KS8=9yxcR-y==5A@mail.gmail.com>
	<CAPoegsxxh+OmkMtwRr1v1h4cH7KrU4riJwSUix2uAQXBM9q6xg@mail.gmail.com>
	<CA+DvKQK_vh7KFwrkOm=1g0gUTX7OONTYi74pYC1=OGGANot7Bw@mail.gmail.com>
Message-ID: <034226e8-9817-469d-9cd4-21e5805b101a@email.android.com>

I think in theory we could arrange for the signal handler to trigger unwinding or use Windows SEH, which is zero cost on 64 bit AIUI.

Daniel Micay <danielmicay at gmail.com> wrote:
>On Sun, Jan 12, 2014 at 3:55 PM, G?bor Lehel <glaebhoerl at gmail.com>
>wrote:
>>
>>
>>
>> On Sat, Jan 11, 2014 at 11:18 AM, Marijn Haverbeke
><marijnh at gmail.com>
>> wrote:
>>>
>>> I am not aware of an efficient way to provide
>>> automatic-overflow-to-bignum semantics in a non-garbage-collected
>>> language, without also imposing the burden of references/move
>>> semantics/etc on users of small integers. I.e. integers, if they may
>>> hold references to allocated memory can no longer sanely be
>considered
>>> a simple value type, which doesn't seem like it'd be a good idea for
>>> Rust.
>>>
>>> If there is a good solution to this, I'd love to find out about it.
>>
>> This is a very good point. My thinking w.r.t. checking for overflow
>used to
>> be that if you're taking the performance hit for it, you might as
>well
>> expand to a big integer instead of failing, because if the use case
>is
>> indexing into an array, then the bounds check will catch it, and in
>other
>> use cases it's likely preferable.
>
>An overflow check adds a branch and the pipeline serialization from
>reading the carry/overflow flag. Expanding to a big integer requires
>another
>branch.
>
>Both can be compiled in such a way that they are always predicted
>correctly, but it still adds very significant overhead.
>
>> But checked integers are POD and big/expanding ones aren't, which is
>a big
>> advantage for the former.
>
>In almost every case, the overflow-checked integer hitting the bound
>is still going to be a bug. An expanding type is actually
>higher-level.
>
>> All of this really makes me wish hardware supported overflow checking
>in an
>> efficient manner natively. If it can throw an exception for divide by
>zero,
>> then why not overflow? (...I expect someone will actually have an
>answer for
>> this.)
>
>Rust can't make use of this kind of CPU support, since it wants to use
>(Rust-specific) unwinding.
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/155ae559/attachment.html>

From artella.coding at googlemail.com  Sun Jan 12 15:13:53 2014
From: artella.coding at googlemail.com (Artella Coding)
Date: Sun, 12 Jan 2014 23:13:53 +0000
Subject: [rust-dev] Debugging (rust 0.9) in Ubuntu via GDB
Message-ID: <CAARHtnQacFsFGDnf_5cWB8U_C+LWmzVmMdWRjF+gft3WPRtNMw@mail.gmail.com>

Suppose I have the following program :

**********************************************
//prog1.rs
use std::rand::{task_rng, Rng};

fn main() {
    let names = ["Alice", "Bob", "Carol"];
    for name in names.iter() {
        let v = task_rng().shuffle(~[1,2,3]);
        for num in v.iter() {
            println!("{:s} says: {:d}", *name, *num);
        }
    }
}
**********************************************

In previous versions of rust it was possible to put
a breakpoint on "shuffle"  e.g.

One would first compile via :

rustc -Z debug-info prog1.rs

and then one could proceed to put a breakpoint on "shuffle" :

gdb ./prog1
(gdb) break shuffle
(gdb) run

However now it doesn't seem possible to put a breakpoint on shuffle. Why is
this? Thanks.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/ecade730/attachment-0001.html>

From robert at ocallahan.org  Sun Jan 12 17:01:43 2014
From: robert at ocallahan.org (Robert O'Callahan)
Date: Mon, 13 Jan 2014 14:01:43 +1300
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D1DAD5.2080308@mozilla.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
Message-ID: <CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>

On Sun, Jan 12, 2014 at 12:59 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/10/14 10:08 PM, Daniel Micay wrote:
>
>> I don't think failure on overflow is very useful. It's still a bug if
>> you overflow when you don't intend it.
>>
>
> Of course it's useful. It prevents attackers from weaponizing
> out-of-bounds reads and writes in unsafe code.
>

Yes. And as a browser developer, I still want trap-on-overflow by default
in the browser if it can be cheap. Overflowing integer coordinates can lead
to infinite loops and incorrect layout or rendering, the latter of which
can occasionally have security implications. Task failure is better than
both of those. Generally, the sooner we detect bugs and fail the more
robust we will be against malicious input. Being able to harden the code
against a common class of bugs without making the language any more
complicated is very attractive to me.

I examined Gecko's gfx module a while back and determined that the only
adds and subtracts that *should* overflow were in hash functions, a
miniscule fraction of the total. Adding crypto and codecs into the mix
wouldn't make much difference. (You aren't going to write those in Rust
without SIMD anyway.)

Daniel's points about cost are interesting but there's a lot of things that
could be tried before declaring the problem intractable. Since most Rust
side effects commute with task failure, you could do a lot of trap code
motion and coalescing. The absence of overflow lets the compiler reason
more effectively about arithmetic, benefiting optimizations such as array
bounds check elimination. Range analysis becomes very important so you want
work at it harder. Etc.

Rob
-- 
Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni
le atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
waanndt  wyeonut  thoo mken.o w
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/b058d713/attachment.html>

From gmaxwell at gmail.com  Sun Jan 12 17:19:06 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 12 Jan 2014 17:19:06 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D1F4B8.7040805@cantrip.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1CE72.8070003@cantrip.org>
	<CA+DvKQJWNBz39cY7e__tqJbn+QERh0RLOX6jhKcQx3xiPGjkMw@mail.gmail.com>
	<52D1F4B8.7040805@cantrip.org>
Message-ID: <CAAS2fgSJ46X_VHxoQoFao974RMEJuZ91BGXgZ2LnM1q9h-D2XQ@mail.gmail.com>

On Sat, Jan 11, 2014 at 5:49 PM, Nathan Myers <ncm at cantrip.org> wrote:
> No one would complain about a built-in "i128" type.  The thing
> about a fixed-size type is that there are no implementation
> choices to leak out.  Overflowing an i128 variable is quite
> difficult, and 128-bit operations are still lots faster than on
> any variable-precision type. I could live with "int" == "i128".

It's certainly harder to overflow a 128 bit type by accident, though I think you
over-state it: iterating foo *= foo 128 times will overflow even if
foo is initially
just 1, but moreover overflow that arises by chance is not the only
sort programs
have to deal with: malicious parties trigger overflow to cause
unexpected behavior.

I think a bigger argument for range checked types is not related to how easy
the overflow is to trigger but, rather, how likely it is that the
software cannot actually
handle it when it is triggered? the same problem with null pointers.
In C a lot of
software is not null safe, its difficulty to tell at a glance if any
particular function
is null safe, and difficult to tell if a function needs to be null
safe, and (apparently)
difficult for many to keep null safety in mind when writing software.
"Surprise! this
value can be null! Hope you weren't going to deference it!" is a lot
like "Surprise!
these integers can have crazy values! Hope you weren't going to square
one of them".

[Not that having a 128 bit type wouldn't be great since x86 has the
lower and upper
multiplies having a 128 bit type makes it easy to get access to
64x64->128 without
using assembly. I just don't think adding larger types really makes a meaningful
improvement with respect to safety... and the overhead is equal or
higher than having
a 64 bit type and a tag that indicates the the stored value is really
a pointer to a
multiprecision integer.]

From danielmicay at gmail.com  Sun Jan 12 17:22:43 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 12 Jan 2014 20:22:43 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
	<CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
Message-ID: <CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>

On Sun, Jan 12, 2014 at 8:01 PM, Robert O'Callahan <robert at ocallahan.org> wrote:
> On Sun, Jan 12, 2014 at 12:59 PM, Patrick Walton <pcwalton at mozilla.com>
> wrote:
>>
>> On 1/10/14 10:08 PM, Daniel Micay wrote:
>>>
>>> I don't think failure on overflow is very useful. It's still a bug if
>>> you overflow when you don't intend it.
>>
>>
>> Of course it's useful. It prevents attackers from weaponizing
>> out-of-bounds reads and writes in unsafe code.
>
>
> Yes. And as a browser developer, I still want trap-on-overflow by default in
> the browser if it can be cheap. Overflowing integer coordinates can lead to
> infinite loops and incorrect layout or rendering, the latter of which can
> occasionally have security implications. Task failure is better than both of
> those. Generally, the sooner we detect bugs and fail the more robust we will
> be against malicious input. Being able to harden the code against a common
> class of bugs without making the language any more complicated is very
> attractive to me.

-fsanitize=signed-integer-overflow: Signed integer overflow, including
all the checks added by -ftrapv, and checking for overflow in signed
division (INT_MIN / -1).

Why not measure the impact of this on Firefox performance? We'll have
a concrete answer about half of the picture (but not about the cost
for unsigned or checks on overlong shifts and for division by zero).

> Daniel's points about cost are interesting but there's a lot of things that
> could be tried before declaring the problem intractable. Since most Rust
> side effects commute with task failure, you could do a lot of trap code
> motion and coalescing. The absence of overflow lets the compiler reason more
> effectively about arithmetic, benefiting optimizations such as array bounds
> check elimination. Range analysis becomes very important so you want work at
> it harder. Etc.

Inter-procedural optimization in LLVM can only eliminate dead code,
propagate constants, inline/merge functions and bubble up effects.

As far as I know, doing more takes way too long. Eliminating array
bounds checks and reasoning about arithmetic just doesn't really
happen.

The best hope for an inner loop is for loop-vectorize/slp-vectorize to
do their work, and they won't if there are overflow/carry checks.

LLVM is designed to optimize C code, and deviating from that kind of
code generation without losing a lot of performance means doing your
own optimizations on your own intermediate format like Haskell.

From pcwalton at mozilla.com  Sun Jan 12 17:30:12 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 12 Jan 2014 17:30:12 -0800
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
	<CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
	<CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
Message-ID: <52D341A4.7060300@mozilla.com>

On 1/12/14 5:22 PM, Daniel Micay wrote:
> As far as I know, doing more takes way too long. Eliminating array
> bounds checks and reasoning about arithmetic just doesn't really
> happen.

I think the jury is still out. See "A Fast and Low-Overhead Technique to 
Secure Programs Against Integer Overflows" by Rodrigues et al., CGO '2013:

http://homepages.dcc.ufmg.br/~fernando/publications/papers/CGO13_raphael.pdf

This has been implemented as an LLVM pass:

http://code.google.com/p/range-analysis/

They cite a slowdown of merely 1.73% on the LLVM benchmark suite with 
their analysis, which is quite impressive. Given that range analysis can 
also eliminate bounds checks in Rust, I suspect that this is worth pursuing.

That said I'm not sure we can gate 1.0 on this, since there's 
undoubtedly work needed to get this up to production quality. This is 
bleeding-edge stuff. However, I would personally definitely be 
interested in pursuing this post-1.0 for Servo and other apps that want 
to be hardened against overflows.

Patrick


From robert at ocallahan.org  Sun Jan 12 17:53:41 2014
From: robert at ocallahan.org (Robert O'Callahan)
Date: Mon, 13 Jan 2014 14:53:41 +1300
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
	<CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
	<CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
Message-ID: <CAOp6jLYuB4nvR1GRQxRHo6w2vvb5CxuE-tApzROirDSNqT=C1Q@mail.gmail.com>

On Mon, Jan 13, 2014 at 2:22 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> -fsanitize=signed-integer-overflow: Signed integer overflow, including
> all the checks added by -ftrapv, and checking for overflow in signed
> division (INT_MIN / -1).
>
> Why not measure the impact of this on Firefox performance? We'll have
> a concrete answer about half of the picture (but not about the cost
> for unsigned or checks on overlong shifts and for division by zero).
>

That would give us neither an upper bound on overhead (due to excluding
unsigned), nor a lower bound (due to no range analysis or LLVM changes).
But it might be interesting...

Inter-procedural optimization in LLVM can only eliminate dead code,
> propagate constants, inline/merge functions and bubble up effects.
>
> As far as I know, doing more takes way too long. Eliminating array
> bounds checks and reasoning about arithmetic just doesn't really
> happen.
>

So not even as good as Java and JS JITs? Sad.


> The best hope for an inner loop is for loop-vectorize/slp-vectorize to
> do their work, and they won't if there are overflow/carry checks.
>
> LLVM is designed to optimize C code, and deviating from that kind of
> code generation without losing a lot of performance means doing your
> own optimizations on your own intermediate format like Haskell.
>

I would rather not treat LLVM as immutable.

Rob
-- 
Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni
le atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
waanndt  wyeonut  thoo mken.o w
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/cf885f42/attachment-0001.html>

From carter.schonwald at gmail.com  Sun Jan 12 19:53:58 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Sun, 12 Jan 2014 22:53:58 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAOp6jLYuB4nvR1GRQxRHo6w2vvb5CxuE-tApzROirDSNqT=C1Q@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
	<CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
	<CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
	<CAOp6jLYuB4nvR1GRQxRHo6w2vvb5CxuE-tApzROirDSNqT=C1Q@mail.gmail.com>
Message-ID: <CAHYVw0z5OcG3dV6M72LcxNwd07gPCe9H0cXz714cQnOmoL5_1Q@mail.gmail.com>

@daniel,
the GHC haskell IR predates LLVM, and theres actually some pretty nice
examples of LLVM doing AMAZING optimization of bit fiddling haskell code
(in fact, for any performance ratio, i can manufacture a natural bit
fiddlign example where ghc -fllvm is that much better than ghc -fasm for
bit fiddling code currently).

Mind you this only happens in bit fiddling code where LLVM can basically
cancel out the composition of long sequences of bit fiddling of the form
mortonShuffle . inverseMortonShuffle . mortonShuffle .
inverseMortonShuffle, llvm is able to take the GHC IR  and algebraically
turn it into a No Op function.

That said, I definitely think theres ways LLVM can improve support for
langs that aren't C, and I've certainly gotten the impression LLVM devs are
open to contributions that leave everyone better off.


On Sun, Jan 12, 2014 at 8:53 PM, Robert O'Callahan <robert at ocallahan.org>wrote:

> On Mon, Jan 13, 2014 at 2:22 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> -fsanitize=signed-integer-overflow: Signed integer overflow, including
>> all the checks added by -ftrapv, and checking for overflow in signed
>> division (INT_MIN / -1).
>>
>> Why not measure the impact of this on Firefox performance? We'll have
>> a concrete answer about half of the picture (but not about the cost
>> for unsigned or checks on overlong shifts and for division by zero).
>>
>
> That would give us neither an upper bound on overhead (due to excluding
> unsigned), nor a lower bound (due to no range analysis or LLVM changes).
> But it might be interesting...
>
> Inter-procedural optimization in LLVM can only eliminate dead code,
>> propagate constants, inline/merge functions and bubble up effects.
>>
>> As far as I know, doing more takes way too long. Eliminating array
>> bounds checks and reasoning about arithmetic just doesn't really
>> happen.
>>
>
> So not even as good as Java and JS JITs? Sad.
>
>
>> The best hope for an inner loop is for loop-vectorize/slp-vectorize to
>> do their work, and they won't if there are overflow/carry checks.
>>
>> LLVM is designed to optimize C code, and deviating from that kind of
>> code generation without losing a lot of performance means doing your
>> own optimizations on your own intermediate format like Haskell.
>>
>
> I would rather not treat LLVM as immutable.
>
> Rob
> --
> Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni
> le atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
> stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
> 'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
> waanndt  wyeonut  thoo mken.o w
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140112/50617f27/attachment.html>

From michaelwoerister at posteo.de  Sun Jan 12 23:42:53 2014
From: michaelwoerister at posteo.de (Michael Woerister)
Date: Mon, 13 Jan 2014 08:42:53 +0100
Subject: [rust-dev] Debugging (rust 0.9) in Ubuntu via GDB
In-Reply-To: <CAARHtnQacFsFGDnf_5cWB8U_C+LWmzVmMdWRjF+gft3WPRtNMw@mail.gmail.com>
References: <CAARHtnQacFsFGDnf_5cWB8U_C+LWmzVmMdWRjF+gft3WPRtNMw@mail.gmail.com>
Message-ID: <52D398FD.7070408@posteo.de>

Hi,
the `break` command can be a bit particular where function names are 
concerned, especially when namespaces and generics are involved. The 
correct full name of the shuffle method would be something like 
`std::rand::TaskRng::shuffle<int>` (there is a seperate function for 
every set of concrete type parameters, so `shuffle<int>` would be 
different from `shuffle<f32>`).

My recommendation here is to either
* set the breakpoint using line numbers: break prog.rs:7
* or use the `rbreak` command which takes a regular expression as 
argument, that is, `rbreak shuffle` will match any function containing 
the string "shuffle" in its name.

Don't be shy to ask further questions if you have any :)

-Michael

On 13.01.2014 00:13, Artella Coding wrote:
> Suppose I have the following program :
>
> **********************************************
> //prog1.rs <http://prog1.rs>
> use std::rand::{task_rng, Rng};
> fn main() {
>     let names = ["Alice", "Bob", "Carol"];
>     for name in names.iter() {
>         let v = task_rng().shuffle(~[1,2,3]);
>         for num in v.iter() {
>             println!("{:s} says: {:d}", *name, *num);
>         }
>     }
> }
> **********************************************
>
> In previous versions of rust it was possible to put
> a breakpoint on "shuffle"  e.g.
>
> One would first compile via :
>
> rustc -Z debug-info prog1.rs <http://prog1.rs>
>
> and then one could proceed to put a breakpoint on "shuffle" :
>
> gdb ./prog1
> (gdb) break shuffle
> (gdb) run
>
> However now it doesn't seem possible to put a breakpoint on shuffle. 
> Why is this? Thanks.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/a6fcdc28/attachment.html>

From gaetan at xeberon.net  Mon Jan 13 02:43:26 2014
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 13 Jan 2014 11:43:26 +0100
Subject: [rust-dev] Call for central external packages repository
Message-ID: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>

Hi

I know this question has been debated, however I'd like to highly recommend
to give a clean infrastructure to register, list, search and describe
external libraries developed by everyone.

For instance, how do I know which http server lib should I use for rust 0.9?

This mailing list is quite good for announcing new package, but not for
find existing project that might have solved a given problem before me.

rust-ci
--------

This is the main candidate for this job, however I find it quite difficult
to find which project does what. It miss a "one line project description"
column. Its main purpose seem to watch for this set of projects still
compile against the master git branch, but there are other lib that are not
listed here.

I would recommend a central repository web site, working like pypi or other
community based repo, that would stimulate user contribution.

Such central repository would provide the following features:
- hierarchical project organisation (look at
here<https://pypi.python.org/pypi?%3Aaction=browse>
)
- provide clean forms to submit, review, publish, vote project
- clealy display which version of rust compiler (0.8, 0.9, master,...) this
lib is validated. For master, this would be linked to rust-ci. I also like
the idea of having automatic rust-ci validation for rust 0.8, 0.9,... Maybe
with several level of validation: compile validated, peer/administrator
validated, recommended,...
- good search form. This is how users look for a given project
- popular project. I tend to choose a project over its popularity. The more
"popular" a project is, or the more downloads count a lib have, the more I
think it will be actively maintained or more stable than the others.
- clear project dependency listing
- be promoted by rust homepage (repo.rust.org? rustpkg.rust.org,...?), so
any lambda user can easy find it

At first sight, I think we could just extending rust-ci to do this,
reoriented for package listing for a given rust version, by adding new
pages "package index for 0.9" with just a project name column ("rust-http"
and not "chris-morgan/rust-http <https://github.com/chris-morgan/rust-http>")
and a description column (extracted from github project description?.. this
also force to have to be on github for any project?). And what about
tarball or non github project?

What do you think about this idea? I am interested on working on this
matter, but would like to have your opinion on it.

Thanks
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/73e1db8d/attachment.html>

From hansjorg at gmail.com  Mon Jan 13 03:09:22 2014
From: hansjorg at gmail.com (=?ISO-8859-1?Q?Hans_J=F8rgen_Hoel?=)
Date: Mon, 13 Jan 2014 12:09:22 +0100
Subject: [rust-dev] Call for central external packages repository
In-Reply-To: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
References: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
Message-ID: <CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>

Hi,

Regarding rust-ci, I'm about to deploy some changes for it sometime in the
next few days.

Changes will include:

- project editing enabled (including removal of projects :))
- possibility for adding categories to projects and a category based index
- documentation upload from Travis CI builds (by adding two lines to the
.travis.yml)

I've also started working on search which would index project descriptions,
uploaded documentation and sources.

Source for the webapp will be available on GitHub soon if anyone is
interested in collaborating.

Regards,

Hans J?rgen


On 13 January 2014 11:43, Gaetan <gaetan at xeberon.net> wrote:

> Hi
>
> I know this question has been debated, however I'd like to highly
> recommend to give a clean infrastructure to register, list, search and
> describe external libraries developed by everyone.
>
> For instance, how do I know which http server lib should I use for rust
> 0.9?
>
> This mailing list is quite good for announcing new package, but not for
> find existing project that might have solved a given problem before me.
>
> rust-ci
> --------
>
> This is the main candidate for this job, however I find it quite difficult
> to find which project does what. It miss a "one line project description"
> column. Its main purpose seem to watch for this set of projects still
> compile against the master git branch, but there are other lib that are not
> listed here.
>
> I would recommend a central repository web site, working like pypi or
> other community based repo, that would stimulate user contribution.
>
> Such central repository would provide the following features:
> - hierarchical project organisation (look at here<https://pypi.python.org/pypi?%3Aaction=browse>
> )
> - provide clean forms to submit, review, publish, vote project
> - clealy display which version of rust compiler (0.8, 0.9, master,...)
> this lib is validated. For master, this would be linked to rust-ci. I also
> like the idea of having automatic rust-ci validation for rust 0.8, 0.9,...
> Maybe with several level of validation: compile validated,
> peer/administrator validated, recommended,...
> - good search form. This is how users look for a given project
> - popular project. I tend to choose a project over its popularity. The
> more "popular" a project is, or the more downloads count a lib have, the
> more I think it will be actively maintained or more stable than the others.
> - clear project dependency listing
> - be promoted by rust homepage (repo.rust.org? rustpkg.rust.org,...?), so
> any lambda user can easy find it
>
> At first sight, I think we could just extending rust-ci to do this,
> reoriented for package listing for a given rust version, by adding new
> pages "package index for 0.9" with just a project name column ("rust-http"
> and not "chris-morgan/rust-http<https://github.com/chris-morgan/rust-http>")
> and a description column (extracted from github project description?.. this
> also force to have to be on github for any project?). And what about
> tarball or non github project?
>
> What do you think about this idea? I am interested on working on this
> matter, but would like to have your opinion on it.
>
> Thanks
> -----
> Gaetan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/bcdafea6/attachment-0001.html>

From dbau.pp at gmail.com  Mon Jan 13 03:19:02 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 13 Jan 2014 22:19:02 +1100
Subject: [rust-dev] Call for central external packages repository
In-Reply-To: <CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>
References: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
	<CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>
Message-ID: <52D3CBA6.6090409@gmail.com>

On 13/01/14 22:09, Hans J?rgen Hoel wrote:
> Hi,
>
> Regarding rust-ci, I'm about to deploy some changes for it sometime in 
> the next few days.
>
> Changes will include:
>
> - project editing enabled (including removal of projects :))
> - possibility for adding categories to projects and a category based index
> - documentation upload from Travis CI builds (by adding two lines to 
> the .travis.yml)

Woah, woah. This sounds awesome.



Huon


>
> I've also started working on search which would index project 
> descriptions, uploaded documentation and sources.
>
> Source for the webapp will be available on GitHub soon if anyone is 
> interested in collaborating.
>
> Regards,
>
> Hans J?rgen
>
>
> On 13 January 2014 11:43, Gaetan <gaetan at xeberon.net 
> <mailto:gaetan at xeberon.net>> wrote:
>
>     Hi
>
>     I know this question has been debated, however I'd like to highly
>     recommend to give a clean infrastructure to register, list, search
>     and describe external libraries developed by everyone.
>
>     For instance, how do I know which http server lib should I use for
>     rust 0.9?
>
>     This mailing list is quite good for announcing new package, but
>     not for find existing project that might have solved a given
>     problem before me.
>
>     rust-ci
>     --------
>
>     This is the main candidate for this job, however I find it quite
>     difficult to find which project does what. It miss a "one line
>     project description" column. Its main purpose seem to watch for
>     this set of projects still compile against the master git branch,
>     but there are other lib that are not listed here.
>
>     I would recommend a central repository web site, working like pypi
>     or other community based repo, that would stimulate user contribution.
>
>     Such central repository would provide the following features:
>     - hierarchical project organisation (look at here
>     <https://pypi.python.org/pypi?%3Aaction=browse>)
>     - provide clean forms to submit, review, publish, vote project
>     - clealy display which version of rust compiler (0.8, 0.9,
>     master,...) this lib is validated. For master, this would be
>     linked to rust-ci. I also like the idea of having automatic
>     rust-ci validation for rust 0.8, 0.9,... Maybe with several level
>     of validation: compile validated, peer/administrator validated,
>     recommended,...
>     - good search form. This is how users look for a given project
>     - popular project. I tend to choose a project over its popularity.
>     The more "popular" a project is, or the more downloads count a lib
>     have, the more I think it will be actively maintained or more
>     stable than the others.
>     - clear project dependency listing
>     - be promoted by rust homepage (repo.rust.org
>     <http://repo.rust.org>? rustpkg.rust.org
>     <http://rustpkg.rust.org>,...?), so any lambda user can easy find it
>
>     At first sight, I think we could just extending rust-ci to do
>     this, reoriented for package listing for a given rust version, by
>     adding new pages "package index for 0.9" with just a project name
>     column ("rust-http" and not "chris-morgan/rust-http
>     <https://github.com/chris-morgan/rust-http>") and a description
>     column (extracted from github project description?.. this also
>     force to have to be on github for any project?). And what about
>     tarball or non github project?
>
>     What do you think about this idea? I am interested on working on
>     this matter, but would like to have your opinion on it.
>
>     Thanks
>     -----
>     Gaetan
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/c7da2e00/attachment.html>

From robert at ocallahan.org  Mon Jan 13 03:42:32 2014
From: robert at ocallahan.org (Robert O'Callahan)
Date: Tue, 14 Jan 2014 00:42:32 +1300
Subject: [rust-dev]  Impact of -ftrapv on Firefox
Message-ID: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>

On Mon, Jan 13, 2014 at 2:53 PM, Robert O'Callahan <robert at ocallahan.org>wrote:

> On Mon, Jan 13, 2014 at 2:22 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> -fsanitize=signed-integer-overflow: Signed integer overflow, including
>> all the checks added by -ftrapv, and checking for overflow in signed
>> division (INT_MIN / -1).
>>
>> Why not measure the impact of this on Firefox performance? We'll have
>> a concrete answer about half of the picture (but not about the cost
>> for unsigned or checks on overlong shifts and for division by zero).
>>
>
> That would give us neither an upper bound on overhead (due to excluding
> unsigned), nor a lower bound (due to no range analysis or LLVM changes).
> But it might be interesting...
>

Just for fun I did a Firefox build with -ftrapv. The most surprising thing
is that the browser actually worked, on Linux64 at least. Not so much on
Linux32 and Mac. https://tbpl.mozilla.org/?tree=Try&rev=45b9932ca819

The Talos performance results aren't exactly science, but it looks like the
performance impact is negligible. For example, tp5o (page load time test)
reported 285, central is around 280 (lower is better). Dromaeo-CSS reported
5408, whereas central is around 5500 (but noisy) (higher is better).

Like I said, I don't really know what this means, but it sounds hopeful to
me.

Rob
-- 
Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni
le atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
waanndt  wyeonut  thoo mken.o w
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/f5899ddf/attachment.html>

From glaebhoerl at gmail.com  Mon Jan 13 03:50:59 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 13 Jan 2014 12:50:59 +0100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <52D341A4.7060300@mozilla.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<52D0DF1D.1080805@gmail.com>
	<CA+DvKQJO2kFJZajVLAQ4pXQ+6fKxEhgWYRMtS8b+5HAypPJPdw@mail.gmail.com>
	<52D1DAD5.2080308@mozilla.com>
	<CAOp6jLZSc0GKiE27q2BdT9OC48vn_ZS1MnUZ=sVQ7wJxndVtmA@mail.gmail.com>
	<CA+DvKQKAUJkNSSynrT5P6PHesFTxwZsSpeXCQvAbi32zFcmoDA@mail.gmail.com>
	<52D341A4.7060300@mozilla.com>
Message-ID: <CAPoegszb0w2+YP0EvZprD36dkGy6xYfri0Vn8W0YqchZSug=fg@mail.gmail.com>

Would it be accurate to say that the only significant changes required at
the language level for all this would be not having a default integer type,
and then probably polymorphic number literals a la Haskell? And that the
rest of this discussion is only about policy and ergonomics?


On Mon, Jan 13, 2014 at 2:30 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/12/14 5:22 PM, Daniel Micay wrote:
>
>> As far as I know, doing more takes way too long. Eliminating array
>> bounds checks and reasoning about arithmetic just doesn't really
>> happen.
>>
>
> I think the jury is still out. See "A Fast and Low-Overhead Technique to
> Secure Programs Against Integer Overflows" by Rodrigues et al., CGO '2013:
>
> http://homepages.dcc.ufmg.br/~fernando/publications/papers/
> CGO13_raphael.pdf
>
> This has been implemented as an LLVM pass:
>
> http://code.google.com/p/range-analysis/
>
> They cite a slowdown of merely 1.73% on the LLVM benchmark suite with
> their analysis, which is quite impressive. Given that range analysis can
> also eliminate bounds checks in Rust, I suspect that this is worth pursuing.
>
> That said I'm not sure we can gate 1.0 on this, since there's undoubtedly
> work needed to get this up to production quality. This is bleeding-edge
> stuff. However, I would personally definitely be interested in pursuing
> this post-1.0 for Servo and other apps that want to be hardened against
> overflows.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/5f52b88b/attachment-0001.html>

From jon.mb at proinbox.com  Mon Jan 13 03:52:47 2014
From: jon.mb at proinbox.com (John Mija)
Date: Mon, 13 Jan 2014 11:52:47 +0000
Subject: [rust-dev] Debugging (rust 0.9) in Ubuntu via GDB
In-Reply-To: <52D398FD.7070408@posteo.de>
References: <CAARHtnQacFsFGDnf_5cWB8U_C+LWmzVmMdWRjF+gft3WPRtNMw@mail.gmail.com>
	<52D398FD.7070408@posteo.de>
Message-ID: <52D3D38F.4000104@proinbox.com>

There is a web front-end for gdb to debug applications in Go, C and C++. 
I'm supposed that it also could be used to debug Rust apps.

https://github.com/sirnewton01/godbg

El 13/01/14 07:42, Michael Woerister escribi?:
> Hi,
> the `break` command can be a bit particular where function names are
> concerned, especially when namespaces and generics are involved. The
> correct full name of the shuffle method would be something like
> `std::rand::TaskRng::shuffle<int>` (there is a seperate function for
> every set of concrete type parameters, so `shuffle<int>` would be
> different from `shuffle<f32>`).
>
> My recommendation here is to either
> * set the breakpoint using line numbers: break prog.rs:7
> * or use the `rbreak` command which takes a regular expression as
> argument, that is, `rbreak shuffle` will match any function containing
> the string "shuffle" in its name.
>
> Don't be shy to ask further questions if you have any :)
>
> -Michael
>
> On 13.01.2014 00:13, Artella Coding wrote:
>> Suppose I have the following program :
>>
>> **********************************************
>> //prog1.rs <http://prog1.rs>
>> use std::rand::{task_rng, Rng};
>> fn main() {
>>     let names = ["Alice", "Bob", "Carol"];
>>     for name in names.iter() {
>>         let v = task_rng().shuffle(~[1,2,3]);
>>         for num in v.iter() {
>>             println!("{:s} says: {:d}", *name, *num);
>>         }
>>     }
>> }
>> **********************************************
>>
>> In previous versions of rust it was possible to put
>> a breakpoint on "shuffle"  e.g.
>>
>> One would first compile via :
>>
>> rustc -Z debug-info prog1.rs <http://prog1.rs>
>>
>> and then one could proceed to put a breakpoint on "shuffle" :
>>
>> gdb ./prog1
>> (gdb) break shuffle
>> (gdb) run
>>
>> However now it doesn't seem possible to put a breakpoint on shuffle.
>> Why is this? Thanks.
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Mon Jan 13 04:49:32 2014
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 13 Jan 2014 13:49:32 +0100
Subject: [rust-dev] Call for central external packages repository
In-Reply-To: <52D3CBA6.6090409@gmail.com>
References: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
	<CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>
	<52D3CBA6.6090409@gmail.com>
Message-ID: <CANK7tAFnXHfP5gjEEW_phB5broOeMMsrgHJ8kbf4oAEeX_Pa0g@mail.gmail.com>

Sounds great.

Can you replace the "last commit msg" by "project description"? I think
this much more relevant.

-----
Gaetan



2014/1/13 Huon Wilson <dbau.pp at gmail.com>

>  On 13/01/14 22:09, Hans J?rgen Hoel wrote:
>
>    Hi,
>
>  Regarding rust-ci, I'm about to deploy some changes for it sometime in
> the next few days.
>
>  Changes will include:
>
>  - project editing enabled (including removal of projects :))
>  - possibility for adding categories to projects and a category based index
>  - documentation upload from Travis CI builds (by adding two lines to the
> .travis.yml)
>
>
> Woah, woah. This sounds awesome.
>
>
>
> Huon
>
>
>
>
>  I've also started working on search which would index project
> descriptions, uploaded documentation and sources.
>
>  Source for the webapp will be available on GitHub soon if anyone is
> interested in collaborating.
>
> Regards,
>
> Hans J?rgen
>
>
>  On 13 January 2014 11:43, Gaetan <gaetan at xeberon.net> wrote:
>
>> Hi
>>
>>  I know this question has been debated, however I'd like to highly
>> recommend to give a clean infrastructure to register, list, search and
>> describe external libraries developed by everyone.
>>
>>  For instance, how do I know which http server lib should I use for rust
>> 0.9?
>>
>>  This mailing list is quite good for announcing new package, but not for
>> find existing project that might have solved a given problem before me.
>>
>>  rust-ci
>> --------
>>
>>  This is the main candidate for this job, however I find it quite
>> difficult to find which project does what. It miss a "one line project
>> description" column. Its main purpose seem to watch for this set of
>> projects still compile against the master git branch, but there are other
>> lib that are not listed here.
>>
>>  I would recommend a central repository web site, working like pypi or
>> other community based repo, that would stimulate user contribution.
>>
>>  Such central repository would provide the following features:
>> - hierarchical project organisation (look at here<https://pypi.python.org/pypi?%3Aaction=browse>
>> )
>> - provide clean forms to submit, review, publish, vote project
>> - clealy display which version of rust compiler (0.8, 0.9, master,...)
>> this lib is validated. For master, this would be linked to rust-ci. I also
>> like the idea of having automatic rust-ci validation for rust 0.8, 0.9,...
>> Maybe with several level of validation: compile validated,
>> peer/administrator validated, recommended,...
>> - good search form. This is how users look for a given project
>> - popular project. I tend to choose a project over its popularity. The
>> more "popular" a project is, or the more downloads count a lib have, the
>> more I think it will be actively maintained or more stable than the others.
>> - clear project dependency listing
>> - be promoted by rust homepage (repo.rust.org? rustpkg.rust.org,...?),
>> so any lambda user can easy find it
>>
>>  At first sight, I think we could just extending rust-ci to do this,
>> reoriented for package listing for a given rust version, by adding new
>> pages "package index for 0.9" with just a project name column ("rust-http"
>> and not "chris-morgan/rust-http<https://github.com/chris-morgan/rust-http>")
>> and a description column (extracted from github project description?.. this
>> also force to have to be on github for any project?). And what about
>> tarball or non github project?
>>
>>  What do you think about this idea? I am interested on working on this
>> matter, but would like to have your opinion on it.
>>
>>  Thanks
>>  -----
>> Gaetan
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/94a6392d/attachment.html>

From gaetan at xeberon.net  Mon Jan 13 05:46:20 2014
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 13 Jan 2014 14:46:20 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
Message-ID: <CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>

what about using a well known build system as a transition to a custom,
rust-written build tool? If this is not planned in rust roadmap, I can't
see how this will work.

For me it's the same old dilemna: write my tool or use an existing one?
Same for doc... should we use sphinx or write a customized tool?

-----
Gaetan



2014/1/11 George Makrydakis <irrequietus at gmail.com>

> There is little reason to believe that having a build system in Rust would
> make It harder for people to package.
>
> I do understand the predependecy argument, but the Rust compiler itself in
> order to compile has predependencies anyway, as does any similar project.
> Therefore the decisional weight of choosing a non - rust based solution
> over a rust one because Debian packagers have problems packaging a compiler
> is not adequately justified.
>
> Using a well known build system as a means to appeal to programmers is
> seemingly an advantage, but it does not exonerate them from having to be
> competent in Rust before they write useful programs. And that has a
> learning curve superior to that of a build system.
>
> As for boost's jam I have nothing to say other than boost having its own
> build system makes it easy for boost first; this does not mean that their
> needs are those of everybody else and boost is a library, not a programming
> language itself. So, again, a decision based on picking a popular solution
> on the basis of such a comparison, has flawed background.
>
> Lastly, imagine the irony of Rust proposing to use python, c, c++ based
> build tools for simple packages. That would make packagers more frustrated
> because of a wider set of dependecies. While end users would have to also
> deal with a known system, its eventual inadequacies could not be met
> directly by Rust devs unless they start amending that system in order to
> deal with them. Therefore, maintenance overhead is inescapable either way,
> with the pessimization of relying in another nom - Rust project in order to
> make it worth your while to enjoy programming in Rust.
>
> The only valid argument against having a build system proposed as the
> official, defacto, cross - platform way of building rust packages written
> in rust is its development and maintenance overhead for the rust core team
> itself.
>
> That problem is easily circumvented by not proposing one right now and
> letting it to the end developer decide. If however an official build system
> is to be proposed, Rust developers merit having it done on their own
> platform, thus proving rust's worth. It is 2014 after all.
>
> G.
>
>
>
> Lee Braiden <leebraid at gmail.com> wrote:
> >On 10/01/14 08:16, Gaetan wrote:
> >>
> >> I am not in favor of a customized build system. For instance boost
> >> library use their jam build system, and i never figured how to use it
> >
> >> in my projects.
> >>
> >> I push to use standard and well proved build system like cmake or
> >> scons, at least for major components. This would give a nice example
> >> of how to use it in any projects.
> >>
> >
> >I'd agree with that on both counts: the principle of using something
> >standard, and the two recommendations.
> >
> >CMake would probably get my vote, because it's not so much a build
> >tool,
> >as a meta tool for whichever system you prefer, so it would fit in well
> >
> >with various platform-specific IDEs, unusual platforms (android,
> >embedded, ...), etc.  That said, scons is also a strong contender, and
> >which of the two is more open to integrating patches and working with
> >new languages is very much worth considering.
> >
> >I think Rust will be contributing to the wider community by lending its
> >
> >support (and patches) to a common, modern build system, AND it will get
> >
> >something back in terms of users who already know the build system.
> >
> >
> >>     On Friday, January 10, 2014, George Makrydakis wrote:
> >>
> >>
> >>         Hello,
> >>
> >>         Having a build system entirely dependent of Rust alone, would
> >>         make the entire experience in deploying the language
> >extremely
> >>         cohere. The only counter - argument is indeed that it would
> >>         require some work to get this to fruition. I would like to
> >>         know if this has any chance of getting priority soon enough.
> >>
> >
> >Bear in mind that Debian are having a lot of issues packaging Rust
> >already, because it self-compiles.  If the build tool also had a Rust
> >pre-dependency, that would be a big step backwards.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/933880ac/attachment-0001.html>

From jhasse at gmail.com  Mon Jan 13 06:46:43 2014
From: jhasse at gmail.com (Jan Niklas Hasse)
Date: Mon, 13 Jan 2014 15:46:43 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
Message-ID: <CALckf6i9nrnfQWb88cENy3MmDoxwO+300v03PmCxR5RJ3Kxx1A@mail.gmail.com>

2014/1/10 Corey Richardson <corey at octayn.net>:
> 3. Write a build system in Rust.
>
> This would take care of everything for us, using ourselves. We'd have
> a small script fetch the snapshot and build the build system, and then
> hand off the rest of the build to it. This has the advantage of one
> less build-time dependency, but the disadvantage that it's going to be
> a lot of work. This could also potentially output tup, ninja[3], or
> another form of build script after taking configuration options and
> so-forth. It could also integrate with librustc for smart handling of
> comments-or-test-only changes, an issue near to my heart[4]. This
> build system could potentially be rustpkg, but as I understand it the
> current idea is to *remove* rustpkg's ability as a build system and
> keep it as a package manager. (At least, that is what I've understood
> of recent discussion; this could be wrong.)

Do you have any links of those discussions? I'm new to the mailing list.

IMHO rustpkg should keep the ability of a build system. Lots of work
has already been put into it and why rewrite that?

I think this rust-written build tool should be rustpkg.

From irrequietus at gmail.com  Mon Jan 13 07:30:22 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Mon, 13 Jan 2014 17:30:22 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
Message-ID: <db443c51-6f04-4139-bd65-944d01641b46@email.android.com>

Several lengthy emails have full argumentation in supporting that as an interim solution given the current status of Rust itself. It is the adoption of a third party tool, not written in rust, as the defacto standard to use with official blessing, that should be discarded for reasons already discussed.

Again, note that this rather long thread is about discussing in the end what the official stance should be. There is no valid reason other than lack of manpower and / or language immaturity for having to depend on ruby, python, autotools, cmake or whatever else in order to build rust software.

Is Rust capable, as a systems language, of having a build system in Rust for Rust, or it should depend on other languages, *officially* for such a thing?

Personal preferences matter up to a point, but no more.


Gaetan <gaetan at xeberon.net> wrote:
>what about using a well known build system as a transition to a custom,
>rust-written build tool? If this is not planned in rust roadmap, I
>can't
>see how this will work.
>
>For me it's the same old dilemna: write my tool or use an existing one?
>Same for doc... should we use sphinx or write a customized tool?
>
>-----
>Gaetan
>
>
>
>2014/1/11 George Makrydakis <irrequietus at gmail.com>
>
>> There is little reason to believe that having a build system in Rust
>would
>> make It harder for people to package.
>>
>> I do understand the predependecy argument, but the Rust compiler
>itself in
>> order to compile has predependencies anyway, as does any similar
>project.
>> Therefore the decisional weight of choosing a non - rust based
>solution
>> over a rust one because Debian packagers have problems packaging a
>compiler
>> is not adequately justified.
>>
>> Using a well known build system as a means to appeal to programmers
>is
>> seemingly an advantage, but it does not exonerate them from having to
>be
>> competent in Rust before they write useful programs. And that has a
>> learning curve superior to that of a build system.
>>
>> As for boost's jam I have nothing to say other than boost having its
>own
>> build system makes it easy for boost first; this does not mean that
>their
>> needs are those of everybody else and boost is a library, not a
>programming
>> language itself. So, again, a decision based on picking a popular
>solution
>> on the basis of such a comparison, has flawed background.
>>
>> Lastly, imagine the irony of Rust proposing to use python, c, c++
>based
>> build tools for simple packages. That would make packagers more
>frustrated
>> because of a wider set of dependecies. While end users would have to
>also
>> deal with a known system, its eventual inadequacies could not be met
>> directly by Rust devs unless they start amending that system in order
>to
>> deal with them. Therefore, maintenance overhead is inescapable either
>way,
>> with the pessimization of relying in another nom - Rust project in
>order to
>> make it worth your while to enjoy programming in Rust.
>>
>> The only valid argument against having a build system proposed as the
>> official, defacto, cross - platform way of building rust packages
>written
>> in rust is its development and maintenance overhead for the rust core
>team
>> itself.
>>
>> That problem is easily circumvented by not proposing one right now
>and
>> letting it to the end developer decide. If however an official build
>system
>> is to be proposed, Rust developers merit having it done on their own
>> platform, thus proving rust's worth. It is 2014 after all.
>>
>> G.
>>
>>
>>
>> Lee Braiden <leebraid at gmail.com> wrote:
>> >On 10/01/14 08:16, Gaetan wrote:
>> >>
>> >> I am not in favor of a customized build system. For instance boost
>> >> library use their jam build system, and i never figured how to use
>it
>> >
>> >> in my projects.
>> >>
>> >> I push to use standard and well proved build system like cmake or
>> >> scons, at least for major components. This would give a nice
>example
>> >> of how to use it in any projects.
>> >>
>> >
>> >I'd agree with that on both counts: the principle of using something
>> >standard, and the two recommendations.
>> >
>> >CMake would probably get my vote, because it's not so much a build
>> >tool,
>> >as a meta tool for whichever system you prefer, so it would fit in
>well
>> >
>> >with various platform-specific IDEs, unusual platforms (android,
>> >embedded, ...), etc.  That said, scons is also a strong contender,
>and
>> >which of the two is more open to integrating patches and working
>with
>> >new languages is very much worth considering.
>> >
>> >I think Rust will be contributing to the wider community by lending
>its
>> >
>> >support (and patches) to a common, modern build system, AND it will
>get
>> >
>> >something back in terms of users who already know the build system.
>> >
>> >
>> >>     On Friday, January 10, 2014, George Makrydakis wrote:
>> >>
>> >>
>> >>         Hello,
>> >>
>> >>         Having a build system entirely dependent of Rust alone,
>would
>> >>         make the entire experience in deploying the language
>> >extremely
>> >>         cohere. The only counter - argument is indeed that it
>would
>> >>         require some work to get this to fruition. I would like to
>> >>         know if this has any chance of getting priority soon
>enough.
>> >>
>> >
>> >Bear in mind that Debian are having a lot of issues packaging Rust
>> >already, because it self-compiles.  If the build tool also had a
>Rust
>> >pre-dependency, that would be a big step backwards.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/46f3b005/attachment.html>

From steve at steveklabnik.com  Mon Jan 13 09:08:02 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Mon, 13 Jan 2014 11:08:02 -0600
Subject: [rust-dev] RFC: "A 30 minute introduction to Rust"
Message-ID: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>

Also posted to my blog:
http://words.steveklabnik.com/a-30-minute-introduction-to-rust

I've just kept this in Markdown even though the email is in plain
text, should still be easy on the eyes.

I recently gave a [proposal for Rust's
documentation](https://air.mozilla.org/rust-meetup-december-2013/). An
important component of my overall proposal is a short, simple
introduction for people who may have heard of Rust, so that they can
figure out if Rust is right for them. The other day, I saw [this
excellent presentation](http://www.youtube.com/watch?v=gfCtbGiHcg0),
and thought it might serve as a great basis for this introduction.
Consider this an RFC for such an introduction. Feedback very welcome.
If you all like it, I'll submit it to our documentation.

---------------------------------------------------------------------

Rust is a systems programming language that focuses on strong
compile-time correctness guarantees. It improves upon the ideas other
systems languages like C++, D, and Cyclone by providing very strong
guarantees and explicit control over the life cycle of memory. Strong
memory guarantees make writing correct concurrent Rust code easier
than in other languages. This might sound very complex, but it's
easier than it sounds! This tutorial will give you an idea of what
Rust is like in about thirty minutes. It expects that you're at least
vaguely familiar with a previous 'curly brace' language. The concepts
are more important than the syntax, so don't worry if you don't get
every last detail: the
[tutorial](http://static.rust-lang.org/doc/master/tutorial.html) can
help you out with that later.

Let's talk about the most important concept in Rust, "ownership," and
its implications on a task that programmers usually find very
difficult: concurrency.

## Ownership

Ownership is central to Rust, and is one of its more interesting and
unique features. "Ownership" refers to which parts of your code are
allowed to modify various parts of memory. Let's start by looking at
some C++ code:

```
int *dangling(void)
{
    int i = 1234;
    return &i;
}

int add_one(void)
{
    int *num = dangling();
    return *num + 1;
}
```

This function allocates an integer on the stack, and stores it in a
variable, `i`. It then returns a reference to the variable `i`.
There's just one problem: stack memory becomes invalid when the
function returns. This means that in the second line of `add_one`,
`num` points to some garbage values, and we won't get the effect that
we want. While this is a trivial example, it can happen quite often in
C++ code. There's a similar problem when memory on the heap is
allocated with `malloc` (or `new`), then freed with `free` (or
`delete`), yet your code attempts to do something with the pointer to
that memory. More modern C++ uses RAII with constructors/destructors,
but it amounts to the same thing. This problem is called a 'dangling
pointer,' and it's not possible to write Rust code that has it. Let's
try:

```
fn dangling() -> &int {
    let i = 1234;
    return &i;
}

fn add_one() -> int {
    let num = dangling();
    return *num + 1;
}
```

When you try to compile this program, you'll get an interesting (and
long) error message:

```
temp.rs:3:11: 3:13 error: borrowed value does not live long enough
temp.rs:3     return &i;

temp.rs:1:22: 4:1 note: borrowed pointer must be valid for the
anonymous lifetime #1 defined on the block at 1:22...
temp.rs:1 fn dangling() -> &int {
temp.rs:2     let i = 1234;
temp.rs:3     return &i;
temp.rs:4 }

temp.rs:1:22: 4:1 note: ...but borrowed value is only valid for the
block at 1:22
temp.rs:1 fn dangling() -> &int {
temp.rs:2     let i = 1234;
temp.rs:3     return &i;
temp.rs:4  }
error: aborting due to previous error
```

In order to fully understand this error message, we need to talk about
what it means to "own" something. So for now, let's just accept that
Rust will not allow us to write code with a dangling pointer, and
we'll come back to this code once we understand ownership.

Let's forget about programming for a second and talk about books. I
like to read physical books, and sometimes I really like one and tell
my friends they should read it. While I'm reading my book, I own it:
the book is in my possession. When I loan the book out to someone else
for a while, they "borrow" it from me. And when you borrow a book,
it's for a certain period of time, and then you give it back to me,
and I own it again. Right?

This concept applies directly to Rust code as well: some code "owns" a
particular pointer to memory. It's the sole owner of that pointer. It
can also lend that memory out to some other code for a while: the code
"borrows" it. It borrows it for a certain period of time, called a
"lifetime."

That's all there is to it. That doesn't seem so hard, right? Let's go
back to that error message: `error: borrowed value does not live long
enough`. We tried to loan out a particular variable, `i`, using Rust's
borrowed pointers: the `&`. But Rust knew that the variable would be
invalid after the function returns, and so it tells us that: `borrowed
pointer must be valid for the anonymous lifetime #1... but borrowed
value is only valid for the block`. Neat!

That's a great example for stack memory, but what about heap memory?
Rust has a second kind of pointer, a 'unique' pointer, that you can
create with a `~`. Check it out:

```
fn dangling() -> ~int {
    let i = ~1234;
    return i;
}

fn add_one() -> int {
    let num = dangling();
    return *num + 1;
}
```

This code will successfully compile. Note that instead of a stack
allocated `1234`, we use an owned pointer to that value instead:
`~1234`. You can roughly compare these two lines:

```
// rust
let i = ~1234;

// C++
int *i = new int;
*i = 1234;
```

Rust is able to infer the size of the type, then allocates the correct
amount of memory and sets it to the value you asked for. This means
that it's impossible to allocate uninitialized memory: Rust does not
have the concept of null. Hooray! There's one other difference between
this line of Rust and the C++: The Rust compiler also figures out the
lifetime of `i`, and then inserts a corresponding `free` call after
it's invalid, like a destructor in C++. You get all of the benefits of
manually allocated heap memory without having to do all the
bookkeeping yourself. Furthermore, all of this checking is done at
compile time, so there's no runtime overhead. You'll get (basically)
the exact same code that you'd get if you wrote the correct C++, but
it's impossible to write the incorrect version, thanks to the
compiler.

You've seen one way that ownership and lifetimes are useful to prevent
code that would normally be dangerous in a less-strict language, but
let's talk about another: concurrency.

## Concurrency

Concurrency is an incredibly hot topic in the software world right
now. It's always been an interesting area of study for computer
scientists, but as usage of the Internet explodes, people are looking
to improve the number of users a given service can handle. Concurrency
is one way of achieving this goal. There is a pretty big drawback to
concurrent code, though: it can be hard to reason about, because it is
non-deterministic. There are a few different approaches to writing
good concurrent code, but let's talk about how Rust's notions of
ownership and lifetimes can assist with achieving correct but
concurrent code.

First, let's go over a simple concurrency example in Rust. Rust allows
you to spin up 'tasks,' which are lightweight, 'green' threads. These
tasks do not have any shared memory, and so, we communicate between
tasks with a 'channel'. Like this:

```
fn main() {
    let numbers = [1,2,3];

    let (port, chan)  = Chan::new();
    chan.send(numbers);

    do spawn {
        let numbers = port.recv();
        println!("{:d}", numbers[0]);
    }
}
```

In this example, we create a vector of numbers. We then make a new
`Chan`, which is the name of the package Rust implements channels
with. This returns two different ends of the channel: a channel and a
port. You send data into the channel end, and it comes out the port
end. The `spawn` function spins up a new task. As you can see in the
code, we call `port.recv()` (short for 'receive') inside of the new
task, and we call `chan.send()` outside, passing in our vector. We
then print the first element of the vector.

This works out because Rust copies the vector when it is sent through
the channel. That way, if it were mutable, there wouldn't be a race
condition. However, if we're making a lot of tasks, or if our data is
very large, making a copy for each task inflates our memory usage with
no real benefit.

Enter Arc. Arc stands for 'atomically reference counted,' and it's a
way to share immutable data between multiple tasks. Here's some code:

```
extern mod extra;
use extra::arc::Arc;

fn main() {
    let numbers = [1,2,3];

    let numbers_arc = Arc::new(numbers);

    for num in range(0, 3) {
        let (port, chan)  = Chan::new();
        chan.send(numbers_arc.clone());

        do spawn {
            let local_arc = port.recv();
            let task_numbers = local_arc.get();
            println!("{:d}", task_numbers[num]);
        }
    }
}
```

This is very similar to the code we had before, except now we loop
three times, making three tasks, and sending an `Arc` between them.
`Arc::new` creates a new Arc, `.clone()` makes a new reference to that
Arc, and `.get()` gets the value out of the Arc. So we make a new
reference for each task, send that reference down the channel, and
then use the reference to print out a number. Now we're not copying
our vector.

Arcs are great for immutable data, but what about mutable data? Shared
mutable state is the bane of the concurrent programmer. You can use a
mutex to protect shared mutable state, but if you forget to acquire
the mutex, bad things can happen.

Rust provides a tool for shared mutable state: `RWArc`. This variant
of an Arc allows the contents of the Arc to be mutated. Check it out:

```
extern mod extra;
use extra::arc::RWArc;

fn main() {
    let numbers = [1,2,3];

    let numbers_arc = RWArc::new(numbers);

    for num in range(0, 3) {
        let (port, chan)  = Chan::new();
        chan.send(numbers_arc.clone());

        do spawn {
            let local_arc = port.recv();

            local_arc.write(|nums| {
                nums[num] += 1
            });

            local_arc.read(|nums| {
                println!("{:d}", nums[num]);
            })
        }
    }
}
```

We now use the `RWArc` package to get a read/write Arc. The read/write
Arc has a slightly different API than `Arc`: `read` and `write` allow
you to, well, read and write the data. They both take closures as
arguments, and the read/write Arc will, in the case of write, acquire
a mutex, and then pass the data to this closure. After the closure
does its thing, the mutex is released.

You can see how this makes it impossible to mutate the state without
remembering to aquire the lock. We gain the efficiency of shared
mutable state, while retaining the safety of disallowing shared
mutable state.

But wait, how is that possible? We can't both allow and disallow
mutable state. What gives?

## A footnote: unsafe

So, the Rust language does not allow for shared mutable state, yet I
just showed you some code that has it. How's this possible? The
answer: `unsafe`.

You see, while the Rust compiler is very smart, and saves you from
making mistakes you might normally make, it's not an artificial
intelligence. Because we're smarter than the compiler, sometimes, we
need to over-ride this safe behavior. For this purpose, Rust has an
`unsafe` keyword. Within an `unsafe` block, Rust turns off many of its
safety checks. If something bad happens to your program, you only have
to audit what you've done inside `unsafe`, and not the entire program
itself.

If one of the major goals of Rust was safety, why allow that safety to
be turned off? Well, there are really only three main reasons to do
it: interfacing with external code, such as doing FFI into a C
library, performance (in certain cases), and to provide a safe
abstraction around operations that normally would not be safe. Our
Arcs are an example of this last purpose. We can safely hand out
multiple references to the `Arc`, because we are sure the data is
immutable, and therefore it is safe to share. We can hand out multiple
references to the `RWArc`, because we know that we've wrapped the data
in a mutex, and therefore it is safe to share. But the Rust compiler
can't know that we've made these choices, so _inside_ the
implementation of the Arcs, we use `unsafe` blocks to do (normally)
dangerous things. But we expose a safe interface, which means that the
Arcs are impossible to use incorrectly.

This is how Rust's type system allows you to not make some of the
mistakes that make concurrent programming difficult, yet get the
efficiency of languages such as C++.

## That's all, folks

I hope that this taste of Rust has given you an idea if Rust is the
right language for you. If that's true, I encourage you to check out
[the tutorial](http://rust-lang.org//doc/tutorial.html) for a full,
in-depth exploration of Rust's syntax and concepts.

From troplin at bluewin.ch  Mon Jan 13 09:18:17 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Mon, 13 Jan 2014 17:18:17 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
Message-ID: <1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>

Daniel Micay <danielmicay at gmail.com> wrote:
> On Sun, Jan 12, 2014 at 1:23 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
>> Isaac Dupree
>> <ml at isaac.cedarswampstudios.org> wrote:
>>> In general, Rust is a systems language, so fixed-size integral types are
>>> important to have.  They are better-behaved than in C and C++ in that
>>> signed types are modulo, not undefined behaviour, on overflow.  It could
>>> be nice to have integral types that are task-failure on overflow as an
>>> option too.  As you note, bignum integers are important too; it's good
>>> they're available.  I think bignum rationals would be a fine additional
>>> choice to have (Haskell and GMP offer them, for example).
>> 
>> Wrapping overflow is just as bad as undefined behavior IMO.
> 
> Do you know what undefined behavior is? It doesn't mean unspecified.

True, but despite beeing so often cited it won't format your hard disk
(even in C).
The result of an integer addition will always be an integer in every
compiler I know so in this specific case I don't fear the UB.

>> I cannot remember a single case of using signed integers where wrapping
>> would make any sense.
> 
> It often makes sense in codecs, hashing algorithms and cryptography.

I'm sure there exist many cases where _unsigned_ int overflow makes sense.
For _signed_ integers I'm a bit sceptical but I am no expert in that field.

In any case it should not be the default but rather 'opt-in'. 

But this is not what I meant. Let me rephrase it differently:
Assume that signed int overflow is UB (like in C). That means, all actual
overflows at runtime have to be considered bugs.
Now I cannot imagine any such case (bug) where guaranteed wrapping would
actually behave nicer.

> If you don't have clear bounds and don't want modular arithmetic, you
> need big integers.

Or proper input validation. The type defines the bounds.

>> And you lose some optimization opportunities.
> 
> It's treated as undefined because there are more optimization
> opportunities that way.

That's what I wanted to say. If you guarantee wrapping overflow you lose
those opportunities.

>> So why not take the path of the rust memory management and enforce bounds
>> statically? It would need annotations on the types, like lifetimes, but it
>> would be very rusty. Like C but safe.
> 
> Rust isn't supposed to be really hard to write. Complex dependent typing would

I'm not sure that this would be so complex. At least not more than the
lifetime system. Is simple arithmetics on the bounds.

In reality (rust beeing a systems PL) fixed width ints _will_ be used, and
I am sure that overflow will often just be neglected. So why not enforce it
statically?

Tobi


From thadguidry at gmail.com  Mon Jan 13 09:30:20 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 13 Jan 2014 11:30:20 -0600
Subject: [rust-dev] Debugging (rust 0.9) in Ubuntu via GDB
In-Reply-To: <52D3D38F.4000104@proinbox.com>
References: <CAARHtnQacFsFGDnf_5cWB8U_C+LWmzVmMdWRjF+gft3WPRtNMw@mail.gmail.com>
	<52D398FD.7070408@posteo.de> <52D3D38F.4000104@proinbox.com>
Message-ID: <CAChbWaNY1OWz5m6sMkJXjHhj4eyq_JPnw+7TpWBtYt33O9czHw@mail.gmail.com>

Eclipse also has a GDB plugin to assist with debugging.

http://wiki.eclipse.org/Linux_Tools_Project/GDB/User_Guide


On Mon, Jan 13, 2014 at 5:52 AM, John Mija <jon.mb at proinbox.com> wrote:

> There is a web front-end for gdb to debug applications in Go, C and C++.
> I'm supposed that it also could be used to debug Rust apps.
>
> https://github.com/sirnewton01/godbg
>
> El 13/01/14 07:42, Michael Woerister escribi?:
>
>> Hi,
>> the `break` command can be a bit particular where function names are
>> concerned, especially when namespaces and generics are involved. The
>> correct full name of the shuffle method would be something like
>> `std::rand::TaskRng::shuffle<int>` (there is a seperate function for
>> every set of concrete type parameters, so `shuffle<int>` would be
>> different from `shuffle<f32>`).
>>
>> My recommendation here is to either
>> * set the breakpoint using line numbers: break prog.rs:7
>> * or use the `rbreak` command which takes a regular expression as
>> argument, that is, `rbreak shuffle` will match any function containing
>> the string "shuffle" in its name.
>>
>> Don't be shy to ask further questions if you have any :)
>>
>> -Michael
>>
>> On 13.01.2014 00:13, Artella Coding wrote:
>>
>>> Suppose I have the following program :
>>>
>>> **********************************************
>>> //prog1.rs <http://prog1.rs>
>>>
>>> use std::rand::{task_rng, Rng};
>>> fn main() {
>>>     let names = ["Alice", "Bob", "Carol"];
>>>     for name in names.iter() {
>>>         let v = task_rng().shuffle(~[1,2,3]);
>>>         for num in v.iter() {
>>>             println!("{:s} says: {:d}", *name, *num);
>>>         }
>>>     }
>>> }
>>> **********************************************
>>>
>>> In previous versions of rust it was possible to put
>>> a breakpoint on "shuffle"  e.g.
>>>
>>> One would first compile via :
>>>
>>> rustc -Z debug-info prog1.rs <http://prog1.rs>
>>>
>>>
>>> and then one could proceed to put a breakpoint on "shuffle" :
>>>
>>> gdb ./prog1
>>> (gdb) break shuffle
>>> (gdb) run
>>>
>>> However now it doesn't seem possible to put a breakpoint on shuffle.
>>> Why is this? Thanks.
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/23111306/attachment.html>

From thadguidry at gmail.com  Mon Jan 13 09:55:00 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 13 Jan 2014 11:55:00 -0600
Subject: [rust-dev] RFC: "A 30 minute introduction to Rust"
In-Reply-To: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>
References: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>
Message-ID: <CAChbWaO4_btdDo=St-sf8hMFtCA=fDedhw0vEjDCxCkLt8VGbA@mail.gmail.com>

I think Mozilla just found their new hire for documentation writing !

Excellent Steve !

That's the kind of story and style that makes learning actually fun for
folks;   By giving good examples and analogies to foreign concepts along
the way (books).

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/4ec25857/attachment.html>

From steve at steveklabnik.com  Mon Jan 13 10:30:20 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Mon, 13 Jan 2014 12:30:20 -0600
Subject: [rust-dev] RFC: "A 30 minute introduction to Rust"
In-Reply-To: <CAChbWaO4_btdDo=St-sf8hMFtCA=fDedhw0vEjDCxCkLt8VGbA@mail.gmail.com>
References: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>
	<CAChbWaO4_btdDo=St-sf8hMFtCA=fDedhw0vEjDCxCkLt8VGbA@mail.gmail.com>
Message-ID: <CABL+ZB4EtL_cN-C3_8e6C+oOfs3c1JAiQhsLvA+spusf-VaQLw@mail.gmail.com>

> By giving good examples and analogies to foreign concepts along the way (books).

To be clear, that was in the source presentation, it was not my invention.

From carter.schonwald at gmail.com  Mon Jan 13 10:40:53 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Mon, 13 Jan 2014 13:40:53 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
Message-ID: <CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>

enforce what statically?  There is  a very really very subtle tradeoff in
how powerful a static verification scheme can be vs how easily it can be
used (the sweet spot being somewhere in between nothing  and complete proof
based verification).

It sounds like there are valid arguments for several different error
semantics for fixed size numbers, and those should perhaps be different
builtin types. Everyone is right about the tradeoffs for their own needs,
and choosing one semantics over another in that context is a mixed bag /
iffy proposition. Tradeoffs are real, the best a language can do is make it
easy to choose the right tradeoffs for you!

-Carter


On Mon, Jan 13, 2014 at 12:18 PM, Tobias M?ller <troplin at bluewin.ch> wrote:

> Daniel Micay <danielmicay at gmail.com> wrote:
> > On Sun, Jan 12, 2014 at 1:23 PM, Tobias M?ller <troplin at bluewin.ch>
> wrote:
> >> Isaac Dupree
> >> <ml at isaac.cedarswampstudios.org> wrote:
> >>> In general, Rust is a systems language, so fixed-size integral types
> are
> >>> important to have.  They are better-behaved than in C and C++ in that
> >>> signed types are modulo, not undefined behaviour, on overflow.  It
> could
> >>> be nice to have integral types that are task-failure on overflow as an
> >>> option too.  As you note, bignum integers are important too; it's good
> >>> they're available.  I think bignum rationals would be a fine additional
> >>> choice to have (Haskell and GMP offer them, for example).
> >>
> >> Wrapping overflow is just as bad as undefined behavior IMO.
> >
> > Do you know what undefined behavior is? It doesn't mean unspecified.
>
> True, but despite beeing so often cited it won't format your hard disk
> (even in C).
> The result of an integer addition will always be an integer in every
> compiler I know so in this specific case I don't fear the UB.
>
> >> I cannot remember a single case of using signed integers where wrapping
> >> would make any sense.
> >
> > It often makes sense in codecs, hashing algorithms and cryptography.
>
> I'm sure there exist many cases where _unsigned_ int overflow makes sense.
> For _signed_ integers I'm a bit sceptical but I am no expert in that field.
>
> In any case it should not be the default but rather 'opt-in'.
>
> But this is not what I meant. Let me rephrase it differently:
> Assume that signed int overflow is UB (like in C). That means, all actual
> overflows at runtime have to be considered bugs.
> Now I cannot imagine any such case (bug) where guaranteed wrapping would
> actually behave nicer.
>
> > If you don't have clear bounds and don't want modular arithmetic, you
> > need big integers.
>
> Or proper input validation. The type defines the bounds.
>
> >> And you lose some optimization opportunities.
> >
> > It's treated as undefined because there are more optimization
> > opportunities that way.
>
> That's what I wanted to say. If you guarantee wrapping overflow you lose
> those opportunities.
>
> >> So why not take the path of the rust memory management and enforce
> bounds
> >> statically? It would need annotations on the types, like lifetimes, but
> it
> >> would be very rusty. Like C but safe.
> >
> > Rust isn't supposed to be really hard to write. Complex dependent typing
> would
>
> I'm not sure that this would be so complex. At least not more than the
> lifetime system. Is simple arithmetics on the bounds.
>
> In reality (rust beeing a systems PL) fixed width ints _will_ be used, and
> I am sure that overflow will often just be neglected. So why not enforce it
> statically?
>
> Tobi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/effd5cb3/attachment-0001.html>

From bascule at gmail.com  Mon Jan 13 10:46:31 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Mon, 13 Jan 2014 10:46:31 -0800
Subject: [rust-dev] Call for central external packages repository
In-Reply-To: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
References: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
Message-ID: <CAHOTMVLx3sET9C-EY=jVpS+HgP1mfoWPeFZ3T4RKAyO3=GjiOw@mail.gmail.com>

On Mon, Jan 13, 2014 at 2:43 AM, Gaetan <gaetan at xeberon.net> wrote:

> I know this question has been debated, however I'd like to highly
> recommend to give a clean infrastructure to register, list, search and
> describe external libraries developed by everyone.
>

If there's interest in this, I'd highly encourage taking a look at The
Update Framework as a way to build *secure* software update systems:

https://github.com/theupdateframework/tuf

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/a670d209/attachment.html>

From banderson at mozilla.com  Mon Jan 13 11:36:20 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 13 Jan 2014 11:36:20 -0800
Subject: [rust-dev] RFC: "A 30 minute introduction to Rust"
In-Reply-To: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>
References: <CABL+ZB46_PjF=fp-Y8BZeQ2gtpDKfGqiKbe-YW0PP_Ttyka0MA@mail.gmail.com>
Message-ID: <52D44034.9090008@mozilla.com>

This is awesome, and with some refinement this may be what we want to 
make the official introductory documentation. I left some feedback on HN.

On 01/13/2014 09:08 AM, Steve Klabnik wrote:
> Also posted to my blog:
> http://words.steveklabnik.com/a-30-minute-introduction-to-rust
>
> I've just kept this in Markdown even though the email is in plain
> text, should still be easy on the eyes.
>
> I recently gave a [proposal for Rust's
> documentation](https://air.mozilla.org/rust-meetup-december-2013/). An
> important component of my overall proposal is a short, simple
> introduction for people who may have heard of Rust, so that they can
> figure out if Rust is right for them. The other day, I saw [this
> excellent presentation](http://www.youtube.com/watch?v=gfCtbGiHcg0),
> and thought it might serve as a great basis for this introduction.
> Consider this an RFC for such an introduction. Feedback very welcome.
> If you all like it, I'll submit it to our documentation.
>
> ---------------------------------------------------------------------
>
> Rust is a systems programming language that focuses on strong
> compile-time correctness guarantees. It improves upon the ideas other
> systems languages like C++, D, and Cyclone by providing very strong
> guarantees and explicit control over the life cycle of memory. Strong
> memory guarantees make writing correct concurrent Rust code easier
> than in other languages. This might sound very complex, but it's
> easier than it sounds! This tutorial will give you an idea of what
> Rust is like in about thirty minutes. It expects that you're at least
> vaguely familiar with a previous 'curly brace' language. The concepts
> are more important than the syntax, so don't worry if you don't get
> every last detail: the
> [tutorial](http://static.rust-lang.org/doc/master/tutorial.html) can
> help you out with that later.
>
> Let's talk about the most important concept in Rust, "ownership," and
> its implications on a task that programmers usually find very
> difficult: concurrency.
>
> ## Ownership
>
> Ownership is central to Rust, and is one of its more interesting and
> unique features. "Ownership" refers to which parts of your code are
> allowed to modify various parts of memory. Let's start by looking at
> some C++ code:
>
> ```
> int *dangling(void)
> {
>      int i = 1234;
>      return &i;
> }
>
> int add_one(void)
> {
>      int *num = dangling();
>      return *num + 1;
> }
> ```
>
> This function allocates an integer on the stack, and stores it in a
> variable, `i`. It then returns a reference to the variable `i`.
> There's just one problem: stack memory becomes invalid when the
> function returns. This means that in the second line of `add_one`,
> `num` points to some garbage values, and we won't get the effect that
> we want. While this is a trivial example, it can happen quite often in
> C++ code. There's a similar problem when memory on the heap is
> allocated with `malloc` (or `new`), then freed with `free` (or
> `delete`), yet your code attempts to do something with the pointer to
> that memory. More modern C++ uses RAII with constructors/destructors,
> but it amounts to the same thing. This problem is called a 'dangling
> pointer,' and it's not possible to write Rust code that has it. Let's
> try:
>
> ```
> fn dangling() -> &int {
>      let i = 1234;
>      return &i;
> }
>
> fn add_one() -> int {
>      let num = dangling();
>      return *num + 1;
> }
> ```
>
> When you try to compile this program, you'll get an interesting (and
> long) error message:
>
> ```
> temp.rs:3:11: 3:13 error: borrowed value does not live long enough
> temp.rs:3     return &i;
>
> temp.rs:1:22: 4:1 note: borrowed pointer must be valid for the
> anonymous lifetime #1 defined on the block at 1:22...
> temp.rs:1 fn dangling() -> &int {
> temp.rs:2     let i = 1234;
> temp.rs:3     return &i;
> temp.rs:4 }
>
> temp.rs:1:22: 4:1 note: ...but borrowed value is only valid for the
> block at 1:22
> temp.rs:1 fn dangling() -> &int {
> temp.rs:2     let i = 1234;
> temp.rs:3     return &i;
> temp.rs:4  }
> error: aborting due to previous error
> ```
>
> In order to fully understand this error message, we need to talk about
> what it means to "own" something. So for now, let's just accept that
> Rust will not allow us to write code with a dangling pointer, and
> we'll come back to this code once we understand ownership.
>
> Let's forget about programming for a second and talk about books. I
> like to read physical books, and sometimes I really like one and tell
> my friends they should read it. While I'm reading my book, I own it:
> the book is in my possession. When I loan the book out to someone else
> for a while, they "borrow" it from me. And when you borrow a book,
> it's for a certain period of time, and then you give it back to me,
> and I own it again. Right?
>
> This concept applies directly to Rust code as well: some code "owns" a
> particular pointer to memory. It's the sole owner of that pointer. It
> can also lend that memory out to some other code for a while: the code
> "borrows" it. It borrows it for a certain period of time, called a
> "lifetime."
>
> That's all there is to it. That doesn't seem so hard, right? Let's go
> back to that error message: `error: borrowed value does not live long
> enough`. We tried to loan out a particular variable, `i`, using Rust's
> borrowed pointers: the `&`. But Rust knew that the variable would be
> invalid after the function returns, and so it tells us that: `borrowed
> pointer must be valid for the anonymous lifetime #1... but borrowed
> value is only valid for the block`. Neat!
>
> That's a great example for stack memory, but what about heap memory?
> Rust has a second kind of pointer, a 'unique' pointer, that you can
> create with a `~`. Check it out:
>
> ```
> fn dangling() -> ~int {
>      let i = ~1234;
>      return i;
> }
>
> fn add_one() -> int {
>      let num = dangling();
>      return *num + 1;
> }
> ```
>
> This code will successfully compile. Note that instead of a stack
> allocated `1234`, we use an owned pointer to that value instead:
> `~1234`. You can roughly compare these two lines:
>
> ```
> // rust
> let i = ~1234;
>
> // C++
> int *i = new int;
> *i = 1234;
> ```
>
> Rust is able to infer the size of the type, then allocates the correct
> amount of memory and sets it to the value you asked for. This means
> that it's impossible to allocate uninitialized memory: Rust does not
> have the concept of null. Hooray! There's one other difference between
> this line of Rust and the C++: The Rust compiler also figures out the
> lifetime of `i`, and then inserts a corresponding `free` call after
> it's invalid, like a destructor in C++. You get all of the benefits of
> manually allocated heap memory without having to do all the
> bookkeeping yourself. Furthermore, all of this checking is done at
> compile time, so there's no runtime overhead. You'll get (basically)
> the exact same code that you'd get if you wrote the correct C++, but
> it's impossible to write the incorrect version, thanks to the
> compiler.
>
> You've seen one way that ownership and lifetimes are useful to prevent
> code that would normally be dangerous in a less-strict language, but
> let's talk about another: concurrency.
>
> ## Concurrency
>
> Concurrency is an incredibly hot topic in the software world right
> now. It's always been an interesting area of study for computer
> scientists, but as usage of the Internet explodes, people are looking
> to improve the number of users a given service can handle. Concurrency
> is one way of achieving this goal. There is a pretty big drawback to
> concurrent code, though: it can be hard to reason about, because it is
> non-deterministic. There are a few different approaches to writing
> good concurrent code, but let's talk about how Rust's notions of
> ownership and lifetimes can assist with achieving correct but
> concurrent code.
>
> First, let's go over a simple concurrency example in Rust. Rust allows
> you to spin up 'tasks,' which are lightweight, 'green' threads. These
> tasks do not have any shared memory, and so, we communicate between
> tasks with a 'channel'. Like this:
>
> ```
> fn main() {
>      let numbers = [1,2,3];
>
>      let (port, chan)  = Chan::new();
>      chan.send(numbers);
>
>      do spawn {
>          let numbers = port.recv();
>          println!("{:d}", numbers[0]);
>      }
> }
> ```
>
> In this example, we create a vector of numbers. We then make a new
> `Chan`, which is the name of the package Rust implements channels
> with. This returns two different ends of the channel: a channel and a
> port. You send data into the channel end, and it comes out the port
> end. The `spawn` function spins up a new task. As you can see in the
> code, we call `port.recv()` (short for 'receive') inside of the new
> task, and we call `chan.send()` outside, passing in our vector. We
> then print the first element of the vector.
>
> This works out because Rust copies the vector when it is sent through
> the channel. That way, if it were mutable, there wouldn't be a race
> condition. However, if we're making a lot of tasks, or if our data is
> very large, making a copy for each task inflates our memory usage with
> no real benefit.
>
> Enter Arc. Arc stands for 'atomically reference counted,' and it's a
> way to share immutable data between multiple tasks. Here's some code:
>
> ```
> extern mod extra;
> use extra::arc::Arc;
>
> fn main() {
>      let numbers = [1,2,3];
>
>      let numbers_arc = Arc::new(numbers);
>
>      for num in range(0, 3) {
>          let (port, chan)  = Chan::new();
>          chan.send(numbers_arc.clone());
>
>          do spawn {
>              let local_arc = port.recv();
>              let task_numbers = local_arc.get();
>              println!("{:d}", task_numbers[num]);
>          }
>      }
> }
> ```
>
> This is very similar to the code we had before, except now we loop
> three times, making three tasks, and sending an `Arc` between them.
> `Arc::new` creates a new Arc, `.clone()` makes a new reference to that
> Arc, and `.get()` gets the value out of the Arc. So we make a new
> reference for each task, send that reference down the channel, and
> then use the reference to print out a number. Now we're not copying
> our vector.
>
> Arcs are great for immutable data, but what about mutable data? Shared
> mutable state is the bane of the concurrent programmer. You can use a
> mutex to protect shared mutable state, but if you forget to acquire
> the mutex, bad things can happen.
>
> Rust provides a tool for shared mutable state: `RWArc`. This variant
> of an Arc allows the contents of the Arc to be mutated. Check it out:
>
> ```
> extern mod extra;
> use extra::arc::RWArc;
>
> fn main() {
>      let numbers = [1,2,3];
>
>      let numbers_arc = RWArc::new(numbers);
>
>      for num in range(0, 3) {
>          let (port, chan)  = Chan::new();
>          chan.send(numbers_arc.clone());
>
>          do spawn {
>              let local_arc = port.recv();
>
>              local_arc.write(|nums| {
>                  nums[num] += 1
>              });
>
>              local_arc.read(|nums| {
>                  println!("{:d}", nums[num]);
>              })
>          }
>      }
> }
> ```
>
> We now use the `RWArc` package to get a read/write Arc. The read/write
> Arc has a slightly different API than `Arc`: `read` and `write` allow
> you to, well, read and write the data. They both take closures as
> arguments, and the read/write Arc will, in the case of write, acquire
> a mutex, and then pass the data to this closure. After the closure
> does its thing, the mutex is released.
>
> You can see how this makes it impossible to mutate the state without
> remembering to aquire the lock. We gain the efficiency of shared
> mutable state, while retaining the safety of disallowing shared
> mutable state.
>
> But wait, how is that possible? We can't both allow and disallow
> mutable state. What gives?
>
> ## A footnote: unsafe
>
> So, the Rust language does not allow for shared mutable state, yet I
> just showed you some code that has it. How's this possible? The
> answer: `unsafe`.
>
> You see, while the Rust compiler is very smart, and saves you from
> making mistakes you might normally make, it's not an artificial
> intelligence. Because we're smarter than the compiler, sometimes, we
> need to over-ride this safe behavior. For this purpose, Rust has an
> `unsafe` keyword. Within an `unsafe` block, Rust turns off many of its
> safety checks. If something bad happens to your program, you only have
> to audit what you've done inside `unsafe`, and not the entire program
> itself.
>
> If one of the major goals of Rust was safety, why allow that safety to
> be turned off? Well, there are really only three main reasons to do
> it: interfacing with external code, such as doing FFI into a C
> library, performance (in certain cases), and to provide a safe
> abstraction around operations that normally would not be safe. Our
> Arcs are an example of this last purpose. We can safely hand out
> multiple references to the `Arc`, because we are sure the data is
> immutable, and therefore it is safe to share. We can hand out multiple
> references to the `RWArc`, because we know that we've wrapped the data
> in a mutex, and therefore it is safe to share. But the Rust compiler
> can't know that we've made these choices, so _inside_ the
> implementation of the Arcs, we use `unsafe` blocks to do (normally)
> dangerous things. But we expose a safe interface, which means that the
> Arcs are impossible to use incorrectly.
>
> This is how Rust's type system allows you to not make some of the
> mistakes that make concurrent programming difficult, yet get the
> efficiency of languages such as C++.
>
> ## That's all, folks
>
> I hope that this taste of Rust has given you an idea if Rust is the
> right language for you. If that's true, I encourage you to check out
> [the tutorial](http://rust-lang.org//doc/tutorial.html) for a full,
> in-depth exploration of Rust's syntax and concepts.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From troplin at bluewin.ch  Mon Jan 13 13:06:40 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Mon, 13 Jan 2014 21:06:40 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
Message-ID: <1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>

Carter Schonwald <carter.schonwald at gmail.com>
wrote:
> enforce what statically?  There is  a very really very subtle tradeoff in
> how powerful a static verification scheme can be vs how easily it can be
> used (the sweet spot being somewhere in between nothing  and complete
> proof based verification).

Enforce that integer overflow never happens.

Roughly, I was thinking of the following:

Every int variable/parameter/binding has an associated range (lower and
upper bound):
int<l,u>
If no bound is specified, the min and max values of the type are used.

Every operation on ints specify the range of the result using the range of
the operands:

int<l1,u1> + int<l2,u2> = int<l1+l2,u1+u2>
...

If the result does not fit into an int the compiler throws an error.
To resolve an error, you can:
- annotate the operands with appropriate bounds
- use a bigger type for the operation and check the result.

To go from a bigger to a smaller range you use:
let x : int
match x {
   int<0,255> => ...
   _ => fail()
}

Sorry for the sketchy syntax, I'm just following this list but have never
actually used rust.

> It sounds like there are valid arguments for several different error
> semantics for fixed size numbers, and those should perhaps be different
> builtin types. Everyone is right about the tradeoffs for their own needs,
> and choosing one semantics over another in that context is a mixed bag /
> iffy proposition. Tradeoffs are real, the best a language can do is make
> it easy to choose the right tradeoffs for you!

But also different languages choose different tradeoffs and rust aims to be
a systems PL.

By banning the fastest int version from the language by making overflow
wrapping or failing at runtime, you actually limit the choice already. 

Tobi


From carter.schonwald at gmail.com  Mon Jan 13 13:25:12 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Mon, 13 Jan 2014 16:25:12 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
	<1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
Message-ID: <CAHYVw0yZRwy+4Tngv00ZFLHgDAmgFy57=J-_-ieuYMgg5XhrXg@mail.gmail.com>

indeed, hence why i was saying there should be sized int variants for each
of those semantics (wrapping, trapping, overflowing, etc).
This is something that many people seem to favor, and is the right choice
for supporting smart engineers build reliable sophisticated software.
Namely, really spell out what each alternative means, make sure they're all
first class options, etc etc.

staticly verifying bounded ranges in a language is really subtle. You're
proposing what easily turns into a pretty tricky flow analysis (to have it
have any precision!), and it'd have to happen in type checker too...


On Mon, Jan 13, 2014 at 4:06 PM, Tobias M?ller <troplin at bluewin.ch> wrote:

> Carter Schonwald <carter.schonwald at gmail.com>
> wrote:
> > enforce what statically?  There is  a very really very subtle tradeoff in
> > how powerful a static verification scheme can be vs how easily it can be
> > used (the sweet spot being somewhere in between nothing  and complete
> > proof based verification).
>
> Enforce that integer overflow never happens.
>
> Roughly, I was thinking of the following:
>
> Every int variable/parameter/binding has an associated range (lower and
> upper bound):
> int<l,u>
> If no bound is specified, the min and max values of the type are used.
>
> Every operation on ints specify the range of the result using the range of
> the operands:
>
> int<l1,u1> + int<l2,u2> = int<l1+l2,u1+u2>
> ...
>
> If the result does not fit into an int the compiler throws an error.
> To resolve an error, you can:
> - annotate the operands with appropriate bounds
> - use a bigger type for the operation and check the result.
>
> To go from a bigger to a smaller range you use:
> let x : int
> match x {
>    int<0,255> => ...
>    _ => fail()
> }
>
> Sorry for the sketchy syntax, I'm just following this list but have never
> actually used rust.
>
> > It sounds like there are valid arguments for several different error
> > semantics for fixed size numbers, and those should perhaps be different
> > builtin types. Everyone is right about the tradeoffs for their own needs,
> > and choosing one semantics over another in that context is a mixed bag /
> > iffy proposition. Tradeoffs are real, the best a language can do is make
> > it easy to choose the right tradeoffs for you!
>
> But also different languages choose different tradeoffs and rust aims to be
> a systems PL.
>
> By banning the fastest int version from the language by making overflow
> wrapping or failing at runtime, you actually limit the choice already.
>
> Tobi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/92b08fdf/attachment.html>

From troplin at bluewin.ch  Mon Jan 13 13:52:23 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Mon, 13 Jan 2014 21:52:23 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
	<1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0yZRwy+4Tngv00ZFLHgDAmgFy57=J-_-ieuYMgg5XhrXg@mail.gmail.com>
Message-ID: <347414999411341860.389844troplin-bluewin.ch@news.gmane.org>

Carter Schonwald <carter.schonwald at gmail.com>
wrote:
> indeed, hence why i was saying there should be sized int variants for
> each of those semantics (wrapping, trapping, overflowing, etc). This is
> something that many people seem to favor, and is the right choice for
> supporting smart engineers build reliable sophisticated software. Namely,
> really spell out what each alternative means, make sure they're all first
> class options, etc etc.
> 
> staticly verifying bounded ranges in a language is really subtle. You're
> proposing what easily turns into a pretty tricky flow analysis (to have
> it have any precision!), and it'd have to happen in type checker too...

I was actually trying to avoid flow analysis. With my proposal, the range
would be "attached" to the type and cannot change over time.
That's why I was proposing a case match binding for going to a smaller
range.

Some time ago I was reading a blog post (I think it was from Patrick
Walton) about why you abandoned type state and how it can be replaced with
a less dynamic system that is easier to reason about.
In that system the dynamic type state was replaced by a more static type
parameter.
I don't want type state for integers but this 'replacement'. (I don't know
how it was called, need to read it up again)

Tobi


From danielmicay at gmail.com  Mon Jan 13 15:08:26 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 13 Jan 2014 18:08:26 -0500
Subject: [rust-dev] Impact of -ftrapv on Firefox
In-Reply-To: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>
References: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>
Message-ID: <CA+DvKQKzUG+6_zb+y=_DKzeVJ=xrxA0T0kY4Ly098zkxzhcjsA@mail.gmail.com>

On Mon, Jan 13, 2014 at 6:42 AM, Robert O'Callahan <robert at ocallahan.org> wrote:
> On Mon, Jan 13, 2014 at 2:53 PM, Robert O'Callahan <robert at ocallahan.org>
> wrote:
>>
>> On Mon, Jan 13, 2014 at 2:22 PM, Daniel Micay <danielmicay at gmail.com>
>> wrote:
>>>
>>> -fsanitize=signed-integer-overflow: Signed integer overflow, including
>>> all the checks added by -ftrapv, and checking for overflow in signed
>>> division (INT_MIN / -1).
>>>
>>> Why not measure the impact of this on Firefox performance? We'll have
>>> a concrete answer about half of the picture (but not about the cost
>>> for unsigned or checks on overlong shifts and for division by zero).
>>
>>
>> That would give us neither an upper bound on overhead (due to excluding
>> unsigned), nor a lower bound (due to no range analysis or LLVM changes). But
>> it might be interesting...
>
>
> Just for fun I did a Firefox build with -ftrapv. The most surprising thing
> is that the browser actually worked, on Linux64 at least. Not so much on
> Linux32 and Mac. https://tbpl.mozilla.org/?tree=Try&rev=45b9932ca819
>
> The Talos performance results aren't exactly science, but it looks like the
> performance impact is negligible. For example, tp5o (page load time test)
> reported 285, central is around 280 (lower is better). Dromaeo-CSS reported
> 5408, whereas central is around 5500 (but noisy) (higher is better).
>
> Like I said, I don't really know what this means, but it sounds hopeful to
> me.
>
> Rob
> --
> Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni le
> atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
> stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
> 'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
> waanndt  wyeonut  thoo mken.o w

Is this with `clang`? I don't think `-ftrapv` actually works in `gcc`.

Simple test showing it doesn't work:

foo.c

```
#include <limits.h>

extern int bar;

int main(void) {
    int x = INT_MAX;
    int y = x + bar;
    return 0;
}
```

bar.c

```
int bar = 1;
```

gcc foo.c bar.c -ftrapv && ./a.out # no error
clang foo.c bar.c -ftrapv && ./a.out # zsh: illegal hardware instruction

From danielmicay at gmail.com  Mon Jan 13 15:11:53 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 13 Jan 2014 18:11:53 -0500
Subject: [rust-dev] Impact of -ftrapv on Firefox
In-Reply-To: <CA+DvKQKzUG+6_zb+y=_DKzeVJ=xrxA0T0kY4Ly098zkxzhcjsA@mail.gmail.com>
References: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>
	<CA+DvKQKzUG+6_zb+y=_DKzeVJ=xrxA0T0kY4Ly098zkxzhcjsA@mail.gmail.com>
Message-ID: <CA+DvKQL+rEWurP_UKaqyyLNj9jJzObVdxB0_j4PSOCCGJjTfjQ@mail.gmail.com>

There's also the issue that libgcc_s is missing the function LLVM will
generate for 64-bit overflow checked multiplication on most
architectures. It's there on x86_64, but on x86 you'll need a `clang`
set up to use `compiler-rt`.

It's hilarious that `gcc` is totally broken though...

From andrew.pennebaker at gmail.com  Mon Jan 13 16:48:53 2014
From: andrew.pennebaker at gmail.com (Andrew Pennebaker)
Date: Mon, 13 Jan 2014 19:48:53 -0500
Subject: [rust-dev] Is it just me,
	or do the API docs lie about getopt() in rust v0.8?
Message-ID: <CAHXt_SVLuwT2_Er7203ytUAwhNJhhDMsoJKVxD4u=L25aSC4KQ@mail.gmail.com>

I'm following tutorials and snippets to get my code to work with rust 0.8
(I'm behind, I know).

The rust docs for v0.8 say that getopt() accepts an array of OptGroup (long
options), and my code is written to use that.

http://static.rust-lang.org/doc/0.8/extra/getopts/groups/fn.getopts.html

But when I dig through the rust source code around version 0.8, this is not
the API that I find.

https://github.com/mozilla/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src/libextra/getopts.rs#L396

Am I doing something wrong?

What's the easiest way to convert an array of long options into an array of
short options for the purposes of using getopt()?

Is this discrepancy fixed in 0.9?

-- 
Cheers,

Andrew Pennebaker
www.yellosoft.us
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/01098ca2/attachment-0001.html>

From corey at octayn.net  Mon Jan 13 16:50:17 2014
From: corey at octayn.net (Corey Richardson)
Date: Mon, 13 Jan 2014 19:50:17 -0500
Subject: [rust-dev] Is it just me,
 or do the API docs lie about getopt() in rust v0.8?
In-Reply-To: <CAHXt_SVLuwT2_Er7203ytUAwhNJhhDMsoJKVxD4u=L25aSC4KQ@mail.gmail.com>
References: <CAHXt_SVLuwT2_Er7203ytUAwhNJhhDMsoJKVxD4u=L25aSC4KQ@mail.gmail.com>
Message-ID: <CA++BO6SQ6unNRYkAtEujpBAkNvvaEosmhuDhXPM_RfxfD51_EA@mail.gmail.com>

You're looking at the wrong getopts function. You're looking at
extra::getopts::getopts, but citing the documentation for
extra::getopts::groups::getopts.

On Mon, Jan 13, 2014 at 7:48 PM, Andrew Pennebaker
<andrew.pennebaker at gmail.com> wrote:
> I'm following tutorials and snippets to get my code to work with rust 0.8
> (I'm behind, I know).
>
> The rust docs for v0.8 say that getopt() accepts an array of OptGroup (long
> options), and my code is written to use that.
>
> http://static.rust-lang.org/doc/0.8/extra/getopts/groups/fn.getopts.html
>
> But when I dig through the rust source code around version 0.8, this is not
> the API that I find.
>
> https://github.com/mozilla/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src/libextra/getopts.rs#L396
>
> Am I doing something wrong?
>
> What's the easiest way to convert an array of long options into an array of
> short options for the purposes of using getopt()?
>
> Is this discrepancy fixed in 0.9?
>
> --
> Cheers,
>
> Andrew Pennebaker
> www.yellosoft.us
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From robert at ocallahan.org  Mon Jan 13 17:19:25 2014
From: robert at ocallahan.org (Robert O'Callahan)
Date: Tue, 14 Jan 2014 14:19:25 +1300
Subject: [rust-dev] Impact of -ftrapv on Firefox
In-Reply-To: <CA+DvKQL+rEWurP_UKaqyyLNj9jJzObVdxB0_j4PSOCCGJjTfjQ@mail.gmail.com>
References: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>
	<CA+DvKQKzUG+6_zb+y=_DKzeVJ=xrxA0T0kY4Ly098zkxzhcjsA@mail.gmail.com>
	<CA+DvKQL+rEWurP_UKaqyyLNj9jJzObVdxB0_j4PSOCCGJjTfjQ@mail.gmail.com>
Message-ID: <CAOp6jLYpgnJengJAxeZXt9thy_QcuTDQrYTNrpffzNmFfRCBuw@mail.gmail.com>

On Tue, Jan 14, 2014 at 12:11 PM, Daniel Micay <danielmicay at gmail.com>wrote:

> There's also the issue that libgcc_s is missing the function LLVM will
> generate for 64-bit overflow checked multiplication on most
> architectures. It's there on x86_64, but on x86 you'll need a `clang`
> set up to use `compiler-rt`.
>
> It's hilarious that `gcc` is totally broken though...
>

Thanks for catching that. My experiments indicate that -ftrapv works in gcc
for x86 but not x86-64. Which explains why the Firefox try builds only work
for x86-64. Which makes sense, since Firefox contains code that would
depend on overflow wrapping around.

So we're back to not knowing anything :-).

Rob
-- 
Jtehsauts  tshaei dS,o n" Wohfy  Mdaon  yhoaus  eanuttehrotraiitny  eovni
le atrhtohu gthot sf oirng iyvoeu rs ihnesa.r"t sS?o  Whhei csha iids  teoa
stiheer :p atroa lsyazye,d  'mYaonu,r  "sGients  uapr,e  tfaokreg iyvoeunr,
'm aotr  atnod  sgaoy ,h o'mGee.t"  uTph eann dt hwea lmka'n?  gBoutt  uIp
waanndt  wyeonut  thoo mken.o w
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/e869f777/attachment.html>

From andrew.pennebaker at gmail.com  Mon Jan 13 17:25:50 2014
From: andrew.pennebaker at gmail.com (Andrew Pennebaker)
Date: Mon, 13 Jan 2014 20:25:50 -0500
Subject: [rust-dev] Rust docs for 0.8: "No idea what this does"
Message-ID: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>

Who wrote these 0.8 docs:

http://static.rust-lang.org/doc/0.8/extra/getopts/struct.Matches.html

Fortunately, they're much improved in 0.9.

-- 
Cheers,

Andrew Pennebaker
www.yellosoft.us
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/f34f19cb/attachment.html>

From corey at octayn.net  Mon Jan 13 17:30:42 2014
From: corey at octayn.net (Corey Richardson)
Date: Mon, 13 Jan 2014 20:30:42 -0500
Subject: [rust-dev] Rust docs for 0.8: "No idea what this does"
In-Reply-To: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
References: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
Message-ID: <CA++BO6RDnx8GdjDUK1CeokE7RkYq6F06xp+xCx9r8tChq75Xbw@mail.gmail.com>

You realize you're using a 3 month old unsupported release of a
pre-alpha language, right? Anyway I don't know how those got promoted
to doc comments, they used to just be comments.

On Mon, Jan 13, 2014 at 8:25 PM, Andrew Pennebaker
<andrew.pennebaker at gmail.com> wrote:
> Who wrote these 0.8 docs:
>
> http://static.rust-lang.org/doc/0.8/extra/getopts/struct.Matches.html
>
> Fortunately, they're much improved in 0.9.
>
> --
> Cheers,
>
> Andrew Pennebaker
> www.yellosoft.us
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From banderson at mozilla.com  Mon Jan 13 17:31:47 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 13 Jan 2014 17:31:47 -0800
Subject: [rust-dev] Rust docs for 0.8: "No idea what this does"
In-Reply-To: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
References: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
Message-ID: <52D49383.3050403@mozilla.com>

After seeing the title of this email I hoped that it was me. Regardless 
there's no need to blame anyone. Somebody was nice enough to go through 
and add docs and put in a FIXME. All part of the process.

On 01/13/2014 05:25 PM, Andrew Pennebaker wrote:
> Who wrote these 0.8 docs:
>
> http://static.rust-lang.org/doc/0.8/extra/getopts/struct.Matches.html
>
> Fortunately, they're much improved in 0.9.
>
> -- 
> Cheers,
>
> Andrew Pennebaker
> www.yellosoft.us <http://www.yellosoft.us>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/3ba37b19/attachment.html>

From palmercox at gmail.com  Mon Jan 13 17:50:03 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Mon, 13 Jan 2014 20:50:03 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
Message-ID: <CAPZendyXQhn1dU074H+zq=ZDD-1N96TOSaxAFJ0CZo_4R=eF=g@mail.gmail.com>

On Mon, Jan 13, 2014 at 12:18 PM, Tobias M?ller <troplin at bluewin.ch> wrote:

> Daniel Micay <danielmicay at gmail.com> wrote:
> > On Sun, Jan 12, 2014 at 1:23 PM, Tobias M?ller <troplin at bluewin.ch>
> wrote:
> >> Isaac Dupree
> >> <ml at isaac.cedarswampstudios.org> wrote:
> >>> In general, Rust is a systems language, so fixed-size integral types
> are
> >>> important to have.  They are better-behaved than in C and C++ in that
> >>> signed types are modulo, not undefined behaviour, on overflow.  It
> could
> >>> be nice to have integral types that are task-failure on overflow as an
> >>> option too.  As you note, bignum integers are important too; it's good
> >>> they're available.  I think bignum rationals would be a fine additional
> >>> choice to have (Haskell and GMP offer them, for example).
> >>
> >> Wrapping overflow is just as bad as undefined behavior IMO.
> >
> > Do you know what undefined behavior is? It doesn't mean unspecified.
>
> True, but despite beeing so often cited it won't format your hard disk
> (even in C).
> The result of an integer addition will always be an integer in every
> compiler I know so in this specific case I don't fear the UB.


I don't think that's quite accurate. Its true that the result of undefined
behavior is unlikely to be that your harddrive is formatted. However, you
aren't guaranteed to end up with an integer in any compiler that I'm aware
of either. Its subtle, but important to remember that the instruction that
actually overflows the integer register isn't really the undefined
behavior. Its not that a program is operating in a defined mode and then
the integer overflow occurs and then the program transitions into an
undefined mode. Instead, a program that will execute an integer overflow at
some point in the future is as the mercy of undefined behavior from the
very first instruction. The compiler, knowing that you aren't allowed to
overflow an integer, uses that information to do a variety of
optimizations, including dead code elimination. Since overflowing an
integer is undefined, the compiler assumes that you won't do it and will
use that assumption to eliminate as much code as possible. So, the end
result could be that an entire branch of the program is eliminated. See
http://blog.regehr.org/archives/213 (look for "Type 3 Functions) for an
example. So, the end result of integer overflow undefined behavior might
not an actual overflow since the compiler could remove the add instruction
along with whatever else it thinks it can. This could result in a program
that works fine in debug modes, but once you crank up the optimization
level, it fails to run. Or, it could result in a program that runs fine on
a particular compiler version, but then fails mysteriously after an update.
Or, as in the example, it could result in a program that runs fine, but
silently doesn't do an important check.


> >> I cannot remember a single case of using signed integers where wrapping
> >> would make any sense.
> >
> > It often makes sense in codecs, hashing algorithms and cryptography.
>
> I'm sure there exist many cases where _unsigned_ int overflow makes sense.
> For _signed_ integers I'm a bit sceptical but I am no expert in that field.
>
> In any case it should not be the default but rather 'opt-in'.
>
> But this is not what I meant. Let me rephrase it differently:
> Assume that signed int overflow is UB (like in C). That means, all actual
> overflows at runtime have to be considered bugs.
> Now I cannot imagine any such case (bug) where guaranteed wrapping would
> actually behave nicer.
>
> > If you don't have clear bounds and don't want modular arithmetic, you
> > need big integers.
>
> Or proper input validation. The type defines the bounds.
>
> >> And you lose some optimization opportunities.
> >
> > It's treated as undefined because there are more optimization
> > opportunities that way.
>
> That's what I wanted to say. If you guarantee wrapping overflow you lose
> those opportunities.
>
> >> So why not take the path of the rust memory management and enforce
> bounds
> >> statically? It would need annotations on the types, like lifetimes, but
> it
> >> would be very rusty. Like C but safe.
> >
> > Rust isn't supposed to be really hard to write. Complex dependent typing
> would
>
> I'm not sure that this would be so complex. At least not more than the
> lifetime system. Is simple arithmetics on the bounds.
>
> In reality (rust beeing a systems PL) fixed width ints _will_ be used, and
> I am sure that overflow will often just be neglected. So why not enforce it
> statically?
>
> Tobi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/7acda4eb/attachment-0001.html>

From andrew.pennebaker at gmail.com  Mon Jan 13 18:17:48 2014
From: andrew.pennebaker at gmail.com (Andrew Pennebaker)
Date: Mon, 13 Jan 2014 21:17:48 -0500
Subject: [rust-dev] Rust docs for 0.8: "No idea what this does"
In-Reply-To: <CABL+ZB6sWOnDqXr=30wYdpsX0XvOfdp5DG2cGD7Lutu3oeQxVA@mail.gmail.com>
References: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
	<CABL+ZB6sWOnDqXr=30wYdpsX0XvOfdp5DG2cGD7Lutu3oeQxVA@mail.gmail.com>
Message-ID: <CAHXt_SVWRL5A9=Yy=dfLUeYjTubb9i2xVYtSDRqrDie2R+bi_A@mail.gmail.com>

I won't bother using git blame, it's just weird to see such comments in doc
files. If you don't know what something does, why not leave it blank?
On Jan 13, 2014 9:03 PM, "Steve Klabnik" <steve at steveklabnik.com> wrote:

> No reason to be so harsh, especially since they've been improved.
> There is a way you can find out, but I'm not telling you.
>
> I love 'these docs are poor' comments, as they help me figure out what
> needs to be improved, but there's no reason to pick something that's
> already been fixed and try to make someone feel bad.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/c0b87416/attachment.html>

From banderson at mozilla.com  Mon Jan 13 18:48:04 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 13 Jan 2014 18:48:04 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
Message-ID: <52D4A564.4090602@mozilla.com>

In light of the general consensus that unbounded channels are not so 
hot, here's a new proposal for how Rust's channels should operate. This 
is based on the following assumptions:

* Running out of memory is an awful failure mode for debugging.
* Choosing an appropriate bounded queue size is hard.
* Dealing with backpressure is hard.
* Most channels are not filled without bound.

This proposal has two facets: making the current channels appropriate 
for more use cases; adding additional channel types for specialized use 
cases. I'm still operating under the premise that there should be a 
"default" channel type that can be successfully used in most instances, 
and people should only need to pick something else when their message 
passing behavior calls for it. Not all of these recommendations are 
about resolving the unbounded channel debate.

# Changes to `Chan`

Firstly, let's combine `Chan` and `SharedChan`. This is partly to free 
up some of our complexity budget to add more channel types, and partly a 
concession to usability. A cloned channel will automatically upgrade 
itself to a multi-producer queue. This will add a small amount of 
overhead to various operations.

Secondly, in order to accommodate the very common case where a channel 
is used just once, we optimize the single-send use case to not allocate. 
Essentially, we store a single element directly in the shared state 
between the channel and port. This restores the `oneshot` functionality 
we lost in the last channel rewrite. Again, this will add a small amount 
of overhead to some operations, though possibly not above the overhead 
incurred by combining `Chan` and `SharedChan`.

Finally, my main suggestion about how to deal with OOM, let's put an 
arbitrary bound to the size of the queue on `Chan`. This isn't to say 
let's turn `Chan` into a bounded queue (which is difficult for 
implementation reasons), but instead that we add a feature that helps 
debug when you've actually chosen the wrong kind of channel because your 
producer sends without bound.

When you hit this bound the send will fail and you know that you need to 
think harder about the behavior of this particular channel. If you 
*really* want an unbounded channel then you can construct it with 
`Chan::unbounded`, otherwise you pick ...

# Synchronous and bounded channels

Let's add `SyncChan` which is a bounded multi-producer single-consumer 
queue backed by a ring buffer. This supports `send`, which blocks by 
default, and `try_send` which returns an enum representing whether the 
send succeeded, the channel is full, or the channel is closed (the last 
two cases returning the message). In the special case where the channel 
bound is 0, we don't use a ringbuffer and just do a rendezvousing send 
and recieve. The default bound is 0.

Comments?

Regards,
Brian

From jack at metajack.im  Mon Jan 13 19:25:53 2014
From: jack at metajack.im (Jack Moffitt)
Date: Mon, 13 Jan 2014 20:25:53 -0700
Subject: [rust-dev] Rust docs for 0.8: "No idea what this does"
In-Reply-To: <CAHXt_SVWRL5A9=Yy=dfLUeYjTubb9i2xVYtSDRqrDie2R+bi_A@mail.gmail.com>
References: <CAHXt_SUNuJtKjhNtKkZu2d8_S47q7i8GfrncV3uGsTMEbytuyg@mail.gmail.com>
	<CABL+ZB6sWOnDqXr=30wYdpsX0XvOfdp5DG2cGD7Lutu3oeQxVA@mail.gmail.com>
	<CAHXt_SVWRL5A9=Yy=dfLUeYjTubb9i2xVYtSDRqrDie2R+bi_A@mail.gmail.com>
Message-ID: <CAP7VpsVnZF8jrbN9V2Mf7US9gYTD6DAPaZ5wrDoZ7WvVJhhdfA@mail.gmail.com>

The explanation was already given by Corey. It was a normal comment
but mistakenly got promoted by someone to a doc comment. Perhaps it
was a search and replace gone wrong. At least it was amusing :)

jack.

On Mon, Jan 13, 2014 at 7:17 PM, Andrew Pennebaker
<andrew.pennebaker at gmail.com> wrote:
> I won't bother using git blame, it's just weird to see such comments in doc
> files. If you don't know what something does, why not leave it blank?
>
> On Jan 13, 2014 9:03 PM, "Steve Klabnik" <steve at steveklabnik.com> wrote:
>>
>> No reason to be so harsh, especially since they've been improved.
>> There is a way you can find out, but I'm not telling you.
>>
>> I love 'these docs are poor' comments, as they help me figure out what
>> needs to be improved, but there's no reason to pick something that's
>> already been fixed and try to make someone feel bad.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From olson.jeffery at gmail.com  Mon Jan 13 20:09:58 2014
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Mon, 13 Jan 2014 20:09:58 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52D4A564.4090602@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
Message-ID: <CAEXt_aZTQxM_Png6z4BKwScLr6z4Sk=5fmpdektY=cpELwSiqA@mail.gmail.com>

This is a great proposal, Brian.

I have no criticisms of the proposal itself, feeling that it's a
level-headed response to the previous threads on this issue.

But I do have a request (something I know Daniel Micay brought up in
#rust): What would it take to get shared-Port like functionality in a
similar fashion to the "upgradable" shared-Chan? I think multi-producer,
multi-consumer would be pretty swell as within reach defaults. I
understand, in previous runtime implementations, doing sendable Ports was
pretty much Out Of The Question. I'm curious if things have changed enough
to warrant revisiting to see if it's worth it? Do you think it's a bridge
too far?

I know this distracts from the current issue that your proposal is
addressing and I apologize for that. I'm just curious if it's worth
throwing into the mix.

As it currently stands, though, your proposal gets a +1 from me.

Cheers


On Mon, Jan 13, 2014 at 6:48 PM, Brian Anderson <banderson at mozilla.com>wrote:

> In light of the general consensus that unbounded channels are not so hot,
> here's a new proposal for how Rust's channels should operate. This is based
> on the following assumptions:
>
> * Running out of memory is an awful failure mode for debugging.
> * Choosing an appropriate bounded queue size is hard.
> * Dealing with backpressure is hard.
> * Most channels are not filled without bound.
>
> This proposal has two facets: making the current channels appropriate for
> more use cases; adding additional channel types for specialized use cases.
> I'm still operating under the premise that there should be a "default"
> channel type that can be successfully used in most instances, and people
> should only need to pick something else when their message passing behavior
> calls for it. Not all of these recommendations are about resolving the
> unbounded channel debate.
>
> # Changes to `Chan`
>
> Firstly, let's combine `Chan` and `SharedChan`. This is partly to free up
> some of our complexity budget to add more channel types, and partly a
> concession to usability. A cloned channel will automatically upgrade itself
> to a multi-producer queue. This will add a small amount of overhead to
> various operations.
>
> Secondly, in order to accommodate the very common case where a channel is
> used just once, we optimize the single-send use case to not allocate.
> Essentially, we store a single element directly in the shared state between
> the channel and port. This restores the `oneshot` functionality we lost in
> the last channel rewrite. Again, this will add a small amount of overhead
> to some operations, though possibly not above the overhead incurred by
> combining `Chan` and `SharedChan`.
>
> Finally, my main suggestion about how to deal with OOM, let's put an
> arbitrary bound to the size of the queue on `Chan`. This isn't to say let's
> turn `Chan` into a bounded queue (which is difficult for implementation
> reasons), but instead that we add a feature that helps debug when you've
> actually chosen the wrong kind of channel because your producer sends
> without bound.
>
> When you hit this bound the send will fail and you know that you need to
> think harder about the behavior of this particular channel. If you *really*
> want an unbounded channel then you can construct it with `Chan::unbounded`,
> otherwise you pick ...
>
> # Synchronous and bounded channels
>
> Let's add `SyncChan` which is a bounded multi-producer single-consumer
> queue backed by a ring buffer. This supports `send`, which blocks by
> default, and `try_send` which returns an enum representing whether the send
> succeeded, the channel is full, or the channel is closed (the last two
> cases returning the message). In the special case where the channel bound
> is 0, we don't use a ringbuffer and just do a rendezvousing send and
> recieve. The default bound is 0.
>
> Comments?
>
> Regards,
> Brian
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140113/4fdf06af/attachment.html>

From comexk at gmail.com  Mon Jan 13 20:56:29 2014
From: comexk at gmail.com (comex)
Date: Mon, 13 Jan 2014 23:56:29 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
	<1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
Message-ID: <CAPM5UJ1_7=ahQM9FZtwEBBfT6bo1BymwBZ+Y9ZJZ9=-Xez_kZw@mail.gmail.com>

On Mon, Jan 13, 2014 at 4:06 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
> int<l1,u1> + int<l2,u2> = int<l1+l2,u1+u2>
> ...
>
> If the result does not fit into an int the compiler throws an error.
> To resolve an error, you can:
> - annotate the operands with appropriate bounds
> - use a bigger type for the operation and check the result.

I remember wondering whether this type of solution would be feasible
or too much of a hassle in practice.  As I see it, many values which
might be arithmetic operands are sizes or counts, and really ought to
be size_t sized, and any mutable variable which is operated on in a
loop can't be bounded with a lot more complexity, so it might lean
toward the latter.

From com.liigo at gmail.com  Mon Jan 13 22:15:52 2014
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Tue, 14 Jan 2014 14:15:52 +0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52D4A564.4090602@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
Message-ID: <CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>

People should rethink the Chan api that Chan::new() does not returns a
value of type Chan (instead, a tuple), which is strange, and inconsistent
with other Type::new().


2014/1/14 Brian Anderson <banderson at mozilla.com>

> In light of the general consensus that unbounded channels are not so hot,
> here's a new proposal for how Rust's channels should operate. This is based
> on the following assumptions:
>
> * Running out of memory is an awful failure mode for debugging.
> * Choosing an appropriate bounded queue size is hard.
> * Dealing with backpressure is hard.
> * Most channels are not filled without bound.
>
> This proposal has two facets: making the current channels appropriate for
> more use cases; adding additional channel types for specialized use cases.
> I'm still operating under the premise that there should be a "default"
> channel type that can be successfully used in most instances, and people
> should only need to pick something else when their message passing behavior
> calls for it. Not all of these recommendations are about resolving the
> unbounded channel debate.
>
> # Changes to `Chan`
>
> Firstly, let's combine `Chan` and `SharedChan`. This is partly to free up
> some of our complexity budget to add more channel types, and partly a
> concession to usability. A cloned channel will automatically upgrade itself
> to a multi-producer queue. This will add a small amount of overhead to
> various operations.
>
> Secondly, in order to accommodate the very common case where a channel is
> used just once, we optimize the single-send use case to not allocate.
> Essentially, we store a single element directly in the shared state between
> the channel and port. This restores the `oneshot` functionality we lost in
> the last channel rewrite. Again, this will add a small amount of overhead
> to some operations, though possibly not above the overhead incurred by
> combining `Chan` and `SharedChan`.
>
> Finally, my main suggestion about how to deal with OOM, let's put an
> arbitrary bound to the size of the queue on `Chan`. This isn't to say let's
> turn `Chan` into a bounded queue (which is difficult for implementation
> reasons), but instead that we add a feature that helps debug when you've
> actually chosen the wrong kind of channel because your producer sends
> without bound.
>
> When you hit this bound the send will fail and you know that you need to
> think harder about the behavior of this particular channel. If you *really*
> want an unbounded channel then you can construct it with `Chan::unbounded`,
> otherwise you pick ...
>
> # Synchronous and bounded channels
>
> Let's add `SyncChan` which is a bounded multi-producer single-consumer
> queue backed by a ring buffer. This supports `send`, which blocks by
> default, and `try_send` which returns an enum representing whether the send
> succeeded, the channel is full, or the channel is closed (the last two
> cases returning the message). In the special case where the channel bound
> is 0, we don't use a ringbuffer and just do a rendezvousing send and
> recieve. The default bound is 0.
>
> Comments?
>
> Regards,
> Brian
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/4e1e205e/attachment-0001.html>

From danielmicay at gmail.com  Mon Jan 13 22:19:30 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 14 Jan 2014 01:19:30 -0500
Subject: [rust-dev] Impact of -ftrapv on Firefox
In-Reply-To: <CAOp6jLYpgnJengJAxeZXt9thy_QcuTDQrYTNrpffzNmFfRCBuw@mail.gmail.com>
References: <CAOp6jLY0F-zn+cBKAzC3kEGzgAmf_ydqK3H5BM-MCZA7YHvKww@mail.gmail.com>
	<CA+DvKQKzUG+6_zb+y=_DKzeVJ=xrxA0T0kY4Ly098zkxzhcjsA@mail.gmail.com>
	<CA+DvKQL+rEWurP_UKaqyyLNj9jJzObVdxB0_j4PSOCCGJjTfjQ@mail.gmail.com>
	<CAOp6jLYpgnJengJAxeZXt9thy_QcuTDQrYTNrpffzNmFfRCBuw@mail.gmail.com>
Message-ID: <CA+DvKQLmL9EYRgax40vSyge=R6Y+_FdAT5bujVdhGwNYKi23Cw@mail.gmail.com>

On Mon, Jan 13, 2014 at 8:19 PM, Robert O'Callahan <robert at ocallahan.org> wrote:
>
> Thanks for catching that. My experiments indicate that -ftrapv works in gcc
> for x86 but not x86-64. Which explains why the Firefox try builds only work
> for x86-64. Which makes sense, since Firefox contains code that would depend
> on overflow wrapping around.

That's a bit scary since `-ftrapv` is only for signed integers and
it's probably not using `-fwrapv` to make it defined :).

From comexk at gmail.com  Tue Jan 14 01:29:17 2014
From: comexk at gmail.com (comex)
Date: Tue, 14 Jan 2014 04:29:17 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
Message-ID: <CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>

On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
<irrequietus at gmail.com> wrote:
> Again, note that this rather long thread is about discussing in the end what
> the official stance should be. There is no valid reason other than lack of
> manpower and / or language immaturity for having to depend on ruby, python,
> autotools, cmake or whatever else in order to build rust software.

There is no reason every language should have its own build system
written from scratch (or package manager, for that matter); the goals
of each language community are really mostly identical, and the
existing duplication leads to software that's worse than it has to be
(e.g. inconsistent support for signed packages), a waste of time
relearning the same concepts for multiple build systems / package
managers, and difficulty for packages that include code written in
multiple languages.  Meanwhile, satisfying the dependencies you
mentioned is trivial on most systems.

However, I'd say there is a stunning lack of existing build systems
that actually combine a clean design, flexibility, portability, and
performance.  autotools fails badly on design, performance, and
(ironically) portability; cmake fails on design (seriously, try to
read any cmake script) and flexibility (a lot of stuff is hard coded
in C++ and hard to change); most of the alternatives I know about are
at least slow, and often poorly maintained, insufficiently general, et
cetera.  The only build tool I really like is ninja, and it's
designed to be used with input generated from a separate tool rather
than alone.  So I'd personally like to see a new build system regardless.

From gaetan at xeberon.net  Tue Jan 14 02:03:49 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 11:03:49 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
Message-ID: <CANK7tAG_F3oh9PUmL7DSxjoXHTYk=oOLejG6fKSskg8AUJzHyw@mail.gmail.com>

>
> However, I'd say there is a stunning lack of existing build systems
> that actually combine a clean design, flexibility, portability, and
> performance.  autotools fails badly on design, performance, and
> (ironically) portability; cmake fails on design (seriously, try to
> read any cmake script)

Same than any language, you can write bloated code or quite pretty things.
Just be consistent and think reusability


> and flexibility (a lot of stuff is hard coded
> in C++ and hard to change);

I don't see what you say is hardcoded? At worst, I simply had to rewrite a
import module.


> most of the alternatives I know about are
> at least slow, and often poorly maintained, insufficiently general, et
> cetera.  The only build tool I really like is ninja, and it's
> designed to be used with input generated from a separate tool rather
> than alone.  So I'd personally like to see a new build system regardless.
>

I also agree that having a proper build system sounds sexy, however do the
rust dev team has enough man power for that?

Why not try to assemble a task that will evaluate several existing build
system instead of just trolling in this thread, to see exactly what are the
advantages and flaws of each candidates?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/4246966e/attachment.html>

From irrequietus at gmail.com  Tue Jan 14 08:09:55 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Tue, 14 Jan 2014 18:09:55 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
Message-ID: <ae72f742-4fa6-4671-917c-9aec600a5a8e@email.android.com>

Rust is early in its lifecycle as a language and at a stage where useful applications implemented in it are about to break ground. Deciding on a build system without the multitude of pitfalls that affect curent status quo solutions is detrimental to the language now, not after it has established its own legacy.

Your argument can be generalized into language design. By analogy, we should all stick to what we know, depend on older languages and multitudes of dependencies because they work well.

If you consider Rust a systems language, surely you see how bizzare - if not somewhat ludicrous - it will sound for Rust to have an *official* (which this thread is all about) build system that needs language relic X to work.

You do conclude however in indeed wanting to see some new build system beyond the usual graph theory rehash. On that, we agree. Rust is capable of doing this just for Rust.


comex <comexk at gmail.com> wrote:
>On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
><irrequietus at gmail.com> wrote:
>> Again, note that this rather long thread is about discussing in the
>end what
>> the official stance should be. There is no valid reason other than
>lack of
>> manpower and / or language immaturity for having to depend on ruby,
>python,
>> autotools, cmake or whatever else in order to build rust software.
>
>There is no reason every language should have its own build system
>written from scratch (or package manager, for that matter); the goals
>of each language community are really mostly identical, and the
>existing duplication leads to software that's worse than it has to be
>(e.g. inconsistent support for signed packages), a waste of time
>relearning the same concepts for multiple build systems / package
>managers, and difficulty for packages that include code written in
>multiple languages.  Meanwhile, satisfying the dependencies you
>mentioned is trivial on most systems.
>
>However, I'd say there is a stunning lack of existing build systems
>that actually combine a clean design, flexibility, portability, and
>performance.  autotools fails badly on design, performance, and
>(ironically) portability; cmake fails on design (seriously, try to
>read any cmake script) and flexibility (a lot of stuff is hard coded
>in C++ and hard to change); most of the alternatives I know about are
>at least slow, and often poorly maintained, insufficiently general, et
>cetera.  The only build tool I really like is ninja, and it's
>designed to be used with input generated from a separate tool rather
>than alone.  So I'd personally like to see a new build system
>regardless.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/dbffb190/attachment.html>

From irrequietus at gmail.com  Tue Jan 14 08:22:58 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Tue, 14 Jan 2014 18:22:58 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAG_F3oh9PUmL7DSxjoXHTYk=oOLejG6fKSskg8AUJzHyw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<CANK7tAG_F3oh9PUmL7DSxjoXHTYk=oOLejG6fKSskg8AUJzHyw@mail.gmail.com>
Message-ID: <3beb6623-1e7c-41bf-aa15-785f25d72e32@email.android.com>

Lack of manpower. Correct. As I have written elsewhere in these threads, this is why an interim solution of a third party tool should perhaps be choosen, instead of sactioning a build system in any language relic X as the official tool.

Closer to 1.0, the need will become more apparent. I do not see a task team / working group proposing this and in order for any official guideline to be followed, this is a step to be taken. Wasn't this the purpose of this thread?

Perhaps this is what comex is trying to say, albeit with his own peculiar rhetorical structure - I doubt that anybody is "trolling", knowingly. I still think that for the intended scope, Rust should just need Rust.


Gaetan <gaetan at xeberon.net> wrote:
>>
>> However, I'd say there is a stunning lack of existing build systems
>> that actually combine a clean design, flexibility, portability, and
>> performance.  autotools fails badly on design, performance, and
>> (ironically) portability; cmake fails on design (seriously, try to
>> read any cmake script)
>
>Same than any language, you can write bloated code or quite pretty
>things.
>Just be consistent and think reusability
>
>
>> and flexibility (a lot of stuff is hard coded
>> in C++ and hard to change);
>
>I don't see what you say is hardcoded? At worst, I simply had to
>rewrite a
>import module.
>
>
>> most of the alternatives I know about are
>> at least slow, and often poorly maintained, insufficiently general,
>et
>> cetera.  The only build tool I really like is ninja, and it's
>> designed to be used with input generated from a separate tool rather
>> than alone.  So I'd personally like to see a new build system
>regardless.
>>
>
>I also agree that having a proper build system sounds sexy, however do
>the
>rust dev team has enough man power for that?
>
>Why not try to assemble a task that will evaluate several existing
>build
>system instead of just trolling in this thread, to see exactly what are
>the
>advantages and flaws of each candidates?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/46bf69d5/attachment-0001.html>

From gaetan at xeberon.net  Tue Jan 14 08:28:49 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 17:28:49 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <3beb6623-1e7c-41bf-aa15-785f25d72e32@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<CANK7tAG_F3oh9PUmL7DSxjoXHTYk=oOLejG6fKSskg8AUJzHyw@mail.gmail.com>
	<3beb6623-1e7c-41bf-aa15-785f25d72e32@email.android.com>
Message-ID: <CANK7tAG4VeCjPCWfSbXpZzqERSzVLSSRWTihPUd63CyxVxKNrg@mail.gmail.com>

rust need llvm, make, wget, bash script, python, autotools... it's just a
matter of choice of which external tool you accept to rely on....

-----
Gaetan



2014/1/14 George Makrydakis <irrequietus at gmail.com>

> Lack of manpower. Correct. As I have written elsewhere in these threads,
> this is why an interim solution of a third party tool should perhaps be
> choosen, instead of sactioning a build system in any language relic X as
> the official tool.
>
> Closer to 1.0, the need will become more apparent. I do not see a task
> team / working group proposing this and in order for any official guideline
> to be followed, this is a step to be taken. Wasn't this the purpose of this
> thread?
>
> Perhaps this is what comex is trying to say, albeit with his own peculiar
> rhetorical structure - I doubt that anybody is "trolling", knowingly. I
> still think that for the intended scope, Rust should just need Rust.
>
>
> Gaetan <gaetan at xeberon.net> wrote:
>>
>> However, I'd say there is a stunning lack of existing build systems
>>> that actually combine a clean design, flexibility, portability, and
>>> performance.  autotools fails badly on design, performance, and
>>> (ironically) portability; cmake fails on design (seriously, try to
>>> read any cmake script)
>>
>> Same than any language, you can write bloated code or quite pretty
>> things. Just be consistent and think reusability
>>
>>
>>> and flexibility (a lot of stuff is hard coded
>>> in C++ and hard to change);
>>
>> I don't see what you say is hardcoded? At worst, I simply had to rewrite
>> a import module.
>>
>>
>>> most of the alternatives I know about are
>>> at least slow, and often poorly maintained, insufficiently general, et
>>> cetera.  The only build tool I really like is ninja, and it's
>>> designed to be used with input generated from a separate tool rather
>>> than alone.  So I'd personally like to see a new build system regardless.
>>>
>>
>> I also agree that having a proper build system sounds sexy, however do
>> the rust dev team has enough man power for that?
>>
>> Why not try to assemble a task that will evaluate several existing build
>> system instead of just trolling in this thread, to see exactly what are the
>> advantages and flaws of each candidates?
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/b5ef1549/attachment.html>

From gaetan at xeberon.net  Tue Jan 14 09:15:32 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 18:15:32 +0100
Subject: [rust-dev] sticker
Message-ID: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>

Just came accross this good presentation:
http://www.youtube.com/watch?v=gfCtbGiHcg0

A question poped into my head: where could I find rust stickers ?

-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/3b19564c/attachment.html>

From pcwalton at mozilla.com  Tue Jan 14 09:25:16 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 14 Jan 2014 09:25:16 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
Message-ID: <52D572FC.5050200@mozilla.com>

On 1/14/14 1:29 AM, comex wrote:
> On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
> <irrequietus at gmail.com> wrote:
>> Again, note that this rather long thread is about discussing in the end what
>> the official stance should be. There is no valid reason other than lack of
>> manpower and / or language immaturity for having to depend on ruby, python,
>> autotools, cmake or whatever else in order to build rust software.
>
> There is no reason every language should have its own build system
> written from scratch (or package manager, for that matter); the goals
> of each language community are really mostly identical, and the
> existing duplication leads to software that's worse than it has to be
> (e.g. inconsistent support for signed packages), a waste of time
> relearning the same concepts for multiple build systems / package
> managers, and difficulty for packages that include code written in
> multiple languages.  Meanwhile, satisfying the dependencies you
> mentioned is trivial on most systems.
>
> However, I'd say there is a stunning lack of existing build systems
> that actually combine a clean design, flexibility, portability, and
> performance.  autotools fails badly on design, performance, and
> (ironically) portability; cmake fails on design (seriously, try to
> read any cmake script) and flexibility (a lot of stuff is hard coded
> in C++ and hard to change); most of the alternatives I know about are
> at least slow, and often poorly maintained, insufficiently general, et
> cetera.  The only build tool I really like is ninja, and it's
> designed to be used with input generated from a separate tool rather
> than alone.  So I'd personally like to see a new build system regardless.

This e-mail sums up my feelings to a T, and it's why I'm conflicted 
about the whole matter.

Patrick


From wichard at vitalitystudios.com  Tue Jan 14 09:33:30 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Tue, 14 Jan 2014 11:33:30 -0600
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
Message-ID: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>

Basically the idea here is to support shuffling for SIMD types in a way
that can be easily lowered to IR (LLVM's shufflevector requires the mask be
a vector of constants, so an intrinsic function is out of the question),
however I image this sugar could extend to tuples with multiple types.

Some examples:

let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
0, 0)"?
assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
let single_x = vec -> (0);
assert_eq!(single_x, (1.0f32));

let mut vec = vec;
vec <- (0) = 5.0f32; // set x only
vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));

let vec = vec;
// the mask may be arbitrarily long:
assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
5.0f32));

// leaves vec unchanged
let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
// functional_update would take it's type from vec
assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));

A couple of things would need to be disallowed, however:

let mut vec = vec;
// no duplicate assignments/functional updates:
vec <- (0, 0) = (..);
let _ = vec -> (0, 1, 2, 3, 0) .. (..);
// no out-of-bounds:
vec <- (5, 9000) = (..);
let _ = vec -> (5, 9001);
let _ = vec -> (5, 9002) .. (..);
let _ = vec -> (0, 1, 2, 3, 4) .. (..);
// all mask values must be a const expr:
let mut non_const_expr = 15;
vec <- (non_const_expr) = (..);
let _ = vec -> (non_const_expr) .. (..);
let _ = vec -> (non_const_expr);
// mismatched tuple sizes:
vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
let _ = vec -> (0) .. (0.0f32, 0.0f32);

AIUI, the notation would be:
tuple_mask : '(' integer [ ',' integer ] * ')' ;
tuple_expr : '(' expr [ ',' expr ] * ')' |
                  tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;

I'm willing to write this myself, but I'd like some consensus/feedback
regarding ze proposed sugar.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/c1dd988f/attachment.html>

From flaper87 at gmail.com  Tue Jan 14 09:53:24 2014
From: flaper87 at gmail.com (Flaper87)
Date: Tue, 14 Jan 2014 18:53:24 +0100
Subject: [rust-dev] sticker
In-Reply-To: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
Message-ID: <CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>

2014/1/14 Gaetan <gaetan at xeberon.net>

> Just came accross this good presentation:
> http://www.youtube.com/watch?v=gfCtbGiHcg0
>
> A question poped into my head: where could I find rust stickers ?
>

I was wondering the same thing! I love stickers and I definitely want a
Rust sticker :D



-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/369ec614/attachment.html>

From catamorphism at gmail.com  Tue Jan 14 10:25:50 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 14 Jan 2014 10:25:50 -0800
Subject: [rust-dev] sticker
In-Reply-To: <CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
Message-ID: <CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>

If you organize a Rust meetup near you and email Brian Anderson or one
of the other core Rust developers who work for Mozilla, I suspect they
would be happy to send you a batch of stickers to hand out. That's one
way, anyway :-)

Cheers,
Tim

On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com> wrote:
>
>
>
> 2014/1/14 Gaetan <gaetan at xeberon.net>
>>
>> Just came accross this good presentation:
>> http://www.youtube.com/watch?v=gfCtbGiHcg0
>>
>> A question poped into my head: where could I find rust stickers ?
>
>
> I was wondering the same thing! I love stickers and I definitely want a Rust
> sticker :D
>
>
>
> --
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From bascule at gmail.com  Tue Jan 14 10:37:49 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 14 Jan 2014 10:37:49 -0800
Subject: [rust-dev] sticker
In-Reply-To: <CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>
Message-ID: <CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>

Have you considered selling the stickers through something like
DevSwag.com? I'm sure Yehuda can get you connected ;)


On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier <catamorphism at gmail.com>wrote:

> If you organize a Rust meetup near you and email Brian Anderson or one
> of the other core Rust developers who work for Mozilla, I suspect they
> would be happy to send you a batch of stickers to hand out. That's one
> way, anyway :-)
>
> Cheers,
> Tim
>
> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com> wrote:
> >
> >
> >
> > 2014/1/14 Gaetan <gaetan at xeberon.net>
> >>
> >> Just came accross this good presentation:
> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
> >>
> >> A question poped into my head: where could I find rust stickers ?
> >
> >
> > I was wondering the same thing! I love stickers and I definitely want a
> Rust
> > sticker :D
> >
> >
> >
> > --
> > Flavio (@flaper87) Percoco
> > http://www.flaper87.com
> > http://github.com/FlaPer87
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed
> it."
> -- Zora Neale Hurston
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/718774f5/attachment.html>

From bascule at gmail.com  Tue Jan 14 10:42:59 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 14 Jan 2014 10:42:59 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52D4A564.4090602@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
Message-ID: <CAHOTMVLPwUNypMmX=mKe_At2w_jTO1CEdoi34m-Be0d7VKATWw@mail.gmail.com>

On Mon, Jan 13, 2014 at 6:48 PM, Brian Anderson <banderson at mozilla.com>wrote:

> Let's add `SyncChan` which is a bounded multi-producer single-consumer
> queue backed by a ring buffer. This supports `send`, which blocks by
> default, and `try_send` which returns an enum representing whether the send
> succeeded, the channel is full, or the channel is closed (the last two
> cases returning the message). In the special case where the channel bound
> is 0, we don't use a ringbuffer and just do a rendezvousing send and
> recieve. The default bound is 0.


Nice! This sounds awesome.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/ff7654f5/attachment.html>

From carter.schonwald at gmail.com  Tue Jan 14 11:07:34 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 14 Jan 2014 14:07:34 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
Message-ID: <CAHYVw0zDzY=Crtn4Yqq2G-yF1Lwr4jn7124G_mbKZX=tq+-nVA@mail.gmail.com>

Neat proposal:
thoughts
0) seems like you need to add a notion of const expr to the type system for
this proposal, right? I started staring at that and it's pretty subtle
(though I may have been looking at it wrong)

1) do rust tuples actually map to the llvm simd vector types?
2) so this would require some special syntax support right? Could it be
prototyped with a procedural macro plus having the shuffle ast code
generated internally?
3) would the internal rep properly treat the shuffle mask ints as part of
the op itself so that it won't get cse'd or the like?
4) would the syntax do a type / syntax error when you use a tuple position
index that's too large?

5) the llvm shuffle vector intrinsic takes two vectors of values and let's
you express interleaving them, not just rearranging a single one (which
seems to be a restriction on your example).  Both styles matter, and
respectively correspond to different platform specific shuffle instructions

I like the idea of something like this, and it's definitely simpler than
the shuffle proposals I've been trying to draft, though using a word like
"shuffle" may be. Though it doesn't give a way to use the same idea for
someone using the platform specific shuffle intrinsics that hopefully would
be added eventually. (Any such platform specific intrinsics would be for
fixed tuple size and type).

*An Alternative approach*? *Int *

One way around the const expr requirement for the type system that someone
suggested was pretty neat: expose the various platform specific simd
shuffle ops, an have their shuffle mask int args actually be "type args".
Apparently there's some protean support for type level numbers because of
sized vectors, and because rust requires all generics to be monomorphized,
this actually would capture the right "constness at compile time"

an example of this idea would be to take the VSHUFPD intel instruction (in
the intel architecture), and modify the intrinsic from the c code version

(nb: __m256d == v4f64 in rust parlance)
  __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int select);

into

fn  _mm256_shuffle_pd<const int select>(__m256d a, __m256d b)-> __m256d

I'm not sure how such a type level int application would work out, but It
may be the nicest way to conservatively add type safe SIMD  shuffle primops
to rust, though I could be completely wrong. (I was initially meh on this
type application idea, but its grown on me, it exploits the way rust
generics work very very nicely!)

*note* while exposing the architecture specific intrinsics would be bit
more work, it would also mean that the SIMD support in rust have a more
transparent mapping to various architectures, allow better architecture/cpu
microarchitecture based tuning (writing an version of BLIS
http://code.google.com/p/blis/ in rust might be a good stress test), and
it'd be less coupled to the vagaries of how LLVM lowers the shuffle
instruction to the target architecture. This actually matters in the
context of writing code that uses the "optimal" instruction sequence by
detecting the cpu micro architecture at runtime and branching to the tune
variant internally, something OpenBLAS does very nicely, see here for
examples https://github.com/xianyi/OpenBLAS/tree/develop/kernel/x86_64

That said, having a systematic way to support the llvm shuffle intrinsic In
it's full generality would be lovely, it's a much more friendly operation
that people can use to get started with doing simd in a somewhat user
friendly way.

point being: I support there being better shuffle simd support / simd
support period :), though how to do  it best seems unclear to me (and
theres also a few ways that arent good too)
-Carter

On Tuesday, January 14, 2014, Richard Diamond wrote:

> Basically the idea here is to support shuffling for SIMD types in a way
> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
> a vector of constants, so an intrinsic function is out of the question),
> however I image this sugar could extend to tuples with multiple types.
>
> Some examples:
>
> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
> 0, 0)"?
> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
> let single_x = vec -> (0);
> assert_eq!(single_x, (1.0f32));
>
> let mut vec = vec;
> vec <- (0) = 5.0f32; // set x only
> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>
> let vec = vec;
> // the mask may be arbitrarily long:
> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
> 5.0f32));
>
> // leaves vec unchanged
> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
> // functional_update would take it's type from vec
> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>
> A couple of things would need to be disallowed, however:
>
> let mut vec = vec;
> // no duplicate assignments/functional updates:
> vec <- (0, 0) = (..);
> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
> // no out-of-bounds:
> vec <- (5, 9000) = (..);
> let _ = vec -> (5, 9001);
> let _ = vec -> (5, 9002) .. (..);
> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
> // all mask values must be a const expr:
> let mut non_const_expr = 15;
> vec <- (non_const_expr) = (..);
> let _ = vec -> (non_const_expr) .. (..);
> let _ = vec -> (non_const_expr);
> // mismatched tuple sizes:
> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>
> AIUI, the notation would be:
> tuple_mask : '(' integer [ ',' integer ] * ')' ;
> tuple_expr : '(' expr [ ',' expr ] * ')' |
>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>
> I'm willing to write this myself, but I'd like some consensus/feedback
> regarding ze proposed sugar.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/d7c53272/attachment.html>

From matthieu.monrocq at gmail.com  Tue Jan 14 11:35:07 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Tue, 14 Jan 2014 20:35:07 +0100
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAPM5UJ1_7=ahQM9FZtwEBBfT6bo1BymwBZ+Y9ZJZ9=-Xez_kZw@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
	<1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
	<CAPM5UJ1_7=ahQM9FZtwEBBfT6bo1BymwBZ+Y9ZJZ9=-Xez_kZw@mail.gmail.com>
Message-ID: <CAKE6RfgFUish3VCJXagKUEx1pwmH=vM901Qd-mJ4Q2aXDWmVtg@mail.gmail.com>

On Tue, Jan 14, 2014 at 5:56 AM, comex <comexk at gmail.com> wrote:

> On Mon, Jan 13, 2014 at 4:06 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
> > int<l1,u1> + int<l2,u2> = int<l1+l2,u1+u2>
> > ...
> >
> > If the result does not fit into an int the compiler throws an error.
> > To resolve an error, you can:
> > - annotate the operands with appropriate bounds
> > - use a bigger type for the operation and check the result.
>
> I remember wondering whether this type of solution would be feasible
> or too much of a hassle in practice.  As I see it, many values which
> might be arithmetic operands are sizes or counts, and really ought to
> be size_t sized, and any mutable variable which is operated on in a
> loop can't be bounded with a lot more complexity, so it might lean
> toward the latter.


It's indeed a risk that such an annotation might be too annoying
(especially since addition is actually quite easy, the bounds grow faster
on multiplication)... but on the other hand, you do need dynamic checks
anyway to verify that the value of type "u32<0, 4_294_967_295>" won't
overflow if you multiply it by "3".

So as I see it, you can do either of: "let result = to<u32<0,
1_431_655_765>>(size)
* 3;" OR "let result = to<u32>(to<u64>(size) * 3);".

Of course, compared to "let result = size * 3;" it seems the annotation tax
is high, however the latter may overflow (and wrap, certainly, but that is
still a bogus answer in most languages).

So, maybe it one could just use a couple primitives:

- wrapping integers (for hashes)
- saturating integers (useful for colors)
- fail-on-overflow integers
- compile-time range-checked integers

u32w, u32s, u32o and u32c ?


Note: as far as I know Rust *plans* on having non-type template parameters
but does not have them yet, so the compile-time range-checked integers are
out of question for now.

Note 2: having all those in the core language would be unnecessary if the
syntax 3u32c (<number><type>) was sugar coating for u32c::new(3) like C++
suffix literals; with "new" using some "default" integer type (I vote for
the fail-on-overflow, it catches the bugs) and the compiler verifying that
the "raw" number can be expressed in that "default" integer type perfectly.
Then libraries could add the other modes.

-- Matthieu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/e518f371/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 11:35:32 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 19:35:32 +0000
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <CAPZendyXQhn1dU074H+zq=ZDD-1N96TOSaxAFJ0CZo_4R=eF=g@mail.gmail.com>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAPZendyXQhn1dU074H+zq=ZDD-1N96TOSaxAFJ0CZo_4R=eF=g@mail.gmail.com>
Message-ID: <52D59184.7090008@gmail.com>

On 14/01/14 01:50, Palmer Cox wrote:
>
> On Mon, Jan 13, 2014 at 12:18 PM, Tobias M?ller <troplin at bluewin.ch 
> <mailto:troplin at bluewin.ch>> wrote:
>
>     Daniel Micay <danielmicay at gmail.com
>     <mailto:danielmicay at gmail.com>> wrote:
>     > Do you know what undefined behavior is? It doesn't mean unspecified.
>
>     True, but despite beeing so often cited it won't format your hard disk
>     (even in C).
>

Actually, it's possible, at least on systems without MMU protection --- 
some embedded systems, for example.  Ints are often used (not just in 
your own code but in library code) to index a jump table. If that index 
is a different number than you expected it to be, you could end up 
executing calling random "functions" in memory.  Said "functions" could 
(and probably would) crash within 1--2 instructions, but even then, it's 
not INCONCEIVABLE that those instructions could equate to "1) load hard 
drive device number into the first arg register; 2) call the OS 
format_drive function".

This all leaves the realm of remote possibility and enters the realm of 
unacceptable risk, at least for some software on some systems, when you 
factor in malicious individuals trying to manipulate what address gets 
called and/or what code is sitting at the address called, waiting to 
execute.

As I understand it, there are essentially three bugs that can cause a 
segfault: 1) write to memory you're not allowed to write to.  2) read 
memory you're not allowed to read from.  3) execute code in memory 
you're not allowed to execute code from.  The third kind of bug is 
basically saying "do anything you like computer, I don't care."  It's 
very much undefined behaviour, very much like calling a function pointer 
that's NULL.  Mostly, you get a segfault, thanks to the MMU, but in 
portable code, you can't depend on that -- either the compiler handles 
it, or you have to remember to check everything carefully, treating your 
coding environment as a hostile one, full of adversaries.

-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/fbe14fa0/attachment.html>

From carter.schonwald at gmail.com  Tue Jan 14 11:46:37 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 14 Jan 2014 14:46:37 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAHYVw0zDzY=Crtn4Yqq2G-yF1Lwr4jn7124G_mbKZX=tq+-nVA@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAHYVw0zDzY=Crtn4Yqq2G-yF1Lwr4jn7124G_mbKZX=tq+-nVA@mail.gmail.com>
Message-ID: <CAHYVw0znzL4RxgJiQ8WvDXYskEt1RWzHgdMx8W+Soy2tfV+bOg@mail.gmail.com>

to further elaborate, from the perspective of translating the syntax to
llvm ir,
the proposal seem to correspond to

shuffleVector(aV,aV,maskVectorLiteral), while the llvm instruction allows
shuffleVector(aV,bV,maskVectorLiteral), and you need the latter to express
stuff like the _mm256_shuffle_pd
operation!

http://llvm.org/docs/LangRef.html#shufflevector-instruction





On Tue, Jan 14, 2014 at 2:07 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> Neat proposal:
> thoughts
> 0) seems like you need to add a notion of const expr to the type system
> for this proposal, right? I started staring at that and it's pretty subtle
> (though I may have been looking at it wrong)
>
> 1) do rust tuples actually map to the llvm simd vector types?
> 2) so this would require some special syntax support right? Could it be
> prototyped with a procedural macro plus having the shuffle ast code
> generated internally?
> 3) would the internal rep properly treat the shuffle mask ints as part of
> the op itself so that it won't get cse'd or the like?
> 4) would the syntax do a type / syntax error when you use a tuple position
> index that's too large?
>
> 5) the llvm shuffle vector intrinsic takes two vectors of values and let's
> you express interleaving them, not just rearranging a single one (which
> seems to be a restriction on your example).  Both styles matter, and
> respectively correspond to different platform specific shuffle instructions
>
> I like the idea of something like this, and it's definitely simpler than
> the shuffle proposals I've been trying to draft, though using a word like
> "shuffle" may be. Though it doesn't give a way to use the same idea for
> someone using the platform specific shuffle intrinsics that hopefully would
> be added eventually. (Any such platform specific intrinsics would be for
> fixed tuple size and type).
>
> *An Alternative approach*? *Int *
>
> One way around the const expr requirement for the type system that someone
> suggested was pretty neat: expose the various platform specific simd
> shuffle ops, an have their shuffle mask int args actually be "type args".
> Apparently there's some protean support for type level numbers because of
> sized vectors, and because rust requires all generics to be monomorphized,
> this actually would capture the right "constness at compile time"
>
> an example of this idea would be to take the VSHUFPD intel instruction (in
> the intel architecture), and modify the intrinsic from the c code version
>
> (nb: __m256d == v4f64 in rust parlance)
>   __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int select);
>
> into
>
> fn  _mm256_shuffle_pd<const int select>(__m256d a, __m256d b)-> __m256d
>
> I'm not sure how such a type level int application would work out, but It
> may be the nicest way to conservatively add type safe SIMD  shuffle primops
> to rust, though I could be completely wrong. (I was initially meh on this
> type application idea, but its grown on me, it exploits the way rust
> generics work very very nicely!)
>
> *note* while exposing the architecture specific intrinsics would be bit
> more work, it would also mean that the SIMD support in rust have a more
> transparent mapping to various architectures, allow better architecture/cpu
> microarchitecture based tuning (writing an version of BLIS
> http://code.google.com/p/blis/ in rust might be a good stress test), and
> it'd be less coupled to the vagaries of how LLVM lowers the shuffle
> instruction to the target architecture. This actually matters in the
> context of writing code that uses the "optimal" instruction sequence by
> detecting the cpu micro architecture at runtime and branching to the tune
> variant internally, something OpenBLAS does very nicely, see here for
> examples https://github.com/xianyi/OpenBLAS/tree/develop/kernel/x86_64
>
> That said, having a systematic way to support the llvm shuffle intrinsic
> In it's full generality would be lovely, it's a much more friendly
> operation that people can use to get started with doing simd in a somewhat
> user friendly way.
>
> point being: I support there being better shuffle simd support / simd
> support period :), though how to do  it best seems unclear to me (and
> theres also a few ways that arent good too)
> -Carter
>
>
> On Tuesday, January 14, 2014, Richard Diamond wrote:
>
>> Basically the idea here is to support shuffling for SIMD types in a way
>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>> a vector of constants, so an intrinsic function is out of the question),
>> however I image this sugar could extend to tuples with multiple types.
>>
>> Some examples:
>>
>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
>> 0, 0)"?
>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>> let single_x = vec -> (0);
>> assert_eq!(single_x, (1.0f32));
>>
>> let mut vec = vec;
>> vec <- (0) = 5.0f32; // set x only
>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>
>> let vec = vec;
>> // the mask may be arbitrarily long:
>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>> 5.0f32));
>>
>> // leaves vec unchanged
>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>> // functional_update would take it's type from vec
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>
>> A couple of things would need to be disallowed, however:
>>
>> let mut vec = vec;
>> // no duplicate assignments/functional updates:
>> vec <- (0, 0) = (..);
>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>> // no out-of-bounds:
>> vec <- (5, 9000) = (..);
>> let _ = vec -> (5, 9001);
>> let _ = vec -> (5, 9002) .. (..);
>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>> // all mask values must be a const expr:
>> let mut non_const_expr = 15;
>> vec <- (non_const_expr) = (..);
>> let _ = vec -> (non_const_expr) .. (..);
>> let _ = vec -> (non_const_expr);
>> // mismatched tuple sizes:
>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>
>> AIUI, the notation would be:
>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>
>> I'm willing to write this myself, but I'd like some consensus/feedback
>> regarding ze proposed sugar.
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/278c3d88/attachment.html>

From wichard at vitalitystudios.com  Tue Jan 14 12:06:57 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Tue, 14 Jan 2014 14:06:57 -0600
Subject: [rust-dev]  Re: RFC: Tuple Swizzling/Shuffling
Message-ID: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>

On Tue, Jan 14, 2014 at 1:07 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> Neat proposal:
> thoughts
> 0) seems like you need to add a notion of const expr to the type system
> for this proposal, right? I started staring at that and it's pretty subtle
> (though I may have been looking at it wrong)
>
I did add the const expr notion a bit, but it's only in anticipation of
somebody wanting to specify the mask in such terms. Of course, boarder
support for const expr's would be required.

1) do rust tuples actually map to the llvm simd vector types?
>
They do with #[simd]. Though I think it would be worth considering whether
all tuples of a single primitive type should be automatically considered
#[simd] and be lowered to a LLVM vector type. In fact one way I'm
considering impling this is to treat the mask as a tuple and lower it as a
vector into a shufflevector mask operand.

2) so this would require some special syntax support right? Could it be
> prototyped with a procedural macro plus having the shuffle ast code
> generated internally?
>
Yes. Sadly not; I've tried. Moreover procedural macros don't exist at a
stage where tuple type info is known, so such a macro would only be able to
operate on literals and still wouldn't be able to dictate trans.

3) would the internal rep properly treat the shuffle mask ints as part of
> the op itself so that it won't get cse'd or the like?
>
Yes.

4) would the syntax do a type / syntax error when you use a tuple position
> index that's too large?
>
Yes.


> 5) the llvm shuffle vector intrinsic takes two vectors of values and let's
> you express interleaving them, not just rearranging a single one (which
> seems to be a restriction on your example).  Both styles matter, and
> respectively correspond to different platform specific shuffle instructions
>
Yeah, not even ten minutes after sending the proposal, I realized I had
forgotten about that one detail. I'm not terribly fond of any of my
envisioned solutions, but the best one uses the recently removed '@':
let vec1 = (10, 11, 12, 13);
let vec2 = (9, 8, 7, 6);
let shuffled = vec1 @ vec2 -> (7, 6, 5, 4, 0, 1, 2, 3); // think
concATenate; it'll likely be thought of as such in rustc.

As an aside, note the arrows point towards what type of value the
expression is supposed to be (lvalue is <-, rvalue is ->).

I like the idea of something like this, and it's definitely simpler than
> the shuffle proposals I've been trying to draft, though using a word like
> "shuffle" may be. Though it doesn't give a way to use the same idea for
> someone using the platform specific shuffle intrinsics that hopefully would
> be added eventually. (Any such platform specific intrinsics would be for
> fixed tuple size and type).
>
Thank you!
The intent is to lean on LLVM's platform independenceness; LLVM supports
vectors (the SIMD type) of any length, so in an effort to be forward
compatible with future SIMD sizes, offer a generic way to 'do the shuffle'.
Access to more specialized shuffles could be done via functions with a
#[link_name] attribute (because such instructions operate on operands of
specific types anyway, they wouldn't be very amenable to a generic
solution) in unstable::simd or an external library. But that's another
project ;)

>
> *An Alternative approach*? *Int *
>
> One way around the const expr requirement for the type system that someone
> suggested was pretty neat: expose the various platform specific simd
> shuffle ops, an have their shuffle mask int args actually be "type args".
> Apparently there's some protean support for type level numbers because of
> sized vectors, and because rust requires all generics to be monomorphized,
> this actually would capture the right "constness at compile time"
>

> an example of this idea would be to take the VSHUFPD intel instruction (in
> the intel architecture), and modify the intrinsic from the c code version
>
> (nb: __m256d == v4f64 in rust parlance)
>   __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int select);
>
> into
>
> fn  _mm256_shuffle_pd<const int select>(__m256d a, __m256d b)-> __m256d
>
> I'm not sure how such a type level int application would work out, but It
> may be the nicest way to conservatively add type safe SIMD  shuffle primops
> to rust, though I could be completely wrong. (I was initially meh on this
> type application idea, but its grown on me, it exploits the way rust
> generics work very very nicely!)
>
> *note* while exposing the architecture specific intrinsics would be bit
> more work, it would also mean that the SIMD support in rust have a more
> transparent mapping to various architectures, allow better architecture/cpu
> microarchitecture based tuning (writing an version of BLIS
> http://code.google.com/p/blis/ in rust might be a good stress test), and
> it'd be less coupled to the vagaries of how LLVM lowers the shuffle
> instruction to the target architecture. This actually matters in the
> context of writing code that uses the "optimal" instruction sequence by
> detecting the cpu micro architecture at runtime and branching to the tune
> variant internally, something OpenBLAS does very nicely, see here for
> examples https://github.com/xianyi/OpenBLAS/tree/develop/kernel/x86_64
>
> That said, having a systematic way to support the llvm shuffle intrinsic
> In it's full generality would be lovely, it's a much more friendly
> operation that people can use to get started with doing simd in a somewhat
> user friendly way.
>
> point being: I support there being better shuffle simd support / simd
> support period :), though how to do  it best seems unclear to me (and
> theres also a few ways that arent good too)
> -Carter
>
>
> On Tuesday, January 14, 2014, Richard Diamond wrote:
>
>> Basically the idea here is to support shuffling for SIMD types in a way
>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>> a vector of constants, so an intrinsic function is out of the question),
>> however I image this sugar could extend to tuples with multiple types.
>>
>> Some examples:
>>
>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
>> 0, 0)"?
>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>> let single_x = vec -> (0);
>> assert_eq!(single_x, (1.0f32));
>>
>> let mut vec = vec;
>> vec <- (0) = 5.0f32; // set x only
>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>
>> let vec = vec;
>> // the mask may be arbitrarily long:
>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>> 5.0f32));
>>
>> // leaves vec unchanged
>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>> // functional_update would take it's type from vec
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>
>> A couple of things would need to be disallowed, however:
>>
>> let mut vec = vec;
>> // no duplicate assignments/functional updates:
>> vec <- (0, 0) = (..);
>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>> // no out-of-bounds:
>> vec <- (5, 9000) = (..);
>> let _ = vec -> (5, 9001);
>> let _ = vec -> (5, 9002) .. (..);
>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>> // all mask values must be a const expr:
>> let mut non_const_expr = 15;
>> vec <- (non_const_expr) = (..);
>> let _ = vec -> (non_const_expr) .. (..);
>> let _ = vec -> (non_const_expr);
>> // mismatched tuple sizes:
>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>
>> AIUI, the notation would be:
>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>
>> I'm willing to write this myself, but I'd like some consensus/feedback
>> regarding ze proposed sugar.
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/1bfb0179/attachment.html>

From danielmicay at gmail.com  Tue Jan 14 12:09:43 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 14 Jan 2014 15:09:43 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
Message-ID: <CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>

On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond
<wichard at vitalitystudios.com> wrote:
>
> They do with #[simd]. Though I think it would be worth considering whether
> all tuples of a single primitive type should be automatically considered
> #[simd] and be lowered to a LLVM vector type. In fact one way I'm
> considering impling this is to treat the mask as a tuple and lower it as a
> vector into a shufflevector mask operand.

This isn't possible due to alignment issues. Only very recent Intel
CPUs lack the requirement of alignment for SIMD instructions.

From carter.schonwald at gmail.com  Tue Jan 14 12:14:01 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 14 Jan 2014 15:14:01 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
Message-ID: <CAHYVw0zy9rHX9Gc-Ut7uhBhjUO19vzMpd69Ks4=yTcz-bmN3vQ@mail.gmail.com>

good points all!

why not have the operation just be
shuffleSimdVector(a,b,masktuple) ?
seems a bit more human friendly than a   mix of @ and <- and ->

I'm a bit confused about the l/rvalue remark, could you explain more?


On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond <
wichard at vitalitystudios.com> wrote:

>
> On Tue, Jan 14, 2014 at 1:07 PM, Carter Schonwald <
> carter.schonwald at gmail.com> wrote:
>
>> Neat proposal:
>> thoughts
>> 0) seems like you need to add a notion of const expr to the type system
>> for this proposal, right? I started staring at that and it's pretty subtle
>> (though I may have been looking at it wrong)
>>
> I did add the const expr notion a bit, but it's only in anticipation of
> somebody wanting to specify the mask in such terms. Of course, boarder
> support for const expr's would be required.
>
> 1) do rust tuples actually map to the llvm simd vector types?
>>
> They do with #[simd]. Though I think it would be worth considering whether
> all tuples of a single primitive type should be automatically considered
> #[simd] and be lowered to a LLVM vector type. In fact one way I'm
> considering impling this is to treat the mask as a tuple and lower it as a
> vector into a shufflevector mask operand.
>
> 2) so this would require some special syntax support right? Could it be
>> prototyped with a procedural macro plus having the shuffle ast code
>> generated internally?
>>
> Yes. Sadly not; I've tried. Moreover procedural macros don't exist at a
> stage where tuple type info is known, so such a macro would only be able to
> operate on literals and still wouldn't be able to dictate trans.
>
> 3) would the internal rep properly treat the shuffle mask ints as part of
>> the op itself so that it won't get cse'd or the like?
>>
> Yes.
>
> 4) would the syntax do a type / syntax error when you use a tuple position
>> index that's too large?
>>
> Yes.
>
>
>> 5) the llvm shuffle vector intrinsic takes two vectors of values and
>> let's you express interleaving them, not just rearranging a single one
>> (which seems to be a restriction on your example).  Both styles matter, and
>> respectively correspond to different platform specific shuffle instructions
>>
> Yeah, not even ten minutes after sending the proposal, I realized I had
> forgotten about that one detail. I'm not terribly fond of any of my
> envisioned solutions, but the best one uses the recently removed '@':
> let vec1 = (10, 11, 12, 13);
> let vec2 = (9, 8, 7, 6);
> let shuffled = vec1 @ vec2 -> (7, 6, 5, 4, 0, 1, 2, 3); // think
> concATenate; it'll likely be thought of as such in rustc.
>
>  As an aside, note the arrows point towards what type of value the
> expression is supposed to be (lvalue is <-, rvalue is ->).
>
> I like the idea of something like this, and it's definitely simpler than
>> the shuffle proposals I've been trying to draft, though using a word like
>> "shuffle" may be. Though it doesn't give a way to use the same idea for
>> someone using the platform specific shuffle intrinsics that hopefully would
>> be added eventually. (Any such platform specific intrinsics would be for
>> fixed tuple size and type).
>>
> Thank you!
> The intent is to lean on LLVM's platform independenceness; LLVM supports
> vectors (the SIMD type) of any length, so in an effort to be forward
> compatible with future SIMD sizes, offer a generic way to 'do the shuffle'.
> Access to more specialized shuffles could be done via functions with a
> #[link_name] attribute (because such instructions operate on operands of
> specific types anyway, they wouldn't be very amenable to a generic
> solution) in unstable::simd or an external library. But that's another
> project ;)
>
>>
>> *An Alternative approach*? *Int *
>>
>> One way around the const expr requirement for the type system
>> that someone suggested was pretty neat: expose the various platform
>> specific simd shuffle ops, an have their shuffle mask int args actually be
>> "type args". Apparently there's some protean support for type level numbers
>> because of sized vectors, and because rust requires all generics to be
>> monomorphized, this actually would capture the right "constness at compile
>> time"
>>
>
>> an example of this idea would be to take the VSHUFPD intel instruction
>> (in the intel architecture), and modify the intrinsic from the c code
>> version
>>
>> (nb: __m256d == v4f64 in rust parlance)
>>   __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int select);
>>
>> into
>>
>> fn  _mm256_shuffle_pd<const int select>(__m256d a, __m256d b)-> __m256d
>>
>> I'm not sure how such a type level int application would work out, but It
>> may be the nicest way to conservatively add type safe SIMD  shuffle primops
>> to rust, though I could be completely wrong. (I was initially meh on this
>> type application idea, but its grown on me, it exploits the way rust
>> generics work very very nicely!)
>>
>> *note* while exposing the architecture specific intrinsics would be bit
>> more work, it would also mean that the SIMD support in rust have a more
>> transparent mapping to various architectures, allow better architecture/cpu
>> microarchitecture based tuning (writing an version of BLIS
>> http://code.google.com/p/blis/ in rust might be a good stress test), and
>> it'd be less coupled to the vagaries of how LLVM lowers the shuffle
>> instruction to the target architecture. This actually matters in the
>> context of writing code that uses the "optimal" instruction sequence by
>> detecting the cpu micro architecture at runtime and branching to the tune
>> variant internally, something OpenBLAS does very nicely, see here for
>> examples https://github.com/xianyi/OpenBLAS/tree/develop/kernel/x86_64
>>
>> That said, having a systematic way to support the llvm shuffle intrinsic
>> In it's full generality would be lovely, it's a much more friendly
>> operation that people can use to get started with doing simd in a somewhat
>> user friendly way.
>>
>> point being: I support there being better shuffle simd support / simd
>> support period :), though how to do  it best seems unclear to me (and
>> theres also a few ways that arent good too)
>> -Carter
>>
>>
>> On Tuesday, January 14, 2014, Richard Diamond wrote:
>>
>>> Basically the idea here is to support shuffling for SIMD types in a way
>>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>>> a vector of constants, so an intrinsic function is out of the question),
>>> however I image this sugar could extend to tuples with multiple types.
>>>
>>> Some examples:
>>>
>>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0,
>>> 0, 0, 0)"?
>>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>>> let single_x = vec -> (0);
>>> assert_eq!(single_x, (1.0f32));
>>>
>>> let mut vec = vec;
>>> vec <- (0) = 5.0f32; // set x only
>>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>>
>>> let vec = vec;
>>> // the mask may be arbitrarily long:
>>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>>> 5.0f32));
>>>
>>> // leaves vec unchanged
>>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>>> // functional_update would take it's type from vec
>>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>>
>>> A couple of things would need to be disallowed, however:
>>>
>>> let mut vec = vec;
>>> // no duplicate assignments/functional updates:
>>> vec <- (0, 0) = (..);
>>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>>> // no out-of-bounds:
>>> vec <- (5, 9000) = (..);
>>> let _ = vec -> (5, 9001);
>>> let _ = vec -> (5, 9002) .. (..);
>>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>>> // all mask values must be a const expr:
>>> let mut non_const_expr = 15;
>>> vec <- (non_const_expr) = (..);
>>> let _ = vec -> (non_const_expr) .. (..);
>>> let _ = vec -> (non_const_expr);
>>> // mismatched tuple sizes:
>>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>>
>>> AIUI, the notation would be:
>>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>>
>>> I'm willing to write this myself, but I'd like some consensus/feedback
>>> regarding ze proposed sugar.
>>>
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/fbf83cf7/attachment-0001.html>

From troplin at bluewin.ch  Tue Jan 14 12:16:04 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Tue, 14 Jan 2014 20:16:04 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAPZendyXQhn1dU074H+zq=ZDD-1N96TOSaxAFJ0CZo_4R=eF=g@mail.gmail.com>
	<52D59184.7090008@gmail.com>
Message-ID: <859122086411422198.599410troplin-bluewin.ch@news.gmane.org>

Lee Braiden <leebraid at gmail.com> wrote:
> On 14/01/14 01:50, Palmer Cox wrote:
> 
> On Mon, Jan 13, 2014 at 12:18 PM, Tobias M?ller
> <troplin at bluewin.ch 
> <mailto:troplin at bluewin.ch>> wrote:
> 
>     Daniel Micay <danielmicay at gmail.com
> <mailto:danielmicay at gmail.com>> wrote:    
> > Do you know what undefined behavior is? It doesn't mean unspecified.
> 
>     True, but despite beeing so often cited it won't format your hard disk     (even in C).
> 
> Actually, it's possible, at least on systems without MMU protection --- 
> some embedded systems, for example.  Ints are often used (not just in 
> your own code but in library code) to index a jump table. If that index 
> is a different number than you expected it to be, you could end up 
> executing calling random "functions" in memory.  Said "functions" could 
> (and probably would) crash within 1--2 instructions, but even then, it's 
> not INCONCEIVABLE that those instructions could equate to "1) load hard 
> drive device number into the first arg register; 2) call the OS  format_drive function".

But this is just as likely with wrapping integers. _Any_ deviation from the
expected behavior is as dangerous as UB.

> This all leaves the realm of remote possibility and enters the realm of 
> unacceptable risk, at least for some software on some systems, when you 
> factor in malicious individuals trying to manipulate what address gets 
> called and/or what code is sitting at the address called, waiting to  execute.
> 
> As I understand it, there are essentially three bugs that can cause a 
> segfault: 1) write to memory you're not allowed to write to.  2) read 
> memory you're not allowed to read from.  3) execute code in memory 
> you're not allowed to execute code from.  The third kind of bug is 
> basically saying "do anything you like computer, I don't care."  It's 
> very much undefined behaviour, very much like calling a function pointer 
> that's NULL.  Mostly, you get a segfault, thanks to the MMU, but in 
> portable code, you can't depend on that -- either the compiler handles 
> it, or you have to remember to check everything carefully, treating your 
> coding environment as a hostile one, full of adversaries.

And that's just why I want to help the programmer with those checks as much
as possible. Lifetimes and non-nullable pointers do a great job ensuring
this for memory management, int overflow is missing such a feature.

Tobi


From irrequietus at gmail.com  Tue Jan 14 12:17:06 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Tue, 14 Jan 2014 22:17:06 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAG4VeCjPCWfSbXpZzqERSzVLSSRWTihPUd63CyxVxKNrg@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<CANK7tAG_F3oh9PUmL7DSxjoXHTYk=oOLejG6fKSskg8AUJzHyw@mail.gmail.com>
	<3beb6623-1e7c-41bf-aa15-785f25d72e32@email.android.com>
	<CANK7tAG4VeCjPCWfSbXpZzqERSzVLSSRWTihPUd63CyxVxKNrg@mail.gmail.com>
Message-ID: <84f179c1-80c3-4b71-a393-84261da76ddc@email.android.com>

Already too much I guess.

Gaetan <gaetan at xeberon.net> wrote:
>rust need llvm, make, wget, bash script, python, autotools... it's just
>a
>matter of choice of which external tool you accept to rely on....
>
>-----
>Gaetan
>
>
>
>2014/1/14 George Makrydakis <irrequietus at gmail.com>
>
>> Lack of manpower. Correct. As I have written elsewhere in these
>threads,
>> this is why an interim solution of a third party tool should perhaps
>be
>> choosen, instead of sactioning a build system in any language relic X
>as
>> the official tool.
>>
>> Closer to 1.0, the need will become more apparent. I do not see a
>task
>> team / working group proposing this and in order for any official
>guideline
>> to be followed, this is a step to be taken. Wasn't this the purpose
>of this
>> thread?
>>
>> Perhaps this is what comex is trying to say, albeit with his own
>peculiar
>> rhetorical structure - I doubt that anybody is "trolling", knowingly.
>I
>> still think that for the intended scope, Rust should just need Rust.
>>
>>
>> Gaetan <gaetan at xeberon.net> wrote:
>>>
>>> However, I'd say there is a stunning lack of existing build systems
>>>> that actually combine a clean design, flexibility, portability, and
>>>> performance.  autotools fails badly on design, performance, and
>>>> (ironically) portability; cmake fails on design (seriously, try to
>>>> read any cmake script)
>>>
>>> Same than any language, you can write bloated code or quite pretty
>>> things. Just be consistent and think reusability
>>>
>>>
>>>> and flexibility (a lot of stuff is hard coded
>>>> in C++ and hard to change);
>>>
>>> I don't see what you say is hardcoded? At worst, I simply had to
>rewrite
>>> a import module.
>>>
>>>
>>>> most of the alternatives I know about are
>>>> at least slow, and often poorly maintained, insufficiently general,
>et
>>>> cetera.  The only build tool I really like is ninja, and it's
>>>> designed to be used with input generated from a separate tool
>rather
>>>> than alone.  So I'd personally like to see a new build system
>regardless.
>>>>
>>>
>>> I also agree that having a proper build system sounds sexy, however
>do
>>> the rust dev team has enough man power for that?
>>>
>>> Why not try to assemble a task that will evaluate several existing
>build
>>> system instead of just trolling in this thread, to see exactly what
>are the
>>> advantages and flaws of each candidates?
>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/197bcb73/attachment.html>

From wichard at vitalitystudios.com  Tue Jan 14 12:22:01 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Tue, 14 Jan 2014 14:22:01 -0600
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAHYVw0zy9rHX9Gc-Ut7uhBhjUO19vzMpd69Ks4=yTcz-bmN3vQ@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
	<CAHYVw0zy9rHX9Gc-Ut7uhBhjUO19vzMpd69Ks4=yTcz-bmN3vQ@mail.gmail.com>
Message-ID: <CAPpP=LDZhs31K-EYqx69H8=1zY=bJw=aAkmVPEHM7+v+PTQxnA@mail.gmail.com>

Take a look at
http://static.rust-lang.org/doc/master/rust.html#lvalues-rvalues-and-temporaries
 or http://en.wikipedia.org/wiki/Value_(computer_science)


On Tue, Jan 14, 2014 at 2:14 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> good points all!
>
> why not have the operation just be
> shuffleSimdVector(a,b,masktuple) ?
> seems a bit more human friendly than a   mix of @ and <- and ->
>
> I'm a bit confused about the l/rvalue remark, could you explain more?
>
>
> On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond <
> wichard at vitalitystudios.com> wrote:
>
>>
>> On Tue, Jan 14, 2014 at 1:07 PM, Carter Schonwald <
>> carter.schonwald at gmail.com> wrote:
>>
>>> Neat proposal:
>>> thoughts
>>> 0) seems like you need to add a notion of const expr to the type system
>>> for this proposal, right? I started staring at that and it's pretty subtle
>>> (though I may have been looking at it wrong)
>>>
>> I did add the const expr notion a bit, but it's only in anticipation of
>> somebody wanting to specify the mask in such terms. Of course, boarder
>> support for const expr's would be required.
>>
>> 1) do rust tuples actually map to the llvm simd vector types?
>>>
>> They do with #[simd]. Though I think it would be worth considering
>> whether all tuples of a single primitive type should be automatically
>> considered #[simd] and be lowered to a LLVM vector type. In fact one way
>> I'm considering impling this is to treat the mask as a tuple and lower it
>> as a vector into a shufflevector mask operand.
>>
>> 2) so this would require some special syntax support right? Could it be
>>> prototyped with a procedural macro plus having the shuffle ast code
>>> generated internally?
>>>
>> Yes. Sadly not; I've tried. Moreover procedural macros don't exist at a
>> stage where tuple type info is known, so such a macro would only be able to
>> operate on literals and still wouldn't be able to dictate trans.
>>
>> 3) would the internal rep properly treat the shuffle mask ints as part of
>>> the op itself so that it won't get cse'd or the like?
>>>
>> Yes.
>>
>> 4) would the syntax do a type / syntax error when you use a tuple
>>> position index that's too large?
>>>
>> Yes.
>>
>>
>>> 5) the llvm shuffle vector intrinsic takes two vectors of values and
>>> let's you express interleaving them, not just rearranging a single one
>>> (which seems to be a restriction on your example).  Both styles matter, and
>>> respectively correspond to different platform specific shuffle instructions
>>>
>> Yeah, not even ten minutes after sending the proposal, I realized I had
>> forgotten about that one detail. I'm not terribly fond of any of my
>> envisioned solutions, but the best one uses the recently removed '@':
>> let vec1 = (10, 11, 12, 13);
>> let vec2 = (9, 8, 7, 6);
>> let shuffled = vec1 @ vec2 -> (7, 6, 5, 4, 0, 1, 2, 3); // think
>> concATenate; it'll likely be thought of as such in rustc.
>>
>>  As an aside, note the arrows point towards what type of value the
>> expression is supposed to be (lvalue is <-, rvalue is ->).
>>
>> I like the idea of something like this, and it's definitely simpler than
>>> the shuffle proposals I've been trying to draft, though using a word like
>>> "shuffle" may be. Though it doesn't give a way to use the same idea for
>>> someone using the platform specific shuffle intrinsics that hopefully would
>>> be added eventually. (Any such platform specific intrinsics would be for
>>> fixed tuple size and type).
>>>
>> Thank you!
>> The intent is to lean on LLVM's platform independenceness; LLVM supports
>> vectors (the SIMD type) of any length, so in an effort to be forward
>> compatible with future SIMD sizes, offer a generic way to 'do the shuffle'.
>> Access to more specialized shuffles could be done via functions with a
>> #[link_name] attribute (because such instructions operate on operands of
>> specific types anyway, they wouldn't be very amenable to a generic
>> solution) in unstable::simd or an external library. But that's another
>> project ;)
>>
>>>
>>> *An Alternative approach*? *Int *
>>>
>>> One way around the const expr requirement for the type system
>>> that someone suggested was pretty neat: expose the various platform
>>> specific simd shuffle ops, an have their shuffle mask int args actually be
>>> "type args". Apparently there's some protean support for type level numbers
>>> because of sized vectors, and because rust requires all generics to be
>>> monomorphized, this actually would capture the right "constness at compile
>>> time"
>>>
>>
>>> an example of this idea would be to take the VSHUFPD intel instruction
>>> (in the intel architecture), and modify the intrinsic from the c code
>>> version
>>>
>>> (nb: __m256d == v4f64 in rust parlance)
>>>   __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int select);
>>>
>>> into
>>>
>>> fn  _mm256_shuffle_pd<const int select>(__m256d a, __m256d b)-> __m256d
>>>
>>> I'm not sure how such a type level int application would work out, but
>>> It may be the nicest way to conservatively add type safe SIMD  shuffle
>>> primops to rust, though I could be completely wrong. (I was initially meh
>>> on this type application idea, but its grown on me, it exploits the way
>>> rust generics work very very nicely!)
>>>
>>> *note* while exposing the architecture specific intrinsics would be bit
>>> more work, it would also mean that the SIMD support in rust have a more
>>> transparent mapping to various architectures, allow better architecture/cpu
>>> microarchitecture based tuning (writing an version of BLIS
>>> http://code.google.com/p/blis/ in rust might be a good stress test),
>>> and it'd be less coupled to the vagaries of how LLVM lowers the shuffle
>>> instruction to the target architecture. This actually matters in the
>>> context of writing code that uses the "optimal" instruction sequence by
>>> detecting the cpu micro architecture at runtime and branching to the tune
>>> variant internally, something OpenBLAS does very nicely, see here for
>>> examples https://github.com/xianyi/OpenBLAS/tree/develop/kernel/x86_64
>>>
>>> That said, having a systematic way to support the llvm shuffle intrinsic
>>> In it's full generality would be lovely, it's a much more friendly
>>> operation that people can use to get started with doing simd in a somewhat
>>> user friendly way.
>>>
>>> point being: I support there being better shuffle simd support / simd
>>> support period :), though how to do  it best seems unclear to me (and
>>> theres also a few ways that arent good too)
>>> -Carter
>>>
>>>
>>> On Tuesday, January 14, 2014, Richard Diamond wrote:
>>>
>>>> Basically the idea here is to support shuffling for SIMD types in a way
>>>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>>>> a vector of constants, so an intrinsic function is out of the question),
>>>> however I image this sugar could extend to tuples with multiple types.
>>>>
>>>> Some examples:
>>>>
>>>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>>>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0,
>>>> 0, 0, 0)"?
>>>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>>>> let single_x = vec -> (0);
>>>> assert_eq!(single_x, (1.0f32));
>>>>
>>>> let mut vec = vec;
>>>> vec <- (0) = 5.0f32; // set x only
>>>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>>>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>>>
>>>> let vec = vec;
>>>> // the mask may be arbitrarily long:
>>>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>>>> 5.0f32));
>>>>
>>>> // leaves vec unchanged
>>>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>>>> // functional_update would take it's type from vec
>>>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>>>
>>>> A couple of things would need to be disallowed, however:
>>>>
>>>> let mut vec = vec;
>>>> // no duplicate assignments/functional updates:
>>>> vec <- (0, 0) = (..);
>>>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>>>> // no out-of-bounds:
>>>> vec <- (5, 9000) = (..);
>>>> let _ = vec -> (5, 9001);
>>>> let _ = vec -> (5, 9002) .. (..);
>>>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>>>> // all mask values must be a const expr:
>>>> let mut non_const_expr = 15;
>>>> vec <- (non_const_expr) = (..);
>>>> let _ = vec -> (non_const_expr) .. (..);
>>>> let _ = vec -> (non_const_expr);
>>>> // mismatched tuple sizes:
>>>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>>>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>>>
>>>> AIUI, the notation would be:
>>>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>>>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>>>
>>>> I'm willing to write this myself, but I'd like some consensus/feedback
>>>> regarding ze proposed sugar.
>>>>
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/b6bc0ffb/attachment-0001.html>

From irrequietus at gmail.com  Tue Jan 14 12:24:20 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Tue, 14 Jan 2014 22:24:20 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D572FC.5050200@mozilla.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com>
Message-ID: <a915ec72-6a5b-4606-8f51-aeeead856a07@email.android.com>

Then, as we discuss on the replies to this, shouldn't there be a "task force" dealing with the matter for what it concerns Rust? Personal preferences lead to conflicts; reaching a consensus requires a wider set of options discussed inproper setting and community audience.

So far, there is little more presented here than personal preferences. These could be used as a basis for what the definitive solution to this matter should be.

Patrick Walton <pcwalton at mozilla.com> wrote:
>On 1/14/14 1:29 AM, comex wrote:
>> On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>> <irrequietus at gmail.com> wrote:
>>> Again, note that this rather long thread is about discussing in the
>end what
>>> the official stance should be. There is no valid reason other than
>lack of
>>> manpower and / or language immaturity for having to depend on ruby,
>python,
>>> autotools, cmake or whatever else in order to build rust software.
>>
>> There is no reason every language should have its own build system
>> written from scratch (or package manager, for that matter); the goals
>> of each language community are really mostly identical, and the
>> existing duplication leads to software that's worse than it has to be
>> (e.g. inconsistent support for signed packages), a waste of time
>> relearning the same concepts for multiple build systems / package
>> managers, and difficulty for packages that include code written in
>> multiple languages.  Meanwhile, satisfying the dependencies you
>> mentioned is trivial on most systems.
>>
>> However, I'd say there is a stunning lack of existing build systems
>> that actually combine a clean design, flexibility, portability, and
>> performance.  autotools fails badly on design, performance, and
>> (ironically) portability; cmake fails on design (seriously, try to
>> read any cmake script) and flexibility (a lot of stuff is hard coded
>> in C++ and hard to change); most of the alternatives I know about are
>> at least slow, and often poorly maintained, insufficiently general,
>et
>> cetera.  The only build tool I really like is ninja, and it's
>> designed to be used with input generated from a separate tool rather
>> than alone.  So I'd personally like to see a new build system
>regardless.
>
>This e-mail sums up my feelings to a T, and it's why I'm conflicted 
>about the whole matter.
>
>Patrick
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/4bf1254d/attachment.html>

From troplin at bluewin.ch  Tue Jan 14 12:26:30 2014
From: troplin at bluewin.ch (=?UTF-8?Q?Tobias=20M=C3=BCller?=)
Date: Tue, 14 Jan 2014 20:26:30 +0000 (UTC)
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAHYVw0xgEP5TcxwrTtJn+pN6j7swHDYU3yzEgj80ZytoGV8nvg@mail.gmail.com>
	<1654420187411338464.740972troplin-bluewin.ch@news.gmane.org>
	<CAPM5UJ1_7=ahQM9FZtwEBBfT6bo1BymwBZ+Y9ZJZ9=-Xez_kZw@mail.gmail.com>
Message-ID: <514130363411423479.211216troplin-bluewin.ch@news.gmane.org>

comex <comexk at gmail.com> wrote:
> On Mon, Jan 13, 2014 at 4:06 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
>> int<l1,u1> + int<l2,u2> = int<l1+l2,u1+u2>
>> ...
>> 
>> If the result does not fit into an int the compiler throws an error.
>> To resolve an error, you can:
>> - annotate the operands with appropriate bounds
>> - use a bigger type for the operation and check the result.
> 
> I remember wondering whether this type of solution would be feasible
> or too much of a hassle in practice.  As I see it, many values which
> might be arithmetic operands are sizes or counts, and really ought to
> be size_t sized, and any mutable variable which is operated on in a
> loop can't be bounded with a lot more complexity, so it might lean
> toward the latter.

You are right, mutations that depend on previous values of the same
variable are a problem. For example it would be impossible to determine
bounds for i in 'i = i + 1'.
But you could shadow i like 'let i = i + 1'. However that is no more
mutation but definition of a new variable.

Tobi


From danielmicay at gmail.com  Tue Jan 14 12:27:11 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 14 Jan 2014 15:27:11 -0500
Subject: [rust-dev] Appeal for CORRECT, capable, future-proof math,
	pre-1.0
In-Reply-To: <859122086411422198.599410troplin-bluewin.ch@news.gmane.org>
References: <52D0D385.1080200@gmail.com>
	<52D0DDA3.8040501@isaac.cedarswampstudios.org>
	<1190503484411242604.533060troplin-bluewin.ch@news.gmane.org>
	<CA+DvKQ+2MVxrHUAZ=H7dcv62--niq_i4D3=hsNB3+KoV7T1D3A@mail.gmail.com>
	<1493431469411324195.606317troplin-bluewin.ch@news.gmane.org>
	<CAPZendyXQhn1dU074H+zq=ZDD-1N96TOSaxAFJ0CZo_4R=eF=g@mail.gmail.com>
	<52D59184.7090008@gmail.com>
	<859122086411422198.599410troplin-bluewin.ch@news.gmane.org>
Message-ID: <CA+DvKQKkbUMv+qXyiywwkEoxoMyzFAUD93GoYKtKPmEQPV9dTQ@mail.gmail.com>

On Tue, Jan 14, 2014 at 3:16 PM, Tobias M?ller <troplin at bluewin.ch> wrote:
> Lee Braiden <leebraid at gmail.com> wrote:
>> On 14/01/14 01:50, Palmer Cox wrote:
>>
>> On Mon, Jan 13, 2014 at 12:18 PM, Tobias M?ller
>> <troplin at bluewin.ch
>> <mailto:troplin at bluewin.ch>> wrote:
>>
>>     Daniel Micay <danielmicay at gmail.com
>> <mailto:danielmicay at gmail.com>> wrote:
>> > Do you know what undefined behavior is? It doesn't mean unspecified.
>>
>>     True, but despite beeing so often cited it won't format your hard disk     (even in C).
>>
>> Actually, it's possible, at least on systems without MMU protection ---
>> some embedded systems, for example.  Ints are often used (not just in
>> your own code but in library code) to index a jump table. If that index
>> is a different number than you expected it to be, you could end up
>> executing calling random "functions" in memory.  Said "functions" could
>> (and probably would) crash within 1--2 instructions, but even then, it's
>> not INCONCEIVABLE that those instructions could equate to "1) load hard
>> drive device number into the first arg register; 2) call the OS  format_drive function".
>
> But this is just as likely with wrapping integers. _Any_ deviation from the
> expected behavior is as dangerous as UB.

That's not how undefined behaviour works in LLVM (and C). If you
perform an integer arithmetic operation with undefined behaviour, it
does not mean that you get an undefined result back. Undefined values
and undefined behaviour are not the same thing.

An arithmetic operation in LLVM can be marked as undefined on overflow
with `nsw` or `nuw` rather than wrapping. `clang` uses `nsw` on signed
integers when `-fwrapv` is not passed to communicate this guarantee.

LLVM can then assume that signed integers never overflow, enabling
more optimizations. It can become aware that makes loops must
terminate, and even gain the ability to count the number of
iterations. It can also glean information on the possible ranges of
values based on the invariants provided by most arithmetic operations.
If it sees `x + INT_MAX`, then `x` is less than or equal to zero.

Invoking undefined behaviour is always a safety issue. You would need
to look at the assembly for the whole program in detail to know
whether an optimization pass made an assumption that's not going to
hold. This will of course change across every compiler version, which
is why C programs so often break with a new `gcc` release.

Wrapping on overflow is a logic error and in rare cases may become a
safety issue if it's then used in a specific kind of `unsafe` code.
The `unsafe` code needs to make the assumption that the integer is in
some valid range, without checking it.

> And that's just why I want to help the programmer with those checks as much
> as possible. Lifetimes and non-nullable pointers do a great job ensuring
> this for memory management, int overflow is missing such a feature.

Rust has support for big integers. It also has support for
library-defined overflow checks via the LLVM overflow checking
intrinsics. A language feature is not necessary to support this.

From wichard at vitalitystudios.com  Tue Jan 14 12:27:48 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Tue, 14 Jan 2014 14:27:48 -0600
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
	<CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
Message-ID: <CAPpP=LA_naiN08es1_NR2yHUb+4BQ2bQNojkLc=P9L5z_HOu1Q@mail.gmail.com>

On Tue, Jan 14, 2014 at 2:09 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond
> <wichard at vitalitystudios.com> wrote:
> >
> > They do with #[simd]. Though I think it would be worth considering
> whether
> > all tuples of a single primitive type should be automatically considered
> > #[simd] and be lowered to a LLVM vector type. In fact one way I'm
> > considering impling this is to treat the mask as a tuple and lower it as
> a
> > vector into a shufflevector mask operand.
>
> This isn't possible due to alignment issues. Only very recent Intel
> CPUs lack the requirement of alignment for SIMD instructions.
>
Obviously, battlefield promotions will be necessary when shifting between
heap and stack.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/04fd391e/attachment.html>

From carter.schonwald at gmail.com  Tue Jan 14 12:27:31 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 14 Jan 2014 15:27:31 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
	<CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
Message-ID: <CAHYVw0yMbYuMVtAFrzUSKY8z+pPtREmJGum4G8Dcw-OZ9U8wFQ@mail.gmail.com>

good point, SIMD vectors are values where you can't take pointers /
addresses (except when suitable cpu dependent intrinsics are available that
load a value from a memory and do an operation and optionally store it
again )


On Tue, Jan 14, 2014 at 3:09 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond
> <wichard at vitalitystudios.com> wrote:
> >
> > They do with #[simd]. Though I think it would be worth considering
> whether
> > all tuples of a single primitive type should be automatically considered
> > #[simd] and be lowered to a LLVM vector type. In fact one way I'm
> > considering impling this is to treat the mask as a tuple and lower it as
> a
> > vector into a shufflevector mask operand.
>
> This isn't possible due to alignment issues. Only very recent Intel
> CPUs lack the requirement of alignment for SIMD instructions.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/f1da37cd/attachment-0001.html>

From carter.schonwald at gmail.com  Tue Jan 14 12:30:37 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Tue, 14 Jan 2014 15:30:37 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LA_naiN08es1_NR2yHUb+4BQ2bQNojkLc=P9L5z_HOu1Q@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
	<CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
	<CAPpP=LA_naiN08es1_NR2yHUb+4BQ2bQNojkLc=P9L5z_HOu1Q@mail.gmail.com>
Message-ID: <CAHYVw0xPLHoH66zzizGzz0Z2r+7q9S=dBQE1Wku=6+qAYAokfg@mail.gmail.com>

ummm, the whole point of SIMD vector values is they work in register. Sure,
sometimes the register allocator may spill to stack, but while an *ARRAY*
of values of type T can have notion of an address, a SIMD Vector of T
(likely f64/f32/int32/int64) doesn't really have the same idea..


On Tue, Jan 14, 2014 at 3:27 PM, Richard Diamond <
wichard at vitalitystudios.com> wrote:

>
>
>
> On Tue, Jan 14, 2014 at 2:09 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> On Tue, Jan 14, 2014 at 3:06 PM, Richard Diamond
>> <wichard at vitalitystudios.com> wrote:
>> >
>> > They do with #[simd]. Though I think it would be worth considering
>> whether
>> > all tuples of a single primitive type should be automatically considered
>> > #[simd] and be lowered to a LLVM vector type. In fact one way I'm
>> > considering impling this is to treat the mask as a tuple and lower it
>> as a
>> > vector into a shufflevector mask operand.
>>
>> This isn't possible due to alignment issues. Only very recent Intel
>> CPUs lack the requirement of alignment for SIMD instructions.
>>
> Obviously, battlefield promotions will be necessary when shifting between
> heap and stack.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/a87a8498/attachment.html>

From leebraid at gmail.com  Tue Jan 14 12:43:36 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 20:43:36 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D572FC.5050200@mozilla.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com>
Message-ID: <52D5A178.6060009@gmail.com>

On 14/01/14 17:25, Patrick Walton wrote:
> On 1/14/14 1:29 AM, comex wrote:
>> On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>> <irrequietus at gmail.com> wrote:
>>> Again, note that this rather long thread is about discussing in the 
>>> end what
>>> the official stance should be. There is no valid reason other than 
>>> lack of
>>> manpower and / or language immaturity for having to depend on ruby, 
>>> python,
>>> autotools, cmake or whatever else in order to build rust software.
>>
>> There is no reason every language should have its own build system
>> written from scratch (or package manager, for that matter); the goals
>> of each language community are really mostly identical<snip>
>>
>> However, I'd say there is a stunning lack of existing build systems
>> that actually combine a clean design, flexibility, portability, and
>> performance<snip>
> This e-mail sums up my feelings to a T, and it's why I'm conflicted 
> about the whole matter.

The more people talk about different build systems and how we can't 
choose one yet, the more I agree.

So, rethinking, it seems to me that important part seems, is to be 
COMPATIBLE with everyone's project hosting, build system, and/or package 
manager of choice.  That would include command line build tools, pretty 
website download catalogs, yum, synaptic, cabal, etc.


So, much more important than choosing TOOLS, I think Rust needs to 
standardise INFORMATION that any tool can use.  Perhaps something like this?

[
    "project": {
         "name":  "someproject",

         "brief-description": "some description",

         "limited-description": [
             "Para-one.",
             "Para-two.",
             "Para-three."
],

         "web": "http://buggysoft.com",

         "screenshots":    {
             "screenshot one": {
                 "uri": "http://www.buggypics.com/massivebug.png",
                 "alt-text":     "Features massive bugs",
             },
         },

         "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",

         "authors": {
             "author1": {
                 "email":        "author1 at someplace.com",
                 "web":          "http://someplace.com",
             },
         },

         "copyright": {
             "license-file":        "docs/LICENSE.TXT",
             "license-flags":    "SHAREALIKE | ATTRIBUTION | 
ADVERTISING_CLAUSE",
         },

         "build-info": {
             "build-type":        "library",
             "target":             "libx.so"
             "source-files":     [ "src/*.rs", "somedir/a_file.rs" ],
         },

         "developer-support-info": {
              "rust-ide-doc-file": "docs/libx.rustapi",
              "rust-ide-completion-file": "docs/libx.rusttags",
         },

         "dependencies": {
             "rust-projects":  {
                     "someotherproject": {        # from that projects 
"project" -> "name" entry

                             # following fields are optional; any 
specified filter the list
                             # the list of suitable candidates.

                             "min-version": "0.1",
                             "max-version": "0.1",

                             "gitrepo": 
"http://somehub.com/someuser/someotherproject/",
                             "min-git-tag": "04a453543",
                             "max-git-tag": "045ead634",

                             "tarball-uri": 
"http://someotherproject.com/somepath-${version}.tgz",

                             "distro-version-ok":    "true"
                     }
             },

             "external-libs": {
                     "libssl":    {
                             "min-version": "0.1",
                             "max-version": "0.1",

                             "gitrepo": 
"http://somehub.com/someuser/someotherproject/",
                             "min-git-tag": "04a453543",
                             "max-git-tag": "045ead634",

                             "tarball-uri": 
"http://someotherproject.com/somepath-${version}.tgz"

                             "distro-version-ok":    "true",
                     }
             },
        }
    }
]

-- 
Lee


From jens at nockert.se  Tue Jan 14 12:48:18 2014
From: jens at nockert.se (Jens Nockert)
Date: Tue, 14 Jan 2014 21:48:18 +0100
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAHYVw0xPLHoH66zzizGzz0Z2r+7q9S=dBQE1Wku=6+qAYAokfg@mail.gmail.com>
References: <CAPpP=LA_r1==hxscZu=b2pRO8vnUb4MpBe5yVOibzpzs10KMZg@mail.gmail.com>
	<CA+DvKQ+EqKJh1o9ZAyt6WRL318HRUHZZsW+K=O9RMb-twpcAYw@mail.gmail.com>
	<CAPpP=LA_naiN08es1_NR2yHUb+4BQ2bQNojkLc=P9L5z_HOu1Q@mail.gmail.com>
	<CAHYVw0xPLHoH66zzizGzz0Z2r+7q9S=dBQE1Wku=6+qAYAokfg@mail.gmail.com>
Message-ID: <4721BD8C-7DD1-4720-9219-AFC3F49AE52F@nockert.se>

I just want to point out that there has already been implementations of swizzling/shuffling, (https://github.com/jensnockert/rust/commit/d3709e3e7426fc41666e971b35cb683e0de15a79) the issue back then was just syntax.

If people can agree on a syntax, implementation should be really simple, just a few hundred lines.

From irrequietus at gmail.com  Tue Jan 14 12:51:55 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Tue, 14 Jan 2014 22:51:55 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5A178.6060009@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
Message-ID: <730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>

That would be a good start. But are you advocating that it should be third party tools thatcshould be given guidelines on how to comply? What would be their incentive to do so? Or should this be used as a basis for creating a prototype deploying duch information... which would inevitably ask again:

Should Rust have its own build tool, given your proposal of standardized representational information ? Dealing with such metadata forces you to design a new system.


Lee Braiden <leebraid at gmail.com> wrote:
>On 14/01/14 17:25, Patrick Walton wrote:
>> On 1/14/14 1:29 AM, comex wrote:
>>> On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>>> <irrequietus at gmail.com> wrote:
>>>> Again, note that this rather long thread is about discussing in the
>
>>>> end what
>>>> the official stance should be. There is no valid reason other than 
>>>> lack of
>>>> manpower and / or language immaturity for having to depend on ruby,
>
>>>> python,
>>>> autotools, cmake or whatever else in order to build rust software.
>>>
>>> There is no reason every language should have its own build system
>>> written from scratch (or package manager, for that matter); the
>goals
>>> of each language community are really mostly identical<snip>
>>>
>>> However, I'd say there is a stunning lack of existing build systems
>>> that actually combine a clean design, flexibility, portability, and
>>> performance<snip>
>> This e-mail sums up my feelings to a T, and it's why I'm conflicted 
>> about the whole matter.
>
>The more people talk about different build systems and how we can't 
>choose one yet, the more I agree.
>
>So, rethinking, it seems to me that important part seems, is to be 
>COMPATIBLE with everyone's project hosting, build system, and/or
>package 
>manager of choice.  That would include command line build tools, pretty
>
>website download catalogs, yum, synaptic, cabal, etc.
>
>
>So, much more important than choosing TOOLS, I think Rust needs to 
>standardise INFORMATION that any tool can use.  Perhaps something like
>this?
>
>[
>    "project": {
>         "name":  "someproject",
>
>         "brief-description": "some description",
>
>         "limited-description": [
>             "Para-one.",
>             "Para-two.",
>             "Para-three."
>],
>
>         "web": "http://buggysoft.com",
>
>         "screenshots":    {
>             "screenshot one": {
>                 "uri": "http://www.buggypics.com/massivebug.png",
>                 "alt-text":     "Features massive bugs",
>             },
>         },
>
>         "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>
>         "authors": {
>             "author1": {
>                 "email":        "author1 at someplace.com",
>                 "web":          "http://someplace.com",
>             },
>         },
>
>         "copyright": {
>             "license-file":        "docs/LICENSE.TXT",
>             "license-flags":    "SHAREALIKE | ATTRIBUTION | 
>ADVERTISING_CLAUSE",
>         },
>
>         "build-info": {
>             "build-type":        "library",
>             "target":             "libx.so"
>             "source-files":     [ "src/*.rs", "somedir/a_file.rs" ],
>         },
>
>         "developer-support-info": {
>              "rust-ide-doc-file": "docs/libx.rustapi",
>              "rust-ide-completion-file": "docs/libx.rusttags",
>         },
>
>         "dependencies": {
>             "rust-projects":  {
>                     "someotherproject": {        # from that projects 
>"project" -> "name" entry
>
>                             # following fields are optional; any 
>specified filter the list
>                             # the list of suitable candidates.
>
>                             "min-version": "0.1",
>                             "max-version": "0.1",
>
>                             "gitrepo": 
>"http://somehub.com/someuser/someotherproject/",
>                             "min-git-tag": "04a453543",
>                             "max-git-tag": "045ead634",
>
>                             "tarball-uri": 
>"http://someotherproject.com/somepath-${version}.tgz",
>
>                             "distro-version-ok":    "true"
>                     }
>             },
>
>             "external-libs": {
>                     "libssl":    {
>                             "min-version": "0.1",
>                             "max-version": "0.1",
>
>                             "gitrepo": 
>"http://somehub.com/someuser/someotherproject/",
>                             "min-git-tag": "04a453543",
>                             "max-git-tag": "045ead634",
>
>                             "tarball-uri": 
>"http://someotherproject.com/somepath-${version}.tgz"
>
>                             "distro-version-ok":    "true",
>                     }
>             },
>        }
>    }
>]
>
>-- 
>Lee
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/b6c4d8de/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 14:11:19 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 22:11:19 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
Message-ID: <52D5B607.5070003@gmail.com>

On 14/01/14 20:51, George Makrydakis wrote:
>
> That would be a good start. But are you advocating that it should be 
> third party tools thatcshould be given guidelines on how to comply? 
> What would be their incentive to do so? Or should this be used as a 
> basis for creating a prototype deploying duch information... which 
> would inevitably ask again:
>
> Should Rust have its own build tool, given your proposal of 
> standardized representational information ? Dealing with such metadata 
> forces you to design a new system.
>

I guess I'm saying that, no matter what solution you choose:

a) People will want their own version, either because they know and 
prefer something else, OR just because they run, say, debian, and it 
manages 26000 packages on their system, and they want Rust to be managed 
that way too.**

b) This kind of information will be needed

** For instance, Debian has tools to create debian packages from git 
repositories, PHP's pear packages, perl packages, google earth tarballs, 
etc.

Arch, BSD ports, and the like import packages using a thin wrapper 
around whatever package system upstream developers use.  There's a will, 
in Linux, in Mac, with MacPorts, in cygwin, etc., and in mobile, to 
integrate package management into one system for all.  We don't 
necessarily have to provide "build" tools for each platform, so 
integration tools for each IDE, syntax highlighting for each editor, or 
API documentation/tags for each IDE.  At least, to start with, all we 
need to do is make it possible for people who want to do these things, 
to do them.

But, what I think is pretty important, is to establish the standard as 
early as possible, to allow people to build tools for as many Rust 
packages as possible.  In many ways, speaking as a general developer 
rather than a rust developer, knowing that any rust package / repository 
will contain a .rust-info file, say, which tells me all the metadata I 
need to know to integrate that package into my website, buildtool, or 
whatever... that's much more valuable to me, than knowing that I can 
download some package, on any of 3 platforms, and it'll just just 
build.  The tool is short term convenience, but the data lets me build 
short term tools AND long-term infrastructure.


-- 
Lee


>
>
> Lee Braiden <leebraid at gmail.com> wrote:
>
>     On 14/01/14 17:25, Patrick Walton wrote:
>
>         On 1/14/14 1:29 AM, comex wrote:
>
>             On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>             <irrequietus at gmail.com> wrote:
>
>                 Again, note that this rather long thread is about
>                 discussing in the end what the official stance should
>                 be. There is no valid reason other than lack of
>                 manpower and / or language immaturity for having to
>                 depend on ruby, python, autotools, cmake or whatever
>                 else in order to build rust software. 
>
>             There is no reason every language should have its own
>             build system written from scratch (or package manager, for
>             that matter); the goals of each language community are
>             really mostly identical<snip> However, I'd say there is a
>             stunning lack of existing build systems that actually
>             combine a clean design, flexibility, portability, and
>             performance<snip> 
>
>         This e-mail sums up my feelings to a T, and it's why I'm
>         conflicted about the whole matter. 
>
>
>     The more people talk about different build systems and how we can't
>     choose one yet, the more I agree.
>
>     So, rethinking, it seems to me that important part seems, is to be
>     COMPATIBLE with everyone's project hosting, build system, and/or package
>     manager of choice.  That would include command line build tools, pretty
>     website download catalogs, yum, synaptic, cabal, etc.
>
>
>     So, much more important than choosing TOOLS, I think Rust needs to
>     standardise INFORMATION that any
>     tool can use.  Perhaps something like this?
>
>     [
>          "project": {
>               "name":  "someproject",
>
>               "brief-description": "some description",
>
>               "limited-description": [
>                   "Para-one.",
>                   "Para-two.",
>                   "Para-three."
>     ],
>
>               "web": "http://buggysoft.com",
>
>               "screenshots":    {
>                   "screenshot one": {
>                       "uri": "http://www.buggypics.com/massivebug.png",
>                       "alt-text":     "Features massive bugs",
>                   },
>               },
>
>               "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>
>               "authors": {
>                   "author1": {
>                       "email":        "author1 at someplace.com",
>             
>               "web":          "http://someplace.com",
>                   },
>               },
>
>               "copyright": {
>                   "license-file":        "docs/LICENSE.TXT",
>                   "license-flags":    "SHAREALIKE | ATTRIBUTION |
>     ADVERTISING_CLAUSE",
>               },
>
>               "build-info": {
>                   "build-type":        "library",
>                   "target":             "libx.so  <http://libx.so>"
>                   "source-files":     [ "src/*.rs", "somedir/a_file.rs  <http://file.rs>" ],
>               },
>
>               "developer-support-info": {
>                    "rust-ide-doc-file": "docs/libx.rustapi",
>                    "rust-ide-completion-file": "docs/libx.rusttags",
>               },
>
>               "dependencies": {
>                   "rust-projects":  {
>                           "someotherproject": {        # from that projects
>     "project" -> "name"
>     entry
>
>                                   # following fields are optional; any
>     specified filter the list
>                                   # the list of suitable candidates.
>
>                                   "min-version": "0.1",
>                                   "max-version": "0.1",
>
>                                   "gitrepo":
>     "http://somehub.com/someuser/someotherproject/",
>                                   "min-git-tag": "04a453543",
>                                   "max-git-tag": "045ead634",
>
>                                   "tarball-uri":
>     "http://someotherproject.com/somepath-${version}.tgz",
>
>                                   "distro-version-ok":    "true"
>                           }
>                   },
>
>                   "external-libs": {
>                           "libssl":    {
>                                  
>     "min-version": "0.1",
>                                   "max-version": "0.1",
>
>                                   "gitrepo":
>     "http://somehub.com/someuser/someotherproject/",
>                                   "min-git-tag": "04a453543",
>                                   "max-git-tag": "045ead634",
>
>                                   "tarball-uri":
>     "http://someotherproject.com/somepath-${version}.tgz"
>
>                                   "distro-version-ok":    "true",
>                           }
>                   },
>              }
>          }
>     ]
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/8236f568/attachment.html>

From jhasse at gmail.com  Tue Jan 14 14:31:00 2014
From: jhasse at gmail.com (Jan Niklas Hasse)
Date: Tue, 14 Jan 2014 23:31:00 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5B607.5070003@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>	<52D572FC.5050200@mozilla.com>
	<52D5A178.6060009@gmail.com>	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com>
Message-ID: <52D5BAA4.8070405@gmail.com>

Am 14.01.2014 23:11, schrieb Lee Braiden:
> On 14/01/14 20:51, George Makrydakis wrote:
>>
>> That would be a good start. But are you advocating that it should be 
>> third party tools thatcshould be given guidelines on how to comply? 
>> What would be their incentive to do so? Or should this be used as a 
>> basis for creating a prototype deploying duch information... which 
>> would inevitably ask again:
>>
>> Should Rust have its own build tool, given your proposal of 
>> standardized representational information ? Dealing with such 
>> metadata forces you to design a new system.
>>
>
> I guess I'm saying that, no matter what solution you choose:
>
> a) People will want their own version, either because they know and 
> prefer something else, OR just because they run, say, debian, and it 
> manages 26000 packages on their system, and they want Rust to be 
> managed that way too.**

I don't understand what debian's package manager has to do with a build 
system?

There's no reason why

apt-get install librust-sdl2-dev

shouldn't work, no matter what rust-sdl2 uses for building itself. The 
package will just contain a rlib file and put it inside 
/usr/lib/rustlib/<target-triple>/.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/1fbc02f1/attachment.html>

From gaetan at xeberon.net  Tue Jan 14 14:32:17 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 23:32:17 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5A178.6060009@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
Message-ID: <CANK7tAFpY-QnELdrv6-FiX4nfLtE1cD9Po+1Uq3GobXs5qxOiA@mail.gmail.com>

this looks like POM :)

I always dreamt of writing a proper build system with such high level
structure, deal with project dependencies, but that is way more complex
than that.

if a project in rust start with this matter, I volunteer to participate to
it.

-----
Gaetan



2014/1/14 Lee Braiden <leebraid at gmail.com>

> On 14/01/14 17:25, Patrick Walton wrote:
>
>> On 1/14/14 1:29 AM, comex wrote:
>>
>>> On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>>> <irrequietus at gmail.com> wrote:
>>>
>>>> Again, note that this rather long thread is about discussing in the end
>>>> what
>>>> the official stance should be. There is no valid reason other than lack
>>>> of
>>>> manpower and / or language immaturity for having to depend on ruby,
>>>> python,
>>>> autotools, cmake or whatever else in order to build rust software.
>>>>
>>>
>>> There is no reason every language should have its own build system
>>> written from scratch (or package manager, for that matter); the goals
>>> of each language community are really mostly identical<snip>
>>>
>>>
>>> However, I'd say there is a stunning lack of existing build systems
>>> that actually combine a clean design, flexibility, portability, and
>>> performance<snip>
>>>
>> This e-mail sums up my feelings to a T, and it's why I'm conflicted about
>> the whole matter.
>>
>
> The more people talk about different build systems and how we can't choose
> one yet, the more I agree.
>
> So, rethinking, it seems to me that important part seems, is to be
> COMPATIBLE with everyone's project hosting, build system, and/or package
> manager of choice.  That would include command line build tools, pretty
> website download catalogs, yum, synaptic, cabal, etc.
>
>
> So, much more important than choosing TOOLS, I think Rust needs to
> standardise INFORMATION that any tool can use.  Perhaps something like this?
>
> [
>    "project": {
>         "name":  "someproject",
>
>         "brief-description": "some description",
>
>         "limited-description": [
>             "Para-one.",
>             "Para-two.",
>             "Para-three."
> ],
>
>         "web": "http://buggysoft.com",
>
>         "screenshots":    {
>             "screenshot one": {
>                 "uri": "http://www.buggypics.com/massivebug.png",
>                 "alt-text":     "Features massive bugs",
>             },
>         },
>
>         "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>
>         "authors": {
>             "author1": {
>                 "email":        "author1 at someplace.com",
>                 "web":          "http://someplace.com",
>             },
>         },
>
>         "copyright": {
>             "license-file":        "docs/LICENSE.TXT",
>             "license-flags":    "SHAREALIKE | ATTRIBUTION |
> ADVERTISING_CLAUSE",
>         },
>
>         "build-info": {
>             "build-type":        "library",
>             "target":             "libx.so"
>             "source-files":     [ "src/*.rs", "somedir/a_file.rs" ],
>         },
>
>         "developer-support-info": {
>              "rust-ide-doc-file": "docs/libx.rustapi",
>              "rust-ide-completion-file": "docs/libx.rusttags",
>         },
>
>         "dependencies": {
>             "rust-projects":  {
>                     "someotherproject": {        # from that projects
> "project" -> "name" entry
>
>                             # following fields are optional; any specified
> filter the list
>                             # the list of suitable candidates.
>
>                             "min-version": "0.1",
>                             "max-version": "0.1",
>
>                             "gitrepo": "http://somehub.com/someuser/
> someotherproject/",
>                             "min-git-tag": "04a453543",
>                             "max-git-tag": "045ead634",
>
>                             "tarball-uri": "http://someotherproject.com/
> somepath-${version}.tgz",
>
>                             "distro-version-ok":    "true"
>                     }
>             },
>
>             "external-libs": {
>                     "libssl":    {
>                             "min-version": "0.1",
>                             "max-version": "0.1",
>
>                             "gitrepo": "http://somehub.com/someuser/
> someotherproject/",
>                             "min-git-tag": "04a453543",
>                             "max-git-tag": "045ead634",
>
>                             "tarball-uri": "http://someotherproject.com/
> somepath-${version}.tgz"
>
>                             "distro-version-ok":    "true",
>                     }
>             },
>        }
>    }
> ]
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/48d3687e/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 14:33:39 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 22:33:39 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
Message-ID: <52D5BB43.5020101@gmail.com>

Another point is that we don't really need a massively complicated 
"build system" right now, as far as I know.

I don't know rust well yet, but it's a two-line script to load this data 
(excluding comments).  Another few lines to figure out whether to build 
a library or an executable, another few to run rustc with the list of 
files, OR to output that list to a Makefile, or a CMakeList.txt, or an 
IDE project file.

With the data, you could build any tool of your choice, to use (almost) 
any tool of your choice, with a few lines in the language of your choice.

And, you can evolve it all later, into something better.  And the data 
format could be extended too.  I should add that the data format should 
have a version number, so tools could parse new versions differently, or 
even read this file, see that it's version 2, and that a better, more 
file format with a different filename should be used instead.


-- 
Lee


On 14/01/14 20:51, George Makrydakis wrote:
>
> That would be a good start. But are you advocating that it should be 
> third party tools thatcshould be given guidelines on how to comply? 
> What would be their incentive to do so? Or should this be used as a 
> basis for creating a prototype deploying duch information... which 
> would inevitably ask again:
>
> Should Rust have its own build tool, given your proposal of 
> standardized representational information ? Dealing with such metadata 
> forces you to design a new system.
>
>
>
> Lee Braiden <leebraid at gmail.com> wrote:
>
>     On 14/01/14 17:25, Patrick Walton wrote:
>
>         On 1/14/14 1:29 AM, comex wrote:
>
>             On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>             <irrequietus at gmail.com> wrote:
>
>                 Again, note that this rather long thread is about
>                 discussing in the end what the official stance should
>                 be. There is no valid reason other than lack of
>                 manpower and / or language immaturity for having to
>                 depend on ruby, python, autotools, cmake or whatever
>                 else in order to build rust software. 
>
>             There is no reason every language should have its own
>             build system written from scratch (or package manager, for
>             that matter); the goals of each language community are
>             really mostly identical<snip> However, I'd say there is a
>             stunning lack of existing build systems that actually
>             combine a clean design, flexibility, portability, and
>             performance<snip> 
>
>         This e-mail sums up my feelings to a T, and it's why I'm
>         conflicted about the whole matter. 
>
>
>     The more people talk about different build systems and how we can't
>     choose one yet, the more I agree.
>
>     So, rethinking, it seems to me that important part seems, is to be
>     COMPATIBLE with everyone's project hosting, build system, and/or package
>     manager of choice.  That would include command line build tools, pretty
>     website download catalogs, yum, synaptic, cabal, etc.
>
>
>     So, much more important than choosing TOOLS, I think Rust needs to
>     standardise INFORMATION that any
>     tool can use.  Perhaps something like this?
>
>     [
>          "project": {
>               "name":  "someproject",
>
>               "brief-description": "some description",
>
>               "limited-description": [
>                   "Para-one.",
>                   "Para-two.",
>                   "Para-three."
>     ],
>
>               "web": "http://buggysoft.com",
>
>               "screenshots":    {
>                   "screenshot one": {
>                       "uri": "http://www.buggypics.com/massivebug.png",
>                       "alt-text":     "Features massive bugs",
>                   },
>               },
>
>               "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>
>               "authors": {
>                   "author1": {
>                       "email":        "author1 at someplace.com",
>             
>               "web":          "http://someplace.com",
>                   },
>               },
>
>               "copyright": {
>                   "license-file":        "docs/LICENSE.TXT",
>                   "license-flags":    "SHAREALIKE | ATTRIBUTION |
>     ADVERTISING_CLAUSE",
>               },
>
>               "build-info": {
>                   "build-type":        "library",
>                   "target":             "libx.so  <http://libx.so>"
>                   "source-files":     [ "src/*.rs", "somedir/a_file.rs  <http://file.rs>" ],
>               },
>
>               "developer-support-info": {
>                    "rust-ide-doc-file": "docs/libx.rustapi",
>                    "rust-ide-completion-file": "docs/libx.rusttags",
>               },
>
>               "dependencies": {
>                   "rust-projects":  {
>                           "someotherproject": {        # from that projects
>     "project" -> "name"
>     entry
>
>                                   # following fields are optional; any
>     specified filter the list
>                                   # the list of suitable candidates.
>
>                                   "min-version": "0.1",
>                                   "max-version": "0.1",
>
>                                   "gitrepo":
>     "http://somehub.com/someuser/someotherproject/",
>                                   "min-git-tag": "04a453543",
>                                   "max-git-tag": "045ead634",
>
>                                   "tarball-uri":
>     "http://someotherproject.com/somepath-${version}.tgz",
>
>                                   "distro-version-ok":    "true"
>                           }
>                   },
>
>                   "external-libs": {
>                           "libssl":    {
>                                  
>     "min-version": "0.1",
>                                   "max-version": "0.1",
>
>                                   "gitrepo":
>     "http://somehub.com/someuser/someotherproject/",
>                                   "min-git-tag": "04a453543",
>                                   "max-git-tag": "045ead634",
>
>                                   "tarball-uri":
>     "http://someotherproject.com/somepath-${version}.tgz"
>
>                                   "distro-version-ok":    "true",
>                           }
>                   },
>              }
>          }
>     ]
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/2c380cf1/attachment.html>

From ecreed at cs.washington.edu  Tue Jan 14 14:35:15 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 14:35:15 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52D4A564.4090602@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
Message-ID: <CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>

I'm skeptical about combining Chan and SharedChan. Maintaining that
distinction is useful for expressing the programmer's intent and would
certainly make any analysis that cared to distinguish between single and
multiple producers easier to implement (off the top of my head, knowing
you're the only one with a Chan means you don't have to deal with potential
race conditions arising from interleaving of messages from different
producers). Maybe a SharedChan should be constructed by consuming a Chan
and upgrading its queue rather than duplicating all of Chan constructors?

Otherwise I'm fine with this proposal.


On Mon, Jan 13, 2014 at 6:48 PM, Brian Anderson <banderson at mozilla.com>wrote:

> In light of the general consensus that unbounded channels are not so hot,
> here's a new proposal for how Rust's channels should operate. This is based
> on the following assumptions:
>
> * Running out of memory is an awful failure mode for debugging.
> * Choosing an appropriate bounded queue size is hard.
> * Dealing with backpressure is hard.
> * Most channels are not filled without bound.
>
> This proposal has two facets: making the current channels appropriate for
> more use cases; adding additional channel types for specialized use cases.
> I'm still operating under the premise that there should be a "default"
> channel type that can be successfully used in most instances, and people
> should only need to pick something else when their message passing behavior
> calls for it. Not all of these recommendations are about resolving the
> unbounded channel debate.
>
> # Changes to `Chan`
>
> Firstly, let's combine `Chan` and `SharedChan`. This is partly to free up
> some of our complexity budget to add more channel types, and partly a
> concession to usability. A cloned channel will automatically upgrade itself
> to a multi-producer queue. This will add a small amount of overhead to
> various operations.
>
> Secondly, in order to accommodate the very common case where a channel is
> used just once, we optimize the single-send use case to not allocate.
> Essentially, we store a single element directly in the shared state between
> the channel and port. This restores the `oneshot` functionality we lost in
> the last channel rewrite. Again, this will add a small amount of overhead
> to some operations, though possibly not above the overhead incurred by
> combining `Chan` and `SharedChan`.
>
> Finally, my main suggestion about how to deal with OOM, let's put an
> arbitrary bound to the size of the queue on `Chan`. This isn't to say let's
> turn `Chan` into a bounded queue (which is difficult for implementation
> reasons), but instead that we add a feature that helps debug when you've
> actually chosen the wrong kind of channel because your producer sends
> without bound.
>
> When you hit this bound the send will fail and you know that you need to
> think harder about the behavior of this particular channel. If you *really*
> want an unbounded channel then you can construct it with `Chan::unbounded`,
> otherwise you pick ...
>
> # Synchronous and bounded channels
>
> Let's add `SyncChan` which is a bounded multi-producer single-consumer
> queue backed by a ring buffer. This supports `send`, which blocks by
> default, and `try_send` which returns an enum representing whether the send
> succeeded, the channel is full, or the channel is closed (the last two
> cases returning the message). In the special case where the channel bound
> is 0, we don't use a ringbuffer and just do a rendezvousing send and
> recieve. The default bound is 0.
>
> Comments?
>
> Regards,
> Brian
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/82c8ddbf/attachment.html>

From gaetan at xeberon.net  Tue Jan 14 14:35:34 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 23:35:34 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5BB43.5020101@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
Message-ID: <CANK7tAGMWZbdG6HPNRu=Psf3yuWQ1mVzC0-GX4HxC9paCRb+5A@mail.gmail.com>

i disagree, the data structure needs to be developed with the majority of
use case possible. you cannot rely on just "extending it" later when new
feature will be needed, that will NOT work.

-----
Gaetan



2014/1/14 Lee Braiden <leebraid at gmail.com>

>  Another point is that we don't really need a massively complicated
> "build system" right now, as far as I know.
>
> I don't know rust well yet, but it's a two-line script to load this data
> (excluding comments).  Another few lines to figure out whether to build a
> library or an executable, another few to run rustc with the list of files,
> OR to output that list to a Makefile, or a CMakeList.txt, or an IDE project
> file.
>
> With the data, you could build any tool of your choice, to use (almost)
> any tool of your choice, with a few lines in the language of your choice.
>
> And, you can evolve it all later, into something better.  And the data
> format could be extended too.  I should add that the data format should
> have a version number, so tools could parse new versions differently, or
> even read this file, see that it's version 2, and that a better, more file
> format with a different filename should be used instead.
>
>
> --
> Lee
>
>
>
> On 14/01/14 20:51, George Makrydakis wrote:
>
> That would be a good start. But are you advocating that it should be third
> party tools thatcshould be given guidelines on how to comply? What would be
> their incentive to do so? Or should this be used as a basis for creating a
> prototype deploying duch information... which would inevitably ask again:
>
> Should Rust have its own build tool, given your proposal of standardized
> representational information ? Dealing with such metadata forces you to
> design a new system.
>
>
> Lee Braiden <leebraid at gmail.com> <leebraid at gmail.com> wrote:
>>
>> On 14/01/14 17:25, Patrick Walton wrote:
>>>
>>>  On 1/14/14 1:29 AM, comex wrote:
>>>>
>>>>  On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>>>>  <irrequietus at gmail.com> <irrequietus at gmail.com> wrote:
>>>>>
>>>>>  Again, note that this rather long thread is about discussing in the
>>>>>  end what
>>>>>  the official stance should be. There is no valid reason other than
>>>>>  lack of
>>>>>  manpower and / or language immaturity for having to depend on ruby,
>>>>>  python,
>>>>>  autotools, cmake or whatever else in order to build rust software.
>>>>
>>>>
>>>>  There is no reason every language should have its own build system
>>>>
>>>> written from scratch (or package manager, for that matter); the goals
>>>>  of each language community are really mostly identical<snip>
>>>>
>>>>  However, I'd say there is a stunning lack of existing build systems
>>>>  that actually combine a clean design, flexibility, portability, and
>>>>  performance<snip>
>>>
>>>  This e-mail sums up my feelings to a T, and it's why I'm conflicted
>>>  about the whole matter.
>>
>>
>> The more people talk about different build systems and how we can't
>> choose one yet, the more I agree.
>>
>> So, rethinking, it seems to me that important part seems, is to be
>> COMPATIBLE with everyone's project hosting, build system, and/or package
>> manager of choice.  That would include command line build tools, pretty
>> website download catalogs, yum, synaptic, cabal, etc.
>>
>>
>> So, much more important than choosing TOOLS, I think Rust needs to
>> standardise INFORMATION that any
>> tool can use.  Perhaps something like this?
>>
>> [
>>     "project": {
>>          "name":  "someproject",
>>
>>          "brief-description": "some description",
>>
>>          "limited-description": [
>>              "Para-one.",
>>              "Para-two.",
>>              "Para-three."
>> ],
>>
>>          "web": "http://buggysoft.com",
>>
>>          "screenshots":    {
>>              "screenshot one": {
>>                  "uri": "http://www.buggypics.com/massivebug.png",
>>                  "alt-text":     "Features massive bugs",
>>              },
>>          },
>>
>>          "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>>
>>          "authors": {
>>              "author1": {
>>                  "email":        "author1 at someplace.com" <author1 at someplace.com>,
>>
>>          "web":          "http://someplace.com",
>>              },
>>          },
>>
>>          "copyright": {
>>              "license-file":        "docs/LICENSE.TXT",
>>              "license-flags":    "SHAREALIKE | ATTRIBUTION |
>> ADVERTISING_CLAUSE",
>>          },
>>
>>          "build-info": {
>>              "build-type":        "library",
>>              "target":             "libx.so"
>>              "source-files":     [ "src/*.rs", "somedir/a_file.rs" ],
>>          },
>>
>>          "developer-support-info": {
>>               "rust-ide-doc-file": "docs/libx.rustapi",
>>               "rust-ide-completion-file": "docs/libx.rusttags",
>>          },
>>
>>          "dependencies": {
>>              "rust-projects":  {
>>                      "someotherproject": {        # from that projects
>> "project" -> "name"
>> entry
>>
>>                              # following fields are optional; any
>> specified filter the list
>>                              # the list of suitable candidates.
>>
>>                              "min-version": "0.1",
>>                              "max-version": "0.1",
>>
>>                              "gitrepo":
>> "http://somehub.com/someuser/someotherproject/",
>>                              "min-git-tag": "04a453543",
>>                              "max-git-tag": "045ead634",
>>
>>                              "tarball-uri":
>> "http://someotherproject.com/somepath-${version}.tgz",
>>
>>                              "distro-version-ok":    "true"
>>                      }
>>              },
>>
>>              "external-libs": {
>>                      "libssl":    {
>>
>> "min-version": "0.1",
>>                              "max-version": "0.1",
>>
>>                              "gitrepo":
>> "http://somehub.com/someuser/someotherproject/",
>>                              "min-git-tag": "04a453543",
>>                              "max-git-tag": "045ead634",
>>
>>                              "tarball-uri":
>> "http://someotherproject.com/somepath-${version}.tgz"
>>
>>                              "distro-version-ok":    "true",
>>                      }
>>              },
>>         }
>>     }
>> ]
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/31462a97/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 14:41:20 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 22:41:20 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5BAA4.8070405@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>	<52CFB098.8010100@gmail.com>	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>	<52D572FC.5050200@mozilla.com>
	<52D5A178.6060009@gmail.com>	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
Message-ID: <52D5BD10.9080406@gmail.com>

On 14/01/14 22:31, Jan Niklas Hasse wrote:
> I don't understand what debian's package manager has to do with a 
> build system?
>
> There's no reason why
>
> apt-get install librust-sdl2-dev
>
> shouldn't work, no matter what rust-sdl2 uses for building itself. The 
> package will just contain a rlib file and put it inside 
> /usr/lib/rustlib/<target-triple>/.
>

There is a LOT of cross-over between package managers and build 
systems.  In fact, I'd argue that the distinction is very blurry, if not 
misguided.  Debian, for instance, provides:

     apt-get -b source packagename

Which downloads and builds a package from source.

Many package managers, like the BSD ports, MAINLY download and build 
from source.  They're nothing but standardised wrappers for the many 
build systems out there, along with (in some package managers, like 
Debian's) standards for where the installed files should end up.

Other packages managers will ONLY build from source.



I think what you're mainly getting at, though, is why you need to care 
about debian choosing to say:

     apt-get install librust-sdl2-dev

When the Rust community says:

     rustpkg -i rust-sdl


The problem is that, the whole concept of a package manager is to 
standardise and maintain compatiblity between installed packages. So 
when debian says:

     apt-get install librust-sdl2-dev

AND you say:

     rustpkg -i rust-sdl--berts-version

That's a conflict.  Because two open source communities failed to work 
together.  BUT, debian, and others like BSD ports etc., very much do 
their part, in providing ways to install librust-sdl2-dev etc.  The part 
that's missing is the metadata for rust-sdl--berts-version, which says, 
"This package provides librust-sdl, so if you install this, don't 
install some other librust-sdl as well."

Basically, I'm saying that, if we make a little effort to create open, 
accessible package data, then everyone will find it easier to work with 
us.  That shouldn't be a foreign concept.


-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/71e3bad5/attachment.html>

From gaetan at xeberon.net  Tue Jan 14 14:51:57 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 14 Jan 2014 23:51:57 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5BD10.9080406@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com>
	<52D5BAA4.8070405@gmail.com> <52D5BD10.9080406@gmail.com>
Message-ID: <CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>

you cannot stick build environment with one system. apt is now on every
system, you cannot use it under windows or mac.
and apt source simply checkout the source zip from repository, this is not
a proper build system.
package management is one job and build is another one. you will use
another package management on another system, while you expect to use the
same build system on another system.

in my experience, i ended up quite often with some bash script for unix
like systems that generates some makefiles or trigs cmake/cpack, visual
studio or eclipse projects for windows.
the only portable build system i used was cmake, which exists under windows
mac and unit, with ctest and cpack, even if there are quite limited. And
there were a lot of "if windows..."

But, i tend to NOT recommend cmake if the final goal is to be integrated
into systems like debian.

-----
Gaetan



2014/1/14 Lee Braiden <leebraid at gmail.com>

>  On 14/01/14 22:31, Jan Niklas Hasse wrote:
>
> I don't understand what debian's package manager has to do with a build
> system?
>
> There's no reason why
>
> apt-get install librust-sdl2-dev
>
> shouldn't work, no matter what rust-sdl2 uses for building itself. The
> package will just contain a rlib file and put it inside
> /usr/lib/rustlib/<target-triple>/.
>
>
> There is a LOT of cross-over between package managers and build systems.
> In fact, I'd argue that the distinction is very blurry, if not misguided.
> Debian, for instance, provides:
>
>     apt-get -b source packagename
>
> Which downloads and builds a package from source.
>
> Many package managers, like the BSD ports, MAINLY download and build from
> source.  They're nothing but standardised wrappers for the many build
> systems out there, along with (in some package managers, like Debian's)
> standards for where the installed files should end up.
>
> Other packages managers will ONLY build from source.
>
>
>
> I think what you're mainly getting at, though, is why you need to care
> about debian choosing to say:
>
>     apt-get install librust-sdl2-dev
>
> When the Rust community says:
>
>     rustpkg -i rust-sdl
>
>
> The problem is that, the whole concept of a package manager is to
> standardise and maintain compatiblity between installed packages.  So when
> debian says:
>
>     apt-get install librust-sdl2-dev
>
> AND you say:
>
>     rustpkg -i rust-sdl--berts-version
>
> That's a conflict.  Because two open source communities failed to work
> together.  BUT, debian, and others like BSD ports etc., very much do their
> part, in providing ways to install librust-sdl2-dev etc.  The part that's
> missing is the metadata for rust-sdl--berts-version, which says, "This
> package provides librust-sdl, so if you install this, don't install some
> other librust-sdl as well."
>
> Basically, I'm saying that, if we make a little effort to create open,
> accessible package data, then everyone will find it easier to work with
> us.  That shouldn't be a foreign concept.
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/5c9a8a14/attachment.html>

From leebraid at gmail.com  Tue Jan 14 14:58:53 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 22:58:53 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAGMWZbdG6HPNRu=Psf3yuWQ1mVzC0-GX4HxC9paCRb+5A@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CANK7tAGMWZbdG6HPNRu=Psf3yuWQ1mVzC0-GX4HxC9paCRb+5A@mail.gmail.com>
Message-ID: <52D5C12D.30001@gmail.com>

Gaetan,

I agree, it's important to think of use cases up-front, and I've tried 
to do that below, too.  If you can add any necessary features or ideas, 
please do.  And if Rustics reach consensus that this is the preferred 
approach, then we should definitely formalise the decision process about 
selecting use cases, making sure they're all covered, etc.

However, from experience, it's IMPOSSIBLE to think of EVERY use case up 
front.  Simply not knowing what technology will be invented in five 
years prevents it.  No matter how hard you try to envisage all 
circumstances, and all future use-cases, something will just be 
obviously missing, in hindsight.  The best standards ALWAYS tag 
versions, and leave room for forwards-compatible upgrades.  It's the 
very reason we have to deal with packages for lots of different library 
versions: eventually, you want to deprecate old stuff, and embrace new 
stuff, and you need some version number to tell which is which.  This 
shouldn't be threatening; it's the EASY, SAFE, GENTLE way to add new 
features. It's what every sensible protocol and standard on the internet 
does, for instance, right down to IP itself.


-- 
Lee


On 14/01/14 22:35, Gaetan wrote:
> i disagree, the data structure needs to be developed with the majority 
> of use case possible. you cannot rely on just "extending it" later 
> when new feature will be needed, that will NOT work.
>
> -----
> Gaetan
>
>
>
> 2014/1/14 Lee Braiden <leebraid at gmail.com <mailto:leebraid at gmail.com>>
>
>     Another point is that we don't really need a massively complicated
>     "build system" right now, as far as I know.
>
>     I don't know rust well yet, but it's a two-line script to load
>     this data (excluding comments).  Another few lines to figure out
>     whether to build a library or an executable, another few to run
>     rustc with the list of files, OR to output that list to a
>     Makefile, or a CMakeList.txt, or an IDE project file.
>
>     With the data, you could build any tool of your choice, to use
>     (almost) any tool of your choice, with a few lines in the language
>     of your choice.
>
>     And, you can evolve it all later, into something better.  And the
>     data format could be extended too.  I should add that the data
>     format should have a version number, so tools could parse new
>     versions differently, or even read this file, see that it's
>     version 2, and that a better, more file format with a different
>     filename should be used instead.
>
>
>     -- 
>     Lee
>
>
>
>     On 14/01/14 20:51, George Makrydakis wrote:
>>
>>     That would be a good start. But are you advocating that it should
>>     be third party tools thatcshould be given guidelines on how to
>>     comply? What would be their incentive to do so? Or should this be
>>     used as a basis for creating a prototype deploying duch
>>     information... which would inevitably ask again:
>>
>>     Should Rust have its own build tool, given your proposal of
>>     standardized representational information ? Dealing with such
>>     metadata forces you to design a new system.
>>
>>
>>
>>     Lee Braiden <leebraid at gmail.com> <mailto:leebraid at gmail.com> wrote:
>>
>>         On 14/01/14 17:25, Patrick Walton wrote:
>>
>>             On 1/14/14 1:29 AM, comex wrote:
>>
>>                 On Mon, Jan 13, 2014 at 10:30 AM, George Makrydakis
>>                 <irrequietus at gmail.com>
>>                 <mailto:irrequietus at gmail.com> wrote:
>>
>>                     Again, note that this rather long thread is about
>>                     discussing in the end what the official stance
>>                     should be. There is no valid reason other than
>>                     lack of manpower and / or language immaturity for
>>                     having to depend on ruby, python, autotools,
>>                     cmake or whatever else in order to build rust
>>                     software. 
>>
>>                 There is no reason every language should have its own
>>                 build system written from scratch (or package
>>                 manager, for that matter); the goals of each language
>>                 community are really mostly identical<snip> However,
>>                 I'd say there is a stunning lack of existing build
>>                 systems that actually combine a clean design,
>>                 flexibility, portability, and performance<snip> 
>>
>>             This e-mail sums up my feelings to a T, and it's why I'm
>>             conflicted about the whole matter. 
>>
>>
>>         The more people talk about different build systems and how we can't
>>         choose one yet, the more I agree.
>>
>>         So, rethinking, it seems to me that important part seems, is to be
>>         COMPATIBLE with everyone's project hosting, build system, and/or package
>>         manager of choice.  That would include command line build tools, pretty
>>         website download catalogs, yum, synaptic, cabal, etc.
>>
>>
>>         So, much more important than choosing TOOLS, I think Rust needs to
>>         standardise INFORMATION that any
>>         tool can use.  Perhaps something like this?
>>
>>         [
>>              "project": {
>>                   "name":  "someproject",
>>
>>                   "brief-description": "some description",
>>
>>                   "limited-description": [
>>                       "Para-one.",
>>                       "Para-two.",
>>                       "Para-three."
>>         ],
>>
>>                   "web": "http://buggysoft.com",
>>
>>                   "screenshots":    {
>>                       "screenshot one": {
>>                           "uri": "http://www.buggypics.com/massivebug.png",
>>                           "alt-text":     "Features massive bugs",
>>                       },
>>                   },
>>
>>                   "bug-tickets": "http://overloaded-cloud-system.buggysoft.com",
>>
>>                   "authors": {
>>                       "author1": {
>>                           "email":"author1 at someplace.com"  <mailto:author1 at someplace.com>,
>>                 
>>                   "web":          "http://someplace.com",
>>                       },
>>                   },
>>
>>                   "copyright": {
>>                       "license-file":        "docs/LICENSE.TXT",
>>                       "license-flags":    "SHAREALIKE | ATTRIBUTION |
>>         ADVERTISING_CLAUSE",
>>                   },
>>
>>                   "build-info": {
>>                       "build-type":        "library",
>>                       "target":             "libx.so  <http://libx.so>"
>>                       "source-files":     [ "src/*.rs", "somedir/a_file.rs  <http://file.rs>" ],
>>                   },
>>
>>                   "developer-support-info": {
>>                        "rust-ide-doc-file": "docs/libx.rustapi",
>>                        "rust-ide-completion-file": "docs/libx.rusttags",
>>                   },
>>
>>                   "dependencies": {
>>                       "rust-projects":  {
>>                               "someotherproject": {        # from that projects
>>         "project" -> "name"
>>         entry
>>
>>                                       # following fields are optional; any
>>         specified filter the list
>>                                       # the list of suitable candidates.
>>
>>                                       "min-version": "0.1",
>>                                       "max-version": "0.1",
>>
>>                                       "gitrepo":
>>         "http://somehub.com/someuser/someotherproject/",
>>                                       "min-git-tag": "04a453543",
>>                                       "max-git-tag": "045ead634",
>>
>>                                       "tarball-uri":
>>         "http://someotherproject.com/somepath-${version}.tgz",
>>
>>                                       "distro-version-ok":    "true"
>>                               }
>>                       },
>>
>>                       "external-libs": {
>>                               "libssl":    {
>>                                      
>>         "min-version": "0.1",
>>                                       "max-version": "0.1",
>>
>>                                       "gitrepo":
>>         "http://somehub.com/someuser/someotherproject/",
>>                                       "min-git-tag": "04a453543",
>>                                       "max-git-tag": "045ead634",
>>
>>                                       "tarball-uri":
>>         "http://someotherproject.com/somepath-${version}.tgz"
>>
>>                                       "distro-version-ok":    "true",
>>                               }
>>                       },
>>                  }
>>              }
>>         ]
>>
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/121962bb/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 15:07:02 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 23:07:02 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
Message-ID: <52D5C316.9070309@gmail.com>

On 14/01/14 22:51, Gaetan wrote:
> you cannot stick build environment with one system. apt is now on 
> every system, you cannot use it under windows or mac.

I think you're misunderstanding me.  I don't favor debian in any way.  I 
would like debian people (and windows people, and mac people, and BSD 
people, and cloud deployment people, etc.) to be able to use Rust 
packages in whatever why they choose, though.


> and apt source simply checkout the source zip from repository, this is 
> not a proper build system.

This is getting off topic, but no, apt-get source builds source code 
that's already been patched with package information. It's exactly how 
debian builds its packages for general use.


> package management is one job and build is another one. you will use 
> another package management on another system, while you expect to use 
> the same build system on another system.

That's true IF your package manager only supports third-party binaries.  
However, if your package manager includes some build process, as most 
emphatically DO, then I believe that's incorrect.

However, I understand that you're saying we shouldn't rely on particular 
package managers.  That is NOT my intention -- just the opposite :)


> in my experience, i ended up quite often with some bash script for 
> unix like systems that generates some makefiles or trigs cmake/cpack, 
> visual studio or eclipse projects for windows.
> the only portable build system i used was cmake, which exists under 
> windows mac and unit, with ctest and cpack, even if there are quite 
> limited. And there were a lot of "if windows..."

Yes, this is what I'm saying :)


> But, i tend to NOT recommend cmake if the final goal is to be 
> integrated into systems like debian.

The final goal would be to allow every distro, every operating system, 
every continuous integration system, every shell script, every cloud 
image builder, every mobile phone developer, and custom OS writer,  do 
work with Rust packages in whatever way suits them best.



-- 
Lee


From gaetan at xeberon.net  Tue Jan 14 15:09:48 2014
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 15 Jan 2014 00:09:48 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5C316.9070309@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com>
	<52D5BAA4.8070405@gmail.com> <52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
Message-ID: <CANK7tAGqajZniKw-ROii-WW8OP92BYbucFs_SSVqiXMsp_6QXA@mail.gmail.com>

i read the ninja documentation, and this integrates well with cmake, and do
the majority of the graph stuff required to compile file. i kind of like
it. and i wonder why rust-pkg cannot be extended, for simple project to
generate ninja files...

-----
Gaetan



2014/1/15 Lee Braiden <leebraid at gmail.com>

> On 14/01/14 22:51, Gaetan wrote:
>
>> you cannot stick build environment with one system. apt is now on every
>> system, you cannot use it under windows or mac.
>>
>
> I think you're misunderstanding me.  I don't favor debian in any way.  I
> would like debian people (and windows people, and mac people, and BSD
> people, and cloud deployment people, etc.) to be able to use Rust packages
> in whatever why they choose, though.
>
>
>
>  and apt source simply checkout the source zip from repository, this is
>> not a proper build system.
>>
>
> This is getting off topic, but no, apt-get source builds source code
> that's already been patched with package information. It's exactly how
> debian builds its packages for general use.
>
>
>
>  package management is one job and build is another one. you will use
>> another package management on another system, while you expect to use the
>> same build system on another system.
>>
>
> That's true IF your package manager only supports third-party binaries.
>  However, if your package manager includes some build process, as most
> emphatically DO, then I believe that's incorrect.
>
> However, I understand that you're saying we shouldn't rely on particular
> package managers.  That is NOT my intention -- just the opposite :)
>
>
>
>  in my experience, i ended up quite often with some bash script for unix
>> like systems that generates some makefiles or trigs cmake/cpack, visual
>> studio or eclipse projects for windows.
>> the only portable build system i used was cmake, which exists under
>> windows mac and unit, with ctest and cpack, even if there are quite
>> limited. And there were a lot of "if windows..."
>>
>
> Yes, this is what I'm saying :)
>
>
>
>  But, i tend to NOT recommend cmake if the final goal is to be integrated
>> into systems like debian.
>>
>
> The final goal would be to allow every distro, every operating system,
> every continuous integration system, every shell script, every cloud image
> builder, every mobile phone developer, and custom OS writer,  do work with
> Rust packages in whatever way suits them best.
>
>
>
> --
> Lee
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/f5009814/attachment.html>

From jhasse at fastmail.fm  Tue Jan 14 15:15:13 2014
From: jhasse at fastmail.fm (Jan Niklas Hasse)
Date: Tue, 14 Jan 2014 15:15:13 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5C316.9070309@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
Message-ID: <1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>

On Tue, Jan 14, 2014, at 03:07 PM, Lee Braiden wrote:
> > package management is one job and build is another one. you will use 
> > another package management on another system, while you expect to use 
> > the same build system on another system.
> 
> That's true IF your package manager only supports third-party binaries.  
> However, if your package manager includes some build process, as most 
> emphatically DO, then I believe that's incorrect.

Doesn't matter what the build system is, it's just another command to
execute specified for the debian package.

> The final goal would be to allow every distro, every operating system, 
> every continuous integration system, every shell script, every cloud 
> image builder, every mobile phone developer, and custom OS writer,  do 
> work with Rust packages in whatever way suits them best.

I wouldn't say *every* distro, etc. Here's an extreme example: Let's say
there's a distro which forces every source package to have its filenames
start with capital letters. Should we rename our files? I would say
definitely no. The distro has to adapt in that case.

The same goes for the build system: Debian can't handle executing
"rustpkg build" instead of "make"? It's their problem! (This is of
course false: Debian CAN handle exactly that)

From martindemello at gmail.com  Tue Jan 14 15:15:47 2014
From: martindemello at gmail.com (Martin DeMello)
Date: Tue, 14 Jan 2014 15:15:47 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAGqajZniKw-ROii-WW8OP92BYbucFs_SSVqiXMsp_6QXA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
	<CANK7tAGqajZniKw-ROii-WW8OP92BYbucFs_SSVqiXMsp_6QXA@mail.gmail.com>
Message-ID: <CAFrFfuFPmzGpEAKo7AT0fyzG8tUoJZhBgnBTQC5P2ug0rS1-iw@mail.gmail.com>

This would probably be a useful thing to have even if the rust project
doesn't officially end up adopting it as the One True Solution.

martin


On Tue, Jan 14, 2014 at 3:09 PM, Gaetan <gaetan at xeberon.net> wrote:

> i read the ninja documentation, and this integrates well with cmake, and
> do the majority of the graph stuff required to compile file. i kind of like
> it. and i wonder why rust-pkg cannot be extended, for simple project to
> generate ninja files...
>
> -----
> Gaetan
>
>
>
> 2014/1/15 Lee Braiden <leebraid at gmail.com>
>
>> On 14/01/14 22:51, Gaetan wrote:
>>
>>> you cannot stick build environment with one system. apt is now on every
>>> system, you cannot use it under windows or mac.
>>>
>>
>> I think you're misunderstanding me.  I don't favor debian in any way.  I
>> would like debian people (and windows people, and mac people, and BSD
>> people, and cloud deployment people, etc.) to be able to use Rust packages
>> in whatever why they choose, though.
>>
>>
>>
>>  and apt source simply checkout the source zip from repository, this is
>>> not a proper build system.
>>>
>>
>> This is getting off topic, but no, apt-get source builds source code
>> that's already been patched with package information. It's exactly how
>> debian builds its packages for general use.
>>
>>
>>
>>  package management is one job and build is another one. you will use
>>> another package management on another system, while you expect to use the
>>> same build system on another system.
>>>
>>
>> That's true IF your package manager only supports third-party binaries.
>>  However, if your package manager includes some build process, as most
>> emphatically DO, then I believe that's incorrect.
>>
>> However, I understand that you're saying we shouldn't rely on particular
>> package managers.  That is NOT my intention -- just the opposite :)
>>
>>
>>
>>  in my experience, i ended up quite often with some bash script for unix
>>> like systems that generates some makefiles or trigs cmake/cpack, visual
>>> studio or eclipse projects for windows.
>>> the only portable build system i used was cmake, which exists under
>>> windows mac and unit, with ctest and cpack, even if there are quite
>>> limited. And there were a lot of "if windows..."
>>>
>>
>> Yes, this is what I'm saying :)
>>
>>
>>
>>  But, i tend to NOT recommend cmake if the final goal is to be integrated
>>> into systems like debian.
>>>
>>
>> The final goal would be to allow every distro, every operating system,
>> every continuous integration system, every shell script, every cloud image
>> builder, every mobile phone developer, and custom OS writer,  do work with
>> Rust packages in whatever way suits them best.
>>
>>
>>
>> --
>> Lee
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/68b62835/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 14 15:40:02 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 23:40:02 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
	<1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>
Message-ID: <52D5CAD2.7040306@gmail.com>

On 14/01/14 23:15, Jan Niklas Hasse wrote:
> On Tue, Jan 14, 2014, at 03:07 PM, Lee Braiden wrote:
>>> package management is one job and build is another one. you will use
>>> another package management on another system, while you expect to use
>>> the same build system on another system.
>> That's true IF your package manager only supports third-party binaries.
>> However, if your package manager includes some build process, as most
>> emphatically DO, then I believe that's incorrect.
> Doesn't matter what the build system is, it's just another command to
> execute specified for the debian package.

Well, the problem for package managers is threefold:

1) Builds involve dependencies: which source *packages* need to be 
installed for that package to build, and of course, what dependencies 
are requiring the CURRENT package to be installed in the first place.  
It's not enough to just be able to BUILD a package; a package manager 
has to know how, and why it's building something, where it will go when 
installed, and what that will MEAN in terms of dependency resolution, 
when the package is finally built and installed.  Otherwise, it's not a 
package MANAGER: it's just front end for downloaders/installers.

2) Some packages, if Rust becomes mainstream at all, will be available 
from multiple sources, in multiple versions.  For example, rust-std 
might be included with a distro, as a standard package.  So might 
rust-sdl2.  But maybe someone with that package installed decides to 
install rust-newgame, which requires 
rust-sdl2--bobs-greenthreads-patch.  Then you have a conflict.  If your 
build script blindly installs rust-sdl2--bobs-greenthreads-patch over 
rust-sdl2, it could break all rust packages that use SDL.

3) Packages take a lot of time to create and maintain.  If we want 
useful rust packages to reach as many people as possible, they should be 
readily available in as many package managers as possible, in a 
standard, non-conflicting package.

Now, there are two ways (that I can see so far) to achieve (3):

     i) Expect all operating systems' and all distros' package 
maintainers to find the resources to package lots of rust libraries and 
programs.

     ii) Make it easy for those maintainers to IMPORT rust libraries and 
programs, using information that only we know, and that we will get 
multiple emails requesting anyway, if we don't provide it up front, from 
the start.


>> I wouldn't say *every* distro, etc. Here's an extreme example: Let's say
>> there's a distro which forces every source package to have its filenames
>> start with capital letters. Should we rename our files? I would say
>> definitely no. The distro has to adapt in that case.

That's a good point, and a good example of why we should think through 
maximum compatibility carefully.  I hadn't thought of that one, but now 
that someone's thought of it, it should be easily solved by disallowing 
case-dependency in package names.  That way, different tools could 
auto-capitalize, auto-title-case or whatever they prefer, as long as 
they remember to lower-case when building the URL.

But yes, I take your wider point that there'll invariably be something 
you don't think of first time around.  It's that kind of thing I'm 
talking about a version number for -- ensuring an upgrade path, just in 
case.

> The same goes for the build system: Debian can't handle executing
> "rustpkg build" instead of "make"? It's their problem! (This is of
> course false: Debian CAN handle exactly that)

Right; building itself (for most things) isn't that hard, even if you're 
running rustc instead of rustpkg, I suppose.  It's dependencies and 
package conflicts that are the real issue, not just building.  
Otherwise, package management, DLL hell, RPM hell, etc., would have been 
mostly solved as soon as most builds used make.


-- 
Lee


From mozilla at mcpherrin.ca  Tue Jan 14 15:43:13 2014
From: mozilla at mcpherrin.ca (Matthew McPherrin)
Date: Tue, 14 Jan 2014 15:43:13 -0800
Subject: [rust-dev] sticker
In-Reply-To: <CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>
	<CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>
Message-ID: <CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>

I've heard continual rumours a proper Mozilla / Firefox store is
coming alive again: Maybe somebody at MoCo can prod and see if it's
possible to get some Rust schwag in that.

On Tue, Jan 14, 2014 at 10:37 AM, Tony Arcieri <bascule at gmail.com> wrote:
> Have you considered selling the stickers through something like DevSwag.com?
> I'm sure Yehuda can get you connected ;)
>
>
> On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier <catamorphism at gmail.com>
> wrote:
>>
>> If you organize a Rust meetup near you and email Brian Anderson or one
>> of the other core Rust developers who work for Mozilla, I suspect they
>> would be happy to send you a batch of stickers to hand out. That's one
>> way, anyway :-)
>>
>> Cheers,
>> Tim
>>
>> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com> wrote:
>> >
>> >
>> >
>> > 2014/1/14 Gaetan <gaetan at xeberon.net>
>> >>
>> >> Just came accross this good presentation:
>> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
>> >>
>> >> A question poped into my head: where could I find rust stickers ?
>> >
>> >
>> > I was wondering the same thing! I love stickers and I definitely want a
>> > Rust
>> > sticker :D
>> >
>> >
>> >
>> > --
>> > Flavio (@flaper87) Percoco
>> > http://www.flaper87.com
>> > http://github.com/FlaPer87
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>>
>>
>> --
>> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
>> "If you are silent about your pain, they'll kill you and say you enjoyed
>> it."
>> -- Zora Neale Hurston
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From corey at octayn.net  Tue Jan 14 15:43:56 2014
From: corey at octayn.net (Corey Richardson)
Date: Tue, 14 Jan 2014 18:43:56 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5BB43.5020101@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
Message-ID: <CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>

On Tue, Jan 14, 2014 at 5:33 PM, Lee Braiden <leebraid at gmail.com> wrote:
> Another point is that we don't really need a massively complicated "build
> system" right now, as far as I know.
>
> I don't know rust well yet, but it's a two-line script to load this data
> (excluding comments).  Another few lines to figure out whether to build a
> library or an executable, another few to run rustc with the list of files,
> OR to output that list to a Makefile, or a CMakeList.txt, or an IDE project
> file.
>

This thread is deviating from its purpose. The idea isn't to hash out
a generic build system for all of Rust, merely for the compiler +
stdlib.

From christopher.meiklejohn at gmail.com  Tue Jan 14 15:45:02 2014
From: christopher.meiklejohn at gmail.com (Christopher Meiklejohn)
Date: Tue, 14 Jan 2014 18:45:02 -0500
Subject: [rust-dev] sticker
In-Reply-To: <CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>
	<CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>
	<CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>
Message-ID: <CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>

Who do we contact if we're running a meetup?  I'm in the process of
organizing one in Providence, RI currently.

- Chris


On Tue, Jan 14, 2014 at 6:43 PM, Matthew McPherrin <mozilla at mcpherrin.ca>wrote:

> I've heard continual rumours a proper Mozilla / Firefox store is
> coming alive again: Maybe somebody at MoCo can prod and see if it's
> possible to get some Rust schwag in that.
>
> On Tue, Jan 14, 2014 at 10:37 AM, Tony Arcieri <bascule at gmail.com> wrote:
> > Have you considered selling the stickers through something like
> DevSwag.com?
> > I'm sure Yehuda can get you connected ;)
> >
> >
> > On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier <catamorphism at gmail.com>
> > wrote:
> >>
> >> If you organize a Rust meetup near you and email Brian Anderson or one
> >> of the other core Rust developers who work for Mozilla, I suspect they
> >> would be happy to send you a batch of stickers to hand out. That's one
> >> way, anyway :-)
> >>
> >> Cheers,
> >> Tim
> >>
> >> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com> wrote:
> >> >
> >> >
> >> >
> >> > 2014/1/14 Gaetan <gaetan at xeberon.net>
> >> >>
> >> >> Just came accross this good presentation:
> >> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
> >> >>
> >> >> A question poped into my head: where could I find rust stickers ?
> >> >
> >> >
> >> > I was wondering the same thing! I love stickers and I definitely want
> a
> >> > Rust
> >> > sticker :D
> >> >
> >> >
> >> >
> >> > --
> >> > Flavio (@flaper87) Percoco
> >> > http://www.flaper87.com
> >> > http://github.com/FlaPer87
> >> >
> >> > _______________________________________________
> >> > Rust-dev mailing list
> >> > Rust-dev at mozilla.org
> >> > https://mail.mozilla.org/listinfo/rust-dev
> >> >
> >>
> >>
> >>
> >> --
> >> Tim Chevalier * http://catamorphism.org/ * Often in error, never in
> doubt
> >> "If you are silent about your pain, they'll kill you and say you enjoyed
> >> it."
> >> -- Zora Neale Hurston
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> >
> > --
> > Tony Arcieri
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/02058eab/attachment.html>

From bjzaba at yahoo.com.au  Tue Jan 14 15:48:52 2014
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Wed, 15 Jan 2014 10:48:52 +1100
Subject: [rust-dev]  RFC: New Rust channel proposal
References: <F0436EAE-99A2-41A1-AB6A-D042907DE5E3@yahoo.com.au>
Message-ID: <D88B46C7-9EA0-41DE-8FA7-DAB3E1618CEE@yahoo.com.au>

On 15 Jan 2014, at 9:35 am, Eric Reed <ecreed at cs.washington.edu> wrote:

> I'm skeptical about combining Chan and SharedChan. Maintaining that distinction is useful for expressing the programmer's intent and would certainly make any analysis that cared to distinguish between single and multiple producers easier to implement (off the top of my head, knowing you're the only one with a Chan means you don't have to deal with potential race conditions arising from interleaving of messages from different producers). Maybe a SharedChan should be constructed by consuming a Chan and upgrading its queue rather than duplicating all of Chan constructors?

Perhaps there could be a simple `UniqueChan` type like:

~~~
struct UniqueChan<T> {
   priv chan: Chan<T>,
}

impl<T: Send> UniqueChan<T> {
   // Re-implement Chan methods here
}

impl<T> Drop for UniqueChan<T> {
   fn drop(&mut self) {}
}
~~~

But that is the special case rather than the general case, which is why it might be better to make Chan shared by default.

~Brendan


From jhasse at fastmail.fm  Tue Jan 14 15:49:10 2014
From: jhasse at fastmail.fm (Jan Niklas Hasse)
Date: Tue, 14 Jan 2014 15:49:10 -0800
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5CAD2.7040306@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
	<1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>
	<52D5CAD2.7040306@gmail.com>
Message-ID: <1389743350.6905.70827901.4812F340@webmail.messagingengine.com>

On Tue, Jan 14, 2014, at 03:40 PM, Lee Braiden wrote:
> 2) Some packages, if Rust becomes mainstream at all, will be available 
> from multiple sources, in multiple versions.  For example, rust-std 
> might be included with a distro, as a standard package.  So might 
> rust-sdl2.  But maybe someone with that package installed decides to 
> install rust-newgame, which requires 
> rust-sdl2--bobs-greenthreads-patch.  Then you have a conflict.  If your 
> build script blindly installs rust-sdl2--bobs-greenthreads-patch over 
> rust-sdl2, it could break all rust packages that use SDL.

This already works with rustpkg: When you type rustpkg install sdl2 it
installs it into the current working directory (locally) and there won't
be any conflicts with globally installed packages by the package
manager.

> 3) Packages take a lot of time to create and maintain.  If we want 
> useful rust packages to reach as many people as possible, they should be 
> readily available in as many package managers as possible, in a 
> standard, non-conflicting package.

I disagree! rustpkg should handle dependencies for building a rust
package. It can automatically know which packages are needed from
"extern mod" etc. apt-get and others are just unsuited for this.

From leebraid at gmail.com  Tue Jan 14 15:53:43 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 23:53:43 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <1389743350.6905.70827901.4812F340@webmail.messagingengine.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
	<1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>
	<52D5CAD2.7040306@gmail.com>
	<1389743350.6905.70827901.4812F340@webmail.messagingengine.com>
Message-ID: <52D5CE07.7030300@gmail.com>

On 14/01/14 23:49, Jan Niklas Hasse wrote:
> I disagree! rustpkg should handle dependencies for building a rust
> package. It can automatically know which packages are needed from
> "extern mod" etc. apt-get and others are just unsuited for this.
>

But that is exactly my point.  Only Rust developers / tools / community 
know that information, so we should make it available to others.

If you're trying to say, though, that we should hide that information so 
we can control builds, I think that simply WON'T work WELL.  Sure, it 
can work, but there will be package conflicts; you will be making 
people's lives harder.


-- 
Lee


From leebraid at gmail.com  Tue Jan 14 15:54:06 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 14 Jan 2014 23:54:06 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
Message-ID: <52D5CE1E.7050601@gmail.com>

On 14/01/14 23:43, Corey Richardson wrote:
> This thread is deviating from its purpose. The idea isn't to hash out 
> a generic build system for all of Rust, merely for the compiler + stdlib. 

I think it naturally progressed, because some people wanted to discuss a 
more generic solution.

But fair enough... if the only goal is to build rust, I've very little 
preference, except to say:

Please choose something cross-platform that's as standard as possible, 
and leads to builds as simple as "make" or "configure && make" or 
something along those lines.

At the outside, CMake's "cmake -G 'Unix Makefiles' etc. is tolerable 
(for me), in the name of supporting IDE users.


-- 
Lee


From flaper87 at gmail.com  Tue Jan 14 16:14:30 2014
From: flaper87 at gmail.com (Flaper87)
Date: Wed, 15 Jan 2014 01:14:30 +0100
Subject: [rust-dev] sticker
In-Reply-To: <CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>
	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>
	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>
	<CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>
	<CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>
	<CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>
Message-ID: <CAMOT3C2WtbU2sOsyR0F+4VXxiWCnjL6OqaFB-F5O1W+BaHa6qg@mail.gmail.com>

2014/1/15 Christopher Meiklejohn <christopher.meiklejohn at gmail.com>

> Who do we contact if we're running a meetup?  I'm in the process of
> organizing one in Providence, RI currently.
>

And I'm about to start one in Milan, IT.


>
> - Chris
>
>
> On Tue, Jan 14, 2014 at 6:43 PM, Matthew McPherrin <mozilla at mcpherrin.ca>wrote:
>
>> I've heard continual rumours a proper Mozilla / Firefox store is
>> coming alive again: Maybe somebody at MoCo can prod and see if it's
>> possible to get some Rust schwag in that.
>>
>> On Tue, Jan 14, 2014 at 10:37 AM, Tony Arcieri <bascule at gmail.com> wrote:
>> > Have you considered selling the stickers through something like
>> DevSwag.com?
>> > I'm sure Yehuda can get you connected ;)
>> >
>> >
>> > On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier <catamorphism at gmail.com
>> >
>> > wrote:
>> >>
>> >> If you organize a Rust meetup near you and email Brian Anderson or one
>> >> of the other core Rust developers who work for Mozilla, I suspect they
>> >> would be happy to send you a batch of stickers to hand out. That's one
>> >> way, anyway :-)
>> >>
>> >> Cheers,
>> >> Tim
>> >>
>> >> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com> wrote:
>> >> >
>> >> >
>> >> >
>> >> > 2014/1/14 Gaetan <gaetan at xeberon.net>
>> >> >>
>> >> >> Just came accross this good presentation:
>> >> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
>> >> >>
>> >> >> A question poped into my head: where could I find rust stickers ?
>> >> >
>> >> >
>> >> > I was wondering the same thing! I love stickers and I definitely
>> want a
>> >> > Rust
>> >> > sticker :D
>> >> >
>> >> >
>> >> >
>> >> > --
>> >> > Flavio (@flaper87) Percoco
>> >> > http://www.flaper87.com
>> >> > http://github.com/FlaPer87
>> >> >
>> >> > _______________________________________________
>> >> > Rust-dev mailing list
>> >> > Rust-dev at mozilla.org
>> >> > https://mail.mozilla.org/listinfo/rust-dev
>> >> >
>> >>
>> >>
>> >>
>> >> --
>> >> Tim Chevalier * http://catamorphism.org/ * Often in error, never in
>> doubt
>> >> "If you are silent about your pain, they'll kill you and say you
>> enjoyed
>> >> it."
>> >> -- Zora Neale Hurston
>> >> _______________________________________________
>> >> Rust-dev mailing list
>> >> Rust-dev at mozilla.org
>> >> https://mail.mozilla.org/listinfo/rust-dev
>> >
>> >
>> >
>> >
>> > --
>> > Tony Arcieri
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/cd8010a9/attachment.html>

From jack at metajack.im  Tue Jan 14 16:52:06 2014
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 14 Jan 2014 17:52:06 -0700
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
Message-ID: <CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>

> I'm skeptical about combining Chan and SharedChan. Maintaining that
> distinction is useful for expressing the programmer's intent and would
> certainly make any analysis that cared to distinguish between single and
> multiple producers easier to implement (off the top of my head, knowing
> you're the only one with a Chan means you don't have to deal with potential
> race conditions arising from interleaving of messages from different
> producers).

I think the core issue about that is that the person who writes the
type signature of a function doesn't always know the contexts in which
its used.

jack.

From ecreed at cs.washington.edu  Tue Jan 14 16:58:39 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 16:58:39 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
Message-ID: <CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>

Good point. Make `Chan` a trait with implementers `UniqueChan` and
`SharedChan`?


On Tue, Jan 14, 2014 at 4:52 PM, Jack Moffitt <jack at metajack.im> wrote:

> > I'm skeptical about combining Chan and SharedChan. Maintaining that
> > distinction is useful for expressing the programmer's intent and would
> > certainly make any analysis that cared to distinguish between single and
> > multiple producers easier to implement (off the top of my head, knowing
> > you're the only one with a Chan means you don't have to deal with
> potential
> > race conditions arising from interleaving of messages from different
> > producers).
>
> I think the core issue about that is that the person who writes the
> type signature of a function doesn't always know the contexts in which
> its used.
>
> jack.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/83d18d88/attachment.html>

From jack at metajack.im  Tue Jan 14 17:22:39 2014
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 14 Jan 2014 18:22:39 -0700
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
Message-ID: <CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>

> Good point. Make `Chan` a trait with implementers `UniqueChan` and
> `SharedChan`?

I suppose the main downside of that solution is that you lose stack
allocated return values.

jack.

From banderson at mozilla.com  Tue Jan 14 17:30:51 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 14 Jan 2014 17:30:51 -0800
Subject: [rust-dev] sticker
In-Reply-To: <CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>	<CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>	<CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>
	<CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>
Message-ID: <52D5E4CB.7090607@mozilla.com>

People that need Rust stickers can send me an email off-list.

On 01/14/2014 03:45 PM, Christopher Meiklejohn wrote:
> Who do we contact if we're running a meetup?  I'm in the process of 
> organizing one in Providence, RI currently.
>
> - Chris
>
>
> On Tue, Jan 14, 2014 at 6:43 PM, Matthew McPherrin 
> <mozilla at mcpherrin.ca <mailto:mozilla at mcpherrin.ca>> wrote:
>
>     I've heard continual rumours a proper Mozilla / Firefox store is
>     coming alive again: Maybe somebody at MoCo can prod and see if it's
>     possible to get some Rust schwag in that.
>
>     On Tue, Jan 14, 2014 at 10:37 AM, Tony Arcieri <bascule at gmail.com
>     <mailto:bascule at gmail.com>> wrote:
>     > Have you considered selling the stickers through something like
>     DevSwag.com?
>     > I'm sure Yehuda can get you connected ;)
>     >
>     >
>     > On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier
>     <catamorphism at gmail.com <mailto:catamorphism at gmail.com>>
>     > wrote:
>     >>
>     >> If you organize a Rust meetup near you and email Brian Anderson
>     or one
>     >> of the other core Rust developers who work for Mozilla, I
>     suspect they
>     >> would be happy to send you a batch of stickers to hand out.
>     That's one
>     >> way, anyway :-)
>     >>
>     >> Cheers,
>     >> Tim
>     >>
>     >> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com
>     <mailto:flaper87 at gmail.com>> wrote:
>     >> >
>     >> >
>     >> >
>     >> > 2014/1/14 Gaetan <gaetan at xeberon.net <mailto:gaetan at xeberon.net>>
>     >> >>
>     >> >> Just came accross this good presentation:
>     >> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
>     >> >>
>     >> >> A question poped into my head: where could I find rust
>     stickers ?
>     >> >
>     >> >
>     >> > I was wondering the same thing! I love stickers and I
>     definitely want a
>     >> > Rust
>     >> > sticker :D
>     >> >
>     >> >
>     >> >
>     >> > --
>     >> > Flavio (@flaper87) Percoco
>     >> > http://www.flaper87.com
>     >> > http://github.com/FlaPer87
>     >> >
>     >> > _______________________________________________
>     >> > Rust-dev mailing list
>     >> > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     >> > https://mail.mozilla.org/listinfo/rust-dev
>     >> >
>     >>
>     >>
>     >>
>     >> --
>     >> Tim Chevalier * http://catamorphism.org/ * Often in error,
>     never in doubt
>     >> "If you are silent about your pain, they'll kill you and say
>     you enjoyed
>     >> it."
>     >> -- Zora Neale Hurston
>     >> _______________________________________________
>     >> Rust-dev mailing list
>     >> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     >> https://mail.mozilla.org/listinfo/rust-dev
>     >
>     >
>     >
>     >
>     > --
>     > Tony Arcieri
>     >
>     > _______________________________________________
>     > Rust-dev mailing list
>     > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     > https://mail.mozilla.org/listinfo/rust-dev
>     >
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/d724278f/attachment.html>

From banderson at mozilla.com  Tue Jan 14 17:31:40 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 14 Jan 2014 17:31:40 -0800
Subject: [rust-dev] sticker
In-Reply-To: <52D5E4CB.7090607@mozilla.com>
References: <CANK7tAFryXbOS_7VoiExQCjncQvjjv=myN383AMAJ-sL8n3H1w@mail.gmail.com>	<CAMOT3C3rLdk6LxnVNc01FwvFcLsanz+eh7vKbGSfkFqzsWXH_A@mail.gmail.com>	<CADcg8=mqB2hJvjbhNHwTRK=26uw4pbqhamNuTGvhDY0JFXSuzA@mail.gmail.com>	<CAHOTMVJRawboDZuf-MP5v0JeoSwf0bfMKcc3X0+p3HK-eZSwSw@mail.gmail.com>	<CAMYrfj+rbHT5oKr+o=thOS6jGpT7WNXiZVX0OWK4FnJifxjZ_w@mail.gmail.com>	<CAGVmt0WTgfS57XfXmBhaAF7=2kz5SR8pPQGsyGoXiU_QaPYFRw@mail.gmail.com>
	<52D5E4CB.7090607@mozilla.com>
Message-ID: <52D5E4FC.4020509@mozilla.com>

Tell me how many you need (if you want a lot then maybe mention why) and 
a shipping address.

On 01/14/2014 05:30 PM, Brian Anderson wrote:
> People that need Rust stickers can send me an email off-list.
>
> On 01/14/2014 03:45 PM, Christopher Meiklejohn wrote:
>> Who do we contact if we're running a meetup?  I'm in the process of 
>> organizing one in Providence, RI currently.
>>
>> - Chris
>>
>>
>> On Tue, Jan 14, 2014 at 6:43 PM, Matthew McPherrin 
>> <mozilla at mcpherrin.ca <mailto:mozilla at mcpherrin.ca>> wrote:
>>
>>     I've heard continual rumours a proper Mozilla / Firefox store is
>>     coming alive again: Maybe somebody at MoCo can prod and see if it's
>>     possible to get some Rust schwag in that.
>>
>>     On Tue, Jan 14, 2014 at 10:37 AM, Tony Arcieri <bascule at gmail.com
>>     <mailto:bascule at gmail.com>> wrote:
>>     > Have you considered selling the stickers through something like
>>     DevSwag.com?
>>     > I'm sure Yehuda can get you connected ;)
>>     >
>>     >
>>     > On Tue, Jan 14, 2014 at 10:25 AM, Tim Chevalier
>>     <catamorphism at gmail.com <mailto:catamorphism at gmail.com>>
>>     > wrote:
>>     >>
>>     >> If you organize a Rust meetup near you and email Brian
>>     Anderson or one
>>     >> of the other core Rust developers who work for Mozilla, I
>>     suspect they
>>     >> would be happy to send you a batch of stickers to hand out.
>>     That's one
>>     >> way, anyway :-)
>>     >>
>>     >> Cheers,
>>     >> Tim
>>     >>
>>     >> On Tue, Jan 14, 2014 at 9:53 AM, Flaper87 <flaper87 at gmail.com
>>     <mailto:flaper87 at gmail.com>> wrote:
>>     >> >
>>     >> >
>>     >> >
>>     >> > 2014/1/14 Gaetan <gaetan at xeberon.net
>>     <mailto:gaetan at xeberon.net>>
>>     >> >>
>>     >> >> Just came accross this good presentation:
>>     >> >> http://www.youtube.com/watch?v=gfCtbGiHcg0
>>     >> >>
>>     >> >> A question poped into my head: where could I find rust
>>     stickers ?
>>     >> >
>>     >> >
>>     >> > I was wondering the same thing! I love stickers and I
>>     definitely want a
>>     >> > Rust
>>     >> > sticker :D
>>     >> >
>>     >> >
>>     >> >
>>     >> > --
>>     >> > Flavio (@flaper87) Percoco
>>     >> > http://www.flaper87.com
>>     >> > http://github.com/FlaPer87
>>     >> >
>>     >> > _______________________________________________
>>     >> > Rust-dev mailing list
>>     >> > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     >> > https://mail.mozilla.org/listinfo/rust-dev
>>     >> >
>>     >>
>>     >>
>>     >>
>>     >> --
>>     >> Tim Chevalier * http://catamorphism.org/ * Often in error,
>>     never in doubt
>>     >> "If you are silent about your pain, they'll kill you and say
>>     you enjoyed
>>     >> it."
>>     >> -- Zora Neale Hurston
>>     >> _______________________________________________
>>     >> Rust-dev mailing list
>>     >> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     >> https://mail.mozilla.org/listinfo/rust-dev
>>     >
>>     >
>>     >
>>     >
>>     > --
>>     > Tony Arcieri
>>     >
>>     > _______________________________________________
>>     > Rust-dev mailing list
>>     > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     > https://mail.mozilla.org/listinfo/rust-dev
>>     >
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/5c3c1553/attachment-0001.html>

From banderson at mozilla.com  Tue Jan 14 19:28:55 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 14 Jan 2014 19:28:55 -0800
Subject: [rust-dev] Call for central external packages repository
In-Reply-To: <CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>
References: <CANK7tAGAbV1Ub+2xKjir2nEVVjUJbSLkobuL3PRH_yGwqOMV+Q@mail.gmail.com>
	<CAJr2aW6bL3j4_QLwQP=KksLQnvEnoS3R-ZnoP2aAHL6bWxt45Q@mail.gmail.com>
Message-ID: <52D60077.6030409@mozilla.com>

This sounds very promising. Like Gaetan, I believe that a central 
package database is a critical piece of infrastructure for the Rust 
community. I haven't made any effort in this direction yet because our 
packaging tool isn't ready, but I fully encourage people to work on 
this. The rust issue is https://github.com/mozilla/rust/issues/10041.

On 01/13/2014 03:09 AM, Hans J?rgen Hoel wrote:
> Hi,
>
> Regarding rust-ci, I'm about to deploy some changes for it sometime in 
> the next few days.
>
> Changes will include:
>
> - project editing enabled (including removal of projects :))
> - possibility for adding categories to projects and a category based index
> - documentation upload from Travis CI builds (by adding two lines to 
> the .travis.yml)
>
> I've also started working on search which would index project 
> descriptions, uploaded documentation and sources.
>
> Source for the webapp will be available on GitHub soon if anyone is 
> interested in collaborating.
>
> Regards,
>
> Hans J?rgen
>
>
> On 13 January 2014 11:43, Gaetan <gaetan at xeberon.net 
> <mailto:gaetan at xeberon.net>> wrote:
>
>     Hi
>
>     I know this question has been debated, however I'd like to highly
>     recommend to give a clean infrastructure to register, list, search
>     and describe external libraries developed by everyone.
>
>     For instance, how do I know which http server lib should I use for
>     rust 0.9?
>
>     This mailing list is quite good for announcing new package, but
>     not for find existing project that might have solved a given
>     problem before me.
>
>     rust-ci
>     --------
>
>     This is the main candidate for this job, however I find it quite
>     difficult to find which project does what. It miss a "one line
>     project description" column. Its main purpose seem to watch for
>     this set of projects still compile against the master git branch,
>     but there are other lib that are not listed here.
>
>     I would recommend a central repository web site, working like pypi
>     or other community based repo, that would stimulate user contribution.
>
>     Such central repository would provide the following features:
>     - hierarchical project organisation (look at here
>     <https://pypi.python.org/pypi?%3Aaction=browse>)
>     - provide clean forms to submit, review, publish, vote project
>     - clealy display which version of rust compiler (0.8, 0.9,
>     master,...) this lib is validated. For master, this would be
>     linked to rust-ci. I also like the idea of having automatic
>     rust-ci validation for rust 0.8, 0.9,... Maybe with several level
>     of validation: compile validated, peer/administrator validated,
>     recommended,...
>     - good search form. This is how users look for a given project
>     - popular project. I tend to choose a project over its popularity.
>     The more "popular" a project is, or the more downloads count a lib
>     have, the more I think it will be actively maintained or more
>     stable than the others.
>     - clear project dependency listing
>     - be promoted by rust homepage (repo.rust.org
>     <http://repo.rust.org>? rustpkg.rust.org
>     <http://rustpkg.rust.org>,...?), so any lambda user can easy find it
>
>     At first sight, I think we could just extending rust-ci to do
>     this, reoriented for package listing for a given rust version, by
>     adding new pages "package index for 0.9" with just a project name
>     column ("rust-http" and not "chris-morgan/rust-http
>     <https://github.com/chris-morgan/rust-http>") and a description
>     column (extracted from github project description?.. this also
>     force to have to be on github for any project?). And what about
>     tarball or non github project?
>
>     What do you think about this idea? I am interested on working on
>     this matter, but would like to have your opinion on it.
>
>     Thanks
>     -----
>     Gaetan
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/2e0b902b/attachment.html>

From ecreed at cs.washington.edu  Tue Jan 14 21:10:49 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 21:10:49 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
Message-ID: <CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>

How would that make us lose stack allocated return values?


On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:

> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
> > `SharedChan`?
>
> I suppose the main downside of that solution is that you lose stack
> allocated return values.
>
> jack.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/8bee90f9/attachment.html>

From jack at metajack.im  Tue Jan 14 21:20:36 2014
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 14 Jan 2014 22:20:36 -0700
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
Message-ID: <CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>

You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
Well, unless DST fixes this. I assume this is the same reason we
return specific instances of iterators instead of an Iteratable trait
object.

jack.

On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu> wrote:
> How would that make us lose stack allocated return values?
>
>
> On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:
>>
>> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
>> > `SharedChan`?
>>
>> I suppose the main downside of that solution is that you lose stack
>> allocated return values.
>>
>> jack.
>
>

From ecreed at cs.washington.edu  Tue Jan 14 21:21:37 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 21:21:37 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
	<CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
Message-ID: <CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>

fn foo<T: Trait>() -> T


On Tue, Jan 14, 2014 at 9:20 PM, Jack Moffitt <jack at metajack.im> wrote:

> You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
> Well, unless DST fixes this. I assume this is the same reason we
> return specific instances of iterators instead of an Iteratable trait
> object.
>
> jack.
>
> On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu>
> wrote:
> > How would that make us lose stack allocated return values?
> >
> >
> > On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:
> >>
> >> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
> >> > `SharedChan`?
> >>
> >> I suppose the main downside of that solution is that you lose stack
> >> allocated return values.
> >>
> >> jack.
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/e9e41696/attachment.html>

From ecreed at cs.washington.edu  Tue Jan 14 21:26:22 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 21:26:22 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
	<CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
	<CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>
Message-ID: <CANbMr6HVweq_iR=4=t5hixe1CYxFT8QejZVZN4i3SsHM6Yv2dg@mail.gmail.com>

As a follow up, what situation would arise where you'd have to actually
return a Chan trait object?
Constructors are going to return the concrete type UniqueChan/SharedChan.
Functions acting on channels can just use generics, which will allow
returning.


On Tue, Jan 14, 2014 at 9:21 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> fn foo<T: Trait>() -> T
>
>
> On Tue, Jan 14, 2014 at 9:20 PM, Jack Moffitt <jack at metajack.im> wrote:
>
>> You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
>> Well, unless DST fixes this. I assume this is the same reason we
>> return specific instances of iterators instead of an Iteratable trait
>> object.
>>
>> jack.
>>
>> On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu>
>> wrote:
>> > How would that make us lose stack allocated return values?
>> >
>> >
>> > On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:
>> >>
>> >> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
>> >> > `SharedChan`?
>> >>
>> >> I suppose the main downside of that solution is that you lose stack
>> >> allocated return values.
>> >>
>> >> jack.
>> >
>> >
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/b5cd3482/attachment-0001.html>

From jack at metajack.im  Tue Jan 14 21:41:58 2014
From: jack at metajack.im (Jack Moffitt)
Date: Tue, 14 Jan 2014 22:41:58 -0700
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6HVweq_iR=4=t5hixe1CYxFT8QejZVZN4i3SsHM6Yv2dg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
	<CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
	<CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>
	<CANbMr6HVweq_iR=4=t5hixe1CYxFT8QejZVZN4i3SsHM6Yv2dg@mail.gmail.com>
Message-ID: <CAP7VpsXJQDt7fKA3ZAYHpvetQuT_rjeKu250mZ5y3ag67twFgg@mail.gmail.com>

You can't promote a Chan to a SharedChan currently (like you could
with the old API), so if the caller needs to make the decision, all
the APIs will have to return SharedChan to be flexible. I don't think
traits help with that problem (they do help with passing in Chans). If
we want flexible APIs that returns Chans, we need promotion of some
kind.

I think I misspoke before. The core issue is cognitive load of 3
channel types. Auto-promoting Chan to shared Chan reduces the number
of channels (less API surface) and makes channels just work (never
have to think about whether Chans are clonable). That seems a
compelling combo. I was just focused more on the latter use case.

jack.

On Tue, Jan 14, 2014 at 10:26 PM, Eric Reed <ecreed at cs.washington.edu> wrote:
> As a follow up, what situation would arise where you'd have to actually
> return a Chan trait object?
> Constructors are going to return the concrete type UniqueChan/SharedChan.
> Functions acting on channels can just use generics, which will allow
> returning.
>
>
> On Tue, Jan 14, 2014 at 9:21 PM, Eric Reed <ecreed at cs.washington.edu> wrote:
>>
>> fn foo<T: Trait>() -> T
>>
>>
>> On Tue, Jan 14, 2014 at 9:20 PM, Jack Moffitt <jack at metajack.im> wrote:
>>>
>>> You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
>>> Well, unless DST fixes this. I assume this is the same reason we
>>> return specific instances of iterators instead of an Iteratable trait
>>> object.
>>>
>>> jack.
>>>
>>> On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu>
>>> wrote:
>>> > How would that make us lose stack allocated return values?
>>> >
>>> >
>>> > On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:
>>> >>
>>> >> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
>>> >> > `SharedChan`?
>>> >>
>>> >> I suppose the main downside of that solution is that you lose stack
>>> >> allocated return values.
>>> >>
>>> >> jack.
>>> >
>>> >
>>
>>
>

From corey at octayn.net  Tue Jan 14 22:34:04 2014
From: corey at octayn.net (Corey Richardson)
Date: Wed, 15 Jan 2014 01:34:04 -0500
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5CE1E.7050601@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
Message-ID: <CA++BO6TCiuA41PzpB-wggOkfUM2xs5n3qOLttjM7gDZZsSeX4g@mail.gmail.com>

On Tue, Jan 14, 2014 at 6:54 PM, Lee Braiden <leebraid at gmail.com> wrote:
> On 14/01/14 23:43, Corey Richardson wrote:
>>
>> This thread is deviating from its purpose. The idea isn't to hash out a
>> generic build system for all of Rust, merely for the compiler + stdlib.
>
>
> I think it naturally progressed, because some people wanted to discuss a
> more generic solution.
>
> But fair enough... if the only goal is to build rust, I've very little
> preference, except to say:
>

I don't mean to squash discussion. I think the build system the wider
ecosystem uses is important. But that can happen in another thread;
this RFC is unrelated and has a much narrow scope and wider set of
requirements.

>From the thread I it seems we want a custom solution, in Rust, that
plugs into something like Ninja. I think our dep management is simple
enough that this can work very well. (In particular, we don't have the
madness of header deps + each file being a compilation unit)

From ecreed at cs.washington.edu  Tue Jan 14 23:06:17 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 14 Jan 2014 23:06:17 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAP7VpsXJQDt7fKA3ZAYHpvetQuT_rjeKu250mZ5y3ag67twFgg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
	<CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
	<CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>
	<CANbMr6HVweq_iR=4=t5hixe1CYxFT8QejZVZN4i3SsHM6Yv2dg@mail.gmail.com>
	<CAP7VpsXJQDt7fKA3ZAYHpvetQuT_rjeKu250mZ5y3ag67twFgg@mail.gmail.com>
Message-ID: <CANbMr6Gw-=Qwh0m=VmiA1YCBzD=4FkYTan-H40V0Vy21_p10UA@mail.gmail.com>

I was working under the assumption that we'd add UniqueChan -> SharedChan
promotion back. I assumed that would be possible since a unified Chan would
be doing it internally.

Does an auto-promoting Chan really do that much for reducing cognitive
load?
The only thing the programmer can skip understanding with a unified Chan is
the whether to choose between cloneable and uncloneable channels, which
isn't very much.
It seems like a pretty significant departure from how Rust approaches this
kind of thing elsewhere (i.e. memory allocation and threading model being
the two things that come to mind).
I'm just skeptical that the cognitive load reduction outweighs the
information loss.


On Tue, Jan 14, 2014 at 9:41 PM, Jack Moffitt <jack at metajack.im> wrote:

> You can't promote a Chan to a SharedChan currently (like you could
> with the old API), so if the caller needs to make the decision, all
> the APIs will have to return SharedChan to be flexible. I don't think
> traits help with that problem (they do help with passing in Chans). If
> we want flexible APIs that returns Chans, we need promotion of some
> kind.
>
> I think I misspoke before. The core issue is cognitive load of 3
> channel types. Auto-promoting Chan to shared Chan reduces the number
> of channels (less API surface) and makes channels just work (never
> have to think about whether Chans are clonable). That seems a
> compelling combo. I was just focused more on the latter use case.
>
> jack.
>
> On Tue, Jan 14, 2014 at 10:26 PM, Eric Reed <ecreed at cs.washington.edu>
> wrote:
> > As a follow up, what situation would arise where you'd have to actually
> > return a Chan trait object?
> > Constructors are going to return the concrete type UniqueChan/SharedChan.
> > Functions acting on channels can just use generics, which will allow
> > returning.
> >
> >
> > On Tue, Jan 14, 2014 at 9:21 PM, Eric Reed <ecreed at cs.washington.edu>
> wrote:
> >>
> >> fn foo<T: Trait>() -> T
> >>
> >>
> >> On Tue, Jan 14, 2014 at 9:20 PM, Jack Moffitt <jack at metajack.im> wrote:
> >>>
> >>> You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
> >>> Well, unless DST fixes this. I assume this is the same reason we
> >>> return specific instances of iterators instead of an Iteratable trait
> >>> object.
> >>>
> >>> jack.
> >>>
> >>> On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu>
> >>> wrote:
> >>> > How would that make us lose stack allocated return values?
> >>> >
> >>> >
> >>> > On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im>
> wrote:
> >>> >>
> >>> >> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
> >>> >> > `SharedChan`?
> >>> >>
> >>> >> I suppose the main downside of that solution is that you lose stack
> >>> >> allocated return values.
> >>> >>
> >>> >> jack.
> >>> >
> >>> >
> >>
> >>
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140114/d4a190aa/attachment.html>

From leebraid at gmail.com  Wed Jan 15 01:30:35 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Wed, 15 Jan 2014 09:30:35 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6TCiuA41PzpB-wggOkfUM2xs5n3qOLttjM7gDZZsSeX4g@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<CA++BO6TCiuA41PzpB-wggOkfUM2xs5n3qOLttjM7gDZZsSeX4g@mail.gmail.com>
Message-ID: <52D6553B.8040808@gmail.com>

On 15/01/14 06:34, Corey Richardson wrote:
> On Tue, Jan 14, 2014 at 6:54 PM, Lee Braiden <leebraid at gmail.com> wrote:
>> On 14/01/14 23:43, Corey Richardson wrote:
>>> This thread is deviating from its purpose. The idea isn't to hash out a
>>> generic build system for all of Rust, merely for the compiler + stdlib.
>>
>> I think it naturally progressed, because some people wanted to discuss a
>> more generic solution.
>>
>> But fair enough... if the only goal is to build rust, I've very little
>> preference, except to say:
>>
> I don't mean to squash discussion. I think the build system the wider
> ecosystem uses is important. But that can happen in another thread;
> this RFC is unrelated and has a much narrow scope and wider set of
> requirements.
>
>  From the thread I it seems we want a custom solution, in Rust, that
> plugs into something like Ninja. I think our dep management is simple
> enough that this can work very well. (In particular, we don't have the
> madness of header deps + each file being a compilation unit)

For the Rust toolchain's purposes, we could write a simple script to 
generate template-based "buildfiles" (for want of a better word) for 
one/more build tools (depending on whether you want to generate all and 
have them choose, or generate the first that seems sensible for that 
platform / available tools on system): make, XCode, Visual Studio...

I'm thinking of a file with a few variables, and a script that applies 
those to a template, perhaps with a bit of logic to decide which 
template to use, and which output filename to generate, and perhaps 
adding a few variables gleaned from the system / command line, at runtime.

Probably 100 lines of python, plus templates; a bit more to make it 
highly usable.  Not sure what the equivalent would be in Rust code, as 
I'm still fairly new to it.

I think the first step to getting a build tool written in rust though, 
would be to bring back the "rust run" command.

-- 
Lee


From irrequietus at gmail.com  Wed Jan 15 01:38:19 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Wed, 15 Jan 2014 09:38:19 -0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
Message-ID: <29dd027d-c581-48eb-a773-e7430a387e92@email.android.com>

This is why I am reserving commentation right now and have been consistently asking about Rust providing a build system in all other emails.  Can the other commenters refocus with the rest of us back to the original question?

Corey Richardson <corey at octayn.net> wrote:
>On Tue, Jan 14, 2014 at 5:33 PM, Lee Braiden <leebraid at gmail.com>
>wrote:
>> Another point is that we don't really need a massively complicated
>"build
>> system" right now, as far as I know.
>>
>> I don't know rust well yet, but it's a two-line script to load this
>data
>> (excluding comments).  Another few lines to figure out whether to
>build a
>> library or an executable, another few to run rustc with the list of
>files,
>> OR to output that list to a Makefile, or a CMakeList.txt, or an IDE
>project
>> file.
>>
>
>This thread is deviating from its purpose. The idea isn't to hash out
>a generic build system for all of Rust, merely for the compiler +
>stdlib.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/7f4f5707/attachment.html>

From robertknight at gmail.com  Wed Jan 15 02:06:46 2014
From: robertknight at gmail.com (Robert Knight)
Date: Wed, 15 Jan 2014 10:06:46 +0000
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <29dd027d-c581-48eb-a773-e7430a387e92@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<29dd027d-c581-48eb-a773-e7430a387e92@email.android.com>
Message-ID: <CAJGrnh2iAJkgHf3-Xea4hdrad6Vyudg3SAj9PJ5nMvybYPVEbw@mail.gmail.com>

 > Probably 100 lines of python, plus templates; a bit more to make it
highly usable.  Not sure what the equivalent would be in Rust code, as
I'm still fairly new to it.

Maybe the initial version - then you add logic to deal with different
versions of Xcode/Visual Studio etc, then some more logic to find
different packages that rust requires to build on a multitude of
systems etc. etc.

Sometimes you can get away writing something new and simple that just
deals with your use case (building Rust here). The problem is if you
end up with lots of feature creep re-discovering all the knowledge
that is encoded in existing tools - eg. the many modules for config
checks, locating packages etc. that come with CMake, automake, SCons
etc.

By all means, have a go at writing that initial version and see how
well it serves you - but be prepared to switch if it looks like you
are re-inventing something that already exists.

On 21 October 2013 12:43, George Makrydakis <irrequietus at gmail.com> wrote:
> This is why I am reserving commentation right now and have been consistently
> asking about Rust providing a build system in all other emails.  Can the
> other commenters refocus with the rest of us back to the original question?
>
>
>
> Corey Richardson <corey at octayn.net> wrote:
>>
>> On Tue, Jan 14, 2014 at 5:33 PM, Lee Braiden <leebraid at gmail.com> wrote:
>>>
>>>  Another point is that we don't really need a massively complicated
>>> "build
>>>  system" right now, as far as I know.
>>>
>>>  I don't know rust well yet, but it's a two-line script to load this data
>>>  (excluding comments).  Another few lines to figure out whether to build
>>> a
>>>  library or an executable, another few to run rustc with the list of
>>> files,
>>>  OR to output that list to a Makefile, or a CMakeList.txt, or an IDE
>>> project
>>>  file.
>>
>>
>>
>> This thread is deviating from its purpose. The idea isn't to hash out
>> a generic build system for all of Rust, merely for the compiler +
>> stdlib.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Wed Jan 15 02:08:27 2014
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 15 Jan 2014 11:08:27 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAJGrnh2iAJkgHf3-Xea4hdrad6Vyudg3SAj9PJ5nMvybYPVEbw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<29dd027d-c581-48eb-a773-e7430a387e92@email.android.com>
	<CAJGrnh2iAJkgHf3-Xea4hdrad6Vyudg3SAj9PJ5nMvybYPVEbw@mail.gmail.com>
Message-ID: <CANK7tAGhN0vJBEExV+V5QcMFFAaqQNv-Hiyd5mXFKX2hqMuRWQ@mail.gmail.com>

I agree. If you take this path, use Cmake or scons.

-----
Gaetan



2014/1/15 Robert Knight <robertknight at gmail.com>

>  > Probably 100 lines of python, plus templates; a bit more to make it
> highly usable.  Not sure what the equivalent would be in Rust code, as
> I'm still fairly new to it.
>
> Maybe the initial version - then you add logic to deal with different
> versions of Xcode/Visual Studio etc, then some more logic to find
> different packages that rust requires to build on a multitude of
> systems etc. etc.
>
> Sometimes you can get away writing something new and simple that just
> deals with your use case (building Rust here). The problem is if you
> end up with lots of feature creep re-discovering all the knowledge
> that is encoded in existing tools - eg. the many modules for config
> checks, locating packages etc. that come with CMake, automake, SCons
> etc.
>
> By all means, have a go at writing that initial version and see how
> well it serves you - but be prepared to switch if it looks like you
> are re-inventing something that already exists.
>
> On 21 October 2013 12:43, George Makrydakis <irrequietus at gmail.com> wrote:
> > This is why I am reserving commentation right now and have been
> consistently
> > asking about Rust providing a build system in all other emails.  Can the
> > other commenters refocus with the rest of us back to the original
> question?
> >
> >
> >
> > Corey Richardson <corey at octayn.net> wrote:
> >>
> >> On Tue, Jan 14, 2014 at 5:33 PM, Lee Braiden <leebraid at gmail.com>
> wrote:
> >>>
> >>>  Another point is that we don't really need a massively complicated
> >>> "build
> >>>  system" right now, as far as I know.
> >>>
> >>>  I don't know rust well yet, but it's a two-line script to load this
> data
> >>>  (excluding comments).  Another few lines to figure out whether to
> build
> >>> a
> >>>  library or an executable, another few to run rustc with the list of
> >>> files,
> >>>  OR to output that list to a Makefile, or a CMakeList.txt, or an IDE
> >>> project
> >>>  file.
> >>
> >>
> >>
> >> This thread is deviating from its purpose. The idea isn't to hash out
> >> a generic build system for all of Rust, merely for the compiler +
> >> stdlib.
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/12c0acf8/attachment.html>

From irrequietus at gmail.com  Wed Jan 15 02:17:06 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Wed, 15 Jan 2014 12:17:06 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAJGrnh2iAJkgHf3-Xea4hdrad6Vyudg3SAj9PJ5nMvybYPVEbw@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<29dd027d-c581-48eb-a773-e7430a387e92@email.android.com>
	<CAJGrnh2iAJkgHf3-Xea4hdrad6Vyudg3SAj9PJ5nMvybYPVEbw@mail.gmail.com>
Message-ID: <c69f96fd-fd35-49d7-9544-eff9ac9ebffe@email.android.com>

As Corey Richardson already said, the threads in these posts are deviating from their intended purpose.

Can we talk again about what the system used for building the Rust compiler and standard library should eventually be ?

It is as if we are discussing several, unrelated issues at once.


Robert Knight <robertknight at gmail.com> wrote:
> > Probably 100 lines of python, plus templates; a bit more to make it
>highly usable.  Not sure what the equivalent would be in Rust code, as
>I'm still fairly new to it.
>
>Maybe the initial version - then you add logic to deal with different
>versions of Xcode/Visual Studio etc, then some more logic to find
>different packages that rust requires to build on a multitude of
>systems etc. etc.
>
>Sometimes you can get away writing something new and simple that just
>deals with your use case (building Rust here). The problem is if you
>end up with lots of feature creep re-discovering all the knowledge
>that is encoded in existing tools - eg. the many modules for config
>checks, locating packages etc. that come with CMake, automake, SCons
>etc.
>
>By all means, have a go at writing that initial version and see how
>well it serves you - but be prepared to switch if it looks like you
>are re-inventing something that already exists.
>
>On 21 October 2013 12:43, George Makrydakis <irrequietus at gmail.com>
>wrote:
>> This is why I am reserving commentation right now and have been
>consistently
>> asking about Rust providing a build system in all other emails.  Can
>the
>> other commenters refocus with the rest of us back to the original
>question?
>>
>>
>>
>> Corey Richardson <corey at octayn.net> wrote:
>>>
>>> On Tue, Jan 14, 2014 at 5:33 PM, Lee Braiden <leebraid at gmail.com>
>wrote:
>>>>
>>>>  Another point is that we don't really need a massively complicated
>>>> "build
>>>>  system" right now, as far as I know.
>>>>
>>>>  I don't know rust well yet, but it's a two-line script to load
>this data
>>>>  (excluding comments).  Another few lines to figure out whether to
>build
>>>> a
>>>>  library or an executable, another few to run rustc with the list
>of
>>>> files,
>>>>  OR to output that list to a Makefile, or a CMakeList.txt, or an
>IDE
>>>> project
>>>>  file.
>>>
>>>
>>>
>>> This thread is deviating from its purpose. The idea isn't to hash
>out
>>> a generic build system for all of Rust, merely for the compiler +
>>> stdlib.
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/edefe42e/attachment.html>

From irrequietus at gmail.com  Wed Jan 15 02:18:55 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Wed, 15 Jan 2014 12:18:55 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CA++BO6TCiuA41PzpB-wggOkfUM2xs5n3qOLttjM7gDZZsSeX4g@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<CA++BO6TCiuA41PzpB-wggOkfUM2xs5n3qOLttjM7gDZZsSeX4g@mail.gmail.com>
Message-ID: <2a28d123-e26b-41ed-b76e-5219b18e5eca@email.android.com>

+1, even more than that.

Corey Richardson <corey at octayn.net> wrote:
>On Tue, Jan 14, 2014 at 6:54 PM, Lee Braiden <leebraid at gmail.com>
>wrote:
>> On 14/01/14 23:43, Corey Richardson wrote:
>>>
>>> This thread is deviating from its purpose. The idea isn't to hash
>out a
>>> generic build system for all of Rust, merely for the compiler +
>stdlib.
>>
>>
>> I think it naturally progressed, because some people wanted to
>discuss a
>> more generic solution.
>>
>> But fair enough... if the only goal is to build rust, I've very
>little
>> preference, except to say:
>>
>
>I don't mean to squash discussion. I think the build system the wider
>ecosystem uses is important. But that can happen in another thread;
>this RFC is unrelated and has a much narrow scope and wider set of
>requirements.
>
>From the thread I it seems we want a custom solution, in Rust, that
>plugs into something like Ninja. I think our dep management is simple
>enough that this can work very well. (In particular, we don't have the
>madness of header deps + each file being a compilation unit)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/623a99e7/attachment-0001.html>

From irrequietus at gmail.com  Wed Jan 15 03:05:28 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Wed, 15 Jan 2014 13:05:28 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <52D5CE1E.7050601@gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
Message-ID: <4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>

As an interim solution, any proven build system will do regardless of preference. Given the current status quo of Rust's evolving condition, the choice should weigh on the side compatible with what the core developers use since they build way too often.

Simplify the build process by reducing number of tools required, going towards a single tool if possible. That would make the option of "rusting" an alternative, future solution far easier to adopt if that would still be an option.

Should a poll be made instead of these threads?


Lee Braiden <leebraid at gmail.com> wrote:
>On 14/01/14 23:43, Corey Richardson wrote:
>> This thread is deviating from its purpose. The idea isn't to hash out
>
>> a generic build system for all of Rust, merely for the compiler +
>stdlib. 
>
>I think it naturally progressed, because some people wanted to discuss
>a 
>more generic solution.
>
>But fair enough... if the only goal is to build rust, I've very little 
>preference, except to say:
>
>Please choose something cross-platform that's as standard as possible, 
>and leads to builds as simple as "make" or "configure && make" or 
>something along those lines.
>
>At the outside, CMake's "cmake -G 'Unix Makefiles' etc. is tolerable 
>(for me), in the name of supporting IDE users.
>
>
>-- 
>Lee
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/f56c41a6/attachment.html>

From gaetan at xeberon.net  Wed Jan 15 05:46:58 2014
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 15 Jan 2014 14:46:58 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
Message-ID: <CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>

To answer to this RFC, I don't see what will be improved if cmake where
used. The makefile macro may be rewritten in CMakeList.txt stuff, but this
will still generate makefiles and thus don't solve the compilation time.

I'm curious about
ninja<http://martine.github.io/ninja/manual.html#_philosophical_overview>,
it is its promise to provide a simple, clean, super-fast Make. It has been
made to replace the old Makefiles and even scons files to build google
chrome.

And moreover, it follows the UNIX principles: do one thing but do it well.
It's adviced to use a "meta build" sytem like CMake or gyp. Does anyone has
ever used ninja intensively?
And then, a rust meta build program could be written to replace this
metabuilder (i.e. cmake), without having to rewrite the complete ninja
layer (I suppose there will be some ninja module to write to answer some
issues).
And see if at the end the ninja build layer can be replaced completely by a
rust one.

Arg, as I unroll my idea i see that it is exactly the proposal 3 in the
original email...

For me, poll will not give the necessary feedback about any system, merely
personal point of view. Maybe it's a good start. A good "deliverable"
should be to generate some small reports with "presentation, pro, cons..."
the most applicable to the compilation of the rust compiler and then vote
can happen.
I've opened a doodle here <http://doodle.com/3ngkb9ms9gt2qrap>.

-----
Gaetan



2014/1/15 George Makrydakis <irrequietus at gmail.com>

> As an interim solution, any proven build system will do regardless of
> preference. Given the current status quo of Rust's evolving condition, the
> choice should weigh on the side compatible with what the core developers
> use since they build way too often.
>
> Simplify the build process by reducing number of tools required, going
> towards a single tool if possible. That would make the option of "rusting"
> an alternative, future solution far easier to adopt if that would still be
> an option.
>
> Should a poll be made instead of these threads?
>
>
> Lee Braiden <leebraid at gmail.com> wrote:
>>
>> On 14/01/14 23:43, Corey Richardson wrote:
>>
>>>  This thread is deviating from its purpose. The idea isn't to hash out
>>>
>>>  a generic build system for all of Rust, merely for the compiler + stdlib.
>>>
>>
>> I think it naturally progressed, because some people wanted to discuss a
>> more generic solution.
>>
>> But fair enough... if the only goal is to build rust, I've very little
>>
>> preference, except to say:
>>
>> Please choose something cross-platform that's as standard as possible,
>> and leads to builds as simple as "make" or "configure && make" or
>> something along those lines.
>>
>> At the outside, CMake's "cmake -G 'Unix Makefiles' etc. is tolerable
>> (for me), in the name of supporting IDE users.
>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/944e1fa9/attachment.html>

From irrequietus at gmail.com  Wed Jan 15 05:56:14 2014
From: irrequietus at gmail.com (George Makrydakis)
Date: Wed, 15 Jan 2014 15:56:14 +0200
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
	<CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
Message-ID: <5abd605c-018a-4601-afed-98917db2a37c@email.android.com>

For what concerns the entire discussion so far, I think that ninja would be an excellent suggestion as a starting point in cleaning up the build process for both Rust compiler and the standard library.

Because of such a refactoring, what could follow afterwards (post - 1.0 likely) could undoubtedly have better chances in being even cleaner and more useful for both compiler and standard library building.

Under current circumstances, it is an alternative with merit.


Gaetan <gaetan at xeberon.net> wrote:
>To answer to this RFC, I don't see what will be improved if cmake where
>used. The makefile macro may be rewritten in CMakeList.txt stuff, but
>this
>will still generate makefiles and thus don't solve the compilation
>time.
>
>I'm curious about
>ninja<http://martine.github.io/ninja/manual.html#_philosophical_overview>,
>it is its promise to provide a simple, clean, super-fast Make. It has
>been
>made to replace the old Makefiles and even scons files to build google
>chrome.
>
>And moreover, it follows the UNIX principles: do one thing but do it
>well.
>It's adviced to use a "meta build" sytem like CMake or gyp. Does anyone
>has
>ever used ninja intensively?
>And then, a rust meta build program could be written to replace this
>metabuilder (i.e. cmake), without having to rewrite the complete ninja
>layer (I suppose there will be some ninja module to write to answer
>some
>issues).
>And see if at the end the ninja build layer can be replaced completely
>by a
>rust one.
>
>Arg, as I unroll my idea i see that it is exactly the proposal 3 in the
>original email...
>
>For me, poll will not give the necessary feedback about any system,
>merely
>personal point of view. Maybe it's a good start. A good "deliverable"
>should be to generate some small reports with "presentation, pro,
>cons..."
>the most applicable to the compilation of the rust compiler and then
>vote
>can happen.
>I've opened a doodle here <http://doodle.com/3ngkb9ms9gt2qrap>.
>
>-----
>Gaetan
>
>
>
>2014/1/15 George Makrydakis <irrequietus at gmail.com>
>
>> As an interim solution, any proven build system will do regardless of
>> preference. Given the current status quo of Rust's evolving
>condition, the
>> choice should weigh on the side compatible with what the core
>developers
>> use since they build way too often.
>>
>> Simplify the build process by reducing number of tools required,
>going
>> towards a single tool if possible. That would make the option of
>"rusting"
>> an alternative, future solution far easier to adopt if that would
>still be
>> an option.
>>
>> Should a poll be made instead of these threads?
>>
>>
>> Lee Braiden <leebraid at gmail.com> wrote:
>>>
>>> On 14/01/14 23:43, Corey Richardson wrote:
>>>
>>>>  This thread is deviating from its purpose. The idea isn't to hash
>out
>>>>
>>>>  a generic build system for all of Rust, merely for the compiler +
>stdlib.
>>>>
>>>
>>> I think it naturally progressed, because some people wanted to
>discuss a
>>> more generic solution.
>>>
>>> But fair enough... if the only goal is to build rust, I've very
>little
>>>
>>> preference, except to say:
>>>
>>> Please choose something cross-platform that's as standard as
>possible,
>>> and leads to builds as simple as "make" or "configure && make" or
>>> something along those lines.
>>>
>>> At the outside, CMake's "cmake -G 'Unix Makefiles' etc. is tolerable
>>> (for me), in the name of supporting IDE users.
>>>
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/949657ad/attachment-0001.html>

From jack at metajack.im  Wed Jan 15 06:06:58 2014
From: jack at metajack.im (Jack Moffitt)
Date: Wed, 15 Jan 2014 07:06:58 -0700
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
	<CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
Message-ID: <CAP7VpsV4bXJcvc95zO6GcbVXJXMyB8xp1ACzuN5P=dt5fFQk7w@mail.gmail.com>

> used. The makefile macro may be rewritten in CMakeList.txt stuff, but this
> will still generate makefiles and thus don't solve the compilation time.

Our Makefiles are quite inferior to the ones that CMake generates. For
example, if you run `make` on an up to date servo tree, it takes
several seconds. If you run `make` on an up to date Servo tree where
the makefiles are generated by CMake, it is substantially faster. Like
0.3s or so. I didn't do a full port to CMake but I was surprised at
how bad our build currently was.

Not only that but our hand written Makefiles are pretty loose about
dependency calculation and tracking, especially across submodule
boundaries. There's lots of file globs and very little attention paid
to C headers. Both of these CMake solves.

The fact that we often see people getting decoder ICEs in rustc is a
testament to just how unreliable the current system is. Every new
submodule we add and every new flag just increases this problem.
Writing make abstractions is tedious an difficult. Writing them in
nearly anything else would be easier.

I mean, you are right that it won't fix LLVM optimization passes, so
the Rust compiler's build time won't change much, but the output
should be substantially more reliable. It might make a noticeable
difference to those doing a lot of compiler dev work due to the
quicker invocations of the tool.

> I'm curious about ninja, it is its promise to provide a simple, clean,
> super-fast Make. It has been made to replace the old Makefiles and even
> scons files to build google chrome.

Ninja is pretty fast, but CMake's generated Makefiles are probably not
far off on a project of our size. The place where this difference is
most noticeable is on builds of an up to date tree. One reason it is
fast, and also the reason it needs a generator, is that it makes no
decisions at runtime. There is no branching, etc, just the dependency
info and the commandlines to generate the build products.

Note that CMake also removes the need for autotools, which is a
blessing in itself. You may not like CMake's language, but I'll take
it over m4 any day.

jack.

From mneumann at ntecs.de  Wed Jan 15 06:37:03 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Wed, 15 Jan 2014 15:37:03 +0100
Subject: [rust-dev] ASCII character literals
Message-ID: <52D69D0F.9070903@ntecs.de>

Hi,

There are lots of protocols based on ASCII character representation. In 
Rust, the natural way to represent them is
by an u8 literal (optionally wrapped within std::ascii::Ascii).
What I am missing is a simple way to represent those literals in code. 
What I am doing most of the time is:

     fn read_char() -> Option<char> {
        match io.read_byte() {
          Some(b) => Some(b as char),
          None => None
       }
     }

And then use character literals in pattern matching. What I'd highly 
prefer is a way to directly repesent ASCII characters
in the code, like:

     match io.read_byte().unwrap {
         'c'_ascii => ....
        ....
     }

If macros would work in patterns, something like:

    match ... {
        ascii!('a') => ...
    }

would work for me too. Ideally that would work with range patterns as 
well, but of course an ascii_range!() macro would
do the same.

Is this useful to anyone?

Regards,

     Michael

From mneumann at ntecs.de  Wed Jan 15 07:26:31 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Wed, 15 Jan 2014 16:26:31 +0100
Subject: [rust-dev] ASCII character literals
In-Reply-To: <CAJY4u8GSL00g3Kq6O6WZZfeB_FNL4azhvx_w84rzGM5DZjUx5w@mail.gmail.com>
References: <52D69D0F.9070903@ntecs.de>
	<CAJY4u8GSL00g3Kq6O6WZZfeB_FNL4azhvx_w84rzGM5DZjUx5w@mail.gmail.com>
Message-ID: <52D6A8A7.2020900@ntecs.de>


Am 15.01.2014 16:23, schrieb Evan G:
> I'm not weighing in on whether this is something rust should do or 
> not, but we could mimic the 16i, 10u numeric literal system to achieve 
> this in syntax. An ascii literal would have a suffix, for example 'x'a 
> or 'x'u to explicitly specify unicode (which would still be the 
> default). This could probably work for string literals too.

Something like 'x'a would be very nice to have!

Regards,

   Michael

>
>
> On Wed, Jan 15, 2014 at 8:37 AM, Michael Neumann <mneumann at ntecs.de 
> <mailto:mneumann at ntecs.de>> wrote:
>
>     Hi,
>
>     There are lots of protocols based on ASCII character
>     representation. In Rust, the natural way to represent them is
>     by an u8 literal (optionally wrapped within std::ascii::Ascii).
>     What I am missing is a simple way to represent those literals in
>     code. What I am doing most of the time is:
>
>         fn read_char() -> Option<char> {
>            match io.read_byte() {
>              Some(b) => Some(b as char),
>              None => None
>           }
>         }
>
>     And then use character literals in pattern matching. What I'd
>     highly prefer is a way to directly repesent ASCII characters
>     in the code, like:
>
>         match io.read_byte().unwrap {
>             'c'_ascii => ....
>            ....
>         }
>
>     If macros would work in patterns, something like:
>
>        match ... {
>            ascii!('a') => ...
>        }
>
>     would work for me too. Ideally that would work with range patterns
>     as well, but of course an ascii_range!() macro would
>     do the same.
>
>     Is this useful to anyone?
>
>     Regards,
>
>         Michael
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/9130fd50/attachment.html>

From gaetan at xeberon.net  Wed Jan 15 07:34:29 2014
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 15 Jan 2014 16:34:29 +0100
Subject: [rust-dev] RFC: Future of the Build System
In-Reply-To: <CAP7VpsV4bXJcvc95zO6GcbVXJXMyB8xp1ACzuN5P=dt5fFQk7w@mail.gmail.com>
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<abd3881f-49dd-459f-a753-e706f989fa8d@email.android.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
	<CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
	<CAP7VpsV4bXJcvc95zO6GcbVXJXMyB8xp1ACzuN5P=dt5fFQk7w@mail.gmail.com>
Message-ID: <CANK7tAE4cPeknCEq-GA86ZsFNiKfi+4KOFCYXxxWLGLpkMWfpw@mail.gmail.com>

I just hate the "if/elseif/else" block in CMake list, that's all :)

One of the major advantage of cmake is the huge list of supported
dependency scripts that is provided out of the box. You want to use QT4 in
your software, just write 'FindPackage(QT4)'. That is a good inspiration.

-----
Gaetan



2014/1/15 Jack Moffitt <jack at metajack.im>

> > used. The makefile macro may be rewritten in CMakeList.txt stuff, but
> this
> > will still generate makefiles and thus don't solve the compilation time.
>
> Our Makefiles are quite inferior to the ones that CMake generates. For
> example, if you run `make` on an up to date servo tree, it takes
> several seconds. If you run `make` on an up to date Servo tree where
> the makefiles are generated by CMake, it is substantially faster. Like
> 0.3s or so. I didn't do a full port to CMake but I was surprised at
> how bad our build currently was.
>
> Not only that but our hand written Makefiles are pretty loose about
> dependency calculation and tracking, especially across submodule
> boundaries. There's lots of file globs and very little attention paid
> to C headers. Both of these CMake solves.
>
> The fact that we often see people getting decoder ICEs in rustc is a
> testament to just how unreliable the current system is. Every new
> submodule we add and every new flag just increases this problem.
> Writing make abstractions is tedious an difficult. Writing them in
> nearly anything else would be easier.
>
> I mean, you are right that it won't fix LLVM optimization passes, so
> the Rust compiler's build time won't change much, but the output
> should be substantially more reliable. It might make a noticeable
> difference to those doing a lot of compiler dev work due to the
> quicker invocations of the tool.
>
> > I'm curious about ninja, it is its promise to provide a simple, clean,
> > super-fast Make. It has been made to replace the old Makefiles and even
> > scons files to build google chrome.
>
> Ninja is pretty fast, but CMake's generated Makefiles are probably not
> far off on a project of our size. The place where this difference is
> most noticeable is on builds of an up to date tree. One reason it is
> fast, and also the reason it needs a generator, is that it makes no
> decisions at runtime. There is no branching, etc, just the dependency
> info and the commandlines to generate the build products.
>
> Note that CMake also removes the need for autotools, which is a
> blessing in itself. You may not like CMake's language, but I'll take
> it over m4 any day.
>
> jack.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/ebaef846/attachment.html>

From philippe.delrieu at free.fr  Wed Jan 15 08:17:25 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 15 Jan 2014 17:17:25 +0100
Subject: [rust-dev] Bitwise operations in rust.
Message-ID: <52D6B495.2080108@free.fr>

I work on the SDL2 binding and I have the following code :

pub enum SDL_WindowFlags {
     SDL_WINDOW_FULLSCREEN           = ffi::video::SDL_WINDOW_FULLSCREEN,
     SDL_WINDOW_OPENGL               = ffi::video::SDL_WINDOW_OPENGL,
     SDL_WINDOW_SHOWN                = ffi::video::SDL_WINDOW_SHOWN,
     SDL_WINDOW_HIDDEN               = ffi::video::SDL_WINDOW_HIDDEN,
     SDL_WINDOW_BORDERLESS           = ffi::video::SDL_WINDOW_BORDERLESS,
     SDL_WINDOW_RESIZABLE            = ffi::video::SDL_WINDOW_RESIZABLE,
     SDL_WINDOW_MINIMIZED            = ffi::video::SDL_WINDOW_MINIMIZED,
     SDL_WINDOW_MAXIMIZED            = ffi::video::SDL_WINDOW_MAXIMIZED,
     SDL_WINDOW_INPUT_GRABBED        = ffi::video::SDL_WINDOW_INPUT_GRABBED,
     SDL_WINDOW_INPUT_FOCUS          = ffi::video::SDL_WINDOW_INPUT_FOCUS,
     SDL_WINDOW_MOUSE_FOCUS          = ffi::video::SDL_WINDOW_MOUSE_FOCUS,
     SDL_WINDOW_FULLSCREEN_DESKTOP   = 
ffi::video::SDL_WINDOW_FULLSCREEN_DESKTOP,
     SDL_WINDOW_FOREIGN              = ffi::video::SDL_WINDOW_FOREIGN,
}

impl SDL_WindowFlags {
     pub fn fold_bits(flags: &[SDL_WindowFlags]) -> Uint32 {
         flags.iter().fold(0, |acc, &flag| acc | flag as Uint32)
     }
}

I would like to do the opposite operation of the fold_bits function :
     pub fn unfold_bits(bits: Uint32) -> ~[SDL_WindowFlags]    {
         ??
     }

I don't have a simple way to do it (like the fold method) . Anybody can 
help me ?

Philippe Delrieu


From nical.silva at gmail.com  Wed Jan 15 08:29:05 2014
From: nical.silva at gmail.com (Nicolas Silva)
Date: Wed, 15 Jan 2014 17:29:05 +0100
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <52D6B495.2080108@free.fr>
References: <52D6B495.2080108@free.fr>
Message-ID: <CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>

I ran into a similar situation in my own code and did something which would
transpose to:

type WindowFlags = u32;
static SDL_WINDOW_FULLSCREEN : u32 = ffi::video::SDL_WINDOW_FULLSCREEN;
...

I think enums are not a good fit for bitwise operations, it's not really
meant for that.

Cheers,

Nical



On Wed, Jan 15, 2014 at 5:17 PM, Philippe Delrieu
<philippe.delrieu at free.fr>wrote:

> I work on the SDL2 binding and I have the following code :
>
> pub enum SDL_WindowFlags {
>     SDL_WINDOW_FULLSCREEN           = ffi::video::SDL_WINDOW_FULLSCREEN,
>     SDL_WINDOW_OPENGL               = ffi::video::SDL_WINDOW_OPENGL,
>     SDL_WINDOW_SHOWN                = ffi::video::SDL_WINDOW_SHOWN,
>     SDL_WINDOW_HIDDEN               = ffi::video::SDL_WINDOW_HIDDEN,
>     SDL_WINDOW_BORDERLESS           = ffi::video::SDL_WINDOW_BORDERLESS,
>     SDL_WINDOW_RESIZABLE            = ffi::video::SDL_WINDOW_RESIZABLE,
>     SDL_WINDOW_MINIMIZED            = ffi::video::SDL_WINDOW_MINIMIZED,
>     SDL_WINDOW_MAXIMIZED            = ffi::video::SDL_WINDOW_MAXIMIZED,
>     SDL_WINDOW_INPUT_GRABBED        = ffi::video::SDL_WINDOW_INPUT_
> GRABBED,
>     SDL_WINDOW_INPUT_FOCUS          = ffi::video::SDL_WINDOW_INPUT_FOCUS,
>     SDL_WINDOW_MOUSE_FOCUS          = ffi::video::SDL_WINDOW_MOUSE_FOCUS,
>     SDL_WINDOW_FULLSCREEN_DESKTOP   = ffi::video::SDL_WINDOW_
> FULLSCREEN_DESKTOP,
>     SDL_WINDOW_FOREIGN              = ffi::video::SDL_WINDOW_FOREIGN,
> }
>
> impl SDL_WindowFlags {
>     pub fn fold_bits(flags: &[SDL_WindowFlags]) -> Uint32 {
>         flags.iter().fold(0, |acc, &flag| acc | flag as Uint32)
>     }
> }
>
> I would like to do the opposite operation of the fold_bits function :
>     pub fn unfold_bits(bits: Uint32) -> ~[SDL_WindowFlags]    {
>         ??
>     }
>
> I don't have a simple way to do it (like the fold method) . Anybody can
> help me ?
>
> Philippe Delrieu
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/516e6652/attachment.html>

From slabode at aim.com  Wed Jan 15 08:36:33 2014
From: slabode at aim.com (SiegeLord)
Date: Wed, 15 Jan 2014 11:36:33 -0500
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>
References: <52D6B495.2080108@free.fr>
	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>
Message-ID: <52D6B911.6000309@aim.com>

On 01/15/2014 11:29 AM, Nicolas Silva wrote:
> I think enums are not a good fit for bitwise operations, it's not really
> meant for that.
I came to the same conclusion and came up with a nice macro to automate 
that, seen here: 
https://github.com/SiegeLord/RustAllegro/blob/master/src/rust_util.rs#L3..L56 
and used here 
https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/bitmap_like.rs#L9..L23 
.

This enables a nice, C-like API when composing/extracting flags via the 
bit-or and bit-and operators.

-SL

From philippe.delrieu at free.fr  Wed Jan 15 08:45:42 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 15 Jan 2014 17:45:42 +0100
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <52D6B911.6000309@aim.com>
References: <52D6B495.2080108@free.fr>	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>
	<52D6B911.6000309@aim.com>
Message-ID: <52D6BB36.1000703@free.fr>

Thanks for you answer . I have the idea to see in the SDL port (I work 
on the SDL2 port) which is finished and has the same problems. They 
solve the problem like this :

     pub fn unfold_bits(bitflags: u32) -> ~[SDL_WindowFlags] {
         let flags = [SDL_WINDOW_FULLSCREEN,
             SDL_WINDOW_OPENGL,
             SDL_WINDOW_SHOWN,
             SDL_WINDOW_HIDDEN,
             SDL_WINDOW_BORDERLESS,
             SDL_WINDOW_RESIZABLE,
             SDL_WINDOW_MINIMIZED,
             SDL_WINDOW_MAXIMIZED,
             SDL_WINDOW_INPUT_GRABBED,
             SDL_WINDOW_INPUT_FOCUS,
             SDL_WINDOW_MOUSE_FOCUS,
             SDL_WINDOW_FULLSCREEN_DESKTOP,
             SDL_WINDOW_FOREIGN
         ];

        flags.iter().filter_map(|&flag| {
             if bitflags & (flag as u32) != 0 { Some(flag) }
             else { None }
         }).collect()
     }

Philippe

Le 15/01/2014 17:36, SiegeLord a ?crit :
> On 01/15/2014 11:29 AM, Nicolas Silva wrote:
>> I think enums are not a good fit for bitwise operations, it's not really
>> meant for that.
> I came to the same conclusion and came up with a nice macro to 
> automate that, seen here: 
> https://github.com/SiegeLord/RustAllegro/blob/master/src/rust_util.rs#L3..L56 
> and used here 
> https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/bitmap_like.rs#L9..L23 
> .
>
> This enables a nice, C-like API when composing/extracting flags via 
> the bit-or and bit-and operators.
>
> -SL
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From bilal at bilalhusain.com  Wed Jan 15 09:28:16 2014
From: bilal at bilalhusain.com (Bilal Husain)
Date: Wed, 15 Jan 2014 22:58:16 +0530
Subject: [rust-dev] Rust to JS
Message-ID: <CANinyTjtek6tgY06mTtt1wPkY6pf0K3K8j3t_iOaoNG1p+bHeQ@mail.gmail.com>

http://bilalhusain.com/rust-lexer/transpile.html

thoughts?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/ba284ef0/attachment.html>

From kevin at sb.org  Wed Jan 15 09:59:23 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 15 Jan 2014 09:59:23 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CANbMr6Gw-=Qwh0m=VmiA1YCBzD=4FkYTan-H40V0Vy21_p10UA@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CANbMr6EL8NB1pt3Scg_8w9j_SHA9eNZ7CHZNOQcyd8iSWpVs4g@mail.gmail.com>
	<CAP7VpsV00SM=JGMcPZpPY9mg14PWCfPdkiug=C=7D8HwsFOaVQ@mail.gmail.com>
	<CANbMr6EdyvD=RXcaRsLs+fABogZMJMpeF6Sv3K6Ct8QGfSd5pQ@mail.gmail.com>
	<CAP7VpsXFpO9J32VuGe1Je4A=F5C+Q3gU_=BwMV0C=P2pQAt+WQ@mail.gmail.com>
	<CANbMr6E7ReDshdMkRnjJ7C=zcyKOY6e-e=_of2WExCEADUSiLw@mail.gmail.com>
	<CAP7VpsX242OV+rPRDDMS-6t0Mod7v7BL9uqN4+zWRg0Fc0_n1Q@mail.gmail.com>
	<CANbMr6HPxNugjsu+NTW6a8KRxtqLaO+76E-st_q3RvCh-8Spfw@mail.gmail.com>
	<CANbMr6HVweq_iR=4=t5hixe1CYxFT8QejZVZN4i3SsHM6Yv2dg@mail.gmail.com>
	<CAP7VpsXJQDt7fKA3ZAYHpvetQuT_rjeKu250mZ5y3ag67twFgg@mail.gmail.com>
	<CANbMr6Gw-=Qwh0m=VmiA1YCBzD=4FkYTan-H40V0Vy21_p10UA@mail.gmail.com>
Message-ID: <F002E098-C969-491C-887A-EC577A869406@sb.org>

I don't understand why you think the type of the channel needs to encode information as to whether it's shared. It doesn't encode any other information about how you expect to use the channel. Merging Chan and SharedChan together so users don't even know there's a difference under the hood seems like a good idea to me. Less API to accomplish the same thing == better.

-Kevin

On Jan 14, 2014, at 11:06 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> I was working under the assumption that we'd add UniqueChan -> SharedChan promotion back. I assumed that would be possible since a unified Chan would be doing it internally.
> 
> Does an auto-promoting Chan really do that much for reducing cognitive load? 
> The only thing the programmer can skip understanding with a unified Chan is the whether to choose between cloneable and uncloneable channels, which isn't very much.
> It seems like a pretty significant departure from how Rust approaches this kind of thing elsewhere (i.e. memory allocation and threading model being the two things that come to mind).
> I'm just skeptical that the cognitive load reduction outweighs the information loss.
> 
> 
> On Tue, Jan 14, 2014 at 9:41 PM, Jack Moffitt <jack at metajack.im> wrote:
> You can't promote a Chan to a SharedChan currently (like you could
> with the old API), so if the caller needs to make the decision, all
> the APIs will have to return SharedChan to be flexible. I don't think
> traits help with that problem (they do help with passing in Chans). If
> we want flexible APIs that returns Chans, we need promotion of some
> kind.
> 
> I think I misspoke before. The core issue is cognitive load of 3
> channel types. Auto-promoting Chan to shared Chan reduces the number
> of channels (less API surface) and makes channels just work (never
> have to think about whether Chans are clonable). That seems a
> compelling combo. I was just focused more on the latter use case.
> 
> jack.
> 
> On Tue, Jan 14, 2014 at 10:26 PM, Eric Reed <ecreed at cs.washington.edu> wrote:
> > As a follow up, what situation would arise where you'd have to actually
> > return a Chan trait object?
> > Constructors are going to return the concrete type UniqueChan/SharedChan.
> > Functions acting on channels can just use generics, which will allow
> > returning.
> >
> >
> > On Tue, Jan 14, 2014 at 9:21 PM, Eric Reed <ecreed at cs.washington.edu> wrote:
> >>
> >> fn foo<T: Trait>() -> T
> >>
> >>
> >> On Tue, Jan 14, 2014 at 9:20 PM, Jack Moffitt <jack at metajack.im> wrote:
> >>>
> >>> You can't do `foo() -> Trait`. It would have to be `foo() -> ~Trait`.
> >>> Well, unless DST fixes this. I assume this is the same reason we
> >>> return specific instances of iterators instead of an Iteratable trait
> >>> object.
> >>>
> >>> jack.
> >>>
> >>> On Tue, Jan 14, 2014 at 10:10 PM, Eric Reed <ecreed at cs.washington.edu>
> >>> wrote:
> >>> > How would that make us lose stack allocated return values?
> >>> >
> >>> >
> >>> > On Tue, Jan 14, 2014 at 5:22 PM, Jack Moffitt <jack at metajack.im> wrote:
> >>> >>
> >>> >> > Good point. Make `Chan` a trait with implementers `UniqueChan` and
> >>> >> > `SharedChan`?
> >>> >>
> >>> >> I suppose the main downside of that solution is that you lose stack
> >>> >> allocated return values.
> >>> >>
> >>> >> jack.
> >>> >
> >>> >
> >>
> >>
> >
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/3e053d83/attachment-0001.html>

From kevin at sb.org  Wed Jan 15 10:01:15 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 15 Jan 2014 10:01:15 -0800
Subject: [rust-dev] ASCII character literals
In-Reply-To: <52D6A8A7.2020900@ntecs.de>
References: <52D69D0F.9070903@ntecs.de>
	<CAJY4u8GSL00g3Kq6O6WZZfeB_FNL4azhvx_w84rzGM5DZjUx5w@mail.gmail.com>
	<52D6A8A7.2020900@ntecs.de>
Message-ID: <4B11F95C-FDA3-4C0A-B530-598209DEA8D0@sb.org>

The relevant issue for this is https://github.com/mozilla/rust/issues/4334.

-Kevin

On Jan 15, 2014, at 7:26 AM, Michael Neumann <mneumann at ntecs.de> wrote:

> 
> Am 15.01.2014 16:23, schrieb Evan G:
>> I'm not weighing in on whether this is something rust should do or not, but we could mimic the 16i, 10u numeric literal system to achieve this in syntax. An ascii literal would have a suffix, for example 'x'a or 'x'u to explicitly specify unicode (which would still be the default). This could probably work for string literals too.
> 
> Something like 'x'a would be very nice to have!
> 
> Regards,
> 
>   Michael
> 
>> 
>> 
>> On Wed, Jan 15, 2014 at 8:37 AM, Michael Neumann <mneumann at ntecs.de> wrote:
>> Hi,
>> 
>> There are lots of protocols based on ASCII character representation. In Rust, the natural way to represent them is
>> by an u8 literal (optionally wrapped within std::ascii::Ascii).
>> What I am missing is a simple way to represent those literals in code. What I am doing most of the time is:
>> 
>>     fn read_char() -> Option<char> {
>>        match io.read_byte() {
>>          Some(b) => Some(b as char),
>>          None => None
>>       }
>>     }
>> 
>> And then use character literals in pattern matching. What I'd highly prefer is a way to directly repesent ASCII characters
>> in the code, like:
>> 
>>     match io.read_byte().unwrap {
>>         'c'_ascii => ....
>>        ....
>>     }
>> 
>> If macros would work in patterns, something like:
>> 
>>    match ... {
>>        ascii!('a') => ...
>>    }
>> 
>> would work for me too. Ideally that would work with range patterns as well, but of course an ascii_range!() macro would
>> do the same.
>> 
>> Is this useful to anyone?
>> 
>> Regards,
>> 
>>     Michael
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/e545329d/attachment.html>

From jhasse at fastmail.fm  Wed Jan 15 15:24:41 2014
From: jhasse at fastmail.fm (Jan Niklas Hasse)
Date: Wed, 15 Jan 2014 15:24:41 -0800
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <52D6BB36.1000703@free.fr>
References: <52D6B495.2080108@free.fr>
	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>
	<52D6B911.6000309@aim.com> <52D6BB36.1000703@free.fr>
Message-ID: <1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>

On Wed, Jan 15, 2014, at 08:45 AM, Philippe Delrieu wrote:
> Thanks for you answer . I have the idea to see in the SDL port (I work 
> on the SDL2 port) which is finished and has the same problems. They 
> solve the problem like this :
> 
>      pub fn unfold_bits(bitflags: u32) -> ~[SDL_WindowFlags] {
>          let flags = [SDL_WINDOW_FULLSCREEN,
>              SDL_WINDOW_OPENGL,
>              SDL_WINDOW_SHOWN,
>              SDL_WINDOW_HIDDEN,
>              SDL_WINDOW_BORDERLESS,
>              SDL_WINDOW_RESIZABLE,
>              SDL_WINDOW_MINIMIZED,
>              SDL_WINDOW_MAXIMIZED,
>              SDL_WINDOW_INPUT_GRABBED,
>              SDL_WINDOW_INPUT_FOCUS,
>              SDL_WINDOW_MOUSE_FOCUS,
>              SDL_WINDOW_FULLSCREEN_DESKTOP,
>              SDL_WINDOW_FOREIGN
>          ];
> 
>         flags.iter().filter_map(|&flag| {
>              if bitflags & (flag as u32) != 0 { Some(flag) }
>              else { None }
>          }).collect()
>      }
> 
> Philippe
> 
> Le 15/01/2014 17:36, SiegeLord a ?crit :
> > On 01/15/2014 11:29 AM, Nicolas Silva wrote:
> >> I think enums are not a good fit for bitwise operations, it's not really
> >> meant for that.
> > I came to the same conclusion and came up with a nice macro to 
> > automate that, seen here: 
> > https://github.com/SiegeLord/RustAllegro/blob/master/src/rust_util.rs#L3..L56 
> > and used here 
> > https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/bitmap_like.rs#L9..L23 
> > .
> >
> > This enables a nice, C-like API when composing/extracting flags via 
> > the bit-or and bit-and operators.
> >
> > -SL
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Did you know that there are SDL2 bindings for Rust?

See:
https://github.com/AngryLawyer/rust-sdl2/blob/master/src/sdl2/video.rs

From jmgrosen at gmail.com  Wed Jan 15 15:30:25 2014
From: jmgrosen at gmail.com (John Grosen)
Date: Wed, 15 Jan 2014 15:30:25 -0800
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>
References: <52D6B495.2080108@free.fr>
	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>
	<52D6B911.6000309@aim.com> <52D6BB36.1000703@free.fr>
	<1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>
Message-ID: <354625C691634F019293E8B3B33D6C5A@gmail.com>

EnumSet (http://static.rust-lang.org/doc/master/extra/enum_set/struct.EnumSet.html) looks almost exactly like what you want ? except, unfortunately, it doesn?t actually expose its `bits` field. Perhaps a new method should be added to it?

--  
John Grosen


On Wednesday, January 15, 2014 at 3:24 PM, Jan Niklas Hasse wrote:

> On Wed, Jan 15, 2014, at 08:45 AM, Philippe Delrieu wrote:
> > Thanks for you answer . I have the idea to see in the SDL port (I work  
> > on the SDL2 port) which is finished and has the same problems. They  
> > solve the problem like this :
> >  
> > pub fn unfold_bits(bitflags: u32) -> ~[SDL_WindowFlags] {
> > let flags = [SDL_WINDOW_FULLSCREEN,
> > SDL_WINDOW_OPENGL,
> > SDL_WINDOW_SHOWN,
> > SDL_WINDOW_HIDDEN,
> > SDL_WINDOW_BORDERLESS,
> > SDL_WINDOW_RESIZABLE,
> > SDL_WINDOW_MINIMIZED,
> > SDL_WINDOW_MAXIMIZED,
> > SDL_WINDOW_INPUT_GRABBED,
> > SDL_WINDOW_INPUT_FOCUS,
> > SDL_WINDOW_MOUSE_FOCUS,
> > SDL_WINDOW_FULLSCREEN_DESKTOP,
> > SDL_WINDOW_FOREIGN
> > ];
> >  
> > flags.iter().filter_map(|&flag| {
> > if bitflags & (flag as u32) != 0 { Some(flag) }
> > else { None }
> > }).collect()
> > }
> >  
> > Philippe
> >  
> > Le 15/01/2014 17:36, SiegeLord a ?crit :
> > > On 01/15/2014 11:29 AM, Nicolas Silva wrote:
> > > > I think enums are not a good fit for bitwise operations, it's not really
> > > > meant for that.
> > > >  
> > >  
> > > I came to the same conclusion and came up with a nice macro to  
> > > automate that, seen here:  
> > > https://github.com/SiegeLord/RustAllegro/blob/master/src/rust_util.rs#L3..L56  
> > > and used here  
> > > https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/bitmap_like.rs#L9..L23  
> > > .
> > >  
> > > This enables a nice, C-like API when composing/extracting flags via  
> > > the bit-or and bit-and operators.
> > >  
> > > -SL
> > > _______________________________________________
> > > Rust-dev mailing list
> > > Rust-dev at mozilla.org (mailto:Rust-dev at mozilla.org)
> > > https://mail.mozilla.org/listinfo/rust-dev
> > >  
> >  
> >  
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org (mailto:Rust-dev at mozilla.org)
> > https://mail.mozilla.org/listinfo/rust-dev
> >  
>  
>  
> Did you know that there are SDL2 bindings for Rust?
>  
> See:
> https://github.com/AngryLawyer/rust-sdl2/blob/master/src/sdl2/video.rs
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org (mailto:Rust-dev at mozilla.org)
> https://mail.mozilla.org/listinfo/rust-dev
>  
>  


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140115/2c600497/attachment.html>

From philippe.delrieu at free.fr  Wed Jan 15 22:27:52 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 16 Jan 2014 07:27:52 +0100
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>
References: <52D6B495.2080108@free.fr>	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>	<52D6B911.6000309@aim.com>
	<52D6BB36.1000703@free.fr>
	<1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>
Message-ID: <52D77BE8.2050501@free.fr>

Yes and no. I fork the project of bjz (https://github.com/bjz/sdl2-rs). 
I didn't see the one from Tony Aldridge.
It seem more advanced than the one I working on (only the ffi part is done).

Thanks for your advice.

Philippe

Le 16/01/2014 00:24, Jan Niklas Hasse a ?crit :
>
> Did you know that there are SDL2 bindings for Rust?
>
> See:
> https://github.com/AngryLawyer/rust-sdl2/blob/master/src/sdl2/video.rs
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From philippe.delrieu at free.fr  Wed Jan 15 22:41:45 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 16 Jan 2014 07:41:45 +0100
Subject: [rust-dev] Bitwise operations in rust.
In-Reply-To: <354625C691634F019293E8B3B33D6C5A@gmail.com>
References: <52D6B495.2080108@free.fr>	<CAJdRmvvq92Yo6GOrU1HjH=-8tO9tRSd8Ev7KDfP7jnZWxqq6ZA@mail.gmail.com>	<52D6B911.6000309@aim.com>
	<52D6BB36.1000703@free.fr>	<1389828281.23453.71302701.40B40A04@webmail.messagingengine.com>
	<354625C691634F019293E8B3B33D6C5A@gmail.com>
Message-ID: <52D77F29.6090404@free.fr>

Yes your right. To be useful in bitwise operation you need four methods 
I think
  fn pub or_enum() -> uint
  fn pub add_all(&[CLike]) or
  fn pub to_array() -> ~[CLike]
  fn pub add_unfold(uint)

No sure with the names but if the idea to add some methods is validated 
I can try to implements them.

Philippe


Le 16/01/2014 00:30, John Grosen a ?crit :
> EnumSet 
> (http://static.rust-lang.org/doc/master/extra/enum_set/struct.EnumSet.html) 
> looks almost exactly like what you want --- except, unfortunately, it 
> doesn't actually expose its `bits` field. Perhaps a new method should 
> be added to it?
>
> -- 
> John Grosen
>
> On Wednesday, January 15, 2014 at 3:24 PM, Jan Niklas Hasse wrote:
>
>> On Wed, Jan 15, 2014, at 08:45 AM, Philippe Delrieu wrote:
>>> Thanks for you answer . I have the idea to see in the SDL port (I work
>>> on the SDL2 port) which is finished and has the same problems. They
>>> solve the problem like this :
>>>
>>> pub fn unfold_bits(bitflags: u32) -> ~[SDL_WindowFlags] {
>>> let flags = [SDL_WINDOW_FULLSCREEN,
>>> SDL_WINDOW_OPENGL,
>>> SDL_WINDOW_SHOWN,
>>> SDL_WINDOW_HIDDEN,
>>> SDL_WINDOW_BORDERLESS,
>>> SDL_WINDOW_RESIZABLE,
>>> SDL_WINDOW_MINIMIZED,
>>> SDL_WINDOW_MAXIMIZED,
>>> SDL_WINDOW_INPUT_GRABBED,
>>> SDL_WINDOW_INPUT_FOCUS,
>>> SDL_WINDOW_MOUSE_FOCUS,
>>> SDL_WINDOW_FULLSCREEN_DESKTOP,
>>> SDL_WINDOW_FOREIGN
>>> ];
>>>
>>> flags.iter().filter_map(|&flag| {
>>> if bitflags & (flag as u32) != 0 { Some(flag) }
>>> else { None }
>>> }).collect()
>>> }
>>>
>>> Philippe
>>>
>>> Le 15/01/2014 17:36, SiegeLord a ?crit :
>>>> On 01/15/2014 11:29 AM, Nicolas Silva wrote:
>>>>> I think enums are not a good fit for bitwise operations, it's not 
>>>>> really
>>>>> meant for that.
>>>> I came to the same conclusion and came up with a nice macro to
>>>> automate that, seen here:
>>>> https://github.com/SiegeLord/RustAllegro/blob/master/src/rust_util.rs#L3..L56 
>>>>
>>>> and used here
>>>> https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/bitmap_like.rs#L9..L23 
>>>>
>>>> .
>>>>
>>>> This enables a nice, C-like API when composing/extracting flags via
>>>> the bit-or and bit-and operators.
>>>>
>>>> -SL
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>> Did you know that there are SDL2 bindings for Rust?
>>
>> See:
>> https://github.com/AngryLawyer/rust-sdl2/blob/master/src/sdl2/video.rs
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140116/fbd34100/attachment-0001.html>

From com.liigo at gmail.com  Thu Jan 16 02:02:02 2014
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Thu, 16 Jan 2014 18:02:02 +0800
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
Message-ID: <CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>

let tuple = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
let a,b,c = tuple.1, tuple.2, tuple.3; // I prefer this. (0-based?)
// or: tuple.a, tuple.b, tuple.c, ...z
// or: tuple[index]


2014/1/15 Richard Diamond <wichard at vitalitystudios.com>

> Basically the idea here is to support shuffling for SIMD types in a way
> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
> a vector of constants, so an intrinsic function is out of the question),
> however I image this sugar could extend to tuples with multiple types.
>
> Some examples:
>
> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
> 0, 0)"?
> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
> let single_x = vec -> (0);
> assert_eq!(single_x, (1.0f32));
>
> let mut vec = vec;
> vec <- (0) = 5.0f32; // set x only
> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>
> let vec = vec;
> // the mask may be arbitrarily long:
> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
> 5.0f32));
>
> // leaves vec unchanged
> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
> // functional_update would take it's type from vec
> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>
> A couple of things would need to be disallowed, however:
>
> let mut vec = vec;
> // no duplicate assignments/functional updates:
> vec <- (0, 0) = (..);
> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
> // no out-of-bounds:
> vec <- (5, 9000) = (..);
> let _ = vec -> (5, 9001);
> let _ = vec -> (5, 9002) .. (..);
> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
> // all mask values must be a const expr:
> let mut non_const_expr = 15;
> vec <- (non_const_expr) = (..);
> let _ = vec -> (non_const_expr) .. (..);
> let _ = vec -> (non_const_expr);
> // mismatched tuple sizes:
> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>
> AIUI, the notation would be:
> tuple_mask : '(' integer [ ',' integer ] * ')' ;
> tuple_expr : '(' expr [ ',' expr ] * ')' |
>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>
> I'm willing to write this myself, but I'd like some consensus/feedback
> regarding ze proposed sugar.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
by *Liigo*, http://blog.csdn.net/liigo/
Google+  https://plus.google.com/105597640837742873343/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140116/826af9f8/attachment.html>

From olivier.lemaire at me.com  Thu Jan 16 02:40:36 2014
From: olivier.lemaire at me.com (Olivier Lemaire)
Date: Thu, 16 Jan 2014 11:40:36 +0100
Subject: [rust-dev] OSX install package for rust 0.9
Message-ID: <0CF31745-2E6A-4E73-AC79-74F53830AB08@me.com>

Greetings,

I did an OSX install package for rust 0.9 to allow easy deployment/spreading of rust on OSX machines. 
This helped me to install rust on more than one (OSX) station without having to compile rust from source each time.
utils, libs and man page installed in /usr/local/

You can find the package (build) for OSX 10.9 (Maverick) there: https://github.com/olemaire/rust-osx
You?ll find also the Apple package manager ?source? to rebuild that kind of package for your own use. 

I plan to continue making/commiting install packages for the upcoming releases (rust/osx) - but I cannot do the job for nightlies rust builds. 

Hope this could help some anyway
Any feedback welcome.

Cheers,
? 
lem


From mcguire at crsr.net  Thu Jan 16 08:13:07 2014
From: mcguire at crsr.net (Tommy M. McGuire)
Date: Thu, 16 Jan 2014 10:13:07 -0600
Subject: [rust-dev] Something odd I just noticed with mut and pattern
	matching
In-Reply-To: <52D5EFD1.1000104@crsr.net>
References: <52D5EFD1.1000104@crsr.net>
Message-ID: <52D80513.5030905@crsr.net>

I found something odd with mutablity and pattern matching.

    let file = File::open_mode(&Path::new("test"), Truncate, Write);

    match file {
        Some(f) => f.write_str( "hello" ),
        None => fail!("not a file")
    }

results in a "cannot borrow immutable local variable as mutable" error,
as expected. But,

    let mut file = File::open_mode(&Path::new("test"), Truncate, Write);

    match file {
        Some(f) => f.write_str( "hello" ),
        None => fail!("not a file")
    }

also results in a "cannot borrow immutable local variable as mutable"
error, and

    let file = File::open_mode(&Path::new("test"), Truncate, Write);

    match file {
        Some(mut f) => f.write_str( "hello" ),
        None => fail!("not a file")
    }

works, while

    let mut file = File::open_mode(&Path::new("test"), Truncate, Write);

    match file {
        Some(mut f) => f.write_str( "hello" ),
        None => fail!("not a file")
    }

results in a "variable does not need to be mutable" warning.

Shouldn't the third option also fail (and possibly the second option
succeed)?




-- 
Tommy M. McGuire
mcguire at crsr.net

From simon.sapin at exyr.org  Thu Jan 16 08:24:24 2014
From: simon.sapin at exyr.org (Simon Sapin)
Date: Thu, 16 Jan 2014 16:24:24 +0000
Subject: [rust-dev] Something odd I just noticed with mut and pattern
 matching
In-Reply-To: <52D80513.5030905@crsr.net>
References: <52D5EFD1.1000104@crsr.net> <52D80513.5030905@crsr.net>
Message-ID: <52D807B8.2040605@exyr.org>

On 16/01/2014 16:13, Tommy M. McGuire wrote:
> I found something odd with mutablity and pattern matching.
>
>      let file = File::open_mode(&Path::new("test"), Truncate, Write);
>
>      match file {
>          Some(f) => f.write_str( "hello" ),
>          None => fail!("not a file")
>      }
>
> results in a "cannot borrow immutable local variable as mutable" error,
> as expected. But,
>
>      let mut file = File::open_mode(&Path::new("test"), Truncate, Write);
>
>      match file {
>          Some(f) => f.write_str( "hello" ),
>          None => fail!("not a file")
>      }
>
> also results in a "cannot borrow immutable local variable as mutable"
> error, and
>
>      let file = File::open_mode(&Path::new("test"), Truncate, Write);
>
>      match file {
>          Some(mut f) => f.write_str( "hello" ),
>          None => fail!("not a file")
>      }
>
> works, while
>
>      let mut file = File::open_mode(&Path::new("test"), Truncate, Write);
>
>      match file {
>          Some(mut f) => f.write_str( "hello" ),
>          None => fail!("not a file")
>      }
>
> results in a "variable does not need to be mutable" warning.
>
> Shouldn't the third option also fail (and possibly the second option
> succeed)?


Something immutable can become mutable when it?s moved. Matching an enum 
member without "ref" moves.

It would be a different story (I think) if your pattern was Some(ref mut f).

-- 
Simon Sapin

From mathstuf at gmail.com  Wed Jan 15 21:42:23 2014
From: mathstuf at gmail.com (Ben Boeckel)
Date: Thu, 16 Jan 2014 05:42:23 +0000 (UTC)
Subject: [rust-dev] RFC: Future of the Build System
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5BB43.5020101@gmail.com>
	<CA++BO6QghqMr16KLwOkdqtJA8xZP2yEAVvpi6jYSLz0KEtSspA@mail.gmail.com>
	<52D5CE1E.7050601@gmail.com>
	<4184858f-e8aa-4bdf-86a0-a0925fb3a56f@email.android.com>
	<CANK7tAELUsuprG-3BUOEa5fPopUQHUk8g=-UORzFrER4BMDVGA@mail.gmail.com>
	<CAP7VpsV4bXJcvc95zO6GcbVXJXMyB8xp1ACzuN5P=dt5fFQk7w@mail.gmail.com>
	<CANK7tAE4cPeknCEq-GA86ZsFNiKfi+4KOFCYXxxWLGLpkMWfpw@mail.gmail.com>
Message-ID: <lb7rfv$lno$2@ger.gmane.org>

On Wed, 15 Jan, 2014 at 15:34:29 GMT, Gaetan wrote:
> I just hate the "if/elseif/else" block in CMake list, that's all :)

If you're referring to the:

    if (long expr)
    else (long expr)
    endif (long expr)

ugliness, the 'else' and 'endif' "arguments" can now be empty (and
really should be).

--Ben


From kevin at sb.org  Thu Jan 16 11:37:33 2014
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 16 Jan 2014 11:37:33 -0800
Subject: [rust-dev] Something odd I just noticed with mut and pattern
	matching
In-Reply-To: <52D80513.5030905@crsr.net>
References: <52D5EFD1.1000104@crsr.net> <52D80513.5030905@crsr.net>
Message-ID: <AFB37CF9-6203-4B8B-81FA-90ACC41C733E@sb.org>

On Jan 16, 2014, at 8:13 AM, Tommy M. McGuire <mcguire at crsr.net> wrote:

>    let file = File::open_mode(&Path::new("test"), Truncate, Write);
> 
>    match file {
>        Some(mut f) => f.write_str( "hello" ),
>        None => fail!("not a file")
>    }

This is fine, because you?re consuming `file` and moving the contained value into a new mutable `f` variable. It?s basically the same as

    if file.is_some() {
        let mut f = file.unwrap();
        ?
    } else {
        fail!(?..?);
    }

> works, while
> 
>    let mut file = File::open_mode(&Path::new("test"), Truncate, Write);
> 
>    match file {
>        Some(mut f) => f.write_str( "hello" ),
>        None => fail!("not a file")
>    }
> 
> results in a "variable does not need to be mutable" warning.

The warning here is because `file` doesn?t need to be mutable.

> Shouldn't the third option also fail (and possibly the second option
> succeed)?

The first two failed because the variable that needed to be mutable, `f`, was not mutable the second two succeeded because it was.

As Simon has already pointed out, if you tried to use a by-ref binding it would fail, because you can?t take a mutable borrow of an immutable variable. But you didn?t do that, you moved the value, and moving from an immutable variable into a mutable one is perfectly legal.

-Kevin

From uzytkownik2 at gmail.com  Thu Jan 16 14:00:53 2014
From: uzytkownik2 at gmail.com (Maciej Piechotka)
Date: Thu, 16 Jan 2014 22:00:53 +0000 (UTC)
Subject: [rust-dev] RFC: Future of the Build System
References: <CA++BO6Qsd_OSqktYwAKbSekzBYm=mcXQgPA+kiSVdmBdPyq1kw@mail.gmail.com>
	<CAHYVw0xQVkiQxwbPKiRfgtT5dny=1=3by41aFCyiMLbrVSGHyQ@mail.gmail.com>
	<CANK7tAF73sSo=iJVMMMTnGCRdWs56+S-Ra=eBqy-TPgd6ys5+Q@mail.gmail.com>
	<52CFB098.8010100@gmail.com>
	<3b3dc812-9dc6-4019-8313-4b8d1f55f921@email.android.com>
	<CANK7tAGXzF_mnfS46+QTLMWBipFG1rRZ=FOoC6C=9P8SV0emdA@mail.gmail.com>
	<db443c51-6f04-4139-bd65-944d01641b46@email.android.com>
	<CAPM5UJ3E7QxRwPErz35S6YEM1DAy=hbuKHAAE_DokB1mxR9Y6A@mail.gmail.com>
	<52D572FC.5050200@mozilla.com> <52D5A178.6060009@gmail.com>
	<730e8785-a81b-48b4-9153-e74c9fdea757@email.android.com>
	<52D5B607.5070003@gmail.com> <52D5BAA4.8070405@gmail.com>
	<52D5BD10.9080406@gmail.com>
	<CANK7tAFaTSJ_6YJXiY=OpJLcLZDCQPAiEOn=bzFf9YeF-ZCwtQ@mail.gmail.com>
	<52D5C316.9070309@gmail.com>
	<1389741313.32027.70816441.69B32D0C@webmail.messagingengine.com>
	<52D5CAD2.7040306@gmail.com>
	<1389743350.6905.70827901.4812F340@webmail.messagingengine.com>
	<52D5CE07.7030300@gmail.com>
Message-ID: <loom.20140116T225944-994@post.gmane.org>

Lee Braiden <leebraid at ...> writes:

> 
> On 14/01/14 23:49, Jan Niklas Hasse wrote:
> > I disagree! rustpkg should handle dependencies for building a rust
> > package. It can automatically know which packages are needed from
> > "extern mod" etc. apt-get and others are just unsuited for this.
> >
> 
> But that is exactly my point.  Only Rust developers / tools / community 
> know that information, so we should make it available to others.
> 
> If you're trying to say, though, that we should hide that information so 
> we can control builds, I think that simply WON'T work WELL.  Sure, it 
> can work, but there will be package conflicts; you will be making 
> people's lives harder.
> 

Possibly an useful note - in Gentoo there is tool to automatically
create ebuilds (read for simplicity - packages[1]) for Haskell
programs/libraries using cabal. The only thing you need is replace the
library names with packages name if the library is a binding to one.
Because there is a central repository (hackage) creation of package for
an application/library is as easy as:

% hackport app-editor/yi # Creates a 'package'
% emerge app-editor/yi # Installs a package

Or bindings:

% hackport dev-haskell/llvm-base # Creates a 'package'
% vim dev-haskell/llvm-base/llvm-base-<version>.ebuild
% emerge app-editor/yi # Installs a package

This picks ups all the changes, allows to select options (listed by
reading cabal files) etc. On the other hand cmake/autotools packages
require a bit more work.
(Some packages require further patching as authors assumed for example
that it'll be installed in /usr/local, or don't respect DESTDIR etc.)

For that reason I guess there would be benefit in having a single tool
which would make things uniform (say - rustpkg) as anyone maintaining a
rust repor for <insert your distribution here> would have just one tool
to work with instead of reading README file.

PS. Sorry if it double posted but gmane refused to send mail via NNTP
asking me to subscribe to this list even though I'm subscribe...

[1] This is a BIG lie for children but I don't want to explain it at
this moment



From carter.schonwald at gmail.com  Thu Jan 16 15:12:43 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 16 Jan 2014 18:12:43 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
Message-ID: <CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>

whatever the notation, it needs to be one that
a) gives good support for enforcing the "the shuffle is dictated at compile
time"
b) is really simple, and easy to adjust for different size SIMD vectors.
2x, 4x,8x,16x are all ones that currently and/or  will soon exist on the
CPU front at the very least!


On Thu, Jan 16, 2014 at 5:02 AM, Liigo Zhuang <com.liigo at gmail.com> wrote:

> let tuple = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
> let a,b,c = tuple.1, tuple.2, tuple.3; // I prefer this. (0-based?)
> // or: tuple.a, tuple.b, tuple.c, ...z
> // or: tuple[index]
>
>
> 2014/1/15 Richard Diamond <wichard at vitalitystudios.com>
>
>>  Basically the idea here is to support shuffling for SIMD types in a way
>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>> a vector of constants, so an intrinsic function is out of the question),
>> however I image this sugar could extend to tuples with multiple types.
>>
>> Some examples:
>>
>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
>> 0, 0)"?
>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>> let single_x = vec -> (0);
>> assert_eq!(single_x, (1.0f32));
>>
>> let mut vec = vec;
>> vec <- (0) = 5.0f32; // set x only
>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>
>> let vec = vec;
>> // the mask may be arbitrarily long:
>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>> 5.0f32));
>>
>> // leaves vec unchanged
>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>> // functional_update would take it's type from vec
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>
>> A couple of things would need to be disallowed, however:
>>
>> let mut vec = vec;
>> // no duplicate assignments/functional updates:
>> vec <- (0, 0) = (..);
>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>> // no out-of-bounds:
>> vec <- (5, 9000) = (..);
>> let _ = vec -> (5, 9001);
>> let _ = vec -> (5, 9002) .. (..);
>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>> // all mask values must be a const expr:
>> let mut non_const_expr = 15;
>> vec <- (non_const_expr) = (..);
>> let _ = vec -> (non_const_expr) .. (..);
>> let _ = vec -> (non_const_expr);
>> // mismatched tuple sizes:
>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>
>> AIUI, the notation would be:
>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>
>> I'm willing to write this myself, but I'd like some consensus/feedback
>> regarding ze proposed sugar.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> by *Liigo*, http://blog.csdn.net/liigo/
> Google+  https://plus.google.com/105597640837742873343/
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140116/9688bd5e/attachment.html>

From jens at nockert.se  Thu Jan 16 15:16:49 2014
From: jens at nockert.se (Jens Nockert)
Date: Fri, 17 Jan 2014 00:16:49 +0100
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
	<CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>
Message-ID: <BBC7B087-A853-4BA2-A3D0-480C4580147C@nockert.se>


On 2014/01/17, at 0:12, Carter Schonwald <carter.schonwald at gmail.com> wrote:

> whatever the notation, it needs to be one that 
> a) gives good support for enforcing the "the shuffle is dictated at compile time"
> b) is really simple, and easy to adjust for different size SIMD vectors.   2x, 4x,8x,16x are all ones that currently and/or  will soon exist on the CPU front at the very least!

I prefer the OpenCL notation, vector.xyzw, vector.s0321 and so on. Supports up to 16 elements, which is fine with most common SIMD types. (AVX-512 with bytes and so on will always require horrible syntax, since there are so many elements)

From carter.schonwald at gmail.com  Thu Jan 16 15:33:06 2014
From: carter.schonwald at gmail.com (Carter Schonwald)
Date: Thu, 16 Jan 2014 18:33:06 -0500
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <BBC7B087-A853-4BA2-A3D0-480C4580147C@nockert.se>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
	<CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>
	<BBC7B087-A853-4BA2-A3D0-480C4580147C@nockert.se>
Message-ID: <CAHYVw0wYa3QNcrwObd6=7hXzwP_GsjxNrdaRPA9FSjugRTt29w@mail.gmail.com>

doesn't the opencl notation in the 16x case require 16^16 orders to be
supported (even if its implicit in the parser support?)
That said, if it can be engineered in sane way, sure, that'd be neat, how
does the OpenCL notation work in the 16x simd case?

On Thu, Jan 16, 2014 at 6:16 PM, Jens Nockert <jens at nockert.se> wrote:

>
> On 2014/01/17, at 0:12, Carter Schonwald <carter.schonwald at gmail.com>
> wrote:
>
> > whatever the notation, it needs to be one that
> > a) gives good support for enforcing the "the shuffle is dictated at
> compile time"
> > b) is really simple, and easy to adjust for different size SIMD vectors.
>   2x, 4x,8x,16x are all ones that currently and/or  will soon exist on the
> CPU front at the very least!
>
> I prefer the OpenCL notation, vector.xyzw, vector.s0321 and so on.
> Supports up to 16 elements, which is fine with most common SIMD types.
> (AVX-512 with bytes and so on will always require horrible syntax, since
> there are so many elements)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140116/f77ed3dd/attachment.html>

From wichard at vitalitystudios.com  Thu Jan 16 23:51:01 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Fri, 17 Jan 2014 01:51:01 -0600
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
Message-ID: <CAPpP=LASEv0aw=fb0FDRaxLMg9V5RH_TSRBwaN_e5TJeRiQYfQ@mail.gmail.com>

That would require quite a bit of look-ahead in the parser (unless you
really meant 'let (a, b, c) = ..') and doesn't expose the intent of the
swizzle without effort; not to mention in terms of grace its not exactly an
upgrade from:
let (v_x, v_y, v_z, v_w) = f32x4(..);
// things

However, if you were just referring to being able to access individual
elements by an index, yeah, that's a bruise from tuple usage and sadly not
yet fixable by generics.

Richard Diamond


On Thu, Jan 16, 2014 at 4:02 AM, Liigo Zhuang <com.liigo at gmail.com> wrote:

> let tuple = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
> let a,b,c = tuple.1, tuple.2, tuple.3; // I prefer this. (0-based?)
> // or: tuple.a, tuple.b, tuple.c, ...z
> // or: tuple[index]
>
>
> 2014/1/15 Richard Diamond <wichard at vitalitystudios.com>
>
>> Basically the idea here is to support shuffling for SIMD types in a way
>> that can be easily lowered to IR (LLVM's shufflevector requires the mask be
>> a vector of constants, so an intrinsic function is out of the question),
>> however I image this sugar could extend to tuples with multiple types.
>>
>> Some examples:
>>
>> let vec = (1.0f32, 2.0f32, 3.0f32, 4.0f32);
>> let all_x = vec -> (0, 0, 0, 0); // perhaps this should be "vec <- (0, 0,
>> 0, 0)"?
>> assert_eq!(all_x, (1.0f32, 1.0f32, 1.0f32, 1.0f32));
>> let single_x = vec -> (0);
>> assert_eq!(single_x, (1.0f32));
>>
>> let mut vec = vec;
>> vec <- (0) = 5.0f32; // set x only
>> vec <- (1, 2) = (6.0f32, 7.0f32) // set y & z
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>>
>> let vec = vec;
>> // the mask may be arbitrarily long:
>> assert_eq!(vec -> (0, 1, 2, 3, 0), (5.0f32, 6.0f32, 7.0f32, 4.0f32,
>> 5.0f32));
>>
>> // leaves vec unchanged
>> let functional_update = vec -> (0, 1, 3) .. (0.5f32, 1.0f32, 10.0f32);
>> // functional_update would take it's type from vec
>> assert_eq!(vec, (5.0f32, 6.0f32, 7.0f32, 4.0f32));
>> assert_eq!(functional_update, (0.5f32, 1.0f32, 7.0f32, 10.0f32));
>>
>> A couple of things would need to be disallowed, however:
>>
>> let mut vec = vec;
>> // no duplicate assignments/functional updates:
>> vec <- (0, 0) = (..);
>> let _ = vec -> (0, 1, 2, 3, 0) .. (..);
>> // no out-of-bounds:
>> vec <- (5, 9000) = (..);
>> let _ = vec -> (5, 9001);
>> let _ = vec -> (5, 9002) .. (..);
>> let _ = vec -> (0, 1, 2, 3, 4) .. (..);
>> // all mask values must be a const expr:
>> let mut non_const_expr = 15;
>> vec <- (non_const_expr) = (..);
>> let _ = vec -> (non_const_expr) .. (..);
>> let _ = vec -> (non_const_expr);
>> // mismatched tuple sizes:
>> vec <- (0, 1) = (0.0f32, 0.0f32, 0.0f32);
>> let _ = vec -> (0) .. (0.0f32, 0.0f32);
>>
>> AIUI, the notation would be:
>> tuple_mask : '(' integer [ ',' integer ] * ')' ;
>> tuple_expr : '(' expr [ ',' expr ] * ')' |
>>                   tuple_expr "->" tuple_mask [ ".." tuple_expr ] ? ;
>>
>> I'm willing to write this myself, but I'd like some consensus/feedback
>> regarding ze proposed sugar.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> by *Liigo*, http://blog.csdn.net/liigo/
> Google+  https://plus.google.com/105597640837742873343/
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140117/2abc2547/attachment-0001.html>

From wichard at vitalitystudios.com  Thu Jan 16 23:57:13 2014
From: wichard at vitalitystudios.com (Richard Diamond)
Date: Fri, 17 Jan 2014 01:57:13 -0600
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAHYVw0wYa3QNcrwObd6=7hXzwP_GsjxNrdaRPA9FSjugRTt29w@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
	<CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>
	<BBC7B087-A853-4BA2-A3D0-480C4580147C@nockert.se>
	<CAHYVw0wYa3QNcrwObd6=7hXzwP_GsjxNrdaRPA9FSjugRTt29w@mail.gmail.com>
Message-ID: <CAPpP=LDjy9Bdh45JuOserBcR9ejspe6dfFEEPWyUyDL-oRk3Eg@mail.gmail.com>

On Thu, Jan 16, 2014 at 5:33 PM, Carter Schonwald <
carter.schonwald at gmail.com> wrote:

> doesn't the opencl notation in the 16x case require 16^16 orders to be
> supported (even if its implicit in the parser support?)
> That said, if it can be engineered in sane way, sure, that'd be neat, how
> does the OpenCL notation work in the 16x simd case?
>
A float16 is accessed like v.s#, where v is a float16 type and # is a
single hex digit. It ain't pretty if one's not used to it.


> On Thu, Jan 16, 2014 at 6:16 PM, Jens Nockert <jens at nockert.se> wrote:
>
>>
>> On 2014/01/17, at 0:12, Carter Schonwald <carter.schonwald at gmail.com>
>> wrote:
>>
>> > whatever the notation, it needs to be one that
>> > a) gives good support for enforcing the "the shuffle is dictated at
>> compile time"
>> > b) is really simple, and easy to adjust for different size SIMD
>> vectors.   2x, 4x,8x,16x are all ones that currently and/or  will soon
>> exist on the CPU front at the very least!
>>
>> I prefer the OpenCL notation, vector.xyzw, vector.s0321 and so on.
>> Supports up to 16 elements, which is fine with most common SIMD types.
>> (AVX-512 with bytes and so on will always require horrible syntax, since
>> there are so many elements)
>
> I explicitly choose an index based element addressing scheme over
OpenGL/OpenCL's notation because:

   1. Not everyone speaks English; in fact, most people don't. Granted,
   most people on the Internet do.
   2. 'Most' SIMD types doesn't cut it for inclusion in a systems language
   or for the future in general; there's a lot of future left, so expect
   eventual use of SIMD types of unbounded size.
   3. There's nothing more natural for a systems language than offset
   indexing. There's nothing more generic either. I'm not saying that such a
   language shouldn't have features that make life easier for us mere mortals;
   I'm saying turning to the alphabet in this case would be a Bad Idea because
   they would be fulfilling the exact same role as a thing that does that role
   Better.
   4. OpenGL/OpenCL's notation is tacky (subjective, I know).
   5. i8x32 is already out of the question (and that's AVX1).
   6. someSimd.xyzw alphabet ordering/memory layout nonsense. What order is
   one actually using? Plus, apropos to #2 & #5, there aren't enough letters
   to support ze present or ze future.
   7. SIMD types are N-sized arrays of a primitive type; frankly, it's
   pretty smelly that rustc stipulates the use of tuple structures for this in
   the first place (not to mention the loss of inherent, simple element
   indexing), though I will acknowledge that the flaky support for stuffs like
   'type f32x4 = [f32, ..4]; impl f32x4 {}' or the lifetime hell of 'struct
   f32x4([f32x4]);' / 'strust f32x4 { priv d: [f32x4] };' makes the use of
   arrays less than ideal (the former plus compile time constant expressions
   in generics and, of course, swizzling, are going to make all the difference
   in the world to this end though) for SIMD use.

Following in the footsteps of OpenGL/OpenCL/mathematicians (particularly
the latter, who I think are well known for their 1337 software engineering
skillz && experience) in this regard would be a grave blunder for Rust.
That said, I think that supporting generic even/odd/etc masks (particularly
for certain swizzle--binop expressions that map to a somewhat common
instruction) would be advantageous, but that can be easily done without
involving rustc now that Mr. Fackler's external syntax extensions PR has
landed.

In other news, after prototyping what some basic CG maths would look like
and how it would 'write', I've decided to drop the lvalue form in favor of
the functional update form; Functional updates can be used in a way that
basically expresses the lvalue use. I didn't even use the lvalue form once
in the prototype and it's removal would simplify the changes needed to
rustc/syntax to just one new expression.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140117/5623f42a/attachment.html>

From jens at nockert.se  Fri Jan 17 03:28:35 2014
From: jens at nockert.se (Jens Nockert)
Date: Fri, 17 Jan 2014 12:28:35 +0100
Subject: [rust-dev] RFC: Tuple Swizzling/Shuffling
In-Reply-To: <CAPpP=LDjy9Bdh45JuOserBcR9ejspe6dfFEEPWyUyDL-oRk3Eg@mail.gmail.com>
References: <CAPpP=LBg+9C=Q95pTe4o-asdnmKozT_dM-iGEwia0K8Dc8birA@mail.gmail.com>
	<CAH8Jz7gOzUXJRYrMr34yaD7PP2-py5KStAkObxkggChYckE3NA@mail.gmail.com>
	<CAHYVw0yCE2+4qna6Hwug4DKw_Rk5D=H0395LV+EMkO69H91zEQ@mail.gmail.com>
	<BBC7B087-A853-4BA2-A3D0-480C4580147C@nockert.se>
	<CAHYVw0wYa3QNcrwObd6=7hXzwP_GsjxNrdaRPA9FSjugRTt29w@mail.gmail.com>
	<CAPpP=LDjy9Bdh45JuOserBcR9ejspe6dfFEEPWyUyDL-oRk3Eg@mail.gmail.com>
Message-ID: <E2FCBD34-19C7-42CB-99DB-1A87C2AFAAFE@nockert.se>

Hello,

I?m delighted that this topic is on the mailing list again, last time it wasn?t very popular, and I think rustc is more ready for this now than last time when I tried to implement it. Especially syntax extensions and feature flags.

I wrote a bit of thoughts after my last attempt on my blog (http://blog.aventine.se/post/55669497784/my-vision-for-rust-simd) and I know my preference is significantly different from other peoples, but you might find something you like there. It had some nice thoughts, I think.

On 2014/01/17, at 8:57, Richard Diamond <wichard at vitalitystudios.com> wrote:

> On Thu, Jan 16, 2014 at 5:33 PM, Carter Schonwald <carter.schonwald at gmail.com> wrote:
> A float16 is accessed like v.s#, where v is a float16 type and # is a single hex digit. It ain't pretty if one's not used to it.

Nothing is pretty if you are not used to it. I have a feeling that almost any syntax for arbitrary shuffles of more than 16 elements will look horrible.

> 1. Not everyone speaks English; in fact, most people don't. Granted, most people on the Internet do.

All other keywords are also in English, I don?t think this is an issue.

> 2. 'Most' SIMD types doesn't cut it for inclusion in a systems language or for the future in general; there's a lot of future left, so expect eventual use of SIMD types of unbounded size.

My personal opinion is that f64, followed by f32 are the most important SIMD types. Arbitrary shuffles of these types are unusual, and the OpenCL-like syntax can expand to these specific shuffles. (Transpose?)

Old vector systems used very large vectors, so there is obviously the possibility, I don?t think they will make a comeback, but I wouldn?t be surprised if they did.

> 3. There's nothing more natural for a systems language than offset indexing. There's nothing more generic either. I'm not saying that such a language shouldn't have features that make life easier for us mere mortals; I'm saying turning to the alphabet in this case would be a Bad Idea because they would be fulfilling the exact same role as a thing that does that role Better.

OpenCL notation uses indexes, there?s just a different syntax for indexing. And the difference in syntax shows the user that there?s a difference in semantics.

> 4. OpenGL/OpenCL's notation is tacky (subjective, I know).

My love for OpenCL notation is also subjective, I just happen to be brainwashed by OpenCL.

> 5. i8x32 is already out of the question (and that's AVX1).

There are no 8-bit shuffles in AVX, but I think they arrived in AVX2, so I think you have a point.

> 6. someSimd.xyzw alphabet ordering/memory layout nonsense. What order is one actually using? Plus, apropos to #2 & #5, there aren't enough letters to support ze present or ze future.

a.s0123 = b.s6431 is quite obvious in my opinion, but no, there are not enough indices for more than 16 elements. I personally don?t think that is much of a weakness, but if someone has a use-case for long 8-bit vector shuffles, then it would be cool to have a nice syntax for that too.

> 7. SIMD types are N-sized arrays of a primitive type; frankly, it's pretty smelly that rustc stipulates the use of tuple structures for this in the first place (not to mention the loss of inherent, simple element indexing), though I will acknowledge that the flaky support for stuffs like 'type f32x4 = [f32, ..4]; impl f32x4 {}' or the lifetime hell of 'struct f32x4([f32x4]);' / 'strust f32x4 { priv d: [f32x4] };' makes the use of arrays less than ideal (the former plus compile time constant expressions in generics and, of course, swizzling, are going to make all the difference in the world to this end though) for SIMD use.

I agree, there was at one point talk about a SIMD4<T> type and so on, that could evolve into SIMD<T, N> or something like that. But I don?t think that ended up anywhere due to a small bug in the compiler at the time.

In order of preference, my type declaration syntax preferences would be <f32, ..4>, simd!(f32 * 4), #[simd(4)] f32, #[simd] [f32, ..4], #[simd] (f32, f32, f32, f32). I don?t know how much stuff could be done in a syntax extension these days, but I think it is critical that SIMD types should be named, because that becomes confusing fast when implementing functions passing them around. You suddenly need a lot of types floating around, especially for intrinsics and so on.

> Following in the footsteps of OpenGL/OpenCL/mathematicians (particularly the latter, who I think are well known for their 1337 software engineering skillz && experience) in this regard would be a grave blunder for Rust.

I disagree, but this comment made my day, it was hilarious, thanks.

> That said, I think that supporting generic even/odd/etc masks (particularly for certain swizzle--binop expressions that map to a somewhat common instruction) would be advantageous, but that can be easily done without involving rustc now that Mr. Fackler's external syntax extensions PR has landed.

I agree, if we can implement the syntax outside of the compiler, then that would be nicer. Most people don?t need SIMD, and most people that need SIMD don?t need shuffles. (They only use libraries)

From jhaberman at gmail.com  Fri Jan 17 10:39:45 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Fri, 17 Jan 2014 10:39:45 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
Message-ID: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>

Hi Rust experts,

I would love your advice on how to wrap my C library with Rust, and
particularly how to map my library's ownership/mutability semantics
onto idiomatic Rust types, since my library's ownership/mutability
model is a great match for Rust's approach.

My library's objects have a two-phase lifecycle: when first created
they are mutable and are not thread-safe. When the client has set all
properties to their satisfaction, they perform a "freeze" operation,
after which the object is thread-safe and immutable.

Once immutable, they are also reference-counted. These objects also
can have references between them in a possibly-cyclic graph, but the
library handles intra-object cycles internally; the client only need
maintain their own refcount properly and the library will handle the
rest.

Here is a quick example of using my library's C API (the .h file for
this API is here:
https://github.com/haberman/upb/blob/master/upb/def.h)

  // Create a new object.
  upb_msgdef *md = upb_msgdef_new(&md);

  // It is initially mutable, so I can set its properties now.
  upb_msgdef_setfullname(md, "MyMessage", NULL);

  // Now freeze the msgdef; after this it may only be accessed through a
  // const pointer, though there is no way to enforce this in C/C++ except
  // with assert().
  upb_def_freeze(&md, 1, NULL);

  // Now that it is frozen we can take other refs on it.
  // The second parameter to ref/unref is used in debug mode to match
  // refs and unrefs, to make refcounting bugs easier to track down.
  const upb_msgdef *md2 = md;
  upb_msgdef_ref(md2, &md2);

  // This function is thread-safe and allowed on frozen objs.
  const char *fullname = upb_msgdef_fullname(md2);

  // We must release all refs to prevent the object from leaking.
  upb_msgdef_unref(md, &md);
  upb_msgdef_unref(md2, &md2);

This seems like a great match for Rust, because an object could be
created as "mut" and local to a single task, but then "become" non-mut
and be sharable between tasks once frozen. And the refcounting scheme
sounds like a great match for the Arc model.

I could just use a little help on how to map this onto Rust's existing
libraries and traits:

1. Can I write a "freeze" function in Rust where my mut pointers
"become" non-mut pointers in a way that the mut pointers are no longer
accessible?

2. Is my notion of freezing the same as Rust's "Freeze" trait? Is
there a pattern I should follow to make my type "fit in" with the
stdlib better?

3. I think I can write a very Arc-like interface to my refcounting.
Will my individual refcounting wrappers let me take their address so I
can pass it to the second param of my ref/unref functions?

Thanks,
Josh

From erick.tryzelaar at gmail.com  Fri Jan 17 11:46:35 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Fri, 17 Jan 2014 11:46:35 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
Message-ID: <CALdfqQKzNAJNZQ2oPOobuntQgg26ApuL+WLEjbLpoyPGYnPm2g@mail.gmail.com>

I can help with the first question. You can use move semantics to do this.
For example:

```
pub struct MessageDef {
    fullname: ~str,
}

impl MessageDef {
    fn new() -> MessageDef { MessageDef { ... } }
    fn set_fullname(&mut self, s: &str) { self.fullname = s.to_str(); }
}

pub struct Message {
    priv def: MessageDef,
}

impl Message {
    fn new(def: MessageDef) -> Message { Message { def: def } }
    fn get_fullname<'a>(&self) -> &'a ~str { self.def.fullname }
}



fn main() {
    let def = MessageDef::new();
    def.set_fullname("foo");
    let msg = Message::new(def);
    // def is now inaccessible.
}
```

I'm afraid I can't help out much with two and three. The simplest is to
have `Message::new` wrap the `Message` struct in an Arc. Then it's
guaranteed to be safe to access threads. The downside is that it wouldn't
use any of your reference counting code so it might be more tricky to
debug. A more complicated approach would be to make an Arc-like structure
that uses your code for reference counting instead of Arcs. Unfortunately
while I know it's possible, I couldn't tell you how to do it.



On Fri, Jan 17, 2014 at 10:39 AM, Josh Haberman <jhaberman at gmail.com> wrote:

> Hi Rust experts,
>
> I would love your advice on how to wrap my C library with Rust, and
> particularly how to map my library's ownership/mutability semantics
> onto idiomatic Rust types, since my library's ownership/mutability
> model is a great match for Rust's approach.
>
> My library's objects have a two-phase lifecycle: when first created
> they are mutable and are not thread-safe. When the client has set all
> properties to their satisfaction, they perform a "freeze" operation,
> after which the object is thread-safe and immutable.
>
> Once immutable, they are also reference-counted. These objects also
> can have references between them in a possibly-cyclic graph, but the
> library handles intra-object cycles internally; the client only need
> maintain their own refcount properly and the library will handle the
> rest.
>
> Here is a quick example of using my library's C API (the .h file for
> this API is here:
> https://github.com/haberman/upb/blob/master/upb/def.h)
>
>   // Create a new object.
>   upb_msgdef *md = upb_msgdef_new(&md);
>
>   // It is initially mutable, so I can set its properties now.
>   upb_msgdef_setfullname(md, "MyMessage", NULL);
>
>   // Now freeze the msgdef; after this it may only be accessed through a
>   // const pointer, though there is no way to enforce this in C/C++ except
>   // with assert().
>   upb_def_freeze(&md, 1, NULL);
>
>   // Now that it is frozen we can take other refs on it.
>   // The second parameter to ref/unref is used in debug mode to match
>   // refs and unrefs, to make refcounting bugs easier to track down.
>   const upb_msgdef *md2 = md;
>   upb_msgdef_ref(md2, &md2);
>
>   // This function is thread-safe and allowed on frozen objs.
>   const char *fullname = upb_msgdef_fullname(md2);
>
>   // We must release all refs to prevent the object from leaking.
>   upb_msgdef_unref(md, &md);
>   upb_msgdef_unref(md2, &md2);
>
> This seems like a great match for Rust, because an object could be
> created as "mut" and local to a single task, but then "become" non-mut
> and be sharable between tasks once frozen. And the refcounting scheme
> sounds like a great match for the Arc model.
>
> I could just use a little help on how to map this onto Rust's existing
> libraries and traits:
>
> 1. Can I write a "freeze" function in Rust where my mut pointers
> "become" non-mut pointers in a way that the mut pointers are no longer
> accessible?
>
> 2. Is my notion of freezing the same as Rust's "Freeze" trait? Is
> there a pattern I should follow to make my type "fit in" with the
> stdlib better?
>
> 3. I think I can write a very Arc-like interface to my refcounting.
> Will my individual refcounting wrappers let me take their address so I
> can pass it to the second param of my ref/unref functions?
>
> Thanks,
> Josh
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140117/81faea3a/attachment-0001.html>

From alex at crichton.co  Fri Jan 17 12:09:01 2014
From: alex at crichton.co (Alex Crichton)
Date: Fri, 17 Jan 2014 12:09:01 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
Message-ID: <CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>

> Hi Rust experts,

How flattering!

> This seems like a great match for Rust, because an object could be
> created as "mut" and local to a single task, but then "become" non-mut
> and be sharable between tasks once frozen. And the refcounting scheme
> sounds like a great match for the Arc model.

I agree! You may want to think about things a little differently
though. Using something like Arc means that the refcounting is managed
in rust, whereas it sounds like you're already dealing with it in your
library. You just want to write *wrapper* types which perform the
relevant calls to C.

What you'll likely end up having is two types. Both types internally
are just an unsafe C pointer (which is initialized in your library)
which allow interfacing with the underlying C object. You'll have a
Mutable version for mutable methods and then an Immutable version for
the methods which don't mutate (where creating the immutable version
consumes the mutable version in rust code).

I've answered some specific questions below, but if you have any more,
feel free to ask! You can reach out to me as acrichto on IRC, and I
always love to read code :)

> 1. Can I write a "freeze" function in Rust where my mut pointers
> "become" non-mut pointers in a way that the mut pointers are no longer
> accessible?

I think Erick answered this well. Rust allows you to specify whether a
function requests a mutable pointer "&mut self", or an immutable
pointer "&self", but there only way to forbid methods is to just have
a type that doesn't have those methods.

> 2. Is my notion of freezing the same as Rust's "Freeze" trait? Is
> there a pattern I should follow to make my type "fit in" with the
> stdlib better?

Not quite. The rust Freeze trait is a "kind" which basically means
that the compiler will infer it based on the structure of a type. This
kind is the notion that an object cannot be mutated through a &self
pointer (for example Cell is *not* Freeze).

Your object does indeed ascribe to Freeze, but you don't need to worry
about dealing with the Freeze trait itself. Your library already deals
with freezing internally, so when you write Rust bindings the best way
to expose this would be to have separate types for the
mutable/immutable methods. As Erick suggested, creating the immutable
would consume the mutable type. Under the hood it would look like:

pub struct MyMutableBuilder {
    priv ptr: *my_c_type_t
}

pub struct MyImmutableStruct {
    priv ptr: *my_c_type_t
}

> 3. I think I can write a very Arc-like interface to my refcounting.
> Will my individual refcounting wrappers let me take their address so I
> can pass it to the second param of my ref/unref functions?

I'm a little confused by this question because this sounds like you
want to *port* your library to Rust rather than *wrap* your library
with Rust. If you're porting, then I would certainly recommend Arc. If
you're wrapping, then you wouldn't need Arc because you're already
doing that atomic refcounts yourself.

What you'll probably want is something like:

impl Clone for MyImmutableStruct {
    fn clone(&self) -> MyImmutableStruct {
        unsafe { my_c_ref_function(self.ptr); }
        MyImmutableStruct { ptr: self.ptr }
    }
}

impl Drop for MyImmutableStruct {
    fn drop(&mut self) {
        unsafe { my_c_unref_funtion(self.ptr); }
    }
}

Basically, when you clone() your object, it bumps the refcount. You
can then send the clone'd object to another thread. When the objects
go out of scope (get destroyed) they'll deref the refcount, allowing
you to safely clean things up.

From jhaberman at gmail.com  Fri Jan 17 16:15:29 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Fri, 17 Jan 2014 16:15:29 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
Message-ID: <CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>

Hi there, thanks for the friendly replies. This is really helpful.

> You may want to think about things a little differently
> though. Using something like Arc means that the refcounting
> is managed in rust, whereas it sounds like you're already
> dealing with it in your library.

Yes, I didn't mean to imply that I would use Arc directly,
just that I would use it as a model for my own refcounted
interface (ie. by having a clone() function).

> What you'll likely end up having is two types. Both types
> internally are just an unsafe C pointer (which is
> initialized in your library) which allow interfacing with
> the underlying C object.

Yes, that sounds like the right direction to me, except that
I would *really* prefer to have one single type with mut and
non-mut versions.  If I have to introduce two types, it means
that any algorithms that operate on these types have to
either be written twice or use generics.  And they aren't
two types really, they're just mutable and non-mutable versions
of the same type, so why not model them that way?

> I think Erick answered this well. Rust allows you to specify
> whether a function requests a mutable pointer "&mut self",
> or an immutable pointer "&self", but there only way to
> forbid methods is to just have a type that doesn't have
> those methods.

This is the part that I don't follow; why can't I just mark
my mutable-only methods as taking a mutable self?  The
following example does what I expect and seems to give me what
I need:

  pub struct Box {
    priv x: i32,
  }

  impl Box {
    fn set_x(&mut self, val: i32) { self.x = val }
    fn x(&self) -> i32 { self.x }
  }

  fn main() {
    let mut var1 = Box {x: 1};
    let val1 = var1.x();
    var1.set_x(1);

    let var2 = Box {x: 2};
    let val2 = var2.x();
    // This fails to compile, because var2 is not mutable.
    var2.set_x(2);
  }

Using this model, I could have just one type and mark the
methods that are mutable-only as taking a &mut self.

> What you'll probably want is something like:
>
> impl Clone for MyImmutableStruct {
>     fn clone(&self) -> MyImmutableStruct {
>         unsafe { my_c_ref_function(self.ptr); }
>         MyImmutableStruct { ptr: self.ptr }
>     }
> }
>
> impl Drop for MyImmutableStruct {
>     fn drop(&mut self) {
>         unsafe { my_c_unref_funtion(self.ptr); }
>     }
> }

This looks about right.  What I was asking is how to furnish
the second parameter to my ref/unref functions: the "owner".
In my API all refs have an "owner", which is simply a
"const void*" that must be distinct from all other ref owners
for this object.  It's a debugging facility that makes it
easier to track down ref leaks.  In C or C++, I usually use
the address of the variable that is storing the pointer to
my MessageDef object as the ref owner.

So I want to do something sort of like:

impl Clone for MessageDef {
    fn clone(&self) -> MessageDef {
        let ret = MyImmutableStruct { ptr: self.ptr };
        unsafe { upb_msgdef_ref(ret.ptr, &ret.ptr); }
        ret
    }
}

impl Drop for MessageDef {
    fn drop(&self) {
        unsafe { upb_msgdef_unref(self.ptr, &self.ptr); }
    }
}

However I am wondering if there is any way to actually take
the address of a Rust variable as I did above (and if it is
possible, to guarantee that the address is stable over the
lifetime of the object).

Thanks,
Josh

On Fri, Jan 17, 2014 at 12:09 PM, Alex Crichton <alex at crichton.co> wrote:
>> Hi Rust experts,
>
> How flattering!
>
>> This seems like a great match for Rust, because an object could be
>> created as "mut" and local to a single task, but then "become" non-mut
>> and be sharable between tasks once frozen. And the refcounting scheme
>> sounds like a great match for the Arc model.
>
> I agree! You may want to think about things a little differently
> though. Using something like Arc means that the refcounting is managed
> in rust, whereas it sounds like you're already dealing with it in your
> library. You just want to write *wrapper* types which perform the
> relevant calls to C.
>
> What you'll likely end up having is two types. Both types internally
> are just an unsafe C pointer (which is initialized in your library)
> which allow interfacing with the underlying C object. You'll have a
> Mutable version for mutable methods and then an Immutable version for
> the methods which don't mutate (where creating the immutable version
> consumes the mutable version in rust code).
>
> I've answered some specific questions below, but if you have any more,
> feel free to ask! You can reach out to me as acrichto on IRC, and I
> always love to read code :)
>
>> 1. Can I write a "freeze" function in Rust where my mut pointers
>> "become" non-mut pointers in a way that the mut pointers are no longer
>> accessible?
>
> I think Erick answered this well. Rust allows you to specify whether a
> function requests a mutable pointer "&mut self", or an immutable
> pointer "&self", but there only way to forbid methods is to just have
> a type that doesn't have those methods.
>
>> 2. Is my notion of freezing the same as Rust's "Freeze" trait? Is
>> there a pattern I should follow to make my type "fit in" with the
>> stdlib better?
>
> Not quite. The rust Freeze trait is a "kind" which basically means
> that the compiler will infer it based on the structure of a type. This
> kind is the notion that an object cannot be mutated through a &self
> pointer (for example Cell is *not* Freeze).
>
> Your object does indeed ascribe to Freeze, but you don't need to worry
> about dealing with the Freeze trait itself. Your library already deals
> with freezing internally, so when you write Rust bindings the best way
> to expose this would be to have separate types for the
> mutable/immutable methods. As Erick suggested, creating the immutable
> would consume the mutable type. Under the hood it would look like:
>
> pub struct MyMutableBuilder {
>     priv ptr: *my_c_type_t
> }
>
> pub struct MyImmutableStruct {
>     priv ptr: *my_c_type_t
> }
>
>> 3. I think I can write a very Arc-like interface to my refcounting.
>> Will my individual refcounting wrappers let me take their address so I
>> can pass it to the second param of my ref/unref functions?
>
> I'm a little confused by this question because this sounds like you
> want to *port* your library to Rust rather than *wrap* your library
> with Rust. If you're porting, then I would certainly recommend Arc. If
> you're wrapping, then you wouldn't need Arc because you're already
> doing that atomic refcounts yourself.
>
> What you'll probably want is something like:
>
> impl Clone for MyImmutableStruct {
>     fn clone(&self) -> MyImmutableStruct {
>         unsafe { my_c_ref_function(self.ptr); }
>         MyImmutableStruct { ptr: self.ptr }
>     }
> }
>
> impl Drop for MyImmutableStruct {
>     fn drop(&mut self) {
>         unsafe { my_c_unref_funtion(self.ptr); }
>     }
> }
>
> Basically, when you clone() your object, it bumps the refcount. You
> can then send the clone'd object to another thread. When the objects
> go out of scope (get destroyed) they'll deref the refcount, allowing
> you to safely clean things up.

From alex at crichton.co  Fri Jan 17 16:32:24 2014
From: alex at crichton.co (Alex Crichton)
Date: Fri, 17 Jan 2014 16:32:24 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
Message-ID: <CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>

> This is the part that I don't follow; why can't I just mark
> my mutable-only methods as taking a mutable self?

The problem with this is that it requires that the *owner* of a type
have a *mutable slot*, and you cannot prevent owners from declaring
their slots as mutable. In the example you gave, you could write "let
mut var2 = Box { x: 2 }" and it would compile, there's nothing
preventing usage of the "mut" at the owner.

One possible solution is to use a thing called "shadow type parameters"

pub enum Mutable {}
pub enum Frozen {}
pub struct Box<State> {
    priv x: i32,
}

// methods that only work on a mutable box
impl Box<Mutable> {
    fn new() -> Box<Mutable> { Box { x: 2 } }
    fn set_x(&mut self, val: i32) -> { self.x = val; }
    fn freeze(self) -> Box<Frozen> { Box { x: self.x } }
}

// methods that work on all boxes (mutable and immutable)
impl<T> Box<T> {
    fn x(&self) -> i32 { self.x }
}

impl Clone for Box<Frozen> { ... }

impl<T> Drop for Box<T> { ... }

With something like this you can write code that works over generic
boxes (immutable or mutable), but you have a clear separation of what
a mutable box can do and what a frozen box can do.

>> impl Clone for MyImmutableStruct {
>>     fn clone(&self) -> MyImmutableStruct {
>>         unsafe { my_c_ref_function(self.ptr); }
>>         MyImmutableStruct { ptr: self.ptr }
>>     }
>> }
>>
>> impl Drop for MyImmutableStruct {
>>     fn drop(&mut self) {
>>         unsafe { my_c_unref_funtion(self.ptr); }
>>     }
>> }
>
> This looks about right.  What I was asking is how to furnish
> the second parameter to my ref/unref functions: the "owner".
> In my API all refs have an "owner", which is simply a
> "const void*" that must be distinct from all other ref owners
> for this object.  It's a debugging facility that makes it
> easier to track down ref leaks.  In C or C++, I usually use
> the address of the variable that is storing the pointer to
> my MessageDef object as the ref owner.

Sadly this doesn't translate to rust. In your example, you're
declaring the owner as a stack pointer, but then that stack pointer is
invalidated as soon as the function returns. You'll probably not want
to implement the trait Clone or you'll want to find some other way to
track owners perhaps.

> However I am wondering if there is any way to actually take
> the address of a Rust variable as I did above (and if it is
> possible, to guarantee that the address is stable over the
> lifetime of the object).

Without making an explicit allocation, you have no guarantee about the
stability of an address because objects can be moved from place to
place.

From jhaberman at gmail.com  Fri Jan 17 16:53:57 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Fri, 17 Jan 2014 16:53:57 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
Message-ID: <CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>

On Fri, Jan 17, 2014 at 4:32 PM, Alex Crichton <alex at crichton.co> wrote:
>> This is the part that I don't follow; why can't I just mark
>> my mutable-only methods as taking a mutable self?
>
> The problem with this is that it requires that the *owner* of a type
> have a *mutable slot*, and you cannot prevent owners from declaring
> their slots as mutable. In the example you gave, you could write "let
> mut var2 = Box { x: 2 }" and it would compile, there's nothing
> preventing usage of the "mut" at the owner.

Are you saying (if I may lapse into C++ vocab for a moment) that I can't
hide the copy constructor? Anyone can copy my non-mut struct into a
mut struct at any time and I don't have any say in the matter?

Feel free to correct this into Rust-speak.  :)

> One possible solution is to use a thing called "shadow type parameters"
>
> pub enum Mutable {}
> pub enum Frozen {}
> pub struct Box<State> {
>     priv x: i32,
> }
>
> // methods that only work on a mutable box
> impl Box<Mutable> {
>     fn new() -> Box<Mutable> { Box { x: 2 } }
>     fn set_x(&mut self, val: i32) -> { self.x = val; }
>     fn freeze(self) -> Box<Frozen> { Box { x: self.x } }
> }
>
> // methods that work on all boxes (mutable and immutable)
> impl<T> Box<T> {
>     fn x(&self) -> i32 { self.x }
> }
>
> impl Clone for Box<Frozen> { ... }
>
> impl<T> Drop for Box<T> { ... }
>
> With something like this you can write code that works over generic
> boxes (immutable or mutable), but you have a clear separation of what
> a mutable box can do and what a frozen box can do.

Hmm, this looks promising. Not as nice as mut/non but not as bad as
two unrelated types. What does the declaration/use of these types
look like syntactically? Does the user write out Mutable and Frozen?

>> What I was asking is how to furnish
>> the second parameter to my ref/unref functions: the "owner".
>> In my API all refs have an "owner", which is simply a
>> "const void*" that must be distinct from all other ref owners
>> for this object.  It's a debugging facility that makes it
>> easier to track down ref leaks.  In C or C++, I usually use
>> the address of the variable that is storing the pointer to
>> my MessageDef object as the ref owner.
>
> Sadly this doesn't translate to rust. In your example, you're
> declaring the owner as a stack pointer, but then that stack pointer is
> invalidated as soon as the function returns. You'll probably not want
> to implement the trait Clone or you'll want to find some other way to
> track owners perhaps.

Yeah, maybe I'll have to allow people to pass NULL as an owner
if they can't easily provide one. Hopefully this wouldn't give up
too much since cases like this should be guaranteed correct by
Rust anyway (assuming I write the wrappers right).

Thanks,
Josh

From alex at crichton.co  Fri Jan 17 17:02:07 2014
From: alex at crichton.co (Alex Crichton)
Date: Fri, 17 Jan 2014 17:02:07 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
	<CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
Message-ID: <CAFnh-mfifJhr5osEu+wzMAYwMqqgtiM-v9uVbL4fRVbiZ=S_+g@mail.gmail.com>

>> The problem with this is that it requires that the *owner* of a type
>> have a *mutable slot*, and you cannot prevent owners from declaring
>> their slots as mutable. In the example you gave, you could write "let
>> mut var2 = Box { x: 2 }" and it would compile, there's nothing
>> preventing usage of the "mut" at the owner.
>
> Are you saying (if I may lapse into C++ vocab for a moment) that I can't
> hide the copy constructor? Anyone can copy my non-mut struct into a
> mut struct at any time and I don't have any say in the matter?

I'm not very familiar with what exactly a C++ copy constructor is, but
rust-wise it mostly has to do with ownerships and moves. Let's say you
have one type, Box. This type has &mut and & methods (dictating when
they're call-able). The problem is that &mut is dictated by the
*owner* of the box. So if your clone() method hands out another Box,
then if whomever owns the box decides to declare it as mutable "let
mut box = orig_blox.clone()", then they'll be able to call the '&mut'
methods.

You need to provide some method of forbidding calling &mut methods,
which would probably involve leveraging the type system in one way or
another. One way is to have two types. The other I know of is to have
the shadow type parameters below. You basically need to forbid "&mut
self" from ever being possible. Something like Arc can accomplish this
because the Arc *owns* the data. The arc then decides to never hand
out &mut pointers, only & pointers. This is along the same lines as a
second type for you though, which I think you're right in trying to
avoid.

Using a shadow type parameter is kinda like having the ancient rust
idea of "type state", although I don't know how that worked or how
equivalent it is to shadow type parameters.

>> With something like this you can write code that works over generic
>> boxes (immutable or mutable), but you have a clear separation of what
>> a mutable box can do and what a frozen box can do.
>
> Hmm, this looks promising. Not as nice as mut/non but not as bad as
> two unrelated types. What does the declaration/use of these types
> look like syntactically? Does the user write out Mutable and Frozen?

Using this implementation, it's not super-elegant, but it's perhaps
better than having two types:

let mut x = Box::new();
x.set_x(100);
let x = x.freeze();
let y = x.clone();
do spawn { use(&y) }
use(&x);

The difficult comes up whenever you have to name the type

fn foo(t: Box<Frozen>) {} // only works on frozen boxes
fn bar(t: Box<Mutable>) {} // only works on mutable boxes
fn baz<T>(t: Box<T>) {} // works on any flavor of box

I would probably say that the shadow type parameter route is the
direction that you'd want to go in, but maybe I'm missing something!

From danielmicay at gmail.com  Fri Jan 17 17:07:33 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 17 Jan 2014 20:07:33 -0500
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
	<CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
Message-ID: <CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>

On Fri, Jan 17, 2014 at 7:53 PM, Josh Haberman <jhaberman at gmail.com> wrote:
>
> Are you saying (if I may lapse into C++ vocab for a moment) that I can't
> hide the copy constructor? Anyone can copy my non-mut struct into a
> mut struct at any time and I don't have any say in the matter?
>
> Feel free to correct this into Rust-speak.  :)

Every type in Rust can be assigned, passed or returned by-value. This
is always semantically equivalent to a shallow copy, as they are in C.
If the type has a destructor, closure or `&mut T` inside then the copy
is considered a move of ownership.

That's why there's a `Clone` trait in the standard library. It's the
minimum work to go from a non-owning reference to a value, rather than
just being the built-in shallow copy potentially moving ownership from
the source to the destination.

You're also free to make fields private.

From danielmicay at gmail.com  Fri Jan 17 17:09:28 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 17 Jan 2014 20:09:28 -0500
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
	<CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
	<CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>
Message-ID: <CA+DvKQKNByyYNSuSATngNvqPCAKiToYMv5moRZ8G0Lo5Nj6QBA@mail.gmail.com>

On Fri, Jan 17, 2014 at 8:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Fri, Jan 17, 2014 at 7:53 PM, Josh Haberman <jhaberman at gmail.com> wrote:
>>
>> Are you saying (if I may lapse into C++ vocab for a moment) that I can't
>> hide the copy constructor? Anyone can copy my non-mut struct into a
>> mut struct at any time and I don't have any say in the matter?
>>
>> Feel free to correct this into Rust-speak.  :)
>
> Every type in Rust can be assigned, passed or returned by-value. This
> is always semantically equivalent to a shallow copy, as they are in C.
> If the type has a destructor, closure or `&mut T` inside then the copy
> is considered a move of ownership.
>
> That's why there's a `Clone` trait in the standard library. It's the
> minimum work to go from a non-owning reference to a value, rather than
> just being the built-in shallow copy potentially moving ownership from
> the source to the destination.
>
> You're also free to make fields private.

For example, you can have a type with private fields and the
`#[no_send]` attribute. You can then take it by-value in a function
returning the thread-safe type without `#[no_send]`. If it has a
destructor, then the caller is unable to implicitly copy it without
moving ownership and you would need to implement `Clone` to permit
making more instances.

From edward.yu.wang at gmail.com  Fri Jan 17 23:45:58 2014
From: edward.yu.wang at gmail.com (Edward Wang)
Date: Sat, 18 Jan 2014 15:45:58 +0800
Subject: [rust-dev] A regression: eh-personality lang item is always needed
 regardless no-landing-pads flag
Message-ID: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>

Hi list,

I built a rustc minutes ago from the source to pull down Niko's fix for
temporary lifetime (https://github.com/mozilla/rust/pull/11585). It works
great. In the meantime, there seems to be a possible regression introduced
by unknown commit of the past day or so. That is, the eh-personality lang
item is always needed now regardless the '-Z no-landing-pads' flag.

I don't have a test case to reproduce the issue yet. Any suggestion on how
to track down the root cause of this regression?

Regards,
Edward
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140118/8048ff6c/attachment.html>

From danielmicay at gmail.com  Fri Jan 17 23:48:01 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 18 Jan 2014 02:48:01 -0500
Subject: [rust-dev] A regression: eh-personality lang item is always
 needed regardless no-landing-pads flag
In-Reply-To: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>
References: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>
Message-ID: <CA+DvKQLUKf6t9R1sMJ-Ax3D=CL9qn+FVppXHcFec_DEzaJM-Gw@mail.gmail.com>

On Sat, Jan 18, 2014 at 2:45 AM, Edward Wang <edward.yu.wang at gmail.com> wrote:
> Hi list,
>
> I built a rustc minutes ago from the source to pull down Niko's fix for
> temporary lifetime (https://github.com/mozilla/rust/pull/11585). It works
> great. In the meantime, there seems to be a possible regression introduced
> by unknown commit of the past day or so. That is, the eh-personality lang
> item is always needed now regardless the '-Z no-landing-pads' flag.
>
> I don't have a test case to reproduce the issue yet. Any suggestion on how
> to track down the root cause of this regression?
>
> Regards,
> Edward

You also need the `-Z lto` flag.

From edward.yu.wang at gmail.com  Fri Jan 17 23:57:22 2014
From: edward.yu.wang at gmail.com (Edward Wang)
Date: Sat, 18 Jan 2014 15:57:22 +0800
Subject: [rust-dev] A regression: eh-personality lang item is always
 needed regardless no-landing-pads flag
In-Reply-To: <CA+DvKQLUKf6t9R1sMJ-Ax3D=CL9qn+FVppXHcFec_DEzaJM-Gw@mail.gmail.com>
References: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>
	<CA+DvKQLUKf6t9R1sMJ-Ax3D=CL9qn+FVppXHcFec_DEzaJM-Gw@mail.gmail.com>
Message-ID: <CAEqtYYgwpEHX0cddT49m1cAkO0TTnmRd4K62kQvKyD+LiytUoA@mail.gmail.com>

Well, I did. It all works very well until I pulled down the latest source.
I'd like to dive into the rust source code but where to start?


On Sat, Jan 18, 2014 at 3:48 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 18, 2014 at 2:45 AM, Edward Wang <edward.yu.wang at gmail.com>
> wrote:
> > Hi list,
> >
> > I built a rustc minutes ago from the source to pull down Niko's fix for
> > temporary lifetime (https://github.com/mozilla/rust/pull/11585). It
> works
> > great. In the meantime, there seems to be a possible regression
> introduced
> > by unknown commit of the past day or so. That is, the eh-personality lang
> > item is always needed now regardless the '-Z no-landing-pads' flag.
> >
> > I don't have a test case to reproduce the issue yet. Any suggestion on
> how
> > to track down the root cause of this regression?
> >
> > Regards,
> > Edward
>
> You also need the `-Z lto` flag.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140118/2d0b9a4d/attachment.html>

From danielmicay at gmail.com  Sat Jan 18 02:02:27 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 18 Jan 2014 05:02:27 -0500
Subject: [rust-dev] A regression: eh-personality lang item is always
 needed regardless no-landing-pads flag
In-Reply-To: <CAEqtYYgwpEHX0cddT49m1cAkO0TTnmRd4K62kQvKyD+LiytUoA@mail.gmail.com>
References: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>
	<CA+DvKQLUKf6t9R1sMJ-Ax3D=CL9qn+FVppXHcFec_DEzaJM-Gw@mail.gmail.com>
	<CAEqtYYgwpEHX0cddT49m1cAkO0TTnmRd4K62kQvKyD+LiytUoA@mail.gmail.com>
Message-ID: <CA+DvKQJTwQh3vFZPpKPKKNB46urS-WvUG2oFi98CB8ggC1rKDQ@mail.gmail.com>

On Sat, Jan 18, 2014 at 2:57 AM, Edward Wang <edward.yu.wang at gmail.com> wrote:
> Well, I did. It all works very well until I pulled down the latest source.
> I'd like to dive into the rust source code but where to start?

Ah, yes. I can confirm that it's broken for me too. Is there already
an issue report? It's a bit sad that there are no tests for
freestanding Rust.

From edward.yu.wang at gmail.com  Sat Jan 18 04:22:00 2014
From: edward.yu.wang at gmail.com (Edward Wang)
Date: Sat, 18 Jan 2014 20:22:00 +0800
Subject: [rust-dev] A regression: eh-personality lang item is always
 needed regardless no-landing-pads flag
In-Reply-To: <CA+DvKQJTwQh3vFZPpKPKKNB46urS-WvUG2oFi98CB8ggC1rKDQ@mail.gmail.com>
References: <CAEqtYYiqPbw_Av7LRC9mOWP-WFrR2k=yUrciqCEKU6ESXF+3DQ@mail.gmail.com>
	<CA+DvKQLUKf6t9R1sMJ-Ax3D=CL9qn+FVppXHcFec_DEzaJM-Gw@mail.gmail.com>
	<CAEqtYYgwpEHX0cddT49m1cAkO0TTnmRd4K62kQvKyD+LiytUoA@mail.gmail.com>
	<CA+DvKQJTwQh3vFZPpKPKKNB46urS-WvUG2oFi98CB8ggC1rKDQ@mail.gmail.com>
Message-ID: <CAEqtYYgiDAYoZfFhk-kmmgHg7dy-FhyhADYrcbynchuEnFDMCQ@mail.gmail.com>

I just did: https://github.com/mozilla/rust/issues/11647


On Sat, Jan 18, 2014 at 6:02 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Jan 18, 2014 at 2:57 AM, Edward Wang <edward.yu.wang at gmail.com>
> wrote:
> > Well, I did. It all works very well until I pulled down the latest
> source.
> > I'd like to dive into the rust source code but where to start?
>
> Ah, yes. I can confirm that it's broken for me too. Is there already
> an issue report? It's a bit sad that there are no tests for
> freestanding Rust.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140118/2a2ff212/attachment-0001.html>

From jhaberman at gmail.com  Sat Jan 18 13:24:54 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Sat, 18 Jan 2014 13:24:54 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
	<CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
	<CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>
Message-ID: <CAOM7mawUO3E0F2sCjLgCbOPMtqNVd-TP=WT1eKZbqVsJEuLO7Q@mail.gmail.com>

On Fri, Jan 17, 2014 at 5:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> Every type in Rust can be assigned, passed or returned by-value. This
> is always semantically equivalent to a shallow copy, as they are in C.
> If the type has a destructor, closure or `&mut T` inside then the copy
> is considered a move of ownership.

Interesting. I have also learned (thanks to people on IRC) that you
cannot move out of a borrowed pointer. So this gave me a new idea for
the wrapper that I have written a little prototype for:

https://gist.github.com/haberman/8496516

And this is the little fake version of my library you can link against it:

https://gist.github.com/haberman/8496487

The idea behind this wrapper is that we model my C type as a Rust unit
struct (with no members) that serves only to hold the pointer and
methods on the struct. But the wrapper only allows you to obtain
borrowed refs to this struct through Arc-like get() methods, so you
can never do an ownership move (and can therefore never convert a
non-mut ref into a mut ref).

Then any functions that want to take my type as a parameter just
accept a borrowed, non-mut reference. They can nicely accept either
mut or non-mut references:

fn algorithm_on_fielddef(f: &FieldDef) {
  // ...
}

I just realized unfortunately that this scheme can't prevent the user
from saying:

  let field_def = FieldDef;
  field_def.number();  // Crash, this isn't actually a legitimate FieldDef.

Any way to prevent this, so that only I am allowed to create FieldDef
structs but can still return references to them in my public API?

Thanks,
Josh

From jhaberman at gmail.com  Sat Jan 18 19:18:17 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Sat, 18 Jan 2014 19:18:17 -0800
Subject: [rust-dev] sandboxing Rust?
Message-ID: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>

Is it a design goal of Rust that you will be able to run untrusted
code in-process safely?

In other words, by whitelisting the set of available APIs and
prohibiting unsafe blocks, would you be able to (eventually, once Rust
is stable and hardened) run untrusted code in the same address space
without it intentionally or unintentionally escaping its sandbox?

(Sorry if this a FAQ, I couldn't find any info about it).

Thanks,
Josh

From corey at octayn.net  Sat Jan 18 19:21:36 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 18 Jan 2014 22:21:36 -0500
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
Message-ID: <CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>

Rust's safety model is not intended to prevent untrusted code from
doing evil things.

On Sat, Jan 18, 2014 at 10:18 PM, Josh Haberman <jhaberman at gmail.com> wrote:
> Is it a design goal of Rust that you will be able to run untrusted
> code in-process safely?
>
> In other words, by whitelisting the set of available APIs and
> prohibiting unsafe blocks, would you be able to (eventually, once Rust
> is stable and hardened) run untrusted code in the same address space
> without it intentionally or unintentionally escaping its sandbox?
>
> (Sorry if this a FAQ, I couldn't find any info about it).
>
> Thanks,
> Josh
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From jack at metajack.im  Sat Jan 18 19:23:44 2014
From: jack at metajack.im (Jack Moffitt)
Date: Sat, 18 Jan 2014 20:23:44 -0700
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
Message-ID: <CAP7VpsUcdtpOGanhEpBWzSsrizTKfvGrnwUgqa2Rd8DxZvisJg@mail.gmail.com>

> Rust's safety model is not intended to prevent untrusted code from
> doing evil things.

We'd like something like this for Servo, but I think the idea was to
see if we couldn't use NaCl to do this kind of sandboxing. The NaCl
devs seemed to think this might be interesting as well.

jack.

From bytbox at gmail.com  Sat Jan 18 19:30:09 2014
From: bytbox at gmail.com (Scott Lawrence)
Date: Sat, 18 Jan 2014 22:30:09 -0500 (EST)
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
Message-ID: <alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>

On Sat, 18 Jan 2014, Corey Richardson wrote:

> Rust's safety model is not intended to prevent untrusted code from
> doing evil things.

Doesn't it succesfully do that, though? Or at least with only a small amount 
of extra logic? For example, suppose I accept, compile, and run arbitrary rust 
code, with only the requirement that there be no "unsafe" blocks (ignore for a 
moment the fact that libstd uses unsafe). Barring compiler bugs, I think it's 
then guaranteed nothing bad can happen.

It seems to me that (as usual with languages like Rust) it's simply a mildly 
arduous task of maintaining a parallel libstd implementation to be used for 
sandboxing, which either lacks implementations for dangerous functionality, or 
has them replaced with special versions that perform correct permissions 
checking. That, coupled with forbidding unsafe blocks in submitted code, 
should solve the problem.

I could be completely wrong. (Is there some black magic I don't know?)

>
> On Sat, Jan 18, 2014 at 10:18 PM, Josh Haberman <jhaberman at gmail.com> wrote:
>> Is it a design goal of Rust that you will be able to run untrusted
>> code in-process safely?
>>
>> In other words, by whitelisting the set of available APIs and
>> prohibiting unsafe blocks, would you be able to (eventually, once Rust
>> is stable and hardened) run untrusted code in the same address space
>> without it intentionally or unintentionally escaping its sandbox?
>>
>> (Sorry if this a FAQ, I couldn't find any info about it).
>>
>> Thanks,
>> Josh
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

-- 
Scott Lawrence

From dbau.pp at gmail.com  Sat Jan 18 19:30:27 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 19 Jan 2014 14:30:27 +1100
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CAP7VpsUcdtpOGanhEpBWzSsrizTKfvGrnwUgqa2Rd8DxZvisJg@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<CAP7VpsUcdtpOGanhEpBWzSsrizTKfvGrnwUgqa2Rd8DxZvisJg@mail.gmail.com>
Message-ID: <52DB46D3.4080201@gmail.com>

On 19/01/14 14:23, Jack Moffitt wrote:
>> Rust's safety model is not intended to prevent untrusted code from
>> doing evil things.
> We'd like something like this for Servo, but I think the idea was to
> see if we couldn't use NaCl to do this kind of sandboxing. The NaCl
> devs seemed to think this might be interesting as well.
>
> jack.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Isn't the "correct" way to do this to use the OS's security features?

FWIW, https://github.com/mozilla/rust/issues/6811 covers allowing 
spawning tasks as sandboxed tasks, and strcat wrote up something about 
sandboxing on Linux for Servo: 
https://github.com/mozilla/servo/wiki/Linux-sandboxing


Huon

From corey at octayn.net  Sat Jan 18 19:33:32 2014
From: corey at octayn.net (Corey Richardson)
Date: Sat, 18 Jan 2014 22:33:32 -0500
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
Message-ID: <CA++BO6Qjfyf61VGpyX4mm+=guMd_qYhgLD3S96WaTDfE5dtsig@mail.gmail.com>

On Sat, Jan 18, 2014 at 10:30 PM, Scott Lawrence <bytbox at gmail.com> wrote:
> On Sat, 18 Jan 2014, Corey Richardson wrote:
>
>> Rust's safety model is not intended to prevent untrusted code from
>> doing evil things.
>
>
> Doesn't it succesfully do that, though?

It might! But Graydon was very adamant that protection from untrusted
code was/is not one of Rust's goals.

I can't think of anything evil you could do without unsafe code, and
assuming a flawless compiler.

From marcianx at gmail.com  Sat Jan 18 19:47:51 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 18 Jan 2014 22:47:51 -0500
Subject: [rust-dev] Converting ~[T] embedded in struct to &[T]
Message-ID: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>

I understand as per a previous discussion that the owned box ~[T] doesn't
quite have the semantics of a unique *pointer*. Below include my successes
in some borrowing scenarios and analogous failed attempts at borrowing a
reference to a unique pointer to an array within a FooVec struct.  How do I
do this?  Is there a borrow() type function/method provided for owned boxes
somewhere? (I see some borrow() stuff within the libstd source, but doesn't
seem to be relevant.)

--------------------------------------------------
fn main() {
    let a : ~[int] = ~[1,2,3];

    // WORKS (borrow1 style below)
    let b : &[int] = a;
}


fn do_borrow<'a, T>(t : &'a T) -> &'a T {
    t
}


struct Foo(~int);

impl Foo {
    fn borrow1<'a>(&'a self) -> &'a int {
        match (self) {
            // error: mismatched types: expected `&'a int` but found `~int`
            // (expected &-ptr but found ~-ptr)
            &Foo(ref v) => *v
        }
    }

    fn borrow2<'a>(&'a self) -> &'a int {
        match (self) {
            // WORKS
            &Foo(ref v) => &**v
        }
    }

    fn borrow3<'a>(&'a self) -> &'a int {
        match (self) {
            // WORKS
            &Foo(ref v) => do_borrow(*v)
        }
    }
}



struct FooVec(~[int]);

impl FooVec {
    fn borrow1<'a>(&'a self) -> &'a [int] {
        match (self) {
            // error: mismatched types: expected `&'a [int]` but found
            // `~[int]` ([] storage differs: expected &'a  but found ~)
            &FooVec(ref v) => *v
        }
    }

    fn borrow2<'a>(&'a self) -> &'a [int] {
        match (self) {
            // error: type ~[int] cannot be dereferenced
            &FooVec(ref v) => &**v
        }
    }

    fn borrow3<'a>(&'a self) -> &'a [int] {
        match (self) {
            // error: mismatched types: expected `&'a [int]` but found
            // `&<V2>` (expected vector but found &-ptr)
            &FooVec(ref v) => do_borrow(*v)
        }
    }
}
--------------------------------------------------
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140118/88bed08b/attachment-0001.html>

From danielmicay at gmail.com  Sat Jan 18 21:03:16 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 19 Jan 2014 00:03:16 -0500
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
Message-ID: <CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>

On Sat, Jan 18, 2014 at 10:30 PM, Scott Lawrence <bytbox at gmail.com> wrote:
> On Sat, 18 Jan 2014, Corey Richardson wrote:
>
>> Rust's safety model is not intended to prevent untrusted code from
>> doing evil things.
>
>
> Doesn't it succesfully do that, though? Or at least with only a small amount
> of extra logic? For example, suppose I accept, compile, and run arbitrary
> rust code, with only the requirement that there be no "unsafe" blocks
> (ignore for a moment the fact that libstd uses unsafe). Barring compiler
> bugs, I think it's then guaranteed nothing bad can happen.

Even a small subset of Rust hasn't been proven to be secure. It has
plenty of soundness holes left in the unspoken specification. It will
eventually provide a reasonable level of certainty that you aren't
going to hit one of these issues just writing code, but it's not even
there yet.

> It seems to me that (as usual with languages like Rust) it's simply a mildly
> arduous task of maintaining a parallel libstd implementation to be used for
> sandboxing, which either lacks implementations for dangerous functionality,
> or has them replaced with special versions that perform correct permissions
> checking. That, coupled with forbidding unsafe blocks in submitted code,
> should solve the problem.

You'll need to start with an implementation of `rustc` and `LLVM` free
of known exploitable issues. Once the known issues are all fixed, then
you can start worrying about *really* securing them against an
attacker who only needs to find a bug on one line of code in one
poorly maintained LLVM pass. Even compiling untrusted code with LLVM
without running it is a very scary prospect.

> I could be completely wrong. (Is there some black magic I don't know?)

Yes, you're completely wrong. This kind of thinking is dangerous and
how we ended up in the mess where everyone is using ridiculously
complex and totally insecure web browsers to run untrusted code
without building a very simple trusted sandbox around it. Many known
exploits been discovered every year, and countless ones kept private
by entities like nation states and organized crime.

The language isn't yet secure and the implementation is unlikely to
ever be very secure. LLVM is certainly full of many known exploitable
bugs and many more unknown ones. There are many known issues in
`rustc` and the language too.

I don't see much of a point in avoiding a process anyway. On Linux, it
close to no overhead over a thread. Giving up shared memory is an
obvious first step, and the process can be restricted to making
`read`, `write` and `exit` system calls.

The `chromium` sandbox isn't incredibly secure but it's not insane
enough to even render from the same process as where it's compiling
JavaScript. Intel open-source Linux driver is reaching the point where
an untrusted process can be allowed to use it, but it's not there yet
and any other video driver on any of the major operating systems is a
joke.

You're not going to get very far if you're not willing to start from
process isolation, and then build real security on top of it. Anyway,
the world doesn't need another Java applet.

From marcianx at gmail.com  Sat Jan 18 21:17:57 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sun, 19 Jan 2014 00:17:57 -0500
Subject: [rust-dev]  Cloning a statically-sized array
Message-ID: <CAEsTQVNBPn=LbzkmQvSTHdSfkKz5=PamQeEp_EvezZGxHK961A@mail.gmail.com>

Now, I already know that statically-sized arrays of primitives are
implicitly copyable, but consider, for example, a statically-sized array of
a non-copyable but Clone-able type.  I find that for v of type [T, ..2],
v.clone() is not a static array.  Perhaps it's because v is being
implicitly treated as &[T] instead.

Eg.
--------------------------------------------------
fn make_clone<T : Clone>(a : &T) -> T {
    a.clone();
}

fn main() {
    let a : [int, ..2] = [1, 2];
    // error: failed to find an implementation of trait std::clone::Clone
    // for [int, .. 2]
    make_clone(&a);

    let a : [int, ..2] = [1, 2];
    // error: mismatched types: expected `[int, .. 2]` but found `&[int]`
    // ([] storage differs: expected 2 but found &)
    let b : [int, ..2] = a.clone();
}
--------------------------------------------------

So is it a missing feature of rust that Clone is not supported generated
for statically-sized arrays or is there a more fundamental reason that it
doesn't exist?

Ashish
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/71adcce5/attachment.html>

From danielmicay at gmail.com  Sat Jan 18 21:19:46 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 19 Jan 2014 00:19:46 -0500
Subject: [rust-dev] Cloning a statically-sized array
In-Reply-To: <CAEsTQVNBPn=LbzkmQvSTHdSfkKz5=PamQeEp_EvezZGxHK961A@mail.gmail.com>
References: <CAEsTQVNBPn=LbzkmQvSTHdSfkKz5=PamQeEp_EvezZGxHK961A@mail.gmail.com>
Message-ID: <CA+DvKQLPk-da99qyLYn7+oXKCQp+UWeDesqYHAXFcR+kG2K_Uw@mail.gmail.com>

On Sun, Jan 19, 2014 at 12:17 AM, Ashish Myles <marcianx at gmail.com> wrote:
> Now, I already know that statically-sized arrays of primitives are
> implicitly copyable, but consider, for example, a statically-sized array of
> a non-copyable but Clone-able type.  I find that for v of type [T, ..2],
> v.clone() is not a static array.  Perhaps it's because v is being implicitly
> treated as &[T] instead.
>
> Eg.
> --------------------------------------------------
> fn make_clone<T : Clone>(a : &T) -> T {
>     a.clone();
> }
>
> fn main() {
>     let a : [int, ..2] = [1, 2];
>     // error: failed to find an implementation of trait std::clone::Clone
>     // for [int, .. 2]
>     make_clone(&a);
>
>     let a : [int, ..2] = [1, 2];
>     // error: mismatched types: expected `[int, .. 2]` but found `&[int]`
>     // ([] storage differs: expected 2 but found &)
>     let b : [int, ..2] = a.clone();
> }
> --------------------------------------------------
>
> So is it a missing feature of rust that Clone is not supported generated for
> statically-sized arrays or is there a more fundamental reason that it
> doesn't exist?
>
> Ashish

Clone is entirely a library feature, and Rust currently provides no
way to implement methods on fixed-size arrays. The latter is the real
issue, because there are other methods like `Eq` that should be
implemented on them too.

From jfager at gmail.com  Sat Jan 18 22:04:47 2014
From: jfager at gmail.com (Jason Fager)
Date: Sun, 19 Jan 2014 01:04:47 -0500
Subject: [rust-dev] Cloning a statically-sized array
In-Reply-To: <CA+DvKQLPk-da99qyLYn7+oXKCQp+UWeDesqYHAXFcR+kG2K_Uw@mail.gmail.com>
References: <CAEsTQVNBPn=LbzkmQvSTHdSfkKz5=PamQeEp_EvezZGxHK961A@mail.gmail.com>
	<CA+DvKQLPk-da99qyLYn7+oXKCQp+UWeDesqYHAXFcR+kG2K_Uw@mail.gmail.com>
Message-ID: <CAFEbTaU4qptc4JtLesEs4sc5a7uA7rFRXV=TSR4BSBU-bTpUsA@mail.gmail.com>

The workaround for this is a wrapper struct around the fixed-size vec, with
the trait methods you want impl'd on the wrapper.

I've got a macro for this:

https://github.com/jfager/d3cap/blob/master/fixed_vec_macros.rs

So to wrap a [u16,..8], you'd say something like:

fixed_vec!(WrapperType, u16, 8)

and get a back a type called WrapperType implementing IterBytes, Eq, Ord,
and Clone (would be easy to add others).  Not ideal, but useful until this
gets straightened out.





On Sun, Jan 19, 2014 at 12:19 AM, Daniel Micay <danielmicay at gmail.com>wrote:

> On Sun, Jan 19, 2014 at 12:17 AM, Ashish Myles <marcianx at gmail.com> wrote:
> > Now, I already know that statically-sized arrays of primitives are
> > implicitly copyable, but consider, for example, a statically-sized array
> of
> > a non-copyable but Clone-able type.  I find that for v of type [T, ..2],
> > v.clone() is not a static array.  Perhaps it's because v is being
> implicitly
> > treated as &[T] instead.
> >
> > Eg.
> > --------------------------------------------------
> > fn make_clone<T : Clone>(a : &T) -> T {
> >     a.clone();
> > }
> >
> > fn main() {
> >     let a : [int, ..2] = [1, 2];
> >     // error: failed to find an implementation of trait std::clone::Clone
> >     // for [int, .. 2]
> >     make_clone(&a);
> >
> >     let a : [int, ..2] = [1, 2];
> >     // error: mismatched types: expected `[int, .. 2]` but found `&[int]`
> >     // ([] storage differs: expected 2 but found &)
> >     let b : [int, ..2] = a.clone();
> > }
> > --------------------------------------------------
> >
> > So is it a missing feature of rust that Clone is not supported generated
> for
> > statically-sized arrays or is there a more fundamental reason that it
> > doesn't exist?
> >
> > Ashish
>
> Clone is entirely a library feature, and Rust currently provides no
> way to implement methods on fixed-size arrays. The latter is the real
> issue, because there are other methods like `Eq` that should be
> implemented on them too.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/32d437f1/attachment.html>

From alex at crichton.co  Sat Jan 18 22:54:51 2014
From: alex at crichton.co (Alex Crichton)
Date: Sat, 18 Jan 2014 22:54:51 -0800
Subject: [rust-dev] wrapping a C library (ownership/mutability questions)
In-Reply-To: <CAOM7mawUO3E0F2sCjLgCbOPMtqNVd-TP=WT1eKZbqVsJEuLO7Q@mail.gmail.com>
References: <CAOM7mayjddWA7Fy==6FVFW=VTFCVs4Ef3T80hHytFq7vsj-OGQ@mail.gmail.com>
	<CAFnh-mcsFWL_d5GF4dGaKqbjv49Vsw=Y03hGtgCL8FPVGHx16g@mail.gmail.com>
	<CAOM7mawLTwvppt-Q3fs9FPgYemZs6v-dYEOG+y2WSSSC+mUtDg@mail.gmail.com>
	<CAFnh-mdtQXPZvX3M16=3rOzYD4UPB2MkWegAqEP+9h9rDPfWqw@mail.gmail.com>
	<CAOM7maz4RfJT5pns+mav8RAFC318Xx-bDXMAh7xPnWdA+wSEAA@mail.gmail.com>
	<CA+DvKQJi9jqQKBQoFnN5EpuZJYDf5zMy6h8gALPBho7RXr3Zcw@mail.gmail.com>
	<CAOM7mawUO3E0F2sCjLgCbOPMtqNVd-TP=WT1eKZbqVsJEuLO7Q@mail.gmail.com>
Message-ID: <CAFnh-md501aMg7edZst5+JibgjnLbj34177A=SEdS0d9et69gg@mail.gmail.com>

> Any way to prevent this, so that only I am allowed to create FieldDef
> structs but can still return references to them in my public API?

You'll want something like:

pub struct FieldDef {
    priv field: int,
}

That way everyone can name your struct, but no one other than you can
construct it because it has private fields.

From alex at crichton.co  Sat Jan 18 23:01:57 2014
From: alex at crichton.co (Alex Crichton)
Date: Sat, 18 Jan 2014 23:01:57 -0800
Subject: [rust-dev] Converting ~[T] embedded in struct to &[T]
In-Reply-To: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>
References: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>
Message-ID: <CAFnh-mdCTaZdThYEhoSzB_oDFgyL+3EZw_tO0yzRh4DvAKJWtQ@mail.gmail.com>

>     fn borrow1<'a>(&'a self) -> &'a int {
>         match (self) {
>             // error: mismatched types: expected `&'a int` but found `~int`
>             // (expected &-ptr but found ~-ptr)
>             &Foo(ref v) => *v
>         }
>     }

This doesn't work because the local variable v has type &~int, when
you dereference this you get something of type ~int which if you load
is a move so you're not allowed to do that. Additionally, the return
type wants &int when you're giving it ~int

>     fn borrow2<'a>(&'a self) -> &'a int {
>         match (self) {
>             // WORKS
>             &Foo(ref v) => &**v
>         }
>     }

This works because you're going from &~int => ~int => int => &int via
the * => * => & ordering

>     fn borrow3<'a>(&'a self) -> &'a int {
>         match (self) {
>             // WORKS
>             &Foo(ref v) => do_borrow(*v)
>         }
>     }
> }

The reason this works and borrow1 doesn't is a little tricky. As I
said above, the intermediate value has type ~int. The function
do_borrow takes something of type &int, so the compiler will coerce
the value of type ~int. The compiler silently does this so you don't
have to. This is equivalent to writing (as in this is what the
compiler automatically injects)

    do_borrow(&**v)


> impl FooVec {
>     fn borrow1<'a>(&'a self) -> &'a [int] {
>         match (self) {
>             // error: mismatched types: expected `&'a [int]` but found
>             // `~[int]` ([] storage differs: expected &'a  but found ~)
>             &FooVec(ref v) => *v
>         }
>     }

This doesn't work due to the same reasons as the above borrow1

>
>     fn borrow2<'a>(&'a self) -> &'a [int] {
>         match (self) {
>             // error: type ~[int] cannot be dereferenced
>             &FooVec(ref v) => &**v
>         }
>     }

There's a subtle reason that this doesn't work. You'll note in the
above borrow2 I mentioned that you transformed ~int => int => &int. If
the same thing were to happen here, it would look like ~[int] => [int]
=> &[int]. This kind of promotion is not allowed yet (namely
dereferencing something of type ~[T]), but it will hopefully be
enabled soon with something called dynamically sized types (DST).

>     fn borrow3<'a>(&'a self) -> &'a [int] {
>         match (self) {
>             // error: mismatched types: expected `&'a [int]` but found
>             // `&<V2>` (expected vector but found &-ptr)
>             &FooVec(ref v) => do_borrow(*v)
>         }
>     }
> }

This doesn't work because the do_borrow function takes something of
type &int, not ~[int] (which is the type of *v). You'd need to rewrite
the borrow function to take &[int] instead of &int.

Another solution for vectors is to return v.as_slice() which is a
function that will convert all forms of vectors to its slice
representation (&[T])

Hope that helps!

From pwalton at mozilla.com  Sun Jan 19 00:34:18 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Sun, 19 Jan 2014 00:34:18 -0800
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
	<CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>
Message-ID: <1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>

I think this is too strongly worded. While I agree that naively running untrusted Rust code is not a good idea at all, I think that language level security is not unachievable. It is absolutely an utmost priority to get to the point where the language is secure, and Rust treats memory safety issues with the same severity as security bugs. Even though we presently strongly advise against it, we intend to pretend that the point of Rust is to run untrusted code *as far as triaging issues and bugs is concerned*.

Emscripten/OdinMonkey and PNaCl have demonstrated that effectively hardening LLVM is possible for untrusted code. (Of course, there is a performance penalty for this.)

Finally, I disagree that processes are always the right solution here. If processes were as flexible as threads, there would be no need for threads! The trouble with isolation through processes is that isolation at the process level makes shared memory more difficult. For isolation with complex use of shared memory (mutexes and cvars), you really want language-level safety.

Patrick

Daniel Micay <danielmicay at gmail.com> wrote:
>On Sat, Jan 18, 2014 at 10:30 PM, Scott Lawrence <bytbox at gmail.com>
>wrote:
>> On Sat, 18 Jan 2014, Corey Richardson wrote:
>>
>>> Rust's safety model is not intended to prevent untrusted code from
>>> doing evil things.
>>
>>
>> Doesn't it succesfully do that, though? Or at least with only a small
>amount
>> of extra logic? For example, suppose I accept, compile, and run
>arbitrary
>> rust code, with only the requirement that there be no "unsafe" blocks
>> (ignore for a moment the fact that libstd uses unsafe). Barring
>compiler
>> bugs, I think it's then guaranteed nothing bad can happen.
>
>Even a small subset of Rust hasn't been proven to be secure. It has
>plenty of soundness holes left in the unspoken specification. It will
>eventually provide a reasonable level of certainty that you aren't
>going to hit one of these issues just writing code, but it's not even
>there yet.
>
>> It seems to me that (as usual with languages like Rust) it's simply a
>mildly
>> arduous task of maintaining a parallel libstd implementation to be
>used for
>> sandboxing, which either lacks implementations for dangerous
>functionality,
>> or has them replaced with special versions that perform correct
>permissions
>> checking. That, coupled with forbidding unsafe blocks in submitted
>code,
>> should solve the problem.
>
>You'll need to start with an implementation of `rustc` and `LLVM` free
>of known exploitable issues. Once the known issues are all fixed, then
>you can start worrying about *really* securing them against an
>attacker who only needs to find a bug on one line of code in one
>poorly maintained LLVM pass. Even compiling untrusted code with LLVM
>without running it is a very scary prospect.
>
>> I could be completely wrong. (Is there some black magic I don't
>know?)
>
>Yes, you're completely wrong. This kind of thinking is dangerous and
>how we ended up in the mess where everyone is using ridiculously
>complex and totally insecure web browsers to run untrusted code
>without building a very simple trusted sandbox around it. Many known
>exploits been discovered every year, and countless ones kept private
>by entities like nation states and organized crime.
>
>The language isn't yet secure and the implementation is unlikely to
>ever be very secure. LLVM is certainly full of many known exploitable
>bugs and many more unknown ones. There are many known issues in
>`rustc` and the language too.
>
>I don't see much of a point in avoiding a process anyway. On Linux, it
>close to no overhead over a thread. Giving up shared memory is an
>obvious first step, and the process can be restricted to making
>`read`, `write` and `exit` system calls.
>
>The `chromium` sandbox isn't incredibly secure but it's not insane
>enough to even render from the same process as where it's compiling
>JavaScript. Intel open-source Linux driver is reaching the point where
>an untrusted process can be allowed to use it, but it's not there yet
>and any other video driver on any of the major operating systems is a
>joke.
>
>You're not going to get very far if you're not willing to start from
>process isolation, and then build real security on top of it. Anyway,
>the world doesn't need another Java applet.
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/c45be0bd/attachment.html>

From danielmicay at gmail.com  Sun Jan 19 01:17:07 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 19 Jan 2014 04:17:07 -0500
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
	<CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>
	<1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>
Message-ID: <CA+DvKQ+qOdGW4+ov9gRA+ONnUntyhd5tRBFtoHidWd2pjvyD8Q@mail.gmail.com>

On Sun, Jan 19, 2014 at 3:34 AM, Patrick Walton <pwalton at mozilla.com> wrote:
>
> Emscripten/OdinMonkey and PNaCl have demonstrated that effectively hardening
> LLVM is possible for untrusted code. (Of course, there is a performance
> penalty for this.)

PNaCl is primarily a low-level sandboxing technology though. The
frontend languages/libraries, analysis/optimization passes, etc. do
not have to be correct. The scope of what they have to verify has been
drastically cut down to what is essentially a CPU architecture. I
think it's unlikely that the core implementation itself will have many
(if any) vulnerabilities. Once you throw in *all* of the Pepper API,
it's communicating with a huge codebase and loses the strong level of
security.

I don't think you can make a very strong claim that browser JavaScript
engines are secure sandboxes. There's an endless stream of *known*
security vulnerabilities for every major browser and the scope is far
too large. You can't trust a technology like that to be secure because
for every security researcher disclosing vulnerabilities, there are
many more being paid to keep it secret. The fact that vulnerabilities
are disclosed as a steady rate proves that browsers are totally
insecure.

> Finally, I disagree that processes are always the right solution here. If
> processes were as flexible as threads, there would be no need for threads!
> The trouble with isolation through processes is that isolation at the
> process level makes shared memory more difficult. For isolation with complex
> use of shared memory (mutexes and cvars), you really want language-level
> safety.

If there was a tiny subset of Rust it could be compiled down to with a
simpler backend (not LLVM), then I think you could talk seriously
about the language offering a secure sandbox. I don't think it is even
obtainable with a codebase as large as librustc/LLVM. A pretty high
number of issues in the Rust and LLVM trackers could be considered
security issues, and those are just the ones we know about.

From danielmicay at gmail.com  Sun Jan 19 01:21:48 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 19 Jan 2014 04:21:48 -0500
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <CA+DvKQ+qOdGW4+ov9gRA+ONnUntyhd5tRBFtoHidWd2pjvyD8Q@mail.gmail.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
	<CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>
	<1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>
	<CA+DvKQ+qOdGW4+ov9gRA+ONnUntyhd5tRBFtoHidWd2pjvyD8Q@mail.gmail.com>
Message-ID: <CA+DvKQJ_MPVnG8YvNZLfrMEREQx5LL6DSi5TyCzgPnVAtT=q4Q@mail.gmail.com>

On Sun, Jan 19, 2014 at 4:17 AM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> If there was a tiny subset of Rust it could be compiled down to with a
> simpler backend (not LLVM), then I think you could talk seriously
> about the language offering a secure sandbox. I don't think it is even
> obtainable with a codebase as large as librustc/LLVM. A pretty high
> number of issues in the Rust and LLVM trackers could be considered
> security issues, and those are just the ones we know about.

Of course, the entire compiler still has to be free of vulnerabilities
itself. Even if it targets a backend assumed to be correct, the
attacker still has the entire surface area of libsyntax/librustc to
play with.

From flaper87 at gmail.com  Sun Jan 19 04:52:00 2014
From: flaper87 at gmail.com (Flaper87)
Date: Sun, 19 Jan 2014 13:52:00 +0100
Subject: [rust-dev] Code review checklist
Message-ID: <CAMOT3C2x9G0c3t+2n5s+yo9ZT98_-jUspYuKx3CY9_h4zUaU1g@mail.gmail.com>

Hey,

I've been doing reviews for a bit and I just realized we, as community,
don't have a review checklist that all reviewers should go through. I
thought that it could be useful to have a wiki page describing the review
proces for newcomers and people willing to contribute with reviews.

I wrote some points here[0] based on what I've seen. I also added a section
for non-core reviewers (people w/o r+ powers). In this section I just added
1 item in order for these group of folks (which I'm part of) to give their
blessing to the patches they've reviewed. This will welcome more reviewes
at the cost of adding more noise to the PR.

Any comments are welcome. Also, it's a wiki page so feel free to improve
it.  I haven't linked it to the 'Notes for developers' page because I'd
like it to be reviewed first.

[0] https://github.com/mozilla/rust/wiki/Note-code-review

FF

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/f6a0e780/attachment.html>

From abe.egnor at gmail.com  Sun Jan 19 08:09:06 2014
From: abe.egnor at gmail.com (Abraham Egnor)
Date: Sun, 19 Jan 2014 11:09:06 -0500
Subject: [rust-dev] Closure types and iterators: impossible constraints?
Message-ID: <CAFVLdifuxHDoa4BnMv=rxKfr7qT5wLBmpiq7-V47HEx2A7i_1w@mail.gmail.com>

I recently ran into an issue with closure types that seems to have no
solution present in the language.  In a silly example, say you want to
implement an iterator that wraps an int iterator and adds a value to it:

fn add_n<I: Iterator<Int>>(v: I, n: int) -> ???

This is naturally expressed as a map operation:

fn add_n<I: Iterator<Int>>(v: I, n: int) -> ??? {
  v.map(|i| i+n)
}

The problem here is that Iterator::map returns a value that is templated on
the lifetime of the closure passed in.  In other words, the result of
v.map(...) is only valid for the stack frame in which it's called; there's
no way to return it from the function.

It seems like it should be possible to resolve this problem by creating a
struct that owns the closure and can therefore also safely store the result
of the map() call, but I can't find a way to actually express this to the
compiler.

For this specific silly example it's trivial to directly implement the map
logic, but in the general case that means that you can't build new generic
iterator transformers on existing ones, which is a pretty terrible
situation.

Am I missing something or is this a hole in the language?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/dea608e4/attachment-0001.html>

From danielmicay at gmail.com  Sun Jan 19 08:17:54 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 19 Jan 2014 11:17:54 -0500
Subject: [rust-dev] Closure types and iterators: impossible constraints?
In-Reply-To: <CAFVLdifuxHDoa4BnMv=rxKfr7qT5wLBmpiq7-V47HEx2A7i_1w@mail.gmail.com>
References: <CAFVLdifuxHDoa4BnMv=rxKfr7qT5wLBmpiq7-V47HEx2A7i_1w@mail.gmail.com>
Message-ID: <CA+DvKQKF-=MbNO2rSxzeuwrMe4S0kT_Zd0cKSPhc3BMqM+QzYg@mail.gmail.com>

It's a missing feature:

https://github.com/mozilla/rust/issues/8622

From jhaberman at gmail.com  Sun Jan 19 08:39:26 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Sun, 19 Jan 2014 08:39:26 -0800
Subject: [rust-dev] sandboxing Rust?
In-Reply-To: <1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>
References: <CAOM7mazShrnzx-EQOXo9F_ii=oSLbf4GdcVwYy2Csgn8hEWXXQ@mail.gmail.com>
	<CA++BO6RqamBgKuf4v7AhH+454H8n=D0N0zK32E-gW=d_nZQABw@mail.gmail.com>
	<alpine.LNX.2.03.1401182225000.1433@localhost.localdomain>
	<CA+DvKQJcrFWQjQeFBDGFzYFnr98gmQCuJwoyXp+v02F5tcvX_g@mail.gmail.com>
	<1bb06dc4-ac31-4f49-a4b9-bf50396a53a7@email.android.com>
Message-ID: <CAOM7maz1gsVwfQ_Wj5hSjFO-tqB0PpW8qKgsP4q4uR7sKOzKGw@mail.gmail.com>

On Sun, Jan 19, 2014 at 12:34 AM, Patrick Walton <pwalton at mozilla.com> wrote:
> I think this is too strongly worded. While I agree that naively running
> untrusted Rust code is not a good idea at all, I think that language level
> security is not unachievable. It is absolutely an utmost priority to get to
> the point where the language is secure, and Rust treats memory safety issues
> with the same severity as security bugs.

Cool, this is really what I was looking to know. For my own purposes
I'm not thinking so much of running entirely untrusted code, but more
like "pretty trusted" code: like the level of trust you have in a
framework/library that you download and use in your project; where you
didn't write the code yourself but you can read it first if you want
(and others probably have); where there is reputation on the line and
it would be tricky to hide an exploit in plain sight.

For this scenario you would care first and foremost that the code is
highly unlikely to escape inadvertently, and resistance to intentional
attack is just icing on the cake. From the above it sounds like the
goal is to take safety seriously, which would seem to make it entirely
appropriate for this purpose (eventually, once Rust is stable).

Thanks,
Josh

From jhaberman at gmail.com  Sun Jan 19 08:53:36 2014
From: jhaberman at gmail.com (Josh Haberman)
Date: Sun, 19 Jan 2014 08:53:36 -0800
Subject: [rust-dev] embedding Rust?
Message-ID: <CAOM7mazAMPt3_AiGFA4gopbu5FEtsgEmSCDmbmpE4a5LFGGq8w@mail.gmail.com>

Is it a design goal of the Rust compiler that it (eventually) be
offered as a library, so that you can compile/link Rust code and
dynamically load / call into it at runtime?

If so, what do you foresee as far as size/speed profile? I get the
impression that the Rust compiler is relatively large/slow (both to
compile rustc itself and to compile Rust code) -- is this inherent or
do you see it slimming/speeding over time? I guess LLVM is pretty
heavyweight on its own.

When it comes to embedding I always compare against LuaJIT which
compiles in ~20 seconds to a  ~500k library and can compile/run "Hello
World" in 5ms. This is surely an unrealistic goal for Rust which has
to do far more static checking, but I'm curious to know what a
realistic ballpark is for where Rust will likely get.

Thanks,
Josh

From marcianx at gmail.com  Sun Jan 19 09:28:21 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sun, 19 Jan 2014 12:28:21 -0500
Subject: [rust-dev] Converting ~[T] embedded in struct to &[T]
In-Reply-To: <CAFnh-mdCTaZdThYEhoSzB_oDFgyL+3EZw_tO0yzRh4DvAKJWtQ@mail.gmail.com>
References: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>
	<CAFnh-mdCTaZdThYEhoSzB_oDFgyL+3EZw_tO0yzRh4DvAKJWtQ@mail.gmail.com>
Message-ID: <CAEsTQVM96mTSA2yDkog_Jb3VHt3A_cNUS45Gdie6wjReVGcG-g@mail.gmail.com>

Thanks for the detailed explanations!

On Sun, Jan 19, 2014 at 2:01 AM, Alex Crichton <alex at crichton.co> wrote:

> >     fn borrow1<'a>(&'a self) -> &'a int {
> >         match (self) {
> >             // error: mismatched types: expected `&'a int` but found
> `~int`
> >             // (expected &-ptr but found ~-ptr)
> >             &Foo(ref v) => *v
> >         }
> >     }
>
> This doesn't work because the local variable v has type &~int, when
> you dereference this you get something of type ~int which if you load
> is a move so you're not allowed to do that. Additionally, the return
> type wants &int when you're giving it ~int
>

What's the reason ~T not coerced to &T the same way as in the main()
function and borrow3 -- ie. why isn't it automatically converted to &**v as
it is in these cases? The conversion is identical, no?  The inability in
this particular context seems rather arbitrary.

> ... *snip* ...

>     fn borrow3<'a>(&'a self) -> &'a [int] {
>         match (self) {
>             // error: mismatched types: expected `&'a [int]` but found
>             // `&<V2>` (expected vector but found &-ptr)
>             &FooVec(ref v) => do_borrow(*v)
>         }
>     }
> }

This doesn't work because the do_borrow function takes something of
> type &int, not ~[int] (which is the type of *v). You'd need to rewrite
> the borrow function to take &[int] instead of &int.
>
> Another solution for vectors is to return v.as_slice() which is a
> function that will convert all forms of vectors to its slice
> representation (&[T])
>
> Hope that helps!
>

Wow, thanks...this worked (surprisingly to me).
fn do_borrow_ary<'a, T>(t : &'a [T]) -> &'a [T] {
    t
}
...
    fn borrow3<'a>(&'a self) -> &'a [int] {
        match (self) {
            // WORKS
            &FooVec(ref v) => do_borrow_ary(*v)
        }
    }

This leads to multiple points of confusion for me.  It seems that [T] is
special-cased in a way that prevents it from being used as a regular type.
In particular,

1. How did do_borrow_ary manage to coerce ~[T] to &[T] when the other
methods (eg. automatic insertion of &*)  failed? Is this special-cased by
the compiler?  Is there some way to trigger this coercion without requiring
an intermediate function like do_borrow_ary (say, if one wants to return a
static array value type, not a slice)?

2. Why did
    fn do_borrow<'a, T>(t : &'a T) -> &'a T
fail to match types? Isn't [S] a type T and of the same kind?  (Any other
language also exhibit this dichotomy?)  This prevents one from being able
to write a truly generic function -- one must duplicate the code for T and
[T] variations.

Ashish
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/9673f5f2/attachment.html>

From marcianx at gmail.com  Sun Jan 19 09:32:57 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sun, 19 Jan 2014 12:32:57 -0500
Subject: [rust-dev] Cloning a statically-sized array
In-Reply-To: <CAFEbTaU4qptc4JtLesEs4sc5a7uA7rFRXV=TSR4BSBU-bTpUsA@mail.gmail.com>
References: <CAEsTQVNBPn=LbzkmQvSTHdSfkKz5=PamQeEp_EvezZGxHK961A@mail.gmail.com>
	<CA+DvKQLPk-da99qyLYn7+oXKCQp+UWeDesqYHAXFcR+kG2K_Uw@mail.gmail.com>
	<CAFEbTaU4qptc4JtLesEs4sc5a7uA7rFRXV=TSR4BSBU-bTpUsA@mail.gmail.com>
Message-ID: <CAEsTQVN+9vkC7qx19HbMdadkJFBe=2DM-m2bNvfEYRZ5cC-a2g@mail.gmail.com>

Thanks! I was half thinking of implementing this. :)


On Sun, Jan 19, 2014 at 1:04 AM, Jason Fager <jfager at gmail.com> wrote:

> The workaround for this is a wrapper struct around the fixed-size vec,
> with the trait methods you want impl'd on the wrapper.
>
> I've got a macro for this:
>
> https://github.com/jfager/d3cap/blob/master/fixed_vec_macros.rs
>
> So to wrap a [u16,..8], you'd say something like:
>
> fixed_vec!(WrapperType, u16, 8)
>
> and get a back a type called WrapperType implementing IterBytes, Eq, Ord,
> and Clone (would be easy to add others).  Not ideal, but useful until this
> gets straightened out.
>
>
>
>
>
> On Sun, Jan 19, 2014 at 12:19 AM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> On Sun, Jan 19, 2014 at 12:17 AM, Ashish Myles <marcianx at gmail.com>
>> wrote:
>> > Now, I already know that statically-sized arrays of primitives are
>> > implicitly copyable, but consider, for example, a statically-sized
>> array of
>> > a non-copyable but Clone-able type.  I find that for v of type [T, ..2],
>> > v.clone() is not a static array.  Perhaps it's because v is being
>> implicitly
>> > treated as &[T] instead.
>> >
>> > Eg.
>> > --------------------------------------------------
>> > fn make_clone<T : Clone>(a : &T) -> T {
>> >     a.clone();
>> > }
>> >
>> > fn main() {
>> >     let a : [int, ..2] = [1, 2];
>> >     // error: failed to find an implementation of trait
>> std::clone::Clone
>> >     // for [int, .. 2]
>> >     make_clone(&a);
>> >
>> >     let a : [int, ..2] = [1, 2];
>> >     // error: mismatched types: expected `[int, .. 2]` but found
>> `&[int]`
>> >     // ([] storage differs: expected 2 but found &)
>> >     let b : [int, ..2] = a.clone();
>> > }
>> > --------------------------------------------------
>> >
>> > So is it a missing feature of rust that Clone is not supported
>> generated for
>> > statically-sized arrays or is there a more fundamental reason that it
>> > doesn't exist?
>> >
>> > Ashish
>>
>> Clone is entirely a library feature, and Rust currently provides no
>> way to implement methods on fixed-size arrays. The latter is the real
>> issue, because there are other methods like `Eq` that should be
>> implemented on them too.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/ad53fd13/attachment.html>

From dpx.infinity at gmail.com  Sun Jan 19 09:58:45 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 19 Jan 2014 21:58:45 +0400
Subject: [rust-dev] Failure stacktraces
Message-ID: <CA+jWdBgLdQb3H471Bewo3DorMSV+P3+mfqf-4JwL3JS5JvNSsw@mail.gmail.com>

Hi,

Is it possible to view full stacktraces when task fails? Currently
only the last item in the stacktrace is printed to the terminal when I
run a failing program. I'm very surprised that I was not able to find
any information on this. It looks like that the problem is
nonexistent. However, the ability of getting full failure stacktraces
is of colossal importance. Failures mean stack unwinding, so it
shouldn't be a problem, should it?

Thanks,
Vladimir.

From corey at octayn.net  Sun Jan 19 10:05:11 2014
From: corey at octayn.net (Corey Richardson)
Date: Sun, 19 Jan 2014 13:05:11 -0500
Subject: [rust-dev] Failure stacktraces
In-Reply-To: <CA+jWdBgLdQb3H471Bewo3DorMSV+P3+mfqf-4JwL3JS5JvNSsw@mail.gmail.com>
References: <CA+jWdBgLdQb3H471Bewo3DorMSV+P3+mfqf-4JwL3JS5JvNSsw@mail.gmail.com>
Message-ID: <CA++BO6SYjZdG0YWOJxfb4OhypKtnt3Xf8HXMn85EEzrZ-ZFL9g@mail.gmail.com>

You're not actually seeing a stack entry, you're seeing the string
that was given to `fail!()`. You can get a real backtrace with gdb,
break on `rust_fail`. You can also get a super crappy backtrace using
the backtrace function, see prototype
https://gist.github.com/cmr/8192817. We used to use it, but it only
really works for dynamic linking (which we discourage for a variety of
reasons right now), and doesn't work on OS X.

Getting a real backtrace when unwinding would be possible, but we'd
need to start parsing DWARF etc. Not trivial.

On Sun, Jan 19, 2014 at 12:58 PM, Vladimir Matveev
<dpx.infinity at gmail.com> wrote:
> Hi,
>
> Is it possible to view full stacktraces when task fails? Currently
> only the last item in the stacktrace is printed to the terminal when I
> run a failing program. I'm very surprised that I was not able to find
> any information on this. It looks like that the problem is
> nonexistent. However, the ability of getting full failure stacktraces
> is of colossal importance. Failures mean stack unwinding, so it
> shouldn't be a problem, should it?
>
> Thanks,
> Vladimir.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From alex at crichton.co  Sun Jan 19 10:17:55 2014
From: alex at crichton.co (Alex Crichton)
Date: Sun, 19 Jan 2014 10:17:55 -0800
Subject: [rust-dev] Converting ~[T] embedded in struct to &[T]
In-Reply-To: <CAEsTQVM96mTSA2yDkog_Jb3VHt3A_cNUS45Gdie6wjReVGcG-g@mail.gmail.com>
References: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>
	<CAFnh-mdCTaZdThYEhoSzB_oDFgyL+3EZw_tO0yzRh4DvAKJWtQ@mail.gmail.com>
	<CAEsTQVM96mTSA2yDkog_Jb3VHt3A_cNUS45Gdie6wjReVGcG-g@mail.gmail.com>
Message-ID: <CAFnh-mdq+i19xyHT4TR0oA+2YmxsYmaqpdOab5C+RwH+uohJEA@mail.gmail.com>

> What's the reason ~T not coerced to &T the same way as in the main()
> function and borrow3 -- ie. why isn't it automatically converted to &**v as
> it is in these cases? The conversion is identical, no?  The inability in
> this particular context seems rather arbitrary.

Sadly this is correct. Right now type coercion does not happen in all
places, where the return expression is one of them. Coercion is
allowed in let expressions through type ascription and around method
calls.

The conversion is indeed similar, and we've talked about refining this
sort of behavior in the past. This is partly the topic of
https://github.com/mozilla/rust/issues/10504, but specifically
concerning return type coercion I don't think a bug exists.

It can be argued though that coercion on the return type is a little
different than coercion on a function call, though. You've explicitly
listed the return type as &int, but then you return something of type
~int. This reasoning isn't very strong though, and I think I would
personally like to see coercion *everywhere* as opposed to just a few
locations.

> Wow, thanks...this worked (surprisingly to me).
> fn do_borrow_ary<'a, T>(t : &'a [T]) -> &'a [T] {
>     t
> }
> ...
>
>     fn borrow3<'a>(&'a self) -> &'a [int] {
>         match (self) {
>             // WORKS
>             &FooVec(ref v) => do_borrow_ary(*v)
>         }
>     }
>
> This leads to multiple points of confusion for me.  It seems that [T] is
> special-cased in a way that prevents it from being used as a regular type.
> In particular,

That is correct. Sadly you cannot instantiate a type parameter T with
something that looks like [U] (but soon you will be able to)!

This is the source of a number of difficulties throughout the stdlib
and language, which is why we definitely intend to fix it!

> 1. How did do_borrow_ary manage to coerce ~[T] to &[T] when the other
> methods (eg. automatic insertion of &*)  failed? Is this special-cased by
> the compiler?  Is there some way to trigger this coercion without requiring
> an intermediate function like do_borrow_ary (say, if one wants to return a
> static array value type, not a slice)?

This sort of coercion is special-cased in the compiler to allow it to
be possible.

> 2. Why did
>
>     fn do_borrow<'a, T>(t : &'a T) -> &'a T
> fail to match types? Isn't [S] a type T and of the same kind?  (Any other
> language also exhibit this dichotomy?)  This prevents one from being able to
> write a truly generic function -- one must duplicate the code for T and [T]
> variations.

Ah, it appears I answered this above! I would recommend reading
http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/,
the most recent development in DST and it should explain how we intend
to allow this in the future. Soon, hopefully!

From dpx.infinity at gmail.com  Sun Jan 19 10:31:25 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 19 Jan 2014 22:31:25 +0400
Subject: [rust-dev] Failure stacktraces
In-Reply-To: <CA++BO6SYjZdG0YWOJxfb4OhypKtnt3Xf8HXMn85EEzrZ-ZFL9g@mail.gmail.com>
References: <CA+jWdBgLdQb3H471Bewo3DorMSV+P3+mfqf-4JwL3JS5JvNSsw@mail.gmail.com>
	<CA++BO6SYjZdG0YWOJxfb4OhypKtnt3Xf8HXMn85EEzrZ-ZFL9g@mail.gmail.com>
Message-ID: <CA+jWdBgAEPUKghpZBKN1=Sg=viEkFUpB=LwM-VzOo0hsBahX-A@mail.gmail.com>

Thanks for explanation! I guess gdb will do for me.

2014/1/19 Corey Richardson <corey at octayn.net>:
> You're not actually seeing a stack entry, you're seeing the string
> that was given to `fail!()`. You can get a real backtrace with gdb,
> break on `rust_fail`. You can also get a super crappy backtrace using
> the backtrace function, see prototype
> https://gist.github.com/cmr/8192817. We used to use it, but it only
> really works for dynamic linking (which we discourage for a variety of
> reasons right now), and doesn't work on OS X.
>
> Getting a real backtrace when unwinding would be possible, but we'd
> need to start parsing DWARF etc. Not trivial.
>
> On Sun, Jan 19, 2014 at 12:58 PM, Vladimir Matveev
> <dpx.infinity at gmail.com> wrote:
>> Hi,
>>
>> Is it possible to view full stacktraces when task fails? Currently
>> only the last item in the stacktrace is printed to the terminal when I
>> run a failing program. I'm very surprised that I was not able to find
>> any information on this. It looks like that the problem is
>> nonexistent. However, the ability of getting full failure stacktraces
>> is of colossal importance. Failures mean stack unwinding, so it
>> shouldn't be a problem, should it?
>>
>> Thanks,
>> Vladimir.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

From marcianx at gmail.com  Sun Jan 19 10:34:00 2014
From: marcianx at gmail.com (Ashish Myles)
Date: Sun, 19 Jan 2014 13:34:00 -0500
Subject: [rust-dev] Converting ~[T] embedded in struct to &[T]
In-Reply-To: <CAFnh-mdq+i19xyHT4TR0oA+2YmxsYmaqpdOab5C+RwH+uohJEA@mail.gmail.com>
References: <CAEsTQVMMX+nSpOFnk8z20ZsS_AwkEYkrEm3oWErvcFSi1GYPKQ@mail.gmail.com>
	<CAFnh-mdCTaZdThYEhoSzB_oDFgyL+3EZw_tO0yzRh4DvAKJWtQ@mail.gmail.com>
	<CAEsTQVM96mTSA2yDkog_Jb3VHt3A_cNUS45Gdie6wjReVGcG-g@mail.gmail.com>
	<CAFnh-mdq+i19xyHT4TR0oA+2YmxsYmaqpdOab5C+RwH+uohJEA@mail.gmail.com>
Message-ID: <CAEsTQVPMK_NNextTK34sC4snKwqzEek0FhfO9Hmy37hCXSzGiw@mail.gmail.com>

Thanks! I appreciate the detailed answers and look forward to future
changes. :)
And I had already run into and started reading Niko's article you linked
for DSTs.
I love the thorough analyses you guys go through for each feature.

Ashish



On Sun, Jan 19, 2014 at 1:17 PM, Alex Crichton <alex at crichton.co> wrote:

> > What's the reason ~T not coerced to &T the same way as in the main()
> > function and borrow3 -- ie. why isn't it automatically converted to &**v
> as
> > it is in these cases? The conversion is identical, no?  The inability in
> > this particular context seems rather arbitrary.
>
> Sadly this is correct. Right now type coercion does not happen in all
> places, where the return expression is one of them. Coercion is
> allowed in let expressions through type ascription and around method
> calls.
>
> The conversion is indeed similar, and we've talked about refining this
> sort of behavior in the past. This is partly the topic of
> https://github.com/mozilla/rust/issues/10504, but specifically
> concerning return type coercion I don't think a bug exists.
>
> It can be argued though that coercion on the return type is a little
> different than coercion on a function call, though. You've explicitly
> listed the return type as &int, but then you return something of type
> ~int. This reasoning isn't very strong though, and I think I would
> personally like to see coercion *everywhere* as opposed to just a few
> locations.
>
> > Wow, thanks...this worked (surprisingly to me).
> > fn do_borrow_ary<'a, T>(t : &'a [T]) -> &'a [T] {
> >     t
> > }
> > ...
> >
> >     fn borrow3<'a>(&'a self) -> &'a [int] {
> >         match (self) {
> >             // WORKS
> >             &FooVec(ref v) => do_borrow_ary(*v)
> >         }
> >     }
> >
> > This leads to multiple points of confusion for me.  It seems that [T] is
> > special-cased in a way that prevents it from being used as a regular
> type.
> > In particular,
>
> That is correct. Sadly you cannot instantiate a type parameter T with
> something that looks like [U] (but soon you will be able to)!
>
> This is the source of a number of difficulties throughout the stdlib
> and language, which is why we definitely intend to fix it!
>
> > 1. How did do_borrow_ary manage to coerce ~[T] to &[T] when the other
> > methods (eg. automatic insertion of &*)  failed? Is this special-cased by
> > the compiler?  Is there some way to trigger this coercion without
> requiring
> > an intermediate function like do_borrow_ary (say, if one wants to return
> a
> > static array value type, not a slice)?
>
> This sort of coercion is special-cased in the compiler to allow it to
> be possible.
>
> > 2. Why did
> >
> >     fn do_borrow<'a, T>(t : &'a T) -> &'a T
> > fail to match types? Isn't [S] a type T and of the same kind?  (Any other
> > language also exhibit this dichotomy?)  This prevents one from being
> able to
> > write a truly generic function -- one must duplicate the code for T and
> [T]
> > variations.
>
> Ah, it appears I answered this above! I would recommend reading
> http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/,
> the most recent development in DST and it should explain how we intend
> to allow this in the future. Soon, hopefully!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/51bdb3ad/attachment.html>

From pwalton at mozilla.com  Sun Jan 19 10:55:28 2014
From: pwalton at mozilla.com (Patrick Walton)
Date: Sun, 19 Jan 2014 10:55:28 -0800
Subject: [rust-dev] embedding Rust?
In-Reply-To: <CAOM7mazAMPt3_AiGFA4gopbu5FEtsgEmSCDmbmpE4a5LFGGq8w@mail.gmail.com>
References: <CAOM7mazAMPt3_AiGFA4gopbu5FEtsgEmSCDmbmpE4a5LFGGq8w@mail.gmail.com>
Message-ID: <d0609945-a120-46d5-b26f-31ed04270dde@email.android.com>

Yes, all of the guts of the compiler are in a dynamic library, librustc, for reasons similar to those.

We have some initial support for loading Rust code at runtime (so that the compiler can load syntax extensions), though it's fairly immature at the moment.

Patrick

Josh Haberman <jhaberman at gmail.com> wrote:
>Is it a design goal of the Rust compiler that it (eventually) be
>offered as a library, so that you can compile/link Rust code and
>dynamically load / call into it at runtime?
>
>If so, what do you foresee as far as size/speed profile? I get the
>impression that the Rust compiler is relatively large/slow (both to
>compile rustc itself and to compile Rust code) -- is this inherent or
>do you see it slimming/speeding over time? I guess LLVM is pretty
>heavyweight on its own.
>
>When it comes to embedding I always compare against LuaJIT which
>compiles in ~20 seconds to a  ~500k library and can compile/run "Hello
>World" in 5ms. This is surely an unrealistic goal for Rust which has
>to do far more static checking, but I'm curious to know what a
>realistic ballpark is for where Rust will likely get.
>
>Thanks,
>Josh
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/eef6e814/attachment-0001.html>

From abe.egnor at gmail.com  Sun Jan 19 12:24:16 2014
From: abe.egnor at gmail.com (Abraham Egnor)
Date: Sun, 19 Jan 2014 15:24:16 -0500
Subject: [rust-dev] Closure types and iterators: impossible constraints?
In-Reply-To: <CA+DvKQKF-=MbNO2rSxzeuwrMe4S0kT_Zd0cKSPhc3BMqM+QzYg@mail.gmail.com>
References: <CAFVLdifuxHDoa4BnMv=rxKfr7qT5wLBmpiq7-V47HEx2A7i_1w@mail.gmail.com>
	<CA+DvKQKF-=MbNO2rSxzeuwrMe4S0kT_Zd0cKSPhc3BMqM+QzYg@mail.gmail.com>
Message-ID: <CAFVLdid90Wxa3MYL-0eGhjgkeR3v78jvp9c9VOP9bpOa9O2aug@mail.gmail.com>

Aha, yes, that would plug the hole.  I'm a little worried that there's no
assignee and no milestone listed, and the only mention of a timeline on
that page is a comment of "Not until Rust 2.0".  Is that comment accurate?
 That's a fairly major feature to leave lacking, especially given the
effect of preventing composition of HOFs.


On Sun, Jan 19, 2014 at 11:17 AM, Daniel Micay <danielmicay at gmail.com>wrote:

> It's a missing feature:
>
> https://github.com/mozilla/rust/issues/8622
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/dab3cf6b/attachment.html>

From armin.ronacher at active-4.com  Sun Jan 19 12:58:53 2014
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Sun, 19 Jan 2014 20:58:53 +0000
Subject: [rust-dev] redis-rs Pipelining and Connections
Message-ID: <52DC3C8D.3070301@active-4.com>

Hi,

I'm currently wrapping all of redis in a fairly high-level library similar to 
the Python binding.  It's currently living here:
   https://github.com/mitsuhiko/redis-rs

In general I did not encounter many problems with that but there are some open 
questions in regards to how pipelining and connection pooling should work.

In general, this is roughly how the library works:

   extern mod redis;

   fn main() {
     let client = redis::Client::open("redis://127.0.0.1/").unwrap();
     let mut con = client.get_connection().unwrap();
     println!("Got value: {}", con.get("my_key").unwrap_or("<no value>"));
   }

Pipelining:

I currently have no idea how to implement this.  The API I had in mind was this:

   let mut con = client.get_connection().unwrap();
   let mut counter, data;
   con.pipeline()
     .incr("counter").tap(|value| { counter = value; })
     .get("data_key").tap(|value| { data = value; })
     .execute();

The general idea is pretty simple: whereas a regular redis connection 
immediately returns the results the pipeline buffers them up and will execute 
the tap'ed callbacks to return the data.  Unfortunately I have no idea how this 
can be implemented currently.  There are two issues with that:  first of all I 
don't fancy implementing all methods twice (once for the connection and once for 
the pipeline), secondly the .tap() method needs to change signature depending on 
the return value of the most recent operation.

Lastly because the pipeline borrows the connection as mutable the code currently 
would need to be placed in a separate scope, otherwise the con object becomes 
unusable after the pipeline call.

Connections:

I don't know what the best way to deal with connections is.  Right now I have a 
client object which tries to connect to redis and does the address resolution. 
The actual connection however is provided by a get_connection() function on it 
which will connect and return a connection object.  This way two tasks can have 
a connection each.  I was thinking of extending this with a connection pool but 
I'm not sure how to do this properly since I don't want that the client needs to 
be mutable to get a connection.  That would make it much harder to use with 
multiple tasks.


If anyone has some ideas of how to advance I would love to get some feedback. 
I'm running a bit into a wall here.


Regards,
Armin

From mneumann at ntecs.de  Sun Jan 19 14:58:52 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Sun, 19 Jan 2014 23:58:52 +0100
Subject: [rust-dev] redis-rs Pipelining and Connections
In-Reply-To: <52DC3C8D.3070301@active-4.com>
References: <52DC3C8D.3070301@active-4.com>
Message-ID: <52DC58AC.10408@ntecs.de>


Am 19.01.2014 21:58, schrieb Armin Ronacher:
> Hi,
>
> I'm currently wrapping all of redis in a fairly high-level library 
> similar to the Python binding.  It's currently living here:
>   https://github.com/mitsuhiko/redis-rs

Cool, another redis library :). This is mine: [1]

>
> In general I did not encounter many problems with that but there are 
> some open questions in regards to how pipelining and connection 
> pooling should work.
>
> In general, this is roughly how the library works:
>
>   extern mod redis;
>
>   fn main() {
>     let client = redis::Client::open("redis://127.0.0.1/").unwrap();
>     let mut con = client.get_connection().unwrap();
>     println!("Got value: {}", con.get("my_key").unwrap_or("<no value>"));
>   }
>
> Pipelining:
>
> I currently have no idea how to implement this.  The API I had in mind 
> was this:
>
>   let mut con = client.get_connection().unwrap();
>   let mut counter, data;
>   con.pipeline()
>     .incr("counter").tap(|value| { counter = value; })
>     .get("data_key").tap(|value| { data = value; })
>     .execute();
>
> The general idea is pretty simple: whereas a regular redis connection 
> immediately returns the results the pipeline buffers them up and will 
> execute the tap'ed callbacks to return the data. Unfortunately I have 
> no idea how this can be implemented currently.  There are two issues 
> with that:  first of all I don't fancy implementing all methods twice 
> (once for the connection and once for the pipeline), secondly the 
> .tap() method needs to change signature depending on the return value 
> of the most recent operation.

I think, if you add something like "Postpone(&mut Connection)" to the 
Value type it could work.
Method tap would only be defined for type Value and will fails it it's 
value is not Postpone.
Something like that:

enum Value {
   Nil,
   Int(int64),
   Data(~[u8]),
   Error(~str),
   Status(~str),
   Postpone(&mut Connection)
}

impl Value {
   fn tap(&self, fn callback) -> Connection {
      match *self {
          Postpone(conn) => { conn.add_callback(callback); conn }
          _ => fail!()
     }
   }
}

Of course incr() etc. will only return Postpone if it is in pipeline 
mode, otherwise it will execute
normally and return the redis value.

> Lastly because the pipeline borrows the connection as mutable the code 
> currently would need to be placed in a separate scope, otherwise the 
> con object becomes unusable after the pipeline call.
>
> Connections:
>
> I don't know what the best way to deal with connections is.  Right now 
> I have a client object which tries to connect to redis and does the 
> address resolution. The actual connection however is provided by a 
> get_connection() function on it which will connect and return a 
> connection object.  This way two tasks can have a connection each.  I 
> was thinking of extending this with a connection pool but I'm not sure 
> how to do this properly since I don't want that the client needs to be 
> mutable to get a connection.  That would make it much harder to use 
> with multiple tasks.

Hm, in my rust-redis library, I just connect in redis::Client::new(). 
That's pretty simple. What's the problem if each task just calls 
Client::new() instead of get_connection()? If address resolution is your 
problem, I'd solve it differently.

Regards,

   Michael

[1]: https://github.com/mneumann/rust-redis


From armin.ronacher at active-4.com  Sun Jan 19 15:29:04 2014
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Sun, 19 Jan 2014 23:29:04 +0000
Subject: [rust-dev] redis-rs Pipelining and Connections
In-Reply-To: <52DC58AC.10408@ntecs.de>
References: <52DC3C8D.3070301@active-4.com> <52DC58AC.10408@ntecs.de>
Message-ID: <52DC5FC0.3020400@active-4.com>

Hi,

On 19/01/2014 22:58, Michael Neumann wrote:
> I think, if you add something like "Postpone(&mut Connection)" to the Value type
> it could work.
> Method tap would only be defined for type Value and will fails it it's value is
> not Postpone.
> Something like that:
That works if you always return value objects which I'm not doing.  I return 
actual rust types unwrapped because it gets too annoying otherwise.

> impl Value {
>    fn tap(&self, fn callback) -> Connection {
>       match *self {
>           Postpone(conn) => { conn.add_callback(callback); conn }
>           _ => fail!()
>      }
>    }
> }
Same thing here.  The signature of the callback is different for each function 
once you get rid of the concept of a value type.

> Hm, in my rust-redis library, I just connect in redis::Client::new(). That's
> pretty simple. What's the problem if each task just calls Client::new() instead
> of get_connection()? If address resolution is your problem, I'd solve it
> differently.
The problem with that is that each task will actually connect to the server.  If 
you have 10000 tasks that's 10000 connections to the server.  My plan is to have 
a connection pool on the client because of this and the tasks can fetch a 
connection from there if one is available or will block until one becomes 
available otherwise.

If there is no separate concept of a client then it has to be a global 
connection pool which seems like a really bad idea.


Regards,
Armin


From adamson.benjamin at gmail.com  Sun Jan 19 17:28:40 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Sun, 19 Jan 2014 17:28:40 -0800
Subject: [rust-dev] Lifetime help
Message-ID: <CAHzuJ338CzJ_BYzyUsciPVH+gpMR5gw=ryX1zt=aLS5rO0JNbA@mail.gmail.com>

Hi all!

I having a little trouble resolving this issue on my own, and I think it's
an issue of syntax, not so much comprehending life times.

What I'm doing is, using the RSFML library to try and write a pong clone in
rust. So far it's been going awesome! I'm running into a small problem with
lifetimes though. To give some context, SFML separates textures from
sprites, and sprites can be created with a borrowed pointer to a texture. I
first load all the textures into a HashMap, and pass that hashmap to a
function which (is supposed to) will return a HashMap of Sprites. These
sprites I would like to initialize inside the function with references to
the textures in the input HashMap of textures.

Based on my understanding of borrowed pointers, this should be able to
work. In fact, I wrote a simpler version of my function just to make sure I
understand what I am not understanding. I wrote a version of the function
which takes the same HashMap of textures, and returns a single sprite (not
a hashmap). The single sprite is created with a reference to the first
texture in the hashmap. I was able to figure out the syntax to express
this. However I can't seem to figure out the syntax for the more
complicated case, returning the hashmap of Sprites.

I created a gist for easy viewing of the code I am having trouble with, and
I think I've made it very obvious what's happening in the gist link,
hopefully somebody can help me sort this out :D
https://gist.github.com/ShortStomp/8513368

also the link to the full file, if it helps.
https://github.com/ShortStomp/pong-rust/blob/master/main.rs

Thanks in advance!!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140119/0181d304/attachment.html>

From clements at brinckerhoff.org  Sun Jan 19 23:21:32 2014
From: clements at brinckerhoff.org (John Clements)
Date: Sun, 19 Jan 2014 23:21:32 -0800
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <CA+jWdBgz53T+KnSDPxmoQFbBHzz5eZ7EoRekK5rN3Hg-f9R6Kg@mail.gmail.com>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
	<CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>
	<CA+jWdBgz53T+KnSDPxmoQFbBHzz5eZ7EoRekK5rN3Hg-f9R6Kg@mail.gmail.com>
Message-ID: <78A32AC8-D936-4A11-8CEB-FD1B6E2E5EE8@brinckerhoff.org>


On Jan 11, 2014, at 12:15 AM, Vladimir Matveev wrote:

> Oh, thanks. It does work now. Are macro scoping rules documented
> somewhere except the compiler source code?

As the author of the macro_escape hack: no, I don't believe it's documented. 

John Clements


From dpx.infinity at gmail.com  Sun Jan 19 23:41:47 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Mon, 20 Jan 2014 11:41:47 +0400
Subject: [rust-dev] Lifetime help
In-Reply-To: <CAHzuJ338CzJ_BYzyUsciPVH+gpMR5gw=ryX1zt=aLS5rO0JNbA@mail.gmail.com>
References: <CAHzuJ338CzJ_BYzyUsciPVH+gpMR5gw=ryX1zt=aLS5rO0JNbA@mail.gmail.com>
Message-ID: <CA+jWdBjBcLr2pbAWtUHjA6zN7ZwjTSRZAS_k3DzvDv10=w8yKQ@mail.gmail.com>

Hi,

In fact, you're almost there. You only need to add lifetime
annotations on `Sprite` in the intermediate HashMap variable and in
return type. See here: https://gist.github.com/dpx-infinity/8516387

I tried to emulate rust-sfml types. This gist compiles, and the test
is successful. BTW, you don't have to write `return` unless you want
to exit early, for example, from inside a loop. Just leave out
semicolon at the last line.

Simple hint to detect mistakes in lifetime annotations: if you only
have lifetime annotations on parameters or return values but not on
both parameters and return values, then it is likely that something is
wrong.

2014/1/20 benjamin adamson <adamson.benjamin at gmail.com>:
> Hi all!
>
> I having a little trouble resolving this issue on my own, and I think it's
> an issue of syntax, not so much comprehending life times.
>
> What I'm doing is, using the RSFML library to try and write a pong clone in
> rust. So far it's been going awesome! I'm running into a small problem with
> lifetimes though. To give some context, SFML separates textures from
> sprites, and sprites can be created with a borrowed pointer to a texture. I
> first load all the textures into a HashMap, and pass that hashmap to a
> function which (is supposed to) will return a HashMap of Sprites. These
> sprites I would like to initialize inside the function with references to
> the textures in the input HashMap of textures.
>
> Based on my understanding of borrowed pointers, this should be able to work.
> In fact, I wrote a simpler version of my function just to make sure I
> understand what I am not understanding. I wrote a version of the function
> which takes the same HashMap of textures, and returns a single sprite (not a
> hashmap). The single sprite is created with a reference to the first texture
> in the hashmap. I was able to figure out the syntax to express this. However
> I can't seem to figure out the syntax for the more complicated case,
> returning the hashmap of Sprites.
>
> I created a gist for easy viewing of the code I am having trouble with, and
> I think I've made it very obvious what's happening in the gist link,
> hopefully somebody can help me sort this out :D
> https://gist.github.com/ShortStomp/8513368
>
> also the link to the full file, if it helps.
> https://github.com/ShortStomp/pong-rust/blob/master/main.rs
>
> Thanks in advance!!
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From dpx.infinity at gmail.com  Sun Jan 19 23:50:15 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Mon, 20 Jan 2014 11:50:15 +0400
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <78A32AC8-D936-4A11-8CEB-FD1B6E2E5EE8@brinckerhoff.org>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
	<CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>
	<CA+jWdBgz53T+KnSDPxmoQFbBHzz5eZ7EoRekK5rN3Hg-f9R6Kg@mail.gmail.com>
	<78A32AC8-D936-4A11-8CEB-FD1B6E2E5EE8@brinckerhoff.org>
Message-ID: <CA+jWdBgXq_cFrHNLy_6=ZNDjBHonGJJnzxOAfzfdrvQev57_uA@mail.gmail.com>

I thought so :)
By the way, isn't one of the latest pull requests (the one about
loadable syntax extensions) provide a solution to this problem? It has
this particular snippet in its explanation:

#[macro_export]
macro_rules! exported_macro (() => (2))

Which suggests that macros can now be exported.


2014/1/20 John Clements <clements at brinckerhoff.org>:
>
> On Jan 11, 2014, at 12:15 AM, Vladimir Matveev wrote:
>
>> Oh, thanks. It does work now. Are macro scoping rules documented
>> somewhere except the compiler source code?
>
> As the author of the macro_escape hack: no, I don't believe it's documented.
>
> John Clements
>

From dpx.infinity at gmail.com  Mon Jan 20 07:12:16 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Mon, 20 Jan 2014 19:12:16 +0400
Subject: [rust-dev] Lifetime help
In-Reply-To: <CAJY4u8HWFDM3z6ozFGMat1dN7sQ7MPUcUqSDAX0fdH82Y1QUeQ@mail.gmail.com>
References: <CAHzuJ338CzJ_BYzyUsciPVH+gpMR5gw=ryX1zt=aLS5rO0JNbA@mail.gmail.com>
	<CA+jWdBjBcLr2pbAWtUHjA6zN7ZwjTSRZAS_k3DzvDv10=w8yKQ@mail.gmail.com>
	<CAJY4u8HWFDM3z6ozFGMat1dN7sQ7MPUcUqSDAX0fdH82Y1QUeQ@mail.gmail.com>
Message-ID: <CA+jWdBiooHwizCORG_2OSMMrOH8o1APxiDqwO41cb+4BRYmCYA@mail.gmail.com>

In general it is likely that type annotations will be needed. But in
this case you're quite correct. I have updated the gist, it now has
significantly less noise.

2014/1/20 Evan G <eg1290 at gmail.com>:
> Do you need to type annotate the intermediate variable? Shouldn't "let
> sprites = assets.iter()" be sufficient? Or is it because of the lifetimes?
>
> On Jan 20, 2014 1:41 AM, "Vladimir Matveev" <dpx.infinity at gmail.com> wrote:
>>
>> Hi,
>>
>> In fact, you're almost there. You only need to add lifetime
>> annotations on `Sprite` in the intermediate HashMap variable and in
>> return type. See here: https://gist.github.com/dpx-infinity/8516387
>>
>> I tried to emulate rust-sfml types. This gist compiles, and the test
>> is successful. BTW, you don't have to write `return` unless you want
>> to exit early, for example, from inside a loop. Just leave out
>> semicolon at the last line.
>>
>> Simple hint to detect mistakes in lifetime annotations: if you only
>> have lifetime annotations on parameters or return values but not on
>> both parameters and return values, then it is likely that something is
>> wrong.
>>
>> 2014/1/20 benjamin adamson <adamson.benjamin at gmail.com>:
>> > Hi all!
>> >
>> > I having a little trouble resolving this issue on my own, and I think
>> > it's
>> > an issue of syntax, not so much comprehending life times.
>> >
>> > What I'm doing is, using the RSFML library to try and write a pong clone
>> > in
>> > rust. So far it's been going awesome! I'm running into a small problem
>> > with
>> > lifetimes though. To give some context, SFML separates textures from
>> > sprites, and sprites can be created with a borrowed pointer to a
>> > texture. I
>> > first load all the textures into a HashMap, and pass that hashmap to a
>> > function which (is supposed to) will return a HashMap of Sprites. These
>> > sprites I would like to initialize inside the function with references
>> > to
>> > the textures in the input HashMap of textures.
>> >
>> > Based on my understanding of borrowed pointers, this should be able to
>> > work.
>> > In fact, I wrote a simpler version of my function just to make sure I
>> > understand what I am not understanding. I wrote a version of the
>> > function
>> > which takes the same HashMap of textures, and returns a single sprite
>> > (not a
>> > hashmap). The single sprite is created with a reference to the first
>> > texture
>> > in the hashmap. I was able to figure out the syntax to express this.
>> > However
>> > I can't seem to figure out the syntax for the more complicated case,
>> > returning the hashmap of Sprites.
>> >
>> > I created a gist for easy viewing of the code I am having trouble with,
>> > and
>> > I think I've made it very obvious what's happening in the gist link,
>> > hopefully somebody can help me sort this out :D
>> > https://gist.github.com/ShortStomp/8513368
>> >
>> > also the link to the full file, if it helps.
>> > https://github.com/ShortStomp/pong-rust/blob/master/main.rs
>> >
>> > Thanks in advance!!
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

From jens at nockert.se  Mon Jan 20 08:58:16 2014
From: jens at nockert.se (Jens Nockert)
Date: Mon, 20 Jan 2014 17:58:16 +0100
Subject: [rust-dev] Fast inverse square root in Rust
In-Reply-To: <CAHYVw0xUKO93Hp-=th0pDmiMYSH59Y4YoLgC3sHS=ct8Acfi_w@mail.gmail.com>
References: <CAChbWaO-X8Ykuq7uKxO9H+U6kjra+HcK9LzEF+6vtC5KxX+oHw@mail.gmail.com>
	<CAHYVw0wn42iDWjFEz8ShNbrg4R_mhzbYFY2iewusf-wj5-XHrw@mail.gmail.com>
	<CAHYVw0xUKO93Hp-=th0pDmiMYSH59Y4YoLgC3sHS=ct8Acfi_w@mail.gmail.com>
Message-ID: <1416CE06-CAC4-4733-BD95-77E95F4CDAA0@nockert.se>

Sorry for being late to the party,

On 2014/01/12, at 20:06, Carter Schonwald <carter.schonwald at gmail.com> wrote:

> That actually raises a good point: for finite precision real number types like f64 /f32 etc, what are the desired precision/numerical stability guarantees of routines included I the std lib?  For operations on IEEE floating point types, how do these guarantees carry  these composite operations in the presence of rounding modes?  

The normal parts of the standard library should strive to be correctly rounded imho, for something like a hypothetical FastMath module, anything goes.

That is the IEEE 754-2008 recommendation, on the other hand, certain numerical languages like OpenCL have other (lower) guarantees that could be followed as well, but that would mean that Rust would give different results on different hardware, which might not be acceptable for certain applications (multiplayer games?)

> These are nuanced questions.  And maybe there should different types / traits depending on the assumptions needed. (A fun question is: "when is multiplication commutative and associative?", because it's not for matrices, float

I think we?ll have to work with the assumption that the * is never commutative or associative. Unfortunately.

From sfackler at gmail.com  Mon Jan 20 10:45:21 2014
From: sfackler at gmail.com (Steven Fackler)
Date: Mon, 20 Jan 2014 10:45:21 -0800
Subject: [rust-dev] Exporting macros: #[macro_escape] usage
In-Reply-To: <CA+jWdBgXq_cFrHNLy_6=ZNDjBHonGJJnzxOAfzfdrvQev57_uA@mail.gmail.com>
References: <CA+jWdBhzaj5Cta-70Yzf+kRYhd023f46LJ=5Xe0_=te5Vc+THA@mail.gmail.com>
	<CAMF4WejEz5vvHR2=w47NNg0hX3fMoXFJyQBLOWF+RaGS5HpxMw@mail.gmail.com>
	<CA+jWdBgz53T+KnSDPxmoQFbBHzz5eZ7EoRekK5rN3Hg-f9R6Kg@mail.gmail.com>
	<78A32AC8-D936-4A11-8CEB-FD1B6E2E5EE8@brinckerhoff.org>
	<CA+jWdBgXq_cFrHNLy_6=ZNDjBHonGJJnzxOAfzfdrvQev57_uA@mail.gmail.com>
Message-ID: <CANb7cF4efxo+6QuX81+uHWRRN8JCNUtELTekSSJOK_fq0qKucQ@mail.gmail.com>

#[macro_export] exports macros from one crate to another (across an "extern
mod" boundary). It doesn't have any effect inside of the crate in which it
is defined.

Steven Fackler


On Sun, Jan 19, 2014 at 11:50 PM, Vladimir Matveev
<dpx.infinity at gmail.com>wrote:

> I thought so :)
> By the way, isn't one of the latest pull requests (the one about
> loadable syntax extensions) provide a solution to this problem? It has
> this particular snippet in its explanation:
>
> #[macro_export]
> macro_rules! exported_macro (() => (2))
>
> Which suggests that macros can now be exported.
>
>
> 2014/1/20 John Clements <clements at brinckerhoff.org>:
> >
> > On Jan 11, 2014, at 12:15 AM, Vladimir Matveev wrote:
> >
> >> Oh, thanks. It does work now. Are macro scoping rules documented
> >> somewhere except the compiler source code?
> >
> > As the author of the macro_escape hack: no, I don't believe it's
> documented.
> >
> > John Clements
> >
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140120/b072e414/attachment.html>

From hansjorg at gmail.com  Mon Jan 20 16:01:36 2014
From: hansjorg at gmail.com (=?ISO-8859-1?Q?Hans_J=F8rgen_Hoel?=)
Date: Tue, 21 Jan 2014 01:01:36 +0100
Subject: [rust-dev] Rust-ci updates (project categories and documentation)
Message-ID: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>

Hi,

Rust-ci (http://www.rust-ci.org/) has been updated with some new features

* documentation can be uploaded during Travis CI builds (see project
page -> owner actions -> get config for docs upload)
* categorization of projects
* projects can now be edited and deleted by owners (aka Web 2.0 compliance)

For a view of projects by category see:

http://www.rust-ci.org/projects/

I've added likely categories to projects based on name and
description, but I've probably missed a few so please take a look at
your own project (owner actions -> edit project to change).

Categories are fixed for now. Give me a ping if you want to have a
category added or changed.

Projects on the frontpage with a padlock in the status column are
missing Travis CI authentication due to an earlier bug. To fix this,
go to the project page and select Authenticate.

If you encounter any other issues, please report it here:

https://github.com/hansjorg/rust-ci

Next up:

* benchmarks upload (and graphing)

cheers,

Hans J?rgen

From kevin at sb.org  Mon Jan 20 16:42:07 2014
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 20 Jan 2014 16:42:07 -0800
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
Message-ID: <8BE81A50-716C-4AA7-AB4C-4C5B5ED2DA93@sb.org>

That's pretty cool. http://www.rust-ci.org/kballard/rust-lua/doc/lua now contains documentation for rust-lua!

Although there are two issues with the documentation as it exists now. Both are caused by the fact that the docs link actually embeds the real documentation in an <iframe>.

The first issue is that the title of the page is always "Rust CI".

The second is that clicking a link in the documentation will only navigate that <iframe>, and therefore the URL bar doesn't get updated and the browser back button (and history list) is broken.

-Kevin

On Jan 20, 2014, at 4:01 PM, Hans J?rgen Hoel <hansjorg at gmail.com> wrote:

> Hi,
> 
> Rust-ci (http://www.rust-ci.org/) has been updated with some new features
> 
> * documentation can be uploaded during Travis CI builds (see project
> page -> owner actions -> get config for docs upload)
> * categorization of projects
> * projects can now be edited and deleted by owners (aka Web 2.0 compliance)
> 
> For a view of projects by category see:
> 
> http://www.rust-ci.org/projects/
> 
> I've added likely categories to projects based on name and
> description, but I've probably missed a few so please take a look at
> your own project (owner actions -> edit project to change).
> 
> Categories are fixed for now. Give me a ping if you want to have a
> category added or changed.
> 
> Projects on the frontpage with a padlock in the status column are
> missing Travis CI authentication due to an earlier bug. To fix this,
> go to the project page and select Authenticate.
> 
> If you encounter any other issues, please report it here:
> 
> https://github.com/hansjorg/rust-ci
> 
> Next up:
> 
> * benchmarks upload (and graphing)
> 
> cheers,
> 
> Hans J?rgen
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From hansjorg at gmail.com  Mon Jan 20 18:54:15 2014
From: hansjorg at gmail.com (=?ISO-8859-1?Q?Hans_J=F8rgen_Hoel?=)
Date: Tue, 21 Jan 2014 03:54:15 +0100
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <8BE81A50-716C-4AA7-AB4C-4C5B5ED2DA93@sb.org>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
	<8BE81A50-716C-4AA7-AB4C-4C5B5ED2DA93@sb.org>
Message-ID: <CAJr2aW7URtSn8iKZ1r-jCcUiaudGt9S8LGAK+t-ZnQ=Df3fAKA@mail.gmail.com>

I've switched from an iframe to proxying:

http://www.rust-ci.org/kballard/rust-lua/doc/lua/

A bit slow at the moment. I'll add some caching asap.

-- 

Hans J?rgen

On 21 January 2014 01:42, Kevin Ballard <kevin at sb.org> wrote:
> That's pretty cool. http://www.rust-ci.org/kballard/rust-lua/doc/lua now contains documentation for rust-lua!
>
> Although there are two issues with the documentation as it exists now. Both are caused by the fact that the docs link actually embeds the real documentation in an <iframe>.
>
> The first issue is that the title of the page is always "Rust CI".
>
> The second is that clicking a link in the documentation will only navigate that <iframe>, and therefore the URL bar doesn't get updated and the browser back button (and history list) is broken.
>
> -Kevin
>
> On Jan 20, 2014, at 4:01 PM, Hans J?rgen Hoel <hansjorg at gmail.com> wrote:
>
>> Hi,
>>
>> Rust-ci (http://www.rust-ci.org/) has been updated with some new features
>>
>> * documentation can be uploaded during Travis CI builds (see project
>> page -> owner actions -> get config for docs upload)
>> * categorization of projects
>> * projects can now be edited and deleted by owners (aka Web 2.0 compliance)
>>
>> For a view of projects by category see:
>>
>> http://www.rust-ci.org/projects/
>>
>> I've added likely categories to projects based on name and
>> description, but I've probably missed a few so please take a look at
>> your own project (owner actions -> edit project to change).
>>
>> Categories are fixed for now. Give me a ping if you want to have a
>> category added or changed.
>>
>> Projects on the frontpage with a padlock in the status column are
>> missing Travis CI authentication due to an earlier bug. To fix this,
>> go to the project page and select Authenticate.
>>
>> If you encounter any other issues, please report it here:
>>
>> https://github.com/hansjorg/rust-ci
>>
>> Next up:
>>
>> * benchmarks upload (and graphing)
>>
>> cheers,
>>
>> Hans J?rgen
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>

From kevin at sb.org  Mon Jan 20 19:47:56 2014
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 20 Jan 2014 19:47:56 -0800
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <CAJr2aW7URtSn8iKZ1r-jCcUiaudGt9S8LGAK+t-ZnQ=Df3fAKA@mail.gmail.com>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
	<8BE81A50-716C-4AA7-AB4C-4C5B5ED2DA93@sb.org>
	<CAJr2aW7URtSn8iKZ1r-jCcUiaudGt9S8LGAK+t-ZnQ=Df3fAKA@mail.gmail.com>
Message-ID: <F6F25D71-7706-46DD-8AD5-6505740348B2@sb.org>

Now that is beautiful :)

Thanks for the quick fix!

-Kevin

On Jan 20, 2014, at 6:54 PM, Hans J?rgen Hoel <hansjorg at gmail.com> wrote:

> I've switched from an iframe to proxying:
> 
> http://www.rust-ci.org/kballard/rust-lua/doc/lua/
> 
> A bit slow at the moment. I'll add some caching asap.
> 
> -- 
> 
> Hans J?rgen
> 
> On 21 January 2014 01:42, Kevin Ballard <kevin at sb.org> wrote:
>> That's pretty cool. http://www.rust-ci.org/kballard/rust-lua/doc/lua now contains documentation for rust-lua!
>> 
>> Although there are two issues with the documentation as it exists now. Both are caused by the fact that the docs link actually embeds the real documentation in an <iframe>.
>> 
>> The first issue is that the title of the page is always "Rust CI".
>> 
>> The second is that clicking a link in the documentation will only navigate that <iframe>, and therefore the URL bar doesn't get updated and the browser back button (and history list) is broken.
>> 
>> -Kevin
>> 
>> On Jan 20, 2014, at 4:01 PM, Hans J?rgen Hoel <hansjorg at gmail.com> wrote:
>> 
>>> Hi,
>>> 
>>> Rust-ci (http://www.rust-ci.org/) has been updated with some new features
>>> 
>>> * documentation can be uploaded during Travis CI builds (see project
>>> page -> owner actions -> get config for docs upload)
>>> * categorization of projects
>>> * projects can now be edited and deleted by owners (aka Web 2.0 compliance)
>>> 
>>> For a view of projects by category see:
>>> 
>>> http://www.rust-ci.org/projects/
>>> 
>>> I've added likely categories to projects based on name and
>>> description, but I've probably missed a few so please take a look at
>>> your own project (owner actions -> edit project to change).
>>> 
>>> Categories are fixed for now. Give me a ping if you want to have a
>>> category added or changed.
>>> 
>>> Projects on the frontpage with a padlock in the status column are
>>> missing Travis CI authentication due to an earlier bug. To fix this,
>>> go to the project page and select Authenticate.
>>> 
>>> If you encounter any other issues, please report it here:
>>> 
>>> https://github.com/hansjorg/rust-ci
>>> 
>>> Next up:
>>> 
>>> * benchmarks upload (and graphing)
>>> 
>>> cheers,
>>> 
>>> Hans J?rgen
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 


From palmercox at gmail.com  Mon Jan 20 20:24:07 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Mon, 20 Jan 2014 23:24:07 -0500
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <F6F25D71-7706-46DD-8AD5-6505740348B2@sb.org>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
	<8BE81A50-716C-4AA7-AB4C-4C5B5ED2DA93@sb.org>
	<CAJr2aW7URtSn8iKZ1r-jCcUiaudGt9S8LGAK+t-ZnQ=Df3fAKA@mail.gmail.com>
	<F6F25D71-7706-46DD-8AD5-6505740348B2@sb.org>
Message-ID: <CAPZendxvW05zw-r_SA20N6M5tP31YCbYjWn=FUydyqS8SvpGrw@mail.gmail.com>

I've got to say, I'm very much against these changes - it sounds like I now
need to write some documentation for rust-crypto! Boo!

Just kidding - this sounds fantastic. Thanks for the great work!

-Palmer Cox

On Mon, Jan 20, 2014 at 10:47 PM, Kevin Ballard <kevin at sb.org> wrote:

> Now that is beautiful :)
>
> Thanks for the quick fix!
>
> -Kevin
>
> On Jan 20, 2014, at 6:54 PM, Hans J?rgen Hoel <hansjorg at gmail.com> wrote:
>
> > I've switched from an iframe to proxying:
> >
> > http://www.rust-ci.org/kballard/rust-lua/doc/lua/
> >
> > A bit slow at the moment. I'll add some caching asap.
> >
> > --
> >
> > Hans J?rgen
> >
> > On 21 January 2014 01:42, Kevin Ballard <kevin at sb.org> wrote:
> >> That's pretty cool. http://www.rust-ci.org/kballard/rust-lua/doc/luanow contains documentation for rust-lua!
> >>
> >> Although there are two issues with the documentation as it exists now.
> Both are caused by the fact that the docs link actually embeds the real
> documentation in an <iframe>.
> >>
> >> The first issue is that the title of the page is always "Rust CI".
> >>
> >> The second is that clicking a link in the documentation will only
> navigate that <iframe>, and therefore the URL bar doesn't get updated and
> the browser back button (and history list) is broken.
> >>
> >> -Kevin
> >>
> >> On Jan 20, 2014, at 4:01 PM, Hans J?rgen Hoel <hansjorg at gmail.com>
> wrote:
> >>
> >>> Hi,
> >>>
> >>> Rust-ci (http://www.rust-ci.org/) has been updated with some new
> features
> >>>
> >>> * documentation can be uploaded during Travis CI builds (see project
> >>> page -> owner actions -> get config for docs upload)
> >>> * categorization of projects
> >>> * projects can now be edited and deleted by owners (aka Web 2.0
> compliance)
> >>>
> >>> For a view of projects by category see:
> >>>
> >>> http://www.rust-ci.org/projects/
> >>>
> >>> I've added likely categories to projects based on name and
> >>> description, but I've probably missed a few so please take a look at
> >>> your own project (owner actions -> edit project to change).
> >>>
> >>> Categories are fixed for now. Give me a ping if you want to have a
> >>> category added or changed.
> >>>
> >>> Projects on the frontpage with a padlock in the status column are
> >>> missing Travis CI authentication due to an earlier bug. To fix this,
> >>> go to the project page and select Authenticate.
> >>>
> >>> If you encounter any other issues, please report it here:
> >>>
> >>> https://github.com/hansjorg/rust-ci
> >>>
> >>> Next up:
> >>>
> >>> * benchmarks upload (and graphing)
> >>>
> >>> cheers,
> >>>
> >>> Hans J?rgen
> >>> _______________________________________________
> >>> Rust-dev mailing list
> >>> Rust-dev at mozilla.org
> >>> https://mail.mozilla.org/listinfo/rust-dev
> >>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140120/7696f8ae/attachment-0001.html>

From adamson.benjamin at gmail.com  Mon Jan 20 21:49:21 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Mon, 20 Jan 2014 21:49:21 -0800
Subject: [rust-dev] Lifetime help
In-Reply-To: <CA+jWdBiooHwizCORG_2OSMMrOH8o1APxiDqwO41cb+4BRYmCYA@mail.gmail.com>
References: <CAHzuJ338CzJ_BYzyUsciPVH+gpMR5gw=ryX1zt=aLS5rO0JNbA@mail.gmail.com>
	<CA+jWdBjBcLr2pbAWtUHjA6zN7ZwjTSRZAS_k3DzvDv10=w8yKQ@mail.gmail.com>
	<CAJY4u8HWFDM3z6ozFGMat1dN7sQ7MPUcUqSDAX0fdH82Y1QUeQ@mail.gmail.com>
	<CA+jWdBiooHwizCORG_2OSMMrOH8o1APxiDqwO41cb+4BRYmCYA@mail.gmail.com>
Message-ID: <CAHzuJ31QuJf5_c5j14pcd-ud+TtCZyuc3n7g+6fQm7Wj35sUMA@mail.gmail.com>

Ah, the returned sprite must be annotated with the return value as well,
specifically the Sprite (because it has the reference to the Texture).
Thanks Vladimir*! *The gist you provided was very insightful :)

Adding the lifetime annotation to the sprite returned, tells the compiler
the sprite returned in the HashMap will live as long as the texture living
in the assets.

I think I worded that correctly.


On Mon, Jan 20, 2014 at 7:12 AM, Vladimir Matveev <dpx.infinity at gmail.com>wrote:

> In general it is likely that type annotations will be needed. But in
> this case you're quite correct. I have updated the gist, it now has
> significantly less noise.
>
> 2014/1/20 Evan G <eg1290 at gmail.com>:
> > Do you need to type annotate the intermediate variable? Shouldn't "let
> > sprites = assets.iter()" be sufficient? Or is it because of the
> lifetimes?
> >
> > On Jan 20, 2014 1:41 AM, "Vladimir Matveev" <dpx.infinity at gmail.com>
> wrote:
> >>
> >> Hi,
> >>
> >> In fact, you're almost there. You only need to add lifetime
> >> annotations on `Sprite` in the intermediate HashMap variable and in
> >> return type. See here: https://gist.github.com/dpx-infinity/8516387
> >>
> >> I tried to emulate rust-sfml types. This gist compiles, and the test
> >> is successful. BTW, you don't have to write `return` unless you want
> >> to exit early, for example, from inside a loop. Just leave out
> >> semicolon at the last line.
> >>
> >> Simple hint to detect mistakes in lifetime annotations: if you only
> >> have lifetime annotations on parameters or return values but not on
> >> both parameters and return values, then it is likely that something is
> >> wrong.
> >>
> >> 2014/1/20 benjamin adamson <adamson.benjamin at gmail.com>:
> >> > Hi all!
> >> >
> >> > I having a little trouble resolving this issue on my own, and I think
> >> > it's
> >> > an issue of syntax, not so much comprehending life times.
> >> >
> >> > What I'm doing is, using the RSFML library to try and write a pong
> clone
> >> > in
> >> > rust. So far it's been going awesome! I'm running into a small problem
> >> > with
> >> > lifetimes though. To give some context, SFML separates textures from
> >> > sprites, and sprites can be created with a borrowed pointer to a
> >> > texture. I
> >> > first load all the textures into a HashMap, and pass that hashmap to a
> >> > function which (is supposed to) will return a HashMap of Sprites.
> These
> >> > sprites I would like to initialize inside the function with references
> >> > to
> >> > the textures in the input HashMap of textures.
> >> >
> >> > Based on my understanding of borrowed pointers, this should be able to
> >> > work.
> >> > In fact, I wrote a simpler version of my function just to make sure I
> >> > understand what I am not understanding. I wrote a version of the
> >> > function
> >> > which takes the same HashMap of textures, and returns a single sprite
> >> > (not a
> >> > hashmap). The single sprite is created with a reference to the first
> >> > texture
> >> > in the hashmap. I was able to figure out the syntax to express this.
> >> > However
> >> > I can't seem to figure out the syntax for the more complicated case,
> >> > returning the hashmap of Sprites.
> >> >
> >> > I created a gist for easy viewing of the code I am having trouble
> with,
> >> > and
> >> > I think I've made it very obvious what's happening in the gist link,
> >> > hopefully somebody can help me sort this out :D
> >> > https://gist.github.com/ShortStomp/8513368
> >> >
> >> > also the link to the full file, if it helps.
> >> > https://github.com/ShortStomp/pong-rust/blob/master/main.rs
> >> >
> >> > Thanks in advance!!
> >> >
> >> > _______________________________________________
> >> > Rust-dev mailing list
> >> > Rust-dev at mozilla.org
> >> > https://mail.mozilla.org/listinfo/rust-dev
> >> >
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140120/57762f69/attachment.html>

From someone at mearie.org  Tue Jan 21 01:18:39 2014
From: someone at mearie.org (Kang Seonghoon)
Date: Tue, 21 Jan 2014 18:18:39 +0900
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
Message-ID: <CAL04ganuGQztrKY-JxLrKieyDzu7KbWNbT6pBaRnTuLNJqSqQQ@mail.gmail.com>

Great! I really appreciate a new project listing. Maybe you should
emphasize that you need to run `rustdoc` yourself to get the generated
docs uploaded to the server ;)

I have a question, or rather, a possible security issue with the
artifact uploading though, especially given the following script
template:

https://github.com/hansjorg/rust-ci/blob/master/tpt/ppatrigger/templates/ppatrigger/put_artifacts_script.txt

I'm not sure how you are using S3, but unless you give temporary
credentials to every project and set the bucket policy to ensure the
quota, malicious owners can do hairy things (exceeding quotas at the
least). I think per-upload signed policy [1] will work in this case,
though I'm not sure there is a CLI command for that. Not to mention
that the current script can upload anything, but I assume that you are
already taking that risk (or somehow have mitigated it).

[1] http://stackoverflow.com/a/5349530

2014/1/21 Hans J?rgen Hoel <hansjorg at gmail.com>:
> Hi,
>
> Rust-ci (http://www.rust-ci.org/) has been updated with some new features
>
> * documentation can be uploaded during Travis CI builds (see project
> page -> owner actions -> get config for docs upload)
> * categorization of projects
> * projects can now be edited and deleted by owners (aka Web 2.0 compliance)
>
> For a view of projects by category see:
>
> http://www.rust-ci.org/projects/
>
> I've added likely categories to projects based on name and
> description, but I've probably missed a few so please take a look at
> your own project (owner actions -> edit project to change).
>
> Categories are fixed for now. Give me a ping if you want to have a
> category added or changed.
>
> Projects on the frontpage with a padlock in the status column are
> missing Travis CI authentication due to an earlier bug. To fix this,
> go to the project page and select Authenticate.
>
> If you encounter any other issues, please report it here:
>
> https://github.com/hansjorg/rust-ci
>
> Next up:
>
> * benchmarks upload (and graphing)
>
> cheers,
>
> Hans J?rgen
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
-- Kang Seonghoon | Software Engineer, iPlateia Inc. | http://mearie.org/
-- Opinions expressed in this email do not necessarily represent the
views of my employer.
--

From hansjorg at gmail.com  Tue Jan 21 02:45:03 2014
From: hansjorg at gmail.com (=?ISO-8859-1?Q?Hans_J=F8rgen_Hoel?=)
Date: Tue, 21 Jan 2014 11:45:03 +0100
Subject: [rust-dev] Rust-ci updates (project categories and
	documentation)
In-Reply-To: <CAL04ganuGQztrKY-JxLrKieyDzu7KbWNbT6pBaRnTuLNJqSqQQ@mail.gmail.com>
References: <CAJr2aW4yc=WxjrtEKD+J_QvVpM9dm-jVNX+a_fAerwmDDHNmuA@mail.gmail.com>
	<CAL04ganuGQztrKY-JxLrKieyDzu7KbWNbT6pBaRnTuLNJqSqQQ@mail.gmail.com>
Message-ID: <CAJr2aW7HxumoC2ksBQBk2KV1mos06iOaR+A_c9XoaJ9MosN46A@mail.gmail.com>

Thanks for the feedback.That is indeed a concern. I'm already using
temporary per project credentials with limited policies.

I'll add some text about actually having to generate the docs yourself :)

Hans J?rgen


On 21 January 2014 10:18, Kang Seonghoon <someone at mearie.org> wrote:
> Great! I really appreciate a new project listing. Maybe you should
> emphasize that you need to run `rustdoc` yourself to get the generated
> docs uploaded to the server ;)
>
> I have a question, or rather, a possible security issue with the
> artifact uploading though, especially given the following script
> template:
>
> https://github.com/hansjorg/rust-ci/blob/master/tpt/ppatrigger/templates/ppatrigger/put_artifacts_script.txt
>
> I'm not sure how you are using S3, but unless you give temporary
> credentials to every project and set the bucket policy to ensure the
> quota, malicious owners can do hairy things (exceeding quotas at the
> least). I think per-upload signed policy [1] will work in this case,
> though I'm not sure there is a CLI command for that. Not to mention
> that the current script can upload anything, but I assume that you are
> already taking that risk (or somehow have mitigated it).
>
> [1] http://stackoverflow.com/a/5349530
>
> 2014/1/21 Hans J?rgen Hoel <hansjorg at gmail.com>:
>> Hi,
>>
>> Rust-ci (http://www.rust-ci.org/) has been updated with some new features
>>
>> * documentation can be uploaded during Travis CI builds (see project
>> page -> owner actions -> get config for docs upload)
>> * categorization of projects
>> * projects can now be edited and deleted by owners (aka Web 2.0 compliance)
>>
>> For a view of projects by category see:
>>
>> http://www.rust-ci.org/projects/
>>
>> I've added likely categories to projects based on name and
>> description, but I've probably missed a few so please take a look at
>> your own project (owner actions -> edit project to change).
>>
>> Categories are fixed for now. Give me a ping if you want to have a
>> category added or changed.
>>
>> Projects on the frontpage with a padlock in the status column are
>> missing Travis CI authentication due to an earlier bug. To fix this,
>> go to the project page and select Authenticate.
>>
>> If you encounter any other issues, please report it here:
>>
>> https://github.com/hansjorg/rust-ci
>>
>> Next up:
>>
>> * benchmarks upload (and graphing)
>>
>> cheers,
>>
>> Hans J?rgen
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> -- Kang Seonghoon | Software Engineer, iPlateia Inc. | http://mearie.org/
> -- Opinions expressed in this email do not necessarily represent the
> views of my employer.
> --

From bilal at bilalhusain.com  Tue Jan 21 04:55:21 2014
From: bilal at bilalhusain.com (Bilal Husain)
Date: Tue, 21 Jan 2014 18:25:21 +0530
Subject: [rust-dev] Rust to JS (minor changes)
Message-ID: <CANinyTh5dc_WfNp-sP244EZhU2vLEK4pnkdKytHcfDcM7fk3Nw@mail.gmail.com>

I have added basic let destructuring so that the `lexer.rs` transpiles
completely and it works for the HEAD[1] at the moment (I am working on
last year's copy). Earlier, few statements in `mod test` block were
not supported.

I will now work on accuracy and functionality of the generated code,
so that lexer.rs can be automatically translated to a working
JavaScript code with minimum hints and glue code.

Again, I have tested on Firefox 26 only.

[1] https://raw.github.com/mozilla/rust/master/src/libsyntax/parse/lexer.rs

On 15/01/2014, Bilal Husain <bilal at bilalhusain.com> wrote:
> http://bilalhusain.com/rust-lexer/transpile.html
>
> thoughts?
>

From karablin at gmail.com  Tue Jan 21 14:18:36 2014
From: karablin at gmail.com (Igor Karablin)
Date: Wed, 22 Jan 2014 02:18:36 +0400
Subject: [rust-dev] should fail to compile or not?
Message-ID: <CALqqbsGibp409oVbOsV1vGwBcmQPZPEFgdMF_dHOf-SkV+Qr8g@mail.gmail.com>

Hello,

I'm learning rust and trying to understand why rust allows me to compile
this piece of code. When Drop impl is uncommented - rustc complains about
'use of moved value', which is ok i think. My question is - why it compiles
code when Drop is not implemented for Inner struct? If its behaves as
intended - where i can read about this difference?

struct Inner;
impl Inner {
    fn innerFn(&mut self) {
        println!("Inner::innerFn"); // just for tracing
    }
}

struct Outer {
    i: Inner
}

// uncomment it, and we get error: use of moved value: `inner`
/*
impl Drop for Inner {
    fn drop(&mut self) {
        println!("Inner::drop"); // just for tracing
    }
}
*/

fn main() {
    let mut inner = Inner;
    let mut outer = Outer { i: inner }; // inner is moved into outer.i ?
    inner.innerFn();                    // why then i can call its method?
    outer.i.innerFn();
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140122/91b1b516/attachment.html>

From alex at crichton.co  Tue Jan 21 17:02:21 2014
From: alex at crichton.co (Alex Crichton)
Date: Tue, 21 Jan 2014 17:02:21 -0800
Subject: [rust-dev] should fail to compile or not?
In-Reply-To: <CALqqbsGibp409oVbOsV1vGwBcmQPZPEFgdMF_dHOf-SkV+Qr8g@mail.gmail.com>
References: <CALqqbsGibp409oVbOsV1vGwBcmQPZPEFgdMF_dHOf-SkV+Qr8g@mail.gmail.com>
Message-ID: <CAFnh-meBsrxzg2dQ7sqbvUtk9BGwpo_sQkGOPHdBYj499CrK2g@mail.gmail.com>

Rust has the idea of "implicit copyability", a property of a type
formalized by the Pod trait. An implicitly copyable type is either a
primitive, or a structure/enum which is built from implicitly copyable
types (plus some extra rules in play here).

When you add a destructor (implementation of the Drop trait) to a
type, it is no longer implicitly copyable. With the Drop
implementation commented out, your value 'inner' is implicitly
copyable, so when you create 'outer' it copies the contents (in this
case there are none). When you have Drop, the creation of 'outer'
*moves* the 'inner' value (because it is no longer implicitly
copyable), hence the method call is no longer valid.

Hope that helps!

On Tue, Jan 21, 2014 at 2:18 PM, Igor Karablin <karablin at gmail.com> wrote:
> Hello,
>
> I'm learning rust and trying to understand why rust allows me to compile
> this piece of code. When Drop impl is uncommented - rustc complains about
> 'use of moved value', which is ok i think. My question is - why it compiles
> code when Drop is not implemented for Inner struct? If its behaves as
> intended - where i can read about this difference?
>
> struct Inner;
> impl Inner {
>     fn innerFn(&mut self) {
>         println!("Inner::innerFn"); // just for tracing
>     }
> }
>
> struct Outer {
>     i: Inner
> }
>
> // uncomment it, and we get error: use of moved value: `inner`
> /*
> impl Drop for Inner {
>     fn drop(&mut self) {
>         println!("Inner::drop"); // just for tracing
>     }
> }
> */
>
> fn main() {
>     let mut inner = Inner;
>     let mut outer = Outer { i: inner }; // inner is moved into outer.i ?
>     inner.innerFn();                    // why then i can call its method?
>     outer.i.innerFn();
> }
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From karablin at gmail.com  Tue Jan 21 17:14:42 2014
From: karablin at gmail.com (Igor Karablin)
Date: Wed, 22 Jan 2014 05:14:42 +0400
Subject: [rust-dev] should fail to compile or not?
In-Reply-To: <CAFnh-meBsrxzg2dQ7sqbvUtk9BGwpo_sQkGOPHdBYj499CrK2g@mail.gmail.com>
References: <CALqqbsGibp409oVbOsV1vGwBcmQPZPEFgdMF_dHOf-SkV+Qr8g@mail.gmail.com>
	<CAFnh-meBsrxzg2dQ7sqbvUtk9BGwpo_sQkGOPHdBYj499CrK2g@mail.gmail.com>
Message-ID: <CALqqbsF9mq8NKakodXDU9CWhWKQbEOiymLuhhBjKUS5CYuDq=g@mail.gmail.com>

Yes, this is really cleared all mystery, thanks for your explanation Alex!


On Wed, Jan 22, 2014 at 5:02 AM, Alex Crichton <alex at crichton.co> wrote:

> Rust has the idea of "implicit copyability", a property of a type
> formalized by the Pod trait. An implicitly copyable type is either a
> primitive, or a structure/enum which is built from implicitly copyable
> types (plus some extra rules in play here).
>
> When you add a destructor (implementation of the Drop trait) to a
> type, it is no longer implicitly copyable. With the Drop
> implementation commented out, your value 'inner' is implicitly
> copyable, so when you create 'outer' it copies the contents (in this
> case there are none). When you have Drop, the creation of 'outer'
> *moves* the 'inner' value (because it is no longer implicitly
> copyable), hence the method call is no longer valid.
>
> Hope that helps!
>
> On Tue, Jan 21, 2014 at 2:18 PM, Igor Karablin <karablin at gmail.com> wrote:
> > Hello,
> >
> > I'm learning rust and trying to understand why rust allows me to compile
> > this piece of code. When Drop impl is uncommented - rustc complains about
> > 'use of moved value', which is ok i think. My question is - why it
> compiles
> > code when Drop is not implemented for Inner struct? If its behaves as
> > intended - where i can read about this difference?
> >
> > struct Inner;
> > impl Inner {
> >     fn innerFn(&mut self) {
> >         println!("Inner::innerFn"); // just for tracing
> >     }
> > }
> >
> > struct Outer {
> >     i: Inner
> > }
> >
> > // uncomment it, and we get error: use of moved value: `inner`
> > /*
> > impl Drop for Inner {
> >     fn drop(&mut self) {
> >         println!("Inner::drop"); // just for tracing
> >     }
> > }
> > */
> >
> > fn main() {
> >     let mut inner = Inner;
> >     let mut outer = Outer { i: inner }; // inner is moved into outer.i ?
> >     inner.innerFn();                    // why then i can call its
> method?
> >     outer.i.innerFn();
> > }
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140122/fac24e3d/attachment.html>

From bytbox at gmail.com  Tue Jan 21 17:41:18 2014
From: bytbox at gmail.com (Scott Lawrence)
Date: Tue, 21 Jan 2014 20:41:18 -0500 (EST)
Subject: [rust-dev] Lifetime required to outlive itself
Message-ID: <alpine.LNX.2.03.1401212030100.1434@localhost.localdomain>

This code compiles successfully: http://ix.io/a34 . I believe this behavior is 
correct. Just so it's clear what this code does: f() takes a `&mut int` and 
adds it to an array - the idea is that all of the `&mut int` can be changed at 
some later time. Naturally, there's some fancy lifetime juggling involved in 
this (which I may have gotten wrong).

Uncommenting the commented parts (the method f() in the impl A, in particular) 
yields the error message shown at the bottom, which appears to say that the 
lifetime created in the second parameter of f() does not necessarily outlive 
itself.

Is there some especially complicated aspect of lifetimes as they interact 
with &self, or is this indeed a bug?

-- 
Scott Lawrence

From dbau.pp at gmail.com  Tue Jan 21 17:46:11 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 22 Jan 2014 12:46:11 +1100
Subject: [rust-dev] Lifetime required to outlive itself
In-Reply-To: <alpine.LNX.2.03.1401212030100.1434@localhost.localdomain>
References: <alpine.LNX.2.03.1401212030100.1434@localhost.localdomain>
Message-ID: <52DF22E3.6020600@gmail.com>

On 22/01/14 12:41, Scott Lawrence wrote:
> This code compiles successfully: http://ix.io/a34 . I believe this 
> behavior is correct. Just so it's clear what this code does: f() takes 
> a `&mut int` and adds it to an array - the idea is that all of the 
> `&mut int` can be changed at some later time. Naturally, there's some 
> fancy lifetime juggling involved in this (which I may have gotten wrong).
>
> Uncommenting the commented parts (the method f() in the impl A, in 
> particular) yields the error message shown at the bottom, which 
> appears to say that the lifetime created in the second parameter of 
> f() does not necessarily outlive itself.
>
> Is there some especially complicated aspect of lifetimes as they 
> interact with &self, or is this indeed a bug?
>

I think it's the compiler tricking you: the 'a in `fn f<'a>(&mut self, 
...)` is shadowing the `impl<'a> A<'a>` i.e. they are different 
lifetimes that happen to have the same identifier. Changing it to `fn 
f(&mut self, &'a mut int)` should work.


There's a bug open about warning on shadowed generics, because, as this 
demonstrates, you end up with hard-to-diagnose error messages: 
https://github.com/mozilla/rust/issues/11658


Huon

From bytbox at gmail.com  Tue Jan 21 17:50:35 2014
From: bytbox at gmail.com (Scott Lawrence)
Date: Tue, 21 Jan 2014 20:50:35 -0500 (EST)
Subject: [rust-dev] Lifetime required to outlive itself
In-Reply-To: <52DF22E3.6020600@gmail.com>
References: <alpine.LNX.2.03.1401212030100.1434@localhost.localdomain>
	<52DF22E3.6020600@gmail.com>
Message-ID: <alpine.LNX.2.03.1401212049340.1434@localhost.localdomain>

Yup, that was pretty much it. (I suspected something like that might be 
happening.) Thanks!

To future generations of confused souls: when the impl is parameterized, the 
function probably doesn't need to be.

On Wed, 22 Jan 2014, Huon Wilson wrote:

> On 22/01/14 12:41, Scott Lawrence wrote:
>> This code compiles successfully: http://ix.io/a34 . I believe this behavior 
>> is correct. Just so it's clear what this code does: f() takes a `&mut int` 
>> and adds it to an array - the idea is that all of the `&mut int` can be 
>> changed at some later time. Naturally, there's some fancy lifetime juggling 
>> involved in this (which I may have gotten wrong).
>> 
>> Uncommenting the commented parts (the method f() in the impl A, in 
>> particular) yields the error message shown at the bottom, which appears to 
>> say that the lifetime created in the second parameter of f() does not 
>> necessarily outlive itself.
>> 
>> Is there some especially complicated aspect of lifetimes as they interact 
>> with &self, or is this indeed a bug?
>> 
>
> I think it's the compiler tricking you: the 'a in `fn f<'a>(&mut self, ...)` 
> is shadowing the `impl<'a> A<'a>` i.e. they are different lifetimes that 
> happen to have the same identifier. Changing it to `fn f(&mut self, &'a mut 
> int)` should work.
>
>
> There's a bug open about warning on shadowed generics, because, as this 
> demonstrates, you end up with hard-to-diagnose error messages: 
> https://github.com/mozilla/rust/issues/11658
>
>
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

-- 
Scott Lawrence

From bascule at gmail.com  Tue Jan 21 21:48:41 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 21 Jan 2014 21:48:41 -0800
Subject: [rust-dev] Improving rustc error messages
Message-ID: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>

I think the biggest thing I've struggled with learning Rust is what I will
call, for lack of a better phrase, "shit rustc says". Reading Steve
Klabnik's tutorial and some blog posts about earlier versions of rust, it's
clear that the error messages have improved dramatically since earlier
versions, but I still think there's quite a bit of room for improvement.

For an example of how errors could be presented better, I'd look to
Facebook's typed PHP language, Hack, which was presented at Strange Loop
2013. Hack supports a pretty fancy type system for a gradually typed
language, complete with subtyping (which PHP necessitates) and non-nullable
types.

Hack uses a story format for error messages in order to make them easier to
understand:

  File "test.php", line 6, characters 10-11:
Invalid return type
File "test.php", line 3, characters 24-26:
This is an int
File "test.php", line 5, characters 10-11:
It is incompatible with a string

If rustc could do something like this, I think it'd make the errors a lot
easier to understand and provide for easier debugging.

For more information on Hack, check out the talk on InfoQ:

http://www.infoq.com/presentations/php-history

Or the slides:

https://github.com/strangeloop/StrangeLoop2013/blob/master/slides/sessions/Adams-TakingPHPSeriously.pdf

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140121/aea598c0/attachment.html>

From pcwalton at mozilla.com  Tue Jan 21 21:55:27 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 21 Jan 2014 21:55:27 -0800
Subject: [rust-dev] Improving rustc error messages
In-Reply-To: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>
References: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>
Message-ID: <52DF5D4F.9020208@mozilla.com>

On 1/21/14 9:48 PM, Tony Arcieri wrote:
> I think the biggest thing I've struggled with learning Rust is what I
> will call, for lack of a better phrase, "shit rustc says". Reading Steve
> Klabnik's tutorial and some blog posts about earlier versions of rust,
> it's clear that the error messages have improved dramatically since
> earlier versions, but I still think there's quite a bit of room for
> improvement.

I think we need some specific examples. I personally think that between 
the colored output, printing of the erroneous lines, spelling 
corrections, suggestions of `.clone()` and so forth, rustc actually has 
some of the best diagnostics around for new statically-typed languages. 
But there is always room for improvement of course.

Patrick


From bascule at gmail.com  Tue Jan 21 21:55:05 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 21 Jan 2014 21:55:05 -0800
Subject: [rust-dev] Improving rustc error messages
In-Reply-To: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>
References: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>
Message-ID: <CAHOTMVKch3_OvZ2f3hPoL3UvxtHjqHui0NuEXdT0GDM-tEwPWw@mail.gmail.com>

I see there's some work underway of this nature ;)

https://github.com/mozilla/rust/pull/11718


On Tue, Jan 21, 2014 at 9:48 PM, Tony Arcieri <bascule at gmail.com> wrote:

> I think the biggest thing I've struggled with learning Rust is what I will
> call, for lack of a better phrase, "shit rustc says". Reading Steve
> Klabnik's tutorial and some blog posts about earlier versions of rust, it's
> clear that the error messages have improved dramatically since earlier
> versions, but I still think there's quite a bit of room for improvement.
>
> For an example of how errors could be presented better, I'd look to
> Facebook's typed PHP language, Hack, which was presented at Strange Loop
> 2013. Hack supports a pretty fancy type system for a gradually typed
> language, complete with subtyping (which PHP necessitates) and non-nullable
> types.
>
> Hack uses a story format for error messages in order to make them easier
> to understand:
>
>   File "test.php", line 6, characters 10-11:
> Invalid return type
> File "test.php", line 3, characters 24-26:
> This is an int
> File "test.php", line 5, characters 10-11:
> It is incompatible with a string
>
> If rustc could do something like this, I think it'd make the errors a lot
> easier to understand and provide for easier debugging.
>
> For more information on Hack, check out the talk on InfoQ:
>
> http://www.infoq.com/presentations/php-history
>
> Or the slides:
>
>
> https://github.com/strangeloop/StrangeLoop2013/blob/master/slides/sessions/Adams-TakingPHPSeriously.pdf
>
> --
> Tony Arcieri
>



-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140121/dbe5301b/attachment.html>

From bascule at gmail.com  Tue Jan 21 21:58:54 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 21 Jan 2014 21:58:54 -0800
Subject: [rust-dev] Improving rustc error messages
In-Reply-To: <52DF5D4F.9020208@mozilla.com>
References: <CAHOTMVKeGGWs63Jq7i6AZZHwtGdLdwrjqVToeUGmFf34rNT2uw@mail.gmail.com>
	<52DF5D4F.9020208@mozilla.com>
Message-ID: <CAHOTMVKtisVa3d0d+FkEZB24xZb+=9_vr2mb90EdraZcfRYp1w@mail.gmail.com>

On Tue, Jan 21, 2014 at 9:55 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> I think we need some specific examples. I personally think that between
> the colored output, printing of the erroneous lines, spelling corrections,
> suggestions of `.clone()` and so forth, rustc actually has some of the best
> diagnostics around for new statically-typed languages. But there is always
> room for improvement of course.
>

#11718 is a great example. If there are other specific things that
particularly bug me, I'll let you know ;)

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140121/37e7e52e/attachment.html>

From banderson at mozilla.com  Tue Jan 21 22:53:03 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 21 Jan 2014 22:53:03 -0800
Subject: [rust-dev] Code review checklist
In-Reply-To: <CAMOT3C2x9G0c3t+2n5s+yo9ZT98_-jUspYuKx3CY9_h4zUaU1g@mail.gmail.com>
References: <CAMOT3C2x9G0c3t+2n5s+yo9ZT98_-jUspYuKx3CY9_h4zUaU1g@mail.gmail.com>
Message-ID: <52DF6ACF.7050704@mozilla.com>

Thanks. This is a good idea.

On 01/19/2014 04:52 AM, Flaper87 wrote:
> Hey,
>
> I've been doing reviews for a bit and I just realized we, as 
> community, don't have a review checklist that all reviewers should go 
> through. I thought that it could be useful to have a wiki page 
> describing the review proces for newcomers and people willing to 
> contribute with reviews.
>
> I wrote some points here[0] based on what I've seen. I also added a 
> section for non-core reviewers (people w/o r+ powers). In this section 
> I just added 1 item in order for these group of folks (which I'm part 
> of) to give their blessing to the patches they've reviewed. This will 
> welcome more reviewes at the cost of adding more noise to the PR.
>
> Any comments are welcome. Also, it's a wiki page so feel free to 
> improve it.  I haven't linked it to the 'Notes for developers' page 
> because I'd like it to be reviewed first.
>
> [0] https://github.com/mozilla/rust/wiki/Note-code-review
>
> FF
>
> -- 
> Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140121/e5a7b818/attachment.html>

From flaper87 at gmail.com  Wed Jan 22 00:41:26 2014
From: flaper87 at gmail.com (Flaper87)
Date: Wed, 22 Jan 2014 09:41:26 +0100
Subject: [rust-dev] Code review checklist
In-Reply-To: <52DF6ACF.7050704@mozilla.com>
References: <CAMOT3C2x9G0c3t+2n5s+yo9ZT98_-jUspYuKx3CY9_h4zUaU1g@mail.gmail.com>
	<52DF6ACF.7050704@mozilla.com>
Message-ID: <CAMOT3C1VBOik_GBOEMVPRv=rrx9sRkgtpq2RJu+0KEyT4O7guA@mail.gmail.com>

2014/1/22 Brian Anderson <banderson at mozilla.com>

>  Thanks. This is a good idea.
>
>

I added it to the Notes wiki page now!

Hope it helps!
FF


>
> On 01/19/2014 04:52 AM, Flaper87 wrote:
>
>   Hey,
>
>  I've been doing reviews for a bit and I just realized we, as community,
> don't have a review checklist that all reviewers should go through. I
> thought that it could be useful to have a wiki page describing the review
> proces for newcomers and people willing to contribute with reviews.
>
>  I wrote some points here[0] based on what I've seen. I also added a
> section for non-core reviewers (people w/o r+ powers). In this section I
> just added 1 item in order for these group of folks (which I'm part of) to
> give their blessing to the patches they've reviewed. This will welcome more
> reviewes at the cost of adding more noise to the PR.
>
>  Any comments are welcome. Also, it's a wiki page so feel free to improve
> it.  I haven't linked it to the 'Notes for developers' page because I'd
> like it to be reviewed first.
>
> [0] https://github.com/mozilla/rust/wiki/Note-code-review
>
>  FF
>
> --
>  Flavio (@flaper87) Percoco
> http://www.flaper87.com
> http://github.com/FlaPer87
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140122/59d851bb/attachment-0001.html>

From matthias.einwag at googlemail.com  Wed Jan 22 12:37:32 2014
From: matthias.einwag at googlemail.com (Matthias Einwag)
Date: Wed, 22 Jan 2014 21:37:32 +0100
Subject: [rust-dev] Modules and visibility
Message-ID: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>

Hi everyone,

During my first steps with Rust (and working on this:
https://github.com/mozilla/rust/issues/11165) I realized that I had much
more trouble with the module and privacy system than in any other language
I worked with up to date. I really had no clear idea of how to structure my
source files and spent nearly ours about it. This seems a little
unfortunate to me, since I have the impression that a basic module and
visibility system doesn't have to be complicated.

There are basically two things that lead to this, and they are both quite
related:

The first in is the relation between modules and files.
In the tutorial there is the sentence: "One important aspect about Rusts
module system is that source files are not important".
I absolutely can't agree on that one, because of the fact that with each
new file you also get new module.
I usually like to structure my programs into source code files where each
code file resembles a type or an object. Keep things small to get a
betteroview and can find the sources where things are declared faster.
However I also don't like Java which forces you to exactly create 1 source
file per object and arrange the folders according to the module/package
structure. In this regard I find Rust even worse to Java, because it's one
module per file.
If you like to have everything in a module (e.g. because the types in the
module tightly interact) this encourages you to simply put everything in a
single big source file. Or to give up on Rust.
Instead I really like to have something were files and types are really
loosely coupled, like C# and C++.

Putting several things in one module is often relevant for privacy reasons.
They tightly interact and I want to access priv fields or members of the
other items. Privacy is the second issue I have with the current system. In
my Rust project I gave up in several cases and just made things public to
allow types in other modules access to my types, even if it's really wrong
from an encapsulation point of view and also gives external library users
the opportunity to manipulate things. The alternative would be to give up
on splitted source files. C++ at least allow friend; and Java and C# an
internal visibility modifier to allow things to reference each without
giving up privacy to the outside.

Besides the problem that file->module leads to modified privacy settings I
also think it's quite verbose to do the whole imports for the file again.

To make things easier and better I would love to see two things in Rust:
1. A real splitting between source files and modules
   One solution is an alternative include to mod Otherfile; That would not
automatically create a new module and put the content of the file in it.
   So basically the same as C++ include. I know there's include!, but is
discouraged and from my tests also did not work for including types.
   The other option is to have something like Dart. There you have a top
level file for you module/library, where you specify which other files are
part of the module.
   Like `part "otherfile.rs";` In the other files you specify `part of
myModule;` to make clear that they belong to each other.
2. Crate local visibility
   I've seen that it was already discussed on the mailing list before. But
I also think that is a great benefit that enables one to access private
fields/methods of other types even though they are in different modules.
   I actually like the internal in C# more than the friend in C++, because
it's much easier to use. Rust could also introduce either an internal
visibility modifer in addition to the existing priv and pub ones.
   Or a crate setting that makes all priv items visible to all other types
in the crate. However I like the internal much better, because it's a more
fine grained and still easy-to-use control.

Don't get me wrong, I think Rust is a great language with lots of potential
- and some awesome developers.
But I think there are some corners were it is much harder to use than it
has to be. And the module system is one of them.

Best Regards
Matthias
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140122/c14a38c8/attachment.html>

From pcwalton at mozilla.com  Thu Jan 23 10:59:10 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 23 Jan 2014 10:59:10 -0800
Subject: [rust-dev] Modules and visibility
In-Reply-To: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
Message-ID: <52E1667E.8040403@mozilla.com>

On 1/22/14 12:37 PM, Matthias Einwag wrote:
> 1. A real splitting between source files and modules
>     One solution is an alternative include to mod Otherfile; That would
> not automatically create a new module and put the content of the file in it.
>     So basically the same as C++ include. I know there's include!, but
> is discouraged and from my tests also did not work for including types.
>     The other option is to have something like Dart. There you have a
> top level file for you module/library, where you specify which other
> files are part of the module.
>     Like `part "otherfile.rs <http://otherfile.rs>";` In the other files
> you specify `part of myModule;` to make clear that they belong to each
> other.

For engineering reasons I really like the fact that you can always find 
the definition of any name by simply looking in the same file. Any name 
"foo" is always:

1. Defined in the same file.

2. Imported at the top of the file.

3. Defined in the prelude.

For large projects, this eliminates a lot of grepping through the codebase.

Patrick


From matthieu.monrocq at gmail.com  Thu Jan 23 11:41:16 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Thu, 23 Jan 2014 20:41:16 +0100
Subject: [rust-dev] Modules and visibility
In-Reply-To: <52E1667E.8040403@mozilla.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
Message-ID: <CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>

On Thu, Jan 23, 2014 at 7:59 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/22/14 12:37 PM, Matthias Einwag wrote:
>
>> 1. A real splitting between source files and modules
>>     One solution is an alternative include to mod Otherfile; That would
>> not automatically create a new module and put the content of the file in
>> it.
>>     So basically the same as C++ include. I know there's include!, but
>> is discouraged and from my tests also did not work for including types.
>>     The other option is to have something like Dart. There you have a
>> top level file for you module/library, where you specify which other
>> files are part of the module.
>>     Like `part "otherfile.rs <http://otherfile.rs>";` In the other files
>>
>> you specify `part of myModule;` to make clear that they belong to each
>> other.
>>
>
> For engineering reasons I really like the fact that you can always find
> the definition of any name by simply looking in the same file. Any name
> "foo" is always:
>
> 1. Defined in the same file.
>
> 2. Imported at the top of the file.
>
> 3. Defined in the prelude.
>
> For large projects, this eliminates a lot of grepping through the codebase.
>
> Patrick
>
>
And working on large projects, I can only concur with that.

Yes we all have IDEs, but when IDEs have to maintain complex internal
indexes (thanks C++) to be able to point you at the definition of the
class/function, they always break in subtle ways... on top of taking ages
to index freshly cloned projects.

-- Matthieu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/47ff7203/attachment.html>

From banderson at mozilla.com  Thu Jan 23 12:33:27 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 23 Jan 2014 12:33:27 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
Message-ID: <52E17C97.6040601@mozilla.com>

On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
> People should rethink the Chan api that Chan::new() does not returns a 
> value of type Chan (instead, a tuple), which is strange, 
> and inconsistent with other Type::new().
>

Agree, though I haven't heard any great suggestions yet. The core 
problem is that there are three different entities involved: the sending 
end, the recieving end, and the thing that represents the entire 
channel, and they all need different names. The best I've heard is 
`pipe() -> (Port, Chan)`, but I would rather call the whole thing a 
channel and have a different name for the sender.


From thadguidry at gmail.com  Thu Jan 23 13:28:32 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 23 Jan 2014 15:28:32 -0600
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E17C97.6040601@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
Message-ID: <CAChbWaOCjcHtHtPw5_9y4ZxHPL-rsy=3eTSn0bbzCqxxjUC+iw@mail.gmail.com>

On Thu, Jan 23, 2014 at 2:33 PM, Brian Anderson <banderson at mozilla.com>wrote:

> On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
>
>> People should rethink the Chan api that Chan::new() does not returns a
>> value of type Chan (instead, a tuple), which is strange, and inconsistent
>> with other Type::new().
>>
>>
> Agree, though I haven't heard any great suggestions yet. The core problem
> is that there are three different entities involved: the sending end, the
> recieving end, and the thing that represents the entire channel, and they
> all need different names. The best I've heard is `pipe() -> (Port, Chan)`,
> but I would rather call the whole thing a channel and have a different name
> for the sender.
>
>
A good alias / synonym for a "sender" would be a "transmitter".  food for
thought.

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/0ca72225/attachment.html>

From steve at steveklabnik.com  Thu Jan 23 14:21:50 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Thu, 23 Jan 2014 14:21:50 -0800
Subject: [rust-dev] Modules and visibility
In-Reply-To: <CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
	<CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
Message-ID: <CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>

We all very much do NOT have IDEs. ;)

From steve at steveklabnik.com  Thu Jan 23 14:23:02 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Thu, 23 Jan 2014 14:23:02 -0800
Subject: [rust-dev] Modules and visibility
In-Reply-To: <CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
	<CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
	<CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>
Message-ID: <CABL+ZB7rmKJTuVO8jCQFh2UBv-_iUgaM75dZLy50Wv3hROoiAA@mail.gmail.com>

Ehhh, my phrasing on that one was poor. What I was trying to say is
that there are a significant number of users of Rust who do not have
IDEs, and adding anything that would _require_ you to use an IDE with
Rust is a significant drawback.

If an IDE floats your boat, no complaints from me. As long as I can
use my vim, I don't care what you use. :)

From vadimcn at gmail.com  Thu Jan 23 14:32:58 2014
From: vadimcn at gmail.com (Vadim)
Date: Thu, 23 Jan 2014 14:32:58 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E17C97.6040601@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
Message-ID: <CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>

Well maybe then channel() -> (SendEnd, RecvEnd) ?   Or, channel() ->
(Source, Drain) ?


On Thu, Jan 23, 2014 at 12:33 PM, Brian Anderson <banderson at mozilla.com>wrote:

> On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
>
>> People should rethink the Chan api that Chan::new() does not returns a
>> value of type Chan (instead, a tuple), which is strange, and inconsistent
>> with other Type::new().
>>
>>
> Agree, though I haven't heard any great suggestions yet. The core problem
> is that there are three different entities involved: the sending end, the
> recieving end, and the thing that represents the entire channel, and they
> all need different names. The best I've heard is `pipe() -> (Port, Chan)`,
> but I would rather call the whole thing a channel and have a different name
> for the sender.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/87910c80/attachment.html>

From adamson.benjamin at gmail.com  Thu Jan 23 14:50:15 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Thu, 23 Jan 2014 14:50:15 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
Message-ID: <CAHzuJ32xzM7qoWQOVSMBWebhMfKhyFi3xb7u+wZxBNqQzqfShw@mail.gmail.com>

Maybe we can borrow some inspiration from the haskell pipes library?


On Thu, Jan 23, 2014 at 2:32 PM, Vadim <vadimcn at gmail.com> wrote:

> Well maybe then channel() -> (SendEnd, RecvEnd) ?   Or, channel() ->
> (Source, Drain) ?
>
>
> On Thu, Jan 23, 2014 at 12:33 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>> On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
>>
>>> People should rethink the Chan api that Chan::new() does not returns a
>>> value of type Chan (instead, a tuple), which is strange, and inconsistent
>>> with other Type::new().
>>>
>>>
>> Agree, though I haven't heard any great suggestions yet. The core problem
>> is that there are three different entities involved: the sending end, the
>> recieving end, and the thing that represents the entire channel, and they
>> all need different names. The best I've heard is `pipe() -> (Port, Chan)`,
>> but I would rather call the whole thing a channel and have a different name
>> for the sender.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/b59cf126/attachment.html>

From val at markovic.io  Thu Jan 23 14:56:56 2014
From: val at markovic.io (Val Markovic)
Date: Thu, 23 Jan 2014 14:56:56 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
Message-ID: <CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>

On Thu, Jan 23, 2014 at 2:32 PM, Vadim <vadimcn at gmail.com> wrote:

> Well maybe then channel() -> (SendEnd, RecvEnd) ?   Or, channel() ->
> (Source, Drain) ?
>

When there are two concepts, one for "data comes out of this" and one for
"data goes into this", the names I have most often encountered are "Source"
and "Sink". They're pretty descriptive; you immediately know which end is
which. "Source" and "Drain" serves the same purpose as well.

"Port" and "Chan" are IMO really bad names. Neither tells me anything about
does it accept or provide data. "Chan" especially, since conceptually a
channel is the conduit between a source and a sink.

Like Brian said, three concepts are involved here. Good names would be
"Source", "Channel" and "Sink", all three of which are descriptive. No
explanation is necessary to understand what's behind the names and no
memorization is required.

Channel::new() returning a Source and Sink would be an improvement, but it
breaks the mental model of "Type::new() creates a new Type" from the rest
of the codebase.

We need a different name than "new" for this. "Channel::pipe()" is better,
but since function names are often verbs or start with verbs, it implies
not that a pipe is being built, but that the function accepts something
that is piped through the channel.

Channel::new_pipe() returning a (Source, Sink) seems ideal. "new" as the
word before "pipe" would be a good choice because it's suggestive of how
"new()" in other types builds the type.


>
>
> On Thu, Jan 23, 2014 at 12:33 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>> On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
>>
>>> People should rethink the Chan api that Chan::new() does not returns a
>>> value of type Chan (instead, a tuple), which is strange, and inconsistent
>>> with other Type::new().
>>>
>>>
>> Agree, though I haven't heard any great suggestions yet. The core problem
>> is that there are three different entities involved: the sending end, the
>> recieving end, and the thing that represents the entire channel, and they
>> all need different names. The best I've heard is `pipe() -> (Port, Chan)`,
>> but I would rather call the whole thing a channel and have a different name
>> for the sender.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/696d8e4d/attachment-0001.html>

From matthias.einwag at googlemail.com  Thu Jan 23 15:28:07 2014
From: matthias.einwag at googlemail.com (Matthias Einwag)
Date: Fri, 24 Jan 2014 00:28:07 +0100
Subject: [rust-dev] Modules and visibility
Message-ID: <01a401cf1892$c67ff480$537fdd80$@googlemail.com>

Hi,

 

with similar engineering reasons I can argue the same way that splitting
into multiple makes sense:

1.       When you name the file like our object you can use jump to file as
a replacement for a Jump to Definition in more complex IDEs.

2.       When you layout your folders like the module structure is and the
files therin like the types it is quite easy to find the actual file that
defines something.

3.       When you have multiple  types in your module you can use multiple
windows in your editor to work on both in parallel. This is not necessarily
supported if you want two views  into the same file at different positions.

 

Propably it's also a matter of taste. Some people like big source files.
Others (like me) don't like them. 

In several projects or even languages (Java) it's convention to break
everything down in small parts.

It shouldn't be too hard to satisfy everyone here I think . This doesn't ask
for really big and incompatible changes to the module system. Only for the
option to get rid of the file -> module condition.

 

PS: Sorry that we now have 2 discussions. One on Github and this one. I sent
it a little bit earlier before seeing the other one. However my intent is
really more the file and privacy thing than discussing about the whole mod
xyz and use:: functionality. 

 

Best regards

Matthias

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/d6858b1a/attachment.html>

From com.liigo at gmail.com  Thu Jan 23 15:58:19 2014
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Fri, 24 Jan 2014 07:58:19 +0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
Message-ID: <CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>

Good idea.

How about Channel::new_ends() returns (SendEnd, RecvEnd) ?
 2014?1?24? ??6:57? "Val Markovic" <val at markovic.io>???

> On Thu, Jan 23, 2014 at 2:32 PM, Vadim <vadimcn at gmail.com> wrote:
>
>> Well maybe then channel() -> (SendEnd, RecvEnd) ?   Or, channel() ->
>> (Source, Drain) ?
>>
>
> When there are two concepts, one for "data comes out of this" and one for
> "data goes into this", the names I have most often encountered are "Source"
> and "Sink". They're pretty descriptive; you immediately know which end is
> which. "Source" and "Drain" serves the same purpose as well.
>
> "Port" and "Chan" are IMO really bad names. Neither tells me anything
> about does it accept or provide data. "Chan" especially, since conceptually
> a channel is the conduit between a source and a sink.
>
> Like Brian said, three concepts are involved here. Good names would be
> "Source", "Channel" and "Sink", all three of which are descriptive. No
> explanation is necessary to understand what's behind the names and no
> memorization is required.
>
> Channel::new() returning a Source and Sink would be an improvement, but it
> breaks the mental model of "Type::new() creates a new Type" from the rest
> of the codebase.
>
> We need a different name than "new" for this. "Channel::pipe()" is better,
> but since function names are often verbs or start with verbs, it implies
> not that a pipe is being built, but that the function accepts something
> that is piped through the channel.
>
> Channel::new_pipe() returning a (Source, Sink) seems ideal. "new" as the
> word before "pipe" would be a good choice because it's suggestive of how
> "new()" in other types builds the type.
>
>
>>
>>
>> On Thu, Jan 23, 2014 at 12:33 PM, Brian Anderson <banderson at mozilla.com>wrote:
>>
>>> On 01/13/2014 10:15 PM, Liigo Zhuang wrote:
>>>
>>>> People should rethink the Chan api that Chan::new() does not returns a
>>>> value of type Chan (instead, a tuple), which is strange, and inconsistent
>>>> with other Type::new().
>>>>
>>>>
>>> Agree, though I haven't heard any great suggestions yet. The core
>>> problem is that there are three different entities involved: the sending
>>> end, the recieving end, and the thing that represents the entire channel,
>>> and they all need different names. The best I've heard is `pipe() -> (Port,
>>> Chan)`, but I would rather call the whole thing a channel and have a
>>> different name for the sender.
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/d5b3c06e/attachment.html>

From steve at steveklabnik.com  Thu Jan 23 15:59:55 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Thu, 23 Jan 2014 15:59:55 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
Message-ID: <CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>

I don't think that `new` not returning a `Channel` is a big deal.
Conceptually, you are, both ends 'make up' a channel.

From val at markovic.io  Thu Jan 23 19:16:01 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 24 Jan 2014 03:16:01 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
Message-ID: <8732788473086921764@gmail297201516>

On Thu Jan 23 2014 at 3:59:56 PM, Steve Klabnik <steve at steveklabnik.com>
wrote:

> I don't think that `new` not returning a `Channel` is a big deal.
> Conceptually, you are, both ends 'make up' a channel.
>

I agree it's not a big deal, but I still think it's something we might want
to change. Why introduce a mental speed bump if we don't have to?
Foo::new() returns a Foo, Bar::new() returns a Bar, Quux::new() returns a
Quux and a Channel::new() returns a... tuple of two items, neither of which
is a Channel (I know the two items together are conceptually a *channel*,
but they are not a Channel).

Using new() here seems like a usability loss for no benefit. But again,
it's not a huge issue (should still be fixed though).

Port & Chan are a bigger problem since users will forever have to
double-check which is which or will have to remember it.

Why the cognitive load? Channel::new_pipe() returning (Source, Sink) is a
usability win we get for free.

I know I don't have to convince anyone here just how critical good naming
is.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/57ab5055/attachment-0001.html>

From bascule at gmail.com  Thu Jan 23 19:17:50 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 23 Jan 2014 19:17:50 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <8732788473086921764@gmail297201516>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
Message-ID: <CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>

On Thu, Jan 23, 2014 at 7:16 PM, Strahinja Markovic <val at markovic.io> wrote:

> Why the cognitive load? Channel::new_pipe() returning (Source, Sink) is a
> usability win we get for free.
>
> I know I don't have to convince anyone here just how critical good naming
> is.
>

I have a crazy idea...

Channel::open()

https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/3f8fc121/attachment.html>

From val at markovic.io  Thu Jan 23 19:20:27 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 24 Jan 2014 03:20:27 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
Message-ID: <-1520576067409297228@gmail297201516>

On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri <bascule at gmail.com> wrote:

> I have a crazy idea...
>
> Channel::open()
>

That's a better name for the function, agreed.


>
>
> https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/c7ff9898/attachment.html>

From ben.striegel at gmail.com  Thu Jan 23 19:29:24 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 23 Jan 2014 22:29:24 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <-1520576067409297228@gmail297201516>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
Message-ID: <CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>

This all seems a bit silly. A channel *is*, conceptually, a tuple of a
sender and a receiver. If I call Chan::new(), that's what I expect to get.
And Chan::open() doesn't map to anything that's as intuitive.

Is naming really all that's left to argue about? How does everyone feel
about the semantics of the proposal?


On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic <val at markovic.io>wrote:

>
> On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
>> I have a crazy idea...
>>
>> Channel::open()
>>
>
> That's a better name for the function, agreed.
>
>
>>
>>
>> https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>>
>> --
>> Tony Arcieri
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/f492234d/attachment.html>

From bascule at gmail.com  Thu Jan 23 19:46:23 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 23 Jan 2014 19:46:23 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
Message-ID: <CAHOTMVJEiF+i7eQF1jmJyo+E5QXxiV17D8ri9Bns_z-z2of9HQ@mail.gmail.com>

On Thu, Jan 23, 2014 at 7:29 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> And Chan::open() doesn't map to anything that's as intuitive.
>

Like File::open? :P

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/8711cc32/attachment.html>

From singingboyo at gmail.com  Thu Jan 23 19:54:33 2014
From: singingboyo at gmail.com (Brandon Sanderson)
Date: Thu, 23 Jan 2014 19:54:33 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
Message-ID: <CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>

I would expect Channel::new() to create a channel object that either lets
me send and receive, or lets me get a source and sink to send and receive
with.  Borrow rules may prevent this, but my point is that Channel::new()
would generally be expected to return a struct, and not a tuple.
On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com> wrote:

> This all seems a bit silly. A channel *is*, conceptually, a tuple of a
> sender and a receiver. If I call Chan::new(), that's what I expect to get.
> And Chan::open() doesn't map to anything that's as intuitive.
>
> Is naming really all that's left to argue about? How does everyone feel
> about the semantics of the proposal?
>
>
> On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic <val at markovic.io>wrote:
>
>>
>> On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri <bascule at gmail.com> wrote:
>>
>>> I have a crazy idea...
>>>
>>> Channel::open()
>>>
>>
>> That's a better name for the function, agreed.
>>
>>
>>>
>>>
>>> https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>>>
>>> --
>>> Tony Arcieri
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/32c5152d/attachment.html>

From jfager at gmail.com  Thu Jan 23 20:00:16 2014
From: jfager at gmail.com (Jason Fager)
Date: Thu, 23 Jan 2014 23:00:16 -0500
Subject: [rust-dev]  RFC: New Rust channel proposal
In-Reply-To: <CAHOTMVJEiF+i7eQF1jmJyo+E5QXxiV17D8ri9Bns_z-z2of9HQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAHOTMVJEiF+i7eQF1jmJyo+E5QXxiV17D8ri9Bns_z-z2of9HQ@mail.gmail.com>
Message-ID: <CAFEbTaXwWzm246etkk8ew0ZzDjfE0WwKLzFBp4yE5Vk7Dz+r1g@mail.gmail.com>

open() feels like the clear winner here.  Channel::new_pipe is annoying
because it's long and because channels and pipes are different things (
http://en.m.wikipedia.org/wiki/Pipe_flow),

And aren't we down to naming? I thought the design sounded mostly settled
from the last conversation, and brson revived the thread specifically
responding to a question about naming.



On Thursday, January 23, 2014, Tony Arcieri <bascule at gmail.com> wrote:

> On Thu, Jan 23, 2014 at 7:29 PM, Benjamin Striegel <ben.striegel at gmail.com
> > wrote:
>
>> And Chan::open() doesn't map to anything that's as intuitive.
>>
>
> Like File::open? :P
>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/9c8b9240/attachment-0001.html>

From jfager at gmail.com  Thu Jan 23 20:07:04 2014
From: jfager at gmail.com (Jason Fager)
Date: Thu, 23 Jan 2014 23:07:04 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAFEbTaXwWzm246etkk8ew0ZzDjfE0WwKLzFBp4yE5Vk7Dz+r1g@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAHOTMVJEiF+i7eQF1jmJyo+E5QXxiV17D8ri9Bns_z-z2of9HQ@mail.gmail.com>
	<CAFEbTaXwWzm246etkk8ew0ZzDjfE0WwKLzFBp4yE5Vk7Dz+r1g@mail.gmail.com>
Message-ID: <CAFEbTaXtjYWN-_8X_hQR84pJu=4Z9FjfaJoeJ=ckjYOWDd4h5Q@mail.gmail.com>

Also, +1 for source and sink, I still get port and channel mixed up.

On Thursday, January 23, 2014, Jason Fager <jfager at gmail.com> wrote:

> open() feels like the clear winner here.  Channel::new_pipe is annoying
> because it's long and because channels and pipes are different things (
> http://en.m.wikipedia.org/wiki/Pipe_flow),
>
> And aren't we down to naming? I thought the design sounded mostly settled
> from the last conversation, and brson revived the thread specifically
> responding to a question about naming.
>
>
>
> On Thursday, January 23, 2014, Tony Arcieri <bascule at gmail.com> wrote:
>
>> On Thu, Jan 23, 2014 at 7:29 PM, Benjamin Striegel <
>> ben.striegel at gmail.com> wrote:
>>
>>> And Chan::open() doesn't map to anything that's as intuitive.
>>>
>>
>> Like File::open? :P
>>
>> --
>> Tony Arcieri
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/f56ffdfe/attachment.html>

From donquestion at rocketmail.com  Thu Jan 23 20:13:56 2014
From: donquestion at rocketmail.com (don)
Date: Fri, 24 Jan 2014 05:13:56 +0100
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>	<52E17C97.6040601@mozilla.com>	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>	<8732788473086921764@gmail297201516>	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>	<-1520576067409297228@gmail297201516>	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
Message-ID: <52E1E884.7030507@rocketmail.com>

Hi, as a not contributing listen-in,

i would like to voice that source and sink share the same initial and 
therefore source and drain might be more useful.

I hope i didn't offend by voicing my opinion,
keep up the good work!

Regards Don


Am 24.01.2014 04:54, schrieb Brandon Sanderson:
> I would expect Channel::new() to create a channel object that either
> lets me send and receive, or lets me get a source and sink to send and
> receive with.  Borrow rules may prevent this, but my point is that
> Channel::new() would generally be expected to return a struct, and not a
> tuple.
>
> On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com
> <mailto:ben.striegel at gmail.com>> wrote:
>
>     This all seems a bit silly. A channel *is*, conceptually, a tuple of
>     a sender and a receiver. If I call Chan::new(), that's what I expect
>     to get. And Chan::open() doesn't map to anything that's as intuitive.
>
>     Is naming really all that's left to argue about? How does everyone
>     feel about the semantics of the proposal?
>
>
>     On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic
>     <val at markovic.io <mailto:val at markovic.io>> wrote:
>
>
>         On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri
>         <bascule at gmail.com <mailto:bascule at gmail.com>> wrote:
>
>             I have a crazy idea...
>
>             Channel::open()
>
>
>         That's a better name for the function, agreed.
>
>
>             https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>
>             --
>             Tony Arcieri
>
>
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From adamson.benjamin at gmail.com  Thu Jan 23 20:32:29 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Thu, 23 Jan 2014 20:32:29 -0800
Subject: [rust-dev] Deriving keyword
Message-ID: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>

Question, what constitutes whether a 'trait' is applicable for
implementation by the #deriving() attribute?

According to the language specification on master:
http://static.rust-lang.org/doc/master/rust.html#deriving

There exists a static list. I found myself interested in the idea of using
the deriving attribute to derive a simple drawable implementation:

https://github.com/JeremyLetang/rust-sfml/blob/master/src/rsfml/traits/drawable.rs

but then looked up the attribute in the rust manual, and noticed that there
is a static list of what I will call 'traits that support the deriving
attribute'. Why the restriction? Is there some prior reading on this? Is
there any plan on letting libraries define more types that can be
'derivable'?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/23f89748/attachment.html>

From sfackler at gmail.com  Thu Jan 23 20:37:23 2014
From: sfackler at gmail.com (Steven Fackler)
Date: Thu, 23 Jan 2014 20:37:23 -0800
Subject: [rust-dev] Deriving keyword
In-Reply-To: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
Message-ID: <CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>

The deriving infrastructure is implemented as a procedural macro (or syntax
extension) that's built into the compiler. Historically, _all_ syntax
extensions had to be built in but that is no longer the case:
https://github.com/mozilla/rust/pull/11151. It's now possible to write
something like #[deriving_Drawable] that will implement Drawable for types
but you can't currently add new traits to #[deriving(..)] to make something
like #[deriving(Clone, Drawable)] work. It would be possible to support
that, but it would make #[deriving(..)] "special" in ways that other syntax
extensions aren't and it's unclear whether or not that's a good idea.

Steven Fackler


On Thu, Jan 23, 2014 at 8:32 PM, benjamin adamson <
adamson.benjamin at gmail.com> wrote:

> Question, what constitutes whether a 'trait' is applicable for
> implementation by the #deriving() attribute?
>
> According to the language specification on master:
> http://static.rust-lang.org/doc/master/rust.html#deriving
>
> There exists a static list. I found myself interested in the idea of using
> the deriving attribute to derive a simple drawable implementation:
>
>
> https://github.com/JeremyLetang/rust-sfml/blob/master/src/rsfml/traits/drawable.rs
>
> but then looked up the attribute in the rust manual, and noticed that
> there is a static list of what I will call 'traits that support the
> deriving attribute'. Why the restriction? Is there some prior reading on
> this? Is there any plan on letting libraries define more types that can be
> 'derivable'?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/e0bd8e0b/attachment.html>

From dbau.pp at gmail.com  Thu Jan 23 20:38:58 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 24 Jan 2014 15:38:58 +1100
Subject: [rust-dev] Deriving keyword
In-Reply-To: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
Message-ID: <52E1EE62.4040803@gmail.com>

On 24/01/14 15:32, benjamin adamson wrote:
> Question, what constitutes whether a 'trait' is applicable for 
> implementation by the #deriving() attribute?
>
> According to the language specification on master:
> http://static.rust-lang.org/doc/master/rust.html#deriving
>
> There exists a static list. I found myself interested in the idea of 
> using the deriving attribute to derive a simple drawable implementation:
>
> https://github.com/JeremyLetang/rust-sfml/blob/master/src/rsfml/traits/drawable.rs
>
> but then looked up the attribute in the rust manual, and noticed that 
> there is a static list of what I will call 'traits that support the 
> deriving attribute'. Why the restriction? Is there some prior reading 
> on this? Is there any plan on letting libraries define more types that 
> can be 'derivable'?
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

There's a static list because they're currently hard-coded into the 
compiler.

With external syntax extensions, it's now possible to define something 
like `#[deriving_Drawable]`, and, iirc, I left the core deriving 
infrastructure public in syntax::ext::deriving::generic, so you can get 
most of the work done for you that way.


There are various things to be worked out for adding traits directly to 
#[deriving(Foo)], including (but not limited to) how namespacing works 
(e.g. if two libraries both define a trait with the same name and 
provide #[deriving] implementations for it), and whether we want it to 
be a priviledged syntax extension where users can directly add to its 
map between traits and deriving implementation.


Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/6c695ef8/attachment-0001.html>

From damienradtke at gmail.com  Thu Jan 23 20:39:16 2014
From: damienradtke at gmail.com (Damien Radtke)
Date: Thu, 23 Jan 2014 22:39:16 -0600
Subject: [rust-dev] Modules and visibility
In-Reply-To: <01a401cf1892$c67ff480$537fdd80$@googlemail.com>
References: <01a401cf1892$c67ff480$537fdd80$@googlemail.com>
Message-ID: <CAH0VdcZtd+0ys9bO1JoS-6b5U8KYETWwRDtZYWE3kb3a0ORgHQ@mail.gmail.com>

I will say that I actually really like Go's approach to modules. It uses a
folder -> module mapping instead, so a module can consist of any number of
source files provided they all live in the same directory. If you prefer
your modules to be one big source file each, then that's easily done, but
those who want to break a module up into several files can do so easily.

As a counterargument, doesn't the ability to re-export modules effectively
give you what you want? It would still be a file -> module mapping, but as
far as the user is concerned, they just import one path that gives them
everything, giving you the ability to create a module out of sub-modules
and therefore keep file size small. I know that Haskell uses this approach.


On Thu, Jan 23, 2014 at 5:28 PM, Matthias Einwag <
matthias.einwag at googlemail.com> wrote:

> Hi,
>
>
>
> with similar engineering reasons I can argue the same way that splitting
> into multiple makes sense:
>
> 1.       When you name the file like our object you can use jump to file
> as a replacement for a Jump to Definition in more complex IDEs.
>
> 2.       When you layout your folders like the module structure is and
> the files therin like the types it is quite easy to find the actual file
> that defines something.
>
> 3.       When you have multiple  types in your module you can use
> multiple windows in your editor to work on both in parallel. This is not
> necessarily supported if you want two views  into the same file at
> different positions.
>
>
>
> Propably it?s also a matter of taste. Some people like big source files.
> Others (like me) don?t like them.
>
> In several projects or even languages (Java) it?s convention to break
> everything down in small parts.
>
> It shouldn?t be too hard to satisfy everyone here I think . This doesn?t
> ask for really big and incompatible changes to the module system. Only for
> the option to get rid of the file -> module condition.
>
>
>
> PS: Sorry that we now have 2 discussions. One on Github and this one. I
> sent it a little bit earlier before seeing the other one. However my intent
> is really more the file and privacy thing than discussing about the whole
> mod xyz and use:: functionality.
>
>
>
> Best regards
>
> Matthias
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/ff881fc3/attachment.html>

From ben.striegel at gmail.com  Thu Jan 23 20:55:39 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 23 Jan 2014 23:55:39 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E1E884.7030507@rocketmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E1E884.7030507@rocketmail.com>
Message-ID: <CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>

If we're going to quibble over names we might as well call the types Sender
and Receiver.

Really though, EVERYONE is fine with the proposed semantics from the
original thread? Really? Speak up if you have anything valuable to add that
isn't bikeshedding! :)


On Thu, Jan 23, 2014 at 11:13 PM, don <donquestion at rocketmail.com> wrote:

> Hi, as a not contributing listen-in,
>
> i would like to voice that source and sink share the same initial and
> therefore source and drain might be more useful.
>
> I hope i didn't offend by voicing my opinion,
> keep up the good work!
>
> Regards Don
>
>
> Am 24.01.2014 04:54, schrieb Brandon Sanderson:
>
>> I would expect Channel::new() to create a channel object that either
>> lets me send and receive, or lets me get a source and sink to send and
>> receive with.  Borrow rules may prevent this, but my point is that
>> Channel::new() would generally be expected to return a struct, and not a
>> tuple.
>>
>> On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com
>> <mailto:ben.striegel at gmail.com>> wrote:
>>
>>     This all seems a bit silly. A channel *is*, conceptually, a tuple of
>>     a sender and a receiver. If I call Chan::new(), that's what I expect
>>     to get. And Chan::open() doesn't map to anything that's as intuitive.
>>
>>     Is naming really all that's left to argue about? How does everyone
>>     feel about the semantics of the proposal?
>>
>>
>>     On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic
>>     <val at markovic.io <mailto:val at markovic.io>> wrote:
>>
>>
>>         On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri
>>         <bascule at gmail.com <mailto:bascule at gmail.com>> wrote:
>>
>>             I have a crazy idea...
>>
>>             Channel::open()
>>
>>
>>         That's a better name for the function, agreed.
>>
>>
>>             https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/
>> AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>>
>>             --
>>             Tony Arcieri
>>
>>
>>         _______________________________________________
>>         Rust-dev mailing list
>>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>
>>         https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/4d58f274/attachment.html>

From bascule at gmail.com  Thu Jan 23 20:57:05 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 23 Jan 2014 20:57:05 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E1E884.7030507@rocketmail.com>
	<CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
Message-ID: <CAHOTMVJ1hB0kzDDQuBho_MrONEGRck3MLWMNS98OEXy3ass4hA@mail.gmail.com>

On Thu, Jan 23, 2014 at 8:55 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> If we're going to quibble over names we might as well call the types
> Sender and Receiver.
>

+1 on that


> Really though, EVERYONE is fine with the proposed semantics from the
> original thread? Really? Speak up if you have anything valuable to add that
> isn't bikeshedding! :)
>

As probably the primary instigator of this change, I'd just like to say
you've done a great job resolving my original complaints, thanks ;)

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/45873818/attachment.html>

From pcwalton at mozilla.com  Thu Jan 23 20:57:40 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 23 Jan 2014 20:57:40 -0800
Subject: [rust-dev] Modules and visibility
In-Reply-To: <CAH0VdcZtd+0ys9bO1JoS-6b5U8KYETWwRDtZYWE3kb3a0ORgHQ@mail.gmail.com>
References: <01a401cf1892$c67ff480$537fdd80$@googlemail.com>
	<CAH0VdcZtd+0ys9bO1JoS-6b5U8KYETWwRDtZYWE3kb3a0ORgHQ@mail.gmail.com>
Message-ID: <52E1F2C4.3040809@mozilla.com>

On 1/23/14 8:39 PM, Damien Radtke wrote:
> I will say that I actually really like Go's approach to modules. It uses
> a folder -> module mapping instead, so a module can consist of any
> number of source files provided they all live in the same directory. If
> you prefer your modules to be one big source file each, then that's
> easily done, but those who want to break a module up into several files
> can do so easily.

My issue with Go's approach is that you lose the ability to see where an 
identifier came from by simply searching through the buffer you have 
open; you have to grep in the current directory.

Patrick


From bascule at gmail.com  Thu Jan 23 21:01:04 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 23 Jan 2014 21:01:04 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAHOTMVJ1hB0kzDDQuBho_MrONEGRck3MLWMNS98OEXy3ass4hA@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E1E884.7030507@rocketmail.com>
	<CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
	<CAHOTMVJ1hB0kzDDQuBho_MrONEGRck3MLWMNS98OEXy3ass4hA@mail.gmail.com>
Message-ID: <CAHOTMVK63Rzg6WwA=z=rZHc16DS_TDiv+_zu9ZQMW8+9G7c6KA@mail.gmail.com>

My vote, FWIW

let (sender, receiver) = Chan::open();

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/3036ad26/attachment-0001.html>

From banderson at mozilla.com  Thu Jan 23 21:35:32 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 23 Jan 2014 21:35:32 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>	<52E17C97.6040601@mozilla.com>	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>	<8732788473086921764@gmail297201516>	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>	<-1520576067409297228@gmail297201516>	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>	<52E1E884.7030507@rocketmail.com>
	<CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
Message-ID: <52E1FBA4.1000308@mozilla.com>

I've opened an issue on the naming problem 
https://github.com/mozilla/rust/issues/11765

On 01/23/2014 08:55 PM, Benjamin Striegel wrote:
> If we're going to quibble over names we might as well call the types 
> Sender and Receiver.
>
> Really though, EVERYONE is fine with the proposed semantics from the 
> original thread? Really? Speak up if you have anything valuable to add 
> that isn't bikeshedding! :)
>
>
> On Thu, Jan 23, 2014 at 11:13 PM, don <donquestion at rocketmail.com 
> <mailto:donquestion at rocketmail.com>> wrote:
>
>     Hi, as a not contributing listen-in,
>
>     i would like to voice that source and sink share the same initial
>     and therefore source and drain might be more useful.
>
>     I hope i didn't offend by voicing my opinion,
>     keep up the good work!
>
>     Regards Don
>
>
>     Am 24.01.2014 04:54, schrieb Brandon Sanderson:
>
>         I would expect Channel::new() to create a channel object that
>         either
>         lets me send and receive, or lets me get a source and sink to
>         send and
>         receive with.  Borrow rules may prevent this, but my point is that
>         Channel::new() would generally be expected to return a struct,
>         and not a
>         tuple.
>
>         On Jan 23, 2014 7:29 PM, "Benjamin Striegel"
>         <ben.striegel at gmail.com <mailto:ben.striegel at gmail.com>
>         <mailto:ben.striegel at gmail.com
>         <mailto:ben.striegel at gmail.com>>> wrote:
>
>             This all seems a bit silly. A channel *is*, conceptually,
>         a tuple of
>             a sender and a receiver. If I call Chan::new(), that's
>         what I expect
>             to get. And Chan::open() doesn't map to anything that's as
>         intuitive.
>
>             Is naming really all that's left to argue about? How does
>         everyone
>             feel about the semantics of the proposal?
>
>
>             On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic
>             <val at markovic.io <mailto:val at markovic.io>
>         <mailto:val at markovic.io <mailto:val at markovic.io>>> wrote:
>
>
>                 On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri
>                 <bascule at gmail.com <mailto:bascule at gmail.com>
>         <mailto:bascule at gmail.com <mailto:bascule at gmail.com>>> wrote:
>
>                     I have a crazy idea...
>
>                     Channel::open()
>
>
>                 That's a better name for the function, agreed.
>
>
>         https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>
>                     --
>                     Tony Arcieri
>
>
>                 _______________________________________________
>                 Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         <mailto:Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>>
>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>             _______________________________________________
>             Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         <mailto:Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>>
>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140123/a83c0e18/attachment.html>

From leebraid at gmail.com  Fri Jan 24 00:28:07 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 08:28:07 +0000
Subject: [rust-dev] Deriving keyword
In-Reply-To: <CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
	<CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
Message-ID: <52E22417.8050207@gmail.com>

On 24/01/14 04:37, Steven Fackler wrote:
> The deriving infrastructure is implemented as a procedural macro (or 
> syntax extension) that's built into the compiler. Historically, _all_ 
> syntax extensions had to be built in but that is no longer the case: 
> https://github.com/mozilla/rust/pull/11151. It's now possible to write 
> something like #[deriving_Drawable] that will implement Drawable for 
> types but you can't currently add new traits to #[deriving(..)] to 
> make something like #[deriving(Clone, Drawable)] work. It would be 
> possible to support that, but it would make #[deriving(..)] "special" 
> in ways that other syntax extensions aren't and it's unclear whether 
> or not that's a good idea.

What exactly is the point of this #[...] syntax, anyway?  I'm sure 
there's a reason, but I *currently* don't see how #[deriving(...)] is 
better than simply "deriving", like Haskell has.  Is maintaining a low 
keyword count really THAT important, that we have to have ugly #[] 
wrappers around things?  I had thought that #[] represented 
meta-information, like how to compile/link the file, but if deriving is 
in there, it's very much involving the language proper, too.

Also, if it's built into the compiler, that makes it special anyway, in 
my book.  However, the derivation feature provides such great 
functionality, that I'd be very OK with it being a keyword.  At least, 
if it could be extended for other types -- i.e., was made to support 
deriving_Drawable and so forth.

Finally (and this is more curiosity than suggestion, because it could 
make the language too dynamic/magic), I wonder what's involved in 
dropping the "...deriving..." syntax altogether, and automatically 
deriving functionality for types that implement all the necessary 
underlying features?  It seems like that's what's done for types that 
fit POD, for example.

-- 
Lee


From danielmicay at gmail.com  Fri Jan 24 00:31:19 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 24 Jan 2014 03:31:19 -0500
Subject: [rust-dev] Deriving keyword
In-Reply-To: <52E22417.8050207@gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>
	<CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
	<52E22417.8050207@gmail.com>
Message-ID: <CA+DvKQJSjPcaN1CKj7TH3PPNroJ-AUC3ZrVF9xy7r++BDx1Sjg@mail.gmail.com>

On Fri, Jan 24, 2014 at 3:28 AM, Lee Braiden <leebraid at gmail.com> wrote:
>
> Finally (and this is more curiosity than suggestion, because it could make
> the language too dynamic/magic), I wonder what's involved in dropping the
> "...deriving..." syntax altogether, and automatically deriving functionality
> for types that implement all the necessary underlying features?  It seems
> like that's what's done for types that fit POD, for example.

This would be incorrect in many cases. Then you're going to need a
syntax to disable it, and you're *still* going to need the syntax to
derive for non-Pod.

From gaetan at xeberon.net  Fri Jan 24 00:44:36 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 24 Jan 2014 09:44:36 +0100
Subject: [rust-dev] Modules and visibility
In-Reply-To: <52E1F2C4.3040809@mozilla.com>
References: <01a401cf1892$c67ff480$537fdd80$@googlemail.com>
	<CAH0VdcZtd+0ys9bO1JoS-6b5U8KYETWwRDtZYWE3kb3a0ORgHQ@mail.gmail.com>
	<52E1F2C4.3040809@mozilla.com>
Message-ID: <CANK7tAHB5+CS96tKNoVyc6_n7iNd43vQ1jxS6K3GmqqTn2XUXg@mail.gmail.com>

I don't see the point to link the logical structure of the code with the
IDE or editor you use. There is no link between them, or it is a good
practice NOT to do any assumption. If one want to code with
vi/emacs/sublime or eclipse or any other one, the build system and
structure of the code should be agnostic.
For me the current structure of code of rust is totaly acceptable, even
though I would recommend to place unit test in a submodule of the tested
one (ie just splitting the code and its unit test in two files), but that
is just a policy you can enforce in your project (is there a lint for
that?). Same for the "one class per module". Maybe having triggerable
linter can help people choosing there convention.

What really annoy me is the fact that public method/class are not easilly
described in one place. On one hand, I like the headers in C++ where you
have a clear way of seeing which are the class/function your module
provides, with private stuff being pushed aside. To be more accurate, I
like the declaration/definition splitting of function. However the python
or java way is really handful where you just write the code directly. I
don't know which is best, I have the feeling rust is in the middle, but I
sometime don't see clearly in the rust code the list of public methods of a
given class. Maybe there is room for improvement.

For the internal visibility, I really enjoy the python's way of life "you
can access to anything at your own risk", however I finally don't think
it's a good practice. If you end up doing that, your design is wrong...
except for unit test where is it really useful to have direct and easy
access to private member to mock it...

-----
Gaetan



2014/1/24 Patrick Walton <pcwalton at mozilla.com>

> On 1/23/14 8:39 PM, Damien Radtke wrote:
>
>> I will say that I actually really like Go's approach to modules. It uses
>> a folder -> module mapping instead, so a module can consist of any
>> number of source files provided they all live in the same directory. If
>> you prefer your modules to be one big source file each, then that's
>> easily done, but those who want to break a module up into several files
>> can do so easily.
>>
>
> My issue with Go's approach is that you lose the ability to see where an
> identifier came from by simply searching through the buffer you have open;
> you have to grep in the current directory.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/935b9f58/attachment-0001.html>

From leebraid at gmail.com  Fri Jan 24 01:02:24 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 09:02:24 +0000
Subject: [rust-dev] Modules and visibility
In-Reply-To: <CABL+ZB7rmKJTuVO8jCQFh2UBv-_iUgaM75dZLy50Wv3hROoiAA@mail.gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
	<CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
	<CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>
	<CABL+ZB7rmKJTuVO8jCQFh2UBv-_iUgaM75dZLy50Wv3hROoiAA@mail.gmail.com>
Message-ID: <52E22C20.5030508@gmail.com>

On 23/01/14 22:23, Steve Klabnik wrote:
> Ehhh, my phrasing on that one was poor. What I was trying to say is
> that there are a significant number of users of Rust who do not have
> IDEs, and adding anything that would _require_ you to use an IDE with
> Rust is a significant drawback.
>
> If an IDE floats your boat, no complaints from me. As long as I can
> use my vim, I don't care what you use. :)
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Even many serious vim / emacs users have it tweaked to the point where 
it does a lot of IDE-like things, such as completion and project file 
switching / builds / tag search too.  I think the need is to support IDE 
features in a flexible way, that any editor / IDE can interface with as 
suits them.

I think the best solution to that would be some sort of daemon that 
takes a top-level project definition, or a set of files, compiles them, 
monitors for changes, and interactively answers questions about it via 
some simple API:

     // static info support, which becomes interactive, if 
update_edited_overlay() is used
     all_tags(include_metadata) // returns tags, plus optional metadata 
like doc strings and highlighting info
     tags_in_file(f)

     // interactive editing extensions
     update_edited_overlay(f, start_line, start_col, end_line, end_col, 
new_content)
     highlight_info(f, start_line, end_line)
     completions_at(f, line, col)

You could then run this in the background, for big IDEs, or just run it 
ahead of time, extract tags, and write an index / highlighting file, for 
simpler editors.  What's more, it would be a framework that many other 
languages could adopt.


-- 
Lee


From gaetan at xeberon.net  Fri Jan 24 01:16:00 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 24 Jan 2014 10:16:00 +0100
Subject: [rust-dev] Modules and visibility
In-Reply-To: <52E22C20.5030508@gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
	<CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
	<CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>
	<CABL+ZB7rmKJTuVO8jCQFh2UBv-_iUgaM75dZLy50Wv3hROoiAA@mail.gmail.com>
	<52E22C20.5030508@gmail.com>
Message-ID: <CANK7tAG5uObLPrHOJKYXZ2rJT6z+GAKpeDJ1zWCgoKdko2do8w@mail.gmail.com>

I've started to work on better implementation of ctags.

-----
Gaetan



2014/1/24 Lee Braiden <leebraid at gmail.com>

> On 23/01/14 22:23, Steve Klabnik wrote:
>
>> Ehhh, my phrasing on that one was poor. What I was trying to say is
>> that there are a significant number of users of Rust who do not have
>> IDEs, and adding anything that would _require_ you to use an IDE with
>> Rust is a significant drawback.
>>
>> If an IDE floats your boat, no complaints from me. As long as I can
>> use my vim, I don't care what you use. :)
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> Even many serious vim / emacs users have it tweaked to the point where it
> does a lot of IDE-like things, such as completion and project file
> switching / builds / tag search too.  I think the need is to support IDE
> features in a flexible way, that any editor / IDE can interface with as
> suits them.
>
> I think the best solution to that would be some sort of daemon that takes
> a top-level project definition, or a set of files, compiles them, monitors
> for changes, and interactively answers questions about it via some simple
> API:
>
>     // static info support, which becomes interactive, if
> update_edited_overlay() is used
>     all_tags(include_metadata) // returns tags, plus optional metadata
> like doc strings and highlighting info
>     tags_in_file(f)
>
>     // interactive editing extensions
>     update_edited_overlay(f, start_line, start_col, end_line, end_col,
> new_content)
>     highlight_info(f, start_line, end_line)
>     completions_at(f, line, col)
>
> You could then run this in the background, for big IDEs, or just run it
> ahead of time, extract tags, and write an index / highlighting file, for
> simpler editors.  What's more, it would be a framework that many other
> languages could adopt.
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/47fa4da3/attachment.html>

From mneumann at ntecs.de  Fri Jan 24 01:53:27 2014
From: mneumann at ntecs.de (Michael Neumann)
Date: Fri, 24 Jan 2014 10:53:27 +0100
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <8732788473086921764@gmail297201516>
References: <52D4A564.4090602@mozilla.com>	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>	<52E17C97.6040601@mozilla.com>	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
Message-ID: <52E23817.5060406@ntecs.de>


Am 24.01.2014 04:16, schrieb Strahinja Markovic:
> On Thu Jan 23 2014 at 3:59:56 PM, Steve Klabnik 
> <steve at steveklabnik.com <mailto:steve at steveklabnik.com>> wrote:
>
>     I don't think that `new` not returning a `Channel` is a big deal.
>     Conceptually, you are, both ends 'make up' a channel.
>
>
> I agree it's not a big deal, but I still think it's something we might 
> want to change. Why introduce a mental speed bump if we don't have to? 
> Foo::new() returns a Foo, Bar::new() returns a Bar, Quux::new() 
> returns a Quux and a Channel::new() returns a... tuple of two items, 
> neither of which is a Channel (I know the two items together are 
> conceptually a /channel/, but they are not a Channel).
>
> Using new() here seems like a usability loss for no benefit. But 
> again, it's not a huge issue (should still be fixed though).
>
> Port & Chan are a bigger problem since users will forever have to 
> double-check which is which or will have to remember it.
>
> Why the cognitive load? Channel::new_pipe() returning (Source, Sink) 
> is a usability win we get for free.

I am against naming it Source and Sink. It doesn't comply with the verbs 
we use for sending and receiving, at least for me as a
non-native english speaker. While you can get/put something from/to a 
Source/Sink, you usually don't receive or send from a
Source or Sink. The names Port and Channel are ambiguous as well, but at 
least you can receive (e.g. goods) from a port and send
things on a channel.

Regards,

   Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/d602664c/attachment.html>

From dbau.pp at gmail.com  Fri Jan 24 01:54:28 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 24 Jan 2014 20:54:28 +1100
Subject: [rust-dev] Deriving keyword
In-Reply-To: <52E22417.8050207@gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>	<CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
	<52E22417.8050207@gmail.com>
Message-ID: <52E23854.6090806@gmail.com>

On 24/01/14 19:28, Lee Braiden wrote:
> On 24/01/14 04:37, Steven Fackler wrote:
>> The deriving infrastructure is implemented as a procedural macro (or 
>> syntax extension) that's built into the compiler. Historically, _all_ 
>> syntax extensions had to be built in but that is no longer the case: 
>> https://github.com/mozilla/rust/pull/11151. It's now possible to 
>> write something like #[deriving_Drawable] that will implement 
>> Drawable for types but you can't currently add new traits to 
>> #[deriving(..)] to make something like #[deriving(Clone, Drawable)] 
>> work. It would be possible to support that, but it would make 
>> #[deriving(..)] "special" in ways that other syntax extensions aren't 
>> and it's unclear whether or not that's a good idea.
>
> What exactly is the point of this #[...] syntax, anyway?  I'm sure 
> there's a reason, but I *currently* don't see how #[deriving(...)] is 
> better than simply "deriving", like Haskell has.  Is maintaining a low 
> keyword count really THAT important, that we have to have ugly #[] 
> wrappers around things?  I had thought that #[] represented 
> meta-information, like how to compile/link the file, but if deriving 
> is in there, it's very much involving the language proper, too.
>
> Also, if it's built into the compiler, that makes it special anyway, 
> in my book.  However, the derivation feature provides such great 
> functionality, that I'd be very OK with it being a keyword. At least, 
> if it could be extended for other types -- i.e., was made to support 
> deriving_Drawable and so forth.
>
> Finally (and this is more curiosity than suggestion, because it could 
> make the language too dynamic/magic), I wonder what's involved in 
> dropping the "...deriving..." syntax altogether, and automatically 
> deriving functionality for types that implement all the necessary 
> underlying features?  It seems like that's what's done for types that 
> fit POD, for example.
>

The #[] is just the form of attribute attached to an item[1], and these 
attributes are general annotations that can be used by any part of the 
compilation process (and even by external tools), e.g. #[no_mangle] to 
stop a function's symbol being mangled by the compiler, or 
#[allow(unused_variable)] to stop the 'unused_variable' compiler 
warning, and, syntax extensions (aka procedural macros), which is what 
#[deriving] is: it's just an AST based transformation (which 
unfortunately results in some weird error messages), and users can use 
the functionality added by #11151 to implement their own (e.g. one, if 
they were so inclined, could write a #[getters] syntax extension that 
would automatically create getter method for the fields of a struct).

Also, with some effort, you can *now* write custom derivings using the 
same core code as the real #[deriving] does; the only difference is you 
don't get to call it like #[deriving(Drawable)].


There are a few "kinds"[2] that automatically inherit their properties 
(Pod is among them), but, as Daniel says, it would be incorrect to do it 
for all traits automatically.


[1]: The exact syntax of these may/will be changing, see 
https://github.com/mozilla/rust/issues/2569

[2]: http://static.rust-lang.org/doc/master/std/kinds/index.html


Huon

From singingboyo at gmail.com  Fri Jan 24 03:22:28 2014
From: singingboyo at gmail.com (Brandon Sanderson)
Date: Fri, 24 Jan 2014 03:22:28 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E23817.5060406@ntecs.de>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516> <52E23817.5060406@ntecs.de>
Message-ID: <CAK-XjKUxckc=5gWk1=eRCWW69Kc7krsQQ0fLGMrQHCJCfrCPgA@mail.gmail.com>

My biggest gripe with port and channel is that a port can both send and
receive things, and a channel is what this things travel along.  Also, I
believe there is precedent in other languages for source/sink, though that
may be only for pipes, which are unrelated to this discussion.

Regardless, I agree that source/sink is unintuitive. (Do I take things from
the source or put them there as source material for the sink?)  Perhaps
SendPort and ReceivePort (or RecvPort) would be better names?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/3c918a1f/attachment-0001.html>

From leebraid at gmail.com  Fri Jan 24 04:01:53 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 12:01:53 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E23817.5060406@ntecs.de>
References: <52D4A564.4090602@mozilla.com>	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>	<52E17C97.6040601@mozilla.com>	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516> <52E23817.5060406@ntecs.de>
Message-ID: <52E25631.9030406@gmail.com>

I regularly send/receive things to/from channels at work, and it seems 
you can do the same with real-world ports.

I really have no idea what Rust means by a port does, vs. what it means 
by a channel, without reading the details in docs.  I'd assume the port, 
channel ordering reads left-to-right like most english, and so equates 
to send, receive, but that could be a very dangerous assumption.

As you can tell from the above, I haven't gotten into using channels 
yet, or knowing the API in detail, but it's one of the things that 
attracts me to Rust, so I will eventually.  My gut instinct so far, 
based on limited understanding of what you're trying to represent, is 
that the API should probably be broken down into clearly distinguished 
"Channels", "Connections", and "Source"/"Sink" "ends" to those 
connections, even if that requires a channel to provide two pairs of 
sources/sinks for send vs. receive (or just some method which returns 
these things, swapped around, as a hidden implementation detail).


-- 
Lee

On 24/01/14 09:53, Michael Neumann wrote:
>
> Am 24.01.2014 04:16, schrieb Strahinja Markovic:
>> On Thu Jan 23 2014 at 3:59:56 PM, Steve Klabnik 
>> <steve at steveklabnik.com <mailto:steve at steveklabnik.com>> wrote:
>>
>>     I don't think that `new` not returning a `Channel` is a big deal.
>>     Conceptually, you are, both ends 'make up' a channel.
>>
>>
>> I agree it's not a big deal, but I still think it's something we 
>> might want to change. Why introduce a mental speed bump if we don't 
>> have to? Foo::new() returns a Foo, Bar::new() returns a Bar, 
>> Quux::new() returns a Quux and a Channel::new() returns a... tuple of 
>> two items, neither of which is a Channel (I know the two items 
>> together are conceptually a /channel/, but they are not a Channel).
>>
>> Using new() here seems like a usability loss for no benefit. But 
>> again, it's not a huge issue (should still be fixed though).
>>
>> Port & Chan are a bigger problem since users will forever have to 
>> double-check which is which or will have to remember it.
>>
>> Why the cognitive load? Channel::new_pipe() returning (Source, Sink) 
>> is a usability win we get for free.
>
> I am against naming it Source and Sink. It doesn't comply with the 
> verbs we use for sending and receiving, at least for me as a
> non-native english speaker. While you can get/put something from/to a 
> Source/Sink, you usually don't receive or send from a
> Source or Sink. The names Port and Channel are ambiguous as well, but 
> at least you can receive (e.g. goods) from a port and send
> things on a channel.
>
> Regards,
>
>   Michael
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/6bf40d8e/attachment.html>

From leebraid at gmail.com  Fri Jan 24 04:23:03 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 12:23:03 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
Message-ID: <52E25B27.2070403@gmail.com>

On 24/01/14 03:54, Brandon Sanderson wrote:
>
> I would expect Channel::new() to create a channel object that either 
> lets me send and receive, or lets me get a source and sink to send and 
> receive with.  Borrow rules may prevent this, but my point is that 
> Channel::new() would generally be expected to return a struct, and not 
> a tuple.
>

Yes.  I think either:

     * Channel should be a struct, created by Channel::new(), with 
sender and receiver instances as fields (by whatever name) -- 
essentially, the tuple should become a struct, with better naming of 
port and chan
     * Channel should have a  ChannelTrait implemention, with send() and 
receive(), and should be created by Channel::new()

But from what Benjamin says below, it seems like the latter isn't necessary.

> On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com 
> <mailto:ben.striegel at gmail.com>> wrote:
>
>     This all seems a bit silly. A channel *is*, conceptually, a tuple
>     of a sender and a receiver. If I call Chan::new(), that's what I
>     expect to get. And Chan::open() doesn't map to anything that's as
>     intuitive.
>

-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/fb353224/attachment.html>

From leebraid at gmail.com  Fri Jan 24 04:24:08 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 12:24:08 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <8732788473086921764@gmail297201516>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
Message-ID: <52E25B68.20700@gmail.com>

On 24/01/14 03:16, Strahinja Markovic wrote:
> On Thu Jan 23 2014 at 3:59:56 PM, Steve Klabnik 
> <steve at steveklabnik.com <mailto:steve at steveklabnik.com>> wrote:
>
>     I don't think that `new` not returning a `Channel` is a big deal.
>     Conceptually, you are, both ends 'make up' a channel.
>
>
> I agree it's not a big deal, but I still think it's something we might 
> want to change. Why introduce a mental speed bump if we don't have to?

Agreed.  I think it's VERY weird, even if it's could conceivably "work 
OK" for everyone.

> Why the cognitive load? Channel::new_pipe() returning (Source, Sink) 
> is a usability win we get for free.
>
> I know I don't have to convince anyone here just how critical good 
> naming is.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/3eca74ad/attachment.html>

From ben.striegel at gmail.com  Fri Jan 24 05:34:03 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 24 Jan 2014 08:34:03 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E25B27.2070403@gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E25B27.2070403@gmail.com>
Message-ID: <CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>

> Channel should be a struct

This is feasible:

    let Chan { send, recv } = Chan::new();

...but it seems needlessly verbose, given that literally 100% of the time
you will want to separate the sending end from the receiving end. It makes
no conceptual sense to have a `Chan` as a discrete entity, when it's
effectively just an abstraction for two entangled endpoints.

Anyway, if we've devolving into bikeshedding then it might be time to
abandon this thread. Usability isn't something that can be crowdsourced.


On Fri, Jan 24, 2014 at 7:23 AM, Lee Braiden <leebraid at gmail.com> wrote:

>  On 24/01/14 03:54, Brandon Sanderson wrote:
>
> I would expect Channel::new() to create a channel object that either lets
> me send and receive, or lets me get a source and sink to send and receive
> with.  Borrow rules may prevent this, but my point is that Channel::new()
> would generally be expected to return a struct, and not a tuple.
>
>
> Yes.  I think either:
>
>     * Channel should be a struct, created by Channel::new(), with sender
> and receiver instances as fields (by whatever name) -- essentially, the
> tuple should become a struct, with better naming of port and chan
>     * Channel should have a  ChannelTrait implemention, with send() and
> receive(), and should be created by Channel::new()
>
> But from what Benjamin says below, it seems like the latter isn't
> necessary.
>
>
>  On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com>
> wrote:
>
>>  This all seems a bit silly. A channel *is*, conceptually, a tuple of a
>> sender and a receiver. If I call Chan::new(), that's what I expect to get.
>> And Chan::open() doesn't map to anything that's as intuitive.
>>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/38c0e37d/attachment-0001.html>

From jfager at gmail.com  Fri Jan 24 05:44:16 2014
From: jfager at gmail.com (Jason Fager)
Date: Fri, 24 Jan 2014 08:44:16 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E1E884.7030507@rocketmail.com>
	<CAAvrL-kNiK9NeWVRtTw=JvxjdKJp5Ne0Uyoc+5CdsDabPRUgpg@mail.gmail.com>
Message-ID: <CAFEbTaXKgb0V372C2mXBRYZJMYB4cRJsGDsLG4PCM84nQ60+7Q@mail.gmail.com>

Consider my +1 for Source/Sink more as a -1 for Port/Chan.  I don't really
care what it ends up as so long as I don't have to look up which is which
every time.  Sender/Receiver wfm.

As far as concerns about the proposal itself, my only remaining issue is
that Chan isn't a trait and so the actual chan type you use can't be
arbitrarily swapped without changes throughout a code base.  The morphing
channel partially addresses this, but doesn't really accommodate things
like wrapped channels or switching to the unbounded or bounded
alternatives.  I understand there are drawbacks to making it a trait,
though, so this isn't a counter proposal, just a lament.



On Thursday, January 23, 2014, Benjamin Striegel <ben.striegel at gmail.com>
wrote:

> If we're going to quibble over names we might as well call the types
> Sender and Receiver.
>
> Really though, EVERYONE is fine with the proposed semantics from the
> original thread? Really? Speak up if you have anything valuable to add that
> isn't bikeshedding! :)
>
>
> On Thu, Jan 23, 2014 at 11:13 PM, don <donquestion at rocketmail.com<javascript:_e({}, 'cvml', 'donquestion at rocketmail.com');>
> > wrote:
>
>> Hi, as a not contributing listen-in,
>>
>> i would like to voice that source and sink share the same initial and
>> therefore source and drain might be more useful.
>>
>> I hope i didn't offend by voicing my opinion,
>> keep up the good work!
>>
>> Regards Don
>>
>>
>> Am 24.01.2014 04:54, schrieb Brandon Sanderson:
>>
>>> I would expect Channel::new() to create a channel object that either
>>> lets me send and receive, or lets me get a source and sink to send and
>>> receive with.  Borrow rules may prevent this, but my point is that
>>> Channel::new() would generally be expected to return a struct, and not a
>>> tuple.
>>>
>>> On Jan 23, 2014 7:29 PM, "Benjamin Striegel" <ben.striegel at gmail.com<javascript:_e({}, 'cvml', 'ben.striegel at gmail.com');>
>>> <mailto:ben.striegel at gmail.com <javascript:_e({}, 'cvml',
>>> 'ben.striegel at gmail.com');>>> wrote:
>>>
>>>     This all seems a bit silly. A channel *is*, conceptually, a tuple of
>>>     a sender and a receiver. If I call Chan::new(), that's what I expect
>>>     to get. And Chan::open() doesn't map to anything that's as intuitive.
>>>
>>>     Is naming really all that's left to argue about? How does everyone
>>>     feel about the semantics of the proposal?
>>>
>>>
>>>     On Thu, Jan 23, 2014 at 10:20 PM, Strahinja Markovic
>>>     <val at markovic.io <javascript:_e({}, 'cvml', 'val at markovic.io');><mailto:
>>> val at markovic.io <javascript:_e({}, 'cvml', 'val at markovic.io');>>> wrote:
>>>
>>>
>>>         On Thu Jan 23 2014 at 7:18:11 PM, Tony Arcieri
>>>         <bascule at gmail.com <javascript:_e({}, 'cvml',
>>> 'bascule at gmail.com');> <mailto:bascule at gmail.com <javascript:_e({},
>>> 'cvml', 'bascule at gmail.com');>>> wrote:
>>>
>>>             I have a crazy idea...
>>>
>>>             Channel::open()
>>>
>>>
>>>         That's a better name for the function, agreed.
>>>
>>>
>>>             https://lh3.ggpht.com/-WpuYGqCEHDg/UBznzaqReKI/
>>> AAAAAAAAB_0/0Vc8_mnnhqw/s1600/mind-blown.gif
>>>
>>>             --
>>>             Tony Arcieri
>>>
>>>
>>>         _______________________________________________
>>>         Rust-dev mailing list
>>>         Rust-dev at mozilla.org <javascript:_e({}, 'cvml',
>>> 'Rust-dev at mozilla.org');> <mailto:Rust-dev at mozilla.org<javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>>> >
>>>
>>>         https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>>     _______________________________________________
>>>     Rust-dev mailing list
>>>     Rust-dev at mozilla.org <javascript:_e({}, 'cvml',
>>> 'Rust-dev at mozilla.org');> <mailto:Rust-dev at mozilla.org<javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>>> >
>>>
>>>     https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml',
>>> 'Rust-dev at mozilla.org');>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>  _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/7ddf3ef7/attachment.html>

From leebraid at gmail.com  Fri Jan 24 06:45:30 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 14:45:30 +0000
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E25B27.2070403@gmail.com>
	<CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>
Message-ID: <52E27C8A.6030004@gmail.com>

On 24/01/14 13:34, Benjamin Striegel wrote:
> Anyway, if we've devolving into bikeshedding then it might be time to 
> abandon this thread. Usability isn't something that can be crowdsourced.

Well, what you're essentially saying here (assuming you don't mean to 
disrespect non-core folks by calling them "the crowd") is that 
"usability can't be discussed", but of course it can, IF you bear 
overall principles in mind, rather than devolving into individual 
instances too much.   In this case, the overall usability issues we're 
TRYING to communicate are:

1)    X::new()  should return an X
2)    An "X" should do what it sounds like it does


-- 
Lee


From danielmicay at gmail.com  Fri Jan 24 07:32:53 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 24 Jan 2014 10:32:53 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
Message-ID: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>

The language documentation currently takes a very opinionated view on
concurrency. It focuses on message passing and at times makes the
claim that Rust does not have shared memory between tasks. I don't
think the language should be taking a position like this but rather
providing useful tools to implement a concurrent application as the
developer sees fit.

The library should be offering the `Arc` and `MutexArc` types in
`libstd` along with other useful concurrent data structures. A
concurrent hash table split into shards is a very scalable primitive
and quite trivial to implement. There's no reason to encode keyed
inserts/searches/removals with message passing when it's faster and
easier to do it directly.

In my opinion, the most prominent message passing tool should be a
multiple-consumer/multiple-producer queue without API sacrifices made
at the performance altar. The lack of a single-consumer restriction
means that a split between senders and receivers can be implemented as
a policy, but is no more necessary than a `Stack<T>` wrapper around
vectors.

    /// Return a new `Queue` instance, holding at most `maximum` elements.
    fn new(maximum: uint) -> Queue<T>;

    /// Pop a value from the front of the queue, blocking until the
queue is not empty.
    fn pop(&self) -> T;

    /// Pop a value from the front of the queue, or return `None` if
the queue is empty.
    fn try_pop(&self) -> Option<T>;

    /// Pop a value from the front of the queue, blocking until the
queue is not empty or the
    /// timeout expires.
    fn pop_timeout(&self, reltime: Time) -> Option<T>;

    /// Push a value to the back of the queue, blocking until the
queue is not full.
    fn push(&self, item: T);

    /// Push a value to the back of the queue, or return `Some(item)`
if the queue is full.
    fn try_push(&self, item: T) -> Option<T>;

    /// Push a value to the back of the queue, blocking until the
queue is not full or the timeout
    /// expires. If the timeout expires, return `Some(item)`.
    fn push_timeout(&self, item: T, reltime: Time) -> Option<T>;

The standard library can then expose more restricted variants for the
sake of optimization. A purely wait-free queue with the capacity
allocated up-front is obviously useful. The single consumer
restriction may be useful, but the current implementation does not
present a performance advantage over a less restricted API.

Supporting selection over multiple queues would involve using kqueue
on FreeBSD/OSX and eventfd/epoll on Linux instead of a condition
variable for the not empty condition. For Windows, the regular
condition variables will work fine. This does have a cost, and may not
make sense with the same type.

From ben.striegel at gmail.com  Fri Jan 24 07:51:25 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 24 Jan 2014 10:51:25 -0500
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52E27C8A.6030004@gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E25B27.2070403@gmail.com>
	<CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>
	<52E27C8A.6030004@gmail.com>
Message-ID: <CAAvrL-knMO66=wd86-rDEMtWg+ivD-wmXcvvc7RECksyxi9bcQ@mail.gmail.com>

No disrespect intended. Crowdsourced *development* is one of our great
strengths, because things like adding test cases, implementing features,
optimizing benchmarks, reproducing bugs, etc. are all tasks with objective
criteria. When goals are clear, the collective can divide and conquer. But
design and usability are subjective tasks, not objective ones, and instead
of dividing and conquering we merely multiply and surrender.

No one's saying usability can't be discussed. If there are problems, we
DESPERATELY DESPERATELY NEED to be made aware. Even if it's just "the names
of these types confuse me", that's valuable feedback. But belaboring the
point through this many mailing list posts just makes noise and wastes
energy that the full-time devs (note: I am not a full-time dev) can spend
on more valuable tasks.

The other problem with this discussion is that it's premature. We need to
make sure that the new semantics fulfill our criteria of "safe" and
"efficient" before we can commit to the design. If we find problems with
the design, changes may be made that would completely invalidate any
syntactic consensus achieved here.

> 1) X::new() should return an X

The dilemma with making this a rule is that it makes it impossible to ever
construct a structural type (like a tuple) rather than a nominal type. From
an API perspective, a channel is conceptually a pair of two distinct
endpoints, and a tuple fits well. That's not to say that we *have* to use
::new() here: Chan::new() used to just be a free function, stream(), and
had its API changed merely as a part of the last comm rewrite. It could
easily go back to being a free function.

> 2) An "X" should do what it sounds like it does

Agreed, and this is why I don't like Sink or Drain: when I put things down
the sink or in the drain, I generally don't want to ever get them back :)

As for this second point, beware as well that we have many non-native
speakers in this community: idioms that are natural for native English
speakers may not be for them.


On Fri, Jan 24, 2014 at 9:45 AM, Lee Braiden <leebraid at gmail.com> wrote:

> On 24/01/14 13:34, Benjamin Striegel wrote:
>
>> Anyway, if we've devolving into bikeshedding then it might be time to
>> abandon this thread. Usability isn't something that can be crowdsourced.
>>
>
> Well, what you're essentially saying here (assuming you don't mean to
> disrespect non-core folks by calling them "the crowd") is that "usability
> can't be discussed", but of course it can, IF you bear overall principles
> in mind, rather than devolving into individual instances too much.   In
> this case, the overall usability issues we're TRYING to communicate are:
>
> 1)    X::new()  should return an X
> 2)    An "X" should do what it sounds like it does
>
>
>
> --
> Lee
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/9b446b88/attachment-0001.html>

From pcwalton at mozilla.com  Fri Jan 24 08:36:06 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 24 Jan 2014 08:36:06 -0800
Subject: [rust-dev] Deriving keyword
In-Reply-To: <52E22417.8050207@gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>	<CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
	<52E22417.8050207@gmail.com>
Message-ID: <52E29676.60207@mozilla.com>

On 1/24/14 12:28 AM, Lee Braiden wrote:
> What exactly is the point of this #[...] syntax, anyway?  I'm sure
> there's a reason, but I *currently* don't see how #[deriving(...)] is
> better than simply "deriving", like Haskell has.  Is maintaining a low
> keyword count really THAT important, that we have to have ugly #[]
> wrappers around things?  I had thought that #[] represented
> meta-information, like how to compile/link the file, but if deriving is
> in there, it's very much involving the language proper, too.

`#[]` is also a macro invocation syntax.

> Also, if it's built into the compiler, that makes it special anyway, in
> my book.  However, the derivation feature provides such great
> functionality, that I'd be very OK with it being a keyword.  At least,
> if it could be extended for other types -- i.e., was made to support
> deriving_Drawable and so forth.

The plan is to allow user-defined deriving via the macro system.

Patrick

From matthias.einwag at googlemail.com  Fri Jan 24 10:27:10 2014
From: matthias.einwag at googlemail.com (Matthias Einwag)
Date: Fri, 24 Jan 2014 19:27:10 +0100
Subject: [rust-dev] Modules and visibility
Message-ID: <001401cf1931$e613c160$b23b4420$@googlemail.com>

I also think it makes no sense to align a programming language to what works
best with one specific editor.
Editors are highly controversial things, and vim even more so.

Also if your are actively working on a module you will know most types that
are defined in it anyway, and if not a jump to file where filename ==
typename would in most cases help.

Regarding Damiens counterargument that you can create small modules and
reexport everything I see the 2 following problems:

1. You actively have to reexport everything. Without globs quite a bit of
nonproductive work.
2. It messes up the visibility settings. Let's say I originally wanted to
make a foomodule with two types Foo and Bar in it. I wanted Foo to  be able
to access Bar's private methods. If I put everything in a file that's no
problem. If I put them in several files I get foomodule::foo::Foo and
foomodule::bar::Bar. And these can not call each others private methods.
Maybe you could restructure it to foomodule::foo::bar::Bar or something like
this and one special case would work, but then another one would fail. And
you really don't get the hierarchy you actually wanted to build.

Best regards
Matthias


> Date: Fri, 24 Jan 2014 09:44:36 +0100
> From: Gaetan <gaetan at xeberon.net>
> To: Patrick Walton <pcwalton at mozilla.com>
> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: Re: [rust-dev] Modules and visibility
> Message-ID:
> 	<CANK7tAHB5+CS96tKNoVyc6_n7iNd43vQ1jxS6K3GmqqTn2XUXg@
> mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
> 
> I don't see the point to link the logical structure of the code with the
IDE or
> editor you use. There is no link between them, or it is a good practice
NOT to
> do any assumption. If one want to code with vi/emacs/sublime or eclipse or
> any other one, the build system and structure of the code should be
> agnostic.
> For me the current structure of code of rust is totaly acceptable, even
though
> I would recommend to place unit test in a submodule of the tested one (ie
> just splitting the code and its unit test in two files), but that is just
a policy you
> can enforce in your project (is there a lint for that?). Same for the "one
class
> per module". Maybe having triggerable linter can help people choosing
there
> convention.
> 
> What really annoy me is the fact that public method/class are not easilly
> described in one place. On one hand, I like the headers in C++ where you
> have a clear way of seeing which are the class/function your module
> provides, with private stuff being pushed aside. To be more accurate, I
like
> the declaration/definition splitting of function. However the python or
java
> way is really handful where you just write the code directly. I don't know
> which is best, I have the feeling rust is in the middle, but I sometime
don't
> see clearly in the rust code the list of public methods of a given class.
Maybe
> there is room for improvement.
> 
> For the internal visibility, I really enjoy the python's way of life "you
can
> access to anything at your own risk", however I finally don't think it's a
good
> practice. If you end up doing that, your design is wrong...
> except for unit test where is it really useful to have direct and easy
access to
> private member to mock it...
> 
> -----
> Gaetan




From leebraid at gmail.com  Fri Jan 24 10:36:03 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 24 Jan 2014 18:36:03 +0000
Subject: [rust-dev] Modules and visibility
In-Reply-To: <001401cf1931$e613c160$b23b4420$@googlemail.com>
References: <001401cf1931$e613c160$b23b4420$@googlemail.com>
Message-ID: <52E2B293.9060006@gmail.com>

I think there are two issues here:

     * mental model <> on disk model impedence
     * on disk model <> editor model impedence

For the first, the editor should have some simple, capable interface to 
a rust syntax analyser (i.e., the front end or at something based on its 
libs)

For the second, though, I think there's no get out of jail free card 
just because you build some module locator interface for an IDE: people 
will still want to be able to find the right files quickly, and whether 
they're working in an IDE, in vim, or just feeding args to "cp".

-- 
Lee


On 24/01/14 18:27, Matthias Einwag wrote:
> I also think it makes no sense to align a programming language to what works
> best with one specific editor.
> Editors are highly controversial things, and vim even more so.
>
> Also if your are actively working on a module you will know most types that
> are defined in it anyway, and if not a jump to file where filename ==
> typename would in most cases help.
>
> Regarding Damiens counterargument that you can create small modules and
> reexport everything I see the 2 following problems:
>
> 1. You actively have to reexport everything. Without globs quite a bit of
> nonproductive work.
> 2. It messes up the visibility settings. Let's say I originally wanted to
> make a foomodule with two types Foo and Bar in it. I wanted Foo to  be able
> to access Bar's private methods. If I put everything in a file that's no
> problem. If I put them in several files I get foomodule::foo::Foo and
> foomodule::bar::Bar. And these can not call each others private methods.
> Maybe you could restructure it to foomodule::foo::bar::Bar or something like
> this and one special case would work, but then another one would fail. And
> you really don't get the hierarchy you actually wanted to build.
>
> Best regards
> Matthias
>
>
>> Date: Fri, 24 Jan 2014 09:44:36 +0100
>> From: Gaetan <gaetan at xeberon.net>
>> To: Patrick Walton <pcwalton at mozilla.com>
>> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
>> Subject: Re: [rust-dev] Modules and visibility
>> Message-ID:
>> 	<CANK7tAHB5+CS96tKNoVyc6_n7iNd43vQ1jxS6K3GmqqTn2XUXg@
>> mail.gmail.com>
>> Content-Type: text/plain; charset="iso-8859-1"
>>
>> I don't see the point to link the logical structure of the code with the
> IDE or
>> editor you use. There is no link between them, or it is a good practice
> NOT to
>> do any assumption. If one want to code with vi/emacs/sublime or eclipse or
>> any other one, the build system and structure of the code should be
>> agnostic.
>> For me the current structure of code of rust is totaly acceptable, even
> though
>> I would recommend to place unit test in a submodule of the tested one (ie
>> just splitting the code and its unit test in two files), but that is just
> a policy you
>> can enforce in your project (is there a lint for that?). Same for the "one
> class
>> per module". Maybe having triggerable linter can help people choosing
> there
>> convention.
>>
>> What really annoy me is the fact that public method/class are not easilly
>> described in one place. On one hand, I like the headers in C++ where you
>> have a clear way of seeing which are the class/function your module
>> provides, with private stuff being pushed aside. To be more accurate, I
> like
>> the declaration/definition splitting of function. However the python or
> java
>> way is really handful where you just write the code directly. I don't know
>> which is best, I have the feeling rust is in the middle, but I sometime
> don't
>> see clearly in the rust code the list of public methods of a given class.
> Maybe
>> there is room for improvement.
>>
>> For the internal visibility, I really enjoy the python's way of life "you
> can
>> access to anything at your own risk", however I finally don't think it's a
> good
>> practice. If you end up doing that, your design is wrong...
>> except for unit test where is it really useful to have direct and easy
> access to
>> private member to mock it...
>>
>> -----
>> Gaetan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Fri Jan 24 11:37:36 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 24 Jan 2014 11:37:36 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
Message-ID: <52E2C100.9030400@mozilla.com>

Thanks for your well thought-out considerations about Rust's message 
passing strategy.

On 01/24/2014 07:32 AM, Daniel Micay wrote:
> The language documentation currently takes a very opinionated view on
> concurrency. It focuses on message passing and at times makes the
> claim that Rust does not have shared memory between tasks. I don't
> think the language should be taking a position like this but rather
> providing useful tools to implement a concurrent application as the
> developer sees fit.

Yes, Rust has always promoted message passing as the preferred way to do 
concurrency. Rust also provides useful tools to implement concurrency as 
the developer sees fit. I believe that recommending message passing by 
default is reasonable since it is widely applicable and easy to use. 
Perhaps we can update language in various documentation to not claim 
absolutely that Rust has no shared memory, but it is important to 
express that Rust protects developers from the pitfalls of shared memory.

>
> The library should be offering the `Arc` and `MutexArc` types in
> `libstd` along with other useful concurrent data structures. A
> concurrent hash table split into shards is a very scalable primitive
> and quite trivial to implement. There's no reason to encode keyed
> inserts/searches/removals with message passing when it's faster and
> easier to do it directly.

Possibly, yes. Instead of putting everything in std though I would 
rather foster a culture of using small crates. It is easier to accept 
more experimental code into the standard distribution if they are in 
seperate packages that can be developed independently. A concurrency 
crate would be more attractive to me than putting specialized data 
structures in the standard library.

>
> In my opinion, the most prominent message passing tool should be a
> multiple-consumer/multiple-producer queue without API sacrifices made
> at the performance altar.

I don't know what 'API sacrifices made at the performance altar' means. 
This sort of unspecific, inflammatory criticism is not necessary or 
welcome. Many people (myself included) have put an enormous amount of 
work into discovering how to build abstractions in this new language. It 
is a long, iterative process, there are many tradeoffs, and mistakes are 
occassionally made. Please try to be nice.

> The lack of a single-consumer restriction
> means that a split between senders and receivers can be implemented as
> a policy, but is no more necessary than a `Stack<T>` wrapper around
> vectors.
>
>      /// Return a new `Queue` instance, holding at most `maximum` elements.
>      fn new(maximum: uint) -> Queue<T>;
>
>      /// Pop a value from the front of the queue, blocking until the
> queue is not empty.
>      fn pop(&self) -> T;
>
>      /// Pop a value from the front of the queue, or return `None` if
> the queue is empty.
>      fn try_pop(&self) -> Option<T>;
>
>      /// Pop a value from the front of the queue, blocking until the
> queue is not empty or the
>      /// timeout expires.
>      fn pop_timeout(&self, reltime: Time) -> Option<T>;
>
>      /// Push a value to the back of the queue, blocking until the
> queue is not full.
>      fn push(&self, item: T);
>
>      /// Push a value to the back of the queue, or return `Some(item)`
> if the queue is full.
>      fn try_push(&self, item: T) -> Option<T>;
>
>      /// Push a value to the back of the queue, blocking until the
> queue is not full or the timeout
>      /// expires. If the timeout expires, return `Some(item)`.
>      fn push_timeout(&self, item: T, reltime: Time) -> Option<T>;
>
> The standard library can then expose more restricted variants for the
> sake of optimization. A purely wait-free queue with the capacity
> allocated up-front is obviously useful. The single consumer
> restriction may be useful, but the current implementation does not
> present a performance advantage over a less restricted API.
>
> Supporting selection over multiple queues would involve using kqueue
> on FreeBSD/OSX and eventfd/epoll on Linux instead of a condition
> variable for the not empty condition. For Windows, the regular
> condition variables will work fine. This does have a cost, and may not
> make sense with the same type.


I believe the single-consumer restriction has to do with the complexity 
of implementing 'select' with multiple consumers. Do you have that 
implemented in rust-core?


From glaebhoerl at gmail.com  Fri Jan 24 11:38:04 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Fri, 24 Jan 2014 20:38:04 +0100
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAAvrL-knMO66=wd86-rDEMtWg+ivD-wmXcvvc7RECksyxi9bcQ@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>
	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>
	<52E17C97.6040601@mozilla.com>
	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>
	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>
	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>
	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>
	<8732788473086921764@gmail297201516>
	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>
	<-1520576067409297228@gmail297201516>
	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>
	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>
	<52E25B27.2070403@gmail.com>
	<CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>
	<52E27C8A.6030004@gmail.com>
	<CAAvrL-knMO66=wd86-rDEMtWg+ivD-wmXcvvc7RECksyxi9bcQ@mail.gmail.com>
Message-ID: <CAPoegswcfinENBqrPmQzwBV_3syGswGjvBZ_wfOM5BYxcowEXw@mail.gmail.com>

On Fri, Jan 24, 2014 at 4:51 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> No one's saying usability can't be discussed. If there are problems, we
> DESPERATELY DESPERATELY NEED to be made aware. Even if it's just "the names
> of these types confuse me", that's valuable feedback. But belaboring the
> point through this many mailing list posts just makes noise and wastes
> energy that the full-time devs (note: I am not a full-time dev) can spend
> on more valuable tasks.
>

The stronger claim that seems to be implied here (I'm not sure if you
intended it!) is that the role of "outside people" in discussing usability
issues should be confined to reporting problems. I don't agree with this.
At a minimum, even if the core developers do the deciding, a discussion
like this can provide them with ideas to choose from among or to draw
inspiration from, and gives them an informal survey of the preferences of
people who care enough to comment. Once in a while, a consensus may even
emerge (for example `box`).

When goals are clear, the collective can divide and conquer. But design and
> usability are subjective tasks, not objective ones, and instead of dividing
> and conquering we merely multiply and surrender.
>

The weaker claim is that "usability issues" can't be productively resolved
through a community process, and I'm not sure I agree with this either. Or
rather, I agree that if the only criterium that can be applied is personal
preference, this is true, but that doesn't hold in every case. For example,
words have meanings. In a debate about naming, it's very much possible to
bring arguments from reason concerning which names have meanings that best
align with the semantics of the construct in question. There may not always
be a clear winner (and then it's back to personal preference), but it's
worth looking for one.

(I agree that we have more important problems to solve than this, and that
the time of people who can is better spent building bikesheds than painting
them.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/57a36c00/attachment-0001.html>

From banderson at mozilla.com  Fri Jan 24 11:45:43 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 24 Jan 2014 11:45:43 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <CAPoegswcfinENBqrPmQzwBV_3syGswGjvBZ_wfOM5BYxcowEXw@mail.gmail.com>
References: <52D4A564.4090602@mozilla.com>	<CAH8Jz7ipjgYnL0PLAb2Dp-QbqF61VAe4j+psyro2jAcw1zTD2g@mail.gmail.com>	<52E17C97.6040601@mozilla.com>	<CADecdiKK5WV+8osPODydVCuKmtPd54+0=BMqOHfX=O76tg_shg@mail.gmail.com>	<CAK9U+m0zDu-xfRrNTpZ08tD7ndBZT-5AFj3PypBffvYssSYcrw@mail.gmail.com>	<CAH8Jz7j-Xeak_+VY-fnDF9H2spJ4qBJrsHtd=2WJbUCsNQdgSQ@mail.gmail.com>	<CABL+ZB6_tDfCkPeWC+AoheX9ChqNX64JiDGVBky_5Y-tn9jhfA@mail.gmail.com>	<8732788473086921764@gmail297201516>	<CAHOTMVKSd4sTA-DVLYzjyAa3qJbKGi=YTB-8uLAG+Gs-KMjnPA@mail.gmail.com>	<-1520576067409297228@gmail297201516>	<CAAvrL-=2KVNaoOL5v7obXm4XMsr1Li_mJgQe8PCiatz6HqBUWA@mail.gmail.com>	<CAK-XjKV7XJ4PC9VknXkv9bWkh+OdD9gAvG9LXynG2v2fqYSnqw@mail.gmail.com>	<52E25B27.2070403@gmail.com>	<CAAvrL-kei4yVtR51ne4t-_+sjSjhTomiDkREV8cHyHiCG0enpA@mail.gmail.com>	<52E27C8A.6030004@gmail.com>	<CAAvrL-knMO66=wd86-rDEMtWg+ivD-wmXcvvc7RECksyxi9bcQ@mail.gmail.com>
	<CAPoegswcfinENBqrPmQzwBV_3syGswGjvBZ_wfOM5BYxcowEXw@mail.gmail.com>
Message-ID: <52E2C2E7.3020204@mozilla.com>

On 01/24/2014 11:38 AM, G?bor Lehel wrote:
> On Fri, Jan 24, 2014 at 4:51 PM, Benjamin Striegel 
> <ben.striegel at gmail.com <mailto:ben.striegel at gmail.com>> wrote:
>
>     No one's saying usability can't be discussed. If there are
>     problems, we DESPERATELY DESPERATELY NEED to be made aware. Even
>     if it's just "the names of these types confuse me", that's
>     valuable feedback. But belaboring the point through this many
>     mailing list posts just makes noise and wastes energy that the
>     full-time devs (note: I am not a full-time dev) can spend on more
>     valuable tasks.
>
>
> The stronger claim that seems to be implied here (I'm not sure if you 
> intended it!) is that the role of "outside people" in discussing 
> usability issues should be confined to reporting problems. I don't 
> agree with this. At a minimum, even if the core developers do the 
> deciding, a discussion like this can provide them with ideas to choose 
> from among or to draw inspiration from, and gives them an informal 
> survey of the preferences of people who care enough to comment. Once 
> in a while, a consensus may even emerge (for example `box`).

I regret there's been a misunderstanding here. The feedback in this 
thread, both on syntax and semantics has been productive. Thanks for 
everybody's input.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/2b41b3ef/attachment.html>

From matthias.einwag at googlemail.com  Fri Jan 24 12:03:23 2014
From: matthias.einwag at googlemail.com (Matthias Einwag)
Date: Fri, 24 Jan 2014 21:03:23 +0100
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E2C100.9030400@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
Message-ID: <001201cf193f$577c6d40$067547c0$@googlemail.com>

Hi everyone,

multi-consumer has many faces.
 Should this send a copy to each consumer? If yes than you can probably do
this easier by creating N SPSP channels.

Or thus that mean you send 1 element and the first task that catches it
wins. That's the classical thing for work queues. You put something into a
single work queue which is accessed by multiple threads and the first one
that reads it performs the work.
You don't need a select thing for multiple consumers. You can also wakeup
one or all possible consumers with a condition variable or the other
proposed mechanisms. 
However I doubt that such a channel is useful for the majority of people, if
they don't want to implement their own threading and scheduling stuff.

You need a select/WaitForMultipleObjects/etc. mechanism only when you want
to monitor multiple channels in parallel by a single task.
I already implemented that as one can see here:
https://github.com/mozilla/rust/issues/11165#issuecomment-32798282
I used eventfd there and in the meanwhile also made some benchmarks about
the overhead of eventfd vs. notification with a condition variable. It's
actually not that much.
But the question there is more how you would your APIs and the Task system
to look like.

Best Regards
Matthias 

> > Supporting selection over multiple queues would involve using kqueue
> > on FreeBSD/OSX and eventfd/epoll on Linux instead of a condition
> > variable for the not empty condition. For Windows, the regular
> > condition variables will work fine. This does have a cost, and may not
> > make sense with the same type.
> 
> 
> I believe the single-consumer restriction has to do with the complexity of
> implementing 'select' with multiple consumers. Do you have that
> implemented in rust-core?
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From bascule at gmail.com  Fri Jan 24 12:33:55 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 24 Jan 2014 12:33:55 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
Message-ID: <CAHOTMV+xz00t4CZO=xTXuOGC09enfJ7rDgsF=5RCvorph_dm_w@mail.gmail.com>

On Friday, January 24, 2014, Daniel Micay <danielmicay at gmail.com> wrote:

> The language documentation currently takes a very opinionated view on
> concurrency. It focuses on message passing and at times makes the
> claim that Rust does not have shared memory between tasks. I don't
> think the language should be taking a position like this but rather
> providing useful tools to implement a concurrent application as the
> developer sees fit.


While I agree and I'm a fan of multi-consumer systems like Java
ThreadPoolExecutor and Disruptor, I think as a general pattern (and not
necessarily performance-oriented one), the actor model (which is
many-to-one by design) is probably going to be the most useful to people.

Just my 2c. I see actors as a generalized, higher-level pattern that can be
built atop CSP, and one I would love to see support for (in the form of an
Erlang/OTP-alike for Rust)



-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140124/efa98826/attachment.html>

From comexk at gmail.com  Fri Jan 24 14:11:09 2014
From: comexk at gmail.com (comex)
Date: Fri, 24 Jan 2014 17:11:09 -0500
Subject: [rust-dev] Modules and visibility
In-Reply-To: <52E22C20.5030508@gmail.com>
References: <CALb7EguSQZSZxJEGiuFpe93e+hbk0rLQ8s7vwxwk_m5aA56XBg@mail.gmail.com>
	<52E1667E.8040403@mozilla.com>
	<CAKE6Rfhgguwbth3SuY9fY_QinjWNk3XW1eLnCVYOknxyf2gNQQ@mail.gmail.com>
	<CABL+ZB672=_+K+7e-zG=c9qfYTOapWhO4BSKg_3cLpSEq3hFuA@mail.gmail.com>
	<CABL+ZB7rmKJTuVO8jCQFh2UBv-_iUgaM75dZLy50Wv3hROoiAA@mail.gmail.com>
	<52E22C20.5030508@gmail.com>
Message-ID: <CAPM5UJ0qu+aFUV3CTkc3Ob27w8Uh82KK483jNtphOdw0EbT9Jw@mail.gmail.com>

On Fri, Jan 24, 2014 at 4:02 AM, Lee Braiden <leebraid at gmail.com> wrote:
> I think the best solution to that would be some sort of daemon that takes a
> top-level project definition, or a set of files, compiles them, monitors for
> changes, and interactively answers questions about it via some simple API:

Note that doing this well requires incremental/cached compilation,
which is one of the reasons I think it's incredibly important for
rustc to gain it.

As a vim user, I'm addicted to cscope.  cscope has serious limitations
for anything that's not C, including C++, but it's useful enough for
me to be much better than doing things manually when reading through
code I'm unfamiliar with.  From my limited experience, the one-to-one
mapping between modules and source files makes the non-tooled
experience better in Rust, but tooling would still be very useful.

From niko at alum.mit.edu  Fri Jan 24 21:31:00 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 25 Jan 2014 00:31:00 -0500
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
Message-ID: <20140125053100.GH5744@Mr-Bennet>

This is good to think about, though I think writing `&mut || foo`
feels like a nonstarter to me.

I still feel that `&my` -- meaning, a pointer that gives ownership of
the referent but not the memory where the referent lives -- is the
right approach here. Basically, the type of `|| ...` would be `&my T`
where `T` is some fresh type that implements `Fn<U,R>`.

Now, the consumer of the closure could be any of:

- `fn foo(x: |U| -> R)`: In this case, the type `|U| -> R`
  is equivalent to `&mut Fn<U,R>`. This is an automatic
  object coercion and also an automatic reborrow. That is,
  written out very explicitly, `foo(|u| r)` would be
  equivalen to `foo((&mut *(&my T { ... })) as &mut Fn<U,R>)`,
  where again `T` is the anonymous closure type.

- `fn foo<T:Fn<U,R>>(x: &my T) -> T`: Now `foo` takes ownership of the
  value `T`. Because it's an `&my` pointer, `foo()` can move the
  referent around.

- `fn foo<T:Fn<U,R>>(x: &mut T) -> T`: `foo` does not take ownership
  of the closure, but does avoid virtual dispatch.

This can be extended to "once closures" in a pretty straightforward
way:

- `fn foo(x: once |U| -> R)`
- `fn foo<T:OnceFn<U,R>>(x: &my T)`

As a bonus, `&my` is perfect for the `drop` trait. And (I think)
fairly straightforwad to implement.

(The semantics of `&my`: when an `&my` value is dropped, it would
 cause the referent to be dropped as well)


Niko

On Mon, Dec 30, 2013 at 07:31:45PM -0800, Patrick Walton wrote:
> Yes, it would need to be &mut, you're right.
> 
> I think the underlying type syntax would be something like `Fn<int,&int>` for the unboxed version, and `&mut Fn<int,&int>` for the boxed version. The type syntax with the bars is just syntactic sugar for the latter (and, in trait bound position, for the former).
> 
> It's somewhat unfortunate but I don't see a particularly good alternative if we want boxed and unboxed closures alike to have nice-looking APIs. The alternative, I guess, is to block 1.0 on unboxed closures, convert all our APIs to unboxed closures where possible, and just say that if you want a boxed closure you have to write `&mut |x| x + 1` at each closure construction site...
> 
> Patrick
> 
> "G?bor Lehel" <glaebhoerl at gmail.com> wrote:
> >Wouldn't it have to be `&mut` rather than `&` to fit the semantics of |
> >|,
> >which is affine and can mutate its environment?
> >
> >And wouldn't this lead to divergence between the type- and value
> >syntax,
> >with | | as a type being a boxed closure (`&mut FnMut`), and an unboxed
> >closure as a value? This was one of the nicer points of the recent
> >closure
> >overhaul, and it would be a shame to lose it so soon.
> >
> >
> >On Mon, Dec 30, 2013 at 10:11 PM, Patrick Walton
> ><pcwalton at mozilla.com>wrote:
> >
> >> I've been thinking that to future-proof unboxed closures in the
> >future we
> >> should maybe limit `|x| x+1` lambda syntax to either (a) require `&`
> >in
> >> front or (b) in function position.
> >>
> >> So today you would write:
> >>
> >>     let f = |x| x+1;
> >>
> >> But tomorrow you would write:
> >>
> >>     let f = &|x| x+1;
> >>
> >> But it would always work here:
> >>
> >>     v.map(|&x| x+1);
> >>
> >> The reason is simply that we'd like `|x| x+1` to become an unboxed
> >closure
> >> in the future and it's easier in the language semantics to
> >future-proof for
> >> it this way: we simply special-case the function argument position.
> >>
> >> Alternatively we can do it with assignability: say that `|x| x+1` is
> >an
> >> anonymous type (an error today) that is assignable to the type
> >> `|int|->int`. That might be cleaner than special-casing the function
> >> argument position.
> >>
> >> Patrick
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Sat Jan 25 00:37:25 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 25 Jan 2014 03:37:25 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CAHOTMV+xz00t4CZO=xTXuOGC09enfJ7rDgsF=5RCvorph_dm_w@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<CAHOTMV+xz00t4CZO=xTXuOGC09enfJ7rDgsF=5RCvorph_dm_w@mail.gmail.com>
Message-ID: <CA+DvKQKQSBC4oL6OisAPJfn4Bm-oh=NKiUXm2ChDvTKb2YHEiQ@mail.gmail.com>

On Fri, Jan 24, 2014 at 3:33 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
> While I agree and I'm a fan of multi-consumer systems like Java
> ThreadPoolExecutor and Disruptor, I think as a general pattern (and not
> necessarily performance-oriented one), the actor model (which is many-to-one
> by design) is probably going to be the most useful to people.
>
> Just my 2c. I see actors as a generalized, higher-level pattern that can be
> built atop CSP, and one I would love to see support for (in the form of an
> Erlang/OTP-alike for Rust)

I don't think it's the place of the standard library of a systems
language to choose the concurrency model for users of the language.
It's a performance-oriented language and tasks are in the same weight
class as threads. There will be a need for task pools and task
graphs/trees layered on top for CPU-bound work.

If single consumer queues can offer a performance advantage over ones
without the restriction and are a common pattern, then they're worth
providing. However, I think the flexible implementation should be the
most prominent as you can express a problem naturally rather than
trying to fit it into an opinionated model. A more restricted queue is
then a drop-in replacement if it meets the needs of the code, but is
just an optimization.

From danielmicay at gmail.com  Sat Jan 25 00:50:26 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 25 Jan 2014 03:50:26 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <001201cf193f$577c6d40$067547c0$@googlemail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
Message-ID: <CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>

On Fri, Jan 24, 2014 at 3:03 PM, Matthias Einwag
<matthias.einwag at googlemail.com> wrote:
> Hi everyone,
>
> multi-consumer has many faces.
>  Should this send a copy to each consumer? If yes than you can probably do
> this easier by creating N SPSP channels.
>
> Or thus that mean you send 1 element and the first task that catches it
> wins. That's the classical thing for work queues. You put something into a
> single work queue which is accessed by multiple threads and the first one
> that reads it performs the work.

Yes, I mean a work queue style of channel.

> You don't need a select thing for multiple consumers. You can also wakeup
> one or all possible consumers with a condition variable or the other
> proposed mechanisms.
> However I doubt that such a channel is useful for the majority of people, if
> they don't want to implement their own threading and scheduling stuff.

I didn't state otherwise. It's a side note at the bottom about an
optional feature for that reason.

> You need a select/WaitForMultipleObjects/etc. mechanism only when you want
> to monitor multiple channels in parallel by a single task.
> I already implemented that as one can see here:
> https://github.com/mozilla/rust/issues/11165#issuecomment-32798282
> I used eventfd there and in the meanwhile also made some benchmarks about
> the overhead of eventfd vs. notification with a condition variable. It's
> actually not that much.
> But the question there is more how you would your APIs and the Task system
> to look like.

Rust should be providing the building blocks for a concurrency pattern
determined by the needs of the application. I don't think it should
push a specific design, as there are many ways of doing this with
their own merits.

From jeremycong at gmail.com  Sat Jan 25 02:37:26 2014
From: jeremycong at gmail.com (Jeremy Ong)
Date: Sat, 25 Jan 2014 02:37:26 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
Message-ID: <CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>

> Rust should be providing the building blocks for a concurrency pattern
> determined by the needs of the application. I don't think it should
> push a specific design, as there are many ways of doing this with
> their own merits.

There is a spectrum of flexibility and safety. I'll be honest, if given a
10000 LOC
highly concurrent application to work with, I'd feel much more comfortable
if things were
primarily shared nothing and it was hard to abuse error-prone shared memory
issues
(race conditions, deadlock, etc). Those problems are even possible in CSP
systems
but at least they're easier to identify and eliminate. It could be argued
that if all you
want are primitive build blocks in a systems language, it already exists in
C.

As an aside, I like the distinction in Haskell between threads (parallelism
units mapped
to cores) and par/pseqs (green concurrency units). Rust tasks feel more
like a library
feature to me rather than a systems feature. Perhaps a much more flexible
systems-oriented threaded model is better suited for a primitive more
analogous to
the pthread?


On Sat, Jan 25, 2014 at 12:50 AM, Daniel Micay <danielmicay at gmail.com>wrote:

> On Fri, Jan 24, 2014 at 3:03 PM, Matthias Einwag
> <matthias.einwag at googlemail.com> wrote:
> > Hi everyone,
> >
> > multi-consumer has many faces.
> >  Should this send a copy to each consumer? If yes than you can probably
> do
> > this easier by creating N SPSP channels.
> >
> > Or thus that mean you send 1 element and the first task that catches it
> > wins. That's the classical thing for work queues. You put something into
> a
> > single work queue which is accessed by multiple threads and the first one
> > that reads it performs the work.
>
> Yes, I mean a work queue style of channel.
>
> > You don't need a select thing for multiple consumers. You can also wakeup
> > one or all possible consumers with a condition variable or the other
> > proposed mechanisms.
> > However I doubt that such a channel is useful for the majority of
> people, if
> > they don't want to implement their own threading and scheduling stuff.
>
> I didn't state otherwise. It's a side note at the bottom about an
> optional feature for that reason.
>
> > You need a select/WaitForMultipleObjects/etc. mechanism only when you
> want
> > to monitor multiple channels in parallel by a single task.
> > I already implemented that as one can see here:
> > https://github.com/mozilla/rust/issues/11165#issuecomment-32798282
> > I used eventfd there and in the meanwhile also made some benchmarks about
> > the overhead of eventfd vs. notification with a condition variable. It's
> > actually not that much.
> > But the question there is more how you would your APIs and the Task
> system
> > to look like.
>
> Rust should be providing the building blocks for a concurrency pattern
> determined by the needs of the application. I don't think it should
> push a specific design, as there are many ways of doing this with
> their own merits.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/f1fa6deb/attachment.html>

From danielmicay at gmail.com  Sat Jan 25 02:48:31 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 25 Jan 2014 05:48:31 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
Message-ID: <CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>

On Sat, Jan 25, 2014 at 5:37 AM, Jeremy Ong <jeremycong at gmail.com> wrote:
>> Rust should be providing the building blocks for a concurrency pattern
>> determined by the needs of the application. I don't think it should
>> push a specific design, as there are many ways of doing this with
>> their own merits.
>
> There is a spectrum of flexibility and safety. I'll be honest, if given a
> 10000 LOC
> highly concurrent application to work with, I'd feel much more comfortable
> if things were
> primarily shared nothing and it was hard to abuse error-prone shared memory
> issues
> (race conditions, deadlock, etc). Those problems are even possible in CSP
> systems
> but at least they're easier to identify and eliminate. It could be argued
> that if all you
> want are primitive build blocks in a systems language, it already exists in
> C.

Rust aims to be a systems language displacing C and C++ from their
niche. I don't think it's suitable as one with the standard library,
and it's not replacement for C without a large library ecosystem.

I doubt it's really any easier to avoid race conditions with channels
as opposed to concurrent data structures, whether they are persistent
or mutable. Keep in mind that Rust won't let you have data races
whether or not you are sharing data.

> As an aside, I like the distinction in Haskell between threads (parallelism
> units mapped
> to cores) and par/pseqs (green concurrency units). Rust tasks feel more like
> a library
> feature to me rather than a systems feature. Perhaps a much more flexible
> systems-oriented threaded model is better suited for a primitive more
> analogous to
> the pthread?

Rust doesn't have segmented stacks anymore so it's not going to have
low memory usage synchronous I/O units. Tasks are pretty much just a
lossy abstraction over threads.

From leebraid at gmail.com  Sat Jan 25 03:44:17 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Sat, 25 Jan 2014 11:44:17 +0000
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
Message-ID: <52E3A391.8030704@gmail.com>

On 25/01/14 10:48, Daniel Micay wrote:
> I doubt it's really any easier to avoid race conditions with channels 
> as opposed to concurrent data structures, whether they are persistent 
> or mutable. Keep in mind that Rust won't let you have data races 
> whether or not you are sharing data.

With messages sent on channels, you're encoding a message-based protocol 
(by definition) and something at least similar to state machines for 
each receiver task.  IF the compiler understands that, then you can, 
potentially, add additional, strong, static checking, and much more 
helpful diagnostics.

You ARE sacrificing flexibility by working within that framework, but I 
think the general idea is that most (all?) parallel jobs CAN be well 
modelled by a message-passing protocol, and so the "extra flexibility" 
is really just "ability to screw it up, without a framework".  If you 
think about it, this is really just encapsulation of concurrent data 
behind accessor methods: the alternative is to randomly access shared 
data at any time, which is clearly more risky (not JUST because of data 
races, but also because of protocol violations / state-machine bugs), 
although it can obviously be done equally well by hand, if you're very 
careful, and Rust's data ownership will help, of course.

The main worry I have with message-passing/actor architectures is 
performance, but that's exactly why the language should understand the 
protocols and be able to compile a: send(b) b: receive(b); total += b 
down to just total += b, if/when that's appropriate.


-- 
Lee



From danielmicay at gmail.com  Sat Jan 25 03:56:08 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 25 Jan 2014 06:56:08 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E3A391.8030704@gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
	<52E3A391.8030704@gmail.com>
Message-ID: <CA+DvKQL0V2T429RO0jUtGKOXpsKgvLQ=RWfjDCq4=Fe9zpdxgQ@mail.gmail.com>

On Sat, Jan 25, 2014 at 6:44 AM, Lee Braiden <leebraid at gmail.com> wrote:
> On 25/01/14 10:48, Daniel Micay wrote:
>>
>> I doubt it's really any easier to avoid race conditions with channels as
>> opposed to concurrent data structures, whether they are persistent or
>> mutable. Keep in mind that Rust won't let you have data races whether or not
>> you are sharing data.
>
>
> With messages sent on channels, you're encoding a message-based protocol (by
> definition) and something at least similar to state machines for each
> receiver task.  IF the compiler understands that, then you can, potentially,
> add additional, strong, static checking, and much more helpful diagnostics.

You can say the exact same thing about other concurrent data
structures. It's easy enough to expose a slow concurrent hash table
API via message passing, so it's obviously no different...

> You ARE sacrificing flexibility by working within that framework, but I
> think the general idea is that most (all?) parallel jobs CAN be well
> modelled by a message-passing protocol, and so the "extra flexibility" is
> really just "ability to screw it up, without a framework".  If you think
> about it, this is really just encapsulation of concurrent data behind
> accessor methods: the alternative is to randomly access shared data at any
> time, which is clearly more risky (not JUST because of data races, but also
> because of protocol violations / state-machine bugs), although it can
> obviously be done equally well by hand, if you're very careful, and Rust's
> data ownership will help, of course.

It's no harder to screw up outside of message passing. You're not
offering any valid points against concurrent data structures.

> not JUST because of data races, but also because of protocol violations / state-machine bugs

Again, there is no risk of data races in Rust. There is also no
increased risk in violating a protocol, as you can represent the same
concepts with both and the compiler isn't going to be able to gain
increased information from a queue used for message passing over a
hash table.

You could have support for building protocols that are provably free
of data races, but there's no reason it has to be restricted to a FIFO
queue and it will be unable to prove more when you're using the FIFO
queue in an unrestricted fashion.

> The main worry I have with message-passing/actor architectures is
> performance, but that's exactly why the language should understand the
> protocols and be able to compile a: send(b) b: receive(b); total += b down
> to just total += b, if/when that's appropriate.

These are never going to be language features and compiler magic like
this simply isn't very realistic. It's quite ridiculous to talk about
designing based on a fantasy world with a sufficiently smart compiler
when you're talking about a language like Rust exposing the details of
memory layout, ownership and lifetimes.

From bill_myers at outlook.com  Sat Jan 25 08:58:39 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Sat, 25 Jan 2014 16:58:39 +0000
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
Message-ID: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>

Stack management for green tasks has been based in the past first on segmented stacks and then on standard large stacks.

However, I just realized that there is a third alternative which might well be better than both of those.

The idea is very simple: a green task would run on a large stack like now, but when it is descheduled, a memory buffer of the size of its used stack space is allocated, and its stack data is copied there; when it is rescheduled, the stack data is copied back to the original address.

The copying can be performed either by memcpy (perhaps with a specialized memcpy that assumes alignment and always uses SIMD instruction to copy with no checks), or perhaps by using a compression algorithm designed for maximum speed, such as Snappy or maybe a new ad-hoc design.

This allows to have the best possible memory efficiency and thus the maximum possible number of tasks, even better than segmented stacks due to precise sizing and optional compression, while not adding any overhead to code that does not block, either in terms of code generation complexity or runtime cost.

There is of course an additional runtime cost when blocking, but blocking already often involves both system calls and context switching, and workloads with lots of blocking green tasks are probably I/O bound anyway; furthermore, stack data is probably in the CPU cache, so there shouldn't be much penalty.

The only significant drawback is that two green tasks running from the 
same "large" stack (note that stacks cannot be easily switched, as that 
would invalidate borrowed pointers on the stack to the stack) cannot 
ever run concurrently; however, by making the number of large stacks a 
large enough multiple of the number of CPU cores, the probability of 
reduced parallelism due to this issue can be made as small as desired.

In general, one would use an adaptive approach, where this kind of copying would start to kick in only once the number of green tasks becomes large; when not copying, one would just optionally use madvise(MADV_DONTNEED) to trim unused whole pages of the stack.

Also, if the data to be copied is large (several OS pages), one may use mremap() or similar facilities to move the address space mappings instead of the data itself.

Some unsafe code that assumes that tasks can access each other's stacks will break (probably only the new Mutex implementation), but that can be fixed by putting the data in the task structure instead of the stack.

Overall, this should allow writing something like a parallel network server or web crawler in Rust in a natural blocking style, while being fully confident in its scalability, which is something that is not really possible at the moment.

Once this is in place, the best practices for Rust programs would become:
1. Use native tasks for tasks whose number is bounded at compile time and small
2. Use green tasks for tasks whose number is unbounded or large

One could even automate this to some extent by spawning by default a native task the first C times a given proc() code address is used to start a task (where C = number of CPU cores), and green tasks afterwards.

What do you think? 		 	   		  

From niceguyneil at gmail.com  Sat Jan 25 09:22:53 2014
From: niceguyneil at gmail.com (Neil LoBracco)
Date: Sat, 25 Jan 2014 12:22:53 -0500
Subject: [rust-dev] Understanding extra::{Encodable, Encoder}
Message-ID: <CAEgkx7O3Z75RktSvLfbDq6WVxPW03W4-nF_72TL86VX_qkxm3A@mail.gmail.com>

Hey guys,
I'm getting started with Rust, building out a web services framework.
I have an enum methods can return for their response body:
public enum ResponseBody {
   Empty,
   Text(~str),
   JSON(~serialize::Encodable)
}

As you may know, this doesn't work, because Encodable expects a type
parameter for Encoder. This is needed because Encodable has method:
fn encode<http://static.rust-lang.org/doc/master/extra/serialize/trait.Encodable.html#tymethod.encode>(&self,
s: &mut S);
I can't even say JSON(~serialize::Encodable<json::Encoder>), because
json::Encoder has a lifetime param that comes from its writer!
It seems like this makes it impossible to ever take in a serializable
object, and serialize it however I fancy. Moreover, it seems odd for the
Encodable to know what it's encoded into - all of the logic that goes into
actually turning an object into json/xml/whatever lives in json::Encoder,
etc, so why should the Encodable be coupled with that?
What makes sense to me would be to be able to say:
pub fn stringify(obj : &Encodable) -> ~str {
  let reader = json::Encoder::new(obj);
  reader.read_to_str()
}
Where the Encoder trait implies the Reader trait. If something were
Encodable, that would not be specific to any particular Encoder - it would
be a general statement.

Anyone have thoughts about this? Am I missing any easy way I would be able
to do what I asked above (take in a ~Encodable and encode it to buffer,
without having whoever created the encodable have to know about the writer
that would eventually get used)?
If we want to make changes here, I can certainly help out with that, just
wanted to understand what's going on here and the rationale.
Thanks,
-Neil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/16592b46/attachment.html>

From pcwalton at mozilla.com  Sat Jan 25 09:31:59 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 25 Jan 2014 09:31:59 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>	<52E2C100.9030400@mozilla.com>	<001201cf193f$577c6d40$067547c0$@googlemail.com>	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
Message-ID: <52E3F50F.2080407@mozilla.com>

On 1/25/14 2:48 AM, Daniel Micay wrote:
> Rust aims to be a systems language displacing C and C++ from their
> niche. I don't think it's suitable as one with the standard library,
> and it's not replacement for C without a large library ecosystem.

As Brian said, this sort of inflammatory, unspecific criticism is not 
welcome. Especially when you are advocating making channels *less* 
performant.

Patrick


From pcwalton at mozilla.com  Sat Jan 25 09:39:14 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 25 Jan 2014 09:39:14 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E3F50F.2080407@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>	<52E2C100.9030400@mozilla.com>	<001201cf193f$577c6d40$067547c0$@googlemail.com>	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
	<52E3F50F.2080407@mozilla.com>
Message-ID: <52E3F6C2.9030806@mozilla.com>

On 1/25/14 9:31 AM, Patrick Walton wrote:
> On 1/25/14 2:48 AM, Daniel Micay wrote:
>> Rust aims to be a systems language displacing C and C++ from their
>> niche. I don't think it's suitable as one with the standard library,
>> and it's not replacement for C without a large library ecosystem.
>
> As Brian said, this sort of inflammatory, unspecific criticism is not
> welcome. Especially when you are advocating making channels *less*
> performant.

As an aside, I don't think multi-consumer queues are the right API for 
dividing up work among many workers, because of the massive contention 
on the queue. Work stealing is the proven approach here. I suspect the 
API should look something like this:

https://github.com/mozilla/servo/blob/18a2050a64cd6f320cc59cb490a69b0e895f11d3/src/components/util/workqueue.rs

This just landed in Servo today and after we give it some time to bake 
I'd like to uplift it to libextra.

Patrick


From glaebhoerl at gmail.com  Sat Jan 25 10:07:32 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 25 Jan 2014 19:07:32 +0100
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <20140125053100.GH5744@Mr-Bennet>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
	<20140125053100.GH5744@Mr-Bennet>
Message-ID: <CAPoegszVH_P4Km1h3bCE38HfV-ExGt_c_kbsa1j6qZ55NLmZZw@mail.gmail.com>

I've been thinking about this on and off.


On Sat, Jan 25, 2014 at 6:31 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> This is good to think about, though I think writing `&mut || foo`
> feels like a nonstarter to me.
>

I agree.


>
> I still feel that `&my` -- meaning, a pointer that gives ownership of
> the referent but not the memory where the referent lives -- is the
> right approach here. Basically, the type of `|| ...` would be `&my T`
> where `T` is some fresh type that implements `Fn<U,R>`.
>

I prefer the name `&move`: it's a natural progression on `&mut`, which
confers permission to mut[ate], while `&move` also confers permission to
move. When creating one, I think `&move some_foo` (move out of my_foo) is
also clearer than `&my some_foo`. Plus it feels weird for the stronger one
to have a shorter name.


>
> Now, the consumer of the closure could be any of:
>
> - `fn foo(x: |U| -> R)`: In this case, the type `|U| -> R`
>   is equivalent to `&mut Fn<U,R>`. This is an automatic
>   object coercion and also an automatic reborrow. That is,
>   written out very explicitly, `foo(|u| r)` would be
>   equivalen to `foo((&mut *(&my T { ... })) as &mut Fn<U,R>)`,
>   where again `T` is the anonymous closure type.
>
> - `fn foo<T:Fn<U,R>>(x: &my T) -> T`: Now `foo` takes ownership of the
>   value `T`. Because it's an `&my` pointer, `foo()` can move the
>   referent around.
>
> - `fn foo<T:Fn<U,R>>(x: &mut T) -> T`: `foo` does not take ownership
>   of the closure, but does avoid virtual dispatch.
>

If you wanted to pass an unboxed closure without indirection though, like
`fn foo<T: Fn<U, R>>(x: T)`, then you would have to explicitly dereference
the closure, i.e. `foo(*|u| r)` (which might be OK).


>
> This can be extended to "once closures" in a pretty straightforward
> way:
>
> - `fn foo(x: once |U| -> R)`
> - `fn foo<T:OnceFn<U,R>>(x: &my T)`
>

The plan I had been thinking of is similar in some ways, different in
others, and likely has different advantages and drawbacks.

The basic problem is that there's a zoo of closure types:
http://glaebhoerl.tumblr.com/rust_closure_types (I will be referring to
things from this in the following!)
and it's difficult to have convenient and consistent syntax for all of them
at the same time. There's also several different areas of the language
which we want to all work ergonomically: writing closures, invoking
closures, using higher-order functions, and writing the types of closures.
I'll go through these in turn.

Anonymous closure literals, `|args| foo`: I was thinking these would
represent an unboxed closure. That seems like the most straightforward
thing (and the same as C++). This raises two questions:

 - Which traits does it implement? Having to explicitly annotate it somehow
would be onerous, so I think this should be inferred from the way the body
of the closure uses captured variables. What's not totally clear to me is
how to handle the case where you have an `&move FnOnce`, but only some of
the captured variables are moved out of by the closure body: presumably the
programmer would expect the remainder to remain available afterwards.

 - If a HOF expects a stack closure, would you have to write e.g. `&mut
|args| foo`? Again, this feels onerous. On the other hand, when making a
heap closure, having to write e.g. `~|args| foo` explicitly is actually
desirable. The least bad solution I can think of is that anonymous closures
would auto-borrow to `&`, `&mut`, or `&move`.

Invoking a closure also raises questions: does `foo()` imply using `call()`
from `Fn`, `call_mut()` from `FnMut`, or `call_once()` from `FnOnce`? Once
again the least bad solution I can think of is that there would be a bit of
magic, and it would select the "best" option (the one least restrictive on
the caller) from the ones in scope (so Fn > FnMut > FnOnce).

Finally there's the question of how to write their types. The raw
trait-based syntax, `&mut FnMut<(int, int), int>`, is just awful. The
current approach the language takes is to have syntax sugar for a couple of
types (`&mut FnMut` is `|args| -> foo` and `~FnOnce` is `proc`), but this
leaves a lot of other equally legitimate types out in the cold. And if a
closure literal `|args| foo` denotes an unboxed closure, it would be weird
for the same thing at the type level to mean something different. On the
other hand, there's too many useful types to provide dedicated syntax for
all of them.

Here the least bad option I managed to think of is to introduce a new
syntax for writing generic types: `Foo(A, B) -> C` would be equivalent to
either `Foo<(A, B), C>` or `Foo<C, A, B>` depending on how variadics end up
working. I don't think this would introduce any ambiguities: parentheses in
types denote tuples, and it's not currently legal to follow an identifier
with a tuple type. (Correct me if I'm wrong.) This syntax would be
available both when declaring a generic type and when referring to one. (To
avoid confusion, we might want to require the same syntax be used
consistently for a given type, so that if you declare it with function-like
syntax, you also have to refer to it that way, and vice versa.) Then the
programmer can write decent-looking typedefs for whichever closure types
she will be using frequently. The standard library could provide a few
basic ones:

    // yes, it would also work for traits!
    trait Fn(Args...) -> Ret { ... }
    trait FnMut(Args...) -> Ret { ... }
    trait FnOnce(Args...) -> Ret { ... }

    // so `MutFn(int, int) -> int` is the new `|int, int| -> int`, a slight
downgrade, in exchange for much flexibility elsewhere.
    type MutFn(Args...) -> Ret = &mut FnMut(Args...) -> Ret;
    type OnceFn(Args...) -> Ret = &move FnOnce(Args...) -> Ret;

    // Would this still be important to have next to `OnceFn`? Anyway, it's
cute.
    type Proc(Args...) -> Ret = ~FnOnce(Args...) -> Ret;



>
>
> Niko
>
> On Mon, Dec 30, 2013 at 07:31:45PM -0800, Patrick Walton wrote:
> > Yes, it would need to be &mut, you're right.
> >
> > I think the underlying type syntax would be something like
> `Fn<int,&int>` for the unboxed version, and `&mut Fn<int,&int>` for the
> boxed version. The type syntax with the bars is just syntactic sugar for
> the latter (and, in trait bound position, for the former).
> >
> > It's somewhat unfortunate but I don't see a particularly good
> alternative if we want boxed and unboxed closures alike to have
> nice-looking APIs. The alternative, I guess, is to block 1.0 on unboxed
> closures, convert all our APIs to unboxed closures where possible, and just
> say that if you want a boxed closure you have to write `&mut |x| x + 1` at
> each closure construction site...
> >
> > Patrick
> >
> > "G?bor Lehel" <glaebhoerl at gmail.com> wrote:
> > >Wouldn't it have to be `&mut` rather than `&` to fit the semantics of |
> > >|,
> > >which is affine and can mutate its environment?
> > >
> > >And wouldn't this lead to divergence between the type- and value
> > >syntax,
> > >with | | as a type being a boxed closure (`&mut FnMut`), and an unboxed
> > >closure as a value? This was one of the nicer points of the recent
> > >closure
> > >overhaul, and it would be a shame to lose it so soon.
> > >
> > >
> > >On Mon, Dec 30, 2013 at 10:11 PM, Patrick Walton
> > ><pcwalton at mozilla.com>wrote:
> > >
> > >> I've been thinking that to future-proof unboxed closures in the
> > >future we
> > >> should maybe limit `|x| x+1` lambda syntax to either (a) require `&`
> > >in
> > >> front or (b) in function position.
> > >>
> > >> So today you would write:
> > >>
> > >>     let f = |x| x+1;
> > >>
> > >> But tomorrow you would write:
> > >>
> > >>     let f = &|x| x+1;
> > >>
> > >> But it would always work here:
> > >>
> > >>     v.map(|&x| x+1);
> > >>
> > >> The reason is simply that we'd like `|x| x+1` to become an unboxed
> > >closure
> > >> in the future and it's easier in the language semantics to
> > >future-proof for
> > >> it this way: we simply special-case the function argument position.
> > >>
> > >> Alternatively we can do it with assignability: say that `|x| x+1` is
> > >an
> > >> anonymous type (an error today) that is assignable to the type
> > >> `|int|->int`. That might be cleaner than special-casing the function
> > >> argument position.
> > >>
> > >> Patrick
> > >> _______________________________________________
> > >> Rust-dev mailing list
> > >> Rust-dev at mozilla.org
> > >> https://mail.mozilla.org/listinfo/rust-dev
> > >>
> >
> > --
> > Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/e75a6126/attachment-0001.html>

From thadguidry at gmail.com  Sat Jan 25 10:37:00 2014
From: thadguidry at gmail.com (Thad Guidry)
Date: Sat, 25 Jan 2014 12:37:00 -0600
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
Message-ID: <CAChbWaOR1eOaygfh2KjZf0TTMkjWhyPfje=91T9Hj24+3DOUOg@mail.gmail.com>

>
>
> Also, if the data to be copied is large (several OS pages), one may use
> mremap() or similar facilities to move the address space mappings instead
> of the data itself.
>

I especially like this idea... since my use cases will be large amounts of
data.  (a graph database)

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/4e4f65dc/attachment.html>

From jurily at gmail.com  Sat Jan 25 11:39:31 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sat, 25 Jan 2014 20:39:31 +0100
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
Message-ID: <52E412F3.9080507@gmail.com>

On 01/24/2014 04:32 PM, Daniel Micay wrote:
> Supporting selection over multiple queues would involve using kqueue
> on FreeBSD/OSX and eventfd/epoll on Linux instead of a condition
> variable for the not empty condition. For Windows, the regular
> condition variables will work fine. This does have a cost, and may not
> make sense with the same type.

Switching to epoll and friends would allow select over ports and file 
descriptors and timers with the same call, which Rust desperately needs.

From vadimcn at gmail.com  Sat Jan 25 12:26:19 2014
From: vadimcn at gmail.com (Vadim)
Date: Sat, 25 Jan 2014 12:26:19 -0800
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
Message-ID: <CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>

Hi Bill,
If I understand this right, what you are proposing is the approach of
Python's greenlets library, which I already tried to pitch
here<http://mail.mozilla.org/pipermail/rust-dev/2013-November/006544.html>.


I think that the biggest problem with this approach, in its' raw form, is
that greenlets are bound to a specific OS thread, which would cause all
sorts of headache.  For example:
- It would be difficult to balance greenlet tasks between several OS
threads,
- If async I/O requests for two greenlets, bound to the same OS thread,
were to complete simultaneously, you would not be able to resume them in
parallel,
- If a thread were to become blocked for a significant amount of time, all
the greenlets bound to it become un-resumable,
and so on...

Greelets would be much more palatable if their stacks were
position-independent.  This might be possible to achieve with a suitable
LLVM transform<http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-January/069662.html>,
though I am not yet sure how portable this would be.


cheers,
Vadim



On Sat, Jan 25, 2014 at 8:58 AM, Bill Myers <bill_myers at outlook.com> wrote:

> Stack management for green tasks has been based in the past first on
> segmented stacks and then on standard large stacks.
>
> However, I just realized that there is a third alternative which might
> well be better than both of those.
>
> The idea is very simple: a green task would run on a large stack like now,
> but when it is descheduled, a memory buffer of the size of its used stack
> space is allocated, and its stack data is copied there; when it is
> rescheduled, the stack data is copied back to the original address.
>
> The copying can be performed either by memcpy (perhaps with a specialized
> memcpy that assumes alignment and always uses SIMD instruction to copy with
> no checks), or perhaps by using a compression algorithm designed for
> maximum speed, such as Snappy or maybe a new ad-hoc design.
>
> This allows to have the best possible memory efficiency and thus the
> maximum possible number of tasks, even better than segmented stacks due to
> precise sizing and optional compression, while not adding any overhead to
> code that does not block, either in terms of code generation complexity or
> runtime cost.
>
> There is of course an additional runtime cost when blocking, but blocking
> already often involves both system calls and context switching, and
> workloads with lots of blocking green tasks are probably I/O bound anyway;
> furthermore, stack data is probably in the CPU cache, so there shouldn't be
> much penalty.
>
> The only significant drawback is that two green tasks running from the
> same "large" stack (note that stacks cannot be easily switched, as that
> would invalidate borrowed pointers on the stack to the stack) cannot
> ever run concurrently; however, by making the number of large stacks a
> large enough multiple of the number of CPU cores, the probability of
> reduced parallelism due to this issue can be made as small as desired.
>
> In general, one would use an adaptive approach, where this kind of copying
> would start to kick in only once the number of green tasks becomes large;
> when not copying, one would just optionally use madvise(MADV_DONTNEED) to
> trim unused whole pages of the stack.
>
> Also, if the data to be copied is large (several OS pages), one may use
> mremap() or similar facilities to move the address space mappings instead
> of the data itself.
>
> Some unsafe code that assumes that tasks can access each other's stacks
> will break (probably only the new Mutex implementation), but that can be
> fixed by putting the data in the task structure instead of the stack.
>
> Overall, this should allow writing something like a parallel network
> server or web crawler in Rust in a natural blocking style, while being
> fully confident in its scalability, which is something that is not really
> possible at the moment.
>
> Once this is in place, the best practices for Rust programs would become:
> 1. Use native tasks for tasks whose number is bounded at compile time and
> small
> 2. Use green tasks for tasks whose number is unbounded or large
>
> One could even automate this to some extent by spawning by default a
> native task the first C times a given proc() code address is used to start
> a task (where C = number of CPU cores), and green tasks afterwards.
>
> What do you think?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/19f676f4/attachment.html>

From pcwalton at mozilla.com  Sat Jan 25 12:29:23 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 25 Jan 2014 12:29:23 -0800
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
Message-ID: <52E41EA3.6090103@mozilla.com>

On 1/25/14 8:58 AM, Bill Myers wrote:
> Stack management for green tasks has been based in the past first on
> segmented stacks and then on standard large stacks.

I assume this is incompatible with work stealing and task migration 
between threads?

Patrick


From olson.jeffery at gmail.com  Sat Jan 25 13:00:54 2014
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Sat, 25 Jan 2014 13:00:54 -0800
Subject: [rust-dev] Understanding extra::{Encodable, Encoder}
In-Reply-To: <CAEgkx7O3Z75RktSvLfbDq6WVxPW03W4-nF_72TL86VX_qkxm3A@mail.gmail.com>
References: <CAEgkx7O3Z75RktSvLfbDq6WVxPW03W4-nF_72TL86VX_qkxm3A@mail.gmail.com>
Message-ID: <CAEXt_aatQ6jBc=ZrY5rGWEEx9s-pyhGaHR+8C+53zDVZ1TNZjw@mail.gmail.com>

Do you have this code posted somewhere? I would want to take a look at it.

But, at first blush, I think part of (if not most of) the woe is around
using a trait object (~serialize::Encodable). I'm working with passing
around serializable objects, right now in my own codebase, and have
encountered pains as well. The API is really powerful/flexible, but you
need to heavily encapsulate where you expose those bounds and limit them as
much as possible (hint: JSON's field probably shouldn't actually be
restricted to only contain an Encodable<E>, because then you have to expose
E, which has the issues you describe).

 In a way, you're declaring a parameter bound by using Trait Objects
(~serialize::Encodable), but it would probably be more optimal to just
restrict the bounds to the methods where JSON variants can be constructed.

Sorry if this is a mess. It's hard to articulate.. As I said, I'd like to
take a look at the code, as this is an area of the library I've been
interested in and working with (with some success) recently.

Cheers,
Jeff


On Sat, Jan 25, 2014 at 9:22 AM, Neil LoBracco <niceguyneil at gmail.com>wrote:

> Hey guys,
> I'm getting started with Rust, building out a web services framework.
> I have an enum methods can return for their response body:
> public enum ResponseBody {
>    Empty,
>    Text(~str),
>    JSON(~serialize::Encodable)
> }
>
> As you may know, this doesn't work, because Encodable expects a type
> parameter for Encoder. This is needed because Encodable has method:
> fn encode<http://static.rust-lang.org/doc/master/extra/serialize/trait.Encodable.html#tymethod.encode>(&self,
> s: &mut S);
> I can't even say JSON(~serialize::Encodable<json::Encoder>), because
> json::Encoder has a lifetime param that comes from its writer!
> It seems like this makes it impossible to ever take in a serializable
> object, and serialize it however I fancy. Moreover, it seems odd for the
> Encodable to know what it's encoded into - all of the logic that goes into
> actually turning an object into json/xml/whatever lives in json::Encoder,
> etc, so why should the Encodable be coupled with that?
> What makes sense to me would be to be able to say:
> pub fn stringify(obj : &Encodable) -> ~str {
>   let reader = json::Encoder::new(obj);
>   reader.read_to_str()
> }
> Where the Encoder trait implies the Reader trait. If something were
> Encodable, that would not be specific to any particular Encoder - it would
> be a general statement.
>
> Anyone have thoughts about this? Am I missing any easy way I would be able
> to do what I asked above (take in a ~Encodable and encode it to buffer,
> without having whoever created the encodable have to know about the writer
> that would eventually get used)?
> If we want to make changes here, I can certainly help out with that, just
> wanted to understand what's going on here and the rationale.
> Thanks,
> -Neil
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/be2864c9/attachment.html>

From bill_myers at outlook.com  Sat Jan 25 14:17:55 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Sat, 25 Jan 2014 22:17:55 +0000
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <52E41EA3.6090103@mozilla.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>,
	<52E41EA3.6090103@mozilla.com>
Message-ID: <SNT152-W202E0C3C939F1BA4D9AF09F8A00@phx.gbl>

> I assume this is incompatible with work stealing and task migration
> between threads?

It is compatible, assuming that the number of large stacks is sufficiently larger than the number of threads.

Basically, each green task can only run on a specific large stack, but as long as you aren't unlucky that all runnable green tasks you'd steal are running on a large stack that has already a running green task, then you can steal one.

The probability of that obviously decreases the more large stacks you use; large stacks can only consume address space (if you wipe them with madvise(MADV_DONTNEED) or similar when unused), so one can reasonably have 256 8MB large stacks on 32-bit, for instance.

So for instance, if you had an HT 4-core machine with 8 system threads running green tasks and 1024 large stacks, the probability of a green task that is not blocked but not executable (because its large stack is in use) is 7/256; obviously if K tasks are not blocked, then the probability of having none executable becomes (7/256)^K (i.e. exponentially lower).

On 64-bit, the probability can be made arbitrarily low, although you consume more kernel memory to store the metadata associated with the memory mappings for the large stacks.

It would require to rearchitecture the work stealing code to work with a two-level data structure and first steal a large stack with at least one non-blocked task, and then run the task, rather than directly stealing the task. 		 	   		  

From bill_myers at outlook.com  Sat Jan 25 14:29:19 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Sat, 25 Jan 2014 22:29:19 +0000
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>,
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
Message-ID: <SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>

Interesting: my proposal appears to be indeed a generalization of the greenlet approach.

Specifically, while the greenlet proposal seems to only use one large stack per native thread, I'm suggesting to use multiple large stacks that can be stolen by other threads, which does mitigate the issues stemming from non-position dependent stacks (they are not eliminated, but they have low probability of happening).

It's also indeed possible to fully eliminate those issues by autoboxing everything whose address is taken, but that would have a potentially large performance impact on non-blocking code, while merely copying the stack only imposes a performance penalty to code that blocks. 		 	   		  

From bill_myers at outlook.com  Sat Jan 25 14:53:45 2014
From: bill_myers at outlook.com (Bill Myers)
Date: Sat, 25 Jan 2014 22:53:45 +0000
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>,
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>,
	<SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>
Message-ID: <SNT152-W629ECEB705EA9AB545519EF8A00@phx.gbl>

The ratio of native threads to stacks and of stacks to tasks can actually be used to characterize all systems discussed.

(stacks/thread, tasks/stacks)
(1, 1) => current Rust native tasks
(1, N) => Python greenlets
(N, 1) => current Rust green tasks
(N, M) => proposal in my original mail 		 	   		  

From niceguyneil at gmail.com  Sat Jan 25 15:34:42 2014
From: niceguyneil at gmail.com (Neil LoBracco)
Date: Sat, 25 Jan 2014 18:34:42 -0500
Subject: [rust-dev] Understanding extra::{Encodable, Encoder}
In-Reply-To: <CAEXt_aatQ6jBc=ZrY5rGWEEx9s-pyhGaHR+8C+53zDVZ1TNZjw@mail.gmail.com>
References: <CAEgkx7O3Z75RktSvLfbDq6WVxPW03W4-nF_72TL86VX_qkxm3A@mail.gmail.com>
	<CAEXt_aatQ6jBc=ZrY5rGWEEx9s-pyhGaHR+8C+53zDVZ1TNZjw@mail.gmail.com>
Message-ID: <CAEgkx7NPWonKbAp7MwYBAQZWr6iYB9-m2ueEvhLHeziqrKnkxg@mail.gmail.com>

Sure, Jeff. I've posted my work so far at https://github.com/daftcorp/feral
(Feral from ferric oxide, which is rust...yeah, kind of a stretch, I know).
Please disregard the commit messages with swears in them. I'm not used to
the ownership model.
Fundamentally, I'd like a controller (for example, controllers/foo.rs) to
be able to say "encode this object I'm returning",  but not have to worry
about how exactly that's going to happen. That sounds like Good Clean
Architecture.
Curious as to how you've handled this with your stuff, and if we can put
together either a plan to make this system work more intuitively, or create
some documentation about how to use the current framework in a clean manner.
-Neil


On Sat, Jan 25, 2014 at 4:00 PM, Jeffery Olson <olson.jeffery at gmail.com>wrote:

> Do you have this code posted somewhere? I would want to take a look at it.
>
> But, at first blush, I think part of (if not most of) the woe is around
> using a trait object (~serialize::Encodable). I'm working with passing
> around serializable objects, right now in my own codebase, and have
> encountered pains as well. The API is really powerful/flexible, but you
> need to heavily encapsulate where you expose those bounds and limit them as
> much as possible (hint: JSON's field probably shouldn't actually be
> restricted to only contain an Encodable<E>, because then you have to expose
> E, which has the issues you describe).
>
>  In a way, you're declaring a parameter bound by using Trait Objects
> (~serialize::Encodable), but it would probably be more optimal to just
> restrict the bounds to the methods where JSON variants can be constructed.
>
> Sorry if this is a mess. It's hard to articulate.. As I said, I'd like to
> take a look at the code, as this is an area of the library I've been
> interested in and working with (with some success) recently.
>
> Cheers,
> Jeff
>
>
> On Sat, Jan 25, 2014 at 9:22 AM, Neil LoBracco <niceguyneil at gmail.com>wrote:
>
>> Hey guys,
>> I'm getting started with Rust, building out a web services framework.
>> I have an enum methods can return for their response body:
>> public enum ResponseBody {
>>    Empty,
>>    Text(~str),
>>    JSON(~serialize::Encodable)
>> }
>>
>> As you may know, this doesn't work, because Encodable expects a type
>> parameter for Encoder. This is needed because Encodable has method:
>> fn encode<http://static.rust-lang.org/doc/master/extra/serialize/trait.Encodable.html#tymethod.encode>(&self,
>> s: &mut S);
>> I can't even say JSON(~serialize::Encodable<json::Encoder>), because
>> json::Encoder has a lifetime param that comes from its writer!
>> It seems like this makes it impossible to ever take in a serializable
>> object, and serialize it however I fancy. Moreover, it seems odd for the
>> Encodable to know what it's encoded into - all of the logic that goes into
>> actually turning an object into json/xml/whatever lives in json::Encoder,
>> etc, so why should the Encodable be coupled with that?
>> What makes sense to me would be to be able to say:
>> pub fn stringify(obj : &Encodable) -> ~str {
>>   let reader = json::Encoder::new(obj);
>>   reader.read_to_str()
>> }
>> Where the Encoder trait implies the Reader trait. If something were
>> Encodable, that would not be specific to any particular Encoder - it would
>> be a general statement.
>>
>> Anyone have thoughts about this? Am I missing any easy way I would be
>> able to do what I asked above (take in a ~Encodable and encode it to
>> buffer, without having whoever created the encodable have to know about the
>> writer that would eventually get used)?
>> If we want to make changes here, I can certainly help out with that, just
>> wanted to understand what's going on here and the rationale.
>> Thanks,
>> -Neil
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/78c0d7ad/attachment.html>

From vadimcn at gmail.com  Sat Jan 25 16:50:44 2014
From: vadimcn at gmail.com (Vadim)
Date: Sat, 25 Jan 2014 16:50:44 -0800
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
	<SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>
Message-ID: <CADecdiLHMD-FqpcN5GW3gBJ=P6RfW+pfetM63p4+w0q5dG_A7A@mail.gmail.com>

On Sat, Jan 25, 2014 at 2:29 PM, Bill Myers <bill_myers at outlook.com> wrote:

> Interesting: my proposal appears to be indeed a generalization of the
> greenlet approach.
>
> Specifically, while the greenlet proposal seems to only use one large
> stack per native thread, I'm suggesting to use multiple large stacks that
> can be stolen by other threads, which does mitigate the issues stemming
> from non-position dependent stacks (they are not eliminated, but they have
> low probability of happening).
>

You'd still have to be very careful to not perform any significant amount
of computation in a greenlet, as to not block all other greenlets it shares
the OS stack with.
Although... I don't see any reason we could not use non-cooperative
greenlet switching as a backstop (i.e. have some watchdog thread suspend
the offending greenlet, and forcibly swap it out).

It's also indeed possible to fully eliminate those issues by autoboxing
> everything whose address is taken, but that would have a potentially large
> performance impact on non-blocking code, while merely copying the stack
> only imposes a performance penalty to code that blocks.
>

True.   It might be possible to restrict this transform only to functions
that might be on the stack when a greenlet is swapped out, though.
Unfortunately, this will probably require some kind of pluggable effects
system in the language,- e.g. mark I/O functions like read() and write() as
potentially yielding with a special trait, then the compiler could
propagate this trait to all callers, and so on...

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/650bc159/attachment.html>

From comexk at gmail.com  Sat Jan 25 18:23:34 2014
From: comexk at gmail.com (comex)
Date: Sat, 25 Jan 2014 21:23:34 -0500
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <CADecdiLHMD-FqpcN5GW3gBJ=P6RfW+pfetM63p4+w0q5dG_A7A@mail.gmail.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
	<SNT152-W837CCCA9B8991BA5E6DECDF8A00@phx.gbl>
	<CADecdiLHMD-FqpcN5GW3gBJ=P6RfW+pfetM63p4+w0q5dG_A7A@mail.gmail.com>
Message-ID: <CAPM5UJ0iwo1QQyxXrtPLUEgY+aeC4Y0MTc0bprLj7Ts9he1Osw@mail.gmail.com>

To me, issues such as large memcpys/system calls on context switches,
having tasks not be able to compute concurrently with random other
tasks, possibly having to autobox everything, etc. sound like they
would spawn equal or greater complexity and performance loss than just
using split stacks.

If you really wanted to avoid wasting memory, couldn't you allow new
tasks to steal memory below the stack pointer of swapped-out tasks,
changing that task's stack bottom pointer in the process?

From banderson at mozilla.com  Sat Jan 25 18:31:40 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Sat, 25 Jan 2014 18:31:40 -0800
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
Message-ID: <52E4738C.9090800@mozilla.com>

On 01/25/2014 08:58 AM, Bill Myers wrote:
> Stack management for green tasks has been based in the past first on segmented stacks and then on standard large stacks.
>
> However, I just realized that there is a third alternative which might well be better than both of those.
>
> The idea is very simple: a green task would run on a large stack like now, but when it is descheduled, a memory buffer of the size of its used stack space is allocated, and its stack data is copied there; when it is rescheduled, the stack data is copied back to the original address.

That's a really clever idea. There are though a number of situations 
where we unsafely read from or write into other task's stacks that would 
need to be considered carefully.


From elliottcon at gmail.com  Sat Jan 25 21:31:26 2014
From: elliottcon at gmail.com (Elliott Conant)
Date: Sat, 25 Jan 2014 21:31:26 -0800
Subject: [rust-dev] Defining a bitfield type
Message-ID: <CAEkwbenNWy+Ewx5VKuigXQax3FXTRa5gfY0HA-q7hNdDeigHuA@mail.gmail.com>

Hello, this is my first post here so I wanted to say congrats on making
such an awesome language so far!

On to my question, I've been struggling to elegantly define a fixed size
64-bit bitfield type.  There are two parts I'm stuck on: implementing
(just) the std::num::Bitwise operations, and extending it to iterate over
bit indices. Here's some stuff I tried:

// This gets me 90% of the way there, but it pulls in operations like add
and multiply
// which don't make sense in this context. This makes the interface a
little unsafe.
type Bits64 = u64;

// This won't compile because u64 is defined externally. It looks like
'type X = Y'
// just gives an alias to the original type.
impl Bits64 {
  fn bit_index_iter() ...
}
// An alternative that iterates over Bits64 directly. Would be neat but
same problem.
impl Iterator<u64> for Bits64 {
  fn next(&mut self) -> Option<u64> ...
}

// Works, but doesn't looks as cool as putting it in the Bits64 impl, a
little disappointing.
fn bit_index_iter(b : &Bits64) ...

// Some other ways the Bits64 type could be represented.  I could make this
work if
// I had to but the boilerplate I'd have to write scared me away.
struct Bits64(u64);
struct Bits64 {
  b: u64
}
impl std::num::Bitwise for Bits64 { ... }
let x = Bits64(123)
let x = Bits64 { b: 123 }


In my perfect world I'd be able to do something like this:

// Defines the Bits64 type and exposes only the Bitwise operations from u64.
type Bits64 implements std::num::Bitwise = u64;

// I'd be able to extend it :)
impl Bits64 { ... }

// Easy to instantiate.
let x : Bits64 = 123;


I wonder if there's something simple I missed or other alternatives? Thanks!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/3478bec3/attachment-0001.html>

From edward.yu.wang at gmail.com  Sat Jan 25 22:10:57 2014
From: edward.yu.wang at gmail.com (Edward Wang)
Date: Sun, 26 Jan 2014 14:10:57 +0800
Subject: [rust-dev] Defining a bitfield type
In-Reply-To: <CAEkwbenNWy+Ewx5VKuigXQax3FXTRa5gfY0HA-q7hNdDeigHuA@mail.gmail.com>
References: <CAEkwbenNWy+Ewx5VKuigXQax3FXTRa5gfY0HA-q7hNdDeigHuA@mail.gmail.com>
Message-ID: <CAEqtYYhEu-SRgK7H3E4Jp=B=iMxwqdgiyhj3srou8xMvTmViKw@mail.gmail.com>

Hi Elliott,

Did you take a look at extra::bitv,
https://github.com/mozilla/rust/blob/master/src/libextra/bitv.rs? It does
exactly what you want.

Ed


On Sun, Jan 26, 2014 at 1:31 PM, Elliott Conant <elliottcon at gmail.com>wrote:

> Hello, this is my first post here so I wanted to say congrats on making
> such an awesome language so far!
>
> On to my question, I've been struggling to elegantly define a fixed size
> 64-bit bitfield type.  There are two parts I'm stuck on: implementing
> (just) the std::num::Bitwise operations, and extending it to iterate over
> bit indices. Here's some stuff I tried:
>
> // This gets me 90% of the way there, but it pulls in operations like add
> and multiply
> // which don't make sense in this context. This makes the interface a
> little unsafe.
> type Bits64 = u64;
>
> // This won't compile because u64 is defined externally. It looks like
> 'type X = Y'
> // just gives an alias to the original type.
> impl Bits64 {
>   fn bit_index_iter() ...
> }
> // An alternative that iterates over Bits64 directly. Would be neat but
> same problem.
> impl Iterator<u64> for Bits64 {
>   fn next(&mut self) -> Option<u64> ...
> }
>
> // Works, but doesn't looks as cool as putting it in the Bits64 impl, a
> little disappointing.
> fn bit_index_iter(b : &Bits64) ...
>
> // Some other ways the Bits64 type could be represented.  I could make
> this work if
> // I had to but the boilerplate I'd have to write scared me away.
> struct Bits64(u64);
> struct Bits64 {
>   b: u64
> }
> impl std::num::Bitwise for Bits64 { ... }
> let x = Bits64(123)
> let x = Bits64 { b: 123 }
>
>
> In my perfect world I'd be able to do something like this:
>
> // Defines the Bits64 type and exposes only the Bitwise operations from
> u64.
> type Bits64 implements std::num::Bitwise = u64;
>
> // I'd be able to extend it :)
> impl Bits64 { ... }
>
> // Easy to instantiate.
> let x : Bits64 = 123;
>
>
> I wonder if there's something simple I missed or other alternatives?
> Thanks!
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/ba48a6e3/attachment.html>

From elliottcon at gmail.com  Sat Jan 25 22:41:01 2014
From: elliottcon at gmail.com (Elliott Conant)
Date: Sat, 25 Jan 2014 22:41:01 -0800
Subject: [rust-dev] Defining a bitfield type
In-Reply-To: <CAEqtYYhEu-SRgK7H3E4Jp=B=iMxwqdgiyhj3srou8xMvTmViKw@mail.gmail.com>
References: <CAEkwbenNWy+Ewx5VKuigXQax3FXTRa5gfY0HA-q7hNdDeigHuA@mail.gmail.com>
	<CAEqtYYhEu-SRgK7H3E4Jp=B=iMxwqdgiyhj3srou8xMvTmViKw@mail.gmail.com>
Message-ID: <CAEkwbenPO+dr5CDzyxEMvAT8x+_B1iM=V71OpV3+qC7B4-b8Fg@mail.gmail.com>

Hi Ed, thanks for the reply.

That's close to what I want but it's not quite a match for a few reasons.

It has to be 64 bits. bitv gives me 32 bits or a vector of bits...

The code I'm writing is performance sensitive so I'd really like to use
methods implemented for u64. I'd go with writing boilerplate instead of
bitv for this reason.
- Everything in Bitwise compiles to a single machine instruction for u64.
- I'll also be using population_count, trailing_zeros from BitCount.
trailing_zeros compiles to 'bsfq' for u64 on x86-64 which is nice.

Implementing the Bitwise trait is also a convenience because it lets me use
bitwise operators (&, |, <<, etc.). It looks like bitv doesn't do that.


On Sat, Jan 25, 2014 at 10:10 PM, Edward Wang <edward.yu.wang at gmail.com>wrote:

> Hi Elliott,
>
> Did you take a look at extra::bitv,
> https://github.com/mozilla/rust/blob/master/src/libextra/bitv.rs? It does
> exactly what you want.
>
> Ed
>
>
> On Sun, Jan 26, 2014 at 1:31 PM, Elliott Conant <elliottcon at gmail.com>wrote:
>
>> Hello, this is my first post here so I wanted to say congrats on making
>> such an awesome language so far!
>>
>> On to my question, I've been struggling to elegantly define a fixed size
>> 64-bit bitfield type.  There are two parts I'm stuck on: implementing
>> (just) the std::num::Bitwise operations, and extending it to iterate over
>> bit indices. Here's some stuff I tried:
>>
>> // This gets me 90% of the way there, but it pulls in operations like add
>> and multiply
>> // which don't make sense in this context. This makes the interface a
>> little unsafe.
>> type Bits64 = u64;
>>
>> // This won't compile because u64 is defined externally. It looks like
>> 'type X = Y'
>> // just gives an alias to the original type.
>> impl Bits64 {
>>   fn bit_index_iter() ...
>> }
>> // An alternative that iterates over Bits64 directly. Would be neat but
>> same problem.
>> impl Iterator<u64> for Bits64 {
>>   fn next(&mut self) -> Option<u64> ...
>> }
>>
>> // Works, but doesn't looks as cool as putting it in the Bits64 impl, a
>> little disappointing.
>> fn bit_index_iter(b : &Bits64) ...
>>
>> // Some other ways the Bits64 type could be represented.  I could make
>> this work if
>> // I had to but the boilerplate I'd have to write scared me away.
>> struct Bits64(u64);
>> struct Bits64 {
>>   b: u64
>> }
>> impl std::num::Bitwise for Bits64 { ... }
>> let x = Bits64(123)
>> let x = Bits64 { b: 123 }
>>
>>
>> In my perfect world I'd be able to do something like this:
>>
>> // Defines the Bits64 type and exposes only the Bitwise operations from
>> u64.
>> type Bits64 implements std::num::Bitwise = u64;
>>
>> // I'd be able to extend it :)
>> impl Bits64 { ... }
>>
>> // Easy to instantiate.
>> let x : Bits64 = 123;
>>
>>
>> I wonder if there's something simple I missed or other alternatives?
>> Thanks!
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140125/4ff656d1/attachment.html>

From matthieu.monrocq at gmail.com  Sun Jan 26 04:26:30 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 26 Jan 2014 13:26:30 +0100
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <52E4738C.9090800@mozilla.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<52E4738C.9090800@mozilla.com>
Message-ID: <CAKE6RfjaYExQKC29nJ9YGCzQhve=Ea-0t4PNfQRyrBiORE2iZA@mail.gmail.com>

On Sun, Jan 26, 2014 at 3:31 AM, Brian Anderson <banderson at mozilla.com>wrote:

> On 01/25/2014 08:58 AM, Bill Myers wrote:
>
>> Stack management for green tasks has been based in the past first on
>> segmented stacks and then on standard large stacks.
>>
>> However, I just realized that there is a third alternative which might
>> well be better than both of those.
>>
>> The idea is very simple: a green task would run on a large stack like
>> now, but when it is descheduled, a memory buffer of the size of its used
>> stack space is allocated, and its stack data is copied there; when it is
>> rescheduled, the stack data is copied back to the original address.
>>
>
> That's a really clever idea. There are though a number of situations where
> we unsafely read from or write into other task's stacks that would need to
> be considered carefully.
>
>
Would it be possible to statically eliminate this risk by preventing the
promotion of such affected tasks as greenlets ? Or is there today too many
ways to read into a greenlet stack ?

-- Matthieu



>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/1cdefa6d/attachment.html>

From glaebhoerl at gmail.com  Sun Jan 26 04:36:52 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 26 Jan 2014 13:36:52 +0100
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <CAKE6RfjaYExQKC29nJ9YGCzQhve=Ea-0t4PNfQRyrBiORE2iZA@mail.gmail.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<52E4738C.9090800@mozilla.com>
	<CAKE6RfjaYExQKC29nJ9YGCzQhve=Ea-0t4PNfQRyrBiORE2iZA@mail.gmail.com>
Message-ID: <CAPoegszNam+B9oJwP7HB7RTt8TnhwgPaN+XcFTffdf7GPj_UOA@mail.gmail.com>

On Sun, Jan 26, 2014 at 1:26 PM, Matthieu Monrocq <
matthieu.monrocq at gmail.com> wrote:

>
>
>
> On Sun, Jan 26, 2014 at 3:31 AM, Brian Anderson <banderson at mozilla.com>wrote:
>
>> On 01/25/2014 08:58 AM, Bill Myers wrote:
>>
>>> Stack management for green tasks has been based in the past first on
>>> segmented stacks and then on standard large stacks.
>>>
>>> However, I just realized that there is a third alternative which might
>>> well be better than both of those.
>>>
>>> The idea is very simple: a green task would run on a large stack like
>>> now, but when it is descheduled, a memory buffer of the size of its used
>>> stack space is allocated, and its stack data is copied there; when it is
>>> rescheduled, the stack data is copied back to the original address.
>>>
>>
>> That's a really clever idea. There are though a number of situations
>> where we unsafely read from or write into other task's stacks that would
>> need to be considered carefully.
>>
>>
> Would it be possible to statically eliminate this risk by preventing the
> promotion of such affected tasks as greenlets ? Or is there today too many
> ways to read into a greenlet stack ?
>

We *already* statically prevent tasks from reading/writing each others'
stacks, the issue here is code which uses `unsafe { }` and does it anyways,
based on particular assumptions about how stacks are implemented which
would no longer be valid. The solution would be to (considering it
carefully) fix this unsafe code to no longer rely on these assumptions.


>
> -- Matthieu
>
>
>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/a68602f8/attachment-0001.html>

From danielmicay at gmail.com  Sun Jan 26 04:56:52 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 26 Jan 2014 07:56:52 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E3F50F.2080407@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
	<52E3F50F.2080407@mozilla.com>
Message-ID: <CA+DvKQ+icZKhs+j87XD0-7JV+szzK5FvN8j9uAUt+BmLYV6v3A@mail.gmail.com>

On Sat, Jan 25, 2014 at 12:31 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 1/25/14 2:48 AM, Daniel Micay wrote:
>>
>> Rust aims to be a systems language displacing C and C++ from their
>> niche. I don't think it's suitable as one with the standard library,
>> and it's not replacement for C without a large library ecosystem.
>
>
> As Brian said, this sort of inflammatory, unspecific criticism is not
> welcome. Especially when you are advocating making channels *less*
> performant.
>
> Patrick

I don't think it's inflammatory or unspecific. Rust's standard library
doesn't follow the pay-for-what-you-use philosophy and pulls in many
megabytes of code via trait objects despite it not be used. It also
forces the bindings to any library making use of thread-local storage
(many!) to use painful context objects, even though it's unnecessary
with 1:1 threading. C++ follows the philosophy of not making you pay
for abstractions you aren't using.

A simple multi-consumer channel is faster than the current Rust
channels with 1:1 threading, so I'm only advocating leaving out a
restricted API until it offers a performance advantage over a default,
unrestricted one.

From glaebhoerl at gmail.com  Sun Jan 26 05:02:39 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 26 Jan 2014 14:02:39 +0100
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
Message-ID: <CAPoegswUg2PkaYdE=HT1-56EwcLc3-WgqmGQaDQFJ1uDSRRTSA@mail.gmail.com>

On Sat, Jan 25, 2014 at 9:26 PM, Vadim <vadimcn at gmail.com> wrote:

> Hi Bill,
> If I understand this right, what you are proposing is the approach of
> Python's greenlets library, which I already tried to pitch here<http://mail.mozilla.org/pipermail/rust-dev/2013-November/006544.html>.
>
>
> I think that the biggest problem with this approach, in its' raw form, is
> that greenlets are bound to a specific OS thread, which would cause all
> sorts of headache.  For example:
> - It would be difficult to balance greenlet tasks between several OS
> threads,
> - If async I/O requests for two greenlets, bound to the same OS thread,
> were to complete simultaneously, you would not be able to resume them in
> parallel,
> - If a thread were to become blocked for a significant amount of time, all
> the greenlets bound to it become un-resumable,
> and so on...
>
> Greelets would be much more palatable if their stacks were
> position-independent.  This might be possible to achieve with a suitable
> LLVM transform<http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-January/069662.html>,
> though I am not yet sure how portable this would be.
>

Totally not an expert in this area, but I'm wondering two things:

 - Once you hoist all variables whose address is taken out into this
secondary stack frame, if you have a pointer on the stack to an object on
the stack who *also*, in turn, has its address taken, then I believe you
would end up with a pointer in the secondary stack frame to an object in
the secondary stack frame, i.e. the secondary stack frame itself would not
be position independent. Does the secondary stack frame always stay in
place, so we don't really care about this?

 - Instead of heap-allocating a secondary stack frame, could another
potential solution be to use similar infrastructure as for DWARF-based
unwinding and/or precise GC tracing of the stack, in other words to emit a
side table of the positions of pointers into the stack in each stack frame,
and then when relocating the stack, to consult this side table and manually
fix-up all of the affected pointers? In this case, aside from the presence
of the side tables, the cost is borne only when actually relocating the
stack.



>
>
> cheers,
> Vadim
>
>
>
> On Sat, Jan 25, 2014 at 8:58 AM, Bill Myers <bill_myers at outlook.com>wrote:
>
>> Stack management for green tasks has been based in the past first on
>> segmented stacks and then on standard large stacks.
>>
>> However, I just realized that there is a third alternative which might
>> well be better than both of those.
>>
>> The idea is very simple: a green task would run on a large stack like
>> now, but when it is descheduled, a memory buffer of the size of its used
>> stack space is allocated, and its stack data is copied there; when it is
>> rescheduled, the stack data is copied back to the original address.
>>
>> The copying can be performed either by memcpy (perhaps with a specialized
>> memcpy that assumes alignment and always uses SIMD instruction to copy with
>> no checks), or perhaps by using a compression algorithm designed for
>> maximum speed, such as Snappy or maybe a new ad-hoc design.
>>
>> This allows to have the best possible memory efficiency and thus the
>> maximum possible number of tasks, even better than segmented stacks due to
>> precise sizing and optional compression, while not adding any overhead to
>> code that does not block, either in terms of code generation complexity or
>> runtime cost.
>>
>> There is of course an additional runtime cost when blocking, but blocking
>> already often involves both system calls and context switching, and
>> workloads with lots of blocking green tasks are probably I/O bound anyway;
>> furthermore, stack data is probably in the CPU cache, so there shouldn't be
>> much penalty.
>>
>> The only significant drawback is that two green tasks running from the
>> same "large" stack (note that stacks cannot be easily switched, as that
>> would invalidate borrowed pointers on the stack to the stack) cannot
>> ever run concurrently; however, by making the number of large stacks a
>> large enough multiple of the number of CPU cores, the probability of
>> reduced parallelism due to this issue can be made as small as desired.
>>
>> In general, one would use an adaptive approach, where this kind of
>> copying would start to kick in only once the number of green tasks becomes
>> large; when not copying, one would just optionally use
>> madvise(MADV_DONTNEED) to trim unused whole pages of the stack.
>>
>> Also, if the data to be copied is large (several OS pages), one may use
>> mremap() or similar facilities to move the address space mappings instead
>> of the data itself.
>>
>> Some unsafe code that assumes that tasks can access each other's stacks
>> will break (probably only the new Mutex implementation), but that can be
>> fixed by putting the data in the task structure instead of the stack.
>>
>> Overall, this should allow writing something like a parallel network
>> server or web crawler in Rust in a natural blocking style, while being
>> fully confident in its scalability, which is something that is not really
>> possible at the moment.
>>
>> Once this is in place, the best practices for Rust programs would become:
>> 1. Use native tasks for tasks whose number is bounded at compile time and
>> small
>> 2. Use green tasks for tasks whose number is unbounded or large
>>
>> One could even automate this to some extent by spawning by default a
>> native task the first C times a given proc() code address is used to start
>> a task (where C = number of CPU cores), and green tasks afterwards.
>>
>> What do you think?
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/adbdbacb/attachment.html>

From cadencemarseille at gmail.com  Sun Jan 26 05:06:32 2014
From: cadencemarseille at gmail.com (Cadence Marseille)
Date: Sun, 26 Jan 2014 08:06:32 -0500
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
Message-ID: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>

Hi,

I am seeing a new build error and I am not sure what is causing it.
rust-pcre <https://github.com/cadencemarseille/rust-pcre>, libpcre bindings
for Rust, is set up to use Travis and Rust CI <http://rust-ci.org/>.  The
latest build is failing with:

rustpkg install pcre

WARNING: The Rust package manager is experimental and may be unstable

error: Package pcre depends on extra, but I don't know how to find it

task '<unnamed>' failed at 'explicit failure',
/build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/
util.rs:531

task '<main>' failed at 'receiving on a closed channel',
/build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/
mod.rs:743

task '<unnamed>' failed at 'Error running custom build command',
/build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/
lib.rs:517

make: *** [install] Error 65

See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218

I looked at some other Rust CI-enabled projects and found a similar error:
https://travis-ci.org/eholk/rust-opencl/builds/17491630
https://travis-ci.org/erickt/rust-zmq/builds/16353359
https://travis-ci.org/erickt/rust-mustache/builds/16059551
https://travis-ci.org/bjz/gl-rs/builds/16126945
https://travis-ci.org/bjz/sax-rs/builds/16405581

What is causing this error and how do I fix it?

Cadence
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/aaf0ace0/attachment.html>

From glaebhoerl at gmail.com  Sun Jan 26 05:07:22 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sun, 26 Jan 2014 14:07:22 +0100
Subject: [rust-dev] Idea: Memcpyed stacks for green tasks
In-Reply-To: <CAPoegswUg2PkaYdE=HT1-56EwcLc3-WgqmGQaDQFJ1uDSRRTSA@mail.gmail.com>
References: <SNT152-W22B6E1904141678173E73EF8A00@phx.gbl>
	<CADecdiKYJsMCt1HxUC7zwVK9MQ6OmrZTwucuTgH=0aurQbdb6Q@mail.gmail.com>
	<CAPoegswUg2PkaYdE=HT1-56EwcLc3-WgqmGQaDQFJ1uDSRRTSA@mail.gmail.com>
Message-ID: <CAPoegswbHydTqSn6yWui=OUta6jVSxJFhyGZ-QF-5oKeiBsihA@mail.gmail.com>

On Sun, Jan 26, 2014 at 2:02 PM, G?bor Lehel <glaebhoerl at gmail.com> wrote:

>
>
>
> On Sat, Jan 25, 2014 at 9:26 PM, Vadim <vadimcn at gmail.com> wrote:
>
>> Hi Bill,
>> If I understand this right, what you are proposing is the approach of
>> Python's greenlets library, which I already tried to pitch here<http://mail.mozilla.org/pipermail/rust-dev/2013-November/006544.html>.
>>
>>
>> I think that the biggest problem with this approach, in its' raw form, is
>> that greenlets are bound to a specific OS thread, which would cause all
>> sorts of headache.  For example:
>> - It would be difficult to balance greenlet tasks between several OS
>> threads,
>> - If async I/O requests for two greenlets, bound to the same OS thread,
>> were to complete simultaneously, you would not be able to resume them in
>> parallel,
>> - If a thread were to become blocked for a significant amount of time,
>> all the greenlets bound to it become un-resumable,
>> and so on...
>>
>> Greelets would be much more palatable if their stacks were
>> position-independent.  This might be possible to achieve with a suitable
>> LLVM transform<http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-January/069662.html>,
>> though I am not yet sure how portable this would be.
>>
>
> Totally not an expert in this area, but I'm wondering two things:
>
>  - Once you hoist all variables whose address is taken out into this
> secondary stack frame, if you have a pointer on the stack to an object on
> the stack who *also*, in turn, has its address taken, then I believe you
> would end up with a pointer in the secondary stack frame to an object in
> the secondary stack frame, i.e. the secondary stack frame itself would not
> be position independent. Does the secondary stack frame always stay in
> place, so we don't really care about this?
>

(Thinking about this further, this was a silly question, because the
primary stack frame itself would have pointers into the secondary one, so
_obviously_ the latter cannot move.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/d2ee76c9/attachment-0001.html>

From danielmicay at gmail.com  Sun Jan 26 05:13:35 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 26 Jan 2014 08:13:35 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E2C100.9030400@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
Message-ID: <CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>

On Fri, Jan 24, 2014 at 2:37 PM, Brian Anderson <banderson at mozilla.com> wrote:
> Thanks for your well thought-out considerations about Rust's message passing
> strategy.
>
>
> On 01/24/2014 07:32 AM, Daniel Micay wrote:
>>
>> The language documentation currently takes a very opinionated view on
>> concurrency. It focuses on message passing and at times makes the
>> claim that Rust does not have shared memory between tasks. I don't
>> think the language should be taking a position like this but rather
>> providing useful tools to implement a concurrent application as the
>> developer sees fit.
>
>
> Yes, Rust has always promoted message passing as the preferred way to do
> concurrency. Rust also provides useful tools to implement concurrency as the
> developer sees fit. I believe that recommending message passing by default
> is reasonable since it is widely applicable and easy to use. Perhaps we can
> update language in various documentation to not claim absolutely that Rust
> has no shared memory, but it is important to express that Rust protects
> developers from the pitfalls of shared memory.

I think shared memory is widely applicable and easy to use too. It's
often much harder to use message passing.

>> The library should be offering the `Arc` and `MutexArc` types in
>> `libstd` along with other useful concurrent data structures. A
>> concurrent hash table split into shards is a very scalable primitive
>> and quite trivial to implement. There's no reason to encode keyed
>> inserts/searches/removals with message passing when it's faster and
>> easier to do it directly.
>
>
> Possibly, yes. Instead of putting everything in std though I would rather
> foster a culture of using small crates. It is easier to accept more
> experimental code into the standard distribution if they are in seperate
> packages that can be developed independently. A concurrency crate would be
> more attractive to me than putting specialized data structures in the
> standard library.

Why not move message passing to another crate then? It doesn't have to
be in the standard library either. The standard library could provide
only native I/O and threading like C++, with the contentious stuff
moved to other crates and built on top of it. If it proves to be
useful, then the community will use it.

Shared memory is already far more solid and less experimental than the
existing concurrency and I/O support.

> I don't know what 'API sacrifices made at the performance altar' means. This
> sort of unspecific, inflammatory criticism is not necessary or welcome. Many
> people (myself included) have put an enormous amount of work into
> discovering how to build abstractions in this new language. It is a long,
> iterative process, there are many tradeoffs, and mistakes are occassionally
> made. Please try to be nice.

Rust is making a lot of semantic sacrifices for the sake of
performance. I see most of it as being under the assumption that it
will eventually perform well rather than being based on hard numbers.

> I believe the single-consumer restriction has to do with the complexity of
> implementing 'select' with multiple consumers. Do you have that implemented
> in rust-core?

I have an implementation for Windows and Linux but haven't pushed it
into rust-core. I haven't set up a FreeBSD install so I don't have a
working implementation with kqueue. It's significantly (20-30%+)
slower in the case where the condition variable is being hit a lot due
to imbalance in consumption/production. It also currently only
supports selection over channels as I don't really see a way to do
cross-platform AIO with acceptable performance. Linux is only going to
be able to select on non-blocking sockets, unless it's all shoved
behind more `eventfd` descriptors hooked up to a thread pool...

From pcwalton at mozilla.com  Sun Jan 26 06:29:06 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 26 Jan 2014 06:29:06 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQ+icZKhs+j87XD0-7JV+szzK5FvN8j9uAUt+BmLYV6v3A@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<001201cf193f$577c6d40$067547c0$@googlemail.com>
	<CA+DvKQL0mpgvD41ZYeC95cDQyoKx5HuqkJyQQWYBh4cXxnJRmw@mail.gmail.com>
	<CALax_rxtJ2uzJjTQGb5Rk6mtPj1Ciqmq22ywcnzocLb9MMnOOQ@mail.gmail.com>
	<CA+DvKQLB6rgqMHQRWmpXAybo4Fw-n7rj7pvPL4=OpashP6Db5A@mail.gmail.com>
	<52E3F50F.2080407@mozilla.com>
	<CA+DvKQ+icZKhs+j87XD0-7JV+szzK5FvN8j9uAUt+BmLYV6v3A@mail.gmail.com>
Message-ID: <52E51BB2.1050100@mozilla.com>

On 1/26/14 4:56 AM, Daniel Micay wrote:
> I don't think it's inflammatory or unspecific. Rust's standard library
> doesn't follow the pay-for-what-you-use philosophy and pulls in many
> megabytes of code via trait objects despite it not be used.

Still unspecific. What code exactly?

> It also
> forces the bindings to any library making use of thread-local storage
> (many!) to use painful context objects, even though it's unnecessary
> with 1:1 threading. C++ follows the philosophy of not making you pay
> for abstractions you aren't using.

Context objects are not painful; they are part of good library design. 
Libraries that don't use them are annoying to work with. OpenGL global 
state juggling is no fun, for example; any API that exposed OpenGL 
safely would possibly have to recreate context objects for memory safety.

In any case, if you used an M:N threading library such as lthread in 
C++, then you would have to do the same thing. If you don't want to pay 
for the abstraction in your library bindings, then don't support M:N 
threading. Rust doesn't force you one way or another.

M:N threading is like C++ RTTI or exceptions: the standard library 
exposes the ability to make it work but you don't have to use it. In 
fact, M:N threading in Rust is much more "pay-for-what-you-use" than C++ 
exceptions, as the C++ language is incomplete without exceptions 
(because there is no way to signal constructor failure) while there is 
no such dependency on M:N threading in Rust.

> A simple multi-consumer channel is faster than the current Rust
> channels with 1:1 threading

Bounded or unbounded?

In any case, Rust offers M:N threading, so this isn't very persuasive. 
M:N threading is not going to be removed until it is optimized and 
compared against the 1:1 implementation on all platforms.

Patrick


From pcwalton at mozilla.com  Sun Jan 26 06:46:05 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 26 Jan 2014 06:46:05 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
Message-ID: <52E51FAD.2040602@mozilla.com>

On 1/26/14 5:13 AM, Daniel Micay wrote:
> I think shared memory is widely applicable and easy to use too. It's
> often much harder to use message passing.

Message passing has been proven time and time again to be among the 
easiest forms of concurrency to understand and use. You don't have to 
look any further than the list of the most popular concurrent languages.

> Rust is making a lot of semantic sacrifices for the sake of
> performance. I see most of it as being under the assumption that it
> will eventually perform well rather than being based on hard numbers.

This is either:

1. An implication that we are not benchmarking, which is plainly false.

2. A denial that sometimes getting good performance requires a 
sophisticated implementation that takes time to get right. This is also 
false. Look at JavaScript engines, for example. You don't get good 
performance without at least two JITs (one non-SSA, one SSA) and 
possibly an interpreter. (And this is not because of JavaScript's 
complexity; LuaJIT's tracing is awfully complex too.) In these 
situations, the only way to know whether you're heading down the right 
path is to actually spend the time to optimize the implementation. Until 
that is done, stop energy (such as your constant stop energy against M:N 
threading) is entirely unhelpful.

> It's significantly (20-30%+)
> slower in the case where the condition variable is being hit a lot due
> to imbalance in consumption/production.

Then why not expose a work-stealing queue instead?

Patrick


From armin.ronacher at active-4.com  Sun Jan 26 06:47:41 2014
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Sun, 26 Jan 2014 14:47:41 +0000
Subject: [rust-dev] Deriving keyword
In-Reply-To: <52E22417.8050207@gmail.com>
References: <CAHzuJ32M-u0PDKZGuBmsQan7SvoyW9b_SU+qS_abKO2Pa1sEBw@mail.gmail.com>	<CANb7cF6VaoXB_yTGJs+6RvMg_Br8fNpD1-w2WW2uM1i3Tg2e4A@mail.gmail.com>
	<52E22417.8050207@gmail.com>
Message-ID: <52E5200D.2030209@active-4.com>

Hi,

On 24/01/2014 08:28, Lee Braiden wrote:
> "deriving", like Haskell has.  Is maintaining a low keyword count really THAT
> important, that we have to have ugly #[] wrappers around things?  I had thought
> that #[] represented meta-information, like how to compile/link the file, but if
> deriving is in there, it's very much involving the language proper, too.
Yes!  It means you can add things after the fact without breaking people's code. 
  Just think of how bools in C are __Bool now and you need a header to make it 
into bool.

Also it means that language specifics and library functionality look more like 
each other.


Regards,
Armin


From vladimir at slate-project.org  Sun Jan 26 07:00:46 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sun, 26 Jan 2014 15:00:46 +0000
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E51FAD.2040602@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
	<52E51FAD.2040602@mozilla.com>
Message-ID: <CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>

Here are a couple of observations/comments from a rust lurker:

* +1 for message-passing as a core paradigm for inter-thread communication.
It is significantly easier to reason about than shared memory. It is not a
silver bullet for all cases of course (but that is why you have unsafe
code):
   ** How do you make asynchronous replies behave in an obvious manner
(without blocking). Akka's approach with Futures offers one possible
solution (see Composing Futures section of
http://doc.akka.io/docs/akka/snapshot/scala/futures.html) but I haven't had
a go at seeing if something like this will work in Rust
   ** How do you group these asynchronous request/reply into synchronous
blocks? I.e. how do you turn groups of asynchronous operations involving
many tasks into a single "transaction" (or monad)? Akka for example does
not support this very well (Transactors offer no way of replying to data).
And anyway we cannot implement STM in the rust core library I think
* Has anyone taken a look at the primitives for inter-task communication
that ZMQ (http://zeromq.org/) offers? Their different alternatives for N-N
communication are particularly powerful in practice. And their API makes a
lot of sense.
* +1 to the Sender/Receiver nomenclature (vs. Sink/Source)
* +1 to context objects, completely agree with Patrick's reasoning

Vladimir


On Sun, Jan 26, 2014 at 2:46 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/26/14 5:13 AM, Daniel Micay wrote:
>
>> I think shared memory is widely applicable and easy to use too. It's
>> often much harder to use message passing.
>>
>
> Message passing has been proven time and time again to be among the
> easiest forms of concurrency to understand and use. You don't have to look
> any further than the list of the most popular concurrent languages.
>
>
>  Rust is making a lot of semantic sacrifices for the sake of
>> performance. I see most of it as being under the assumption that it
>> will eventually perform well rather than being based on hard numbers.
>>
>
> This is either:
>
> 1. An implication that we are not benchmarking, which is plainly false.
>
> 2. A denial that sometimes getting good performance requires a
> sophisticated implementation that takes time to get right. This is also
> false. Look at JavaScript engines, for example. You don't get good
> performance without at least two JITs (one non-SSA, one SSA) and possibly
> an interpreter. (And this is not because of JavaScript's complexity;
> LuaJIT's tracing is awfully complex too.) In these situations, the only way
> to know whether you're heading down the right path is to actually spend the
> time to optimize the implementation. Until that is done, stop energy (such
> as your constant stop energy against M:N threading) is entirely unhelpful.
>
>
>  It's significantly (20-30%+)
>> slower in the case where the condition variable is being hit a lot due
>> to imbalance in consumption/production.
>>
>
> Then why not expose a work-stealing queue instead?
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/a06d07dd/attachment.html>

From philippe.delrieu at free.fr  Sun Jan 26 07:25:53 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Sun, 26 Jan 2014 16:25:53 +0100
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
Message-ID: <52E52901.7020403@free.fr>

Hi,

I have the same problem since 2 or 3 days with the portmidi project.

Philippe

Le 26/01/2014 14:06, Cadence Marseille a ?crit :
> Hi,
>
> I am seeing a new build error and I am not sure what is causing it. 
> rust-pcre <https://github.com/cadencemarseille/rust-pcre>, libpcre 
> bindings for Rust, is set up to use Travis and Rust CI 
> <http://rust-ci.org/>. The latest build is failing with:
>
> rustpkg install pcre
>
> WARNING: The Rust package manager is experimental and may be unstable
>
> error: Package pcre depends on extra, but I don't know how to find it
>
> task '<unnamed>' failed at 'explicit failure', 
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/util.rs:531 
> <http://util.rs:531>
>
> task '<main>' failed at 'receiving on a closed channel', 
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/mod.rs:743 
> <http://mod.rs:743>
>
> task '<unnamed>' failed at 'Error running custom build command', 
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/lib.rs:517 
> <http://lib.rs:517>
>
> make: *** [install] Error 65
>
>
> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>
> I looked at some other Rust CI-enabled projects and found a similar error:
> https://travis-ci.org/eholk/rust-opencl/builds/17491630
> https://travis-ci.org/erickt/rust-zmq/builds/16353359
> https://travis-ci.org/erickt/rust-mustache/builds/16059551
> https://travis-ci.org/bjz/gl-rs/builds/16126945
> https://travis-ci.org/bjz/sax-rs/builds/16405581
>
> What is causing this error and how do I fix it?
>
> Cadence
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/1e9ef6ce/attachment-0001.html>

From dpx.infinity at gmail.com  Sun Jan 26 09:32:11 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Sun, 26 Jan 2014 21:32:11 +0400
Subject: [rust-dev] Avoiding partially moved values error when consuming a
 struct with multiple fields
Message-ID: <CA+jWdBhnVT-ShAKAcaiTqdrT=ArdbkELWdSdn4bzanAu-gaxDw@mail.gmail.com>

Hi all,

Consider this code:

struct Test1 {
    a: ~str,
    b: f32,
}

struct Test2 {
    c: ~str,
    d: f64
}

impl Test1 {
    fn into_test2(self) -> Test2 {
        Test2 {
            c: self.a,
            d: self.b as f64
        }
    }
}


In into_test2() method I want to consume Test1 struct completely. But
because ~str is not implicitly copyable, self.a is moved out of self,
and on Test2.d field assignment I get the following error:

main.rs:15:16: 15:21 error: use of partially moved value: `self`
main.rs:15             d: self.b as f64
                          ^~~~~
main.rs:14:16: 14:22 note: `self.a` moved here because it has type
`~str`, which is non-copyable (perhaps you meant to use clone()?)
main.rs:14             c: self.a,
                          ^~~~~~

I know that I can, say, do self.a.clone() to avoid moving, but I don't
want extra allocations. And it is also possible to reorder Test2
fields assignments and it will work, but it won't if both fields are
not copyable.

So, the question is: how to correctly correctly move several pieces of
data out from a struct without using clone()? Is it possible at all?

Thanks,
Vladimir.

From alex at crichton.co  Sun Jan 26 10:13:49 2014
From: alex at crichton.co (Alex Crichton)
Date: Sun, 26 Jan 2014 10:13:49 -0800
Subject: [rust-dev] Avoiding partially moved values error when consuming
 a struct with multiple fields
In-Reply-To: <CA+jWdBhnVT-ShAKAcaiTqdrT=ArdbkELWdSdn4bzanAu-gaxDw@mail.gmail.com>
References: <CA+jWdBhnVT-ShAKAcaiTqdrT=ArdbkELWdSdn4bzanAu-gaxDw@mail.gmail.com>
Message-ID: <CAFnh-mcW_gEpMd310aK=4z+Wym2QSMh44XFaVVS-af4EC7B9uQ@mail.gmail.com>

You'll want to do destructuring assignment here. This means that you
take ownership of all fields in parallel:

    fn into_test2(self) -> Test2 {
        let Test1 { a, b } = self;
        Test2 {
            c: a,
            d: b as f64
        }
    }

On Sun, Jan 26, 2014 at 9:32 AM, Vladimir Matveev
<dpx.infinity at gmail.com> wrote:
> Hi all,
>
> Consider this code:
>
> struct Test1 {
>     a: ~str,
>     b: f32,
> }
>
> struct Test2 {
>     c: ~str,
>     d: f64
> }
>
> impl Test1 {
>     fn into_test2(self) -> Test2 {
>         Test2 {
>             c: self.a,
>             d: self.b as f64
>         }
>     }
> }
>
>
> In into_test2() method I want to consume Test1 struct completely. But
> because ~str is not implicitly copyable, self.a is moved out of self,
> and on Test2.d field assignment I get the following error:
>
> main.rs:15:16: 15:21 error: use of partially moved value: `self`
> main.rs:15             d: self.b as f64
>                           ^~~~~
> main.rs:14:16: 14:22 note: `self.a` moved here because it has type
> `~str`, which is non-copyable (perhaps you meant to use clone()?)
> main.rs:14             c: self.a,
>                           ^~~~~~
>
> I know that I can, say, do self.a.clone() to avoid moving, but I don't
> want extra allocations. And it is also possible to reorder Test2
> fields assignments and it will work, but it won't if both fields are
> not copyable.
>
> So, the question is: how to correctly correctly move several pieces of
> data out from a struct without using clone()? Is it possible at all?
>
> Thanks,
> Vladimir.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From alex at crichton.co  Sun Jan 26 10:27:59 2014
From: alex at crichton.co (Alex Crichton)
Date: Sun, 26 Jan 2014 10:27:59 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
Message-ID: <CAFnh-mcqUdv3qvxfweU8dgec3e9qH6kdPShxJ5qW6Zo1E1Q-2w@mail.gmail.com>

> Shared memory is already far more solid and less experimental than the
> existing concurrency and I/O support.

> Rust is making a lot of semantic sacrifices for the sake of
> performance. I see most of it as being under the assumption that it
> will eventually perform well rather than being based on hard numbers.

These two comments are examples of inflammatory remarks that Brian
mentioned are not welcome. These are both vague and unspecific.

As Patrick mentioned, software doesn't become high quality overnight,
but rather it takes a lot of time and effort to reach that point. The
Rust standard libraries are still fledgling in their existence and
have much work do to. Constant negative energy against the development
of a library is a terrible way for it to make progress.

On Sun, Jan 26, 2014 at 5:13 AM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Fri, Jan 24, 2014 at 2:37 PM, Brian Anderson <banderson at mozilla.com> wrote:
>> Thanks for your well thought-out considerations about Rust's message passing
>> strategy.
>>
>>
>> On 01/24/2014 07:32 AM, Daniel Micay wrote:
>>>
>>> The language documentation currently takes a very opinionated view on
>>> concurrency. It focuses on message passing and at times makes the
>>> claim that Rust does not have shared memory between tasks. I don't
>>> think the language should be taking a position like this but rather
>>> providing useful tools to implement a concurrent application as the
>>> developer sees fit.
>>
>>
>> Yes, Rust has always promoted message passing as the preferred way to do
>> concurrency. Rust also provides useful tools to implement concurrency as the
>> developer sees fit. I believe that recommending message passing by default
>> is reasonable since it is widely applicable and easy to use. Perhaps we can
>> update language in various documentation to not claim absolutely that Rust
>> has no shared memory, but it is important to express that Rust protects
>> developers from the pitfalls of shared memory.
>
> I think shared memory is widely applicable and easy to use too. It's
> often much harder to use message passing.
>
>>> The library should be offering the `Arc` and `MutexArc` types in
>>> `libstd` along with other useful concurrent data structures. A
>>> concurrent hash table split into shards is a very scalable primitive
>>> and quite trivial to implement. There's no reason to encode keyed
>>> inserts/searches/removals with message passing when it's faster and
>>> easier to do it directly.
>>
>>
>> Possibly, yes. Instead of putting everything in std though I would rather
>> foster a culture of using small crates. It is easier to accept more
>> experimental code into the standard distribution if they are in seperate
>> packages that can be developed independently. A concurrency crate would be
>> more attractive to me than putting specialized data structures in the
>> standard library.
>
> Why not move message passing to another crate then? It doesn't have to
> be in the standard library either. The standard library could provide
> only native I/O and threading like C++, with the contentious stuff
> moved to other crates and built on top of it. If it proves to be
> useful, then the community will use it.
>
> Shared memory is already far more solid and less experimental than the
> existing concurrency and I/O support.
>
>> I don't know what 'API sacrifices made at the performance altar' means. This
>> sort of unspecific, inflammatory criticism is not necessary or welcome. Many
>> people (myself included) have put an enormous amount of work into
>> discovering how to build abstractions in this new language. It is a long,
>> iterative process, there are many tradeoffs, and mistakes are occassionally
>> made. Please try to be nice.
>
> Rust is making a lot of semantic sacrifices for the sake of
> performance. I see most of it as being under the assumption that it
> will eventually perform well rather than being based on hard numbers.
>
>> I believe the single-consumer restriction has to do with the complexity of
>> implementing 'select' with multiple consumers. Do you have that implemented
>> in rust-core?
>
> I have an implementation for Windows and Linux but haven't pushed it
> into rust-core. I haven't set up a FreeBSD install so I don't have a
> working implementation with kqueue. It's significantly (20-30%+)
> slower in the case where the condition variable is being hit a lot due
> to imbalance in consumption/production. It also currently only
> supports selection over channels as I don't really see a way to do
> cross-platform AIO with acceptable performance. Linux is only going to
> be able to select on non-blocking sockets, unless it's all shoved
> behind more `eventfd` descriptors hooked up to a thread pool...
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From olson.jeffery at gmail.com  Sun Jan 26 11:44:56 2014
From: olson.jeffery at gmail.com (Jeffery Olson)
Date: Sun, 26 Jan 2014 11:44:56 -0800
Subject: [rust-dev] Understanding extra::{Encodable, Encoder}
In-Reply-To: <CAEgkx7NPWonKbAp7MwYBAQZWr6iYB9-m2ueEvhLHeziqrKnkxg@mail.gmail.com>
References: <CAEgkx7O3Z75RktSvLfbDq6WVxPW03W4-nF_72TL86VX_qkxm3A@mail.gmail.com>
	<CAEXt_aatQ6jBc=ZrY5rGWEEx9s-pyhGaHR+8C+53zDVZ1TNZjw@mail.gmail.com>
	<CAEgkx7NPWonKbAp7MwYBAQZWr6iYB9-m2ueEvhLHeziqrKnkxg@mail.gmail.com>
Message-ID: <CAEXt_aYYFKDERoCZROZgDaCu9Fh1YJvgY14fG7nzbu2HcJf27A@mail.gmail.com>

I have opened a PR against feral at
https://github.com/daftcorp/feral/pull/4. I hope my solution meets
with your approval.

Cheers,
Jeff


On Sat, Jan 25, 2014 at 3:34 PM, Neil LoBracco <niceguyneil at gmail.com>wrote:

> Sure, Jeff. I've posted my work so far at
> https://github.com/daftcorp/feral
> (Feral from ferric oxide, which is rust...yeah, kind of a stretch, I know).
> Please disregard the commit messages with swears in them. I'm not used to
> the ownership model.
> Fundamentally, I'd like a controller (for example, controllers/foo.rs) to
> be able to say "encode this object I'm returning",  but not have to worry
> about how exactly that's going to happen. That sounds like Good Clean
> Architecture.
> Curious as to how you've handled this with your stuff, and if we can put
> together either a plan to make this system work more intuitively, or create
> some documentation about how to use the current framework in a clean manner.
>  -Neil
>
>
> On Sat, Jan 25, 2014 at 4:00 PM, Jeffery Olson <olson.jeffery at gmail.com>wrote:
>
>> Do you have this code posted somewhere? I would want to take a look at it.
>>
>> But, at first blush, I think part of (if not most of) the woe is around
>> using a trait object (~serialize::Encodable). I'm working with passing
>> around serializable objects, right now in my own codebase, and have
>> encountered pains as well. The API is really powerful/flexible, but you
>> need to heavily encapsulate where you expose those bounds and limit them as
>> much as possible (hint: JSON's field probably shouldn't actually be
>> restricted to only contain an Encodable<E>, because then you have to expose
>> E, which has the issues you describe).
>>
>>  In a way, you're declaring a parameter bound by using Trait Objects
>> (~serialize::Encodable), but it would probably be more optimal to just
>> restrict the bounds to the methods where JSON variants can be constructed.
>>
>> Sorry if this is a mess. It's hard to articulate.. As I said, I'd like to
>> take a look at the code, as this is an area of the library I've been
>> interested in and working with (with some success) recently.
>>
>> Cheers,
>> Jeff
>>
>>
>> On Sat, Jan 25, 2014 at 9:22 AM, Neil LoBracco <niceguyneil at gmail.com>wrote:
>>
>>> Hey guys,
>>> I'm getting started with Rust, building out a web services framework.
>>> I have an enum methods can return for their response body:
>>> public enum ResponseBody {
>>>    Empty,
>>>    Text(~str),
>>>    JSON(~serialize::Encodable)
>>> }
>>>
>>> As you may know, this doesn't work, because Encodable expects a type
>>> parameter for Encoder. This is needed because Encodable has method:
>>> fn encode<http://static.rust-lang.org/doc/master/extra/serialize/trait.Encodable.html#tymethod.encode>(&self,
>>> s: &mut S);
>>> I can't even say JSON(~serialize::Encodable<json::Encoder>), because
>>> json::Encoder has a lifetime param that comes from its writer!
>>> It seems like this makes it impossible to ever take in a serializable
>>> object, and serialize it however I fancy. Moreover, it seems odd for the
>>> Encodable to know what it's encoded into - all of the logic that goes into
>>> actually turning an object into json/xml/whatever lives in json::Encoder,
>>> etc, so why should the Encodable be coupled with that?
>>> What makes sense to me would be to be able to say:
>>> pub fn stringify(obj : &Encodable) -> ~str {
>>>   let reader = json::Encoder::new(obj);
>>>   reader.read_to_str()
>>> }
>>> Where the Encoder trait implies the Reader trait. If something were
>>> Encodable, that would not be specific to any particular Encoder - it would
>>> be a general statement.
>>>
>>> Anyone have thoughts about this? Am I missing any easy way I would be
>>> able to do what I asked above (take in a ~Encodable and encode it to
>>> buffer, without having whoever created the encodable have to know about the
>>> writer that would eventually get used)?
>>> If we want to make changes here, I can certainly help out with that,
>>> just wanted to understand what's going on here and the rationale.
>>> Thanks,
>>> -Neil
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/98c0b8bb/attachment-0001.html>

From pcwalton at mozilla.com  Sun Jan 26 11:51:00 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 26 Jan 2014 11:51:00 -0800
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>	<52E2C100.9030400@mozilla.com>	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>	<52E51FAD.2040602@mozilla.com>
	<CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
Message-ID: <52E56724.3040809@mozilla.com>

On 1/26/14 7:00 AM, Vladimir Lushnikov wrote:
> Here are a couple of observations/comments from a rust lurker:
>
> * +1 for message-passing as a core paradigm for inter-thread
> communication. It is significantly easier to reason about than shared
> memory. It is not a silver bullet for all cases of course (but that is
> why you have unsafe code):

Well, you don't need unsafe code for shared memory. IMHO, one of the 
best features about Rust is that it has an excellent story for shared 
memory when you need it: it's memory safe and race free.

But in the general case, "do not communicate by sharing memory; share 
memory by communicating" should still be your first approach. There is 
nothing evil about shared memory, but I think history has shown that it 
is inherently harder to reason about.

Patrick


From vladimir at slate-project.org  Sun Jan 26 12:21:08 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sun, 26 Jan 2014 20:21:08 +0000
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <52E56724.3040809@mozilla.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
	<52E51FAD.2040602@mozilla.com>
	<CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
	<52E56724.3040809@mozilla.com>
Message-ID: <CACTPm53PvsD0RYM8-9s9mLxiYbAcOfTSEqK0zn4qREfQOUixSg@mail.gmail.com>

Right, I should have been clearer :) There's no way to share memory without
having to use a lock (e.g. in Arc) unless you use unsafe Rust.


On Sun, Jan 26, 2014 at 7:51 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 1/26/14 7:00 AM, Vladimir Lushnikov wrote:
>
>> Here are a couple of observations/comments from a rust lurker:
>>
>> * +1 for message-passing as a core paradigm for inter-thread
>> communication. It is significantly easier to reason about than shared
>> memory. It is not a silver bullet for all cases of course (but that is
>> why you have unsafe code):
>>
>
> Well, you don't need unsafe code for shared memory. IMHO, one of the best
> features about Rust is that it has an excellent story for shared memory
> when you need it: it's memory safe and race free.
>
> But in the general case, "do not communicate by sharing memory; share
> memory by communicating" should still be your first approach. There is
> nothing evil about shared memory, but I think history has shown that it is
> inherently harder to reason about.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/ae9a1af6/attachment.html>

From danielmicay at gmail.com  Sun Jan 26 13:16:07 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Sun, 26 Jan 2014 16:16:07 -0500
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CACTPm53PvsD0RYM8-9s9mLxiYbAcOfTSEqK0zn4qREfQOUixSg@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
	<52E51FAD.2040602@mozilla.com>
	<CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
	<52E56724.3040809@mozilla.com>
	<CACTPm53PvsD0RYM8-9s9mLxiYbAcOfTSEqK0zn4qREfQOUixSg@mail.gmail.com>
Message-ID: <CA+DvKQJic6edJPs6C=FyF60zdLXRO9BqXW-zJ2NBL5TbyKy9Ew@mail.gmail.com>

On Sun, Jan 26, 2014 at 3:21 PM, Vladimir Lushnikov
<vladimir at slate-project.org> wrote:
> Right, I should have been clearer :) There's no way to share memory without
> having to use a lock (e.g. in Arc) unless you use unsafe Rust.

Arc doesn't use a lock as it's immutable. There's also no way to do
message passing without unsafe code.

High-level mutable concurrent data structures would have fine-grained
locking, as is this case with a hash table where the locking
granularity is a flexible runtime choice from 1 to N.

From niko at alum.mit.edu  Sun Jan 26 13:29:46 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sun, 26 Jan 2014 16:29:46 -0500
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <20140125053100.GH5744@Mr-Bennet>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
	<20140125053100.GH5744@Mr-Bennet>
Message-ID: <20140126212946.GC21572@Mr-Bennet>

On Sat, Jan 25, 2014 at 12:31:00AM -0500, Niko Matsakis wrote:
> As a bonus, `&my` is perfect for the `drop` trait.

Thinking on this more, I don't actually think `&my` is perfect for the
drop trait, or at least not any more perfect than normal by-value.  I
still think it's a good idea to address closure-fn-integration
(perhaps post 1.0).


Niko

From flaper87 at gmail.com  Sun Jan 26 13:53:34 2014
From: flaper87 at gmail.com (Flaper87)
Date: Sun, 26 Jan 2014 22:53:34 +0100
Subject: [rust-dev] [ANN] rust-ring Consistent hashing library for rust
Message-ID: <CAMOT3C2TcJ2vXLuvkL0j4yfdS+d12++k1gwBvXP9dMJjcaB+0Q@mail.gmail.com>

Greetings,

I wanted to announce `rust-ring`. It's a consistent hashing library for
rust. I started to play around with this a couple of days ago and I decided
to complete it and keep it updated. It's still quite inefficient and most
probably buggy. :D

In case anyone is interested: https://github.com/flaper87/rust-ring

Feedback, suggestions.. all welcome! :)

Cheers,
FF

-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/bf33f710/attachment.html>

From adamson.benjamin at gmail.com  Sun Jan 26 17:57:16 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Sun, 26 Jan 2014 17:57:16 -0800
Subject: [rust-dev] Defining a bitfield type
In-Reply-To: <CAEkwbenPO+dr5CDzyxEMvAT8x+_B1iM=V71OpV3+qC7B4-b8Fg@mail.gmail.com>
References: <CAEkwbenNWy+Ewx5VKuigXQax3FXTRa5gfY0HA-q7hNdDeigHuA@mail.gmail.com>
	<CAEqtYYhEu-SRgK7H3E4Jp=B=iMxwqdgiyhj3srou8xMvTmViKw@mail.gmail.com>
	<CAEkwbenPO+dr5CDzyxEMvAT8x+_B1iM=V71OpV3+qC7B4-b8Fg@mail.gmail.com>
Message-ID: <CAHzuJ32VDyaOCiMi8rnzN6dEyhVszChM=keSkpfkgQo1iJFKPQ@mail.gmail.com>

Why not extend the bitv library to do what you want, and submit a PR?


On Sat, Jan 25, 2014 at 10:41 PM, Elliott Conant <elliottcon at gmail.com>wrote:

> Hi Ed, thanks for the reply.
>
> That's close to what I want but it's not quite a match for a few reasons.
>
> It has to be 64 bits. bitv gives me 32 bits or a vector of bits...
>
> The code I'm writing is performance sensitive so I'd really like to use
> methods implemented for u64. I'd go with writing boilerplate instead of
> bitv for this reason.
> - Everything in Bitwise compiles to a single machine instruction for u64.
> - I'll also be using population_count, trailing_zeros from BitCount.
> trailing_zeros compiles to 'bsfq' for u64 on x86-64 which is nice.
>
> Implementing the Bitwise trait is also a convenience because it lets me
> use bitwise operators (&, |, <<, etc.). It looks like bitv doesn't do that.
>
>
> On Sat, Jan 25, 2014 at 10:10 PM, Edward Wang <edward.yu.wang at gmail.com>wrote:
>
>> Hi Elliott,
>>
>> Did you take a look at extra::bitv,
>> https://github.com/mozilla/rust/blob/master/src/libextra/bitv.rs? It
>> does exactly what you want.
>>
>> Ed
>>
>>
>> On Sun, Jan 26, 2014 at 1:31 PM, Elliott Conant <elliottcon at gmail.com>wrote:
>>
>>> Hello, this is my first post here so I wanted to say congrats on making
>>> such an awesome language so far!
>>>
>>> On to my question, I've been struggling to elegantly define a fixed size
>>> 64-bit bitfield type.  There are two parts I'm stuck on: implementing
>>> (just) the std::num::Bitwise operations, and extending it to iterate over
>>> bit indices. Here's some stuff I tried:
>>>
>>> // This gets me 90% of the way there, but it pulls in operations like
>>> add and multiply
>>> // which don't make sense in this context. This makes the interface a
>>> little unsafe.
>>> type Bits64 = u64;
>>>
>>> // This won't compile because u64 is defined externally. It looks like
>>> 'type X = Y'
>>> // just gives an alias to the original type.
>>> impl Bits64 {
>>>   fn bit_index_iter() ...
>>> }
>>> // An alternative that iterates over Bits64 directly. Would be neat but
>>> same problem.
>>> impl Iterator<u64> for Bits64 {
>>>   fn next(&mut self) -> Option<u64> ...
>>> }
>>>
>>> // Works, but doesn't looks as cool as putting it in the Bits64 impl, a
>>> little disappointing.
>>> fn bit_index_iter(b : &Bits64) ...
>>>
>>> // Some other ways the Bits64 type could be represented.  I could make
>>> this work if
>>> // I had to but the boilerplate I'd have to write scared me away.
>>> struct Bits64(u64);
>>> struct Bits64 {
>>>   b: u64
>>> }
>>> impl std::num::Bitwise for Bits64 { ... }
>>> let x = Bits64(123)
>>> let x = Bits64 { b: 123 }
>>>
>>>
>>> In my perfect world I'd be able to do something like this:
>>>
>>> // Defines the Bits64 type and exposes only the Bitwise operations from
>>> u64.
>>> type Bits64 implements std::num::Bitwise = u64;
>>>
>>> // I'd be able to extend it :)
>>> impl Bits64 { ... }
>>>
>>> // Easy to instantiate.
>>> let x : Bits64 = 123;
>>>
>>>
>>> I wonder if there's something simple I missed or other alternatives?
>>> Thanks!
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140126/4be4f159/attachment.html>

From banderson at mozilla.com  Sun Jan 26 18:39:52 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Sun, 26 Jan 2014 18:39:52 -0800
Subject: [rust-dev] Today's Rust contribution ideas
Message-ID: <52E5C6F8.8080402@mozilla.com>

People interested in Rust are often looking for ways to have a greater 
impact on its development, and while the issue tracker lists lots of 
stuff that one *could* work on, it's not always clear what one *should* 
work on. There is consistently an overwhelming number of very important 
tasks to do which nobody is tackling, so this is an effort to update 
folks on what high-impact, yet accessible, contribution opportunities 
are available. These are of varying difficulty, but progress on any of 
them is worthy of *extreme kudos*.

# Break up libextra (#8784)

Getting our library ecosystem in shape in critical for Rust 1.0. We want 
Rust to be a "batteries included" language, distributed with many crates 
for common uses, but the way our libraries are organized - everything 
divided between std and extra - has long been very unsatisfactory. 
libextra needs to be split up into a number of subject-specific crates, 
setting the precedent for future expansion of the standard libraries, 
and with the impending merging of #11787 the floodgates can be opened.

This is simply a matter of identifing which modules in extra logically 
belong in their own libraries, extracting them to a directory in src/, 
and adding a minimal amount of boilerplate to the makefiles. Multiple 
people can work on this, coordinating on the issue tracker.

# Improve the official cheatsheet

We have the beginnings of a 'cheatsheet', documenting various common 
patterns in Rust code 
(http://static.rust-lang.org/doc/master/complement-cheatsheet.html), but 
there is so much more that could be here. This style of documentation is 
hugely useful for newcomers. There are a few ways to approach this: 
simply review the current document, editing and augmenting the existing 
examples; think of the questions you had about Rust when you started and 
add them; solicit questions (and answers!) from the broader community 
and them; finally, organize a doc sprint with several people to make 
some quick improvements over a few hours.

# Implement the `Share` kind (#11781)

Future concurrency code is going to need to reason about types that can 
be shared across threads. The canonical example is fork/join concurrency 
using a shared closure, where the closure environment is bounded by 
`Share`. We have the `Freeze` kind which covers a limited version of 
this use case, but it's not sufficient, and may end up completely 
supplanted by `Share`. This is quite important to have sorted out for 
1.0 but the design is not done yet. Work with other developers to figure 
out the design, then once that's done the implementation - while 
involving a fair bit of compiler hacking and library modifications - 
should be relatively easy.

# Remove `do` (#10815)

Consensus is that the `do` keyword is no longer pulling its weight. 
Remove all uses of it, then remove support from the compiler. This is a 
1.0 issue.

# Experiment with faster hash maps (#11783)

Rust's HashMap uses a cryptographically secure hash, and at least partly 
as a result of that it is quite slow. HashMap continues to show up very, 
very high in performance profiles of a variety of code. It's not clear 
what the solution to this is, but it is clear that - at least sometimes 
- we need a much faster hash map solution. Figure out how to create 
faster hash maps in Rust, potentially sacrificing some amount of 
DOS-resistance by using weaker hash functions. This is fairly open-ended 
and researchy, but a solution to this could have a big impact on the 
performance of rustc and other projects.

# Replace 'extern mod' with 'extern crate' (#9880)

Using 'extern mod' as the syntax for linking to another crate has long 
been a bit cringeworthy. The consensus here is to simply rename it to 
`extern crate`. This is a fairly easy change that involves adding 
`crate` as a keyword, modifying the parser to parse the new syntax, then 
changing all uses, either after a snapshot or using conditional 
compilation. This is a 1.0 issue.

# Introduce a design FAQ to the official docs (#4047)

There are many questions about languages' design asked repeatedly, so 
they tend to have documents simply explaining the rationale for various 
decisions. Particularly as we approach 1.0 we'll want a place to point 
newcomers to when these questions are asked. The issue on the bug 
tracker already contains quite a lot of questions, and some answers as 
well. Add a new Markdown file to the doc/ folder and the documentation 
index, and add as many of the answers as you can. Consider recruiting 
others in #rust to help.


From banderson at mozilla.com  Sun Jan 26 19:14:05 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Sun, 26 Jan 2014 19:14:05 -0800
Subject: [rust-dev] RFC: New Rust channel proposal
In-Reply-To: <52D4A564.4090602@mozilla.com>
References: <52D4A564.4090602@mozilla.com>
Message-ID: <52E5CEFD.7020205@mozilla.com>

On 01/13/2014 06:48 PM, Brian Anderson wrote:
>
> # Synchronous and bounded channels
>
> Let's add `SyncChan` which is a bounded multi-producer single-consumer 
> queue backed by a ring buffer. This supports `send`, which blocks by 
> default, and `try_send` which returns an enum representing whether the 
> send succeeded, the channel is full, or the channel is closed (the 
> last two cases returning the message). In the special case where the 
> channel bound is 0, we don't use a ringbuffer and just do a 
> rendezvousing send and recieve. The default bound is 0.

One of the reasons for making sync and async channels different types is 
so that somebody who is given a channel object knows the semantics they 
are dealing with. It occurred to me today that the 0-bound case and the 
N-bound case for sync channels also has this problem. With no buffer you 
are always expecting to rendezvous with the receiver, but the type 
doesn't give you that guarantee. It seems to me these are pretty 
different use cases and I'm worried about combining them.

From dpx.infinity at gmail.com  Sun Jan 26 21:01:53 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Mon, 27 Jan 2014 09:01:53 +0400
Subject: [rust-dev] Avoiding partially moved values error when consuming
 a struct with multiple fields
In-Reply-To: <CAFnh-mcW_gEpMd310aK=4z+Wym2QSMh44XFaVVS-af4EC7B9uQ@mail.gmail.com>
References: <CA+jWdBhnVT-ShAKAcaiTqdrT=ArdbkELWdSdn4bzanAu-gaxDw@mail.gmail.com>
	<CAFnh-mcW_gEpMd310aK=4z+Wym2QSMh44XFaVVS-af4EC7B9uQ@mail.gmail.com>
Message-ID: <CA+jWdBiDeE4cCUX4JmcRY8sdCO0o3FSBjCmbG7nod6P7mAxxuA@mail.gmail.com>

Oh, great! I completely forgot that I can destructure structs in let
bindings too. Indeed it works. Thanks!

2014-01-26 Alex Crichton <alex at crichton.co>:
> You'll want to do destructuring assignment here. This means that you
> take ownership of all fields in parallel:
>
>     fn into_test2(self) -> Test2 {
>         let Test1 { a, b } = self;
>         Test2 {
>             c: a,
>             d: b as f64
>         }
>     }
>
> On Sun, Jan 26, 2014 at 9:32 AM, Vladimir Matveev
> <dpx.infinity at gmail.com> wrote:
>> Hi all,
>>
>> Consider this code:
>>
>> struct Test1 {
>>     a: ~str,
>>     b: f32,
>> }
>>
>> struct Test2 {
>>     c: ~str,
>>     d: f64
>> }
>>
>> impl Test1 {
>>     fn into_test2(self) -> Test2 {
>>         Test2 {
>>             c: self.a,
>>             d: self.b as f64
>>         }
>>     }
>> }
>>
>>
>> In into_test2() method I want to consume Test1 struct completely. But
>> because ~str is not implicitly copyable, self.a is moved out of self,
>> and on Test2.d field assignment I get the following error:
>>
>> main.rs:15:16: 15:21 error: use of partially moved value: `self`
>> main.rs:15             d: self.b as f64
>>                           ^~~~~
>> main.rs:14:16: 14:22 note: `self.a` moved here because it has type
>> `~str`, which is non-copyable (perhaps you meant to use clone()?)
>> main.rs:14             c: self.a,
>>                           ^~~~~~
>>
>> I know that I can, say, do self.a.clone() to avoid moving, but I don't
>> want extra allocations. And it is also possible to reorder Test2
>> fields assignments and it will work, but it won't if both fields are
>> not copyable.
>>
>> So, the question is: how to correctly correctly move several pieces of
>> data out from a struct without using clone()? Is it possible at all?
>>
>> Thanks,
>> Vladimir.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

From leebraid at gmail.com  Mon Jan 27 00:17:39 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Mon, 27 Jan 2014 08:17:39 +0000
Subject: [rust-dev] Why focus on single-consumer message passing?
In-Reply-To: <CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
References: <CA+DvKQJjRWcUon461pNbFeSmq09QUrTKtWLwJ=4uTx0LhHLnYQ@mail.gmail.com>
	<52E2C100.9030400@mozilla.com>
	<CA+DvKQKeVZY0HD9p_6xApVGG+-bhgUxDnUUQcBW+s64oKvxFbw@mail.gmail.com>
	<52E51FAD.2040602@mozilla.com>
	<CACTPm51nBtRNHESEwr=-O3ZTqeUAs8ku_AHBp=9YV0-htgQVAg@mail.gmail.com>
Message-ID: <52E61623.5060301@gmail.com>

On 26/01/14 15:00, Vladimir Lushnikov wrote:
> Here are a couple of observations/comments from a rust lurker:
>
>    ** And anyway we cannot implement STM in the rust core library I think

Worth noting that Haswell supports STM in hardware:

http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions

So this may be something worth looking into.

We really should consider what hardware might look like in 5-10 years 
time, if Rust is planned as a mainstream language in that sort of timeframe.


-- 
Lee


From niko at alum.mit.edu  Mon Jan 27 03:03:51 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 27 Jan 2014 06:03:51 -0500
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <CAPoegszVH_P4Km1h3bCE38HfV-ExGt_c_kbsa1j6qZ55NLmZZw@mail.gmail.com>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
	<20140125053100.GH5744@Mr-Bennet>
	<CAPoegszVH_P4Km1h3bCE38HfV-ExGt_c_kbsa1j6qZ55NLmZZw@mail.gmail.com>
Message-ID: <20140127110351.GC9131@Mr-Bennet>

On Sat, Jan 25, 2014 at 07:07:32PM +0100, G?bor Lehel wrote:
> If you wanted to pass an unboxed closure without indirection though, like
> `fn foo<T: Fn<U, R>>(x: T)`, then you would have to explicitly dereference
> the closure, i.e. `foo(*|u| r)` (which might be OK).

Why would you want to do that? There is no advantage to doing so; the ABI
will almost certainly reintroduce indirection anyhow.

> The basic problem is that there's a zoo of closure types:
> http://glaebhoerl.tumblr.com/rust_closure_types (I will be referring to
> things from this in the following!)

No time to write a long response here just now, but this is a very
nice writeup, thanks.



Niko

From matthieu.monrocq at gmail.com  Mon Jan 27 09:33:46 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Mon, 27 Jan 2014 18:33:46 +0100
Subject: [rust-dev] Today's Rust contribution ideas
In-Reply-To: <52E5C6F8.8080402@mozilla.com>
References: <52E5C6F8.8080402@mozilla.com>
Message-ID: <CAKE6RfhxLKkx-NL1BGkp5HSa5sX80DiOf91zRGNYb-qO0Ktk-g@mail.gmail.com>

On Mon, Jan 27, 2014 at 3:39 AM, Brian Anderson <banderson at mozilla.com>wrote:

> People interested in Rust are often looking for ways to have a greater
> impact on its development, and while the issue tracker lists lots of stuff
> that one *could* work on, it's not always clear what one *should* work on.
> There is consistently an overwhelming number of very important tasks to do
> which nobody is tackling, so this is an effort to update folks on what
> high-impact, yet accessible, contribution opportunities are available.
> These are of varying difficulty, but progress on any of them is worthy of
> *extreme kudos*.
>
> # Break up libextra (#8784)
>
> Getting our library ecosystem in shape in critical for Rust 1.0. We want
> Rust to be a "batteries included" language, distributed with many crates
> for common uses, but the way our libraries are organized - everything
> divided between std and extra - has long been very unsatisfactory. libextra
> needs to be split up into a number of subject-specific crates, setting the
> precedent for future expansion of the standard libraries, and with the
> impending merging of #11787 the floodgates can be opened.
>
> This is simply a matter of identifing which modules in extra logically
> belong in their own libraries, extracting them to a directory in src/, and
> adding a minimal amount of boilerplate to the makefiles. Multiple people
> can work on this, coordinating on the issue tracker.
>
> # Improve the official cheatsheet
>
> We have the beginnings of a 'cheatsheet', documenting various common
> patterns in Rust code (http://static.rust-lang.org/doc/master/complement-
> cheatsheet.html), but there is so much more that could be here. This
> style of documentation is hugely useful for newcomers. There are a few ways
> to approach this: simply review the current document, editing and
> augmenting the existing examples; think of the questions you had about Rust
> when you started and add them; solicit questions (and answers!) from the
> broader community and them; finally, organize a doc sprint with several
> people to make some quick improvements over a few hours.
>
> # Implement the `Share` kind (#11781)
>
> Future concurrency code is going to need to reason about types that can be
> shared across threads. The canonical example is fork/join concurrency using
> a shared closure, where the closure environment is bounded by `Share`. We
> have the `Freeze` kind which covers a limited version of this use case, but
> it's not sufficient, and may end up completely supplanted by `Share`. This
> is quite important to have sorted out for 1.0 but the design is not done
> yet. Work with other developers to figure out the design, then once that's
> done the implementation - while involving a fair bit of compiler hacking
> and library modifications - should be relatively easy.
>
> # Remove `do` (#10815)
>
> Consensus is that the `do` keyword is no longer pulling its weight. Remove
> all uses of it, then remove support from the compiler. This is a 1.0 issue.
>
> # Experiment with faster hash maps (#11783)
>
> Rust's HashMap uses a cryptographically secure hash, and at least partly
> as a result of that it is quite slow. HashMap continues to show up very,
> very high in performance profiles of a variety of code. It's not clear what
> the solution to this is, but it is clear that - at least sometimes - we
> need a much faster hash map solution. Figure out how to create faster hash
> maps in Rust, potentially sacrificing some amount of DOS-resistance by
> using weaker hash functions. This is fairly open-ended and researchy, but a
> solution to this could have a big impact on the performance of rustc and
> other projects.
>

You might be interested by a serie of articles by Joaqu?n M L?pez Mu?oz who
maintains the Boost.MultiIndex library. He did a relatively comprehensive
overview of the hash-maps implementation of Dirkumware (MSVC), libstdc++
and libc++ on top of Boost.MultiIndex, and a lot of benchmarks showing the
performance for insertion/removal/search in a variety of setup.

One of the last articles:
http://bannalia.blogspot.fr/2014/01/a-better-hash-table-clang.html


>
> # Replace 'extern mod' with 'extern crate' (#9880)
>
> Using 'extern mod' as the syntax for linking to another crate has long
> been a bit cringeworthy. The consensus here is to simply rename it to
> `extern crate`. This is a fairly easy change that involves adding `crate`
> as a keyword, modifying the parser to parse the new syntax, then changing
> all uses, either after a snapshot or using conditional compilation. This is
> a 1.0 issue.
>
> # Introduce a design FAQ to the official docs (#4047)
>
> There are many questions about languages' design asked repeatedly, so they
> tend to have documents simply explaining the rationale for various
> decisions. Particularly as we approach 1.0 we'll want a place to point
> newcomers to when these questions are asked. The issue on the bug tracker
> already contains quite a lot of questions, and some answers as well. Add a
> new Markdown file to the doc/ folder and the documentation index, and add
> as many of the answers as you can. Consider recruiting others in #rust to
> help.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/0b7d13e7/attachment-0001.html>

From glaebhoerl at gmail.com  Mon Jan 27 11:33:57 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Mon, 27 Jan 2014 20:33:57 +0100
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <20140127110351.GC9131@Mr-Bennet>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
	<20140125053100.GH5744@Mr-Bennet>
	<CAPoegszVH_P4Km1h3bCE38HfV-ExGt_c_kbsa1j6qZ55NLmZZw@mail.gmail.com>
	<20140127110351.GC9131@Mr-Bennet>
Message-ID: <CAPoegszPXo4ZhsMeAu068pHAv-Z9fO-9y+-co=F_=iS_tvd2kg@mail.gmail.com>

On Mon, Jan 27, 2014 at 12:03 PM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Sat, Jan 25, 2014 at 07:07:32PM +0100, G?bor Lehel wrote:
> > If you wanted to pass an unboxed closure without indirection though, like
> > `fn foo<T: Fn<U, R>>(x: T)`, then you would have to explicitly
> dereference
> > the closure, i.e. `foo(*|u| r)` (which might be OK).
>
> Why would you want to do that? There is no advantage to doing so; the ABI
> will almost certainly reintroduce indirection anyhow.
>

I think this question has a more general form, namely: when should I pass
by value and when using &move/&my? I expect this will come up quite a bit
if we add the latter.


>
> > The basic problem is that there's a zoo of closure types:
> > http://glaebhoerl.tumblr.com/rust_closure_types (I will be referring to
> > things from this in the following!)
>
> No time to write a long response here just now, but this is a very
> nice writeup, thanks.
>
>
>
> Niko
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/58864234/attachment.html>

From sebastian.sylvan at gmail.com  Mon Jan 27 14:41:31 2014
From: sebastian.sylvan at gmail.com (Sebastian Sylvan)
Date: Mon, 27 Jan 2014 14:41:31 -0800
Subject: [rust-dev] Today's Rust contribution ideas
In-Reply-To: <CAKE6RfhxLKkx-NL1BGkp5HSa5sX80DiOf91zRGNYb-qO0Ktk-g@mail.gmail.com>
References: <52E5C6F8.8080402@mozilla.com>
	<CAKE6RfhxLKkx-NL1BGkp5HSa5sX80DiOf91zRGNYb-qO0Ktk-g@mail.gmail.com>
Message-ID: <CAGZgfT7tu+9i3S-W8V=Lod318AnfCM4G2afdjm8_kv7NNbv1-w@mail.gmail.com>

On Mon, Jan 27, 2014 at 9:33 AM, Matthieu Monrocq <
matthieu.monrocq at gmail.com> wrote:

>
>
>
> On Mon, Jan 27, 2014 at 3:39 AM, Brian Anderson <banderson at mozilla.com>wrote:
>
>>
>> Consensus is that the `do` keyword is no longer pulling its weight.
>> Remove all uses of it, then remove support from the compiler. This is a 1.0
>> issue.
>>
>> # Experiment with faster hash maps (#11783)
>>
>> Rust's HashMap uses a cryptographically secure hash, and at least partly
>> as a result of that it is quite slow. HashMap continues to show up very,
>> very high in performance profiles of a variety of code. It's not clear what
>> the solution to this is, but it is clear that - at least sometimes - we
>> need a much faster hash map solution. Figure out how to create faster hash
>> maps in Rust, potentially sacrificing some amount of DOS-resistance by
>> using weaker hash functions. This is fairly open-ended and researchy, but a
>> solution to this could have a big impact on the performance of rustc and
>> other projects.
>>
>
> You might be interested by a serie of articles by Joaqu?n M L?pez Mu?oz
> who maintains the Boost.MultiIndex library. He did a relatively
> comprehensive overview of the hash-maps implementation of Dirkumware
> (MSVC), libstdc++ and libc++ on top of Boost.MultiIndex, and a lot of
> benchmarks showing the performance for insertion/removal/search in a
> variety of setup.
>
> One of the last articles:
> http://bannalia.blogspot.fr/2014/01/a-better-hash-table-clang.html
>

Let me also plug this blog post from a while back:
http://sebastiansylvan.com/2013/05/08/robin-hood-hashing-should-be-your-default-hash-table-implementation/.
There's also a followup on improving deletions*, which makes the final
form the fastest hash map I know of. It's also compact (95% load factor, 32
bits overhead per element, but you can reduce that to 2 bits per element if
you sacrifice some perf.), and doesn't allocate (other than doubling the
size of the table when you hit the load factor).

For a benchmark with lots of std::strings it was 23%, 66% and 25% faster
for insertions deletions and lookups (compared to MSVC unordered_map), it
also uses 30% less memory in that case.

Seb

* the basic form has an issue where repeated deletes gradually increases
the probe count. In pathological cases this can reduce performance by a
lot. The fix is to incrementally fix up the table on each delete (you could
also do it in batch every now and then). It's still faster in all cases,
and the probe-length as well as probe-length-variance remains low even in
the most pathological circumstances.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/e9bc646a/attachment.html>

From erick.tryzelaar at gmail.com  Mon Jan 27 15:13:20 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Mon, 27 Jan 2014 15:13:20 -0800
Subject: [rust-dev] Reminder: Rust Bay Area meetup tomorrow
Message-ID: <CALdfqQ+4+uFDPFun-noaXoRU6gDeP9EuH1K7oXxocz5qD_jn7A@mail.gmail.com>

Good afternoon Rusties,

I wanted to remind everyone of the next Rust Bay Area meetup tomorrow at
the San Francisco Mozilla office. We still have plenty of spots left
available if you want to join us. On the agenda is:

* Brian will talk about Rust 0.9 and the roadmap to 1.0
* Niko will talk about his plans for Dynamically Sized Types, or DST
* Corey Richardson will present remotely about his Rust-themed cake, as
well as his toy OS and his experience with evangelizing Rust.
* And finally Kevin Ballard will present his safe Lua bindings.

You can find more details at our meetup page:

http://www.meetup.com/Rust-Bay-Area/events/153909222/

For those who are remote, you can watch the meetup live on Air Mozilla:

https://air.mozilla.org/rust-meetup-january-2014/

Thanks, and I hope you can make it!

-Erick


PS: I'm always looking for presenters local or remote, so please let me
know if you want to present something.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/5f6db99b/attachment.html>

From banderson at mozilla.com  Mon Jan 27 17:09:48 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 27 Jan 2014 17:09:48 -0800
Subject: [rust-dev] Gating Rust commits on Android testing
Message-ID: <52E7035C.1050107@mozilla.com>

Hey Rustlers.

I've just instructed our friendly bot, bors, to start rejecting pull 
requests that don't pass the test suite on Android. This has been a long 
time coming, but from now on our Android support should be much more 
consistent. This will make it incrementally harder to land certain types 
of changes, but for the most part I don't expect it to be a huge burden 
- it's mostly harder for people working on the runtime, who will now 
occassionally need to break out the emulator.

Note that I am still not considering Android to be a 'tier 1' platform 
(not that we have a clear definition of what that means anyway), but it 
is an important platform for both Rust and Servo.

Thank's for your patience over the next few days while we shake out the 
bugs.

Regards,
Brian

From banderson at mozilla.com  Mon Jan 27 17:25:46 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 27 Jan 2014 17:25:46 -0800
Subject: [rust-dev] Deprecating rustpkg
Message-ID: <52E7071A.50702@mozilla.com>

Hey again, Rusticians.

So I think most of us know that rustpkg isn't quite working the way 
people expect, and the general consensus seems to be that its flaws 
extend pretty deep, to the point where it may just not be exposing the 
right model. I'd like to deprecate it immediately to end the 
frustrations people continue encountering with it, while we figure out 
what to do with it.

Having a good packaging story is critical for Rust's adoption, so I want 
to keep pushing on this. I am looking into hiring a domain expert to 
help us.

Regards,
Brian



From steve at steveklabnik.com  Mon Jan 27 18:05:32 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Mon, 27 Jan 2014 18:05:32 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E7071A.50702@mozilla.com>
References: <52E7071A.50702@mozilla.com>
Message-ID: <CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>

Vote of strong support here. I removed the rustpkg chapter from Rust
for Rubyists for a reason. :/

From jeremycong at gmail.com  Mon Jan 27 20:53:14 2014
From: jeremycong at gmail.com (Jeremy Ong)
Date: Mon, 27 Jan 2014 20:53:14 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
Message-ID: <CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>

I'm somewhat new to the Rust dev scene. Would anybody care to summarize
roughly what the deficiencies are in the existing system in the interest of
forward progress? It may help seed the discussion for the next effort as
well.


On Mon, Jan 27, 2014 at 6:05 PM, Steve Klabnik <steve at steveklabnik.com>wrote:

> Vote of strong support here. I removed the rustpkg chapter from Rust
> for Rubyists for a reason. :/
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/2987b6bc/attachment.html>

From val at markovic.io  Mon Jan 27 22:20:26 2014
From: val at markovic.io (Val Markovic)
Date: Mon, 27 Jan 2014 22:20:26 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
Message-ID: <CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>

On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>
> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
roughly what the deficiencies are in the existing system in the interest of
forward progress? It may help seed the discussion for the next effort as
well.

I'd like to second this request. I haven't used rustpkg myself but I've
read its reference manual (
https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it sounds
like a reasonable design. Again, since I haven't used it, I'm sure I'm
missing some obvious flaws.

>
>
> On Mon, Jan 27, 2014 at 6:05 PM, Steve Klabnik <steve at steveklabnik.com>
wrote:
>>
>> Vote of strong support here. I removed the rustpkg chapter from Rust
>> for Rubyists for a reason. :/
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140127/2abdeee1/attachment-0001.html>

From corey at octayn.net  Mon Jan 27 22:22:46 2014
From: corey at octayn.net (Corey Richardson)
Date: Tue, 28 Jan 2014 01:22:46 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
Message-ID: <CA++BO6SC0bkRDtFPAbRkux9rPXESThwyrFvkp0omsnCmQh4fHw@mail.gmail.com>

I hadn't planned on announcing it just yet, because it's currently
going through some battle testing etc, but I have cargo-lite[0], which
is intended to be a tiny little thing that Just Works for simple
cases.

[0]: https://github.com/cmr/cargo-lite

On Tue, Jan 28, 2014 at 1:20 AM, Val Markovic <val at markovic.io> wrote:
>
> On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>>
>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>> roughly what the deficiencies are in the existing system in the interest of
>> forward progress? It may help seed the discussion for the next effort as
>> well.
>
> I'd like to second this request. I haven't used rustpkg myself but I've read
> its reference manual (
> https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it sounds
> like a reasonable design. Again, since I haven't used it, I'm sure I'm
> missing some obvious flaws.
>
>>
>>
>> On Mon, Jan 27, 2014 at 6:05 PM, Steve Klabnik <steve at steveklabnik.com>
>> wrote:
>>>
>>> Vote of strong support here. I removed the rustpkg chapter from Rust
>>> for Rubyists for a reason. :/
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From catamorphism at gmail.com  Tue Jan 28 00:02:18 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 28 Jan 2014 00:02:18 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
Message-ID: <CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>

On Mon, Jan 27, 2014 at 10:20 PM, Val Markovic <val at markovic.io> wrote:
>
> On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>>
>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>> roughly what the deficiencies are in the existing system in the interest of
>> forward progress? It may help seed the discussion for the next effort as
>> well.
>
> I'd like to second this request. I haven't used rustpkg myself but I've read
> its reference manual (
> https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it sounds
> like a reasonable design. Again, since I haven't used it, I'm sure I'm
> missing some obvious flaws.

Thirded. I implemented rustpkg as it's currently known, and did so in
the open, detailing what I was thinking about in a series of
exhaustively detailed blog posts. Since few people seemed very
interested in providing feedback on it as I was developing it (with
the exception of Graydon, who also worked on the initial design), I
assumed that it was on the right track. I rewrote rustpkg because
there was a perception that the initial design of rustpkg was not on
the right track, nor was cargo, but obviously simply rewriting the
whole system from scratch in the hopes that it would be better didn't
work, since people are talking about throwing it out. So, before
anybody embarks on a third rewrite in the hopes that *that* will be
better, I suggest that a working group form to look at what went wrong
in the past 2 or 3 attempts at implementing a build system / package
system for Rust, so that those mistakes can be learned from. Perhaps
all that needs to be done differently is that someone more central to
the community needs to write it, but if that's what it takes, it seems
preferable to the wasted time and effort that I imagine will ensue
from yet another rewrite for the sake of throwing out code.

Cheers,
Tim


>
>>
>>
>> On Mon, Jan 27, 2014 at 6:05 PM, Steve Klabnik <steve at steveklabnik.com>
>> wrote:
>>>
>>> Vote of strong support here. I removed the rustpkg chapter from Rust
>>> for Rubyists for a reason. :/
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From jurily at gmail.com  Tue Jan 28 00:36:44 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Tue, 28 Jan 2014 09:36:44 +0100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
Message-ID: <52E76C1C.50005@gmail.com>

I never quite understood the problem `rustpkg` was meant to solve. For 
building Rust code, `rustc --out-dir build` is good enough. For running 
tests and benchmarks, `rustc` is good enough. For downloading things, I 
still need to feed it a github address, which kinda takes away any value 
it could have over `git clone` or git submodules.

What I would actually need from a build system, i.e. finding 
{C,C++,Rust} libraries, building {C,C++,Rust} libraries/executables and 
linking them to said {C,C++,Rust} libraries, it doesn't do. It also 
doesn't bootstrap rustc.

[Disclaimer: I've never quite got a rustpkg workflow going. It's 
probably awesome, but completely overshadowed by `rustc`.]

On 01/28/2014 09:02 AM, Tim Chevalier wrote:
> On Mon, Jan 27, 2014 at 10:20 PM, Val Markovic <val at markovic.io> wrote:
>>
>> On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>>>
>>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>>> roughly what the deficiencies are in the existing system in the interest of
>>> forward progress? It may help seed the discussion for the next effort as
>>> well.
>>
>> I'd like to second this request. I haven't used rustpkg myself but I've read
>> its reference manual (
>> https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it sounds
>> like a reasonable design. Again, since I haven't used it, I'm sure I'm
>> missing some obvious flaws.
>
> Thirded. I implemented rustpkg as it's currently known, and did so in
> the open, detailing what I was thinking about in a series of
> exhaustively detailed blog posts. Since few people seemed very
> interested in providing feedback on it as I was developing it (with
> the exception of Graydon, who also worked on the initial design), I
> assumed that it was on the right track. I rewrote rustpkg because
> there was a perception that the initial design of rustpkg was not on
> the right track, nor was cargo, but obviously simply rewriting the
> whole system from scratch in the hopes that it would be better didn't
> work, since people are talking about throwing it out. So, before
> anybody embarks on a third rewrite in the hopes that *that* will be
> better, I suggest that a working group form to look at what went wrong
> in the past 2 or 3 attempts at implementing a build system / package
> system for Rust, so that those mistakes can be learned from. Perhaps
> all that needs to be done differently is that someone more central to
> the community needs to write it, but if that's what it takes, it seems
> preferable to the wasted time and effort that I imagine will ensue
> from yet another rewrite for the sake of throwing out code.
>
> Cheers,
> Tim

From dbau.pp at gmail.com  Tue Jan 28 01:17:23 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 28 Jan 2014 20:17:23 +1100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E76C1C.50005@gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
	<52E76C1C.50005@gmail.com>
Message-ID: <52E775A3.8040909@gmail.com>

On 28/01/14 19:36, Gy?rgy Andrasek wrote:
> I never quite understood the problem `rustpkg` was meant to solve. For 
> building Rust code, `rustc --out-dir build` is good enough. For 
> running tests and benchmarks, `rustc` is good enough. For downloading 
> things, I still need to feed it a github address, which kinda takes 
> away any value it could have over `git clone` or git submodules.

rustpkg (theoretically) manages fetching and building dependencies (with 
the appropriate versions), as well as making sure those dependencies can 
be found (i.e. what the -L flag does for rustc).

>
> What I would actually need from a build system, i.e. finding 
> {C,C++,Rust} libraries, building {C,C++,Rust} libraries/executables 
> and linking them to said {C,C++,Rust} libraries, it doesn't do. It 
> also doesn't bootstrap rustc.
>

rustpkg is unfinished and has several bugs, so describing its current 
behaviour/usage as if it were its intended behaviour/usage is not 
correct. I believe it was designed to handle native (non-Rust) 
dependencies to some degree.


Huon


> [Disclaimer: I've never quite got a rustpkg workflow going. It's 
> probably awesome, but completely overshadowed by `rustc`.]
>
> On 01/28/2014 09:02 AM, Tim Chevalier wrote:
>> On Mon, Jan 27, 2014 at 10:20 PM, Val Markovic <val at markovic.io> wrote:
>>>
>>> On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>>>>
>>>> I'm somewhat new to the Rust dev scene. Would anybody care to 
>>>> summarize
>>>> roughly what the deficiencies are in the existing system in the 
>>>> interest of
>>>> forward progress? It may help seed the discussion for the next 
>>>> effort as
>>>> well.
>>>
>>> I'd like to second this request. I haven't used rustpkg myself but 
>>> I've read
>>> its reference manual (
>>> https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it 
>>> sounds
>>> like a reasonable design. Again, since I haven't used it, I'm sure I'm
>>> missing some obvious flaws.
>>
>> Thirded. I implemented rustpkg as it's currently known, and did so in
>> the open, detailing what I was thinking about in a series of
>> exhaustively detailed blog posts. Since few people seemed very
>> interested in providing feedback on it as I was developing it (with
>> the exception of Graydon, who also worked on the initial design), I
>> assumed that it was on the right track. I rewrote rustpkg because
>> there was a perception that the initial design of rustpkg was not on
>> the right track, nor was cargo, but obviously simply rewriting the
>> whole system from scratch in the hopes that it would be better didn't
>> work, since people are talking about throwing it out. So, before
>> anybody embarks on a third rewrite in the hopes that *that* will be
>> better, I suggest that a working group form to look at what went wrong
>> in the past 2 or 3 attempts at implementing a build system / package
>> system for Rust, so that those mistakes can be learned from. Perhaps
>> all that needs to be done differently is that someone more central to
>> the community needs to write it, but if that's what it takes, it seems
>> preferable to the wasted time and effort that I imagine will ensue
>> from yet another rewrite for the sake of throwing out code.
>>
>> Cheers,
>> Tim
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From gaetan at xeberon.net  Tue Jan 28 01:32:28 2014
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 28 Jan 2014 10:32:28 +0100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E775A3.8040909@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
	<52E76C1C.50005@gmail.com> <52E775A3.8040909@gmail.com>
Message-ID: <CANK7tAEtDarsJt7hVQsrf+=xkp2zRRb8TQ__X_jd9kqMo8EbHw@mail.gmail.com>

I also agree on the task force proposal, it's the right way to capitalize
on past failure and success.

For me, rust-pkg will not success if it doesn't have a proper centralized
repository. That's a debate, the current version explicitely specify the
URL where to download stuff. But things changes, developers changes, URL
get broken, or a new developer forks a project or continue it on another
repository.

I have quite a good experience (I think) on dependency management, mostly
on C++ (QT/Linux projects and embedded) and now python (that's why I love
the simplicity and power of pipy!) so I would be glad to be associated with
such task force. For me you have two approach: "enough for major use case",
things like pipy that do the job for most use case, and "exhaustive
approach" where you end up with complicated but extremely powerful
do-it-all tools like maven but that get eventually dropped because it's too
complex to use.

That is also joining the build system thread, where also rustpkg appeared
:) But I push to split them appart: the dependency management tool should
trigger a build system and not do everything

-----
Gaetan



2014-01-28 Huon Wilson <dbau.pp at gmail.com>

> On 28/01/14 19:36, Gy?rgy Andrasek wrote:
>
>> I never quite understood the problem `rustpkg` was meant to solve. For
>> building Rust code, `rustc --out-dir build` is good enough. For running
>> tests and benchmarks, `rustc` is good enough. For downloading things, I
>> still need to feed it a github address, which kinda takes away any value it
>> could have over `git clone` or git submodules.
>>
>
> rustpkg (theoretically) manages fetching and building dependencies (with
> the appropriate versions), as well as making sure those dependencies can be
> found (i.e. what the -L flag does for rustc).
>
>
>
>> What I would actually need from a build system, i.e. finding {C,C++,Rust}
>> libraries, building {C,C++,Rust} libraries/executables and linking them to
>> said {C,C++,Rust} libraries, it doesn't do. It also doesn't bootstrap rustc.
>>
>>
> rustpkg is unfinished and has several bugs, so describing its current
> behaviour/usage as if it were its intended behaviour/usage is not correct.
> I believe it was designed to handle native (non-Rust) dependencies to some
> degree.
>
>
> Huon
>
>
>
>  [Disclaimer: I've never quite got a rustpkg workflow going. It's probably
>> awesome, but completely overshadowed by `rustc`.]
>>
>> On 01/28/2014 09:02 AM, Tim Chevalier wrote:
>>
>>> On Mon, Jan 27, 2014 at 10:20 PM, Val Markovic <val at markovic.io> wrote:
>>>
>>>>
>>>> On Jan 27, 2014 8:53 PM, "Jeremy Ong" <jeremycong at gmail.com> wrote:
>>>>
>>>>>
>>>>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>>>>> roughly what the deficiencies are in the existing system in the
>>>>> interest of
>>>>> forward progress? It may help seed the discussion for the next effort
>>>>> as
>>>>> well.
>>>>>
>>>>
>>>> I'd like to second this request. I haven't used rustpkg myself but I've
>>>> read
>>>> its reference manual (
>>>> https://github.com/mozilla/rust/blob/master/doc/rustpkg.md) and it
>>>> sounds
>>>> like a reasonable design. Again, since I haven't used it, I'm sure I'm
>>>> missing some obvious flaws.
>>>>
>>>
>>> Thirded. I implemented rustpkg as it's currently known, and did so in
>>> the open, detailing what I was thinking about in a series of
>>> exhaustively detailed blog posts. Since few people seemed very
>>> interested in providing feedback on it as I was developing it (with
>>> the exception of Graydon, who also worked on the initial design), I
>>> assumed that it was on the right track. I rewrote rustpkg because
>>> there was a perception that the initial design of rustpkg was not on
>>> the right track, nor was cargo, but obviously simply rewriting the
>>> whole system from scratch in the hopes that it would be better didn't
>>> work, since people are talking about throwing it out. So, before
>>> anybody embarks on a third rewrite in the hopes that *that* will be
>>> better, I suggest that a working group form to look at what went wrong
>>> in the past 2 or 3 attempts at implementing a build system / package
>>> system for Rust, so that those mistakes can be learned from. Perhaps
>>> all that needs to be done differently is that someone more central to
>>> the community needs to write it, but if that's what it takes, it seems
>>> preferable to the wasted time and effort that I imagine will ensue
>>> from yet another rewrite for the sake of throwing out code.
>>>
>>> Cheers,
>>> Tim
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/7810316e/attachment-0001.html>

From leebraid at gmail.com  Tue Jan 28 01:33:29 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Tue, 28 Jan 2014 09:33:29 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E76C1C.50005@gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
	<52E76C1C.50005@gmail.com>
Message-ID: <52E77969.1020902@gmail.com>

On 28/01/14 08:36, Gy?rgy Andrasek wrote:
> I never quite understood the problem `rustpkg` was meant to solve. For 
> building Rust code, `rustc --out-dir build` is good enough. For 
> running tests and benchmarks, `rustc` is good enough. For downloading 
> things, I still need to feed it a github address, which kinda takes 
> away any value it could have over `git clone` or git submodules.
>
> What I would actually need from a build system, i.e. finding 
> {C,C++,Rust} libraries, building {C,C++,Rust} libraries/executables 
> and linking them to said {C,C++,Rust} libraries, it doesn't do. It 
> also doesn't bootstrap rustc.

I agree with this.  What I'd want is much more like apt (add 
repositories, update lists of available packages from those 
repositories, manage priorities between repositories, say that one 
repository should be preferred over another for a particular package, 
working in specific prefixes (/usr/local, /usr, /, 
~/Projects/something-requiring-old-libs), but rust-specific and platform 
independent.


-- 
Lee


From jeremycong at gmail.com  Tue Jan 28 01:42:31 2014
From: jeremycong at gmail.com (Jeremy Ong)
Date: Tue, 28 Jan 2014 01:42:31 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E77969.1020902@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>
	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>
	<52E76C1C.50005@gmail.com> <52E77969.1020902@gmail.com>
Message-ID: <CALax_rxx=mBY7qjPW5hosvNtCqvy+yXJSpxEqqD_+t99uV-qKQ@mail.gmail.com>

Rubygems is, in my opinion, one of the best examples of package managers
for a programming language out there. I don't use ruby currently but I
recall liking it much more than the competition, at least as of a few years
ago. In no particular order, it features:

- central repository
- optionally specify alternative urls on a per package basis
- hard and soft version requirements
- local bundles (so you can have multiple versions of the same package and
switch seamlessly from project to project)
- dependency calculation
- dependency groups (i.e. ability to group a number of deps in a "test"
group which can be switched on or off)
- local or systemwide install of libraries and executables
- easy to write a package and publish it (very easy)
- gem signing
- plugin system that allowed extensions to be written (an example plugin
was something that allowed a gem to be compiled with specific ruby versions
iirc)
- with the bundler gem, an easy way to at a glance, examine all
dependencies of a given project and fetch them all (the Gemfile). This had
implications to deploy processes too (gemfile.lock).

This isn't a comprehensive list but it evidently made an impression on me.
I'm sure there are tons of other things I'm missing. Other systems that
I've worked with I found critically lacking in isolating the dependencies
of one project from another or failing to resolve dependency trees
satisfactorily. Most importantly, the ease with which packages could be
downloaded and used immediately were immense.

As mentioned before, getting this right is crucial to establishing a
vibrant developer ecosystem (see rubygems and npm).


On Tue, Jan 28, 2014 at 1:33 AM, Lee Braiden <leebraid at gmail.com> wrote:

> On 28/01/14 08:36, Gy?rgy Andrasek wrote:
>
>> I never quite understood the problem `rustpkg` was meant to solve. For
>> building Rust code, `rustc --out-dir build` is good enough. For running
>> tests and benchmarks, `rustc` is good enough. For downloading things, I
>> still need to feed it a github address, which kinda takes away any value it
>> could have over `git clone` or git submodules.
>>
>> What I would actually need from a build system, i.e. finding {C,C++,Rust}
>> libraries, building {C,C++,Rust} libraries/executables and linking them to
>> said {C,C++,Rust} libraries, it doesn't do. It also doesn't bootstrap rustc.
>>
>
> I agree with this.  What I'd want is much more like apt (add repositories,
> update lists of available packages from those repositories, manage
> priorities between repositories, say that one repository should be
> preferred over another for a particular package, working in specific
> prefixes (/usr/local, /usr, /, ~/Projects/something-requiring-old-libs),
> but rust-specific and platform independent.
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/2f489e95/attachment.html>

From jurily at gmail.com  Tue Jan 28 02:38:27 2014
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Tue, 28 Jan 2014 11:38:27 +0100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E77969.1020902@gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>	<52E76C1C.50005@gmail.com>
	<52E77969.1020902@gmail.com>
Message-ID: <52E788A3.8080607@gmail.com>

On 01/28/2014 10:33 AM, Lee Braiden wrote:
> I agree with this.  What I'd want is much more like apt (add
> repositories, update lists of available packages from those
> repositories, manage priorities between repositories, say that one
> repository should be preferred over another for a particular package,
> working in specific prefixes (/usr/local, /usr, /,
> ~/Projects/something-requiring-old-libs), but rust-specific and platform
> independent.

What you actually want is Paludis[0], which installs from source. I'd 
propose it as a standard Rust package manager, but it does have some 
serious flaws for that purpose:

- Designed as the package manager for a full Linux distro, so it wants 
to handle everything by itself. If you give it a build dependency on 
gcc, it'll want to maintain the entire toolchain.
- No Windows support.
- Hard dependency on `bash`.

That said, it has solved a serious number of PM problems we should learn 
from:

- Completely build system agnostic. All tooling is done in bash 
libraries called `exheres`, with an infinite number of customization 
hooks from patching to post-install. Can build everything from glibc to 
xmonad.
- Separate set of build and run dependencies, with configurable install 
root: you can (probably) bootstrap an embedded Linux with it.
- Metadata lives in a number of git repos you can cherry-pick. Creating 
your own is *easy*.
- Some support for external package sources, like Hackage.
- Fast[1] dependency handling including cycles and both global and local 
keywords: `doc` pulls in the doc build tools, `bash_completion` installs 
relevant extra files, `texture-float` enables patented code in mesa.
- Installing from source control.
- All user-facing configuration is done in /etc/paludis, where you can 
apply keywords, CFLAGS, mirrors, scm options, mask/unmask packages etc. 
on a per-package per-version basis with globs and stuff.


tl;dr If you want to design a package manager, bootstrap an Exherbo[2] 
first.




[0]: http://paludis.exherbo.org/overview/features.html
[2]: http://exherbo.org/
[1]:
```
# time cave resolve world --everything
Done: 2501 steps
<snip>
Executing pretend actions: 265 of 265

  * You have 6 unread news items (use 'eclectic news' to read)

real    0m16.108s
user    0m12.706s
sys     0m1.643s
```

From leafstormrush at gmail.com  Tue Jan 28 03:23:09 2014
From: leafstormrush at gmail.com (Matthew Frazier)
Date: Tue, 28 Jan 2014 06:23:09 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E77969.1020902@gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>	<CAK9U+m3Np2E8tVmM6MByab-UnJX-4jodz7Zj4AkMqG+Fcha16w@mail.gmail.com>	<CADcg8==J+7cZuhb=6LUi0w7CE1mv9He4K_ikzozeds_tqnZdTA@mail.gmail.com>	<52E76C1C.50005@gmail.com>
	<52E77969.1020902@gmail.com>
Message-ID: <52E7931D.70808@gmail.com>

On 01/28/2014 04:33 AM, Lee Braiden wrote:
> On 28/01/14 08:36, Gy?rgy Andrasek wrote:
>> I never quite understood the problem `rustpkg` was meant to solve. For
>> building Rust code, `rustc --out-dir build` is good enough. For
>> running tests and benchmarks, `rustc` is good enough. For downloading
>> things, I still need to feed it a github address, which kinda takes
>> away any value it could have over `git clone` or git submodules.
>>
>> What I would actually need from a build system, i.e. finding
>> {C,C++,Rust} libraries, building {C,C++,Rust} libraries/executables
>> and linking them to said {C,C++,Rust} libraries, it doesn't do. It
>> also doesn't bootstrap rustc.
>
> I agree with this.  What I'd want is much more like apt (add
> repositories, update lists of available packages from those
> repositories, manage priorities between repositories, say that one
> repository should be preferred over another for a particular package,
> working in specific prefixes (/usr/local, /usr, /,
> ~/Projects/something-requiring-old-libs), but rust-specific and platform
> independent.

Have you ever used Composer <https://getcomposer.org/>? I know that 
Jordi Boggiano, one of the authors, has been involved with the Rust 
community in the past. Some Composer features that I think are critical 
for the new Rust package manager include:

- Tags and branches are automatically recognized from git to create 
versions.

- Version specifiers aren't just limited to "this version exactly," but 
allow you to match on a range of versions (though Semantic Versioning is 
encouraged).

- Packages have vendor prefixes (like rust/flate or 
leafstorm/mycoollibrary) to help avoid name conflicts and allow for 
forking, but these aren't linked to the way packages are retrieved.

- There's a central repository, but it's really easy to add random git 
repositories to the composer.json, or to create your own repositories 
for internal use.

- It automatically generates a lock file that allows you to reinstall 
exactly the same versions of the dependencies across machines.

- Everything is installed per-project, so no conflicts across projects. 
(Though the new rustpkg may want to not do this exactly because of 
compile times.)

If I had more time and more Rust experience, I would be interested in 
implementing a Composer-like package manager for Rust. Unfortunately I 
have little of both. :-(
-- 
Thanks,
Matthew Frazier
http://leafstorm.us

From niko at alum.mit.edu  Tue Jan 28 05:45:30 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Tue, 28 Jan 2014 08:45:30 -0500
Subject: [rust-dev] RFC: Future-proof for unboxed closures
In-Reply-To: <CAPoegszPXo4ZhsMeAu068pHAv-Z9fO-9y+-co=F_=iS_tvd2kg@mail.gmail.com>
References: <52C1E17F.2010809@mozilla.com>
	<CAPoegsyhn=iRNAq3MmmMJ+dNpO1Rf8g1g8ErW0vpS974wGCnfQ@mail.gmail.com>
	<4cdd55c6-e3ba-49d9-8885-2cb7725bbb3f@email.android.com>
	<20140125053100.GH5744@Mr-Bennet>
	<CAPoegszVH_P4Km1h3bCE38HfV-ExGt_c_kbsa1j6qZ55NLmZZw@mail.gmail.com>
	<20140127110351.GC9131@Mr-Bennet>
	<CAPoegszPXo4ZhsMeAu068pHAv-Z9fO-9y+-co=F_=iS_tvd2kg@mail.gmail.com>
Message-ID: <20140128134530.GA27317@Mr-Bennet>

On Mon, Jan 27, 2014 at 08:33:57PM +0100, G?bor Lehel wrote:
> I think this question has a more general form, namely: when should I pass
> by value and when using &move/&my? I expect this will come up quite a bit
> if we add the latter.

Yes, I agree. The main reason to use `&move/&my` is to permit moves of
dynamically sized types. In the case of once closures, that is a trait
type. Given that, I have wondered if we can do without it, and instead
say that (e.g.) passing a DST as a by value argument is legal. Without
a region, though, we'd need some other rules to prevent that DST from
leaking. For example, you can pass a DST as an input parameter, but
you cannot have a local variable, field, or return type of DST type.

The last time I thought this through, those rules (or something like
them) seemed onerous, but now they seem quite reasonable to me. (More
or less the same as our old reference mode parameters.) They support
the important use case of passing in a (unboxed) `OnceFn` object and
permitting it to be called.


Niko

From slabode at aim.com  Tue Jan 28 08:46:28 2014
From: slabode at aim.com (SiegeLord)
Date: Tue, 28 Jan 2014 11:46:28 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
Message-ID: <52E7DEE4.6000106@aim.com>

On 01/27/2014 11:53 PM, Jeremy Ong wrote:
> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
> roughly what the deficiencies are in the existing system in the interest
> of forward progress? It may help seed the discussion for the next effort
> as well.

I can only speak for myself, but here are some reasons why I abandoned 
rustpkg and switched to CMake.

Firstly, and overarchingly, it was the attitude of the project 
development with respect to issues. As a comparison, let me consider 
Rust the language. It is a pain to make my code pass the borrow check 
sometimes, the lifetimes are perhaps the most frustrating aspect of 
Rust. I put up with them however, because they solve a gigantic problem 
and are the keystone of Rust's safety-without-GC story. rustpkg also has 
many incredibly frustrating aspects, but they are there (in my opinion) 
arbitrarily and not as a solution to any real problem. When I hit them, 
I do not get the same sense of purposeful sacrifice I get with Rust's 
difficult points. Let me outline the specific issues I personally hit (I 
know of other ones, but I haven't encountered them personally).

Conflation of package id and source. That fact combined with the fact 
that to depend on some external package you have to write "extern mod = 
pkgid" meant that you needed to create bizarre directory structures to 
depend on locally developed packages (e.g. you'd have to put your 
locally developed project in a directory tree like so: 
github.com/SiegeLord/Project). This is not something I was going to do.

The package dependencies are written in the source file, which makes it 
onerous to switch between versions/forks. A simple package script would 
have solved it, but it wasn't present by design.

My repositories have multiple crates, and rustpkg is woefully 
under-equipped to handle that case. You cannot build them without 
dealing with pkg.rs, and using them from other projects seemed 
impossible too (the extern mod syntax wasn't equipped to handle multiple 
crates per package). This is particularly vexing when you have multiple 
example programs alongside your library. I was not going to split my 
repository up just because rustpkg wasn't designed to handle that case.

All of those points would be solved by having an explicit package 
description file/script which was THE overarching design non-goal of 
rustpkg. After that was made clear to me, I just ditched it and went to 
C++ style package "management" and a CMake build system.

-SL

From matthieu.monrocq at gmail.com  Tue Jan 28 11:07:25 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Tue, 28 Jan 2014 20:07:25 +0100
Subject: [rust-dev] Today's Rust contribution ideas
In-Reply-To: <CAGZgfT7tu+9i3S-W8V=Lod318AnfCM4G2afdjm8_kv7NNbv1-w@mail.gmail.com>
References: <52E5C6F8.8080402@mozilla.com>
	<CAKE6RfhxLKkx-NL1BGkp5HSa5sX80DiOf91zRGNYb-qO0Ktk-g@mail.gmail.com>
	<CAGZgfT7tu+9i3S-W8V=Lod318AnfCM4G2afdjm8_kv7NNbv1-w@mail.gmail.com>
Message-ID: <CAKE6RfhqD2zusn1Y_Egs_kyCD6M_a1+0VJN29_pTsfic6Pp6Dg@mail.gmail.com>

On Mon, Jan 27, 2014 at 11:41 PM, Sebastian Sylvan <
sebastian.sylvan at gmail.com> wrote:

>
>
>
> On Mon, Jan 27, 2014 at 9:33 AM, Matthieu Monrocq <
> matthieu.monrocq at gmail.com> wrote:
>
>>
>>
>>
>> On Mon, Jan 27, 2014 at 3:39 AM, Brian Anderson <banderson at mozilla.com>wrote:
>>
>>>
>>> Consensus is that the `do` keyword is no longer pulling its weight.
>>> Remove all uses of it, then remove support from the compiler. This is a 1.0
>>> issue.
>>>
>>> # Experiment with faster hash maps (#11783)
>>>
>>> Rust's HashMap uses a cryptographically secure hash, and at least partly
>>> as a result of that it is quite slow. HashMap continues to show up very,
>>> very high in performance profiles of a variety of code. It's not clear what
>>> the solution to this is, but it is clear that - at least sometimes - we
>>> need a much faster hash map solution. Figure out how to create faster hash
>>> maps in Rust, potentially sacrificing some amount of DOS-resistance by
>>> using weaker hash functions. This is fairly open-ended and researchy, but a
>>> solution to this could have a big impact on the performance of rustc and
>>> other projects.
>>>
>>
>> You might be interested by a serie of articles by Joaqu?n M L?pez Mu?oz
>> who maintains the Boost.MultiIndex library. He did a relatively
>> comprehensive overview of the hash-maps implementation of Dirkumware
>> (MSVC), libstdc++ and libc++ on top of Boost.MultiIndex, and a lot of
>> benchmarks showing the performance for insertion/removal/search in a
>> variety of setup.
>>
>> One of the last articles:
>> http://bannalia.blogspot.fr/2014/01/a-better-hash-table-clang.html
>>
>
> Let me also plug this blog post from a while back:
> http://sebastiansylvan.com/2013/05/08/robin-hood-hashing-should-be-your-default-hash-table-implementation/. There's also a followup on improving deletions*, which makes the final
> form the fastest hash map I know of. It's also compact (95% load factor, 32
> bits overhead per element, but you can reduce that to 2 bits per element if
> you sacrifice some perf.), and doesn't allocate (other than doubling the
> size of the table when you hit the load factor).
>
> For a benchmark with lots of std::strings it was 23%, 66% and 25% faster
> for insertions deletions and lookups (compared to MSVC unordered_map), it
> also uses 30% less memory in that case.
>
> Seb
>
> * the basic form has an issue where repeated deletes gradually increases
> the probe count. In pathological cases this can reduce performance by a
> lot. The fix is to incrementally fix up the table on each delete (you could
> also do it in batch every now and then). It's still faster in all cases,
> and the probe-length as well as probe-length-variance remains low even in
> the most pathological circumstances.
>

Thanks for the link, I should have mentioned that the C++ Standard version
is constrained by a memory stability requirement which may or may not apply
to Rust (thanks to borrow checks, it should be possible to know statically
whether an element is borrowed or not). This memory stability requirement
as well as some other requirements such as relative stability of items
within the same equivalence class during insert/erase several constrain the
design; and indeed if the requirements can be lifted it the designs
proposed on bannalia will be suboptimal.

-- Matthieu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/8ae8d370/attachment.html>

From explodingmind at gmail.com  Tue Jan 28 11:28:22 2014
From: explodingmind at gmail.com (Ian Daniher)
Date: Tue, 28 Jan 2014 14:28:22 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E7DEE4.6000106@aim.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<52E7DEE4.6000106@aim.com>
Message-ID: <CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>

Lots of good points in this thread, but I wanted to request deprecation,
but not removal until a better alternative is documented and made
available. Rustpkg works for my needs - I use it every day -  but it
definitely needs some TLC.

Thanks!
--
Ian


On Tue, Jan 28, 2014 at 11:46 AM, SiegeLord <slabode at aim.com> wrote:

> On 01/27/2014 11:53 PM, Jeremy Ong wrote:
>
>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>> roughly what the deficiencies are in the existing system in the interest
>> of forward progress? It may help seed the discussion for the next effort
>> as well.
>>
>
> I can only speak for myself, but here are some reasons why I abandoned
> rustpkg and switched to CMake.
>
> Firstly, and overarchingly, it was the attitude of the project development
> with respect to issues. As a comparison, let me consider Rust the language.
> It is a pain to make my code pass the borrow check sometimes, the lifetimes
> are perhaps the most frustrating aspect of Rust. I put up with them
> however, because they solve a gigantic problem and are the keystone of
> Rust's safety-without-GC story. rustpkg also has many incredibly
> frustrating aspects, but they are there (in my opinion) arbitrarily and not
> as a solution to any real problem. When I hit them, I do not get the same
> sense of purposeful sacrifice I get with Rust's difficult points. Let me
> outline the specific issues I personally hit (I know of other ones, but I
> haven't encountered them personally).
>
> Conflation of package id and source. That fact combined with the fact that
> to depend on some external package you have to write "extern mod = pkgid"
> meant that you needed to create bizarre directory structures to depend on
> locally developed packages (e.g. you'd have to put your locally developed
> project in a directory tree like so: github.com/SiegeLord/Project). This
> is not something I was going to do.
>
> The package dependencies are written in the source file, which makes it
> onerous to switch between versions/forks. A simple package script would
> have solved it, but it wasn't present by design.
>
> My repositories have multiple crates, and rustpkg is woefully
> under-equipped to handle that case. You cannot build them without dealing
> with pkg.rs, and using them from other projects seemed impossible too
> (the extern mod syntax wasn't equipped to handle multiple crates per
> package). This is particularly vexing when you have multiple example
> programs alongside your library. I was not going to split my repository up
> just because rustpkg wasn't designed to handle that case.
>
> All of those points would be solved by having an explicit package
> description file/script which was THE overarching design non-goal of
> rustpkg. After that was made clear to me, I just ditched it and went to C++
> style package "management" and a CMake build system.
>
> -SL
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/88bc67db/attachment.html>

From jayhawk at cs.ucsc.edu  Tue Jan 28 11:29:44 2014
From: jayhawk at cs.ucsc.edu (Noah Watkins)
Date: Tue, 28 Jan 2014 11:29:44 -0800
Subject: [rust-dev] Function shipping
Message-ID: <CAPrxi59Dbrt5eZw73QQHsHr_T7uORF-yWaXwFbAgYc1dDBp-3Q@mail.gmail.com>

This question regarding the run-time generation and compilation of
code was asked about a year ago.

  http://stackoverflow.com/questions/14459647/is-it-possible-to-generate-and-execute-rust-code-at-runtime

I'd like to follow up on that to see if there are any more
developments. It would be particularly useful to be able to ship a
closure to be executed remotely.

Thanks,
Noah

From kevin at sb.org  Tue Jan 28 11:43:03 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 11:43:03 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<52E7DEE4.6000106@aim.com>
	<CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>
Message-ID: <C4A86B58-03C8-4CE5-B69A-FA319DA958B4@sb.org>

Keeping it around means maintaining it, and it means tempting people to use it even though it's deprecated.

My suggestion would be, if you really need rustpkg, then extract it into a separate repo and maintain it there. But get it out of the mozilla/rust tree.

-Kevin

On Jan 28, 2014, at 11:28 AM, Ian Daniher <explodingmind at gmail.com> wrote:

> Lots of good points in this thread, but I wanted to request deprecation, but not removal until a better alternative is documented and made available. Rustpkg works for my needs - I use it every day -  but it definitely needs some TLC.
> 
> Thanks!
> --
> Ian
> 
> 
> On Tue, Jan 28, 2014 at 11:46 AM, SiegeLord <slabode at aim.com> wrote:
> On 01/27/2014 11:53 PM, Jeremy Ong wrote:
> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
> roughly what the deficiencies are in the existing system in the interest
> of forward progress? It may help seed the discussion for the next effort
> as well.
> 
> I can only speak for myself, but here are some reasons why I abandoned rustpkg and switched to CMake.
> 
> Firstly, and overarchingly, it was the attitude of the project development with respect to issues. As a comparison, let me consider Rust the language. It is a pain to make my code pass the borrow check sometimes, the lifetimes are perhaps the most frustrating aspect of Rust. I put up with them however, because they solve a gigantic problem and are the keystone of Rust's safety-without-GC story. rustpkg also has many incredibly frustrating aspects, but they are there (in my opinion) arbitrarily and not as a solution to any real problem. When I hit them, I do not get the same sense of purposeful sacrifice I get with Rust's difficult points. Let me outline the specific issues I personally hit (I know of other ones, but I haven't encountered them personally).
> 
> Conflation of package id and source. That fact combined with the fact that to depend on some external package you have to write "extern mod = pkgid" meant that you needed to create bizarre directory structures to depend on locally developed packages (e.g. you'd have to put your locally developed project in a directory tree like so: github.com/SiegeLord/Project). This is not something I was going to do.
> 
> The package dependencies are written in the source file, which makes it onerous to switch between versions/forks. A simple package script would have solved it, but it wasn't present by design.
> 
> My repositories have multiple crates, and rustpkg is woefully under-equipped to handle that case. You cannot build them without dealing with pkg.rs, and using them from other projects seemed impossible too (the extern mod syntax wasn't equipped to handle multiple crates per package). This is particularly vexing when you have multiple example programs alongside your library. I was not going to split my repository up just because rustpkg wasn't designed to handle that case.
> 
> All of those points would be solved by having an explicit package description file/script which was THE overarching design non-goal of rustpkg. After that was made clear to me, I just ditched it and went to C++ style package "management" and a CMake build system.
> 
> -SL
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/000ccbc2/attachment.html>

From philippe.delrieu at free.fr  Tue Jan 28 11:43:50 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 28 Jan 2014 20:43:50 +0100
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <52E52901.7020403@free.fr>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
	<52E52901.7020403@free.fr>
Message-ID: <52E80876.70805@free.fr>

Any info or idea?
I update from the master and now all my project have the same issue.
If I use rustc I have no problem. I see the thread about rustpkg, 
perhaps I should migrate to rustc and cmake?

Philippe

Le 26/01/2014 16:25, Philippe Delrieu a ?crit :
> Hi,
>
> I have the same problem since 2 or 3 days with the portmidi project.
>
> Philippe
>
> Le 26/01/2014 14:06, Cadence Marseille a ?crit :
>> Hi,
>>
>> I am seeing a new build error and I am not sure what is causing it. 
>> rust-pcre <https://github.com/cadencemarseille/rust-pcre>, libpcre 
>> bindings for Rust, is set up to use Travis and Rust CI 
>> <http://rust-ci.org/>.  The latest build is failing with:
>>
>> rustpkg install pcre
>>
>> WARNING: The Rust package manager is experimental and may be unstable
>>
>> error: Package pcre depends on extra, but I don't know how to find it
>>
>> task '<unnamed>' failed at 'explicit failure', 
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/util.rs:531 
>> <http://util.rs:531>
>>
>> task '<main>' failed at 'receiving on a closed channel', 
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/mod.rs:743 
>> <http://mod.rs:743>
>>
>> task '<unnamed>' failed at 'Error running custom build command', 
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/lib.rs:517 
>> <http://lib.rs:517>
>>
>> make: *** [install] Error 65
>>
>>
>> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>>
>> I looked at some other Rust CI-enabled projects and found a similar 
>> error:
>> https://travis-ci.org/eholk/rust-opencl/builds/17491630
>> https://travis-ci.org/erickt/rust-zmq/builds/16353359
>> https://travis-ci.org/erickt/rust-mustache/builds/16059551
>> https://travis-ci.org/bjz/gl-rs/builds/16126945
>> https://travis-ci.org/bjz/sax-rs/builds/16405581
>>
>> What is causing this error and how do I fix it?
>>
>> Cadence
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/094daefd/attachment.html>

From a.stavonin at gmail.com  Tue Jan 28 11:48:27 2014
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Tue, 28 Jan 2014 23:48:27 +0400
Subject: [rust-dev] static mut and owning pointers
Message-ID: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>

Hi all! I?m not sure is it an error or "static mut" variables misunderstanding from my side. The source:

struct MyStruct {
    val: int
}

static mut global_data: Option<~MyStruct> = None;

fn test_call() {
    unsafe {
        match global_data {
            Some(data) => { println!("We have data {:?}", data);}
            None => { println!("We don't have data");}
        }
    }
}

fn main() {

    unsafe {
        global_data = Some(~MyStruct{val: 42});
    }

    test_call();
    test_call();
}

and output:

We have data ~MyStruct{val: 42}
We don't have data

But if I?m changing global_data from Option<~MyStruct> to Option<MyStruct> output is changed also:

We have data ~MyStruct{val: 42}
We have data ~MyStruct{val: 42}

Is it normal behaviour and owning pointers cannot be stored in global variables or an error?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/63c6a198/attachment.html>

From corey at octayn.net  Tue Jan 28 11:57:03 2014
From: corey at octayn.net (Corey Richardson)
Date: Tue, 28 Jan 2014 11:57:03 -0800 (PST)
Subject: [rust-dev] Function shipping
References: <CAPrxi59Dbrt5eZw73QQHsHr_T7uORF-yWaXwFbAgYc1dDBp-3Q@mail.gmail.com>
Message-ID: <1390939016490.b906aedba66c2@mozgaia>

No change. JITing code is very unlikely to be added to the language, too complex. You should instead consider using a scripting language such as lua or chibi-scheme to send computations across a network

Noah Watkins wrote:
> This question regarding the run-time generation and compilation of
> code was asked about a year ago.
>
>   http://stackoverflow.com/questions/14459647/is-it-possible-to-generate-and-execute-rust-code-at-runtime
>
> I'd like to follow up on that to see if there are any more
> developments. It would be particularly useful to be able to ship a
> closure to be executed remotely.
>
> Thanks,
> Noah

From kevin at sb.org  Tue Jan 28 12:12:23 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 12:12:23 -0800
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
Message-ID: <E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>

Your code is moving the contents of Option<~MyStruct> into the match arm. It just so happens that this seems to be zeroing out the original pointer in memory, and that happens to be the same representation that None does for the type Option<~MyStruct> (since ~ pointers are non-nullable), so the act of moving the value just happens to be transforming it into a None.

Normally you couldn't do this, but mutable statics are weird (which is why you need the unsafe block to access it).

When you remove the ~, the lines end up printing the same because MyStruct is implicitly copyable, so your match arm is now copying instead of moving.

The correct fix here is to use `Some(ref data)` instead of `Some(data)`. This will take a reference to the data instead of moving it, and the static will remain unchanged.

-Kevin

On Jan 28, 2014, at 11:48 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:

> Hi all! I?m not sure is it an error or "static mut" variables misunderstanding from my side. The source:
> 
> struct MyStruct {
>     val: int
> }
> 
> static mut global_data: Option<~MyStruct> = None;
> 
> fn test_call() {
>     unsafe {
>         match global_data {
>             Some(data) => { println!("We have data {:?}", data);}
>             None => { println!("We don't have data");}
>         }
>     }
> }
> 
> fn main() {
> 
>     unsafe {
>         global_data = Some(~MyStruct{val: 42});
>     }
> 
>     test_call();
>     test_call();
> }
> 
> and output:
> 
> We have data ~MyStruct{val: 42}
> We don't have data
> 
> But if I?m changing global_data from Option<~MyStruct> to Option<MyStruct> output is changed also:
> 
> We have data ~MyStruct{val: 42}
> We have data ~MyStruct{val: 42}
> 
> Is it normal behaviour and owning pointers cannot be stored in global variables or an error?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/d17a07c7/attachment.html>

From a.stavonin at gmail.com  Tue Jan 28 12:17:56 2014
From: a.stavonin at gmail.com (Alexander Stavonin)
Date: Wed, 29 Jan 2014 00:17:56 +0400
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
	<E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
Message-ID: <85B79585-D970-4A0D-87F1-7EF6F69C2DDC@gmail.com>

Thanks, Kevin!

On 29 Jan 2014, at 00:12, Kevin Ballard <kevin at sb.org> wrote:

> Your code is moving the contents of Option<~MyStruct> into the match arm. It just so happens that this seems to be zeroing out the original pointer in memory, and that happens to be the same representation that None does for the type Option<~MyStruct> (since ~ pointers are non-nullable), so the act of moving the value just happens to be transforming it into a None.
> 
> Normally you couldn't do this, but mutable statics are weird (which is why you need the unsafe block to access it).
> 
> When you remove the ~, the lines end up printing the same because MyStruct is implicitly copyable, so your match arm is now copying instead of moving.
> 
> The correct fix here is to use `Some(ref data)` instead of `Some(data)`. This will take a reference to the data instead of moving it, and the static will remain unchanged.
> 
> -Kevin

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/b3b53552/attachment.html>

From bascule at gmail.com  Tue Jan 28 12:32:45 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Tue, 28 Jan 2014 12:32:45 -0800
Subject: [rust-dev] Function shipping
In-Reply-To: <CAPrxi59Dbrt5eZw73QQHsHr_T7uORF-yWaXwFbAgYc1dDBp-3Q@mail.gmail.com>
References: <CAPrxi59Dbrt5eZw73QQHsHr_T7uORF-yWaXwFbAgYc1dDBp-3Q@mail.gmail.com>
Message-ID: <CAHOTMVL-9Sm2S+8D5qZWZk8+SUX6A6XkpTo33V0r-G9nMJZ+6w@mail.gmail.com>

On Tuesday, January 28, 2014, Noah Watkins <jayhawk at cs.ucsc.edu> wrote:

> It would be particularly useful to be able to ship a
> closure to be executed remotely.
>

The only language I've seen do this well is Erlang, and it still requires
both nodes have the same version of the same module loaded at the same time.



-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/19243547/attachment.html>

From bombela at gmail.com  Tue Jan 28 13:00:21 2014
From: bombela at gmail.com (=?ISO-8859-1?Q?Fran=E7ois=2DXavier_Bourlet?=)
Date: Tue, 28 Jan 2014 13:00:21 -0800
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
Message-ID: <CAG9r-Da6EsB4ygzLOUo_ViHguzCOPFo0kK3A_ohkOFeNaaryxg@mail.gmail.com>

match global_data {
            Some(data) =>

You should be able to do:
  Some(ref data)

Which will take a reference instead of moving the owned pointer.

In the second case (no owned pointer) you are actually copying the
struct everything. Using "ref data" would safe a copy as well.

I might be wrong, I am a newcomer on rust :)

On Tue, Jan 28, 2014 at 11:48 AM, Alexander Stavonin
<a.stavonin at gmail.com> wrote:
> Hi all! I'm not sure is it an error or "static mut" variables
> misunderstanding from my side. The source:
>
> struct MyStruct {
>     val: int
> }
>
> static mut global_data: Option<~MyStruct> = None;
>
> fn test_call() {
>     unsafe {
>         match global_data {
>             Some(data) => { println!("We have data {:?}", data);}
>             None => { println!("We don't have data");}
>         }
>     }
> }
>
> fn main() {
>
>     unsafe {
>         global_data = Some(~MyStruct{val: 42});
>     }
>
>     test_call();
>     test_call();
> }
>
> and output:
>
> We have data ~MyStruct{val: 42}
> We don't have data
>
> But if I'm changing global_data from Option<~MyStruct> to Option<MyStruct>
> output is changed also:
>
> We have data ~MyStruct{val: 42}
> We have data ~MyStruct{val: 42}
>
> Is it normal behaviour and owning pointers cannot be stored in global
> variables or an error?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From bombela at gmail.com  Tue Jan 28 13:02:56 2014
From: bombela at gmail.com (=?ISO-8859-1?Q?Fran=E7ois=2DXavier_Bourlet?=)
Date: Tue, 28 Jan 2014 13:02:56 -0800
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <CAG9r-Da6EsB4ygzLOUo_ViHguzCOPFo0kK3A_ohkOFeNaaryxg@mail.gmail.com>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
	<CAG9r-Da6EsB4ygzLOUo_ViHguzCOPFo0kK3A_ohkOFeNaaryxg@mail.gmail.com>
Message-ID: <CAG9r-DZumr7P_QS3UxfwyFHNi1Zco21q-PeCDnGszQaPA3aT5Q@mail.gmail.com>

damned, my gmail client was not up to date, you've got a better answer
already (I got the ref keyword right at least ;))

On Tue, Jan 28, 2014 at 1:00 PM, Fran?ois-Xavier Bourlet
<bombela at gmail.com> wrote:
> match global_data {
>             Some(data) =>
>
> You should be able to do:
>   Some(ref data)
>
> Which will take a reference instead of moving the owned pointer.
>
> In the second case (no owned pointer) you are actually copying the
> struct everything. Using "ref data" would safe a copy as well.
>
> I might be wrong, I am a newcomer on rust :)
>
> On Tue, Jan 28, 2014 at 11:48 AM, Alexander Stavonin
> <a.stavonin at gmail.com> wrote:
>> Hi all! I'm not sure is it an error or "static mut" variables
>> misunderstanding from my side. The source:
>>
>> struct MyStruct {
>>     val: int
>> }
>>
>> static mut global_data: Option<~MyStruct> = None;
>>
>> fn test_call() {
>>     unsafe {
>>         match global_data {
>>             Some(data) => { println!("We have data {:?}", data);}
>>             None => { println!("We don't have data");}
>>         }
>>     }
>> }
>>
>> fn main() {
>>
>>     unsafe {
>>         global_data = Some(~MyStruct{val: 42});
>>     }
>>
>>     test_call();
>>     test_call();
>> }
>>
>> and output:
>>
>> We have data ~MyStruct{val: 42}
>> We don't have data
>>
>> But if I'm changing global_data from Option<~MyStruct> to Option<MyStruct>
>> output is changed also:
>>
>> We have data ~MyStruct{val: 42}
>> We have data ~MyStruct{val: 42}
>>
>> Is it normal behaviour and owning pointers cannot be stored in global
>> variables or an error?
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>

From catamorphism at gmail.com  Tue Jan 28 13:29:48 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 28 Jan 2014 13:29:48 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<52E7DEE4.6000106@aim.com>
	<CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>
Message-ID: <CADcg8==Hxyzwoa9swZ8SicxPHcdC+703BUZ7rRyGyoXmAE3K4A@mail.gmail.com>

rustpkg is definitely unfinished. It's not clear to me that what it
needs is to be destroyed, rather than finished. That is, there may
well be good reasons; I just haven't seen them so far in this thread.
The concrete points that a few people have made are ones to do with
unfinished pieces of rustpkg that are relatively well-delineated from
the entire system.

I'm not trying to argue for keeping it, it just seems to me that for
the good of the project, the reasons why it couldn't be salvaged
should be documented somewhere. As the person who did most of the
work, but wasn't able to finish it because I left Mozilla, it's
surprising to me that the fact that rustpkg isn't finished is being
used as a reason to purge it entirely. Rust is, after all, not
finished yet -- as a whole -- but we're not throwing out the entire
language.

Cheers,
Tim


On Tue, Jan 28, 2014 at 11:28 AM, Ian Daniher <explodingmind at gmail.com> wrote:
> Lots of good points in this thread, but I wanted to request deprecation, but
> not removal until a better alternative is documented and made available.
> Rustpkg works for my needs - I use it every day -  but it definitely needs
> some TLC.
>
> Thanks!
> --
> Ian
>
>
> On Tue, Jan 28, 2014 at 11:46 AM, SiegeLord <slabode at aim.com> wrote:
>>
>> On 01/27/2014 11:53 PM, Jeremy Ong wrote:
>>>
>>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
>>> roughly what the deficiencies are in the existing system in the interest
>>> of forward progress? It may help seed the discussion for the next effort
>>> as well.
>>
>>
>> I can only speak for myself, but here are some reasons why I abandoned
>> rustpkg and switched to CMake.
>>
>> Firstly, and overarchingly, it was the attitude of the project development
>> with respect to issues. As a comparison, let me consider Rust the language.
>> It is a pain to make my code pass the borrow check sometimes, the lifetimes
>> are perhaps the most frustrating aspect of Rust. I put up with them however,
>> because they solve a gigantic problem and are the keystone of Rust's
>> safety-without-GC story. rustpkg also has many incredibly frustrating
>> aspects, but they are there (in my opinion) arbitrarily and not as a
>> solution to any real problem. When I hit them, I do not get the same sense
>> of purposeful sacrifice I get with Rust's difficult points. Let me outline
>> the specific issues I personally hit (I know of other ones, but I haven't
>> encountered them personally).
>>
>> Conflation of package id and source. That fact combined with the fact that
>> to depend on some external package you have to write "extern mod = pkgid"
>> meant that you needed to create bizarre directory structures to depend on
>> locally developed packages (e.g. you'd have to put your locally developed
>> project in a directory tree like so: github.com/SiegeLord/Project). This is
>> not something I was going to do.
>>
>> The package dependencies are written in the source file, which makes it
>> onerous to switch between versions/forks. A simple package script would have
>> solved it, but it wasn't present by design.
>>
>> My repositories have multiple crates, and rustpkg is woefully
>> under-equipped to handle that case. You cannot build them without dealing
>> with pkg.rs, and using them from other projects seemed impossible too (the
>> extern mod syntax wasn't equipped to handle multiple crates per package).
>> This is particularly vexing when you have multiple example programs
>> alongside your library. I was not going to split my repository up just
>> because rustpkg wasn't designed to handle that case.
>>
>> All of those points would be solved by having an explicit package
>> description file/script which was THE overarching design non-goal of
>> rustpkg. After that was made clear to me, I just ditched it and went to C++
>> style package "management" and a CMake build system.
>>
>> -SL
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From ptalbot at hyc.io  Tue Jan 28 14:15:03 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Tue, 28 Jan 2014 23:15:03 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
Message-ID: <52E82BE7.3010502@hyc.io>

Hi,

The Mozilla foundation proposes research internships [1] and the CTFE 
optimization in the Rust compiler seems to be a really exciting project. 
I wrote a proposal [2] that I'll send with my application and so I'd 
like to share it with you and discuss about bringing CTFE inside Rust.

Here a non-exhaustive summary of key points in my proposal.

First of all, we need to establish when CTFE is triggered, I found two 
contexts (denoted as a hole []):

* Inside a immutable static variable ("static" ident ?:? type ?=? [] ?;?).
* In a vector expression (?[? expr ?,? ".." [] ?]?).

Next in a similar way than with "inline attributes" we might want to add 
these new attributes:

* #[ctfe] hints the compiler to perform CTFE.
* #[ctfe(always)] asks the compiler to always perform CTFE resulting in a
compiler error if it?s impossible.
* #[ctfe(never)] asks the compiler to never perform CTFE resulting in a 
compiler
error if this function is called in a CTFE context.

The rational behind this is that some functions might want to disallow 
CTFE, for example if they manipulate machine-dependent data (such as 
playing with endianness). Some might want to be designed only for 
compile-time and so we want to disable run-time execution. Finally 
others might hints the compiler to "try to optimize whenever you can", 
of course if the function contains infinite loop for some input, the 
compilation might not terminate.

I propose some requirements on function eligible for CTFE (see the 
proposal for references to the Rust manual):

1. Its parameters are evaluable at compile-time.
2. It isn?t a diverging function.
3. It isn?t an unsafe function.
4. It doesn?t contain unsafe block.
5. It doesn?t perform I/O actions.
6. The function source code is available to the compiler. It mustn?t be 
in an external
block, however it can be an extern function.

In this proposal, you'll also find a pseudo-coded algorithm, related 
work (in D and C++), and much more :-)

If you have any suggestions or corrections, do not hesitate. Also, feel 
free to ask questions.

Regards,
Pierre Talbot

[1] https://careers.mozilla.org/en-US/position/oZO7XfwB
[2] http://hyc.io/rust-ctfe-proposal.pdf

From kevin at sb.org  Tue Jan 28 14:24:56 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 14:24:56 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E82BE7.3010502@hyc.io>
References: <52E82BE7.3010502@hyc.io>
Message-ID: <845EF685-9A05-4223-B867-06B901AC8788@sb.org>

It sounds like you're proposing that arbitrary functions may be eligible for CTFE if they happen to meet all the requirements, without any special annotations. This seems like a bad idea to me. I understand why it's attractive, but it means that seemingly harmless changes to a function's implementation (but not its signature) can cause compiler errors in other modules, or even other crates if the AST for the function happens to be made extern.

A more conservative approach would be to require the #[ctfe] annotation, which then imposes all the given restrictions on the function. The downside is such a function then is restricted to only calling other CTFE functions, so we'd have to go in to the standard libraries and add this annotation whenever we think it's both useful and possible.

This approach mirrors the approach being used by C++11/C++14.

-Kevin

On Jan 28, 2014, at 2:15 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> Hi,
> 
> The Mozilla foundation proposes research internships [1] and the CTFE optimization in the Rust compiler seems to be a really exciting project. I wrote a proposal [2] that I'll send with my application and so I'd like to share it with you and discuss about bringing CTFE inside Rust.
> 
> Here a non-exhaustive summary of key points in my proposal.
> 
> First of all, we need to establish when CTFE is triggered, I found two contexts (denoted as a hole []):
> 
> * Inside a immutable static variable ("static" ident ?:? type ?=? [] ?;?).
> * In a vector expression (?[? expr ?,? ".." [] ?]?).
> 
> Next in a similar way than with "inline attributes" we might want to add these new attributes:
> 
> * #[ctfe] hints the compiler to perform CTFE.
> * #[ctfe(always)] asks the compiler to always perform CTFE resulting in a
> compiler error if it?s impossible.
> * #[ctfe(never)] asks the compiler to never perform CTFE resulting in a compiler
> error if this function is called in a CTFE context.
> 
> The rational behind this is that some functions might want to disallow CTFE, for example if they manipulate machine-dependent data (such as playing with endianness). Some might want to be designed only for compile-time and so we want to disable run-time execution. Finally others might hints the compiler to "try to optimize whenever you can", of course if the function contains infinite loop for some input, the compilation might not terminate.
> 
> I propose some requirements on function eligible for CTFE (see the proposal for references to the Rust manual):
> 
> 1. Its parameters are evaluable at compile-time.
> 2. It isn?t a diverging function.
> 3. It isn?t an unsafe function.
> 4. It doesn?t contain unsafe block.
> 5. It doesn?t perform I/O actions.
> 6. The function source code is available to the compiler. It mustn?t be in an external
> block, however it can be an extern function.
> 
> In this proposal, you'll also find a pseudo-coded algorithm, related work (in D and C++), and much more :-)
> 
> If you have any suggestions or corrections, do not hesitate. Also, feel free to ask questions.
> 
> Regards,
> Pierre Talbot
> 
> [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
> [2] http://hyc.io/rust-ctfe-proposal.pdf
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From ecreed at cs.washington.edu  Tue Jan 28 14:26:25 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 28 Jan 2014 14:26:25 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E82BE7.3010502@hyc.io>
References: <52E82BE7.3010502@hyc.io>
Message-ID: <CANbMr6FZEtPmJosK4Pm5_uLO4WCEYLC01kkgb_30eFzdzi_hUw@mail.gmail.com>

Looks pretty reasonable to me at first glance.
Out of curiosity, what's the rationale behind forbidding unsafe
functions/blocks?


On Tue, Jan 28, 2014 at 2:15 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> Hi,
>
> The Mozilla foundation proposes research internships [1] and the CTFE
> optimization in the Rust compiler seems to be a really exciting project. I
> wrote a proposal [2] that I'll send with my application and so I'd like to
> share it with you and discuss about bringing CTFE inside Rust.
>
> Here a non-exhaustive summary of key points in my proposal.
>
> First of all, we need to establish when CTFE is triggered, I found two
> contexts (denoted as a hole []):
>
> * Inside a immutable static variable ("static" ident ':' type '=' [] ';').
> * In a vector expression ('[' expr ',' ".." [] ']').
>
> Next in a similar way than with "inline attributes" we might want to add
> these new attributes:
>
> * #[ctfe] hints the compiler to perform CTFE.
> * #[ctfe(always)] asks the compiler to always perform CTFE resulting in a
> compiler error if it's impossible.
> * #[ctfe(never)] asks the compiler to never perform CTFE resulting in a
> compiler
> error if this function is called in a CTFE context.
>
> The rational behind this is that some functions might want to disallow
> CTFE, for example if they manipulate machine-dependent data (such as
> playing with endianness). Some might want to be designed only for
> compile-time and so we want to disable run-time execution. Finally others
> might hints the compiler to "try to optimize whenever you can", of course
> if the function contains infinite loop for some input, the compilation
> might not terminate.
>
> I propose some requirements on function eligible for CTFE (see the
> proposal for references to the Rust manual):
>
> 1. Its parameters are evaluable at compile-time.
> 2. It isn't a diverging function.
> 3. It isn't an unsafe function.
> 4. It doesn't contain unsafe block.
> 5. It doesn't perform I/O actions.
> 6. The function source code is available to the compiler. It mustn't be in
> an external
> block, however it can be an extern function.
>
> In this proposal, you'll also find a pseudo-coded algorithm, related work
> (in D and C++), and much more :-)
>
> If you have any suggestions or corrections, do not hesitate. Also, feel
> free to ask questions.
>
> Regards,
> Pierre Talbot
>
> [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
> [2] http://hyc.io/rust-ctfe-proposal.pdf
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/49e226e7/attachment.html>

From josh at joshmatthews.net  Tue Jan 28 14:27:03 2014
From: josh at joshmatthews.net (Josh Matthews)
Date: Tue, 28 Jan 2014 14:27:03 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E82BE7.3010502@hyc.io>
References: <52E82BE7.3010502@hyc.io>
Message-ID: <CAOvJiVXMLtrpn2-6Uw_BryqvoTgHr=UQrF9boxLKoHNdhxyZiQ@mail.gmail.com>

Out of that list of requirements, #5 (doesn't perform I/O actions) is the
one that strikes me as least well-defined. Could you elaborate on how you
would enforce it?

Cheers,
Josh


On 28 January 2014 14:15, Pierre Talbot <ptalbot at hyc.io> wrote:

> Hi,
>
> The Mozilla foundation proposes research internships [1] and the CTFE
> optimization in the Rust compiler seems to be a really exciting project. I
> wrote a proposal [2] that I'll send with my application and so I'd like to
> share it with you and discuss about bringing CTFE inside Rust.
>
> Here a non-exhaustive summary of key points in my proposal.
>
> First of all, we need to establish when CTFE is triggered, I found two
> contexts (denoted as a hole []):
>
> * Inside a immutable static variable ("static" ident ':' type '=' [] ';').
> * In a vector expression ('[' expr ',' ".." [] ']').
>
> Next in a similar way than with "inline attributes" we might want to add
> these new attributes:
>
> * #[ctfe] hints the compiler to perform CTFE.
> * #[ctfe(always)] asks the compiler to always perform CTFE resulting in a
> compiler error if it's impossible.
> * #[ctfe(never)] asks the compiler to never perform CTFE resulting in a
> compiler
> error if this function is called in a CTFE context.
>
> The rational behind this is that some functions might want to disallow
> CTFE, for example if they manipulate machine-dependent data (such as
> playing with endianness). Some might want to be designed only for
> compile-time and so we want to disable run-time execution. Finally others
> might hints the compiler to "try to optimize whenever you can", of course
> if the function contains infinite loop for some input, the compilation
> might not terminate.
>
> I propose some requirements on function eligible for CTFE (see the
> proposal for references to the Rust manual):
>
> 1. Its parameters are evaluable at compile-time.
> 2. It isn't a diverging function.
> 3. It isn't an unsafe function.
> 4. It doesn't contain unsafe block.
> 5. It doesn't perform I/O actions.
> 6. The function source code is available to the compiler. It mustn't be in
> an external
> block, however it can be an extern function.
>
> In this proposal, you'll also find a pseudo-coded algorithm, related work
> (in D and C++), and much more :-)
>
> If you have any suggestions or corrections, do not hesitate. Also, feel
> free to ask questions.
>
> Regards,
> Pierre Talbot
>
> [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
> [2] http://hyc.io/rust-ctfe-proposal.pdf
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/fd26d8a1/attachment.html>

From ptalbot at hyc.io  Tue Jan 28 15:16:22 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 00:16:22 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <845EF685-9A05-4223-B867-06B901AC8788@sb.org>
References: <52E82BE7.3010502@hyc.io>
	<845EF685-9A05-4223-B867-06B901AC8788@sb.org>
Message-ID: <52E83A46.7080104@hyc.io>

On 01/28/2014 11:24 PM, Kevin Ballard wrote:
> It sounds like you're proposing that arbitrary functions may be eligible for CTFE if they happen to meet all the requirements, without any special annotations. This seems like a bad idea to me. I understand why it's attractive, but it means that seemingly harmless changes to a function's implementation (but not its signature) can cause compiler errors in other modules, or even other crates if the AST for the function happens to be made extern.
> A more conservative approach would be to require the #[ctfe] annotation, which then imposes all the given restrictions on the function. The downside is such a function then is restricted to only calling other CTFE functions, so we'd have to go in to the standard libraries and add this annotation whenever we think it's both useful and possible.
>
> This approach mirrors the approach being used by C++11/C++14.
>
> -Kevin
I understand your point of view but adding #[ctfe] doesn't solve the 
problem either, the library designer could remove this annotation, isn't 
it? I didn't precise it, but I gave a different semantic to #[ctfe] than 
what you understood. Let me rephrase it:

* #[ctfe] hints the compiler that performing CTFE outside of the contexts (as specified) is safe. It means that for any input this function will terminate [in a reasonable amount of time and memory].

We should keep in mind the drawbacks of the constexpr semantic:

1. Force the library designer to think about CTFE, the user might be in 
a better position since he knows well which parameters he'll give to 
this function.
2. Annotate functions means more maintenance, more changes and more 
errors. Moreover, the C++11 constexpr only allow a subset of the 
language, which is practical for the compiler implementor but not for 
the library designer. In D, they specify when a function is *not* eligible.

Thanks for comments!
>
> On Jan 28, 2014, at 2:15 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
>
>> Hi,
>>
>> The Mozilla foundation proposes research internships [1] and the CTFE optimization in the Rust compiler seems to be a really exciting project. I wrote a proposal [2] that I'll send with my application and so I'd like to share it with you and discuss about bringing CTFE inside Rust.
>>
>> Here a non-exhaustive summary of key points in my proposal.
>>
>> First of all, we need to establish when CTFE is triggered, I found two contexts (denoted as a hole []):
>>
>> * Inside a immutable static variable ("static" ident ?:? type ?=? [] ?;?).
>> * In a vector expression (?[? expr ?,? ".." [] ?]?).
>>
>> Next in a similar way than with "inline attributes" we might want to add these new attributes:
>>
>> * #[ctfe] hints the compiler to perform CTFE.
>> * #[ctfe(always)] asks the compiler to always perform CTFE resulting in a
>> compiler error if it?s impossible.
>> * #[ctfe(never)] asks the compiler to never perform CTFE resulting in a compiler
>> error if this function is called in a CTFE context.
>>
>> The rational behind this is that some functions might want to disallow CTFE, for example if they manipulate machine-dependent data (such as playing with endianness). Some might want to be designed only for compile-time and so we want to disable run-time execution. Finally others might hints the compiler to "try to optimize whenever you can", of course if the function contains infinite loop for some input, the compilation might not terminate.
>>
>> I propose some requirements on function eligible for CTFE (see the proposal for references to the Rust manual):
>>
>> 1. Its parameters are evaluable at compile-time.
>> 2. It isn?t a diverging function.
>> 3. It isn?t an unsafe function.
>> 4. It doesn?t contain unsafe block.
>> 5. It doesn?t perform I/O actions.
>> 6. The function source code is available to the compiler. It mustn?t be in an external
>> block, however it can be an extern function.
>>
>> In this proposal, you'll also find a pseudo-coded algorithm, related work (in D and C++), and much more :-)
>>
>> If you have any suggestions or corrections, do not hesitate. Also, feel free to ask questions.
>>
>> Regards,
>> Pierre Talbot
>>
>> [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
>> [2] http://hyc.io/rust-ctfe-proposal.pdf
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev


From ptalbot at hyc.io  Tue Jan 28 15:21:04 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 00:21:04 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CANbMr6FZEtPmJosK4Pm5_uLO4WCEYLC01kkgb_30eFzdzi_hUw@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>
	<CANbMr6FZEtPmJosK4Pm5_uLO4WCEYLC01kkgb_30eFzdzi_hUw@mail.gmail.com>
Message-ID: <52E83B60.7050701@hyc.io>

On 01/28/2014 11:26 PM, Eric Reed wrote:
> Looks pretty reasonable to me at first glance.
> Out of curiosity, what's the rationale behind forbidding unsafe 
> functions/blocks?
>
In the reference manual we can read things such as: "Mutating an 
immutable value/reference, if it is not marked as non-freeze". This 
would be impossible at compile-time.
But I'm agree that we could relax this constraint and specify more 
precisely in which cases we disallow this.|||||
|
> On Tue, Jan 28, 2014 at 2:15 PM, Pierre Talbot <ptalbot at hyc.io 
> <mailto:ptalbot at hyc.io>> wrote:
>
>     Hi,
>
>     The Mozilla foundation proposes research internships [1] and the
>     CTFE optimization in the Rust compiler seems to be a really
>     exciting project. I wrote a proposal [2] that I'll send with my
>     application and so I'd like to share it with you and discuss about
>     bringing CTFE inside Rust.
>
>     Here a non-exhaustive summary of key points in my proposal.
>
>     First of all, we need to establish when CTFE is triggered, I found
>     two contexts (denoted as a hole []):
>
>     * Inside a immutable static variable ("static" ident ?:? type ?=?
>     [] ?;?).
>     * In a vector expression (?[? expr ?,? ".." [] ?]?).
>
>     Next in a similar way than with "inline attributes" we might want
>     to add these new attributes:
>
>     * #[ctfe] hints the compiler to perform CTFE.
>     * #[ctfe(always)] asks the compiler to always perform CTFE
>     resulting in a
>     compiler error if it?s impossible.
>     * #[ctfe(never)] asks the compiler to never perform CTFE resulting
>     in a compiler
>     error if this function is called in a CTFE context.
>
>     The rational behind this is that some functions might want to
>     disallow CTFE, for example if they manipulate machine-dependent
>     data (such as playing with endianness). Some might want to be
>     designed only for compile-time and so we want to disable run-time
>     execution. Finally others might hints the compiler to "try to
>     optimize whenever you can", of course if the function contains
>     infinite loop for some input, the compilation might not terminate.
>
>     I propose some requirements on function eligible for CTFE (see the
>     proposal for references to the Rust manual):
>
>     1. Its parameters are evaluable at compile-time.
>     2. It isn?t a diverging function.
>     3. It isn?t an unsafe function.
>     4. It doesn?t contain unsafe block.
>     5. It doesn?t perform I/O actions.
>     6. The function source code is available to the compiler. It
>     mustn?t be in an external
>     block, however it can be an extern function.
>
>     In this proposal, you'll also find a pseudo-coded algorithm,
>     related work (in D and C++), and much more :-)
>
>     If you have any suggestions or corrections, do not hesitate. Also,
>     feel free to ask questions.
>
>     Regards,
>     Pierre Talbot
>
>     [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
>     [2] http://hyc.io/rust-ctfe-proposal.pdf
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>


From niko at alum.mit.edu  Tue Jan 28 15:26:33 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Tue, 28 Jan 2014 18:26:33 -0500
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
	<E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
Message-ID: <20140128232633.GC21710@Mr-Bennet>

Probably this should yield an error -- I tend to think we should only
permit moves that we cannot enforce from `*` pointers, just to add an
extra barrier.


Niko

On Tue, Jan 28, 2014 at 12:12:23PM -0800, Kevin Ballard wrote:
> Your code is moving the contents of Option<~MyStruct> into the match arm. It just so happens that this seems to be zeroing out the original pointer in memory, and that happens to be the same representation that None does for the type Option<~MyStruct> (since ~ pointers are non-nullable), so the act of moving the value just happens to be transforming it into a None.
> 
> Normally you couldn't do this, but mutable statics are weird (which is why you need the unsafe block to access it).
> 
> When you remove the ~, the lines end up printing the same because MyStruct is implicitly copyable, so your match arm is now copying instead of moving.
> 
> The correct fix here is to use `Some(ref data)` instead of `Some(data)`. This will take a reference to the data instead of moving it, and the static will remain unchanged.
> 
> -Kevin
> 
> On Jan 28, 2014, at 11:48 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:
> 
> > Hi all! I?m not sure is it an error or "static mut" variables misunderstanding from my side. The source:
> > 
> > struct MyStruct {
> >     val: int
> > }
> > 
> > static mut global_data: Option<~MyStruct> = None;
> > 
> > fn test_call() {
> >     unsafe {
> >         match global_data {
> >             Some(data) => { println!("We have data {:?}", data);}
> >             None => { println!("We don't have data");}
> >         }
> >     }
> > }
> > 
> > fn main() {
> > 
> >     unsafe {
> >         global_data = Some(~MyStruct{val: 42});
> >     }
> > 
> >     test_call();
> >     test_call();
> > }
> > 
> > and output:
> > 
> > We have data ~MyStruct{val: 42}
> > We don't have data
> > 
> > But if I?m changing global_data from Option<~MyStruct> to Option<MyStruct> output is changed also:
> > 
> > We have data ~MyStruct{val: 42}
> > We have data ~MyStruct{val: 42}
> > 
> > Is it normal behaviour and owning pointers cannot be stored in global variables or an error?
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> 

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From comexk at gmail.com  Tue Jan 28 15:28:50 2014
From: comexk at gmail.com (comex)
Date: Tue, 28 Jan 2014 18:28:50 -0500
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E82BE7.3010502@hyc.io>
References: <52E82BE7.3010502@hyc.io>
Message-ID: <CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>

Devil's advocate: CTFE and procedural macros would both allow
arbitrary Rust code to be evaluated at compile time.  Is there any
sane way to combine them rather than making them separate islands?

Personally, I want a way to run arbitrary code at compile time that
can introspect on and possibly generate type information, although
that's different.

From ecreed at cs.washington.edu  Tue Jan 28 15:34:32 2014
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 28 Jan 2014 15:34:32 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E83B60.7050701@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<CANbMr6FZEtPmJosK4Pm5_uLO4WCEYLC01kkgb_30eFzdzi_hUw@mail.gmail.com>
	<52E83B60.7050701@hyc.io>
Message-ID: <CANbMr6GfH1LJcds0TNU3D8zg0XRTx0MQErEO8TVmst_bi8XYUw@mail.gmail.com>

That's what I figured. Forbidding unsafe is definitely a good way to keep
things simple starting out. Compile time evaluation can always be extended
later on.


On Tue, Jan 28, 2014 at 3:21 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> On 01/28/2014 11:26 PM, Eric Reed wrote:
>
>> Looks pretty reasonable to me at first glance.
>> Out of curiosity, what's the rationale behind forbidding unsafe
>> functions/blocks?
>>
>>  In the reference manual we can read things such as: "Mutating an
> immutable value/reference, if it is not marked as non-freeze". This would
> be impossible at compile-time.
> But I'm agree that we could relax this constraint and specify more
> precisely in which cases we disallow this.|||||
> |
>
>> On Tue, Jan 28, 2014 at 2:15 PM, Pierre Talbot <ptalbot at hyc.io <mailto:
>> ptalbot at hyc.io>> wrote:
>>
>>     Hi,
>>
>>     The Mozilla foundation proposes research internships [1] and the
>>     CTFE optimization in the Rust compiler seems to be a really
>>     exciting project. I wrote a proposal [2] that I'll send with my
>>     application and so I'd like to share it with you and discuss about
>>     bringing CTFE inside Rust.
>>
>>     Here a non-exhaustive summary of key points in my proposal.
>>
>>     First of all, we need to establish when CTFE is triggered, I found
>>     two contexts (denoted as a hole []):
>>
>>     * Inside a immutable static variable ("static" ident ':' type '='
>>     [] ';').
>>     * In a vector expression ('[' expr ',' ".." [] ']').
>>
>>     Next in a similar way than with "inline attributes" we might want
>>     to add these new attributes:
>>
>>     * #[ctfe] hints the compiler to perform CTFE.
>>     * #[ctfe(always)] asks the compiler to always perform CTFE
>>     resulting in a
>>     compiler error if it's impossible.
>>     * #[ctfe(never)] asks the compiler to never perform CTFE resulting
>>     in a compiler
>>     error if this function is called in a CTFE context.
>>
>>     The rational behind this is that some functions might want to
>>     disallow CTFE, for example if they manipulate machine-dependent
>>     data (such as playing with endianness). Some might want to be
>>     designed only for compile-time and so we want to disable run-time
>>     execution. Finally others might hints the compiler to "try to
>>     optimize whenever you can", of course if the function contains
>>     infinite loop for some input, the compilation might not terminate.
>>
>>     I propose some requirements on function eligible for CTFE (see the
>>     proposal for references to the Rust manual):
>>
>>     1. Its parameters are evaluable at compile-time.
>>     2. It isn't a diverging function.
>>     3. It isn't an unsafe function.
>>     4. It doesn't contain unsafe block.
>>     5. It doesn't perform I/O actions.
>>     6. The function source code is available to the compiler. It
>>     mustn't be in an external
>>     block, however it can be an extern function.
>>
>>     In this proposal, you'll also find a pseudo-coded algorithm,
>>     related work (in D and C++), and much more :-)
>>
>>     If you have any suggestions or corrections, do not hesitate. Also,
>>     feel free to ask questions.
>>
>>     Regards,
>>     Pierre Talbot
>>
>>     [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
>>     [2] http://hyc.io/rust-ctfe-proposal.pdf
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/d2746ec3/attachment.html>

From kevin at sb.org  Tue Jan 28 15:34:41 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 15:34:41 -0800
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <20140128232633.GC21710@Mr-Bennet>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
	<E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
	<20140128232633.GC21710@Mr-Bennet>
Message-ID: <9BAFDD7C-25C1-4DBB-8747-0A4CC198C9A2@sb.org>

At first glance it seems reasonable to prohibit moving out of a mutable static, but I'm not sure it really makes sense to try and put restrictions on mutable statics when we can't make them safe.

-Kevin

On Jan 28, 2014, at 3:26 PM, Niko Matsakis <niko at alum.mit.edu> wrote:

> Probably this should yield an error -- I tend to think we should only
> permit moves that we cannot enforce from `*` pointers, just to add an
> extra barrier.
> 
> 
> Niko
> 
> On Tue, Jan 28, 2014 at 12:12:23PM -0800, Kevin Ballard wrote:
>> Your code is moving the contents of Option<~MyStruct> into the match arm. It just so happens that this seems to be zeroing out the original pointer in memory, and that happens to be the same representation that None does for the type Option<~MyStruct> (since ~ pointers are non-nullable), so the act of moving the value just happens to be transforming it into a None.
>> 
>> Normally you couldn't do this, but mutable statics are weird (which is why you need the unsafe block to access it).
>> 
>> When you remove the ~, the lines end up printing the same because MyStruct is implicitly copyable, so your match arm is now copying instead of moving.
>> 
>> The correct fix here is to use `Some(ref data)` instead of `Some(data)`. This will take a reference to the data instead of moving it, and the static will remain unchanged.
>> 
>> -Kevin
>> 
>> On Jan 28, 2014, at 11:48 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:
>> 
>>> Hi all! I?m not sure is it an error or "static mut" variables misunderstanding from my side. The source:
>>> 
>>> struct MyStruct {
>>>    val: int
>>> }
>>> 
>>> static mut global_data: Option<~MyStruct> = None;
>>> 
>>> fn test_call() {
>>>    unsafe {
>>>        match global_data {
>>>            Some(data) => { println!("We have data {:?}", data);}
>>>            None => { println!("We don't have data");}
>>>        }
>>>    }
>>> }
>>> 
>>> fn main() {
>>> 
>>>    unsafe {
>>>        global_data = Some(~MyStruct{val: 42});
>>>    }
>>> 
>>>    test_call();
>>>    test_call();
>>> }
>>> 
>>> and output:
>>> 
>>> We have data ~MyStruct{val: 42}
>>> We don't have data
>>> 
>>> But if I?m changing global_data from Option<~MyStruct> to Option<MyStruct> output is changed also:
>>> 
>>> We have data ~MyStruct{val: 42}
>>> We have data ~MyStruct{val: 42}
>>> 
>>> Is it normal behaviour and owning pointers cannot be stored in global variables or an error?
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 


From alex at crichton.co  Tue Jan 28 15:36:28 2014
From: alex at crichton.co (Alex Crichton)
Date: Tue, 28 Jan 2014 15:36:28 -0800
Subject: [rust-dev] static mut and owning pointers
In-Reply-To: <9BAFDD7C-25C1-4DBB-8747-0A4CC198C9A2@sb.org>
References: <87CD2671-1FA0-4C2A-BCD5-4403A6582F41@gmail.com>
	<E189FBBA-5CD3-4B7F-BE50-67D23FDB4928@sb.org>
	<20140128232633.GC21710@Mr-Bennet>
	<9BAFDD7C-25C1-4DBB-8747-0A4CC198C9A2@sb.org>
Message-ID: <CAFnh-mfZ=361apOnYddn_8O6CtXN52ZE=EbGyffsOOj3trevPQ@mail.gmail.com>

Our discussion in a recent meeting concluded that statics will not be
allowed to contain types with destructors, and you also won't be able
to move out of static items:

https://github.com/mozilla/rust/issues/10577#issuecomment-32294407

On Tue, Jan 28, 2014 at 3:34 PM, Kevin Ballard <kevin at sb.org> wrote:
> At first glance it seems reasonable to prohibit moving out of a mutable static, but I'm not sure it really makes sense to try and put restrictions on mutable statics when we can't make them safe.
>
> -Kevin
>
> On Jan 28, 2014, at 3:26 PM, Niko Matsakis <niko at alum.mit.edu> wrote:
>
>> Probably this should yield an error -- I tend to think we should only
>> permit moves that we cannot enforce from `*` pointers, just to add an
>> extra barrier.
>>
>>
>> Niko
>>
>> On Tue, Jan 28, 2014 at 12:12:23PM -0800, Kevin Ballard wrote:
>>> Your code is moving the contents of Option<~MyStruct> into the match arm. It just so happens that this seems to be zeroing out the original pointer in memory, and that happens to be the same representation that None does for the type Option<~MyStruct> (since ~ pointers are non-nullable), so the act of moving the value just happens to be transforming it into a None.
>>>
>>> Normally you couldn't do this, but mutable statics are weird (which is why you need the unsafe block to access it).
>>>
>>> When you remove the ~, the lines end up printing the same because MyStruct is implicitly copyable, so your match arm is now copying instead of moving.
>>>
>>> The correct fix here is to use `Some(ref data)` instead of `Some(data)`. This will take a reference to the data instead of moving it, and the static will remain unchanged.
>>>
>>> -Kevin
>>>
>>> On Jan 28, 2014, at 11:48 AM, Alexander Stavonin <a.stavonin at gmail.com> wrote:
>>>
>>>> Hi all! I'm not sure is it an error or "static mut" variables misunderstanding from my side. The source:
>>>>
>>>> struct MyStruct {
>>>>    val: int
>>>> }
>>>>
>>>> static mut global_data: Option<~MyStruct> = None;
>>>>
>>>> fn test_call() {
>>>>    unsafe {
>>>>        match global_data {
>>>>            Some(data) => { println!("We have data {:?}", data);}
>>>>            None => { println!("We don't have data");}
>>>>        }
>>>>    }
>>>> }
>>>>
>>>> fn main() {
>>>>
>>>>    unsafe {
>>>>        global_data = Some(~MyStruct{val: 42});
>>>>    }
>>>>
>>>>    test_call();
>>>>    test_call();
>>>> }
>>>>
>>>> and output:
>>>>
>>>> We have data ~MyStruct{val: 42}
>>>> We don't have data
>>>>
>>>> But if I'm changing global_data from Option<~MyStruct> to Option<MyStruct> output is changed also:
>>>>
>>>> We have data ~MyStruct{val: 42}
>>>> We have data ~MyStruct{val: 42}
>>>>
>>>> Is it normal behaviour and owning pointers cannot be stored in global variables or an error?
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ptalbot at hyc.io  Tue Jan 28 15:41:53 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 00:41:53 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CAOvJiVXMLtrpn2-6Uw_BryqvoTgHr=UQrF9boxLKoHNdhxyZiQ@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>
	<CAOvJiVXMLtrpn2-6Uw_BryqvoTgHr=UQrF9boxLKoHNdhxyZiQ@mail.gmail.com>
Message-ID: <52E84041.6080208@hyc.io>

The way it is implemented in Rust is by using the libc, but the 
requirement #6 says we can't call external function, so implicitly the 
problem is solved. I'm agree that it isn't formal, but I can't come up 
with a better solution for now.

You made me think of another requirements (so basic that I forgot to 
mention it):

* A function is eligible for CTFE if every function calls inside this 
function are themselves eligible.


On 01/28/2014 11:27 PM, Josh Matthews wrote:
> Out of that list of requirements, #5 (doesn?t perform I/O actions) is 
> the one that strikes me as least well-defined. Could you elaborate on 
> how you would enforce it?
>
> Cheers,
> Josh
>
>
> On 28 January 2014 14:15, Pierre Talbot <ptalbot at hyc.io 
> <mailto:ptalbot at hyc.io>> wrote:
>
>     Hi,
>
>     The Mozilla foundation proposes research internships [1] and the
>     CTFE optimization in the Rust compiler seems to be a really
>     exciting project. I wrote a proposal [2] that I'll send with my
>     application and so I'd like to share it with you and discuss about
>     bringing CTFE inside Rust.
>
>     Here a non-exhaustive summary of key points in my proposal.
>
>     First of all, we need to establish when CTFE is triggered, I found
>     two contexts (denoted as a hole []):
>
>     * Inside a immutable static variable ("static" ident ?:? type ?=?
>     [] ?;?).
>     * In a vector expression (?[? expr ?,? ".." [] ?]?).
>
>     Next in a similar way than with "inline attributes" we might want
>     to add these new attributes:
>
>     * #[ctfe] hints the compiler to perform CTFE.
>     * #[ctfe(always)] asks the compiler to always perform CTFE
>     resulting in a
>     compiler error if it?s impossible.
>     * #[ctfe(never)] asks the compiler to never perform CTFE resulting
>     in a compiler
>     error if this function is called in a CTFE context.
>
>     The rational behind this is that some functions might want to
>     disallow CTFE, for example if they manipulate machine-dependent
>     data (such as playing with endianness). Some might want to be
>     designed only for compile-time and so we want to disable run-time
>     execution. Finally others might hints the compiler to "try to
>     optimize whenever you can", of course if the function contains
>     infinite loop for some input, the compilation might not terminate.
>
>     I propose some requirements on function eligible for CTFE (see the
>     proposal for references to the Rust manual):
>
>     1. Its parameters are evaluable at compile-time.
>     2. It isn?t a diverging function.
>     3. It isn?t an unsafe function.
>     4. It doesn?t contain unsafe block.
>     5. It doesn?t perform I/O actions.
>     6. The function source code is available to the compiler. It
>     mustn?t be in an external
>     block, however it can be an extern function.
>
>     In this proposal, you'll also find a pseudo-coded algorithm,
>     related work (in D and C++), and much more :-)
>
>     If you have any suggestions or corrections, do not hesitate. Also,
>     feel free to ask questions.
>
>     Regards,
>     Pierre Talbot
>
>     [1] https://careers.mozilla.org/en-US/position/oZO7XfwB
>     [2] http://hyc.io/rust-ctfe-proposal.pdf
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From kevin at sb.org  Tue Jan 28 15:45:02 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 15:45:02 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E83A46.7080104@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<845EF685-9A05-4223-B867-06B901AC8788@sb.org>
	<52E83A46.7080104@hyc.io>
Message-ID: <CE6DD34B-4BB0-423B-8506-6268504DF895@sb.org>

On Jan 28, 2014, at 3:16 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> On 01/28/2014 11:24 PM, Kevin Ballard wrote:
>> It sounds like you're proposing that arbitrary functions may be eligible for CTFE if they happen to meet all the requirements, without any special annotations. This seems like a bad idea to me. I understand why it's attractive, but it means that seemingly harmless changes to a function's implementation (but not its signature) can cause compiler errors in other modules, or even other crates if the AST for the function happens to be made extern.
>> A more conservative approach would be to require the #[ctfe] annotation, which then imposes all the given restrictions on the function. The downside is such a function then is restricted to only calling other CTFE functions, so we'd have to go in to the standard libraries and add this annotation whenever we think it's both useful and possible.
>> 
>> This approach mirrors the approach being used by C++11/C++14.
>> 
>> -Kevin
> I understand your point of view but adding #[ctfe] doesn't solve the problem either, the library designer could remove this annotation, isn't it? I didn't precise it, but I gave a different semantic to #[ctfe] than what you understood. Let me rephrase it:
> 
> * #[ctfe] hints the compiler that performing CTFE outside of the contexts (as specified) is safe. It means that for any input this function will terminate [in a reasonable amount of time and memory].
> 
> We should keep in mind the drawbacks of the constexpr semantic:
> 
> 1. Force the library designer to think about CTFE, the user might be in a better position since he knows well which parameters he'll give to this function.
> 2. Annotate functions means more maintenance, more changes and more errors. Moreover, the C++11 constexpr only allow a subset of the language, which is practical for the compiler implementor but not for the library designer. In D, they specify when a function is *not* eligible.

Yes, I was using #[ctfe] to mean something slightly different than you were. In my case, it meant "mark this function as eligible for CTFE, and impose all the CTFE restrictions". And it does fix the problem I mentioned, because #[ctfe] would be considered part of the function signature, not the function implementation. Everyone is already used to the idea that modifying the function signature may cause compiler errors at the call site. But the only example I can think of right now for when changing a function's _implementation_ causes call site compiler errors is when you're using C++ templates.

Not only that, but with your approach, changing the implementation of one function could accidentally cause a whole host of other functions to become ineligible for CTFE. And the farther apart the actual source of the problem, and the resulting error, the harder it is to diagnose and fix such errors.

That said, I was not aware that D already takes this approach, of allowing CTFE by default. I'm curious how it works for them, and how they handle these problems.

-Kevin

From dbau.pp at gmail.com  Tue Jan 28 15:51:07 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 29 Jan 2014 10:51:07 +1100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CE6DD34B-4BB0-423B-8506-6268504DF895@sb.org>
References: <52E82BE7.3010502@hyc.io>	<845EF685-9A05-4223-B867-06B901AC8788@sb.org>	<52E83A46.7080104@hyc.io>
	<CE6DD34B-4BB0-423B-8506-6268504DF895@sb.org>
Message-ID: <52E8426B.5090706@gmail.com>

On 29/01/14 10:45, Kevin Ballard wrote:
> On Jan 28, 2014, at 3:16 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
>
>> On 01/28/2014 11:24 PM, Kevin Ballard wrote:
>>> It sounds like you're proposing that arbitrary functions may be eligible for CTFE if they happen to meet all the requirements, without any special annotations. This seems like a bad idea to me. I understand why it's attractive, but it means that seemingly harmless changes to a function's implementation (but not its signature) can cause compiler errors in other modules, or even other crates if the AST for the function happens to be made extern.
>>> A more conservative approach would be to require the #[ctfe] annotation, which then imposes all the given restrictions on the function. The downside is such a function then is restricted to only calling other CTFE functions, so we'd have to go in to the standard libraries and add this annotation whenever we think it's both useful and possible.
>>>
>>> This approach mirrors the approach being used by C++11/C++14.
>>>
>>> -Kevin
>> I understand your point of view but adding #[ctfe] doesn't solve the problem either, the library designer could remove this annotation, isn't it? I didn't precise it, but I gave a different semantic to #[ctfe] than what you understood. Let me rephrase it:
>>
>> * #[ctfe] hints the compiler that performing CTFE outside of the contexts (as specified) is safe. It means that for any input this function will terminate [in a reasonable amount of time and memory].
>>
>> We should keep in mind the drawbacks of the constexpr semantic:
>>
>> 1. Force the library designer to think about CTFE, the user might be in a better position since he knows well which parameters he'll give to this function.
>> 2. Annotate functions means more maintenance, more changes and more errors. Moreover, the C++11 constexpr only allow a subset of the language, which is practical for the compiler implementor but not for the library designer. In D, they specify when a function is *not* eligible.
> Yes, I was using #[ctfe] to mean something slightly different than you were. In my case, it meant "mark this function as eligible for CTFE, and impose all the CTFE restrictions". And it does fix the problem I mentioned, because #[ctfe] would be considered part of the function signature, not the function implementation. Everyone is already used to the idea that modifying the function signature may cause compiler errors at the call site. But the only example I can think of right now for when changing a function's _implementation_ causes call site compiler errors is when you're using C++ templates.

FWIW, `transmute` causes such errors in Rust. e.g. `fn errors<T>(x: T) { 
unsafe { std::cast::transmute::<T, int>(x); } }` will fail to compile 
when passed u16, but not when passed uint, and this isn't encoded in the 
type signature.


Huon

>
> Not only that, but with your approach, changing the implementation of one function could accidentally cause a whole host of other functions to become ineligible for CTFE. And the farther apart the actual source of the problem, and the resulting error, the harder it is to diagnose and fix such errors.
>
> That said, I was not aware that D already takes this approach, of allowing CTFE by default. I'm curious how it works for them, and how they handle these problems.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From ptalbot at hyc.io  Tue Jan 28 15:56:20 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 00:56:20 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>
	<CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>
Message-ID: <52E843A4.3000207@hyc.io>

If we drop macro, I can come up with a "simple" solution inspired by the 
Lisp quote:

// Return a Rust construction string.
#[ctfe(always)]
fn make_rust_construct() -> ~str {
   return ~"5 + 5";
}

#[ctfe(always)]
fn eval(s: ~str) -> ??;

fn main() {
   eval(make_rust_construct());
}

We'd rely on string manipulation rather than on a macro language.

For convenience we could add a special quote function:

#[ctfe(always)]
fn make_rust_construct() -> ~str {
   return quote(5 + 5);
}

With support of the compiler, the macros could be implemented in Rust, 
but this is a work that can only be done after CTFE is implemented. So 
we have all the time to invent new syntax and deliberate on the semantic.

On 01/29/2014 12:28 AM, comex wrote:
> Devil's advocate: CTFE and procedural macros would both allow
> arbitrary Rust code to be evaluated at compile time.  Is there any
> sane way to combine them rather than making them separate islands?
>
> Personally, I want a way to run arbitrary code at compile time that
> can introspect on and possibly generate type information, although
> that's different.


From comexk at gmail.com  Tue Jan 28 16:01:44 2014
From: comexk at gmail.com (comex)
Date: Tue, 28 Jan 2014 19:01:44 -0500
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E843A4.3000207@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>
	<52E843A4.3000207@hyc.io>
Message-ID: <CAPM5UJ0nQRGBq0psoQZcT5yPJZFT75BYRSFgja+yp7=D_t-UVw@mail.gmail.com>

On Tue, Jan 28, 2014 at 6:56 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
> With support of the compiler, the macros could be implemented in Rust, but
> this is a work that can only be done after CTFE is implemented. So we have
> all the time to invent new syntax and deliberate on the semantic.

Actually, Rust already has procedural macros as of recently.  I was
wondering whether that could be combined with the proposed new system.

From ptalbot at hyc.io  Tue Jan 28 16:04:16 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 01:04:16 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E844E6.1040307@hyc.io>
References: <52E844E6.1040307@hyc.io>
Message-ID: <52E84580.9080605@hyc.io>

On 01/29/2014 12:45 AM, Kevin Ballard wrote:
> On Jan 28, 2014, at 3:16 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
>
>> On 01/28/2014 11:24 PM, Kevin Ballard wrote:
>>> It sounds like you're proposing that arbitrary functions may be eligible for CTFE if they happen to meet all the requirements, without any special annotations. This seems like a bad idea to me. I understand why it's attractive, but it means that seemingly harmless changes to a function's implementation (but not its signature) can cause compiler errors in other modules, or even other crates if the AST for the function happens to be made extern.
>>> A more conservative approach would be to require the #[ctfe] annotation, which then imposes all the given restrictions on the function. The downside is such a function then is restricted to only calling other CTFE functions, so we'd have to go in to the standard libraries and add this annotation whenever we think it's both useful and possible.
>>>
>>> This approach mirrors the approach being used by C++11/C++14.
>>>
>>> -Kevin
>> I understand your point of view but adding #[ctfe] doesn't solve the problem either, the library designer could remove this annotation, isn't it? I didn't precise it, but I gave a different semantic to #[ctfe] than what you understood. Let me rephrase it:
>>
>> * #[ctfe] hints the compiler that performing CTFE outside of the contexts (as specified) is safe. It means that for any input this function will terminate [in a reasonable amount of time and memory].
>>
>> We should keep in mind the drawbacks of the constexpr semantic:
>>
>> 1. Force the library designer to think about CTFE, the user might be in a better position since he knows well which parameters he'll give to this function.
>> 2. Annotate functions means more maintenance, more changes and more errors. Moreover, the C++11 constexpr only allow a subset of the language, which is practical for the compiler implementor but not for the library designer. In D, they specify when a function is *not* eligible.
> Yes, I was using #[ctfe] to mean something slightly different than you were. In my case, it meant "mark this function as eligible for CTFE, and impose all the CTFE restrictions". And it does fix the problem I mentioned, because #[ctfe] would be considered part of the function signature, not the function implementation. Everyone is already used to the idea that modifying the function signature may cause compiler errors at the call site. But the only example I can think of right now for when changing a function's _implementation_ causes call site compiler errors is when you're using C++ templates.
>
> Not only that, but with your approach, changing the implementation of one function could accidentally cause a whole host of other functions to become ineligible for CTFE. And the farther apart the actual source of the problem, and the resulting error, the harder it is to diagnose and fix such errors.
>
> That said, I was not aware that D already takes this approach, of allowing CTFE by default. I'm curious how it works for them, and how they handle these problems.
>
> -Kevin

They do not allow it by default, they rely on the context (as I also do) to activate it. If a function is designed with CTFE requirements, these might not change much over the time (speculation). I mean, did you ever re-factorize a function code to add unsafe, extern or I/O statements? I have the feeling that it doesn't arrive so often. But it's just an intuition...


Pierre

From kevin at sb.org  Tue Jan 28 16:18:44 2014
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 28 Jan 2014 16:18:44 -0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E844E6.1040307@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<845EF685-9A05-4223-B867-06B901AC8788@sb.org>
	<52E83A46.7080104@hyc.io>
	<CE6DD34B-4BB0-423B-8506-6268504DF895@sb.org>
	<52E844E6.1040307@hyc.io>
Message-ID: <07341667-6F1B-453B-9C9D-E5EA87035345@sb.org>

On Jan 28, 2014, at 4:01 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> On 01/29/2014 12:45 AM, Kevin Ballard wrote:
>> Yes, I was using #[ctfe] to mean something slightly different than you were. In my case, it meant "mark this function as eligible for CTFE, and impose all the CTFE restrictions". And it does fix the problem I mentioned, because #[ctfe] would be considered part of the function signature, not the function implementation. Everyone is already used to the idea that modifying the function signature may cause compiler errors at the call site. But the only example I can think of right now for when changing a function's _implementation_ causes call site compiler errors is when you're using C++ templates.
>> 
>> Not only that, but with your approach, changing the implementation of one function could accidentally cause a whole host of other functions to become ineligible for CTFE. And the farther apart the actual source of the problem, and the resulting error, the harder it is to diagnose and fix such errors.
>> 
>> That said, I was not aware that D already takes this approach, of allowing CTFE by default. I'm curious how it works for them, and how they handle these problems.
>> 
>> -Kevin
> They do not allow it by default, they rely on the context (as I also do) to activate it. If a function is designed with CTFE requirements, these might not change much over the time (speculation). I mean, did you ever re-factorize a function code to add unsafe, extern or I/O statements? I have the feeling that it doesn't arrive so often. But it's just an intuition...

Sure. Unsafe is sometimes used to optimize code for performance that was otherwise safe.

I could write a function intended for CTFE, using a perfectly harmless API (say, std::vec), and then have an update to the perfectly harmless API introduce unsafe code for the purposes of optimization (as has happened in std::vec in the past), and suddenly my function is no longer CTFE-eligible.

-Kevin

From vladimir at slate-project.org  Tue Jan 28 16:40:17 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Wed, 29 Jan 2014 00:40:17 +0000
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <07341667-6F1B-453B-9C9D-E5EA87035345@sb.org>
References: <52E82BE7.3010502@hyc.io>
	<845EF685-9A05-4223-B867-06B901AC8788@sb.org>
	<52E83A46.7080104@hyc.io>
	<CE6DD34B-4BB0-423B-8506-6268504DF895@sb.org>
	<52E844E6.1040307@hyc.io>
	<07341667-6F1B-453B-9C9D-E5EA87035345@sb.org>
Message-ID: <CACTPm50bGdOJnujE1ZUEeZbrsTvSOeZP2Un8Uf5d4Q7pbZnAcQ@mail.gmail.com>

CTFE would indeed be a very interesting thing to see an experiment on in
Rust.

However, practically, what is the problem that CTFE solves that cannot be
solved by a hygienic macro system (or alternatively, a syntax extension
that has access to the AST)?

My experience with D's CTFE has been largely negative (though it was
several years and things may have changed), for a couple of reasons:

1. CTFE is hard to debug (D at the time didn't give very good error
messages in this area especially)
2. Turing completeness is not preventable (obvious but nevertheless because
of point 1 again difficult to find out where something has gone wrong)
3. String generation of program code (i.e. an unclean macro system) was
even more difficult to work with (I see this is not in the proposal, which
is great)

To me it just doesn't seem obvious Rust would need CTFE just as its macro
support is improving.

Vladimir



On Wed, Jan 29, 2014 at 12:18 AM, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 28, 2014, at 4:01 PM, Pierre Talbot <ptalbot at hyc.io> wrote:
>
> > On 01/29/2014 12:45 AM, Kevin Ballard wrote:
> >> Yes, I was using #[ctfe] to mean something slightly different than you
> were. In my case, it meant "mark this function as eligible for CTFE, and
> impose all the CTFE restrictions". And it does fix the problem I mentioned,
> because #[ctfe] would be considered part of the function signature, not the
> function implementation. Everyone is already used to the idea that
> modifying the function signature may cause compiler errors at the call
> site. But the only example I can think of right now for when changing a
> function's _implementation_ causes call site compiler errors is when you're
> using C++ templates.
> >>
> >> Not only that, but with your approach, changing the implementation of
> one function could accidentally cause a whole host of other functions to
> become ineligible for CTFE. And the farther apart the actual source of the
> problem, and the resulting error, the harder it is to diagnose and fix such
> errors.
> >>
> >> That said, I was not aware that D already takes this approach, of
> allowing CTFE by default. I'm curious how it works for them, and how they
> handle these problems.
> >>
> >> -Kevin
> > They do not allow it by default, they rely on the context (as I also do)
> to activate it. If a function is designed with CTFE requirements, these
> might not change much over the time (speculation). I mean, did you ever
> re-factorize a function code to add unsafe, extern or I/O statements? I
> have the feeling that it doesn't arrive so often. But it's just an
> intuition...
>
> Sure. Unsafe is sometimes used to optimize code for performance that was
> otherwise safe.
>
> I could write a function intended for CTFE, using a perfectly harmless API
> (say, std::vec), and then have an update to the perfectly harmless API
> introduce unsafe code for the purposes of optimization (as has happened in
> std::vec in the past), and suddenly my function is no longer CTFE-eligible.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/0d1b6212/attachment.html>

From simon80 at gmail.com  Tue Jan 28 18:05:20 2014
From: simon80 at gmail.com (Simon Ruggier)
Date: Tue, 28 Jan 2014 21:05:20 -0500
Subject: [rust-dev] Faster communication between tasks
In-Reply-To: <CAFyaas0mEQs1hiz2rLjjLVVWSh2MH1_mAsbwFCeKC7iUB7pD6Q@mail.gmail.com>
References: <CAFyaas2SBNYUvzUOsf2TBHn05dCPce8G4QNhPygQQuAX58YdKQ@mail.gmail.com>
	<52700CB8.8010706@mozilla.com>
	<CAFyaas1-s9T7+bpf+oWR1=bHE=rebGob85yuxvYngrb0_Uwssg@mail.gmail.com>
	<CAFyaas0mEQs1hiz2rLjjLVVWSh2MH1_mAsbwFCeKC7iUB7pD6Q@mail.gmail.com>
Message-ID: <CAFyaas0NR4JocssYAUoXagFwegYxgZpYS-T-Z7hArc-5EdUB-g@mail.gmail.com>

A small update: I've gotten a resizable version of my disruptor
implementation working, and the performance looks pretty good so far. I
still have a few loose ends to tie up before I push out the changes. I
should have the updated code on GitHub hopefully within a couple of weeks,
depending on how much time I find to work on it.


On Sat, Nov 9, 2013 at 2:13 PM, Simon Ruggier <simon80 at gmail.com> wrote:

> Hi all, I've tentatively come up with a design that would allow the sender
> to reallocate the buffer as necessary, with very little added performance
> cost. The sending side would bear the cost of reallocation, and there would
> be an extra test that receivers would have to make every time they process
> an item (no extra atomic operations needed). However, it may be a few weeks
> or more before I have a working implementation to demonstrate, so I figured
> it might be worthwhile to mention now that I'll be working on this.
>
> Also, I think it would be interesting to investigate doing something like
> the Linux kernel's deadlock detection[1], but generalized to apply to
> bounded queues, and implemented as a static check. I know little about
> this, but even so, I can see how it would be an enormous amount of work. On
> the other hand, I would have thought the same thing about the memory safety
> rules that Rust enforces. I'm hopeful that this will eventually be possible
> as well.
>
> [1] https://www.kernel.org/doc/Documentation/lockdep-design.txt
>
>
> On Wed, Oct 30, 2013 at 12:55 AM, Simon Ruggier <simon80 at gmail.com> wrote:
>
>> On Tue, Oct 29, 2013 at 3:30 PM, Brian Anderson <banderson at mozilla.com>wrote:
>>
>>>  On 10/28/2013 10:02 PM, Simon Ruggier wrote:
>>>
>>> Greetings fellow Rustians!
>>>
>>> First of all, thanks for working on such a great language. I really like
>>> the clean syntax, increased safety, separation of data from function
>>> definitions, and freedom from having to declare duplicate method prototypes
>>> in header files.
>>>
>>> I've been working on an alternate way to communicate between tasks in
>>> Rust, following the same approach as the LMAX Disruptor.[1] I'm hoping to
>>> eventually offer a superset of the functionality in the pipes API, and
>>> replace them as the default communication mechanism between tasks. Just as
>>> with concurrency in general, my main motivation in implementing this is to
>>> improve performance. For more information about the disruptor approach,
>>> there's a lot of information linked from their home page, in a variety of
>>> formats.
>>>
>>>
>>> This is really exciting work. Thanks for pursuing it. I've been
>>> interested in exploring something like Disruptor in Rust. The current
>>> channel types in Rust are indeed slow, and fixing them is the topic of
>>> https://github.com/mozilla/rust/issues/8568.
>>>
>>
>> I'll start paying attention to that. The Morrison & Afek 2013 paper looks
>> like something I should read.
>>
>>
>>>
>>>
>>> This is my first major contribution of new functionality to an
>>> open-source project, so I didn't want to discuss it in advance until I had
>>> a working system to demonstrate. I currently have a very basic proof of
>>> concept that achieves almost two orders of magnitude better performance
>>> than the pipes API. On my hardware[2], I currently see throughput of about
>>> 27 million items per second when synchronizing with a double-checked wait
>>> condition protocol between sender and receivers, 80+ million items with no
>>> blocking (i.e. busy waiting), and anywhere from 240,000 to 600,000 when
>>> using pipes. The LMAX Disruptor library gets up to 110 million items per
>>> second on the same hardware (using busy waiting and yielding), so there's
>>> definitely still room for significant improvement.
>>>
>>>
>>> Those are awesome results!
>>>
>>
>> Thanks! When I first brought it up, it was getting about 14 million with
>> the busy waiting. Minimizing the number of atomic operations (even with
>> relaxed memory ordering) makes a big difference in performance. The 2/3
>> drop in performance with the blocking wait strategy comes from merely doing
>> a read-modify-write operation on every send (it currently uses atomic swap,
>> I haven't experimented with others yet). To be fair, the only result I can
>> take credit for is the blocking algorithm. The other ideas are straight
>> from the original disruptor.
>>
>>
>>> I've put the code up on GitHub (I'm using rustc from master).[3]
>>> Currently, single and multi-stage pipelines of receivers are supported,
>>> while many features are missing, like multiple concurrent senders, multiple
>>> concurrent receivers, or mutation of the items as they pass through the
>>> pipeline. However, given what I have so far, now is probably the right time
>>> to start soliciting feedback and advice. I'm looking for review,
>>> suggestions/constructive criticism, and guidance about contributing this to
>>> the Rust codebase.
>>>
>>>
>>> I'm not deeply familiar with Disruptor, but I believe that it uses
>>> bounded queues. My general feeling thus far is that, as the general 'go-to'
>>> channel type, people should not be using bounded queues that block the
>>> sender when full because of the potential for unexpected deadlocks. I could
>>> be convinced otherwise though if it's just not possible to have reasonably
>>> fast unbounded channels. Note that I don't think it's critical for the
>>> general-purpose channel to be as fast as possible - it's more important to
>>> be convenient.
>>>
>>
>> Yes, it does. I'm divided on this, because unbounded queues can also lead
>> to memory exhaustion and added latency, but I suspect that for many use
>> cases, you're right. For performance critical code, I think there's
>> probably no argument: if a queue is too large, it starts causing latency
>> problems (like with bufferbloat). A queue that accepts an unlimited number
>> of items is like an API that doesn't let the caller know about errors. The
>> caller needs to know that there's a large queue, and adjust its behaviour.
>> Because of this, I doubt any performance-critical application would find it
>> truly optimal to use unbounded queues. My opinion on this is strongly
>> influenced by this post:
>>
>> http://mechanical-sympathy.blogspot.co.uk/2012/05/apply-back-pressure-when-overloaded.html
>>
>> For general usage, though, I need to do more research. Any application
>> where latency is relevant really should be designed to deal with
>> back-pressure from queues, but there may be some batch job style use cases
>> where, as you say, it isn't worth the extra effort. On the other hand, it's
>> relevant to think about how deadlocks occur, and decide whether or not it's
>> reasonable for developers to expect to be able to do those things. I'll
>> look into this and see what I come up with.
>>
>> If there were some general way to mitigate the deadlock issue within the
>> runtime, it would also solve this problem.
>>
>> As a last resort, I suspect that I could probably figure out a way to
>> have the sender resize the buffer when it fills, copy the elements over,
>> and then switch the consumers over to the larger buffer. I don't know if I
>> could do it without affecting the fast path on the receiver side.
>>
>> Please keep working on this. I'm excited to see your results.
>>>
>>
>> I appreciate the encouragement :)
>>
>>
>>>
>>> Thanks,
>>> Simon
>>>
>>> [1] http://lmax-exchange.github.io/disruptor/
>>> [2] A 2.66GHz Intel P8800 CPU running in a Thinkpad T500 on Linux x86_64
>>> [3] https://github.com/sruggier/rust-disruptor
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/3f96633f/attachment-0001.html>

From erick.tryzelaar at gmail.com  Tue Jan 28 20:09:20 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Tue, 28 Jan 2014 20:09:20 -0800
Subject: [rust-dev] Reminder: Rust Bay Area meetup tomorrow
In-Reply-To: <CALdfqQ+4+uFDPFun-noaXoRU6gDeP9EuH1K7oXxocz5qD_jn7A@mail.gmail.com>
References: <CALdfqQ+4+uFDPFun-noaXoRU6gDeP9EuH1K7oXxocz5qD_jn7A@mail.gmail.com>
Message-ID: <CALdfqQKRT3AwVN=3OTrpzT5GopiqtKNq--GrW5uQ4us8RZSDFg@mail.gmail.com>

All,

There is a slight delay on getting the Air Mozilla broadcast up and
running. Once it's up and running, you'll find it here:

https://air.mozilla.org/rust-meetup-january-2014/

I'll send out another mail once it's back up.

Thanks,
Erick




On Mon, Jan 27, 2014 at 3:13 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com>wrote:

> Good afternoon Rusties,
>
> I wanted to remind everyone of the next Rust Bay Area meetup tomorrow at
> the San Francisco Mozilla office. We still have plenty of spots left
> available if you want to join us. On the agenda is:
>
> * Brian will talk about Rust 0.9 and the roadmap to 1.0
> * Niko will talk about his plans for Dynamically Sized Types, or DST
> * Corey Richardson will present remotely about his Rust-themed cake, as
> well as his toy OS and his experience with evangelizing Rust.
> * And finally Kevin Ballard will present his safe Lua bindings.
>
> You can find more details at our meetup page:
>
> http://www.meetup.com/Rust-Bay-Area/events/153909222/
>
> For those who are remote, you can watch the meetup live on Air Mozilla:
>
> https://air.mozilla.org/rust-meetup-january-2014/
>
> Thanks, and I hope you can make it!
>
> -Erick
>
>
> PS: I'm always looking for presenters local or remote, so please let me
> know if you want to present something.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/5f054a72/attachment.html>

From erick.tryzelaar at gmail.com  Tue Jan 28 20:13:11 2014
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Tue, 28 Jan 2014 20:13:11 -0800
Subject: [rust-dev] Reminder: Rust Bay Area meetup tomorrow
In-Reply-To: <CALdfqQKRT3AwVN=3OTrpzT5GopiqtKNq--GrW5uQ4us8RZSDFg@mail.gmail.com>
References: <CALdfqQ+4+uFDPFun-noaXoRU6gDeP9EuH1K7oXxocz5qD_jn7A@mail.gmail.com>
	<CALdfqQKRT3AwVN=3OTrpzT5GopiqtKNq--GrW5uQ4us8RZSDFg@mail.gmail.com>
Message-ID: <CALdfqQK2F8s1CDuq_mxRBGSeemv0GVx657QVe1gPHBLPX79WBA@mail.gmail.com>

We're on! Live in a few moments.


On Tue, Jan 28, 2014 at 8:09 PM, Erick Tryzelaar
<erick.tryzelaar at gmail.com>wrote:

> All,
>
> There is a slight delay on getting the Air Mozilla broadcast up and
> running. Once it's up and running, you'll find it here:
>
> https://air.mozilla.org/rust-meetup-january-2014/
>
> I'll send out another mail once it's back up.
>
> Thanks,
> Erick
>
>
>
>
> On Mon, Jan 27, 2014 at 3:13 PM, Erick Tryzelaar <
> erick.tryzelaar at gmail.com> wrote:
>
>> Good afternoon Rusties,
>>
>> I wanted to remind everyone of the next Rust Bay Area meetup tomorrow at
>> the San Francisco Mozilla office. We still have plenty of spots left
>> available if you want to join us. On the agenda is:
>>
>> * Brian will talk about Rust 0.9 and the roadmap to 1.0
>> * Niko will talk about his plans for Dynamically Sized Types, or DST
>> * Corey Richardson will present remotely about his Rust-themed cake, as
>> well as his toy OS and his experience with evangelizing Rust.
>> * And finally Kevin Ballard will present his safe Lua bindings.
>>
>> You can find more details at our meetup page:
>>
>> http://www.meetup.com/Rust-Bay-Area/events/153909222/
>>
>> For those who are remote, you can watch the meetup live on Air Mozilla:
>>
>> https://air.mozilla.org/rust-meetup-january-2014/
>>
>> Thanks, and I hope you can make it!
>>
>> -Erick
>>
>>
>> PS: I'm always looking for presenters local or remote, so please let me
>> know if you want to present something.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140128/ae62b0fa/attachment.html>

From ptalbot at hyc.io  Wed Jan 29 01:19:08 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 10:19:08 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>
References: <52E82BE7.3010502@hyc.io>
	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>
Message-ID: <52E8C78C.9000009@hyc.io>

On 01/29/2014 01:39 AM, Brendan Zabarauskas wrote:
> On 29 Jan 2014, at 9:15 am, Pierre Talbot <ptalbot at hyc.io> wrote:
>
>> I propose some requirements on function eligible for CTFE (see the proposal for references to the Rust manual):
>>
>> 1. Its parameters are evaluable at compile-time.
>> 2. It isn?t a diverging function.
>> 3. It isn?t an unsafe function.
>> 4. It doesn?t contain unsafe block.
>> 5. It doesn?t perform I/O actions.
>> 6. The function source code is available to the compiler. It mustn?t be in an external
>> block, however it can be an extern function.
>
> This sounds very much like D?s `pure` keyword. http://dlang.org/function.html#pure-functions
>
>  From the website:
>
>> Pure Functions
>> --------------
>>
>> Pure functions are functions which cannot access global or static, mutable state save through their arguments. This can enable optimizations based on the fact that a pure function is guaranteed to mutate nothing which isn't passed to it, and in cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:
>>
>> - does not read or write any global or static mutable state
>> - cannot call functions that are not pure
>> - can override an impure function, but an impure function cannot override a pure one
>> - is covariant with an impure function
>> - cannot perform I/O
>>
>> As a concession to practicality, a pure function can:
>>
>> - allocate memory via a NewExpression
>> - terminate the program
>> - read and write the floating point exception flags
>> - read and write the floating point mode flags, as long as those flags are restored to their initial state upon function entry
>> - perform impure operations in statements that are in a ConditionalStatement controlled by a DebugCondition.
>>
>> A pure function can throw exceptions.
> CTFE would be extremely welcome for improving Rust?s compile time code generation capabilities. This is important both practically and also for closing the gap between us and D or C++. It could allow, for example, numeric operators to be overloaded in the std whilst still being able to be used at compile time. Casts could also be implemented in-library. I?m sure there are even better examples though.
>
> ~Brendan
Hi,

 From my proposal:

2.3 Relation with pure function

A pure function is a function that is free of side-effects, you can call 
a pure function any
number of time with the same set of inputs and be sure the results will 
be identical.
An observation is that if a function meets the requirements of CTFE it 
must be a pure
function, but a pure function doesn?t necessarily meet the requirements 
of CTFE. It
mostly depends on the language, for example, in Rust, a pure function 
can contain
unsafe blocks but the CTFE requirements doesn?t allow that.

I add: a pure function can call extern code and diverges, so the pure 
requirements are a subset of the CTFE requirements.

Pierre

From bascule at gmail.com  Wed Jan 29 01:40:27 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 01:40:27 -0800
Subject: [rust-dev] Multiplexing I/O the Erlang way: an "ioserver"
Message-ID: <CAHOTMVJFz6ttRNo7hxZgj44auqw51Dz1bdxMHsWNSFUYGcPiBg@mail.gmail.com>

libnative (fast, low-latency native I/O) and libgreen (libuv backed and
great for large numbers of infrequent/idle messengers) are both awesome and
provide some great options for network server I/O, particularly since you
can mix-and-match them.

However there's a seemingly unsolved problem in Rust: multiplexing I/O
operations with channels. I think this can be fixed in a purely additive
manner (i.e everything else that exists today is great!) with a new feature
borrowed from Erlang: the ioserver (noting that Erlang also implements
libgreen-style synchronous I/O in addition to ioserver)

Ignoring Erlang for a second, the naive solution to the I/O + channel
multiplexing is magic select API that can handle both. In my experience
(i.e. I wrote and support this approach in a system some people actually
use) the backend implementation, especially across POSIX and Windows, ends
up quite ugly.

There's a better option though... if you want to multiplex IO with channel
messages, turn everything into channel messages in one place: the "ioserver"

Solution: Centralize I/O event loops into a separate thread (pool if
necessary, probably not). Erlang and 0MQ work this way. Erlang implements
an API called a "port" to talk to the ioserver. In Rust perhaps you could
have a type that implements the same trait as channels?

The ioserver becomes the central place to optimize the nitty gritty of
taking I/O requests from the rest of the program and multiplexing them with
other (i.e channel) events in the system. The basic formula is:

- Have the ioserver block for events using libuv or what have you, and have
an OS-specific I/O handle (i.e. a pipe) to unblock the selector in the
event of in-process communication
- Use lock-free mechanisms so if the selector isn't stuck in a system call
we can use more efficient coordination of registering and unregistering I/O
op interests

(Note: libuv is an I/O completions library and not a selector library so
the proposed solution is admittedly a bit handwavey)

Mixing a pipe-based wakeup mechanism with lock-free operations to eliminate
unnecessary system calls has been used somewhat successfully in the Netty
I/O library for the JVM.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/971f80f1/attachment.html>

From glaebhoerl at gmail.com  Wed Jan 29 02:21:33 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 29 Jan 2014 11:21:33 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E8C78C.9000009@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>
	<52E8C78C.9000009@hyc.io>
Message-ID: <CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>

On Wed, Jan 29, 2014 at 10:19 AM, Pierre Talbot <ptalbot at hyc.io> wrote:

> I add: a pure function can call extern code and diverges, so the pure
> requirements are a subset of the CTFE requirements.
>

How do you plan to enforce that a function won't diverge?

Are there any systems which allow calling functions and enforce convergence
without using dependent types?

(We could probably enforce it by prohibiting both mutual and self-recursion
as well as loops, but I'm guessing this would be too restrictive to be
acceptable.)



>
> Pierre
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/acd26293/attachment-0001.html>

From ptalbot at hyc.io  Wed Jan 29 02:26:26 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 11:26:26 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>	<52E8C78C.9000009@hyc.io>
	<CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>
Message-ID: <52E8D752.8050906@hyc.io>

It's a diverging function in the sense of the manual: 
http://static.rust-lang.org/doc/master/rust.html#diverging-functions

On 01/29/2014 11:21 AM, G?bor Lehel wrote:
> On Wed, Jan 29, 2014 at 10:19 AM, Pierre Talbot <ptalbot at hyc.io 
> <mailto:ptalbot at hyc.io>> wrote:
>
>     I add: a pure function can call extern code and diverges, so the
>     pure requirements are a subset of the CTFE requirements.
>
>
> How do you plan to enforce that a function won't diverge?
>
> Are there any systems which allow calling functions and enforce 
> convergence without using dependent types?
>
> (We could probably enforce it by prohibiting both mutual and 
> self-recursion as well as loops, but I'm guessing this would be too 
> restrictive to be acceptable.)
>
>
>     Pierre
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>


From glaebhoerl at gmail.com  Wed Jan 29 02:39:50 2014
From: glaebhoerl at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 29 Jan 2014 11:39:50 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E8D752.8050906@hyc.io>
References: <52E82BE7.3010502@hyc.io>
	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>
	<52E8C78C.9000009@hyc.io>
	<CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>
	<52E8D752.8050906@hyc.io>
Message-ID: <CAPoegsxDqPCfJ0O5TcyJOj9ZBOXD2M5CRghgZBGg4tRr0j8syQ@mail.gmail.com>

Ah, so `fail!()` is not okay, but `loop { }` is okay.


On Wed, Jan 29, 2014 at 11:26 AM, Pierre Talbot <ptalbot at hyc.io> wrote:

> It's a diverging function in the sense of the manual:
> http://static.rust-lang.org/doc/master/rust.html#diverging-functions
>
> On 01/29/2014 11:21 AM, G?bor Lehel wrote:
>
>> On Wed, Jan 29, 2014 at 10:19 AM, Pierre Talbot <ptalbot at hyc.io <mailto:
>> ptalbot at hyc.io>> wrote:
>>
>>     I add: a pure function can call extern code and diverges, so the
>>     pure requirements are a subset of the CTFE requirements.
>>
>>
>> How do you plan to enforce that a function won't diverge?
>>
>> Are there any systems which allow calling functions and enforce
>> convergence without using dependent types?
>>
>> (We could probably enforce it by prohibiting both mutual and
>> self-recursion as well as loops, but I'm guessing this would be too
>> restrictive to be acceptable.)
>>
>>
>>     Pierre
>>
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/1417449f/attachment.html>

From ptalbot at hyc.io  Wed Jan 29 02:44:20 2014
From: ptalbot at hyc.io (Pierre Talbot)
Date: Wed, 29 Jan 2014 11:44:20 +0100
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CAPoegsxDqPCfJ0O5TcyJOj9ZBOXD2M5CRghgZBGg4tRr0j8syQ@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>	<52E8C78C.9000009@hyc.io>	<CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>	<52E8D752.8050906@hyc.io>
	<CAPoegsxDqPCfJ0O5TcyJOj9ZBOXD2M5CRghgZBGg4tRr0j8syQ@mail.gmail.com>
Message-ID: <52E8DB84.2070703@hyc.io>

Well yes, due to the halting problem, we can't detect if a function will 
diverge or not. It's on the behalf of the library user. However, we 
could limit the number of iteration or recursion to an arbitrary number.

On 01/29/2014 11:39 AM, G?bor Lehel wrote:
> Ah, so `fail!()` is not okay, but `loop { }` is okay.
>
>
> On Wed, Jan 29, 2014 at 11:26 AM, Pierre Talbot <ptalbot at hyc.io 
> <mailto:ptalbot at hyc.io>> wrote:
>
>     It's a diverging function in the sense of the manual:
>     http://static.rust-lang.org/doc/master/rust.html#diverging-functions
>
>     On 01/29/2014 11:21 AM, G?bor Lehel wrote:
>
>         On Wed, Jan 29, 2014 at 10:19 AM, Pierre Talbot
>         <ptalbot at hyc.io <mailto:ptalbot at hyc.io> <mailto:ptalbot at hyc.io
>         <mailto:ptalbot at hyc.io>>> wrote:
>
>             I add: a pure function can call extern code and diverges,
>         so the
>             pure requirements are a subset of the CTFE requirements.
>
>
>         How do you plan to enforce that a function won't diverge?
>
>         Are there any systems which allow calling functions and
>         enforce convergence without using dependent types?
>
>         (We could probably enforce it by prohibiting both mutual and
>         self-recursion as well as loops, but I'm guessing this would
>         be too restrictive to be acceptable.)
>
>
>             Pierre
>
>             _______________________________________________
>             Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         <mailto:Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>


From dguenther9 at gmail.com  Wed Jan 29 06:09:22 2014
From: dguenther9 at gmail.com (Derek Guenther)
Date: Wed, 29 Jan 2014 08:09:22 -0600
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <52E80876.70805@free.fr>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
	<52E52901.7020403@free.fr> <52E80876.70805@free.fr>
Message-ID: <CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>

I believe the workaround is:

extern mod extra = "extra#0.10-pre";

It's broken a few builds on rust-ci this week.

Derek

On Tue, Jan 28, 2014 at 1:43 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> Any info or idea?
> I update from the master and now all my project have the same issue.
> If I use rustc I have no problem. I see the thread about rustpkg, perhaps I
> should migrate to rustc and cmake?
>
> Philippe
>
> Le 26/01/2014 16:25, Philippe Delrieu a ?crit :
>
> Hi,
>
> I have the same problem since 2 or 3 days with the portmidi project.
>
> Philippe
>
> Le 26/01/2014 14:06, Cadence Marseille a ?crit :
>
> Hi,
>
> I am seeing a new build error and I am not sure what is causing it.
> rust-pcre, libpcre bindings for Rust, is set up to use Travis and Rust CI.
> The latest build is failing with:
>
> rustpkg install pcre
>
> WARNING: The Rust package manager is experimental and may be unstable
>
> error: Package pcre depends on extra, but I don't know how to find it
>
> task '<unnamed>' failed at 'explicit failure',
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/util.rs:531
>
> task '<main>' failed at 'receiving on a closed channel',
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/mod.rs:743
>
> task '<unnamed>' failed at 'Error running custom build command',
> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/lib.rs:517
>
> make: *** [install] Error 65
>
>
> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>
> I looked at some other Rust CI-enabled projects and found a similar error:
> https://travis-ci.org/eholk/rust-opencl/builds/17491630
> https://travis-ci.org/erickt/rust-zmq/builds/16353359
> https://travis-ci.org/erickt/rust-mustache/builds/16059551
> https://travis-ci.org/bjz/gl-rs/builds/16126945
> https://travis-ci.org/bjz/sax-rs/builds/16405581
>
> What is causing this error and how do I fix it?
>
> Cadence
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From niko at alum.mit.edu  Wed Jan 29 08:44:18 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 29 Jan 2014 11:44:18 -0500
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <CAPM5UJ0nQRGBq0psoQZcT5yPJZFT75BYRSFgja+yp7=D_t-UVw@mail.gmail.com>
References: <52E82BE7.3010502@hyc.io>
	<CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>
	<52E843A4.3000207@hyc.io>
	<CAPM5UJ0nQRGBq0psoQZcT5yPJZFT75BYRSFgja+yp7=D_t-UVw@mail.gmail.com>
Message-ID: <20140129164418.GB4929@Mr-Bennet>

On Tue, Jan 28, 2014 at 07:01:44PM -0500, comex wrote:
> Actually, Rust already has procedural macros as of recently.  I was
> wondering whether that could be combined with the proposed new system.

I haven't looked in detail at the procedural macro support that was
recently added, but off hand I think I favor that approach. That is,
I'd rather compile a Rust module, link it dynamically, and run it as
normal, versus defining some subset of Rust that the compiler can
execute. The latter seems like it'll be difficult to define,
implement, and understand. Our experience with effect systems and
purity has not been particularly good, and I think staged compilation
is easier to explain and free from the twin hazards of "this library
function is pure but not marked pure" (when using explicit
declaration) or "this library function is accidentally pure" (when
using inference).


Niko

From liuyanghejerry at 126.com  Wed Jan 29 08:56:56 2014
From: liuyanghejerry at 126.com (liuyanghejerry)
Date: Thu, 30 Jan 2014 00:56:56 +0800
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <52E8DB84.2070703@hyc.io>
References: <52E82BE7.3010502@hyc.io>	<2F01AB28-580F-4CEF-B1C4-E1DA51C127AE@yahoo.com.au>	<52E8C78C.9000009@hyc.io>	<CAPoegsztGy=kCGXVY=zO2UsmMGeN8OqL=zGbJL8kvv7PqA-AjQ@mail.gmail.com>	<52E8D752.8050906@hyc.io>	<CAPoegsxDqPCfJ0O5TcyJOj9ZBOXD2M5CRghgZBGg4tRr0j8syQ@mail.gmail.com>
	<52E8DB84.2070703@hyc.io>
Message-ID: <52E932D8.4080506@126.com>

Hi,
I didn't read through the whole post, but I think maybe we could even 
let user add one more hint about max iteration time, since lib user 
should be aware of it?

? 2014/1/29 18:44, Pierre Talbot ??:
> Well yes, due to the halting problem, we can't detect if a function 
> will diverge or not. It's on the behalf of the library user. However, 
> we could limit the number of iteration or recursion to an arbitrary 
> number.
>
> On 01/29/2014 11:39 AM, G?bor Lehel wrote:
>> Ah, so `fail!()` is not okay, but `loop { }` is okay.
>>
>>
>> On Wed, Jan 29, 2014 at 11:26 AM, Pierre Talbot <ptalbot at hyc.io 
>> <mailto:ptalbot at hyc.io>> wrote:
>>
>> It's a diverging function in the sense of the manual:
>> http://static.rust-lang.org/doc/master/rust.html#diverging-functions
>>
>> On 01/29/2014 11:21 AM, G?bor Lehel wrote:
>>
>> On Wed, Jan 29, 2014 at 10:19 AM, Pierre Talbot
>> <ptalbot at hyc.io <mailto:ptalbot at hyc.io> <mailto:ptalbot at hyc.io
>> <mailto:ptalbot at hyc.io>>> wrote:
>>
>> I add: a pure function can call extern code and diverges,
>> so the
>> pure requirements are a subset of the CTFE requirements.
>>
>>
>> How do you plan to enforce that a function won't diverge?
>>
>> Are there any systems which allow calling functions and
>> enforce convergence without using dependent types?
>>
>> (We could probably enforce it by prohibiting both mutual and
>> self-recursion as well as loops, but I'm guessing this would
>> be too restrictive to be acceptable.)
>>
>>
>> Pierre
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>> <mailto:Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



From sfackler at gmail.com  Wed Jan 29 08:56:53 2014
From: sfackler at gmail.com (Steven Fackler)
Date: Wed, 29 Jan 2014 11:56:53 -0500
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <20140129164418.GB4929@Mr-Bennet>
References: <52E82BE7.3010502@hyc.io>
	<CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>
	<52E843A4.3000207@hyc.io>
	<CAPM5UJ0nQRGBq0psoQZcT5yPJZFT75BYRSFgja+yp7=D_t-UVw@mail.gmail.com>
	<20140129164418.GB4929@Mr-Bennet>
Message-ID: <CANb7cF6wENmcGDLfUwLiuweNcZQA1ttn5xRC3SR7dCVOemEj2g@mail.gmail.com>

The rough idea that pcwalton, acrichto and I were talking about when I was
working on the procedural macro stuff was to split compilation into two
phases. The first phase would produce a library that the compiler would
load for the second phase. The procedural macro PR added the `phase`
attribute which is currently only used with `extern mod` statements but
could be extended to functions and whatever else:

#[phase(syntax)]
fn ctfe_function() -> int {
    10
}

static FOO: int = ctfe_function();

Steven Fackler


On Wed, Jan 29, 2014 at 11:44 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Tue, Jan 28, 2014 at 07:01:44PM -0500, comex wrote:
> > Actually, Rust already has procedural macros as of recently.  I was
> > wondering whether that could be combined with the proposed new system.
>
> I haven't looked in detail at the procedural macro support that was
> recently added, but off hand I think I favor that approach. That is,
> I'd rather compile a Rust module, link it dynamically, and run it as
> normal, versus defining some subset of Rust that the compiler can
> execute. The latter seems like it'll be difficult to define,
> implement, and understand. Our experience with effect systems and
> purity has not been particularly good, and I think staged compilation
> is easier to explain and free from the twin hazards of "this library
> function is pure but not marked pure" (when using explicit
> declaration) or "this library function is accidentally pure" (when
> using inference).
>
>
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/a90897b4/attachment-0001.html>

From slabode at aim.com  Wed Jan 29 09:00:47 2014
From: slabode at aim.com (SiegeLord)
Date: Wed, 29 Jan 2014 12:00:47 -0500
Subject: [rust-dev] Compile-time function evaluation in Rust
In-Reply-To: <20140129164418.GB4929@Mr-Bennet>
References: <52E82BE7.3010502@hyc.io>	<CAPM5UJ1KaCpEwgOrzwzddtrz408tDNGC0kw+eY=OVon_mhc-Sg@mail.gmail.com>	<52E843A4.3000207@hyc.io>	<CAPM5UJ0nQRGBq0psoQZcT5yPJZFT75BYRSFgja+yp7=D_t-UVw@mail.gmail.com>
	<20140129164418.GB4929@Mr-Bennet>
Message-ID: <52E933BF.2010807@aim.com>

On 01/29/2014 11:44 AM, Niko Matsakis wrote:
> On Tue, Jan 28, 2014 at 07:01:44PM -0500, comex wrote:
>> Actually, Rust already has procedural macros as of recently.  I was
>> wondering whether that could be combined with the proposed new system.
>
> I haven't looked in detail at the procedural macro support that was
> recently added, but off hand I think I favor that approach. That is,
> I'd rather compile a Rust module, link it dynamically, and run it as
> normal, versus defining some subset of Rust that the compiler can
> execute. The latter seems like it'll be difficult to define,
> implement, and understand. Our experience with effect systems and
> purity has not been particularly good, and I think staged compilation
> is easier to explain and free from the twin hazards of "this library
> function is pure but not marked pure" (when using explicit
> declaration) or "this library function is accidentally pure" (when
> using inference).
>

I was under the impression from some time ago that this was going to be 
the way CTFE is implemented in Rust. Having tried CTFE in D, I was not 
impressed by the nebulous definition of the constant language used 
there, it was never clear ahead of time what will work and what won't 
(although maybe the problem won't be as big in Rust, as Rust is a 
smaller language). Additionally, it was just plain slow (you are 
essentially creating a very slow scripting language without JIT).

It seems to me (judging at the size of the loadable procedural macro 
commit size) that using staged compilation approach will be easier to 
implement and be more powerful at the cost of, perhaps, less convenient 
usage.

-SL


From photex at gmail.com  Wed Jan 29 10:57:35 2014
From: photex at gmail.com (Chip Collier)
Date: Wed, 29 Jan 2014 10:57:35 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CADcg8==Hxyzwoa9swZ8SicxPHcdC+703BUZ7rRyGyoXmAE3K4A@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CABL+ZB4jkjs-TSb1AiMWbZT461OSi6bbY32N4wG-EBxn8LPRuQ@mail.gmail.com>
	<CALax_rxHN1kDERY=RkbPmYGiH36-LHygVGMiSKMwMTNk1rCX_w@mail.gmail.com>
	<52E7DEE4.6000106@aim.com>
	<CAHMjM1r3osg6P675BbH24NNxq410sO7b7r1_yXa_Tr-betp1uA@mail.gmail.com>
	<CADcg8==Hxyzwoa9swZ8SicxPHcdC+703BUZ7rRyGyoXmAE3K4A@mail.gmail.com>
Message-ID: <CAKCa6=v_xBYri4CJje0K1LBogF4RHC1kmNL0ciYkUAqcK=xhwQ@mail.gmail.com>

Hi everyone,

I am new here so please forgive my ignorance of previous efforts and any
discussions leading up to rustpkg in it's current form. I also don't have
extensive experience with rustpkg itself having arrived at time when the
message was basically "don't use rustpkg, just use make". I hope I'm not
out of line with my questions and opinions here.

Because I'm new and I'm very interested in the subject it would be
tremendously useful for me to hear precisely what is so bad about rustpkg
that its problems preclude any salvage or redesign.  If we don't want to do
this on the mailing list there could always be a "rustpkg postmortem" wiki
page. It would also be helpful to know if those in favor of removal and
those in favor of finishing it also agree on what exactly it should do.

Has there been any concentrated review of the state of the art for other
languages/toolkits/ecosystems? Is there any reason not to extend an
existing solution? Gradle for example states that the entire goal of the
project is to be the ultimate tool for any project and already has early
support for building native projects in assembly, C, or C++. Why not add a
toolkit plugin for rustc? I understand that it would be less than ideal to
require a JVM to use the defacto Rust build and packaging tool but the
point I'm trying to make is that if correcting and completing rustpkg isn't
on the table, then where can we look for a head start into a solution that
appeals to the most people?

The rest of this email might be off-topic so feel free to ignore. I can
always start a new thread.

Was it ever the goal to have this tool be the entry point for peoples
interaction with Rust? "Just download X to get started!" I seem to recall
reading that there was once a "rust" as well as "rustc". Is cargo-lite.py
referring to a previous effort as well?
Could a project specify Rust version constraints and this tool fetches the
most appropriate Rust binaries (or uses a set of configured Rust
installations) for it's dependencies, using them to execute the build?
(Having to manage a large codebase that requires multiple versions of GCC
is an enormous headache for me. Rust doesn't seem to be on the same track
at all here... but oh how I hope it never becomes the same problem.)
Related to the question above, is the goal to have Rust itself packaged and
distributed with this tool?

In my experience, whatever solution is chosen needs to embrace
configuration over convention. To me this means that convention is
established through default configuration and for a majority of projects
very little will be required to be productive with the tool. For shops or
projects which need to orchestrate rather large and specific builds with
assortments of dependencies that span platforms, it's wonderful to not have
to travel outside the friendly confines of the official build and package
management tool. I would say that this also adds confidence in a new
technology to know that you won't be fighting the tools to make use of it.


Chip



On Tue, Jan 28, 2014 at 1:29 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> rustpkg is definitely unfinished. It's not clear to me that what it
> needs is to be destroyed, rather than finished. That is, there may
> well be good reasons; I just haven't seen them so far in this thread.
> The concrete points that a few people have made are ones to do with
> unfinished pieces of rustpkg that are relatively well-delineated from
> the entire system.
>
> I'm not trying to argue for keeping it, it just seems to me that for
> the good of the project, the reasons why it couldn't be salvaged
> should be documented somewhere. As the person who did most of the
> work, but wasn't able to finish it because I left Mozilla, it's
> surprising to me that the fact that rustpkg isn't finished is being
> used as a reason to purge it entirely. Rust is, after all, not
> finished yet -- as a whole -- but we're not throwing out the entire
> language.
>
> Cheers,
> Tim
>
>
> On Tue, Jan 28, 2014 at 11:28 AM, Ian Daniher <explodingmind at gmail.com>
> wrote:
> > Lots of good points in this thread, but I wanted to request deprecation,
> but
> > not removal until a better alternative is documented and made available.
> > Rustpkg works for my needs - I use it every day -  but it definitely
> needs
> > some TLC.
> >
> > Thanks!
> > --
> > Ian
> >
> >
> > On Tue, Jan 28, 2014 at 11:46 AM, SiegeLord <slabode at aim.com> wrote:
> >>
> >> On 01/27/2014 11:53 PM, Jeremy Ong wrote:
> >>>
> >>> I'm somewhat new to the Rust dev scene. Would anybody care to summarize
> >>> roughly what the deficiencies are in the existing system in the
> interest
> >>> of forward progress? It may help seed the discussion for the next
> effort
> >>> as well.
> >>
> >>
> >> I can only speak for myself, but here are some reasons why I abandoned
> >> rustpkg and switched to CMake.
> >>
> >> Firstly, and overarchingly, it was the attitude of the project
> development
> >> with respect to issues. As a comparison, let me consider Rust the
> language.
> >> It is a pain to make my code pass the borrow check sometimes, the
> lifetimes
> >> are perhaps the most frustrating aspect of Rust. I put up with them
> however,
> >> because they solve a gigantic problem and are the keystone of Rust's
> >> safety-without-GC story. rustpkg also has many incredibly frustrating
> >> aspects, but they are there (in my opinion) arbitrarily and not as a
> >> solution to any real problem. When I hit them, I do not get the same
> sense
> >> of purposeful sacrifice I get with Rust's difficult points. Let me
> outline
> >> the specific issues I personally hit (I know of other ones, but I
> haven't
> >> encountered them personally).
> >>
> >> Conflation of package id and source. That fact combined with the fact
> that
> >> to depend on some external package you have to write "extern mod =
> pkgid"
> >> meant that you needed to create bizarre directory structures to depend
> on
> >> locally developed packages (e.g. you'd have to put your locally
> developed
> >> project in a directory tree like so: github.com/SiegeLord/Project).
> This is
> >> not something I was going to do.
> >>
> >> The package dependencies are written in the source file, which makes it
> >> onerous to switch between versions/forks. A simple package script would
> have
> >> solved it, but it wasn't present by design.
> >>
> >> My repositories have multiple crates, and rustpkg is woefully
> >> under-equipped to handle that case. You cannot build them without
> dealing
> >> with pkg.rs, and using them from other projects seemed impossible too
> (the
> >> extern mod syntax wasn't equipped to handle multiple crates per
> package).
> >> This is particularly vexing when you have multiple example programs
> >> alongside your library. I was not going to split my repository up just
> >> because rustpkg wasn't designed to handle that case.
> >>
> >> All of those points would be solved by having an explicit package
> >> description file/script which was THE overarching design non-goal of
> >> rustpkg. After that was made clear to me, I just ditched it and went to
> C++
> >> style package "management" and a CMake build system.
> >>
> >> -SL
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed
> it."
> -- Zora Neale Hurston
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/b7998090/attachment.html>

From smcarthur at mozilla.com  Wed Jan 29 11:08:23 2014
From: smcarthur at mozilla.com (Sean McArthur)
Date: Wed, 29 Jan 2014 11:08:23 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
Message-ID: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>

Considering the effort to break up libextra into multiple crates in
#8784[1], could rust-crypto[2] be moved back into rust as libcrypto?

Some comments on the issue deviated about whether crypto should written
*in* Rust, or just be bindings. As a user, I don't care how they are
implemented, as long as the exposed API is Rust-like. However, I can't
imagine scouring the internet for a crypto library maintained by someone,
instead of using what comes with Rust (which gives me a sense of assurance
that it does the crypto correctly).



[1]: https://github.com/mozilla/rust/issues/8784
[2]: https://github.com/DaGenix/rust-crypto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/693fa190/attachment.html>

From adamson.benjamin at gmail.com  Wed Jan 29 11:13:59 2014
From: adamson.benjamin at gmail.com (benjamin adamson)
Date: Wed, 29 Jan 2014 11:13:59 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
Message-ID: <CAHzuJ31pTQtv_+6_OLLMzSC=RzYb1yb3qb5fXWuO6MS_477p8g@mail.gmail.com>

Is there no performance implications for using the bindings vs using rust
code (assuming everything else is equal)??

I assume if the crypto libraries are going to be maintained, keeping the
bindings up to date allows us to focus on more important libraries, rather
then maintaining a parallel rust implementation.


On Wed, Jan 29, 2014 at 11:08 AM, Sean McArthur <smcarthur at mozilla.com>wrote:

> Considering the effort to break up libextra into multiple crates in
> #8784[1], could rust-crypto[2] be moved back into rust as libcrypto?
>
> Some comments on the issue deviated about whether crypto should written
> *in* Rust, or just be bindings. As a user, I don't care how they are
> implemented, as long as the exposed API is Rust-like. However, I can't
> imagine scouring the internet for a crypto library maintained by someone,
> instead of using what comes with Rust (which gives me a sense of assurance
> that it does the crypto correctly).
>
>
>
> [1]: https://github.com/mozilla/rust/issues/8784
> [2]: https://github.com/DaGenix/rust-crypto
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/4836b37c/attachment-0001.html>

From bascule at gmail.com  Wed Jan 29 11:17:56 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 11:17:56 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
Message-ID: <CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>

On Wed, Jan 29, 2014 at 11:08 AM, Sean McArthur <smcarthur at mozilla.com>wrote:

> Considering the effort to break up libextra into multiple crates in
> #8784[1], could rust-crypto[2] be moved back into rust as libcrypto?
>

As it were, ruby-core is now talking about extracting OpenSSL into a
separate library packaged independently from the standard distribution.
They are not cryptographic domain experts, don't want to be responsible for
it, and having it in the standard library limits their agility around
incident response when security problems are discovered.

Some comments on the issue deviated about whether crypto should written
> *in* Rust, or just be bindings. As a user, I don't care how they are
> implemented, as long as the exposed API is Rust-like.
>

rust-crypto is a brand new implementation of a bunch of crypto which hasn't
been well-audited. That alone should worry you.

I would definitely not be a fan of a non-battle hardened crypto library
being in core Rust.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/cf3f0df5/attachment.html>

From smcarthur at mozilla.com  Wed Jan 29 11:32:09 2014
From: smcarthur at mozilla.com (Sean McArthur)
Date: Wed, 29 Jan 2014 11:32:09 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
	<CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>
Message-ID: <CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>

On Wed, Jan 29, 2014 at 11:17 AM, Tony Arcieri <bascule at gmail.com> wrote:

> As it were, ruby-core is now talking about extracting OpenSSL into a
> separate library packaged independently from the standard distribution.
> They are not cryptographic domain experts, don't want to be responsible for
> it, and having it in the standard library limits their agility around
> incident response when security problems are discovered.
>

Understandable. Though, packaging bindings to a mature implementation would
reduce the need for experts in Rust, and still give users the "this is
audited crypto code, use it" message.


> rust-crypto is a brand new implementation of a bunch of crypto which
> hasn't been well-audited. That alone should worry you.
>

I was under the impression that rust-crypto was extra::crypto moved into a
separate library. I could be wrong.


> I would definitely not be a fan of a non-battle hardened crypto library
> being in core Rust.
>

I wouldn't be either. Whichever library is used, Rust could call it
libcrypto, and I as a user can trust that it's a good library that I can
use.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/764e3309/attachment.html>

From steve at steveklabnik.com  Wed Jan 29 11:34:37 2014
From: steve at steveklabnik.com (Steve Klabnik)
Date: Wed, 29 Jan 2014 11:34:37 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
	<CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>
	<CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>
Message-ID: <CABL+ZB7ysoGDdpzwBa2f_GdmyZsWjqjLetb-es0PVk=K8CYfVg@mail.gmail.com>

I would like to completely +1 what Tony has said. Unless we have a
dedicated core team member who cares about crypto, it should stay out
of the official distribution.

From flaper87 at gmail.com  Wed Jan 29 11:37:56 2014
From: flaper87 at gmail.com (Flaper87)
Date: Wed, 29 Jan 2014 20:37:56 +0100
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CABL+ZB7ysoGDdpzwBa2f_GdmyZsWjqjLetb-es0PVk=K8CYfVg@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
	<CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>
	<CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>
	<CABL+ZB7ysoGDdpzwBa2f_GdmyZsWjqjLetb-es0PVk=K8CYfVg@mail.gmail.com>
Message-ID: <CAMOT3C1ZxoXn6UZokO9eoyTVacVpZTdvm7bAmVC2nuRK=CsfaA@mail.gmail.com>

2014-01-29 Steve Klabnik <steve at steveklabnik.com>

> I would like to completely +1 what Tony has said. Unless we have a
> dedicated core team member who cares about crypto, it should stay out
> of the official distribution.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>


As mentioned in the bug report. I think `crypto` libraries should live
outside the standard distribution. So, I agree with Tony and Steve.



-- 
Flavio (@flaper87) Percoco
http://www.flaper87.com
http://github.com/FlaPer87
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/c291d765/attachment.html>

From philippe.delrieu at free.fr  Wed Jan 29 12:07:30 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 29 Jan 2014 21:07:30 +0100
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>	<52E52901.7020403@free.fr>	<52E80876.70805@free.fr>
	<CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>
Message-ID: <52E95F82.5050305@free.fr>

Thank you for your help. I try, it correct the error but I have other 
message and nothing is generated :
WARNING: The Rust package manager is experimental and may be unstable
note: Installed package portmidi#0.0 to 
/home/pdelrieu/Documents/dev/musit/workplace_linux/PortMidi/master/rust-portmidi
task '<unnamed>' failed at 'assertion failed: !outputs_disc.is_empty()', 
/home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/librustpkg/util.rs:552
task '<unnamed>' failed at 'receiving on a closed channel', 
/home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/libstd/comm/mod.rs:743

The problem come from rustpkg or my project?

Philippe


Le 29/01/2014 15:09, Derek Guenther a ?crit :
> I believe the workaround is:
>
> extern mod extra = "extra#0.10-pre";
>
> It's broken a few builds on rust-ci this week.
>
> Derek
>
> On Tue, Jan 28, 2014 at 1:43 PM, Philippe Delrieu
> <philippe.delrieu at free.fr> wrote:
>> Any info or idea?
>> I update from the master and now all my project have the same issue.
>> If I use rustc I have no problem. I see the thread about rustpkg, perhaps I
>> should migrate to rustc and cmake?
>>
>> Philippe
>>
>> Le 26/01/2014 16:25, Philippe Delrieu a ?crit :
>>
>> Hi,
>>
>> I have the same problem since 2 or 3 days with the portmidi project.
>>
>> Philippe
>>
>> Le 26/01/2014 14:06, Cadence Marseille a ?crit :
>>
>> Hi,
>>
>> I am seeing a new build error and I am not sure what is causing it.
>> rust-pcre, libpcre bindings for Rust, is set up to use Travis and Rust CI.
>> The latest build is failing with:
>>
>> rustpkg install pcre
>>
>> WARNING: The Rust package manager is experimental and may be unstable
>>
>> error: Package pcre depends on extra, but I don't know how to find it
>>
>> task '<unnamed>' failed at 'explicit failure',
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/util.rs:531
>>
>> task '<main>' failed at 'receiving on a closed channel',
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/mod.rs:743
>>
>> task '<unnamed>' failed at 'Error running custom build command',
>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/lib.rs:517
>>
>> make: *** [install] Error 65
>>
>>
>> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>>
>> I looked at some other Rust CI-enabled projects and found a similar error:
>> https://travis-ci.org/eholk/rust-opencl/builds/17491630
>> https://travis-ci.org/erickt/rust-zmq/builds/16353359
>> https://travis-ci.org/erickt/rust-mustache/builds/16059551
>> https://travis-ci.org/bjz/gl-rs/builds/16126945
>> https://travis-ci.org/bjz/sax-rs/builds/16405581
>>
>> What is causing this error and how do I fix it?
>>
>> Cadence
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>


From gaetan at xeberon.net  Wed Jan 29 12:27:38 2014
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 29 Jan 2014 21:27:38 +0100
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>
References: <CAHrH6bPg6OEuveWn+iKtpHGVfDwvQzu4qpUT9j0kQUc6UxRP_w@mail.gmail.com>
	<CAHOTMVJbVxitg0qukZVNSeoEDMJ5VqdGs2+9LXB12s2fYtr_3A@mail.gmail.com>
	<CAHrH6bOv1KNaW-yRiGe_yRNspppX=MuZqLbA63ZcN2BGB1w=WQ@mail.gmail.com>
Message-ID: <CANK7tAFU5hrNW0qkGfepvLN-GtQWko6qG90VaD21P=HuGAOGOw@mail.gmail.com>

Bindings in standard library is really wierd, especially for porting and
maintaining on various system (linux, android,...)
Le 29 janv. 2014 20:32, "Sean McArthur" <smcarthur at mozilla.com> a ?crit :

>
>
>
> On Wed, Jan 29, 2014 at 11:17 AM, Tony Arcieri <bascule at gmail.com> wrote:
>
>> As it were, ruby-core is now talking about extracting OpenSSL into a
>> separate library packaged independently from the standard distribution.
>> They are not cryptographic domain experts, don't want to be responsible for
>> it, and having it in the standard library limits their agility around
>> incident response when security problems are discovered.
>>
>
> Understandable. Though, packaging bindings to a mature implementation
> would reduce the need for experts in Rust, and still give users the "this
> is audited crypto code, use it" message.
>
>
>> rust-crypto is a brand new implementation of a bunch of crypto which
>> hasn't been well-audited. That alone should worry you.
>>
>
> I was under the impression that rust-crypto was extra::crypto moved into a
> separate library. I could be wrong.
>
>
>> I would definitely not be a fan of a non-battle hardened crypto library
>> being in core Rust.
>>
>
> I wouldn't be either. Whichever library is used, Rust could call it
> libcrypto, and I as a user can trust that it's a good library that I can
> use.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/037ee638/attachment.html>

From olivier.lemaire at me.com  Wed Jan 29 12:46:45 2014
From: olivier.lemaire at me.com (Olivier LEMAIRE)
Date: Wed, 29 Jan 2014 21:46:45 +0100
Subject: [rust-dev] Moving libcrypto back into rust repo?
Message-ID: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>

As an user, I +1 Tony rationales too.

I suggest to submit a call/request (Rust wiki?) to find this team member/role as crypto is damn needed in this digital age.

Cheers,
-- 
Olivier Lemaire

Steve Klabnik <steve at steveklabnik.com> wrote:

>I would like to completely +1 what Tony has said. Unless we have a
>dedicated core team member who cares about crypto, it should stay out
>of the official distribution.
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

From bascule at gmail.com  Wed Jan 29 12:59:02 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 12:59:02 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
Message-ID: <CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>

On Wednesday, January 29, 2014, Olivier LEMAIRE <olivier.lemaire at me.com>
wrote:

> I suggest to submit a call/request (Rust wiki?) to find this team
> member/role as crypto is damn needed in this digital age.
>

I'd suggest Rust continue its current policy of keeping crypto out of
stdlib.

However, it'd be nice if there were an official "blessed" crypto package
(using TBD packaging system). I think this library should/needs to be
shipped with said TDB packaging system.

Perhaps Mozilla could loop in its NSS people on rust-nss?


-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/b2909edc/attachment.html>

From dguenther9 at gmail.com  Wed Jan 29 12:59:10 2014
From: dguenther9 at gmail.com (Derek Guenther)
Date: Wed, 29 Jan 2014 14:59:10 -0600
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <52E95F82.5050305@free.fr>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
	<52E52901.7020403@free.fr> <52E80876.70805@free.fr>
	<CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>
	<52E95F82.5050305@free.fr>
Message-ID: <CAFPC01ir7rQVLq8MiP1SH3C5dmZdtaLMnQMVw7t4y2HxezWDCQ@mail.gmail.com>

I'm fairly sure that the problem is with rustpkg. I've never had much
success with rustpkg install. You might be better off using rustc and
makefiles for now, at least until rust's dependency management story
has been solidified.

Hope this helps!

On Wed, Jan 29, 2014 at 2:07 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> Thank you for your help. I try, it correct the error but I have other
> message and nothing is generated :
>
> WARNING: The Rust package manager is experimental and may be unstable
> note: Installed package portmidi#0.0 to
> /home/pdelrieu/Documents/dev/musit/workplace_linux/PortMidi/master/rust-portmidi
> task '<unnamed>' failed at 'assertion failed: !outputs_disc.is_empty()',
> /home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/librustpkg/util.rs:552
> task '<unnamed>' failed at 'receiving on a closed channel',
> /home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/libstd/comm/mod.rs:743
>
> The problem come from rustpkg or my project?
>
> Philippe
>
>
> Le 29/01/2014 15:09, Derek Guenther a ?crit :
>
>> I believe the workaround is:
>>
>> extern mod extra = "extra#0.10-pre";
>>
>> It's broken a few builds on rust-ci this week.
>>
>> Derek
>>
>> On Tue, Jan 28, 2014 at 1:43 PM, Philippe Delrieu
>> <philippe.delrieu at free.fr> wrote:
>>>
>>> Any info or idea?
>>> I update from the master and now all my project have the same issue.
>>> If I use rustc I have no problem. I see the thread about rustpkg, perhaps
>>> I
>>> should migrate to rustc and cmake?
>>>
>>> Philippe
>>>
>>> Le 26/01/2014 16:25, Philippe Delrieu a ?crit :
>>>
>>> Hi,
>>>
>>> I have the same problem since 2 or 3 days with the portmidi project.
>>>
>>> Philippe
>>>
>>> Le 26/01/2014 14:06, Cadence Marseille a ?crit :
>>>
>>> Hi,
>>>
>>> I am seeing a new build error and I am not sure what is causing it.
>>> rust-pcre, libpcre bindings for Rust, is set up to use Travis and Rust
>>> CI.
>>> The latest build is failing with:
>>>
>>> rustpkg install pcre
>>>
>>> WARNING: The Rust package manager is experimental and may be unstable
>>>
>>> error: Package pcre depends on extra, but I don't know how to find it
>>>
>>> task '<unnamed>' failed at 'explicit failure',
>>>
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/util.rs:531
>>>
>>> task '<main>' failed at 'receiving on a closed channel',
>>>
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/mod.rs:743
>>>
>>> task '<unnamed>' failed at 'Error running custom build command',
>>>
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/lib.rs:517
>>>
>>> make: *** [install] Error 65
>>>
>>>
>>> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>>>
>>> I looked at some other Rust CI-enabled projects and found a similar
>>> error:
>>> https://travis-ci.org/eholk/rust-opencl/builds/17491630
>>> https://travis-ci.org/erickt/rust-zmq/builds/16353359
>>> https://travis-ci.org/erickt/rust-mustache/builds/16059551
>>> https://travis-ci.org/bjz/gl-rs/builds/16126945
>>> https://travis-ci.org/bjz/sax-rs/builds/16405581
>>>
>>> What is causing this error and how do I fix it?
>>>
>>> Cadence
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From jhasse at fastmail.fm  Wed Jan 29 13:13:23 2014
From: jhasse at fastmail.fm (Jan Niklas Hasse)
Date: Wed, 29 Jan 2014 13:13:23 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52E7071A.50702@mozilla.com>
References: <52E7071A.50702@mozilla.com>
Message-ID: <1391030003.16129.76945009.289252ED@webmail.messagingengine.com>

On Mon, Jan 27, 2014, at 05:25 PM, Brian Anderson wrote:
> Hey again, Rusticians.
> 
> So I think most of us know that rustpkg isn't quite working the way 
> people expect, and the general consensus seems to be that its flaws 
> extend pretty deep, to the point where it may just not be exposing the 
> right model. I'd like to deprecate it immediately to end the 
> frustrations people continue encountering with it, while we figure out 
> what to do with it.
> 
> Having a good packaging story is critical for Rust's adoption, so I want 
> to keep pushing on this. I am looking into hiring a domain expert to 
> help us.
> 
> Regards,
> Brian

Hi,

I'm very shocked and also very much against removing it. I've just
started with Rust a few months ago and actually rustpkg was the thing
that I liked the most. I know it's buggy and unfinished, but at least
the idea looked wonderful to me. I REALLY dislike the C++ world, where
everyone uses another build tool and it's kinda hard to depend on other
peoples work.

Does the "general consensus" mean the Mozilla devs? This bugs me a
little, because I've been using rustpkg and also fixed some bugs of it
in the past weeks and now I hear for the first time that it's going away
anyway? Why not drop a line on a pull request for rustpkg like "Hey btw:
It's not clear if rustpkg is going to stay, so better not invest to much
time into it ;)". Would have saved me some days digging into rustpkg.

So is this decision already final? If not I would work on fixing some of
rustpkg problems in the next week. I think this shouldn't be done by
rewriting it. Most of the time a rewrite is the wrong thing do (remember
Netscape?).

From danielmicay at gmail.com  Wed Jan 29 13:12:58 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 16:12:58 -0500
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
Message-ID: <CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>

On Wed, Jan 29, 2014 at 3:59 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Wednesday, January 29, 2014, Olivier LEMAIRE <olivier.lemaire at me.com>
> wrote:
>>
>> I suggest to submit a call/request (Rust wiki?) to find this team
>> member/role as crypto is damn needed in this digital age.
>
>
> I'd suggest Rust continue its current policy of keeping crypto out of
> stdlib.
>
> However, it'd be nice if there were an official "blessed" crypto package
> (using TBD packaging system). I think this library should/needs to be
> shipped with said TDB packaging system.
>
> Perhaps Mozilla could loop in its NSS people on rust-nss?

I don't think it's possible to make a nice NSS binding because it
depends on thread-local initialization. Green tasks may move between
threads so a context object is necessary. Other libraries don't have
this problem and a nicer interface can be exposed.

From jhasse at fastmail.fm  Wed Jan 29 13:16:16 2014
From: jhasse at fastmail.fm (Jan Niklas Hasse)
Date: Wed, 29 Jan 2014 13:16:16 -0800
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
Message-ID: <1391030176.17025.76948265.5854ABC6@webmail.messagingengine.com>

Hi,



can you run the rustpkg command again with



export RUST_LOG=rustpkg=4



first?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/f13c8368/attachment.html>

From matthewbot at gmail.com  Wed Jan 29 13:16:50 2014
From: matthewbot at gmail.com (Matthew Thompson)
Date: Wed, 29 Jan 2014 16:16:50 -0500
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <52E95F82.5050305@free.fr>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
	<52E52901.7020403@free.fr> <52E80876.70805@free.fr>
	<CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>
	<52E95F82.5050305@free.fr>
Message-ID: <CAO7SXVz+LwkLaacvyt12Jkc=iJfc1VAg+Wq+DASvCu31kZG54g@mail.gmail.com>

This means your project did not compile but rustpkg ate the compiler output
for some reason. For me, the compiler failure was because rustpkg build and
rustpkg install were silently failing (actually, falsely succeeding!) to
move build artifacts around that had explicit crate_id's in their lib.rs.
You see rustpkg claims to have installed portmidi#0.0, but likely it has a
crate_id other than 0.0 on it, which causes rustpkg to fail to move it.
When you run build and install, and when you refer to crates with extern
mod, you have to include the pound sign and proper crate id for it to work.
You can verify rustpkg build and install are functioning by looking inside
lib for libraries and bin for binaries. I'm probably switching away from
rustpkg too, as it's always a guessing game with poor error reporting and
documentation. cargo-lite does everything my project needs, but writing
Makefiles is so easy for rust because of its simple build model that I
don't see many downsides to simply doing that.


On Wed, Jan 29, 2014 at 3:07 PM, Philippe Delrieu
<philippe.delrieu at free.fr>wrote:

> Thank you for your help. I try, it correct the error but I have other
> message and nothing is generated :
>
> WARNING: The Rust package manager is experimental and may be unstable
> note: Installed package portmidi#0.0 to /home/pdelrieu/Documents/dev/
> musit/workplace_linux/PortMidi/master/rust-portmidi
> task '<unnamed>' failed at 'assertion failed: !outputs_disc.is_empty()',
> /home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/librustpkg/
> util.rs:552
> task '<unnamed>' failed at 'receiving on a closed channel',
> /home/pdelrieu/Documents/dev/musit/rust/rust/git/rust/src/libstd/comm/
> mod.rs:743
>
> The problem come from rustpkg or my project?
>
> Philippe
>
>
> Le 29/01/2014 15:09, Derek Guenther a ?crit :
>
>  I believe the workaround is:
>>
>> extern mod extra = "extra#0.10-pre";
>>
>> It's broken a few builds on rust-ci this week.
>>
>> Derek
>>
>> On Tue, Jan 28, 2014 at 1:43 PM, Philippe Delrieu
>> <philippe.delrieu at free.fr> wrote:
>>
>>> Any info or idea?
>>> I update from the master and now all my project have the same issue.
>>> If I use rustc I have no problem. I see the thread about rustpkg,
>>> perhaps I
>>> should migrate to rustc and cmake?
>>>
>>> Philippe
>>>
>>> Le 26/01/2014 16:25, Philippe Delrieu a ?crit :
>>>
>>> Hi,
>>>
>>> I have the same problem since 2 or 3 days with the portmidi project.
>>>
>>> Philippe
>>>
>>> Le 26/01/2014 14:06, Cadence Marseille a ?crit :
>>>
>>> Hi,
>>>
>>> I am seeing a new build error and I am not sure what is causing it.
>>> rust-pcre, libpcre bindings for Rust, is set up to use Travis and Rust
>>> CI.
>>> The latest build is failing with:
>>>
>>> rustpkg install pcre
>>>
>>> WARNING: The Rust package manager is experimental and may be unstable
>>>
>>> error: Package pcre depends on extra, but I don't know how to find it
>>>
>>> task '<unnamed>' failed at 'explicit failure',
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/
>>> util.rs:531
>>>
>>> task '<main>' failed at 'receiving on a closed channel',
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/libstd/comm/
>>> mod.rs:743
>>>
>>> task '<unnamed>' failed at 'Error running custom build command',
>>> /build/buildd/rust-nightly-201401260405~897a0a3~precise/src/librustpkg/
>>> lib.rs:517
>>>
>>> make: *** [install] Error 65
>>>
>>>
>>> See https://travis-ci.org/cadencemarseille/rust-pcre/builds/17643218
>>>
>>> I looked at some other Rust CI-enabled projects and found a similar
>>> error:
>>> https://travis-ci.org/eholk/rust-opencl/builds/17491630
>>> https://travis-ci.org/erickt/rust-zmq/builds/16353359
>>> https://travis-ci.org/erickt/rust-mustache/builds/16059551
>>> https://travis-ci.org/bjz/gl-rs/builds/16126945
>>> https://travis-ci.org/bjz/sax-rs/builds/16405581
>>>
>>> What is causing this error and how do I fix it?
>>>
>>> Cadence
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/fb9bb7da/attachment.html>

From bascule at gmail.com  Wed Jan 29 13:50:06 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 13:50:06 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
Message-ID: <CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>

On Wed, Jan 29, 2014 at 1:13 PM, Jan Niklas Hasse <jhasse at fastmail.fm>wrote:

> I'm very shocked and also very much against removing it. I've just
>  started with Rust a few months ago and actually rustpkg was the thing
> that I liked the most. I know it's buggy and unfinished, but at least
> the idea looked wonderful to me.


Just my 2c: I'd argue the complete opposite.

Package managers are things that are often created quite early in the
lifecycle of a language, and their design mistakes can haunt users of the
language and potentially doom the language itself. Once a package manager
is entrenched, typically there's no turning back, and you are left forever
trying to fix the mess you started with.

Moreover, there's the complex relationships of package managers, dependency
resolvers, and secure software update infrastructures to consider. I think
rustpkg was written in the absence of these considerations. I think
successful packaging/software update systems consider all these problems
up-front, so the MVP is at least future proof when it comes time to
consider things like, say, security.

If we aren't certain that rustpkg is a solid foundation, now is the time to
scrap it and build a better one. Otherwise we'll be stuck with it forever.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/ec4b85ee/attachment.html>

From bascule at gmail.com  Wed Jan 29 13:52:18 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 13:52:18 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
	<CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
Message-ID: <CAHOTMVKa_RzKJ-FqoBKSKKc9g91XwrwWFxw9EGwCUpxyk0DDxw@mail.gmail.com>

On Wed, Jan 29, 2014 at 1:12 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> I don't think it's possible to make a nice NSS binding because it
>  depends on thread-local initialization.


:(

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/0f7ab7ff/attachment-0001.html>

From vadimcn at gmail.com  Wed Jan 29 14:03:48 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 29 Jan 2014 14:03:48 -0800
Subject: [rust-dev] Futures in Rust
Message-ID: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>

After reading about the simultaneous stream reading/writing issue discussed
in the last meeting, I want to ask a question:  Maybe it's time to consider
using explicitly async I/O and futures?

Futures sort of already exist in the libextra, but they still rely on
pushing async operation into a separate task.  I wonder if Rust could
support in-task asynchronicity.   If we had that, the simultaneous
read/write example could be written as:

    let buffer1 = [u8, ..1024];
    let buffer2 = [u8, ..1024];
    ...
    let future1 = stream.read(buffer1);
    let future2 = stream.write(buffer2);
    let combined = wait_any(future1, future2); // new future that resolves
once any of its' parameters does
    combined.wait(); // wait till the combined future resolves
    if future1.is_complete() {
        let value = future1.get_result();
    }
    ...
Current proposals, such as stream splitting might work for that particular
case, but what about stuff like "read stream with a timeout"?   With
futures, that'd be easy - just combine the read future with a timer future
similarly to the above.  I am sure there are tons of other useful scenarios
that would be simplified with futures.

I know that currently there is a problem with preventing un-synchronized
access to local resources involved in the async operation.  In my example
above, the state of buffers is undefined until async operation is complete,
so they should be roped off for the duration.
But maybe Rust type system could grow a new type of borrow that prevents
all object access while it is in scope, similarly to how iterators prevent
mutation of the container being iterated?

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/baa3174b/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 14:06:41 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 17:06:41 -0500
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
Message-ID: <CA+DvKQKnd7o9EewAfsi_=0gSt_t51xvVxjdx2P078uz=HvDgdg@mail.gmail.com>

On Wed, Jan 29, 2014 at 5:03 PM, Vadim <vadimcn at gmail.com> wrote:
>
> But maybe Rust type system could grow a new type of borrow that prevents all
> object access while it is in scope, similarly to how iterators prevent
> mutation of the container being iterated?
>
> Vadim

An `&mut` borrow will prevent reads not through that borrow.

From kevin at sb.org  Wed Jan 29 14:11:45 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 29 Jan 2014 14:11:45 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
Message-ID: <ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>

This solution will not work for what I need stream splitting for. Namely, I need to be in the middle of reading from a socket when I decide that I need to write. I cannot be waiting on the read future at that time or I won't be able to start writing. And if I don't wait on the read future, I won't know when I have data available.

-Kevin

On Jan 29, 2014, at 2:03 PM, Vadim <vadimcn at gmail.com> wrote:

> After reading about the simultaneous stream reading/writing issue discussed in the last meeting, I want to ask a question:  Maybe it's time to consider using explicitly async I/O and futures?
> 
> Futures sort of already exist in the libextra, but they still rely on pushing async operation into a separate task.  I wonder if Rust could support in-task asynchronicity.   If we had that, the simultaneous read/write example could be written as:
> 
>     let buffer1 = [u8, ..1024];
>     let buffer2 = [u8, ..1024];
>     ...
>     let future1 = stream.read(buffer1);
>     let future2 = stream.write(buffer2);
>     let combined = wait_any(future1, future2); // new future that resolves once any of its' parameters does
>     combined.wait(); // wait till the combined future resolves
>     if future1.is_complete() {
>         let value = future1.get_result();
>     }
>     ...
> Current proposals, such as stream splitting might work for that particular case, but what about stuff like "read stream with a timeout"?   With futures, that'd be easy - just combine the read future with a timer future similarly to the above.  I am sure there are tons of other useful scenarios that would be simplified with futures.
> 
> I know that currently there is a problem with preventing un-synchronized access to local resources involved in the async operation.  In my example above, the state of buffers is undefined until async operation is complete, so they should be roped off for the duration.
> But maybe Rust type system could grow a new type of borrow that prevents all object access while it is in scope, similarly to how iterators prevent mutation of the container being iterated?
> 
> Vadim
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From bascule at gmail.com  Wed Jan 29 14:17:04 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Wed, 29 Jan 2014 14:17:04 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
Message-ID: <CAHOTMVKpZmBUKKzUfQZ49MFxm-_8GavO3fnZoiN-N+FBftJcTg@mail.gmail.com>

On Wed, Jan 29, 2014 at 2:11 PM, Kevin Ballard <kevin at sb.org> wrote:

> This solution will not work for what I need stream splitting for. Namely,
> I need to be in the middle of reading from a socket when I decide that I
> need to write. I cannot be waiting on the read future at that time or I
> won't be able to start writing. And if I don't wait on the read future, I
> won't know when I have data available.


I initially thought splitting streams was a good solution, but simultaneous
writes from multiple tasks (if you use a protocol with self-delimiting
frames) seems like a valid use case that is probably best addressed by
cloning streams rather than splitting them.

Cloning streams would allow both that use case and reduce the total number
of types, as splitting would result in a "type explosion" (e.g. TcpStream,
TcpReader, TcpWriter)

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/86d32da0/attachment.html>

From vadimcn at gmail.com  Wed Jan 29 14:19:22 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 29 Jan 2014 14:19:22 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
Message-ID: <CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>

What event initiates the write?


On Wed, Jan 29, 2014 at 2:11 PM, Kevin Ballard <kevin at sb.org> wrote:

> This solution will not work for what I need stream splitting for. Namely,
> I need to be in the middle of reading from a socket when I decide that I
> need to write. I cannot be waiting on the read future at that time or I
> won't be able to start writing. And if I don't wait on the read future, I
> won't know when I have data available.
>
> -Kevin
>
> On Jan 29, 2014, at 2:03 PM, Vadim <vadimcn at gmail.com> wrote:
>
> > After reading about the simultaneous stream reading/writing issue
> discussed in the last meeting, I want to ask a question:  Maybe it's time
> to consider using explicitly async I/O and futures?
> >
> > Futures sort of already exist in the libextra, but they still rely on
> pushing async operation into a separate task.  I wonder if Rust could
> support in-task asynchronicity.   If we had that, the simultaneous
> read/write example could be written as:
> >
> >     let buffer1 = [u8, ..1024];
> >     let buffer2 = [u8, ..1024];
> >     ...
> >     let future1 = stream.read(buffer1);
> >     let future2 = stream.write(buffer2);
> >     let combined = wait_any(future1, future2); // new future that
> resolves once any of its' parameters does
> >     combined.wait(); // wait till the combined future resolves
> >     if future1.is_complete() {
> >         let value = future1.get_result();
> >     }
> >     ...
> > Current proposals, such as stream splitting might work for that
> particular case, but what about stuff like "read stream with a timeout"?
> With futures, that'd be easy - just combine the read future with a timer
> future similarly to the above.  I am sure there are tons of other useful
> scenarios that would be simplified with futures.
> >
> > I know that currently there is a problem with preventing un-synchronized
> access to local resources involved in the async operation.  In my example
> above, the state of buffers is undefined until async operation is complete,
> so they should be roped off for the duration.
> > But maybe Rust type system could grow a new type of borrow that prevents
> all object access while it is in scope, similarly to how iterators prevent
> mutation of the container being iterated?
> >
> > Vadim
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/5b5345b3/attachment.html>

From pcwalton at mozilla.com  Wed Jan 29 14:35:21 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 29 Jan 2014 14:35:21 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
	<CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
Message-ID: <52E98229.5070607@mozilla.com>

On 1/29/14 1:12 PM, Daniel Micay wrote:
> On Wed, Jan 29, 2014 at 3:59 PM, Tony Arcieri <bascule at gmail.com> wrote:
>> On Wednesday, January 29, 2014, Olivier LEMAIRE <olivier.lemaire at me.com>
>> wrote:
>>>
>>> I suggest to submit a call/request (Rust wiki?) to find this team
>>> member/role as crypto is damn needed in this digital age.
>>
>>
>> I'd suggest Rust continue its current policy of keeping crypto out of
>> stdlib.
>>
>> However, it'd be nice if there were an official "blessed" crypto package
>> (using TBD packaging system). I think this library should/needs to be
>> shipped with said TDB packaging system.
>>
>> Perhaps Mozilla could loop in its NSS people on rust-nss?
>
> I don't think it's possible to make a nice NSS binding because it
> depends on thread-local initialization. Green tasks may move between
> threads so a context object is necessary. Other libraries don't have
> this problem and a nicer interface can be exposed.

What's wrong with a context object? Rust supports OO method dispatch 
syntax, so context objects look and feel quite idiomatic.

Patrick


From vadimcn at gmail.com  Wed Jan 29 14:39:01 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 29 Jan 2014 14:39:01 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CA+DvKQKnd7o9EewAfsi_=0gSt_t51xvVxjdx2P078uz=HvDgdg@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<CA+DvKQKnd7o9EewAfsi_=0gSt_t51xvVxjdx2P078uz=HvDgdg@mail.gmail.com>
Message-ID: <CADecdiJQpo9vE=uu5s-cfJo+atUxWVUCPuJA4hdM-=zjA2tpew@mail.gmail.com>

I've tried to simulate that with iterators, but it seems I can still read
the buffer.   This compiles without errors:

    let mut buf = [0, ..1024];
    let mut iter = buf.mut_iter();
    let x = buf[0];
    *iter.next().unwrap() = 2; // just to make sure I can mutate via the
iterator




On Wed, Jan 29, 2014 at 2:06 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Wed, Jan 29, 2014 at 5:03 PM, Vadim <vadimcn at gmail.com> wrote:
> >
> > But maybe Rust type system could grow a new type of borrow that prevents
> all
> > object access while it is in scope, similarly to how iterators prevent
> > mutation of the container being iterated?
> >
> > Vadim
>
> An `&mut` borrow will prevent reads not through that borrow.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/504556f2/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 14:45:40 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 17:45:40 -0500
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <52E98229.5070607@mozilla.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
	<CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
	<52E98229.5070607@mozilla.com>
Message-ID: <CA+DvKQJGgFL+N2h0fnbp9VZptNpr9-HF+SjpPcTm21VDkX+q3Q@mail.gmail.com>

On Wed, Jan 29, 2014 at 5:35 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 1/29/14 1:12 PM, Daniel Micay wrote:
>>
>> On Wed, Jan 29, 2014 at 3:59 PM, Tony Arcieri <bascule at gmail.com> wrote:
>>>
>>> On Wednesday, January 29, 2014, Olivier LEMAIRE <olivier.lemaire at me.com>
>>> wrote:
>>>>
>>>>
>>>> I suggest to submit a call/request (Rust wiki?) to find this team
>>>> member/role as crypto is damn needed in this digital age.
>>>
>>>
>>>
>>> I'd suggest Rust continue its current policy of keeping crypto out of
>>> stdlib.
>>>
>>> However, it'd be nice if there were an official "blessed" crypto package
>>> (using TBD packaging system). I think this library should/needs to be
>>> shipped with said TDB packaging system.
>>>
>>> Perhaps Mozilla could loop in its NSS people on rust-nss?
>>
>> I don't think it's possible to make a nice NSS binding because it
>> depends on thread-local initialization. Green tasks may move between
>> threads so a context object is necessary. Other libraries don't have
>> this problem and a nicer interface can be exposed.
>
> What's wrong with a context object? Rust supports OO method dispatch syntax,
> so context objects look and feel quite idiomatic.
>
> Patrick

It's more painful than the same API without a context object, whether
or not it feels idiomatic. It seems like NSS actually requires a
single *global* initialization at the moment, but it's the same kind
of problem (some other cryptography libraries use thread-local state
and NSS may do it too).

From pcwalton at mozilla.com  Wed Jan 29 14:49:31 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 29 Jan 2014 14:49:31 -0800
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CA+DvKQJGgFL+N2h0fnbp9VZptNpr9-HF+SjpPcTm21VDkX+q3Q@mail.gmail.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
	<CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
	<52E98229.5070607@mozilla.com>
	<CA+DvKQJGgFL+N2h0fnbp9VZptNpr9-HF+SjpPcTm21VDkX+q3Q@mail.gmail.com>
Message-ID: <52E9857B.2090903@mozilla.com>

On 1/29/14 2:45 PM, Daniel Micay wrote:
> It's more painful than the same API without a context object, whether
> or not it feels idiomatic.

I disagree. Context objects are very nice for making state explicit. 
OpenGL, for example, would be a far nicer API if it used context objects 
instead of being dependent on hidden global state everywhere.

Patrick


From palmercox at gmail.com  Wed Jan 29 15:16:08 2014
From: palmercox at gmail.com (Palmer Cox)
Date: Wed, 29 Jan 2014 18:16:08 -0500
Subject: [rust-dev] Moving libcrypto back into rust repo?
In-Reply-To: <CAHOTMVKa_RzKJ-FqoBKSKKc9g91XwrwWFxw9EGwCUpxyk0DDxw@mail.gmail.com>
References: <7vmtri07fps05r5lx15mo5w1.1391028237619@email.android.com>
	<CAHOTMV+y5EmwQAJtCrEqE=aXNLduc0toUJ_BJtNtGszod43JDA@mail.gmail.com>
	<CA+DvKQLBKZ9bWSptVNmm7nL3gv+R3cnkR_P_UZiWELW-uDDpFw@mail.gmail.com>
	<CAHOTMVKa_RzKJ-FqoBKSKKc9g91XwrwWFxw9EGwCUpxyk0DDxw@mail.gmail.com>
Message-ID: <CAPZendySTR+Xe48L=dTUnvo5Z9vf+RgTSJYYyRzh2xQ=xZ8=-w@mail.gmail.com>

Hi,

I'm the maintainer of rust-crypto. It originally started as extra::crypto,
buts its grown a few new features since then - AES, RC4, HMAC, and a few
key derivation functions.

Saying that it hasn't been fully audited is really too kind - it hasn't
been audited at all. Documentation is quite thin. And there is no support
for any public key algorithms or TLS. Rust-crypto is a young crypto
library, and maybe one day it will grow into a stable, audited, fully
featured one, but its a long way off from that point. Anyway, rust-crypto
isn't appropriate to be used as a standard library for Rust at this time
and won't be for the foreseeable future.

-Palmer Cox



On Wed, Jan 29, 2014 at 4:52 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Wed, Jan 29, 2014 at 1:12 PM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> I don't think it's possible to make a nice NSS binding because it
>>  depends on thread-local initialization.
>
>
> :(
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/438dd715/attachment.html>

From kevin at sb.org  Wed Jan 29 15:54:22 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 29 Jan 2014 15:54:22 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CAHOTMVKpZmBUKKzUfQZ49MFxm-_8GavO3fnZoiN-N+FBftJcTg@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
	<CAHOTMVKpZmBUKKzUfQZ49MFxm-_8GavO3fnZoiN-N+FBftJcTg@mail.gmail.com>
Message-ID: <13E334DB-D80C-4811-BEDC-7F82622D9A4D@sb.org>

Cloning the stream is the current approach being explored. See https://github.com/mozilla/rust/pull/11894.

-Kevin

On Jan 29, 2014, at 2:17 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Wed, Jan 29, 2014 at 2:11 PM, Kevin Ballard <kevin at sb.org> wrote:
> This solution will not work for what I need stream splitting for. Namely, I need to be in the middle of reading from a socket when I decide that I need to write. I cannot be waiting on the read future at that time or I won't be able to start writing. And if I don't wait on the read future, I won't know when I have data available.
> 
> I initially thought splitting streams was a good solution, but simultaneous writes from multiple tasks (if you use a protocol with self-delimiting frames) seems like a valid use case that is probably best addressed by cloning streams rather than splitting them.
> 
> Cloning streams would allow both that use case and reduce the total number of types, as splitting would result in a "type explosion" (e.g. TcpStream, TcpReader, TcpWriter)
> 
> -- 
> Tony Arcieri

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/9848c9dc/attachment.html>

From kevin at sb.org  Wed Jan 29 15:55:54 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 29 Jan 2014 15:55:54 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
	<CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>
Message-ID: <F6B37E4F-FF21-44A5-BA0A-9340DEFD45CF@sb.org>

Any number of things.

The use case here is an interactive protocol where writes go in both directions, and can be initiated in response to external events. The classic example is an IRC bot. The server can send a message at any time, so the IRC bot needs to be constantly reading, but writes back to the socket are not necessarily initiated directly in response to reads, they may be initiated due to asynchronous operations, or keyboard input at the terminal, or any number of other external stimuli.

-Kevin

On Jan 29, 2014, at 2:19 PM, Vadim <vadimcn at gmail.com> wrote:

> What event initiates the write?
> 
> 
> On Wed, Jan 29, 2014 at 2:11 PM, Kevin Ballard <kevin at sb.org> wrote:
> This solution will not work for what I need stream splitting for. Namely, I need to be in the middle of reading from a socket when I decide that I need to write. I cannot be waiting on the read future at that time or I won't be able to start writing. And if I don't wait on the read future, I won't know when I have data available.
> 
> -Kevin
> 
> On Jan 29, 2014, at 2:03 PM, Vadim <vadimcn at gmail.com> wrote:
> 
> > After reading about the simultaneous stream reading/writing issue discussed in the last meeting, I want to ask a question:  Maybe it's time to consider using explicitly async I/O and futures?
> >
> > Futures sort of already exist in the libextra, but they still rely on pushing async operation into a separate task.  I wonder if Rust could support in-task asynchronicity.   If we had that, the simultaneous read/write example could be written as:
> >
> >     let buffer1 = [u8, ..1024];
> >     let buffer2 = [u8, ..1024];
> >     ...
> >     let future1 = stream.read(buffer1);
> >     let future2 = stream.write(buffer2);
> >     let combined = wait_any(future1, future2); // new future that resolves once any of its' parameters does
> >     combined.wait(); // wait till the combined future resolves
> >     if future1.is_complete() {
> >         let value = future1.get_result();
> >     }
> >     ...
> > Current proposals, such as stream splitting might work for that particular case, but what about stuff like "read stream with a timeout"?   With futures, that'd be easy - just combine the read future with a timer future similarly to the above.  I am sure there are tons of other useful scenarios that would be simplified with futures.
> >
> > I know that currently there is a problem with preventing un-synchronized access to local resources involved in the async operation.  In my example above, the state of buffers is undefined until async operation is complete, so they should be roped off for the duration.
> > But maybe Rust type system could grow a new type of borrow that prevents all object access while it is in scope, similarly to how iterators prevent mutation of the container being iterated?
> >
> > Vadim
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/3191888e/attachment-0001.html>

From me at kevincantu.org  Wed Jan 29 16:04:36 2014
From: me at kevincantu.org (Kevin Cantu)
Date: Thu, 30 Jan 2014 00:04:36 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
Message-ID: <CABq6+af-7iOzL4tN5rzJf6n-m_vLDQqUwro=ioCwNRLo-QdTEA@mail.gmail.com>

Yeah, neither rustpkg nor cargo before it (which I'd contributed to) solved
the interesting problems.  Chalk it up to CADT and let's move on.

Kevin
On Jan 29, 2014 9:50 PM, "Tony Arcieri" <bascule at gmail.com> wrote:

> On Wed, Jan 29, 2014 at 1:13 PM, Jan Niklas Hasse <jhasse at fastmail.fm>wrote:
>
>> I'm very shocked and also very much against removing it. I've just
>>  started with Rust a few months ago and actually rustpkg was the thing
>> that I liked the most. I know it's buggy and unfinished, but at least
>> the idea looked wonderful to me.
>
>
> Just my 2c: I'd argue the complete opposite.
>
> Package managers are things that are often created quite early in the
> lifecycle of a language, and their design mistakes can haunt users of the
> language and potentially doom the language itself. Once a package manager
> is entrenched, typically there's no turning back, and you are left forever
> trying to fix the mess you started with.
>
> Moreover, there's the complex relationships of package managers,
> dependency resolvers, and secure software update infrastructures to
> consider. I think rustpkg was written in the absence of these
> considerations. I think successful packaging/software update systems
> consider all these problems up-front, so the MVP is at least future proof
> when it comes time to consider things like, say, security.
>
> If we aren't certain that rustpkg is a solid foundation, now is the time
> to scrap it and build a better one. Otherwise we'll be stuck with it
> forever.
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/3b33df92/attachment.html>

From vadimcn at gmail.com  Wed Jan 29 16:16:54 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 29 Jan 2014 16:16:54 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <F6B37E4F-FF21-44A5-BA0A-9340DEFD45CF@sb.org>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
	<CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>
	<F6B37E4F-FF21-44A5-BA0A-9340DEFD45CF@sb.org>
Message-ID: <CADecdiJcdhUHu2MqAyWke7c2f0JheR3nKpZ-xAtemO79ve410w@mail.gmail.com>

On Wed, Jan 29, 2014 at 3:55 PM, Kevin Ballard <kevin at sb.org> wrote:

> Any number of things.
>
> The use case here is an interactive protocol where writes go in both
> directions, and can be initiated in response to external events. The
> classic example is an IRC bot. The server can send a message at any time,
> so the IRC bot needs to be constantly reading, but writes back to the
> socket are not necessarily initiated directly in response to reads, they
> may be initiated due to asynchronous operations, or keyboard input at the
> terminal, or any number of other external stimuli.
>

In this case you'd be waiting on futures from those external events as
well.   I am assuming that all of I/O would be future-ized, not just TCP
streams.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/86211aa2/attachment.html>

From kevin at sb.org  Wed Jan 29 16:53:49 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 29 Jan 2014 16:53:49 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <CADecdiJcdhUHu2MqAyWke7c2f0JheR3nKpZ-xAtemO79ve410w@mail.gmail.com>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
	<CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>
	<F6B37E4F-FF21-44A5-BA0A-9340DEFD45CF@sb.org>
	<CADecdiJcdhUHu2MqAyWke7c2f0JheR3nKpZ-xAtemO79ve410w@mail.gmail.com>
Message-ID: <46C68440-8670-4B05-BDE2-90E9C6703946@sb.org>

On Jan 29, 2014, at 4:16 PM, Vadim <vadimcn at gmail.com> wrote:

> 
> 
> 
> On Wed, Jan 29, 2014 at 3:55 PM, Kevin Ballard <kevin at sb.org> wrote:
> Any number of things.
> 
> The use case here is an interactive protocol where writes go in both directions, and can be initiated in response to external events. The classic example is an IRC bot. The server can send a message at any time, so the IRC bot needs to be constantly reading, but writes back to the socket are not necessarily initiated directly in response to reads, they may be initiated due to asynchronous operations, or keyboard input at the terminal, or any number of other external stimuli.
> 
> In this case you'd be waiting on futures from those external events as well.   I am assuming that all of I/O would be future-ized, not just TCP streams.

"external events" does not necessarily mean I/O. It could also mean some asynchronous computation inside the app.

And if you're going to try and claim that this can be represented by futures too in this same scheme, well, it pretty much sounds like you're reinventing the generic Select. Or perhaps I should call it a run loop.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/4b91b8ba/attachment.html>

From vadimcn at gmail.com  Wed Jan 29 17:52:44 2014
From: vadimcn at gmail.com (Vadim)
Date: Wed, 29 Jan 2014 17:52:44 -0800
Subject: [rust-dev] Futures in Rust
In-Reply-To: <46C68440-8670-4B05-BDE2-90E9C6703946@sb.org>
References: <CADecdiKY03SEcgE2=18E9isHWYQ5PyYcr_RnBpmLLTNn9BV0vw@mail.gmail.com>
	<ED4BAB1F-8A3F-4EBA-971C-0F0A1F92FAF3@sb.org>
	<CADecdiKruOUaL09UR8djboHquTQOAPjn9_f+srYd=Xg2e66FSw@mail.gmail.com>
	<F6B37E4F-FF21-44A5-BA0A-9340DEFD45CF@sb.org>
	<CADecdiJcdhUHu2MqAyWke7c2f0JheR3nKpZ-xAtemO79ve410w@mail.gmail.com>
	<46C68440-8670-4B05-BDE2-90E9C6703946@sb.org>
Message-ID: <CADecdiLBu2SXBdWJNF2RB5wkn7zhm5mpCnidfHA_p++tk-jbBg@mail.gmail.com>

Sure, we can call it a generalization of select.

But, (assuming you mean posix select()) they wouldn't be limited to fd's,
could be more granular (not just "ready for read/write/error"), and they
compose better.

Also, if we could find a way to rope off the buffers, I/O would place data
directly into the user buffer, thus avoiding one data copy and the read()
or write() call, which normally would be needed after a select().



On Wed, Jan 29, 2014 at 4:53 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 29, 2014, at 4:16 PM, Vadim <vadimcn at gmail.com> wrote:
>
>
>
>
> On Wed, Jan 29, 2014 at 3:55 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> Any number of things.
>>
>> The use case here is an interactive protocol where writes go in both
>> directions, and can be initiated in response to external events. The
>> classic example is an IRC bot. The server can send a message at any time,
>> so the IRC bot needs to be constantly reading, but writes back to the
>> socket are not necessarily initiated directly in response to reads, they
>> may be initiated due to asynchronous operations, or keyboard input at the
>> terminal, or any number of other external stimuli.
>>
>
> In this case you'd be waiting on futures from those external events as
> well.   I am assuming that all of I/O would be future-ized, not just TCP
> streams.
>
>
> "external events" does not necessarily mean I/O. It could also mean some
> asynchronous computation inside the app.
>
> And if you're going to try and claim that this can be represented by
> futures too in this same scheme, well, it pretty much sounds like you're
> reinventing the generic Select. Or perhaps I should call it a run loop.
>
> -Kevin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/fdaafa64/attachment.html>

From space.ship.traveller at gmail.com  Wed Jan 29 18:34:29 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 15:34:29 +1300
Subject: [rust-dev] "let mut" <-> "var"
Message-ID: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>

Perhaps this has been considered already, but when I'm reading rust code
"let mut" just seems to stick out all over the place. Why not add a "var"
keyword that does the same thing? I think there are lots of good and bad
reasons to do this or not do it, but I just wanted to propose the idea and
see what other people are thinking.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/742eedce/attachment-0001.html>

From pcwalton at mozilla.com  Wed Jan 29 18:35:53 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 29 Jan 2014 18:35:53 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
Message-ID: <52E9BA89.6030702@mozilla.com>

On 1/29/14 6:34 PM, Samuel Williams wrote:
> Perhaps this has been considered already, but when I'm reading rust code
> "let mut" just seems to stick out all over the place. Why not add a
> "var" keyword that does the same thing? I think there are lots of good
> and bad reasons to do this or not do it, but I just wanted to propose
> the idea and see what other people are thinking.

`let` takes a pattern. `mut` is a modifier on variables in a pattern. It 
is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`, 
`let (mut x, mut y) = ...`, and so forth.

Having a special "var" syntax would defeat this orthogonality.

Patrick


From banderson at mozilla.com  Wed Jan 29 18:43:13 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 29 Jan 2014 18:43:13 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52E9BA89.6030702@mozilla.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com>
Message-ID: <52E9BC41.5010300@mozilla.com>

On 01/29/2014 06:35 PM, Patrick Walton wrote:
> On 1/29/14 6:34 PM, Samuel Williams wrote:
>> Perhaps this has been considered already, but when I'm reading rust code
>> "let mut" just seems to stick out all over the place. Why not add a
>> "var" keyword that does the same thing? I think there are lots of good
>> and bad reasons to do this or not do it, but I just wanted to propose
>> the idea and see what other people are thinking.
>
> `let` takes a pattern. `mut` is a modifier on variables in a pattern. 
> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = 
> ...`, `let (mut x, mut y) = ...`, and so forth.
>
> Having a special "var" syntax would defeat this orthogonality.

`var` could potentially just be special-case sugar for `let mut`.

From kevin at sb.org  Wed Jan 29 18:50:27 2014
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 29 Jan 2014 18:50:27 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52E9BC41.5010300@mozilla.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
Message-ID: <034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>

On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com> wrote:

> On 01/29/2014 06:35 PM, Patrick Walton wrote:
>> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>> Perhaps this has been considered already, but when I'm reading rust code
>>> "let mut" just seems to stick out all over the place. Why not add a
>>> "var" keyword that does the same thing? I think there are lots of good
>>> and bad reasons to do this or not do it, but I just wanted to propose
>>> the idea and see what other people are thinking.
>> 
>> `let` takes a pattern. `mut` is a modifier on variables in a pattern. It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`, `let (mut x, mut y) = ...`, and so forth.
>> 
>> Having a special "var" syntax would defeat this orthogonality.
> 
> `var` could potentially just be special-case sugar for `let mut`.

To what end? Users still need to know about `mut` for all the other uses of patterns. This would reserve a new keyword and appear to duplicate functionality for no gain.

-Kevin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/664ad29e/attachment.p7s>

From smcarthur at mozilla.com  Wed Jan 29 18:52:51 2014
From: smcarthur at mozilla.com (Sean McArthur)
Date: Wed, 29 Jan 2014 18:52:51 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
Message-ID: <CAHrH6bNbKGdZj00MJPS78qMPxj6540jmR4z1Q+tmGvp4kX0zkg@mail.gmail.com>

Part of the nice thing about `let mut` is that it requires you to opt-in to
mutability, making it a conscious choice.

Having `let` and `var` would make Rust be like ES6: we all look at `let`
and say "why bother". For Rust, I imagine many would get into the habit of
using `var` over `let` because it's easier, and as code samples show up
using it, newcomers would default to using `var`.


On Wed, Jan 29, 2014 at 6:50 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com> wrote:
>
> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
> >>> Perhaps this has been considered already, but when I'm reading rust
> code
> >>> "let mut" just seems to stick out all over the place. Why not add a
> >>> "var" keyword that does the same thing? I think there are lots of good
> >>> and bad reasons to do this or not do it, but I just wanted to propose
> >>> the idea and see what other people are thinking.
> >>
> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
> `let (mut x, mut y) = ...`, and so forth.
> >>
> >> Having a special "var" syntax would defeat this orthogonality.
> >
> > `var` could potentially just be special-case sugar for `let mut`.
>
> To what end? Users still need to know about `mut` for all the other uses
> of patterns. This would reserve a new keyword and appear to duplicate
> functionality for no gain.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/5bb7e666/attachment.html>

From mozilla at mcpherrin.ca  Wed Jan 29 18:56:37 2014
From: mozilla at mcpherrin.ca (Matthew McPherrin)
Date: Wed, 29 Jan 2014 18:56:37 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
Message-ID: <CAMYrfjJF7yU7w6G=ZtbCOh_+NLnnjgSSMa7aR-Zp38fVYxzfAA@mail.gmail.com>

"let mut" is to some degree syntactic salt, in my mind.   Minimizing
mutability as the easy thing to do creates better code, I think.  That
isn't to say mutability is a bad thing, but more that you should think
about whether you need it when you're writing code.

I'm not convinced the incremental language complexity is worth it.  Let
with a pattern is pretty elegant IMHO and I'd rather not mess with it.


On Wed, Jan 29, 2014 at 6:50 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com> wrote:
>
> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
> >>> Perhaps this has been considered already, but when I'm reading rust
> code
> >>> "let mut" just seems to stick out all over the place. Why not add a
> >>> "var" keyword that does the same thing? I think there are lots of good
> >>> and bad reasons to do this or not do it, but I just wanted to propose
> >>> the idea and see what other people are thinking.
> >>
> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
> `let (mut x, mut y) = ...`, and so forth.
> >>
> >> Having a special "var" syntax would defeat this orthogonality.
> >
> > `var` could potentially just be special-case sugar for `let mut`.
>
> To what end? Users still need to know about `mut` for all the other uses
> of patterns. This would reserve a new keyword and appear to duplicate
> functionality for no gain.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/57c8fe9f/attachment.html>

From space.ship.traveller at gmail.com  Wed Jan 29 18:59:51 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 15:59:51 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
Message-ID: <CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>

I guess the main gain would be less typing of what seems to be a reasonably
common sequence, and the formalisation of a particular semantic pattern
which makes it easier to recognise the code when you visually scanning it.


On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com> wrote:
>
> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
> >>> Perhaps this has been considered already, but when I'm reading rust
> code
> >>> "let mut" just seems to stick out all over the place. Why not add a
> >>> "var" keyword that does the same thing? I think there are lots of good
> >>> and bad reasons to do this or not do it, but I just wanted to propose
> >>> the idea and see what other people are thinking.
> >>
> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
> `let (mut x, mut y) = ...`, and so forth.
> >>
> >> Having a special "var" syntax would defeat this orthogonality.
> >
> > `var` could potentially just be special-case sugar for `let mut`.
>
> To what end? Users still need to know about `mut` for all the other uses
> of patterns. This would reserve a new keyword and appear to duplicate
> functionality for no gain.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/e2cd0bae/attachment-0001.html>

From danielmicay at gmail.com  Wed Jan 29 19:05:18 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 22:05:18 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHrH6bNbKGdZj00MJPS78qMPxj6540jmR4z1Q+tmGvp4kX0zkg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHrH6bNbKGdZj00MJPS78qMPxj6540jmR4z1Q+tmGvp4kX0zkg@mail.gmail.com>
Message-ID: <CA+DvKQKdwY_AqVBgV7ffcx0bK8pGFgQadgds+pHz2UZU68sBoQ@mail.gmail.com>

On Wed, Jan 29, 2014 at 9:52 PM, Sean McArthur <smcarthur at mozilla.com> wrote:
> Part of the nice thing about `let mut` is that it requires you to opt-in to
> mutability, making it a conscious choice.
>
> Having `let` and `var` would make Rust be like ES6: we all look at `let` and
> say "why bother". For Rust, I imagine many would get into the habit of using
> `var` over `let` because it's easier, and as code samples show up using it,
> newcomers would default to using `var`.

Rust does give a warning when variables are unnecessarily mutable.

From space.ship.traveller at gmail.com  Wed Jan 29 19:09:05 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 16:09:05 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
Message-ID: <CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>

I agree that it is syntactic salt and that the design is to discourage
mutability. I actually appreciate that point as a programmer.

w.r.t. this specific issue: I think what concerns me is that it is quite a
high burden for new programmers (I teach COSC1xx courses to new students so
I have some idea about the level of new programmers). For example, you need
to know more detail about what is going on - new programmers would find
that difficult as it is one more concept to overflow their heads.

Adding "var" as a keyword identically maps to new programmer's expectations
from JavaScript. Writing a program entirely using "var" wouldn't cause any
problems right? But, could be optimised more (potentially) if using "let"
for immutable parts.

Anyway, I'm not convinced either way, I'm not sure I see the entire picture
yet. But, if I was writing code, I'd certainly get sick of writing "let
mut" over and over again - and looking at existing rust examples, that
certainly seems like the norm..






On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com>wrote:

> I guess the main gain would be less typing of what seems to be a
> reasonably common sequence, and the formalisation of a particular semantic
> pattern which makes it easier to recognise the code when you visually
> scanning it.
>
>
> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>> wrote:
>>
>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>> >>> Perhaps this has been considered already, but when I'm reading rust
>> code
>> >>> "let mut" just seems to stick out all over the place. Why not add a
>> >>> "var" keyword that does the same thing? I think there are lots of good
>> >>> and bad reasons to do this or not do it, but I just wanted to propose
>> >>> the idea and see what other people are thinking.
>> >>
>> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
>> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
>> `let (mut x, mut y) = ...`, and so forth.
>> >>
>> >> Having a special "var" syntax would defeat this orthogonality.
>> >
>> > `var` could potentially just be special-case sugar for `let mut`.
>>
>> To what end? Users still need to know about `mut` for all the other uses
>> of patterns. This would reserve a new keyword and appear to duplicate
>> functionality for no gain.
>>
>> -Kevin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/9bce3f42/attachment.html>

From corey at octayn.net  Wed Jan 29 19:11:37 2014
From: corey at octayn.net (Corey Richardson)
Date: Wed, 29 Jan 2014 22:11:37 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
Message-ID: <CA++BO6TMcZF9uN-HQBuXY3GrfcpgYKvpSP-1xCZOwDYt3U=58A@mail.gmail.com>

Last I did a survey, `let mut` was less than half (and more around
30-40%) of the `lets` I found, though it wasn't exhaustive. It's also
important to note that Rust is not a language suited for new
programmers. Far too many concerns; it tackles hard problems and makes
tradeoffs that new programmers don't particularly benefit from, esp.
pedagogically.

(I also teach new programmers, at Thinkful)

On Wed, Jan 29, 2014 at 10:09 PM, Samuel Williams
<space.ship.traveller at gmail.com> wrote:
> I agree that it is syntactic salt and that the design is to discourage
> mutability. I actually appreciate that point as a programmer.
>
> w.r.t. this specific issue: I think what concerns me is that it is quite a
> high burden for new programmers (I teach COSC1xx courses to new students so
> I have some idea about the level of new programmers). For example, you need
> to know more detail about what is going on - new programmers would find that
> difficult as it is one more concept to overflow their heads.
>
> Adding "var" as a keyword identically maps to new programmer's expectations
> from JavaScript. Writing a program entirely using "var" wouldn't cause any
> problems right? But, could be optimised more (potentially) if using "let"
> for immutable parts.
>
> Anyway, I'm not convinced either way, I'm not sure I see the entire picture
> yet. But, if I was writing code, I'd certainly get sick of writing "let mut"
> over and over again - and looking at existing rust examples, that certainly
> seems like the norm..
>
>
>
>
>
>
> On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com>
> wrote:
>>
>> I guess the main gain would be less typing of what seems to be a
>> reasonably common sequence, and the formalisation of a particular semantic
>> pattern which makes it easier to recognise the code when you visually
>> scanning it.
>>
>>
>> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>>> wrote:
>>>
>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>> >>> Perhaps this has been considered already, but when I'm reading rust
>>> >>> code
>>> >>> "let mut" just seems to stick out all over the place. Why not add a
>>> >>> "var" keyword that does the same thing? I think there are lots of
>>> >>> good
>>> >>> and bad reasons to do this or not do it, but I just wanted to propose
>>> >>> the idea and see what other people are thinking.
>>> >>
>>> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
>>> >> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
>>> >> `let (mut x, mut y) = ...`, and so forth.
>>> >>
>>> >> Having a special "var" syntax would defeat this orthogonality.
>>> >
>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>
>>> To what end? Users still need to know about `mut` for all the other uses
>>> of patterns. This would reserve a new keyword and appear to duplicate
>>> functionality for no gain.
>>>
>>> -Kevin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From dbau.pp at gmail.com  Wed Jan 29 19:13:16 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 30 Jan 2014 14:13:16 +1100
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
Message-ID: <52E9C34C.7040108@gmail.com>

On 30/01/14 14:09, Samuel Williams wrote:
> I agree that it is syntactic salt and that the design is to discourage 
> mutability. I actually appreciate that point as a programmer.
>
> w.r.t. this specific issue: I think what concerns me is that it is 
> quite a high burden for new programmers (I teach COSC1xx courses to 
> new students so I have some idea about the level of new programmers). 
> For example, you need to know more detail about what is going on - new 
> programmers would find that difficult as it is one more concept to 
> overflow their heads.
>
> Adding "var" as a keyword identically maps to new programmer's 
> expectations from JavaScript. Writing a program entirely using "var" 
> wouldn't cause any problems right? But, could be optimised more 
> (potentially) if using "let" for immutable parts.
>
> Anyway, I'm not convinced either way, I'm not sure I see the entire 
> picture yet. But, if I was writing code, I'd certainly get sick of 
> writing "let mut" over and over again - and looking at existing rust 
> examples, that certainly seems like the norm..
>

Inside the main rust repository:

$  git grep 'let ' -- '*.rs' | grep -v mut | wc -l
17172
$ git grep 'let ' -- '*.rs' | grep mut | wc -l
5735

i.e. there are approximately 3 times more non-mutable variable bindings 
than there are mutable ones.

>
>
>
>
>
> On 30 January 2014 15:59, Samuel Williams 
> <space.ship.traveller at gmail.com 
> <mailto:space.ship.traveller at gmail.com>> wrote:
>
>     I guess the main gain would be less typing of what seems to be a
>     reasonably common sequence, and the formalisation of a particular
>     semantic pattern which makes it easier to recognise the code when
>     you visually scanning it.
>
>
>     On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org
>     <mailto:kevin at sb.org>> wrote:
>
>         On Jan 29, 2014, at 6:43 PM, Brian Anderson
>         <banderson at mozilla.com <mailto:banderson at mozilla.com>> wrote:
>
>         > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>         >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>         >>> Perhaps this has been considered already, but when I'm
>         reading rust code
>         >>> "let mut" just seems to stick out all over the place. Why
>         not add a
>         >>> "var" keyword that does the same thing? I think there are
>         lots of good
>         >>> and bad reasons to do this or not do it, but I just wanted
>         to propose
>         >>> the idea and see what other people are thinking.
>         >>
>         >> `let` takes a pattern. `mut` is a modifier on variables in
>         a pattern. It is reasonable to write `let (x, mut y) = ...`,
>         `let (mut x, y) = ...`, `let (mut x, mut y) = ...`, and so forth.
>         >>
>         >> Having a special "var" syntax would defeat this orthogonality.
>         >
>         > `var` could potentially just be special-case sugar for `let
>         mut`.
>
>         To what end? Users still need to know about `mut` for all the
>         other uses of patterns. This would reserve a new keyword and
>         appear to duplicate functionality for no gain.
>
>         -Kevin
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/fa6c3994/attachment-0001.html>

From space.ship.traveller at gmail.com  Wed Jan 29 19:18:18 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 16:18:18 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52E9C34C.7040108@gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<52E9C34C.7040108@gmail.com>
Message-ID: <CAHkN8V8QiRQgmiOtibs3LxYziOsob4h57rF7p_tZwXmujffVzQ@mail.gmail.com>

Do you think for client code it would be the same proportion as in
"library" code?


On 30 January 2014 16:13, Huon Wilson <dbau.pp at gmail.com> wrote:

>  On 30/01/14 14:09, Samuel Williams wrote:
>
> I agree that it is syntactic salt and that the design is to discourage
> mutability. I actually appreciate that point as a programmer.
>
>  w.r.t. this specific issue: I think what concerns me is that it is quite
> a high burden for new programmers (I teach COSC1xx courses to new students
> so I have some idea about the level of new programmers). For example, you
> need to know more detail about what is going on - new programmers would
> find that difficult as it is one more concept to overflow their heads.
>
>  Adding "var" as a keyword identically maps to new programmer's
> expectations from JavaScript. Writing a program entirely using "var"
> wouldn't cause any problems right? But, could be optimised more
> (potentially) if using "let" for immutable parts.
>
>  Anyway, I'm not convinced either way, I'm not sure I see the entire
> picture yet. But, if I was writing code, I'd certainly get sick of writing
> "let mut" over and over again - and looking at existing rust examples, that
> certainly seems like the norm..
>
>
> Inside the main rust repository:
>
> $  git grep 'let ' -- '*.rs' | grep -v mut | wc -l
> 17172
> $ git grep 'let ' -- '*.rs' | grep mut | wc -l
> 5735
>
> i.e. there are approximately 3 times more non-mutable variable bindings
> than there are mutable ones.
>
>
>
>
>
>
>
> On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com>wrote:
>
>> I guess the main gain would be less typing of what seems to be a
>> reasonably common sequence, and the formalisation of a particular semantic
>> pattern which makes it easier to recognise the code when you visually
>> scanning it.
>>
>>
>>  On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>>
>>>  On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>>> wrote:
>>>
>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>> >>> Perhaps this has been considered already, but when I'm reading rust
>>> code
>>> >>> "let mut" just seems to stick out all over the place. Why not add a
>>> >>> "var" keyword that does the same thing? I think there are lots of
>>> good
>>> >>> and bad reasons to do this or not do it, but I just wanted to propose
>>> >>> the idea and see what other people are thinking.
>>> >>
>>> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
>>> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
>>> `let (mut x, mut y) = ...`, and so forth.
>>> >>
>>> >> Having a special "var" syntax would defeat this orthogonality.
>>> >
>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>
>>>  To what end? Users still need to know about `mut` for all the other
>>> uses of patterns. This would reserve a new keyword and appear to duplicate
>>> functionality for no gain.
>>>
>>> -Kevin
>>>  _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/275c7259/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 19:18:42 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 22:18:42 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
Message-ID: <CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>

On Wed, Jan 29, 2014 at 10:09 PM, Samuel Williams
<space.ship.traveller at gmail.com> wrote:
> I agree that it is syntactic salt and that the design is to discourage
> mutability. I actually appreciate that point as a programmer.
>
> w.r.t. this specific issue: I think what concerns me is that it is quite a
> high burden for new programmers (I teach COSC1xx courses to new students so
> I have some idea about the level of new programmers). For example, you need
> to know more detail about what is going on - new programmers would find that
> difficult as it is one more concept to overflow their heads.

Either way, Rust is going to warn when there is unnecessary mutability.

> Adding "var" as a keyword identically maps to new programmer's expectations
> from JavaScript. Writing a program entirely using "var" wouldn't cause any
> problems right?

Rust has block scope, so `var` would match what `let` does in JavaScript.

> But, could be optimised more (potentially) if using "let" for immutable parts.

It really doesn't introduce any potential optimizations.

From space.ship.traveller at gmail.com  Wed Jan 29 19:20:45 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 16:20:45 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
Message-ID: <CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>

What about constant folding? Surely let mut x = 10 is easier for the
compiler to optimise?


On 30 January 2014 16:18, Daniel Micay <danielmicay at gmail.com> wrote:

> On Wed, Jan 29, 2014 at 10:09 PM, Samuel Williams
> <space.ship.traveller at gmail.com> wrote:
> > I agree that it is syntactic salt and that the design is to discourage
> > mutability. I actually appreciate that point as a programmer.
> >
> > w.r.t. this specific issue: I think what concerns me is that it is quite
> a
> > high burden for new programmers (I teach COSC1xx courses to new students
> so
> > I have some idea about the level of new programmers). For example, you
> need
> > to know more detail about what is going on - new programmers would find
> that
> > difficult as it is one more concept to overflow their heads.
>
> Either way, Rust is going to warn when there is unnecessary mutability.
>
> > Adding "var" as a keyword identically maps to new programmer's
> expectations
> > from JavaScript. Writing a program entirely using "var" wouldn't cause
> any
> > problems right?
>
> Rust has block scope, so `var` would match what `let` does in JavaScript.
>
> > But, could be optimised more (potentially) if using "let" for immutable
> parts.
>
> It really doesn't introduce any potential optimizations.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/310748ca/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 19:20:48 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 22:20:48 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V8QiRQgmiOtibs3LxYziOsob4h57rF7p_tZwXmujffVzQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<52E9C34C.7040108@gmail.com>
	<CAHkN8V8QiRQgmiOtibs3LxYziOsob4h57rF7p_tZwXmujffVzQ@mail.gmail.com>
Message-ID: <CA+DvKQJB8bDvjPEUxKHePtK0X4UwzHe7skeh-6xxs0Bkge7BEg@mail.gmail.com>

On Wed, Jan 29, 2014 at 10:18 PM, Samuel Williams
<space.ship.traveller at gmail.com> wrote:
> Do you think for client code it would be the same proportion as in "library"
> code?

High-level code won't need nearly as much mutability. One example is
the lack of a need to use loop control variables in most cases now. The
Rust codebase is also far from being a completely modern dialect of
the language and uses much more mutability than it needs to.

From pcwalton at mozilla.com  Wed Jan 29 19:21:23 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 29 Jan 2014 19:21:23 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
Message-ID: <52E9C533.5070806@mozilla.com>

On 1/29/14 7:20 PM, Samuel Williams wrote:
> What about constant folding? Surely let mut x = 10 is easier for the
> compiler to optimise?

In less advanced compilers, that may be true. But Rust internally 
converts everything to SSA, so there is no difference.

Patrick


From space.ship.traveller at gmail.com  Wed Jan 29 19:21:33 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 16:21:33 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
Message-ID: <CAHkN8V975LtqaGKTywnA5wypDo2nz5R+kqQc4ih+ffRhrkspcQ@mail.gmail.com>

Whoops, my bad, let x = 10 (should be easier to optimise) :D



On 30 January 2014 16:20, Samuel Williams <space.ship.traveller at gmail.com>wrote:

> What about constant folding? Surely let mut x = 10 is easier for the
> compiler to optimise?
>
>
> On 30 January 2014 16:18, Daniel Micay <danielmicay at gmail.com> wrote:
>
>> On Wed, Jan 29, 2014 at 10:09 PM, Samuel Williams
>> <space.ship.traveller at gmail.com> wrote:
>> > I agree that it is syntactic salt and that the design is to discourage
>> > mutability. I actually appreciate that point as a programmer.
>> >
>> > w.r.t. this specific issue: I think what concerns me is that it is
>> quite a
>> > high burden for new programmers (I teach COSC1xx courses to new
>> students so
>> > I have some idea about the level of new programmers). For example, you
>> need
>> > to know more detail about what is going on - new programmers would find
>> that
>> > difficult as it is one more concept to overflow their heads.
>>
>> Either way, Rust is going to warn when there is unnecessary mutability.
>>
>> > Adding "var" as a keyword identically maps to new programmer's
>> expectations
>> > from JavaScript. Writing a program entirely using "var" wouldn't cause
>> any
>> > problems right?
>>
>> Rust has block scope, so `var` would match what `let` does in JavaScript.
>>
>> > But, could be optimised more (potentially) if using "let" for immutable
>> parts.
>>
>> It really doesn't introduce any potential optimizations.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/c17fadc3/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 19:21:25 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 22:21:25 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
Message-ID: <CA+DvKQ+gOSLKP6=gGAautqjRt6tdJ1ONo3swwS=A1Ai1x9KCXg@mail.gmail.com>

On Wed, Jan 29, 2014 at 10:20 PM, Samuel Williams
<space.ship.traveller at gmail.com> wrote:
> What about constant folding? Surely let mut x = 10 is easier for the
> compiler to optimise?

Rust can warn with 100% accuracy if a variable is unnecessarily
mutable. So, there's no benefit in terms of optimizations.

From space.ship.traveller at gmail.com  Wed Jan 29 19:26:54 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 16:26:54 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52E9C533.5070806@mozilla.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
	<52E9C533.5070806@mozilla.com>
Message-ID: <CAHkN8V-6o+4+Exypa_hvqebAtP_+JmKsDwHYkCRBWO44Nz9gzw@mail.gmail.com>

Interesting - so if there is no difference, what is the point of "let mut" ?


On 30 January 2014 16:21, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 1/29/14 7:20 PM, Samuel Williams wrote:
>
>> What about constant folding? Surely let mut x = 10 is easier for the
>> compiler to optimise?
>>
>
> In less advanced compilers, that may be true. But Rust internally converts
> everything to SSA, so there is no difference.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/4858fe28/attachment.html>

From dbau.pp at gmail.com  Wed Jan 29 19:28:16 2014
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 30 Jan 2014 14:28:16 +1100
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V8QiRQgmiOtibs3LxYziOsob4h57rF7p_tZwXmujffVzQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>	<52E9C34C.7040108@gmail.com>
	<CAHkN8V8QiRQgmiOtibs3LxYziOsob4h57rF7p_tZwXmujffVzQ@mail.gmail.com>
Message-ID: <52E9C6D0.1010507@gmail.com>

Running the same commands just inside src/librustc (which is essentially 
client code) gives:

let mut = 1051
let (no mut) = 5752

So the ratio is even more skewed toward immutable lets, and, librustc is 
written in "old" Rust, so I can only see the ratio moving away from let 
mut even more: e.g. there are still instances of patterns like `let mut 
v = ~[]; for x in iter { v.push(x); }` rather than just `let v = 
iter.collect();`.


(Obviously those grep commands give a very simplistic view, but I think 
it's accurate enough to demonstrate that `let mut` is not the common case.)

On 30/01/14 14:18, Samuel Williams wrote:
> Do you think for client code it would be the same proportion as in 
> "library" code?
>
>
> On 30 January 2014 16:13, Huon Wilson <dbau.pp at gmail.com 
> <mailto:dbau.pp at gmail.com>> wrote:
>
>     On 30/01/14 14:09, Samuel Williams wrote:
>>     I agree that it is syntactic salt and that the design is to
>>     discourage mutability. I actually appreciate that point as a
>>     programmer.
>>
>>     w.r.t. this specific issue: I think what concerns me is that it
>>     is quite a high burden for new programmers (I teach COSC1xx
>>     courses to new students so I have some idea about the level of
>>     new programmers). For example, you need to know more detail about
>>     what is going on - new programmers would find that difficult as
>>     it is one more concept to overflow their heads.
>>
>>     Adding "var" as a keyword identically maps to new programmer's
>>     expectations from JavaScript. Writing a program entirely using
>>     "var" wouldn't cause any problems right? But, could be optimised
>>     more (potentially) if using "let" for immutable parts.
>>
>>     Anyway, I'm not convinced either way, I'm not sure I see the
>>     entire picture yet. But, if I was writing code, I'd certainly get
>>     sick of writing "let mut" over and over again - and looking at
>>     existing rust examples, that certainly seems like the norm..
>>
>
>     Inside the main rust repository:
>
>     $  git grep 'let ' -- '*.rs' | grep -v mut | wc -l
>     17172
>     $ git grep 'let ' -- '*.rs' | grep mut | wc -l
>     5735
>
>     i.e. there are approximately 3 times more non-mutable variable
>     bindings than there are mutable ones.
>
>
>>
>>
>>
>>
>>
>>     On 30 January 2014 15:59, Samuel Williams
>>     <space.ship.traveller at gmail.com
>>     <mailto:space.ship.traveller at gmail.com>> wrote:
>>
>>         I guess the main gain would be less typing of what seems to
>>         be a reasonably common sequence, and the formalisation of a
>>         particular semantic pattern which makes it easier to
>>         recognise the code when you visually scanning it.
>>
>>
>>         On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org
>>         <mailto:kevin at sb.org>> wrote:
>>
>>             On Jan 29, 2014, at 6:43 PM, Brian Anderson
>>             <banderson at mozilla.com <mailto:banderson at mozilla.com>> wrote:
>>
>>             > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>             >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>             >>> Perhaps this has been considered already, but when
>>             I'm reading rust code
>>             >>> "let mut" just seems to stick out all over the place.
>>             Why not add a
>>             >>> "var" keyword that does the same thing? I think there
>>             are lots of good
>>             >>> and bad reasons to do this or not do it, but I just
>>             wanted to propose
>>             >>> the idea and see what other people are thinking.
>>             >>
>>             >> `let` takes a pattern. `mut` is a modifier on
>>             variables in a pattern. It is reasonable to write `let
>>             (x, mut y) = ...`, `let (mut x, y) = ...`, `let (mut x,
>>             mut y) = ...`, and so forth.
>>             >>
>>             >> Having a special "var" syntax would defeat this
>>             orthogonality.
>>             >
>>             > `var` could potentially just be special-case sugar for
>>             `let mut`.
>>
>>             To what end? Users still need to know about `mut` for all
>>             the other uses of patterns. This would reserve a new
>>             keyword and appear to duplicate functionality for no gain.
>>
>>             -Kevin
>>             _______________________________________________
>>             Rust-dev mailing list
>>             Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>             https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>>
>>
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org  <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/6ebf4989/attachment-0001.html>

From cgaebel at uwaterloo.ca  Wed Jan 29 19:29:37 2014
From: cgaebel at uwaterloo.ca (Clark Gaebel)
Date: Wed, 29 Jan 2014 22:29:37 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V-6o+4+Exypa_hvqebAtP_+JmKsDwHYkCRBWO44Nz9gzw@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
	<52E9C533.5070806@mozilla.com>
	<CAHkN8V-6o+4+Exypa_hvqebAtP_+JmKsDwHYkCRBWO44Nz9gzw@mail.gmail.com>
Message-ID: <CA+aES6Pp2SmDg+ZXh7MPRuCrPq++5GzfT9oR5At4Qz=Z97grOQ@mail.gmail.com>

'let mut' signals a let binding to a mutable variable...?


On Wed, Jan 29, 2014 at 10:26 PM, Samuel Williams <
space.ship.traveller at gmail.com> wrote:

> Interesting - so if there is no difference, what is the point of "let mut"
> ?
>
>
> On 30 January 2014 16:21, Patrick Walton <pcwalton at mozilla.com> wrote:
>
>> On 1/29/14 7:20 PM, Samuel Williams wrote:
>>
>>> What about constant folding? Surely let mut x = 10 is easier for the
>>> compiler to optimise?
>>>
>>
>> In less advanced compilers, that may be true. But Rust internally
>> converts everything to SSA, so there is no difference.
>>
>> Patrick
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Clark.

Key ID     : 0x78099922
Fingerprint: B292 493C 51AE F3AB D016  DD04 E5E3 C36F 5534 F907
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/ecd3360d/attachment.html>

From danielmicay at gmail.com  Wed Jan 29 19:30:53 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 29 Jan 2014 22:30:53 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V-6o+4+Exypa_hvqebAtP_+JmKsDwHYkCRBWO44Nz9gzw@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CA+DvKQ+MXdRFk=ojNTdRNO_b80Cc8xmq=t2R8ZaVv-UNycihxg@mail.gmail.com>
	<CAHkN8V8GUKGK244X5WFjAes8a3tAxFVw_jB3sTncGYKpt3qvDQ@mail.gmail.com>
	<52E9C533.5070806@mozilla.com>
	<CAHkN8V-6o+4+Exypa_hvqebAtP_+JmKsDwHYkCRBWO44Nz9gzw@mail.gmail.com>
Message-ID: <CA+DvKQ+9U0q4dL8gGKDJN5gnhhqXfXKmJgnhqDDbSKUDrAzPFA@mail.gmail.com>

On Wed, Jan 29, 2014 at 10:26 PM, Samuel Williams
<space.ship.traveller at gmail.com> wrote:
> Interesting - so if there is no difference, what is the point of "let mut" ?

It's there for humans like most of the language features. You know
most variables are not mutated from a glance.

From jfager at gmail.com  Wed Jan 29 20:07:44 2014
From: jfager at gmail.com (Jason Fager)
Date: Wed, 29 Jan 2014 23:07:44 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
Message-ID: <CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>

You *should* get sick of writing 'let mut' all over the place, not just b/c
of the syntax but b/c you're using mutable variables "all over the place".
 Casual mutability kills maintainability.

Affordances matter.  I'm convinced that the reason Option.unwrap() is used
so frequently is b/c it's the shortest method name and requires the
fewest explicit decisions, and so is the easiest thing to reach for.  If it
were unwrap_or_fail("reason"), forcing you to both type more and to think
about a fail message, unwrap_or and unwrap_or_else wouldn't look as
difficult in comparison.  or and or_else would be even better, or
'do' syntax now that the keyword's free again.

Make the Right Thing the easy thing, and don't put effort into making the
Wrong Thing as easy or easier.



On Wednesday, January 29, 2014, Samuel Williams <
space.ship.traveller at gmail.com> wrote:

> I agree that it is syntactic salt and that the design is to discourage
> mutability. I actually appreciate that point as a programmer.
>
> w.r.t. this specific issue: I think what concerns me is that it is quite a
> high burden for new programmers (I teach COSC1xx courses to new students so
> I have some idea about the level of new programmers). For example, you need
> to know more detail about what is going on - new programmers would find
> that difficult as it is one more concept to overflow their heads.
>
> Adding "var" as a keyword identically maps to new programmer's
> expectations from JavaScript. Writing a program entirely using "var"
> wouldn't cause any problems right? But, could be optimised more
> (potentially) if using "let" for immutable parts.
>
> Anyway, I'm not convinced either way, I'm not sure I see the entire
> picture yet. But, if I was writing code, I'd certainly get sick of writing
> "let mut" over and over again - and looking at existing rust examples, that
> certainly seems like the norm..
>
>
>
>
>
>
> On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com<javascript:_e({}, 'cvml', 'space.ship.traveller at gmail.com');>
> > wrote:
>
>> I guess the main gain would be less typing of what seems to be a
>> reasonably common sequence, and the formalisation of a particular semantic
>> pattern which makes it easier to recognise the code when you visually
>> scanning it.
>>
>>
>> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org <javascript:_e({},
>> 'cvml', 'kevin at sb.org');>> wrote:
>>
>>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com<javascript:_e({}, 'cvml', 'banderson at mozilla.com');>>
>>> wrote:
>>>
>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>> >>> Perhaps this has been considered already, but when I'm reading rust
>>> code
>>> >>> "let mut" just seems to stick out all over the place. Why not add a
>>> >>> "var" keyword that does the same thing? I think there are lots of
>>> good
>>> >>> and bad reasons to do this or not do it, but I just wanted to propose
>>> >>> the idea and see what other people are thinking.
>>> >>
>>> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern.
>>> It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`,
>>> `let (mut x, mut y) = ...`, and so forth.
>>> >>
>>> >> Having a special "var" syntax would defeat this orthogonality.
>>> >
>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>
>>> To what end? Users still need to know about `mut` for all the other uses
>>> of patterns. This would reserve a new keyword and appear to duplicate
>>> functionality for no gain.
>>>
>>> -Kevin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml',
>>> 'Rust-dev at mozilla.org');>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/b64dc8d8/attachment.html>

From space.ship.traveller at gmail.com  Wed Jan 29 20:18:18 2014
From: space.ship.traveller at gmail.com (Samuel Williams)
Date: Thu, 30 Jan 2014 17:18:18 +1300
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
Message-ID: <CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>

Jason, I haven't actually written any rust code (yet). I'm just commenting
based on reading other people's code - it was something I noticed in a few
examples - it might have been bad form (assuming that mutable data are the
"Wrong Thing"?). I brought it up because I wasn't sure if it was something
that had been considered. It made the code I was reading look a bit clunky
(which appears to be the desired result).


On 30 January 2014 17:07, Jason Fager <jfager at gmail.com> wrote:

> You *should* get sick of writing 'let mut' all over the place, not
> just b/c of the syntax but b/c you're using mutable variables "all over the
> place".  Casual mutability kills maintainability.
>
> Affordances matter.  I'm convinced that the reason Option.unwrap() is used
> so frequently is b/c it's the shortest method name and requires the
> fewest explicit decisions, and so is the easiest thing to reach for.  If it
> were unwrap_or_fail("reason"), forcing you to both type more and to think
> about a fail message, unwrap_or and unwrap_or_else wouldn't look as
> difficult in comparison.  or and or_else would be even better, or
> 'do' syntax now that the keyword's free again.
>
> Make the Right Thing the easy thing, and don't put effort into making the
> Wrong Thing as easy or easier.
>
>
>
> On Wednesday, January 29, 2014, Samuel Williams <
> space.ship.traveller at gmail.com> wrote:
>
>> I agree that it is syntactic salt and that the design is to discourage
>> mutability. I actually appreciate that point as a programmer.
>>
>> w.r.t. this specific issue: I think what concerns me is that it is quite
>> a high burden for new programmers (I teach COSC1xx courses to new students
>> so I have some idea about the level of new programmers). For example, you
>> need to know more detail about what is going on - new programmers would
>> find that difficult as it is one more concept to overflow their heads.
>>
>> Adding "var" as a keyword identically maps to new programmer's
>> expectations from JavaScript. Writing a program entirely using "var"
>> wouldn't cause any problems right? But, could be optimised more
>> (potentially) if using "let" for immutable parts.
>>
>> Anyway, I'm not convinced either way, I'm not sure I see the entire
>> picture yet. But, if I was writing code, I'd certainly get sick of writing
>> "let mut" over and over again - and looking at existing rust examples, that
>> certainly seems like the norm..
>>
>>
>>
>>
>>
>>
>> On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com
>> > wrote:
>>
>>> I guess the main gain would be less typing of what seems to be a
>>> reasonably common sequence, and the formalisation of a particular semantic
>>> pattern which makes it easier to recognise the code when you visually
>>> scanning it.
>>>
>>>
>>> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>>>> wrote:
>>>>
>>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>>> >>> Perhaps this has been considered already, but when I'm reading rust
>>>> code
>>>> >>> "let mut" just seems to stick out all over the place. Why not add a
>>>> >>> "var" keyword that does the same thing? I think there are lots of
>>>> good
>>>> >>> and bad reasons to do this or not do it, but I just wanted to
>>>> propose
>>>> >>> the idea and see what other people are thinking.
>>>> >>
>>>> >> `let` takes a pattern. `mut` is a modifier on variables in a
>>>> pattern. It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y)
>>>> = ...`, `let (mut x, mut y) = ...`, and so forth.
>>>> >>
>>>> >> Having a special "var" syntax would defeat this orthogonality.
>>>> >
>>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>>
>>>> To what end? Users still need to know about `mut` for all the other
>>>> uses of patterns. This would reserve a new keyword and appear to duplicate
>>>> functionality for no gain.
>>>>
>>>> -Kevin
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/45b67f28/attachment-0001.html>

From haoyi.sg at gmail.com  Wed Jan 29 20:31:01 2014
From: haoyi.sg at gmail.com (Haoyi Li)
Date: Thu, 30 Jan 2014 12:31:01 +0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
Message-ID: <CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>

Sorry to parachute in to the conversation (long time lurker) but just to
add to the statistics, the Scala standard library and compiler has
11875:54575 ratio of mutable (var) vs immutable (val) declarations, so it
seems to match pretty well with the numbers you guys are seeing in the rust
libraries.


On Thu, Jan 30, 2014 at 12:18 PM, Samuel Williams <
space.ship.traveller at gmail.com> wrote:

> Jason, I haven't actually written any rust code (yet). I'm just commenting
> based on reading other people's code - it was something I noticed in a few
> examples - it might have been bad form (assuming that mutable data are the
> "Wrong Thing"?). I brought it up because I wasn't sure if it was something
> that had been considered. It made the code I was reading look a bit clunky
> (which appears to be the desired result).
>
>
> On 30 January 2014 17:07, Jason Fager <jfager at gmail.com> wrote:
>
>> You *should* get sick of writing 'let mut' all over the place, not
>> just b/c of the syntax but b/c you're using mutable variables "all over the
>> place".  Casual mutability kills maintainability.
>>
>> Affordances matter.  I'm convinced that the reason Option.unwrap() is
>> used so frequently is b/c it's the shortest method name and requires the
>> fewest explicit decisions, and so is the easiest thing to reach for.  If it
>> were unwrap_or_fail("reason"), forcing you to both type more and to think
>> about a fail message, unwrap_or and unwrap_or_else wouldn't look as
>> difficult in comparison.  or and or_else would be even better, or
>> 'do' syntax now that the keyword's free again.
>>
>> Make the Right Thing the easy thing, and don't put effort into making the
>> Wrong Thing as easy or easier.
>>
>>
>>
>> On Wednesday, January 29, 2014, Samuel Williams <
>> space.ship.traveller at gmail.com> wrote:
>>
>>> I agree that it is syntactic salt and that the design is to discourage
>>> mutability. I actually appreciate that point as a programmer.
>>>
>>> w.r.t. this specific issue: I think what concerns me is that it is quite
>>> a high burden for new programmers (I teach COSC1xx courses to new students
>>> so I have some idea about the level of new programmers). For example, you
>>> need to know more detail about what is going on - new programmers would
>>> find that difficult as it is one more concept to overflow their heads.
>>>
>>> Adding "var" as a keyword identically maps to new programmer's
>>> expectations from JavaScript. Writing a program entirely using "var"
>>> wouldn't cause any problems right? But, could be optimised more
>>> (potentially) if using "let" for immutable parts.
>>>
>>> Anyway, I'm not convinced either way, I'm not sure I see the entire
>>> picture yet. But, if I was writing code, I'd certainly get sick of writing
>>> "let mut" over and over again - and looking at existing rust examples, that
>>> certainly seems like the norm..
>>>
>>>
>>>
>>>
>>>
>>>
>>> On 30 January 2014 15:59, Samuel Williams <
>>> space.ship.traveller at gmail.com> wrote:
>>>
>>>> I guess the main gain would be less typing of what seems to be a
>>>> reasonably common sequence, and the formalisation of a particular semantic
>>>> pattern which makes it easier to recognise the code when you visually
>>>> scanning it.
>>>>
>>>>
>>>> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>>>>> wrote:
>>>>>
>>>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>>>> >>> Perhaps this has been considered already, but when I'm reading
>>>>> rust code
>>>>> >>> "let mut" just seems to stick out all over the place. Why not add a
>>>>> >>> "var" keyword that does the same thing? I think there are lots of
>>>>> good
>>>>> >>> and bad reasons to do this or not do it, but I just wanted to
>>>>> propose
>>>>> >>> the idea and see what other people are thinking.
>>>>> >>
>>>>> >> `let` takes a pattern. `mut` is a modifier on variables in a
>>>>> pattern. It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y)
>>>>> = ...`, `let (mut x, mut y) = ...`, and so forth.
>>>>> >>
>>>>> >> Having a special "var" syntax would defeat this orthogonality.
>>>>> >
>>>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>>>
>>>>> To what end? Users still need to know about `mut` for all the other
>>>>> uses of patterns. This would reserve a new keyword and appear to duplicate
>>>>> functionality for no gain.
>>>>>
>>>>> -Kevin
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>
>>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/8e5b5ed6/attachment.html>

From gaetan at xeberon.net  Wed Jan 29 23:32:33 2014
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 30 Jan 2014 08:32:33 +0100
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
Message-ID: <CANK7tAGOvAQKyss0nG87qviic7tQuc07Y802q_LGO_EFqUfQyQ@mail.gmail.com>

I like the fact that is more expensive to write let mut than let. So you
initialize mutable variable on purpose
Le 30 janv. 2014 05:31, "Haoyi Li" <haoyi.sg at gmail.com> a ?crit :

> Sorry to parachute in to the conversation (long time lurker) but just to
> add to the statistics, the Scala standard library and compiler has
> 11875:54575 ratio of mutable (var) vs immutable (val) declarations, so it
> seems to match pretty well with the numbers you guys are seeing in the rust
> libraries.
>
>
> On Thu, Jan 30, 2014 at 12:18 PM, Samuel Williams <
> space.ship.traveller at gmail.com> wrote:
>
>> Jason, I haven't actually written any rust code (yet). I'm just
>> commenting based on reading other people's code - it was something I
>> noticed in a few examples - it might have been bad form (assuming that
>> mutable data are the "Wrong Thing"?). I brought it up because I wasn't sure
>> if it was something that had been considered. It made the code I was
>> reading look a bit clunky (which appears to be the desired result).
>>
>>
>> On 30 January 2014 17:07, Jason Fager <jfager at gmail.com> wrote:
>>
>>> You *should* get sick of writing 'let mut' all over the place, not
>>> just b/c of the syntax but b/c you're using mutable variables "all over the
>>> place".  Casual mutability kills maintainability.
>>>
>>> Affordances matter.  I'm convinced that the reason Option.unwrap() is
>>> used so frequently is b/c it's the shortest method name and requires the
>>> fewest explicit decisions, and so is the easiest thing to reach for.  If it
>>> were unwrap_or_fail("reason"), forcing you to both type more and to think
>>> about a fail message, unwrap_or and unwrap_or_else wouldn't look as
>>> difficult in comparison.  or and or_else would be even better, or
>>> 'do' syntax now that the keyword's free again.
>>>
>>> Make the Right Thing the easy thing, and don't put effort into making
>>> the Wrong Thing as easy or easier.
>>>
>>>
>>>
>>> On Wednesday, January 29, 2014, Samuel Williams <
>>> space.ship.traveller at gmail.com> wrote:
>>>
>>>> I agree that it is syntactic salt and that the design is to discourage
>>>> mutability. I actually appreciate that point as a programmer.
>>>>
>>>> w.r.t. this specific issue: I think what concerns me is that it is
>>>> quite a high burden for new programmers (I teach COSC1xx courses to new
>>>> students so I have some idea about the level of new programmers). For
>>>> example, you need to know more detail about what is going on - new
>>>> programmers would find that difficult as it is one more concept to overflow
>>>> their heads.
>>>>
>>>> Adding "var" as a keyword identically maps to new programmer's
>>>> expectations from JavaScript. Writing a program entirely using "var"
>>>> wouldn't cause any problems right? But, could be optimised more
>>>> (potentially) if using "let" for immutable parts.
>>>>
>>>> Anyway, I'm not convinced either way, I'm not sure I see the entire
>>>> picture yet. But, if I was writing code, I'd certainly get sick of writing
>>>> "let mut" over and over again - and looking at existing rust examples, that
>>>> certainly seems like the norm..
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>
>>>> On 30 January 2014 15:59, Samuel Williams <
>>>> space.ship.traveller at gmail.com> wrote:
>>>>
>>>>> I guess the main gain would be less typing of what seems to be a
>>>>> reasonably common sequence, and the formalisation of a particular semantic
>>>>> pattern which makes it easier to recognise the code when you visually
>>>>> scanning it.
>>>>>
>>>>>
>>>>> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
>>>>>
>>>>>> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com>
>>>>>> wrote:
>>>>>>
>>>>>> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
>>>>>> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
>>>>>> >>> Perhaps this has been considered already, but when I'm reading
>>>>>> rust code
>>>>>> >>> "let mut" just seems to stick out all over the place. Why not add
>>>>>> a
>>>>>> >>> "var" keyword that does the same thing? I think there are lots of
>>>>>> good
>>>>>> >>> and bad reasons to do this or not do it, but I just wanted to
>>>>>> propose
>>>>>> >>> the idea and see what other people are thinking.
>>>>>> >>
>>>>>> >> `let` takes a pattern. `mut` is a modifier on variables in a
>>>>>> pattern. It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y)
>>>>>> = ...`, `let (mut x, mut y) = ...`, and so forth.
>>>>>> >>
>>>>>> >> Having a special "var" syntax would defeat this orthogonality.
>>>>>> >
>>>>>> > `var` could potentially just be special-case sugar for `let mut`.
>>>>>>
>>>>>> To what end? Users still need to know about `mut` for all the other
>>>>>> uses of patterns. This would reserve a new keyword and appear to duplicate
>>>>>> functionality for no gain.
>>>>>>
>>>>>> -Kevin
>>>>>> _______________________________________________
>>>>>> Rust-dev mailing list
>>>>>> Rust-dev at mozilla.org
>>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>>
>>>>>>
>>>>>
>>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/c13da3ab/attachment-0001.html>

From olivier.lemaire at me.com  Wed Jan 29 23:46:50 2014
From: olivier.lemaire at me.com (Olivier Lemaire)
Date: Thu, 30 Jan 2014 08:46:50 +0100
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CANK7tAGOvAQKyss0nG87qviic7tQuc07Y802q_LGO_EFqUfQyQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CANK7tAGOvAQKyss0nG87qviic7tQuc07Y802q_LGO_EFqUfQyQ@mail.gmail.com>
Message-ID: <E0994C65-02A7-438B-9A3B-965015C3E1E3@me.com>

Hi list,

I?d like the fact ?a = 10? or ?mut a = 10? are shorter to write than ?let a = 10? or ?let mut a = 10?.
On the other hand, I *really* appreciate the fact `grep -ri let src/ | grep (or -v) mut` will return me quickly where the variable declaration are.
So in the end, I feel I can ?pay?/suffer for 3 more characters to write (?let?) for the second hand benefits. 

(notwithstanding other far more important/structural arguments already presented in this thread, that rationalise the fact ?let/let mut? is a excellent choice anyhow :).

my 2 cents of Rust beginner. 
? 
lem

On 30 Jan 2014, at 08:32, Gaetan <gaetan at xeberon.net> wrote:

> I like the fact that is more expensive to write let mut than let. So you initialize mutable variable on purpose
> 
> Le 30 janv. 2014 05:31, "Haoyi Li" <haoyi.sg at gmail.com> a ?crit :
> Sorry to parachute in to the conversation (long time lurker) but just to add to the statistics, the Scala standard library and compiler has 11875:54575 ratio of mutable (var) vs immutable (val) declarations, so it seems to match pretty well with the numbers you guys are seeing in the rust libraries.
> 
> 
> On Thu, Jan 30, 2014 at 12:18 PM, Samuel Williams <space.ship.traveller at gmail.com> wrote:
> Jason, I haven't actually written any rust code (yet). I'm just commenting based on reading other people's code - it was something I noticed in a few examples - it might have been bad form (assuming that mutable data are the "Wrong Thing"?). I brought it up because I wasn't sure if it was something that had been considered. It made the code I was reading look a bit clunky (which appears to be the desired result).
> 
> 
> On 30 January 2014 17:07, Jason Fager <jfager at gmail.com> wrote:
> You *should* get sick of writing 'let mut' all over the place, not just b/c of the syntax but b/c you're using mutable variables "all over the place".  Casual mutability kills maintainability.
> 
> Affordances matter.  I'm convinced that the reason Option.unwrap() is used so frequently is b/c it's the shortest method name and requires the fewest explicit decisions, and so is the easiest thing to reach for.  If it were unwrap_or_fail("reason"), forcing you to both type more and to think about a fail message, unwrap_or and unwrap_or_else wouldn't look as difficult in comparison.  or and or_else would be even better, or 'do' syntax now that the keyword's free again.  
> 
> Make the Right Thing the easy thing, and don't put effort into making the Wrong Thing as easy or easier.
> 
> 
> 
> On Wednesday, January 29, 2014, Samuel Williams <space.ship.traveller at gmail.com> wrote:
> I agree that it is syntactic salt and that the design is to discourage mutability. I actually appreciate that point as a programmer.
> 
> w.r.t. this specific issue: I think what concerns me is that it is quite a high burden for new programmers (I teach COSC1xx courses to new students so I have some idea about the level of new programmers). For example, you need to know more detail about what is going on - new programmers would find that difficult as it is one more concept to overflow their heads.
> 
> Adding "var" as a keyword identically maps to new programmer's expectations from JavaScript. Writing a program entirely using "var" wouldn't cause any problems right? But, could be optimised more (potentially) if using "let" for immutable parts.
> 
> Anyway, I'm not convinced either way, I'm not sure I see the entire picture yet. But, if I was writing code, I'd certainly get sick of writing "let mut" over and over again - and looking at existing rust examples, that certainly seems like the norm..
> 
> 
> 
> 
> 
> 
> On 30 January 2014 15:59, Samuel Williams <space.ship.traveller at gmail.com> wrote:
> I guess the main gain would be less typing of what seems to be a reasonably common sequence, and the formalisation of a particular semantic pattern which makes it easier to recognise the code when you visually scanning it.
> 
> 
> On 30 January 2014 15:50, Kevin Ballard <kevin at sb.org> wrote:
> On Jan 29, 2014, at 6:43 PM, Brian Anderson <banderson at mozilla.com> wrote:
> 
> > On 01/29/2014 06:35 PM, Patrick Walton wrote:
> >> On 1/29/14 6:34 PM, Samuel Williams wrote:
> >>> Perhaps this has been considered already, but when I'm reading rust code
> >>> "let mut" just seems to stick out all over the place. Why not add a
> >>> "var" keyword that does the same thing? I think there are lots of good
> >>> and bad reasons to do this or not do it, but I just wanted to propose
> >>> the idea and see what other people are thinking.
> >>
> >> `let` takes a pattern. `mut` is a modifier on variables in a pattern. It is reasonable to write `let (x, mut y) = ...`, `let (mut x, y) = ...`, `let (mut x, mut y) = ...`, and so forth.
> >>
> >> Having a special "var" syntax would defeat this orthogonality.
> >
> > `var` could potentially just be special-case sugar for `let mut`.
> 
> To what end? Users still need to know about `mut` for all the other uses of patterns. This would reserve a new keyword and appear to duplicate functionality for no gain.
> 
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/b16f938f/attachment.html>

From hatahet at gmail.com  Wed Jan 29 23:47:09 2014
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 29 Jan 2014 23:47:09 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
Message-ID: <CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>

On Wed, Jan 29, 2014 at 8:31 PM, Haoyi Li <haoyi.sg at gmail.com> wrote:

> Sorry to parachute in to the conversation (long time lurker) but just to
> add to the statistics, the Scala standard library and compiler has
> 11875:54575 ratio of mutable (var) vs immutable (val) declarations, so it
> seems to match pretty well with the numbers you guys are seeing in the rust
> libraries.
>
>
That's interesting. However, Scala's `val` is the equivalent of Java's
`final`, and does not imply "total" immutability. For non-primitive types,
it only means that the reference is fixed to being bound to a specific
object. It does not mean that that object itself is immutable (unlike Rusts
`let`, or C++'s `const*`/`const&`). It is better than nothing, but it does
give a false sense of security at times. I really wish more languages
adopted Rust's way of doing immutability (I think D does something
similar); I wonder why it never caught on in the more popular languages.

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140129/0169ca9b/attachment.html>

From philippe.delrieu at free.fr  Wed Jan 29 23:48:00 2014
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 30 Jan 2014 08:48:00 +0100
Subject: [rust-dev] rustpkg error: "Package ____ depends on ____,
 but I don't know how to find it"
In-Reply-To: <CAO7SXVz+LwkLaacvyt12Jkc=iJfc1VAg+Wq+DASvCu31kZG54g@mail.gmail.com>
References: <CAH+UCjNdLeO3L_1NacOh5Afgown8rPvrUNzP3bzG_1=c=XTbag@mail.gmail.com>
	<52E52901.7020403@free.fr> <52E80876.70805@free.fr>
	<CAFPC01i3YF9a_SkQGay0oNvbnYeysTqgEta_aRXvZZH2yi1QKw@mail.gmail.com>
	<52E95F82.5050305@free.fr>
	<CAO7SXVz+LwkLaacvyt12Jkc=iJfc1VAg+Wq+DASvCu31kZG54g@mail.gmail.com>
Message-ID: <52EA03B0.4010702@free.fr>

You're right I have to force the version of the crate to build : rustpkg 
build portmidi#0.1

Thanks Jan for your help. I don't put the trace because there no need now.

Philippe

Le 29/01/2014 22:16, Matthew Thompson a ?crit :
> This means your project did not compile but rustpkg ate the compiler 
> output for some reason. For me, the compiler failure was because 
> rustpkg build and rustpkg install were silently failing (actually, 
> falsely succeeding!) to move build artifacts around that had explicit 
> crate_id's in their lib.rs <http://lib.rs>. You see rustpkg claims to 
> have installed portmidi#0.0, but likely it has a crate_id other than 
> 0.0 on it, which causes rustpkg to fail to move it. When you run build 
> and install, and when you refer to crates with extern mod, you have to 
> include the pound sign and proper crate id for it to work. You can 
> verify rustpkg build and install are functioning by looking inside lib 
> for libraries and bin for binaries. I'm probably switching away from 
> rustpkg too, as it's always a guessing game with poor error reporting 
> and documentation. cargo-lite does everything my project needs, but 
> writing Makefiles is so easy for rust because of its simple build 
> model that I don't see many downsides to simply doing that.
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/4a4443bd/attachment-0001.html>

From pcwalton at mozilla.com  Thu Jan 30 08:34:11 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 30 Jan 2014 08:34:11 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
Message-ID: <52EA7F03.9010005@mozilla.com>

On 1/29/14 11:47 PM, Ziad Hatahet wrote:
> That's interesting. However, Scala's `val` is the equivalent of Java's
> `final`, and does not imply "total" immutability. For non-primitive
> types, it only means that the reference is fixed to being bound to a
> specific object. It does not mean that that object itself is immutable
> (unlike Rusts `let`, or C++'s `const*`/`const&`). It is better than
> nothing, but it does give a false sense of security at times. I really
> wish more languages adopted Rust's way of doing immutability (I think D
> does something similar); I wonder why it never caught on in the more
> popular languages.

Rust's immutability setup depends on uniqueness, which is fairly, well, 
unique to Rust. (C++ has something similar with auto_ptr and unique_ptr, 
but the compiler knows nothing about it and "const" predated those anyhow.)

Patrick


From donquestion at rocketmail.com  Thu Jan 30 08:35:42 2014
From: donquestion at rocketmail.com (Donaldo Fastoso)
Date: Thu, 30 Jan 2014 17:35:42 +0100
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
Message-ID: <52EA7F5E.3030906@rocketmail.com>

I like python's rational of "consenting adults": Give people the tools
to do the right thing, if they still want to hurt themselves, they may
have a good reason, or they are better of dead! ;-)

I would argue, that people choosing Rust over C/C++ are choosing it
BECAUSE of safety measures like immutability and wouldn't need
overbearing lectures.

In all honesty it's not the TYPING of three additional chars "let mut",
but the READING. It interrupts the flow of reading, or better: it's
a bump in the flow of scanning. Source-Code is not prosa, you have to
actively follow the train of thought and guess the intentions of the
author. So improving READABILITY would really be nice, especially
for people coming from other languages. They would probably try to
learn by reading the source from experienced programmers.

In this case i would also advice against the use of "var", instead
of "let mut", but omitting "let" and leave it to "mut" would be much
easier to read and understand.

so
"let mut x, y;"

would become:

"mut x;"
"let y;"

which would take a possible interpretation-ambiguity away from the
single "let mut x, y", which can be read either as "let mut" for x
and y, or "let mut x" and "let y"!

So imho "let mut" has at least two pitfalls:
	1) read-bump
	2) ambiguity.

AFAIK you did a remarkable good job so far, and i have all the faith
you are considering all arguments before coming to a decision.

Even if some thoughts of the thoughts come form the bad smelling
"lurker"-fraction, which do nothing but making comments about things 
they possible can't understand! ;-)

Regards,
Don

From sfackler at gmail.com  Thu Jan 30 08:49:28 2014
From: sfackler at gmail.com (Steven Fackler)
Date: Thu, 30 Jan 2014 11:49:28 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52EA7F5E.3030906@rocketmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
	<52EA7F5E.3030906@rocketmail.com>
Message-ID: <CANb7cF5sd6aiycd3PLpKoFE9zMYZ6Z1XUQ16xA9fRpWU7rWHvA@mail.gmail.com>

The Zen of Python also says "There should be one-- and preferably only one
--obvious way to do it."

Steven Fackler


On Thu, Jan 30, 2014 at 11:35 AM, Donaldo Fastoso <
donquestion at rocketmail.com> wrote:

> I like python's rational of "consenting adults": Give people the tools
> to do the right thing, if they still want to hurt themselves, they may
> have a good reason, or they are better of dead! ;-)
>
> I would argue, that people choosing Rust over C/C++ are choosing it
> BECAUSE of safety measures like immutability and wouldn't need
> overbearing lectures.
>
> In all honesty it's not the TYPING of three additional chars "let mut",
> but the READING. It interrupts the flow of reading, or better: it's
> a bump in the flow of scanning. Source-Code is not prosa, you have to
> actively follow the train of thought and guess the intentions of the
> author. So improving READABILITY would really be nice, especially
> for people coming from other languages. They would probably try to
> learn by reading the source from experienced programmers.
>
> In this case i would also advice against the use of "var", instead
> of "let mut", but omitting "let" and leave it to "mut" would be much
> easier to read and understand.
>
> so
> "let mut x, y;"
>
> would become:
>
> "mut x;"
> "let y;"
>
> which would take a possible interpretation-ambiguity away from the
> single "let mut x, y", which can be read either as "let mut" for x
> and y, or "let mut x" and "let y"!
>
> So imho "let mut" has at least two pitfalls:
>         1) read-bump
>         2) ambiguity.
>
> AFAIK you did a remarkable good job so far, and i have all the faith
> you are considering all arguments before coming to a decision.
>
> Even if some thoughts of the thoughts come form the bad smelling
> "lurker"-fraction, which do nothing but making comments about things they
> possible can't understand! ;-)
>
> Regards,
> Don
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/2e28b8ab/attachment.html>

From catamorphism at gmail.com  Thu Jan 30 09:18:33 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Thu, 30 Jan 2014 09:18:33 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CANb7cF5sd6aiycd3PLpKoFE9zMYZ6Z1XUQ16xA9fRpWU7rWHvA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
	<52EA7F5E.3030906@rocketmail.com>
	<CANb7cF5sd6aiycd3PLpKoFE9zMYZ6Z1XUQ16xA9fRpWU7rWHvA@mail.gmail.com>
Message-ID: <CADcg8==V==ue2Aacm91we1KXWFnXbeUQ_NUTk495O5C5a2n_Jg@mail.gmail.com>

I'm surprised that no one has mentioned so far that there was a
previous, exhaustive, discussion of this question on github:

https://github.com/mozilla/rust/issues/2643

As far as I can tell, this thread adds nothing new that wasn't already
discussed in the comments on #2643. So that strongly suggests to me
that nothing needs to be changed.

Cheers,
Tim


On Thu, Jan 30, 2014 at 8:49 AM, Steven Fackler <sfackler at gmail.com> wrote:
> The Zen of Python also says "There should be one-- and preferably only one
> --obvious way to do it."
>
> Steven Fackler
>
>
> On Thu, Jan 30, 2014 at 11:35 AM, Donaldo Fastoso
> <donquestion at rocketmail.com> wrote:
>>
>> I like python's rational of "consenting adults": Give people the tools
>> to do the right thing, if they still want to hurt themselves, they may
>> have a good reason, or they are better of dead! ;-)
>>
>> I would argue, that people choosing Rust over C/C++ are choosing it
>> BECAUSE of safety measures like immutability and wouldn't need
>> overbearing lectures.
>>
>> In all honesty it's not the TYPING of three additional chars "let mut",
>> but the READING. It interrupts the flow of reading, or better: it's
>> a bump in the flow of scanning. Source-Code is not prosa, you have to
>> actively follow the train of thought and guess the intentions of the
>> author. So improving READABILITY would really be nice, especially
>> for people coming from other languages. They would probably try to
>> learn by reading the source from experienced programmers.
>>
>> In this case i would also advice against the use of "var", instead
>> of "let mut", but omitting "let" and leave it to "mut" would be much
>> easier to read and understand.
>>
>> so
>> "let mut x, y;"
>>
>> would become:
>>
>> "mut x;"
>> "let y;"
>>
>> which would take a possible interpretation-ambiguity away from the
>> single "let mut x, y", which can be read either as "let mut" for x
>> and y, or "let mut x" and "let y"!
>>
>> So imho "let mut" has at least two pitfalls:
>>         1) read-bump
>>         2) ambiguity.
>>
>> AFAIK you did a remarkable good job so far, and i have all the faith
>> you are considering all arguments before coming to a decision.
>>
>> Even if some thoughts of the thoughts come form the bad smelling
>> "lurker"-fraction, which do nothing but making comments about things they
>> possible can't understand! ;-)
>>
>> Regards,
>> Don
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From jfager at gmail.com  Thu Jan 30 09:18:52 2014
From: jfager at gmail.com (Jason Fager)
Date: Thu, 30 Jan 2014 12:18:52 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <52EA7F5E.3030906@rocketmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
	<52EA7F5E.3030906@rocketmail.com>
Message-ID: <CAFEbTaX1PSZgedFDaXBpE6Q03Z2h_qWh+8n6B0MBoDME2Wa=ng@mail.gmail.com>

3 extra characters isn't doing anything to stop consenting adults.
 Nobody's saying get rid of mutable variables, just that it seems like a
waste of limited resources to figure out how to streamline them when in
general their use should be limited to where necessary.

Python isn't busy trying to figure out how to make 'look before you leap'
easier.  They have a culture of discouraging it and favoring 'forgiveness
over permission'.  Consenting adults can do all the looking they like, but that
doesn't mean Python is going to bend over backwards to make it pleasant for
them.



On Thursday, January 30, 2014, Donaldo Fastoso <donquestion at rocketmail.com>
wrote:

> I like python's rational of "consenting adults": Give people the tools
> to do the right thing, if they still want to hurt themselves, they may
> have a good reason, or they are better of dead! ;-)
>
> I would argue, that people choosing Rust over C/C++ are choosing it
> BECAUSE of safety measures like immutability and wouldn't need
> overbearing lectures.
>
> In all honesty it's not the TYPING of three additional chars "let mut",
> but the READING. It interrupts the flow of reading, or better: it's
> a bump in the flow of scanning. Source-Code is not prosa, you have to
> actively follow the train of thought and guess the intentions of the
> author. So improving READABILITY would really be nice, especially
> for people coming from other languages. They would probably try to
> learn by reading the source from experienced programmers.
>
> In this case i would also advice against the use of "var", instead
> of "let mut", but omitting "let" and leave it to "mut" would be much
> easier to read and understand.
>
> so
> "let mut x, y;"
>
> would become:
>
> "mut x;"
> "let y;"
>
> which would take a possible interpretation-ambiguity away from the
> single "let mut x, y", which can be read either as "let mut" for x
> and y, or "let mut x" and "let y"!
>
> So imho "let mut" has at least two pitfalls:
>         1) read-bump
>         2) ambiguity.
>
> AFAIK you did a remarkable good job so far, and i have all the faith
> you are considering all arguments before coming to a decision.
>
> Even if some thoughts of the thoughts come form the bad smelling
> "lurker"-fraction, which do nothing but making comments about things they
> possible can't understand! ;-)
>
> Regards,
> Don
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/f00867be/attachment-0001.html>

From matthieu.monrocq at gmail.com  Thu Jan 30 09:27:27 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Thu, 30 Jan 2014 18:27:27 +0100
Subject: [rust-dev] What of semi-automated segmented stacks ?
Message-ID: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>

Hello,

Segmented stacks were ditched because of performance issues that were never
fully resolved, especially when every opaque call (C, ...) required
allocated a large stack up-front.

Still, there are platforms (FreeBSD) with small stacks where the idea of
segmented tasks could ease development... so what if we let the developer
ship in ?


The idea of semi-automated segmented stacks would be:

- to expose to the user how many bytes worth of stack are remaining

- to let the user trigger a stack switch


This system should keep the penalty close to null for those who do not
care, and be relatively orthogonal to the rest of the implementation:

- how many bytes remaining carries little to no penalty: just a pointed
substraction between the current stack pointer and the "end-of-stack"
pointer (which can be set once and for all at thread start-up)

- the stack switch is voluntary, and can include a prelude on the new stack
that automatically comes back to its parent so that most code should not
care, no penalty in regular execution (without it)

- I foresee some potential implementation difficulty for the unwinder, did
it ever work on segmented stacks ? Was it difficult/slow ? Does performance
of unwind matter that much ?


Work-around:

In the absence of segmented stacks, the user can only resolve to using
another task to get a "free" stack. Unfortunately, because of the (great!)
memory safety of Rust this other task cannot readily access its parent
task's memory.


I do not remember whether this idea was investigated when segmented tasks
were removed. I thought it might be interesting to consider, although... it
is probably useless for 1.0 anyway.

-- Matthieu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/5707d16e/attachment.html>

From leebraid at gmail.com  Thu Jan 30 09:32:42 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Thu, 30 Jan 2014 17:32:42 +0000
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAFEbTaX1PSZgedFDaXBpE6Q03Z2h_qWh+8n6B0MBoDME2Wa=ng@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
	<52EA7F5E.3030906@rocketmail.com>
	<CAFEbTaX1PSZgedFDaXBpE6Q03Z2h_qWh+8n6B0MBoDME2Wa=ng@mail.gmail.com>
Message-ID: <52EA8CBA.7030509@gmail.com>

On 30/01/14 17:18, Jason Fager wrote:
> 3 extra characters isn't doing anything to stop consenting adults. 
>  Nobody's saying get rid of mutable variables, just that it seems like 
> a waste of limited resources to figure out how to streamline them when 
> in general their use should be limited to where necessary.

I agree with your point 100%.

However, as an aside, the argument FOR that point is one I'd personally 
prefer not to use, in language design.  To talk about not considering 
something fully because it's a "waste of resources" is to condemn every 
future programmer using that feature, to dealing with it themselves -- 
in other words, to cause virtually INFINITE waste of resources, 
especially since they would be relatively powerless to fix it after the 
fact.  Language designers need to care deeply, about every single aspect 
of the design.  One of the most refreshing things about Rust is how much 
the everyone involved DOES care, in general.

That said, I think this particular issue has been fully discussed, and 
the current approach is sound, though.


-- 
Lee


From danielmicay at gmail.com  Thu Jan 30 09:33:25 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 30 Jan 2014 12:33:25 -0500
Subject: [rust-dev] What of semi-automated segmented stacks ?
In-Reply-To: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>
References: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>
Message-ID: <CA+DvKQLsF3HB49CjFge_SLAduMqKKFuNn17KF6sg_rp0+-urYA@mail.gmail.com>

On Thu, Jan 30, 2014 at 12:27 PM, Matthieu Monrocq
<matthieu.monrocq at gmail.com> wrote:
> Hello,
>
> Segmented stacks were ditched because of performance issues that were never
> fully resolved, especially when every opaque call (C, ...) required
> allocated a large stack up-front.
>
> Still, there are platforms (FreeBSD) with small stacks where the idea of
> segmented tasks could ease development... so what if we let the developer
> ship in ?

Rust can and does choose the stack size itself. This can exposed as an
API feature too.

> The idea of semi-automated segmented stacks would be:
>
> - to expose to the user how many bytes worth of stack are remaining
>
> - to let the user trigger a stack switch
>
>
> This system should keep the penalty close to null for those who do not care,
> and be relatively orthogonal to the rest of the implementation:

If Rust isn't going to be using the segmented stack prelude (1-5%
performance hit), it needs guard pages. This means the smallest stack
segment size you can have with a "free" solution is 8K. It will
consume less virtual memory than a fixed-size stack, but not more
physical memory.

> - how many bytes remaining carries little to no penalty: just a pointed
> substraction between the current stack pointer and the "end-of-stack"
> pointer (which can be set once and for all at thread start-up)
>
> - the stack switch is voluntary, and can include a prelude on the new stack
> that automatically comes back to its parent so that most code should not
> care, no penalty in regular execution (without it)
>
> - I foresee some potential implementation difficulty for the unwinder, did
> it ever work on segmented stacks ? Was it difficult/slow ? Does performance
> of unwind matter that much ?

Unwind performance doesn't matter, and is already really slow by design.

From matthieu.monrocq at gmail.com  Thu Jan 30 10:55:05 2014
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Thu, 30 Jan 2014 19:55:05 +0100
Subject: [rust-dev] What of semi-automated segmented stacks ?
In-Reply-To: <CA+DvKQLsF3HB49CjFge_SLAduMqKKFuNn17KF6sg_rp0+-urYA@mail.gmail.com>
References: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>
	<CA+DvKQLsF3HB49CjFge_SLAduMqKKFuNn17KF6sg_rp0+-urYA@mail.gmail.com>
Message-ID: <CAKE6Rfg+Tuv41ZcqpRNHSqU=uSWhepOH3p+EaQwYjwn8_hThcg@mail.gmail.com>

On Thu, Jan 30, 2014 at 6:33 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Thu, Jan 30, 2014 at 12:27 PM, Matthieu Monrocq
> <matthieu.monrocq at gmail.com> wrote:
> > Hello,
> >
> > Segmented stacks were ditched because of performance issues that were
> never
> > fully resolved, especially when every opaque call (C, ...) required
> > allocated a large stack up-front.
> >
> > Still, there are platforms (FreeBSD) with small stacks where the idea of
> > segmented tasks could ease development... so what if we let the developer
> > ship in ?
>
> Rust can and does choose the stack size itself. This can exposed as an
> API feature too.
>

I think it would be a good idea, to avoid platform defaults causing
unexpected crashes. I know Clang regularly suffers on a number of tests
because of this.

Still, this seems complementary. Whilst a "large" stack to begin with is an
obvious option, there are always unfavorable cases. Today, to avoid stack
issues, I have to move from "natural" recursive style to self-managed stack
of actions and an "endless loop" so my stack is actually on the heap. It's
feasible, certainly, but it's a technical limitation getting in the way of
my intent.

And unfortunately, whilst I could allocate a 1GB stack to start with (64
bits world sure is fortunate), I have no way to foresee when I will need
such a stack and when I do not. Dynamic adaptation makes things much easier.


> > The idea of semi-automated segmented stacks would be:
> >
> > - to expose to the user how many bytes worth of stack are remaining
> >
> > - to let the user trigger a stack switch
> >
> >
> > This system should keep the penalty close to null for those who do not
> care,
> > and be relatively orthogonal to the rest of the implementation:
>
> If Rust isn't going to be using the segmented stack prelude (1-5%
> performance hit), it needs guard pages. This means the smallest stack
> segment size you can have with a "free" solution is 8K. It will
> consume less virtual memory than a fixed-size stack, but not more
> physical memory.


> > - how many bytes remaining carries little to no penalty: just a pointed
> > substraction between the current stack pointer and the "end-of-stack"
> > pointer (which can be set once and for all at thread start-up)
> >
> > - the stack switch is voluntary, and can include a prelude on the new
> stack
> > that automatically comes back to its parent so that most code should not
> > care, no penalty in regular execution (without it)
> >
> > - I foresee some potential implementation difficulty for the unwinder,
> did
> > it ever work on segmented stacks ? Was it difficult/slow ? Does
> performance
> > of unwind matter that much ?
>
> Unwind performance doesn't matter, and is already really slow by design.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/ee618fb4/attachment.html>

From catamorphism at gmail.com  Thu Jan 30 11:26:54 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Thu, 30 Jan 2014 11:26:54 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
Message-ID: <CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>

On Wed, Jan 29, 2014 at 1:50 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Wed, Jan 29, 2014 at 1:13 PM, Jan Niklas Hasse <jhasse at fastmail.fm>
> wrote:
>>
>> I'm very shocked and also very much against removing it. I've just
>> started with Rust a few months ago and actually rustpkg was the thing
>> that I liked the most. I know it's buggy and unfinished, but at least
>> the idea looked wonderful to me.
>
>
> Just my 2c: I'd argue the complete opposite.
>
> Package managers are things that are often created quite early in the
> lifecycle of a language, and their design mistakes can haunt users of the
> language and potentially doom the language itself. Once a package manager is
> entrenched, typically there's no turning back, and you are left forever
> trying to fix the mess you started with.
>
> Moreover, there's the complex relationships of package managers, dependency
> resolvers, and secure software update infrastructures to consider. I think
> rustpkg was written in the absence of these considerations. I think
> successful packaging/software update systems consider all these problems
> up-front, so the MVP is at least future proof when it comes time to consider
> things like, say, security.
>

In the interest of documentation (especially for the benefit of
whatever person or people end up writing the next package manager),
can you explain what specific architectural issues in rustpkg preclude
the addition of (better?) dependency resolution and secure software
update infrastructure?

Cheers,
Tim


> If we aren't certain that rustpkg is a solid foundation, now is the time to
> scrap it and build a better one. Otherwise we'll be stuck with it forever.
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From bascule at gmail.com  Thu Jan 30 14:20:05 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 30 Jan 2014 14:20:05 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
Message-ID: <CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>

On Thu, Jan 30, 2014 at 11:26 AM, Tim Chevalier <catamorphism at gmail.com>wrote:

> In the interest of documentation (especially for the benefit of
>  whatever person or people end up writing the next package manager),
> can you explain what specific architectural issues in rustpkg preclude
> the addition of (better?) dependency resolution and secure software
> update infrastructure?
>

rustpkg seems to have quite a few features (which it needs in its current
state, I guess) I would prefer to see in a dependency resolution tool,
including the ability to fetch from multiple different ad-hoc sources and
integration with git repositories. These features do not seem to be
particularly well thought out (e.g. how do we handle versioning?) and the
"package identifier" system strikes me as rather odd.

I would really like to see the "where packages come from" and "what
packages are" concepts decoupled, as well as a clear strategy for how to
handle versioning.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/0f909cee/attachment.html>

From catamorphism at gmail.com  Thu Jan 30 14:28:13 2014
From: catamorphism at gmail.com (Tim Chevalier)
Date: Thu, 30 Jan 2014 14:28:13 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
Message-ID: <CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>

On Thu, Jan 30, 2014 at 2:20 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Thu, Jan 30, 2014 at 11:26 AM, Tim Chevalier <catamorphism at gmail.com>
> wrote:
>>
>> In the interest of documentation (especially for the benefit of
>> whatever person or people end up writing the next package manager),
>> can you explain what specific architectural issues in rustpkg preclude
>> the addition of (better?) dependency resolution and secure software
>> update infrastructure?
>
>
> rustpkg seems to have quite a few features (which it needs in its current
> state, I guess) I would prefer to see in a dependency resolution tool,
> including the ability to fetch from multiple different ad-hoc sources and
> integration with git repositories. These features do not seem to be
> particularly well thought out (e.g. how do we handle versioning?) and the
> "package identifier" system strikes me as rather odd.
>

Ah. These concepts are taken directly from the Go package manager:
http://golang.org/cmd/go/ . We believed at the time that this design
has worked well for the Go community, but perhaps someone who has used
Go can comment on that.

I'm not sure what your question is about versioning. Versioning in
rustpkg was not fully tested when I stopped working on it, but from
the start, the design was to treat different versions of the same
package as separate entities that can coexist. That's why package IDs
include optional versions.

Cheers,
Tim

> I would really like to see the "where packages come from" and "what packages
> are" concepts decoupled, as well as a clear strategy for how to handle
> versioning.


>
> --
> Tony Arcieri



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From vadimcn at gmail.com  Thu Jan 30 14:58:14 2014
From: vadimcn at gmail.com (Vadim)
Date: Thu, 30 Jan 2014 14:58:14 -0800
Subject: [rust-dev] Syntax for custom type bounds
Message-ID: <CADecdiL_CHzO__v2bgyBQtdb5QwddcZDiz0axVvr+1OiByZoTw@mail.gmail.com>

Just wondering...  Does anyone else feel that "syntax" around lifetimes and
type bounds is becoming very unwieldy?  I am referring to this PR:
https://github.com/mozilla/rust/pull/11768.   Is using dummy struct fields
for specifying custom type bounds on the struct itself really the best we
can do in a brand-new language?


At least for the lifetimes, Rust could extend existing syntax and allow
specifying them on by-value returns objects, so that, for example, this:

    pub trait MutableVector<'a, T> {
        fn mut_iter(self) -> MutItems<'a, T>;
        ...
    }

could be written as:

    pub trait MutableVector<'a, T> {
        fn mut_iter(self) -> 'a MutItems<T>;
        ...
    }

This also makes the intent much more clear.   Currently, one would have to
dig into the definition of MutItems<'a,T> to figure out that the lifetime
parameter 'a is used to create a dummy borrow field into the vector, so
that the whole iterator is then treated as a mutable borrow.   This feels
very convoluted, if you ask me.


On a slightly different note, is there a strong reason for having to name
lifetime parameters explicitly?   Could we simply re-use actual parameter
names prefixed with ' as their lifetimes?   The above could then be reduced
to this:

    pub trait MutableVector<T> {
        fn mut_iter(self) -> 'self MutItems<T>;
        ...
    }

This used to be valid syntax, btw, though it worked because 'self lifetime
was special, IIRC.
Note that I am not proposing to eliminate explicitly named lifetimes
entirely,- there are still cases when they are needed.  But as far as I've
seen, those are few and far between.

Thanks for reading,
Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/199b2751/attachment.html>

From bascule at gmail.com  Thu Jan 30 15:02:20 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 30 Jan 2014 15:02:20 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
Message-ID: <CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>

On Thu, Jan 30, 2014 at 2:28 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> ...the design was to treat different versions of the same package as
> separate entities that can coexist. That's why package IDs include
> optional versions.
>

RubyGems does this, and I think it was a mistake that has lead to an
explosion of incidental complexity in the form of things like gemsets.

In the presence of a dependency resolver this feature is not only useless
but annoying.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/56704573/attachment.html>

From corey at octayn.net  Thu Jan 30 15:05:13 2014
From: corey at octayn.net (Corey Richardson)
Date: Thu, 30 Jan 2014 18:05:13 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
Message-ID: <CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>

On Thu, Jan 30, 2014 at 6:02 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Thu, Jan 30, 2014 at 2:28 PM, Tim Chevalier <catamorphism at gmail.com>
> wrote:
>>
>> ...the design was to treat different versions of the same package as
>> separate entities that can coexist. That's why package IDs include optional
>> versions.
>
>
> RubyGems does this, and I think it was a mistake that has lead to an
> explosion of incidental complexity in the form of things like gemsets.
>
> In the presence of a dependency resolver this feature is not only useless
> but annoying.
>

I find it both useful and pleasant. I can write a lib that uses
version X of libA, but have an application using version Y of libA be
able to link to me. This isn't a problem in Rust because symbol names
include the version (as well as the hash).

From bascule at gmail.com  Thu Jan 30 15:08:37 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Thu, 30 Jan 2014 15:08:37 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
Message-ID: <CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>

On Thu, Jan 30, 2014 at 3:05 PM, Corey Richardson <corey at octayn.net> wrote:

> I find it both useful and pleasant. I can write a lib that uses
>  version X of libA, but have an application using version Y of libA be
> able to link to me. This isn't a problem in Rust because symbol names
> include the version (as well as the hash).
>

What if the different versions of the library do incompatible things, like:

- Talk incompatible versions of a network protocol
- Serialize data differently
- One contains important security fixes the other does not

etc, etc, etc

Why is having multiple simultaneous versions of a library superior to
toposorting the dependencies and coming up with a combination of versions
that works for all of the project's dependencies?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/d9b8854b/attachment-0001.html>

From ben.striegel at gmail.com  Thu Jan 30 15:20:27 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 30 Jan 2014 18:20:27 -0500
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CADcg8==V==ue2Aacm91we1KXWFnXbeUQ_NUTk495O5C5a2n_Jg@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>
	<52E9BA89.6030702@mozilla.com> <52E9BC41.5010300@mozilla.com>
	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>
	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>
	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>
	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>
	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>
	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>
	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>
	<52EA7F5E.3030906@rocketmail.com>
	<CANb7cF5sd6aiycd3PLpKoFE9zMYZ6Z1XUQ16xA9fRpWU7rWHvA@mail.gmail.com>
	<CADcg8==V==ue2Aacm91we1KXWFnXbeUQ_NUTk495O5C5a2n_Jg@mail.gmail.com>
Message-ID: <CAAvrL-mpgTsnNh1grs1vUXTZx=JkrkUKDX1kA0v_kVBfa-=sLA@mail.gmail.com>

> https://github.com/mozilla/rust/issues/2643

I came here to post that link, you beat me to it. :)

Highly, vehemently, frothing-at-the-mouthly against adding `var` as sugar
for `let mut`. You can see from reading that issue that I too was once a
fan of getting rid of `let mut`, but after using Rust in the years since I
can see how lovely the current setup is. I was the one who initiated the
widespread grepping recently that found that `let` was three times more
common than `let mut`, and I admit I was surprised to find that
immutability was so completely dominant. Immutability is crucial to Rust.
Mutability *must* be explicit. Not having to ever worry about
const-correctness is icing on the cake. Adding an alternative form for `let
mut` would go completely against the spirit of the language.


On Thu, Jan 30, 2014 at 12:18 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> I'm surprised that no one has mentioned so far that there was a
> previous, exhaustive, discussion of this question on github:
>
> https://github.com/mozilla/rust/issues/2643
>
> As far as I can tell, this thread adds nothing new that wasn't already
> discussed in the comments on #2643. So that strongly suggests to me
> that nothing needs to be changed.
>
> Cheers,
> Tim
>
>
> On Thu, Jan 30, 2014 at 8:49 AM, Steven Fackler <sfackler at gmail.com>
> wrote:
> > The Zen of Python also says "There should be one-- and preferably only
> one
> > --obvious way to do it."
> >
> > Steven Fackler
> >
> >
> > On Thu, Jan 30, 2014 at 11:35 AM, Donaldo Fastoso
> > <donquestion at rocketmail.com> wrote:
> >>
> >> I like python's rational of "consenting adults": Give people the tools
> >> to do the right thing, if they still want to hurt themselves, they may
> >> have a good reason, or they are better of dead! ;-)
> >>
> >> I would argue, that people choosing Rust over C/C++ are choosing it
> >> BECAUSE of safety measures like immutability and wouldn't need
> >> overbearing lectures.
> >>
> >> In all honesty it's not the TYPING of three additional chars "let mut",
> >> but the READING. It interrupts the flow of reading, or better: it's
> >> a bump in the flow of scanning. Source-Code is not prosa, you have to
> >> actively follow the train of thought and guess the intentions of the
> >> author. So improving READABILITY would really be nice, especially
> >> for people coming from other languages. They would probably try to
> >> learn by reading the source from experienced programmers.
> >>
> >> In this case i would also advice against the use of "var", instead
> >> of "let mut", but omitting "let" and leave it to "mut" would be much
> >> easier to read and understand.
> >>
> >> so
> >> "let mut x, y;"
> >>
> >> would become:
> >>
> >> "mut x;"
> >> "let y;"
> >>
> >> which would take a possible interpretation-ambiguity away from the
> >> single "let mut x, y", which can be read either as "let mut" for x
> >> and y, or "let mut x" and "let y"!
> >>
> >> So imho "let mut" has at least two pitfalls:
> >>         1) read-bump
> >>         2) ambiguity.
> >>
> >> AFAIK you did a remarkable good job so far, and i have all the faith
> >> you are considering all arguments before coming to a decision.
> >>
> >> Even if some thoughts of the thoughts come form the bad smelling
> >> "lurker"-fraction, which do nothing but making comments about things
> they
> >> possible can't understand! ;-)
> >>
> >> Regards,
> >> Don
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed
> it."
> -- Zora Neale Hurston
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/8c585d63/attachment.html>

From armin.ronacher at active-4.com  Thu Jan 30 16:27:07 2014
From: armin.ronacher at active-4.com (Armin Ronacher)
Date: Fri, 31 Jan 2014 00:27:07 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
Message-ID: <52EAEDDB.4030402@active-4.com>

Hi,

On 30/01/2014 23:08, Tony Arcieri wrote:
> What if the different versions of the library do incompatible things, like:
>
> - Talk incompatible versions of a network protocol
> - Serialize data differently
> - One contains important security fixes the other does not
They are different libraries.  It's not an issue in practice because the 
situation where this happens is if you have a library depending on another 
library internally.

Not having the option to run multiple versions of the same library in parallel 
in different parts is a major problem and Python suffers tremendously under this.


Regards,
Armin

From banderson at mozilla.com  Thu Jan 30 16:32:13 2014
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 30 Jan 2014 16:32:13 -0800
Subject: [rust-dev] "let mut" <-> "var"
In-Reply-To: <CAAvrL-mpgTsnNh1grs1vUXTZx=JkrkUKDX1kA0v_kVBfa-=sLA@mail.gmail.com>
References: <CAHkN8V9PeADmhxiV8e88M6TG5SS8Q8h30NjdV04iLcoHXVxbSQ@mail.gmail.com>	<52E9BA89.6030702@mozilla.com>
	<52E9BC41.5010300@mozilla.com>	<034CF93F-E6C4-4E25-891A-27BB5781E861@sb.org>	<CAHkN8V-1JAh8zMjxFjjZZ4vxg=GtMgg9_7NJf0U_uS6c4pC=GQ@mail.gmail.com>	<CAHkN8V_2bJB1jyC2EAFu+yKQjEVqQK=m6tJq0Dmd1YNgW_K7sA@mail.gmail.com>	<CAFEbTaU-LWo=gXDYZayRm54DR1h6wrnDhiCJ0+aC2+A-Aj-oeg@mail.gmail.com>	<CAHkN8V9s6dR_95Yx41Oz3bFoBuzge8ixG-qeYvXYNjaaQ35T2A@mail.gmail.com>	<CALruUQ+zt7XSALeGT1E=6UWwT=5xjOJYEJ2mCaSPjt7gr9t1Dg@mail.gmail.com>	<CAN1rdEznj0MekUkkeGvanNfqLjzS4wVRHbzdUqE8srajoSAALQ@mail.gmail.com>	<52EA7F5E.3030906@rocketmail.com>	<CANb7cF5sd6aiycd3PLpKoFE9zMYZ6Z1XUQ16xA9fRpWU7rWHvA@mail.gmail.com>	<CADcg8==V==ue2Aacm91we1KXWFnXbeUQ_NUTk495O5C5a2n_Jg@mail.gmail.com>
	<CAAvrL-mpgTsnNh1grs1vUXTZx=JkrkUKDX1kA0v_kVBfa-=sLA@mail.gmail.com>
Message-ID: <52EAEF0D.7030502@mozilla.com>

I'm convinced by this thread that this issue should be put to bed 
forever. I added a note to the design faq issue: 
https://github.com/mozilla/rust/issues/4047#issuecomment-33751021

On 01/30/2014 03:20 PM, Benjamin Striegel wrote:
> > https://github.com/mozilla/rust/issues/2643
>
> I came here to post that link, you beat me to it. :)
>
> Highly, vehemently, frothing-at-the-mouthly against adding `var` as 
> sugar for `let mut`. You can see from reading that issue that I too 
> was once a fan of getting rid of `let mut`, but after using Rust in 
> the years since I can see how lovely the current setup is. I was the 
> one who initiated the widespread grepping recently that found that 
> `let` was three times more common than `let mut`, and I admit I was 
> surprised to find that immutability was so completely dominant. 
> Immutability is crucial to Rust. Mutability *must* be explicit. Not 
> having to ever worry about const-correctness is icing on the cake. 
> Adding an alternative form for `let mut` would go completely against 
> the spirit of the language.
>
>
> On Thu, Jan 30, 2014 at 12:18 PM, Tim Chevalier 
> <catamorphism at gmail.com <mailto:catamorphism at gmail.com>> wrote:
>
>     I'm surprised that no one has mentioned so far that there was a
>     previous, exhaustive, discussion of this question on github:
>
>     https://github.com/mozilla/rust/issues/2643
>
>     As far as I can tell, this thread adds nothing new that wasn't already
>     discussed in the comments on #2643. So that strongly suggests to me
>     that nothing needs to be changed.
>
>     Cheers,
>     Tim
>
>
>     On Thu, Jan 30, 2014 at 8:49 AM, Steven Fackler
>     <sfackler at gmail.com <mailto:sfackler at gmail.com>> wrote:
>     > The Zen of Python also says "There should be one-- and
>     preferably only one
>     > --obvious way to do it."
>     >
>     > Steven Fackler
>     >
>     >
>     > On Thu, Jan 30, 2014 at 11:35 AM, Donaldo Fastoso
>     > <donquestion at rocketmail.com <mailto:donquestion at rocketmail.com>>
>     wrote:
>     >>
>     >> I like python's rational of "consenting adults": Give people
>     the tools
>     >> to do the right thing, if they still want to hurt themselves,
>     they may
>     >> have a good reason, or they are better of dead! ;-)
>     >>
>     >> I would argue, that people choosing Rust over C/C++ are choosing it
>     >> BECAUSE of safety measures like immutability and wouldn't need
>     >> overbearing lectures.
>     >>
>     >> In all honesty it's not the TYPING of three additional chars
>     "let mut",
>     >> but the READING. It interrupts the flow of reading, or better: it's
>     >> a bump in the flow of scanning. Source-Code is not prosa, you
>     have to
>     >> actively follow the train of thought and guess the intentions
>     of the
>     >> author. So improving READABILITY would really be nice, especially
>     >> for people coming from other languages. They would probably try to
>     >> learn by reading the source from experienced programmers.
>     >>
>     >> In this case i would also advice against the use of "var", instead
>     >> of "let mut", but omitting "let" and leave it to "mut" would be
>     much
>     >> easier to read and understand.
>     >>
>     >> so
>     >> "let mut x, y;"
>     >>
>     >> would become:
>     >>
>     >> "mut x;"
>     >> "let y;"
>     >>
>     >> which would take a possible interpretation-ambiguity away from the
>     >> single "let mut x, y", which can be read either as "let mut" for x
>     >> and y, or "let mut x" and "let y"!
>     >>
>     >> So imho "let mut" has at least two pitfalls:
>     >>         1) read-bump
>     >>         2) ambiguity.
>     >>
>     >> AFAIK you did a remarkable good job so far, and i have all the
>     faith
>     >> you are considering all arguments before coming to a decision.
>     >>
>     >> Even if some thoughts of the thoughts come form the bad smelling
>     >> "lurker"-fraction, which do nothing but making comments about
>     things they
>     >> possible can't understand! ;-)
>     >>
>     >> Regards,
>     >> Don
>     >>
>     >> _______________________________________________
>     >> Rust-dev mailing list
>     >> Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     >> https://mail.mozilla.org/listinfo/rust-dev
>     >
>     >
>     >
>     > _______________________________________________
>     > Rust-dev mailing list
>     > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     > https://mail.mozilla.org/listinfo/rust-dev
>     >
>
>
>
>     --
>     Tim Chevalier * http://catamorphism.org/ * Often in error, never
>     in doubt
>     "If you are silent about your pain, they'll kill you and say you
>     enjoyed it."
>     -- Zora Neale Hurston
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/1fbc9a0e/attachment-0001.html>

From val at markovic.io  Thu Jan 30 18:37:41 2014
From: val at markovic.io (Val Markovic)
Date: Thu, 30 Jan 2014 18:37:41 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52EAEDDB.4030402@active-4.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
Message-ID: <CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>

I'll second Armin and Corey here; if lib A and B depend on different
versions of lib C, you *must* still be able to easily build and link them
together as deps of lib D. This is *critical* in large codebases where it's
not feasible to go into A and B and update which version of C they depend
on since A & B are possibly very big and have tons of other users who
aren't as willing as you are to switch to a new version of C.

And now imagine a (frighteningly common) nightmare scenario, where the
library version clash is not two steps away from you, but say 8 and 12. So
you link something that depends on something that depends on something ...
that 8 steps away depends on A (which depends on C v1), and a different
chain of deps that 12 steps away depends on B (which depends on C v2). Good
luck resolving that.

Even more fun scenario: both A and B depend on C v1, but B wants to update
to C v2 because of a new feature they need. And they can't, because it
would break everyone upstream of them who depended on A. And no, you can't
just go into A and update it to C v2 because maybe the API in C changed,
maybe the same functions return slightly different results (a bug was
fixed, but old code implicitly depends on the bug) and just maybe lib A is
millions of lines of code and updating it would take weeks (or longer) for
the team that maintains A in the first place, and God only knows how long
it would take you.

This is a huge problem in large C++ codebases. It is not fun. An example: every
version of Xerces-C++ puts its code in a new C++
namespace<http://xerces.apache.org/xerces-c/program-others-3.html>,
so code is in xerces_3_0, xerces_3_1, xerces_3_2 etc to prevent these kinds
of issues.

Not being able to link together different versions of a library together
completely breaks encapsulation. Just don't go there.



On Thu, Jan 30, 2014 at 4:27 PM, Armin Ronacher <armin.ronacher at active-4.com
> wrote:

> Hi,
>
>
> On 30/01/2014 23:08, Tony Arcieri wrote:
>
>> What if the different versions of the library do incompatible things,
>> like:
>>
>> - Talk incompatible versions of a network protocol
>> - Serialize data differently
>> - One contains important security fixes the other does not
>>
> They are different libraries.  It's not an issue in practice because the
> situation where this happens is if you have a library depending on another
> library internally.
>
> Not having the option to run multiple versions of the same library in
> parallel in different parts is a major problem and Python suffers
> tremendously under this.
>
>
> Regards,
> Armin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/fc98eff9/attachment.html>

From ben.striegel at gmail.com  Thu Jan 30 19:00:25 2014
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 30 Jan 2014 22:00:25 -0500
Subject: [rust-dev] Syntax for custom type bounds
In-Reply-To: <CADecdiL_CHzO__v2bgyBQtdb5QwddcZDiz0axVvr+1OiByZoTw@mail.gmail.com>
References: <CADecdiL_CHzO__v2bgyBQtdb5QwddcZDiz0axVvr+1OiByZoTw@mail.gmail.com>
Message-ID: <CAAvrL-kOxa3fbLjs1sQTAxVu5f7umWA=iZxT1kk-t6Zk-EKzSQ@mail.gmail.com>

> Is using dummy struct fields for specifying custom type bounds on the
struct itself really the best we can do in a brand-new language?

I as well wonder if there's a better way to do this (but I'm note the one
to ask).

> On a slightly different note, is there a strong reason for having to name
lifetime parameters explicitly?

I believe there exist situations where it makes sense for an item to have
multiple lifetime parameters, though I can't think of one off the top of my
head.


On Thu, Jan 30, 2014 at 5:58 PM, Vadim <vadimcn at gmail.com> wrote:

> Just wondering...  Does anyone else feel that "syntax" around lifetimes
> and type bounds is becoming very unwieldy?  I am referring to this PR:
> https://github.com/mozilla/rust/pull/11768.   Is using dummy struct
> fields for specifying custom type bounds on the struct itself really the
> best we can do in a brand-new language?
>
>
> At least for the lifetimes, Rust could extend existing syntax and allow
> specifying them on by-value returns objects, so that, for example, this:
>
>     pub trait MutableVector<'a, T> {
>         fn mut_iter(self) -> MutItems<'a, T>;
>         ...
>     }
>
> could be written as:
>
>     pub trait MutableVector<'a, T> {
>         fn mut_iter(self) -> 'a MutItems<T>;
>         ...
>     }
>
> This also makes the intent much more clear.   Currently, one would have to
> dig into the definition of MutItems<'a,T> to figure out that the lifetime
> parameter 'a is used to create a dummy borrow field into the vector, so
> that the whole iterator is then treated as a mutable borrow.   This feels
> very convoluted, if you ask me.
>
>
> On a slightly different note, is there a strong reason for having to name
> lifetime parameters explicitly?   Could we simply re-use actual parameter
> names prefixed with ' as their lifetimes?   The above could then be reduced
> to this:
>
>     pub trait MutableVector<T> {
>         fn mut_iter(self) -> 'self MutItems<T>;
>         ...
>     }
>
> This used to be valid syntax, btw, though it worked because 'self lifetime
> was special, IIRC.
> Note that I am not proposing to eliminate explicitly named lifetimes
> entirely,- there are still cases when they are needed.  But as far as I've
> seen, those are few and far between.
>
> Thanks for reading,
> Vadim
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/26311af9/attachment.html>

From onelson at gmail.com  Thu Jan 30 19:05:43 2014
From: onelson at gmail.com (Owen Nelson)
Date: Thu, 30 Jan 2014 19:05:43 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
Message-ID: <CAG-u7zgU03q+L5TjNSKdhzEikj01aEWsyP62GF4Nzj5_jn+D8Q@mail.gmail.com>

I don't believe I'll be able to sleep tonight.

On Thu, Jan 30, 2014 at 6:37 PM, Val Markovic <val at markovic.io> wrote:

> And now imagine a (frighteningly common) nightmare scenario, where the
> library version clash is not two steps away from you, but say 8 and 12. So
> you link something that depends on something that depends on something ...
> that 8 steps away depends on A (which depends on C v1), and a different
> chain of deps that 12 steps away depends on B (which depends on C v2). Good
> luck resolving that.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140130/fee791a4/attachment.html>

From corey at octayn.net  Thu Jan 30 19:48:33 2014
From: corey at octayn.net (Corey Richardson)
Date: Thu, 30 Jan 2014 22:48:33 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAG-u7zgU03q+L5TjNSKdhzEikj01aEWsyP62GF4Nzj5_jn+D8Q@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAG-u7zgU03q+L5TjNSKdhzEikj01aEWsyP62GF4Nzj5_jn+D8Q@mail.gmail.com>
Message-ID: <CA++BO6QNDGUTkatG6TfrPQ7rKfT+HQULnWs2Chmksr_BydyxSw@mail.gmail.com>

It's also the case when you only have binary copies of a given thing,
rather than source...

On Thu, Jan 30, 2014 at 10:05 PM, Owen Nelson <onelson at gmail.com> wrote:
> I don't believe I'll be able to sleep tonight.
>
>
> On Thu, Jan 30, 2014 at 6:37 PM, Val Markovic <val at markovic.io> wrote:
>>
>> And now imagine a (frighteningly common) nightmare scenario, where the
>> library version clash is not two steps away from you, but say 8 and 12. So
>> you link something that depends on something that depends on something ...
>> that 8 steps away depends on A (which depends on C v1), and a different
>> chain of deps that 12 steps away depends on B (which depends on C v2). Good
>> luck resolving that.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Fri Jan 31 00:05:08 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 31 Jan 2014 09:05:08 +0100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
Message-ID: <CANK7tAH6MzRWvQH1bx85SO6u9pg86v5cmegt3gWt+OGscaBYdQ@mail.gmail.com>

Le vendredi 31 janvier 2014, Val Markovic <val at markovic.io> a ?crit :

> .This is a huge problem in large C++ codebases. It is not fun. An example: every
> version of Xerces-C++ puts its code in a new C++ namespace<http://xerces.apache.org/xerces-c/program-others-3.html>,
> so code is in xerces_3_0, xerces_3_1, xerces_3_2 etc to prevent these kinds
> of issues.
>
>
We did that at work, this seems to be the unique, practical solution. I
don't like when I see a hash in the library file name or symbol name, but
this very efficient for easily manage inter dependency.



-- 
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/daf1a391/attachment-0001.html>

From leebraid at gmail.com  Fri Jan 31 00:50:42 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Fri, 31 Jan 2014 08:50:42 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CANK7tAH6MzRWvQH1bx85SO6u9pg86v5cmegt3gWt+OGscaBYdQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CANK7tAH6MzRWvQH1bx85SO6u9pg86v5cmegt3gWt+OGscaBYdQ@mail.gmail.com>
Message-ID: <52EB63E2.9030200@gmail.com>

On 31/01/14 08:05, Gaetan wrote:
> Le vendredi 31 janvier 2014, Val Markovic <val at markovic.io 
> <mailto:val at markovic.io>> a ?crit :
>
>     .This is a huge problem in large C++ codebases. It is not fun. An
>     example: every version of Xerces-C++ puts its code in a new C++
>     namespace
>     <http://xerces.apache.org/xerces-c/program-others-3.html>, so code
>     is in xerces_3_0, xerces_3_1, xerces_3_2 etc to prevent these
>     kinds of issues.
>
>
> We did that at work, this seems to be the unique, practical solution. 
> I don't like when I see a hash in the library file name or symbol 
> name, but this very efficient for easily manage inter dependency.

This seems like a very wrong-headed approach to me.  The Amiga had a 
very simple and effective library system, which makes me wonder why 
other systems overcomplicate it.  It followed rules something like 
these, iirc:

1) If a minor change or bugfix happens, increment the minor version.
2) If a major change, which is backwards compatible (i.e., new features) 
happens, then increment the major version.
3) When loading libraries, you can specify a major and a minor version, 
with 0 for the minor version if you like.  You get at least that 
version, or better, or the loading fails.
4) If an incompatible change happens, then it's not fulfilling the same 
library API any more, so you stop trying to force square pegs into round 
holes, and **just rename the damn thing** ;) ;)

Rule 4 seems to be where every other OS's libraries makes a big mistake.


For the internet age, there are new complexities of decentralised forks, 
I think we'd need a few  more rules:

5) Library names have namespaces, something like Java's (and go's?) 
com.org.libname system
6) Anything unofficial (i.e., your patch to version 1.3, bringing it to 
an UNOFFICIAL version 1.4) goes in your own namespace, until accepted 
into the official codebase, OR you fork your own, NEW, incompatible 
library, as in (4)+(5).


-- 
Lee

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/331fb022/attachment.html>

From gaetan at xeberon.net  Fri Jan 31 02:16:06 2014
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 31 Jan 2014 11:16:06 +0100
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52EB63E2.9030200@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CANK7tAH6MzRWvQH1bx85SO6u9pg86v5cmegt3gWt+OGscaBYdQ@mail.gmail.com>
	<52EB63E2.9030200@gmail.com>
Message-ID: <CANK7tAGZeKeUzUKw9+yr0TrwBD5eGyFob8Y-iG1XLADrHfEdeQ@mail.gmail.com>

>
> 1) If a minor change or bugfix happens, increment the minor version.
> 2) If a major change, which is backwards compatible (i.e., new features)
> happens, then increment the major version.
> 3) When loading libraries, you can specify a major and a minor version,
> with 0 for the minor version if you like.  You get at least that version,
> or better, or the loading fails.
> 4) If an incompatible change happens, then it's not fulfilling the same
> library API any more, so you stop trying to force square pegs into round
> holes, and **just rename the damn thing** ;) ;)
>
> Rule 4 seems to be where every other OS's libraries makes a big mistake.
>

It's a matter of politics. You can't choose for every project. Just let
people choose what is best for them. Versionning system for each project is
different, versionning on windows libraries is different than on linux or
mac.

For the internet age, there are new complexities of decentralised forks, I
> think we'd need a few  more rules:
>
> 5) Library names have namespaces, something like Java's (and go's?)
> com.org.libname system
>

I hate this. Even if this is very logicial, it's anti ergonomic. What more
ugly than having the first directory in you source base named "com" or
"org"......


> 6) Anything unofficial (i.e., your patch to version 1.3, bringing it to an
> UNOFFICIAL version 1.4) goes in your own namespace, until accepted into the
> official codebase, OR you fork your own, NEW, incompatible library, as in
> (4)+(5).
>
>

> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/8c5533f2/attachment.html>

From dpx.infinity at gmail.com  Fri Jan 31 06:07:27 2014
From: dpx.infinity at gmail.com (Vladimir Matveev)
Date: Fri, 31 Jan 2014 18:07:27 +0400
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52EB63E2.9030200@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CANK7tAH6MzRWvQH1bx85SO6u9pg86v5cmegt3gWt+OGscaBYdQ@mail.gmail.com>
	<52EB63E2.9030200@gmail.com>
Message-ID: <CA+jWdBh=ESpTi+T-1C6zaWaN2whiempvHwWqQmqiiXXCUA7Z=w@mail.gmail.com>

Hi all,

> 4) If an incompatible change happens, then it's not fulfilling the same library API any more, so you stop trying to force square pegs into round holes, and **just rename the damn thing** ;) ;)

According to this logic Rust itself should have been renamed at least
nine times already :) Franky, this is rather weird approach. Libraries
are constantly being developed and improved, and it will lead to a
whole lot of the same projects but with slightly different names. Or a
part of version number will migrate to library name, which is even
worse. Versions are intended exactly for marking project milestones,
and API changes are natural part of project life, especially if it is
in active development.

> 5) Library names have namespaces, something like Java's (and go's?) com.org.libname system

The main language I work with is Java, and I also use Scala and
Clojure, so I think I can explain how Java packages and artifacts
work.

The kind of namespaces mentioned in 5) is a historical leftover which
causes a LOT of pain now. Java packages are more like modules in Rust
- except that these modules are not isolated at all in the running
program, but can be freely intermixed into a global classpath
assembled from multiple JAR files. This essentially means that there
is no module system at all, because nothing prevents you from e.g.
putting a class into a package you do not own (and then use
package-private and protected members of that package). Implementing
proper module system in Java is very hard, and current attempts like
OSGi or JBoss Modules have various drawbacks. Anyone who developed
complex application with a lot of dependencies for a JavaEE
application server would know what I mean.

Java has several dependency management systems for libraries, however.
Most notable are Ivy and Maven. These systems help in assembling
complete classpath for an application by downloading so-called
artifacts, which are just JAR archives with classes and attached
metadata. Both Ivy and Maven have two-level naming system, which
consists of group identifier and artifact identifier, plus version.
Sometimes there is also a classifier, but it is completely optional
and is used rarely. Complete artifact identifier usually looks like
this: com.google.inject:guice:3.0. Note that "com.google.inject" part
is just a string, no one forces you to use domain names, though that
may affect internal layout of Maven repository. This is most prominent
in Clojure community where libraries are usually named in one or two
words, like [project/artifact "version"] or even [project "version"]
(the latter is equivalent to [project/project "version"]). Clojure
main build tool, Leiningen, uses Maven for dependency resolution, and
aforementioned 'project' becomes group id, and 'artifact' becomes
artifact id.

So, package in Java loosely corresponds to a module in Rust, and
artifact corresponds to crates. In my opinion, Rust system is superior
to Java one because Rust crates are isolated from one another, and you
just cannot have conflicts in modules and items names. Java
conventional artifact system, on the other hand, is really great. It
has its deficiencies, but they are usually tied to concrete build
system (for example, Maven scopes). Java packages is not something
which should be copied, but artifacts systems are mostly nice and
worth learning from.

---

Personally I don't think that rustpkg should be deprecated. The fact
that it has bugs does not mean that it has got something fundamentally
wrong. As far as I understand, it was built using loosely the same
concepts as Go package manager but with own additions like
project-local builds and versions. I think this is really great
approach in its core, and we can start from it.

To summarize, I think the following features should be present in a
decent dependency management/build system:
1. Easy declaration of project dependencies.
2. Automatic downloading of project dependencies from a variety of
sources (version control systems, binary repositories etc.) with an
ability to flexibly define these sources and their priorities over
each other.
3. Support for project-level and user-level packages (this is bare
minimum; system-level packages would also be great, but they are not
required at all).
4. Support for package versions, preferably not tied to version control.
5. Fine-grained control over which dependencies should be used for the
given build.
6. Probably various build scopes with different settings.

These points are a kind of extract of my image of an ideal build
system based on my impressions of various build systems I have worked
with (Maven, Ivy, SBT, Gradle, Leiningen, Cabal, Go).

Most of these items are already present in rustpkg (disregarding bugs
for a moment):
1. Crate dependencies declaration is already present in the language,
it is `extern crate abcd = "crate id";` syntax.
2. rustpkg can use version control to download dependencies
automatically. Other kinds of repositories are not supported yet.
3. Support for various levels of installation is already present, and
it is really great. Maybe it can be tweaked a bit, but it is a solid
base.
4. Currently versions are tied to VCS. This can be changed, I think.
6. Partially supported by the Rust language itself via #[cfg(...)] annotation.

The most difficult part, I think, is 5. As far as I understand,
currently dependencies are resolved automatically, and the user cannot
override or exclude transitive dependencies. I don't know how it could
be implemented without metadata files, which means additional
complexity in the package manager. Item 2 is the second in difficulty,
because concrete format of various kinds of repositories should be
defined, and there are none now. A central, official repository would
be needed too, I think. These points have to be considered very
thoroughly so they won't result into long-standing problems in the
future.

I don't know about flexibility of rustpkg architecture because I
haven't looked through its code, so I don't know its ability to evolve
further, but I think that the main part of the functionality is
already present in it, and it will be a shame not to take advantage of
it.

2014-01-31 Lee Braiden <leebraid at gmail.com>:
> On 31/01/14 08:05, Gaetan wrote:
>
> Le vendredi 31 janvier 2014, Val Markovic <val at markovic.io> a ?crit :
>>
>> .This is a huge problem in large C++ codebases. It is not fun. An example:
>> every version of Xerces-C++ puts its code in a new C++ namespace, so code is
>> in xerces_3_0, xerces_3_1, xerces_3_2 etc to prevent these kinds of issues.
>>
>
> We did that at work, this seems to be the unique, practical solution. I
> don't like when I see a hash in the library file name or symbol name, but
> this very efficient for easily manage inter dependency.
>
>
> This seems like a very wrong-headed approach to me.  The Amiga had a very
> simple and effective library system, which makes me wonder why other systems
> overcomplicate it.  It followed rules something like these, iirc:
>
> 1) If a minor change or bugfix happens, increment the minor version.
> 2) If a major change, which is backwards compatible (i.e., new features)
> happens, then increment the major version.
> 3) When loading libraries, you can specify a major and a minor version, with
> 0 for the minor version if you like.  You get at least that version, or
> better, or the loading fails.
> 4) If an incompatible change happens, then it's not fulfilling the same
> library API any more, so you stop trying to force square pegs into round
> holes, and **just rename the damn thing** ;) ;)
>
> Rule 4 seems to be where every other OS's libraries makes a big mistake.
>
>
> For the internet age, there are new complexities of decentralised forks, I
> think we'd need a few  more rules:
>
> 5) Library names have namespaces, something like Java's (and go's?)
> com.org.libname system
> 6) Anything unofficial (i.e., your patch to version 1.3, bringing it to an
> UNOFFICIAL version 1.4) goes in your own namespace, until accepted into the
> official codebase, OR you fork your own, NEW, incompatible library, as in
> (4)+(5).
>
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From bascule at gmail.com  Fri Jan 31 10:01:12 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 10:01:12 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
Message-ID: <CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>

On Thu, Jan 30, 2014 at 6:37 PM, Val Markovic <val at markovic.io> wrote:

> I'll second Armin and Corey here; if lib A and B depend on different
> versions of lib C, you *must* still be able to easily build and link them
> together as deps of lib D. This is *critical* in large codebases
>

I would personally say having a dependency resolver is *critical* to large
codebases (or any system with a large number of potentially conflicting
packages, like an OS)


> where it's not feasible to go into A and B and update which version of C
> they depend on since A & B are possibly very big and have tons of other
> users who aren't as willing as you are to switch to a new version of C.
>

How does dependency resolution even work in this many-versioned world? Do
you just abandon it entirely? If lib A depends on lib C 1.0.0 and lib B
depends on lib C 1.0.1, do you install both? Or can you find a solution
where both lib A and lib B are happy with one particular version of lib C?

This sort of problem is typically solved by toposorting your way through a
set of constraints, but how do you even specify constraints where there may
be mutually compatible versions, but there may not be? At what point can
you pick one version of lib C as opposed to two or three or more?

For that matter, how do you even resolve dependencies in this sort of
world? What algorithm do you use?

And now imagine a (frighteningly common) nightmare scenario, where the
> library version clash is not two steps away from you, but say 8 and 12. So
> you link something that depends on something that depends on something ...
> that 8 steps away depends on A (which depends on C v1), and a different
> chain of deps that 12 steps away depends on B (which depends on C v2). Good
> luck resolving that.
>

Yes, these situations suck. In the cases where people do actually want to
have two different major versions of a piece of software installed
simultaneously, the convention I've typically seen is to add a "2" or "3"
to the end of the package name. It's a bit silly, but certainly not
irresolvable.

I also don't think this comes up in practice as you allege. Perhaps it's
more frequent in systems that don't have a dependency resolver...

--
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/7d40ad2f/attachment-0001.html>

From val at markovic.io  Fri Jan 31 10:12:14 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 31 Jan 2014 18:12:14 +0000
Subject: [rust-dev] Deprecating rustpkg
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
Message-ID: <6734580107559889337@gmail297201516>

On Fri Jan 31 2014 at 10:01:32 AM, Tony Arcieri <bascule at gmail.com> wrote:

> Or can you find a solution where both lib A and lib B are happy with one
> particular version of lib C?
>

You often cannot find one version that satisfies everyone. I've explained
the reasons why in my previous email.


> At what point can you pick one version of lib C as opposed to two or three
> or more?
>
> For that matter, how do you even resolve dependencies in this sort of
> world? What algorithm do you use?
>

You depend on the latest version of a lib or on a specific, explicit
version. People who don't care about the old version use the latest, and
people who need the old lib version because they haven't updated use that.


> I also don't think this comes up in practice as you allege.
>

This gave me a good, long chuckle (honestly, I mean no offense). Thank you,
I needed that. My day is already better.

If only I lived in a world where this issue "doesn't come up in practice"...


>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/5cdc1a42/attachment.html>

From bascule at gmail.com  Fri Jan 31 10:14:47 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 10:14:47 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <6734580107559889337@gmail297201516>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
Message-ID: <CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>

On Fri, Jan 31, 2014 at 10:12 AM, Strahinja Markovic <val at markovic.io>wrote:

> You depend on the latest version of a lib or on a specific, explicit
> version. People who don't care about the old version use the latest, and
> people who need the old lib version because they haven't updated use that.
>

What algorithm do you use to resolve dependencies in a multi-versioned
world?


> This gave me a good, long chuckle (honestly, I mean no offense). Thank
> you, I needed that. My day is already better.
>
> If only I lived in a world where this issue "doesn't come up in
> practice"...
>

#trolololol

(Sorry, that was a typo, I meant to say "this doesn't come up as often as
you allege in practice")

Yes, I too have been dealing with dependency resolution problems for the
past 20 years... but I have also dealt with problems with incompatible
libraries. They both suck.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/2fcd3d3c/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 12:23:16 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Fri, 31 Jan 2014 20:23:16 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
Message-ID: <CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>

There are some very interesting questions being raised here. I think I can
add to the discussion:

[A] The problem of each version being in its own namespace can be solved by
"slots" (at least that's what portage calls them). See
http://devmanual.gentoo.org/general-concepts/slotting/

Basically you allow package authors to specify versions where there the ABI
doesn't change (I think this is completely orthogonal to the hashing of
library symbols etc) and versions where the ABI does change. So if you care
about a particular version in your rust lib, you can specify either a
version (1.0 > version and version < 2.0 if you want something more than
1.0 but less than 2.0) or a slot or both.

So the algorithm can still be a variant of top sort, just taking the
additional constraint of (optional) slots into account.

[B] Java's mistake with namespaces is made clear by the need for OSGI
containers in the first place.

I don't think there is anything stopping the rust linker for when it
encounters a program that depends on the two libraries (let's call them A
and B) that pull in library C (but A pulls in C version 1.0, slot 1 and B
pulls in C version 2.0, slot 2) to just link the two different versions of
the library in:

                 A  --> C (version 1.0 slot 1)
              /
program /
             \
              \
                 B --> C (version 2.0 slot 2)

Of course, say that this wasn't the case, and both A and B pulled in
different versions of C with slot 1, then you'd potentially have a link
conflict if public symbols were removed during that time and you simply
pick the highest version.

This isn't possible in Java or C++ because the language doesn't allow for
such fine distinctions (and so you see projects like xerces and others try
putting new versions in the namespace itself which is yuk).

[C] (other thoughts)

I think the idea of rustpkg should definitely not be abandoned. There is a
need for a tool to address concerns such as:

* Package identity (this is package A, signed by developer A etc.)
* Package versioning (this is package version 1.0 with slot 1 - see comment
above)
* Package versioning for -SNAPSHOT (-style) versions taken from VCS
* Build-time dependency resolution
* Reliably building packages from source
* Location-agnostic package finding (something like pypi would be a good
start, but obviously decentralized architectures can be more resilient)
* Deterministic builds (yes, the package manager should try to have a
stable dependency resolution algorithm etc)
* Provide the idea of **contained** packages (see virtualenv for python or
GEM_HOME & others)

(Some of these ideas were inspired by http://nixos.org/nixos/ and
http://wiki.gentoo.org/wiki/Project:Portage , both of which are well worth
having a look at if you haven't come across them before)

Vlad


On Fri, Jan 31, 2014 at 6:14 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 10:12 AM, Strahinja Markovic <val at markovic.io>wrote:
>
>> You depend on the latest version of a lib or on a specific, explicit
>> version. People who don't care about the old version use the latest, and
>> people who need the old lib version because they haven't updated use that.
>>
>
> What algorithm do you use to resolve dependencies in a multi-versioned
> world?
>
>


> ?
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/a398152e/attachment.html>

From kevin at sb.org  Fri Jan 31 12:32:01 2014
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 31 Jan 2014 12:32:01 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
Message-ID: <B3AE7703-1D9A-43C7-8B08-813A7AD4B12C@sb.org>

On Jan 31, 2014, at 12:23 PM, Vladimir Lushnikov <vladimir at slate-project.org> wrote:

> There are some very interesting questions being raised here. I think I can add to the discussion:
> 
> [A] The problem of each version being in its own namespace can be solved by "slots" (at least that's what portage calls them). See http://devmanual.gentoo.org/general-concepts/slotting/
> 
> Basically you allow package authors to specify versions where there the ABI doesn't change (I think this is completely orthogonal to the hashing of library symbols etc) and versions where the ABI does change. So if you care about a particular version in your rust lib, you can specify either a version (1.0 > version and version < 2.0 if you want something more than 1.0 but less than 2.0) or a slot or both.
> 
> So the algorithm can still be a variant of top sort, just taking the additional constraint of (optional) slots into account.

I don't know how much of an issue this is in practice, but such a system has two flaws that I can see:

1) It relies on the library author correctly identifying when they've made an API change. Any mistakes on their part will lead to problems down the line for customers.

2) Even non-API changes are sometimes important to customers. Notably, bug fixes, especially if they break previously-implemented workarounds.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/a7f34202/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 12:35:29 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Fri, 31 Jan 2014 20:35:29 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <B3AE7703-1D9A-43C7-8B08-813A7AD4B12C@sb.org>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<B3AE7703-1D9A-43C7-8B08-813A7AD4B12C@sb.org>
Message-ID: <CACTPm50NFLYc9h3xF3PHWoGU457+AQvA6Ej6yiirwPq0edz-dQ@mail.gmail.com>

I agree, the system is flawed as it relies upon the original developer. But
because IMHO we should be considering a build-from-source approach (like
python, unlike Java) it is also easy to fix - just create a fork with the
changes you want. Certainly that is what we do with quite a few libraries
that we use at work (minor changes but still crucial to work with our
software). Of course that doesn't work for binary software, but I don't
think any solution can really address that well.

I wonder if there is appetite for an API compatibility tool that scans your
upgraded library versions and warns you when the public api has changed?
Obviously in the Java world you just upgrade and run your test suite + the
compiler to do that. Also, isn't the rust crate metadata sufficiently rich
to encode at least a subset of the public api reliably? (I'm not sure)






On Fri, Jan 31, 2014 at 8:32 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Jan 31, 2014, at 12:23 PM, Vladimir Lushnikov <
> vladimir at slate-project.org> wrote:
>
> There are some very interesting questions being raised here. I think I can
> add to the discussion:
>
> [A] The problem of each version being in its own namespace can be solved
> by "slots" (at least that's what portage calls them). See
> http://devmanual.gentoo.org/general-concepts/slotting/
>
> Basically you allow package authors to specify versions where there the
> ABI doesn't change (I think this is completely orthogonal to the hashing of
> library symbols etc) and versions where the ABI does change. So if you care
> about a particular version in your rust lib, you can specify either a
> version (1.0 > version and version < 2.0 if you want something more than
> 1.0 but less than 2.0) or a slot or both.
>
> So the algorithm can still be a variant of top sort, just taking the
> additional constraint of (optional) slots into account.
>
>
> I don't know how much of an issue this is in practice, but such a system
> has two flaws that I can see:
>
> 1) It relies on the library author correctly identifying when they've made
> an API change. Any mistakes on their part will lead to problems down the
> line for customers.
>
> 2) Even non-API changes are sometimes important to customers. Notably, bug
> fixes, especially if they break previously-implemented workarounds.
>
> -Kevin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/24ad8c95/attachment-0001.html>

From bascule at gmail.com  Fri Jan 31 12:37:45 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 12:37:45 -0800
Subject: [rust-dev]  Deprecating rustpkg
In-Reply-To: <CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
Message-ID: <CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>

On Friday, January 31, 2014, Vladimir Lushnikov
<vladimir at slate-project.org<javascript:_e(%7B%7D,'cvml','vladimir at slate-project.org');>>
wrote:

> There are some very interesting questions being raised here.
>

You quoted my question (perhaps unintentionally) but didn't answer it...

What algorithm do you use to resolve dependencies in a multi-versioned
world? For a world where you're searching (a DAG) for a set of mutually
compatible versions, toposort is an answer. But what about in a situation
where, based on a given set of constraints, you may or may not want to use
multiple versions of the same dependency?

Unless there's an answer to this question, I think the rustpkg versioning
model is a total nonstarter. I will also note that all major dependency
resolvers (e.g. maven, bundler, apt-get, yum) calculate solutions which
consist of one particular version for each package.

The "version compatibility is hard, let's go shopping!" school of thought
sounds nice in theory, but with nearly a decade of battle scars from
working with a system like that (RubyGems), my experience tells me it's a
terrible, terrible idea in practice...


-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/853a2a00/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 12:51:57 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Fri, 31 Jan 2014 20:51:57 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
Message-ID: <CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>

Apologies, I thought I did.

Package versions consist of a version number and an optional slot.
Constraints are a combination of disjunctive and conjunctive clauses in
boolean logic. From
http://dev.gentoo.org/~zmedico/portage/doc/pt02.html(which explains
what portage does): "Each conjunctive clause represents one
possible alternative combination of dependency atoms capable of satisfying
the dependency expression." You also use lazy evaluation to defer the
computation of concrete dependencies (i.e. a specific version) until as
late as possible. (The docs are quite spartan in both words and layout).

So for slots distinguish the versions that you are trying to pick between -
if you package only depends on slot 1, then you pick the highest version
available in slot 1. If your package libraries have dependencies on a
package with 2 different slots, both get installed. If you have a package
whose libraries depend on incompatible versions of the same library (the
definition of incompatible being what was specified in the packages that
declare their dependencies) - then you get a resolution error.

So your algorithm is a constraint solver essentially. libzypp took a
similar approach (but more formal) -
http://en.opensuse.org/openSUSE:Libzypp_satsolver. They also don't have
multiple 'slots' (in RPMs the slot versions just become part of the package
name). I think explicit slotting is cleaner though.

I realise the above is still a bit hand-wavy still but it already works for
portage ==> it should be implementable for rust.


On Fri, Jan 31, 2014 at 8:37 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Friday, January 31, 2014, Vladimir Lushnikov <
> vladimir at slate-project.org> wrote:
>
>> There are some very interesting questions being raised here.
>>
>
> You quoted my question (perhaps unintentionally) but didn't answer it...
>
> What algorithm do you use to resolve dependencies in a multi-versioned
> world? For a world where you're searching (a DAG) for a set of mutually
> compatible versions, toposort is an answer. But what about in a situation
> where, based on a given set of constraints, you may or may not want to use
> multiple versions of the same dependency?
>
> Unless there's an answer to this question, I think the rustpkg versioning
> model is a total nonstarter. I will also note that all major dependency
> resolvers (e.g. maven, bundler, apt-get, yum) calculate solutions which
> consist of one particular version for each package.
>
> The "version compatibility is hard, let's go shopping!" school of thought
> sounds nice in theory, but with nearly a decade of battle scars from
> working with a system like that (RubyGems), my experience tells me it's a
> terrible, terrible idea in practice...
>
>
> --
> Tony Arcieri
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/c2b02af8/attachment.html>

From bascule at gmail.com  Fri Jan 31 13:05:09 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 13:05:09 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
Message-ID: <CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>

On Fri, Jan 31, 2014 at 12:51 PM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> So for slots distinguish the versions that you are trying to pick between
> - if you package only depends on slot 1, then you pick the highest version
> available in slot 1.
>

What if they're incompatible? In a very handwavey manner, rustpkg claims it
want to (but does not) support semantic versioning. An unexpected major
version bump is to be avoided, IMO, and pinning to a specific version is a
bad solution.


> If you have a package whose libraries depend on incompatible versions of
> the same library (the definition of incompatible being what was specified
> in the packages that declare their dependencies) - then you get a
> resolution error.
>

Why even bother to support multiple versions in this case?

IMO, a system that respects semantic versioning, allows you to constrain
the dependency to a particular *major* version without requiring pinning to
a *specific* version.

I would call anything that requires pinning to a specific version an
antipattern. Among other things, pinning to specific versions precludes
software updates which may be security-critical.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/dade43eb/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 13:12:37 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Fri, 31 Jan 2014 21:12:37 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
Message-ID: <CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>

On Fri, Jan 31, 2014 at 9:05 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 12:51 PM, Vladimir Lushnikov <
> vladimir at slate-project.org> wrote:
>
>> So for slots distinguish the versions that you are trying to pick between
>> - if you package only depends on slot 1, then you pick the highest version
>> available in slot 1.
>>
>
> What if they're incompatible? In a very handwavey manner, rustpkg claims
> it want to (but does not) support semantic versioning. An unexpected major
> version bump is to be avoided, IMO, and pinning to a specific version is a
> bad solution.
>
>

If they're incompatible - you're out of luck - the library authors did not
foresee this and you must deal with it yourself. This is for example why
maven supports their 'exclusion' mechanism (
https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)
but also there is no reason you should not be able to manually say to
rustpkg - 'I know that version x.y.z works for both so please give me that
version'.



> If you have a package whose libraries depend on incompatible versions of
>> the same library (the definition of incompatible being what was specified
>> in the packages that declare their dependencies) - then you get a
>> resolution error.
>>
>
> Why even bother to support multiple versions in this case?
>
> IMO, a system that respects semantic versioning, allows you to constrain
> the dependency to a particular *major* version without requiring pinning
> to a *specific* version.
>
> I would call anything that requires pinning to a specific version an
> antipattern. Among other things, pinning to specific versions precludes
> software updates which may be security-critical.
>

I agree, pinning to a specific version should be avoided (although you have
x.y.z.patch versions sometimes, with you being unable to specify the patch
version as a dependency, which kind of solves the problem) - but I did not
advocate pinning to a particular version.

For example, if I know that I depend on a library of a particular version,
I frequently just go and specify '>= 1.x' as the constraint. Maybe the slot
should be constrained always so that you manually have to bump the version
if a new library release with a new slot is released. Slots in this case
could fill the sematic position of a 'major version'.

By the way, I have not seen how package resolution will handle the case of
a different rust compiler version (especially for binary packages). This is
something Scala addresses for example by guaranteeing binary compatibility
for major compiler versions, and binary packages are typically versioned
with 'slots' that represent the compiler version (though actually they are
just part of the package name if you just use maven and not sbt).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/a2c7aff1/attachment-0001.html>

From bascule at gmail.com  Fri Jan 31 13:35:28 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 13:35:28 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
Message-ID: <CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>

On Fri, Jan 31, 2014 at 1:12 PM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> If they're incompatible - you're out of luck - the library authors did not
> foresee this and you must deal with it yourself. This is for example why
> maven supports their 'exclusion' mechanism (
> https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)
> but also there is no reason you should not be able to manually say to
> rustpkg - 'I know that version x.y.z works for both so please give me that
> version'.
>

I am still confused about:

1) In what situations are you saying there would actually be a workable
multi-version solution that wouldn't exist in a system like Maven
2) How these solutions are calculated

--
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/5ead2afb/attachment.html>

From niko at alum.mit.edu  Fri Jan 31 13:54:10 2014
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 31 Jan 2014 16:54:10 -0500
Subject: [rust-dev] What of semi-automated segmented stacks ?
In-Reply-To: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>
References: <CAKE6RfjL9PxUZ8AYrgU+Hg86b=59su_FtQws4_k_F1j9-433DA@mail.gmail.com>
Message-ID: <20140131215410.GD25089@Mr-Bennet>

One option that might make a lot of sense is having an API like this:

    start_extensible_stack(initial_size, || ...)
    consider_stack_switch(required, || ...)

The idea is that `start_extensible_stack` allocates a stack chunk of
size `initial_size` and runs the closure in
it. `consider_stack_switch` basically does what the old prelude did:
compare the bounds and jump if needed. If you failed to insert
`consider_stack_switch` at all the required place, you'd wind up with
stack overruns. Presumably some mechanism for detecting stack overrun
(e.g. guard pages) is still required.

Unlike the older system, which was intended for universal use, this
would be a power user's API. You get precise control over when to
switch and how much to grow the stack by. This could help avoid the
performance pitfalls we encountered when trying to find a "one size
fits all" heuristic for stack growth. For example, it'd be trivial to
create a system where you start out with a very small stack per
request but switch over to a large stack if the request proves complex
-- but perhaps you only switch once, since you don't want to grow
indefinitely. You should also be better able to avoid performance
pathologies where the stack switch occurs on a frequently traversed
call edge.

On the flip side, of course, it's not clear to me that the API is
really *usable* -- certainly static analysis could identify points of
arbitrary recursion where a call to `consider_stack_switch` may be
needed. One downside is the `start_extensible_stack` routine, since
there is already a start frame to start from. Maybe it's not needed,
and we can just always set the "end of stack" register, but not
necessarily read its contents. That'd be nicer.

Anyway, just thinking aloud here.


Niko


On Thu, Jan 30, 2014 at 06:27:27PM +0100, Matthieu Monrocq wrote:
> Hello,
> 
> Segmented stacks were ditched because of performance issues that were never
> fully resolved, especially when every opaque call (C, ...) required
> allocated a large stack up-front.
> 
> Still, there are platforms (FreeBSD) with small stacks where the idea of
> segmented tasks could ease development... so what if we let the developer
> ship in ?
> 
> 
> The idea of semi-automated segmented stacks would be:
> 
> - to expose to the user how many bytes worth of stack are remaining
> 
> - to let the user trigger a stack switch
> 
> 
> This system should keep the penalty close to null for those who do not
> care, and be relatively orthogonal to the rest of the implementation:
> 
> - how many bytes remaining carries little to no penalty: just a pointed
> substraction between the current stack pointer and the "end-of-stack"
> pointer (which can be set once and for all at thread start-up)
> 
> - the stack switch is voluntary, and can include a prelude on the new stack
> that automatically comes back to its parent so that most code should not
> care, no penalty in regular execution (without it)
> 
> - I foresee some potential implementation difficulty for the unwinder, did
> it ever work on segmented stacks ? Was it difficult/slow ? Does performance
> of unwind matter that much ?
> 
> 
> Work-around:
> 
> In the absence of segmented stacks, the user can only resolve to using
> another task to get a "free" stack. Unfortunately, because of the (great!)
> memory safety of Rust this other task cannot readily access its parent
> task's memory.
> 
> 
> I do not remember whether this idea was investigated when segmented tasks
> were removed. I thought it might be interesting to consider, although... it
> is probably useless for 1.0 anyway.
> 
> -- Matthieu

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From jack at metajack.im  Fri Jan 31 14:29:09 2014
From: jack at metajack.im (Jack Moffitt)
Date: Fri, 31 Jan 2014 15:29:09 -0700
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
Message-ID: <CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>

> I am still confused about:
>
> 1) In what situations are you saying there would actually be a workable
> multi-version solution that wouldn't exist in a system like Maven
> 2) How these solutions are calculated

Every symbol in a crate is hashed with its version. You can load two
extern mod's of the same libriary with different versions with no
problems. Even within the same crate. To the extent that the two
different versions aren't creating a socket to talk to each other with
different versions of a protocol, this works fine. As an example,
think about a JSON library that has undergone significant API changes.
Each version can still read and write JSON, but the API to use them
might be quite different. There's no inherent conflict to using both
versions.

As for how you would calculate this, it's easy. You just use exactly
the versions that the extern mods ask for. If they ask for a version,
you pick that one. If they don't, you pick the newest one. This breaks
the same way as any other algorithm when the unconstrained
dependencies can't be resolved.

This is substantially different than the Java (or Erlang) world where
the function names are not versioned behind the scenes and would
clobber each other.

Hopefully I haven't misunderstood your question.

jack.

From bascule at gmail.com  Fri Jan 31 14:56:38 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 14:56:38 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
Message-ID: <CAHOTMVJoOTE3LXosKXqG9FxMxbFMCsWkVzJb==2L305cogWAFQ@mail.gmail.com>

On Fri, Jan 31, 2014 at 2:29 PM, Jack Moffitt <jack at metajack.im> wrote:

> Every symbol in a crate is hashed with its version. You can load two
>  extern mod's of the same libriary with different versions with no
> problems. [...]
>

This is not what I'm asking. I understand this "works". I am curious
specifically about dependency resolution.

As for how you would calculate this, it's easy. You just use exactly
> the versions that the extern mods ask for. If they ask for a version,

you pick that one.


Okay, we've covered one and exactly one case here: pinning to an exact
version. I'm calling this an *antipattern: *it precludes updates (which may
contain things like security fixes) in the event when there are compatible
upgrades. So this is bad...


> If they don't, you pick the newest one.


What if we're incompatible with the newest version? How do we lock to the
nearest major (or potentially minor) version?


> This is substantially different than the Java (or Erlang) world where
>
the function names are not versioned behind the scenes and would
> clobber each other.
>

Yes, but you're discussing a function of the packaging system, not the
dependency resolver. These concerns are orthogonal.


> Hopefully I haven't misunderstood your question.


You have basically said the same things that have been said before without
answering my question whatsoever, so I'll ask it again:

In what situations are you saying there would actually be a workable
multi-version solution that wouldn't exist in a system like Maven.

Perhaps an example is in order? Can you give me an example of a set of
packages, versions, and dependencies, and show me:

1) How these dependencies would (or would not) be resolved in a
Maven/Bundler/apt-get/yum-like system that's doing something toposort-like
2) How these dependencies would be resolved in the as-yet-unspecified
handwavey pie-in-the-sky system which supports multiple versions of the
same package

I would specifically like to see an example of a problem where
Maven/Bundler/apt-get/yum could not arrive on a solution that a system
which supports the installation of multiple simultaneous versions could
solve

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/3733a738/attachment.html>

From val at markovic.io  Fri Jan 31 14:59:34 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 31 Jan 2014 22:59:34 +0000
Subject: [rust-dev] Deprecating rustpkg
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
Message-ID: <-7815470346720532493@gmail297201516>

On Fri Jan 31 2014 at 2:29:16 PM, Jack Moffitt <jack at metajack.im> wrote:

> > I am still confused about:
> >
> > 1) In what situations are you saying there would actually be a workable
> > multi-version solution that wouldn't exist in a system like Maven
> > 2) How these solutions are calculated
>
> Every symbol in a crate is hashed with its version. You can load two
> extern mod's of the same libriary with different versions with no
> problems. Even within the same crate. To the extent that the two
> different versions aren't creating a socket to talk to each other with
> different versions of a protocol, this works fine. As an example,
> think about a JSON library that has undergone significant API changes.
> Each version can still read and write JSON, but the API to use them
> might be quite different. There's no inherent conflict to using both
> versions.
>
> As for how you would calculate this, it's easy. You just use exactly
> the versions that the extern mods ask for. If they ask for a version,
> you pick that one. If they don't, you pick the newest one. This breaks
> the same way as any other algorithm when the unconstrained
> dependencies can't be resolved.
>

This is exactly the system I was referring to. Rust makes it easy to have
multiple versions of a library linked into a single binary. If the
libraries you depend on all ask for the latest (or unspecified) version of
a library, you pull in the latest. If they ask for a specific version, you
link that in as well.

The package manager should make this more granular as well; instead of
offering "latest" and "exact version", you specify depending on libfoo with
"latest", "1.2.3", "1.2.x", "1.x" etc. If the constraint is "1.x", you pick
the latest version that's still 1.x.

And then you link in *all* the libs that are necessary to satisfy the
various constraints, you *don't* look for the One True Version that
satisfies all of your deps.


>
> This is substantially different than the Java (or Erlang) world where
> the function names are not versioned behind the scenes and would
> clobber each other.
>
> Hopefully I haven't misunderstood your question.
>
> jack.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/b90a521e/attachment-0001.html>

From bascule at gmail.com  Fri Jan 31 15:03:34 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 15:03:34 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <-7815470346720532493@gmail297201516>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
Message-ID: <CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>

On Fri, Jan 31, 2014 at 2:59 PM, Strahinja Markovic <val at markovic.io> wrote:

> This is exactly the system I was referring to. Rust makes it easy to have
> multiple versions of a library linked into a single binary. If the
> libraries you depend on all ask for the latest (or unspecified) version of
> a library, you pull in the latest. If they ask for a specific version, you
> link that in as well.
>
> The package manager should make this more granular as well; instead of
> offering "latest" and "exact version", you specify depending on libfoo with
> "latest", "1.2.3", "1.2.x", "1.x" etc. If the constraint is "1.x", you pick
> the latest version that's still 1.x.
>
> And then you link in *all* the libs that are necessary to satisfy the
> various constraints, you *don't* look for the One True Version that
> satisfies all of your deps.
>

I am 100% clear that, from a technical perspective, Rust has the ability to
support multiple different versions of the same library simultaneously.

However:

1) Is this a good idea?
2) Is this compatible with the idea of toposort-style dependency resolution?

Can anyone point to a real-world example of a dependency resolver which can
produce solutions which may-or-may-not contain multiple versions of the
same library?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/30804ade/attachment.html>

From danielmicay at gmail.com  Fri Jan 31 15:07:56 2014
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 31 Jan 2014 18:07:56 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
Message-ID: <CA+DvKQ+V=PYGQGGifAWBbNcr81xTOKLunoS2+t4BLL8FitjCeQ@mail.gmail.com>

On Fri, Jan 31, 2014 at 6:03 PM, Tony Arcieri <bascule at gmail.com> wrote:
> On Fri, Jan 31, 2014 at 2:59 PM, Strahinja Markovic <val at markovic.io> wrote:
>>
>> This is exactly the system I was referring to. Rust makes it easy to have
>> multiple versions of a library linked into a single binary. If the libraries
>> you depend on all ask for the latest (or unspecified) version of a library,
>> you pull in the latest. If they ask for a specific version, you link that in
>> as well.
>>
>> The package manager should make this more granular as well; instead of
>> offering "latest" and "exact version", you specify depending on libfoo with
>> "latest", "1.2.3", "1.2.x", "1.x" etc. If the constraint is "1.x", you pick
>> the latest version that's still 1.x.
>>
>> And then you link in all the libs that are necessary to satisfy the
>> various constraints, you don't look for the One True Version that satisfies
>> all of your deps.
>
>
> I am 100% clear that, from a technical perspective, Rust has the ability to
> support multiple different versions of the same library simultaneously.
>
> However:
>
> 1) Is this a good idea?
> 2) Is this compatible with the idea of toposort-style dependency resolution?
>
> Can anyone point to a real-world example of a dependency resolver which can
> produce solutions which may-or-may-not contain multiple versions of the same
> library?
>
> --
> Tony Arcieri

http://en.opensuse.org/openSUSE:Libzypp_satsolver

From bascule at gmail.com  Fri Jan 31 15:11:37 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 15:11:37 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CA+DvKQ+V=PYGQGGifAWBbNcr81xTOKLunoS2+t4BLL8FitjCeQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<CA+DvKQ+V=PYGQGGifAWBbNcr81xTOKLunoS2+t4BLL8FitjCeQ@mail.gmail.com>
Message-ID: <CAHOTMVLuxsK8Y1gG=OeUCW8k5jktNxfhmCuU-iax9EMtkg-E7w@mail.gmail.com>

On Fri, Jan 31, 2014 at 3:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> http://en.opensuse.org/openSUSE:Libzypp_satsolver
>

Thanks for the link, but upon cursory examination I'm not seeing
specifically how this determines whether or not a given set of constraints
is:

1) Solvable by a single version of a package

vs

2) Solvable by many versions of the same package

vs

3) Unsolvable

Can you link me something which explains how this particular problem is
resolved specifically?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/4640d043/attachment.html>

From bascule at gmail.com  Fri Jan 31 15:13:26 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 15:13:26 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVLuxsK8Y1gG=OeUCW8k5jktNxfhmCuU-iax9EMtkg-E7w@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<CA+DvKQ+V=PYGQGGifAWBbNcr81xTOKLunoS2+t4BLL8FitjCeQ@mail.gmail.com>
	<CAHOTMVLuxsK8Y1gG=OeUCW8k5jktNxfhmCuU-iax9EMtkg-E7w@mail.gmail.com>
Message-ID: <CAHOTMVJ8TkgEk6KB=bUc6ZTYnfx7GC-FgoC3=wU6RmgBDwgr+g@mail.gmail.com>

On Fri, Jan 31, 2014 at 3:11 PM, Tony Arcieri <bascule at gmail.com> wrote:

> Can you link me something which explains how this particular problem is
> resolved specifically?
>

Also I would really like to see an example of a problem that can be solved
by multiple versions of a package which systems like Maven/Bundler/apt/yum
can't solve

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/ea57f199/attachment.html>

From val at markovic.io  Fri Jan 31 15:24:29 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 31 Jan 2014 23:24:29 +0000
Subject: [rust-dev] Deprecating rustpkg
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
Message-ID: <-5222466096720818471@gmail297201516>

On Fri Jan 31 2014 at 3:03:54 PM, Tony Arcieri <bascule at gmail.com> wrote:

I am 100% clear that, from a technical perspective, Rust has the ability to
support multiple different versions of the same library simultaneously.

However:

1) Is this a good idea?


Of course it's a good idea. There's a need for that today in C++, Python
and other languages. Without this feature you end up in the clash of
"there's no single version that satisfies all of my deps" and you're sad
and unhappy. And waste time and money.

With Rust, the symbols won't conflict so there's no downside.


2) Is this compatible with the idea of toposort-style dependency resolution?


I honestly can't even say I understand what exactly you mean by
"toposort-style dependency resolution", but I can't help but feel that the
answer to your question is *"Why do we care?".* Implementing an algorithm
that fulfills the design I and others have proposed is trivial.


Can anyone point to a real-world example of a dependency resolver which can
produce solutions which may-or-may-not contain multiple versions of the
same library?


What's the point? I don't know of any language other than Rust that doesn't
bork when you link/load/eval multiple versions of a library in the same
binary/process/interpreter. So no other language even *could *have
implemented this without hacks like adding the library version to its
name/namespace/whatever.

Let's not limit what we can build for Rust by constraining ourselves to
what others have built for languages that don't have Rust's capabilities.



-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/4029e5e4/attachment-0001.html>

From bascule at gmail.com  Fri Jan 31 15:32:26 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 15:32:26 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <-5222466096720818471@gmail297201516>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
Message-ID: <CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>

On Fri, Jan 31, 2014 at 3:24 PM, Strahinja Markovic <val at markovic.io> wrote:

> I honestly can't even say I understand what exactly you mean by
> "toposort-style dependency resolution", but I can't help but feel that the
> answer to your question is *"Why do we care?".* Implementing an algorithm
> that fulfills the design I and others have proposed is trivial.
>

What is this algorithm, and what is a concrete example of a set of
dependencies that your hypothetical algorithm can solve which toposort
can't?


> What's the point? I don't know of any language other than Rust that
> doesn't bork when you link/load/eval multiple versions of a library in the
> same binary/process/interpreter. So no other language even *could *have
> implemented this without hacks like adding the library version to its
> name/namespace/whatever.
>
> Let's not limit what we can build for Rust by constraining ourselves to
> what others have built for languages that don't have Rust's capabilities.
>

If the dependency resolver can't support finding solutions which are
satisfied by multiple versions of the same library in cases where a
toposort-style dependency resolver can't, the entire endeavor is a
pointless waste of time which does nothing but complect the packaging
system and make it more confusing.

I am strongly suggesting before you go down this road you figure out:

1) *Exactly* what problem you're trying to solve
2) *Exactly* how you intend to solve it

RubyGems went down the road of trying to support the simultaneous
installation of multiple versions of the same package. However, Bundler,
the dependency resolution tool, ended up resolving packages to a single,
specific version. This made RubyGems support of multiple versions of
packages not only useless, but annoying, and even more cruft (e.g. rvm
gemsets) was added to work around the impedance mismatch between the
package manager and the dependency resolver.

I hope Rust will not make the same mistake for lack of better planning.

--
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/b0ce3275/attachment.html>

From corey at octayn.net  Fri Jan 31 15:33:29 2014
From: corey at octayn.net (Corey Richardson)
Date: Fri, 31 Jan 2014 18:33:29 -0500
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <-5222466096720818471@gmail297201516>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
Message-ID: <CA++BO6SZoMq9khH9R2VL5jrGSv6YWbBcWSy5=gg_zjkaXOeZEg@mail.gmail.com>

I see where Tony is coming from for this one. Just because we *can*
doesn't necessarily mean we should. If possible we should definitely
prefer to find a common version that both libraries can be happy with.
I myself don't have the answers to his questions, though.

On Fri, Jan 31, 2014 at 6:24 PM, Strahinja Markovic <val at markovic.io> wrote:
>
>
> On Fri Jan 31 2014 at 3:03:54 PM, Tony Arcieri <bascule at gmail.com> wrote:
>
> I am 100% clear that, from a technical perspective, Rust has the ability to
> support multiple different versions of the same library simultaneously.
>
> However:
>
> 1) Is this a good idea?
>
>
> Of course it's a good idea. There's a need for that today in C++, Python and
> other languages. Without this feature you end up in the clash of "there's no
> single version that satisfies all of my deps" and you're sad and unhappy.
> And waste time and money.
>
> With Rust, the symbols won't conflict so there's no downside.
>
>
> 2) Is this compatible with the idea of toposort-style dependency resolution?
>
>
> I honestly can't even say I understand what exactly you mean by
> "toposort-style dependency resolution", but I can't help but feel that the
> answer to your question is "Why do we care?". Implementing an algorithm that
> fulfills the design I and others have proposed is trivial.
>
>
> Can anyone point to a real-world example of a dependency resolver which can
> produce solutions which may-or-may-not contain multiple versions of the same
> library?
>
>
> What's the point? I don't know of any language other than Rust that doesn't
> bork when you link/load/eval multiple versions of a library in the same
> binary/process/interpreter. So no other language even could have implemented
> this without hacks like adding the library version to its
> name/namespace/whatever.
>
> Let's not limit what we can build for Rust by constraining ourselves to what
> others have built for languages that don't have Rust's capabilities.
>
>
>
> --
> Tony Arcieri
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From val at markovic.io  Fri Jan 31 15:49:03 2014
From: val at markovic.io (Strahinja Markovic)
Date: Fri, 31 Jan 2014 23:49:03 +0000
Subject: [rust-dev] Deprecating rustpkg
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
Message-ID: <-5232449504785159694@gmail297201516>

On Fri Jan 31 2014 at 3:33:00 PM, Tony Arcieri <bascule at gmail.com> wrote:

> I am strongly suggesting before you go down this road you figure out:
>
> 1) *Exactly* what problem you're trying to solve
> 2) *Exactly* how you intend to solve it
>

I'll try to find some time today/weekend to write up a Google Doc
explaining what I'm proposing (and the algorithm to do it) in more detail.
I'll ping this thread with a link.


>
> RubyGems went down the road of trying to support the simultaneous
> installation of multiple versions of the same package. However, Bundler,
> the dependency resolution tool, ended up resolving packages to a single,
> specific version. This made RubyGems support of multiple versions of
> packages not only useless, but annoying, and even more cruft (e.g. rvm
> gemsets) was added to work around the impedance mismatch between the
> package manager and the dependency resolver.
>
> I hope Rust will not make the same mistake for lack of better planning.
>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/2419005f/attachment.html>

From jack at metajack.im  Fri Jan 31 15:59:50 2014
From: jack at metajack.im (Jack Moffitt)
Date: Fri, 31 Jan 2014 16:59:50 -0700
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
Message-ID: <CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>

> What is this algorithm, and what is a concrete example of a set of
> dependencies that your hypothetical algorithm can solve which toposort
> can't?

Doesn't topsort require that you find a single version that satisfies
all dependencies? It's easy to construct things that will work for the
way rustpkg was designed (multiple versions of libs) that will fail
the requirement of needing a single version.

Package foobar
Depends rust-logger
  Depends rust-json 1.0
Depends rust-rest 1.0
  Depends rust-json 2.0

Here the logger was written back with the old json api, whereas the
REST client is written with the new API. There is no version of
rust-json that will satisfy both dependencies. For sake of argument,
let's assume there are no newer versions of rust-logger.

Without using multiple versions of rust-json, we'd have to fork and
update rust-logger. Such a conflict can appear arbitrarily many times
and arbitrarily deep in the hierarchy. I have hit such dependency
problems in previous projects with both Clojure and Erlang, both (as
far as I understand it) using topsort style dependency resolution.

The algorithm here is rather simple. We try to satisfy rust-logger and
rust-rest. rust-rest has a version (or could be a tag like 1.x) so we
go get that. It depends on rust-json 2.0 so we get that. Then we try
to look for rust-logger, whatever version is latest (in rustpkg this
would mean current master since no version or tag is given). This
pulls in rust-json 1.0 since 1.0 != 2.0 and those have specific tags.
Everything is built and linked as normal. Whether rust-json's
constraints are exact revisions or they are intervals (< 2.0 and >=
2.0 for example), makes little difference I think.

This happens all the time in Clojure especially in the rapidly
advancing web library ecosystem. It's not hard to concoct some set of
versions which conflict on the json library, the Ring library, or some
other low-level dependecy. Sometimes forcing the issue with exclusions
works. Sometimes it doesn't. Just look at the pile of forks on Clojars
of common low-level dependencies, and it's easy to see this is not
uncommon.

I'm not trying to argue that we build something that supports this and
only this. But this was a specific design criteria of Rust's linkage
model *and* it's package manager (rustpkg anyway; i wasn't around for
cargo). People have put a lot of thought into this because it's a long
standing wart of compiled languages, or at least it is in the eyes of
Rust's designers. This model also has issues which much be addressed.
You don't for example want 20 copies of rust-json just because it's
used often and each person specificied some different micro-revision
(doesn't npm do something like this?), bloating the binary size.

Also, I'm not sure the models are incompatible. It's perfectly fine to
do topsort and then just include multiple versions when a conflict
can't be completely resolved.

jack.

PS. Having now gone to look up to make sure I understand what topsort
is, I'm not sure how that is particularly related.  I assume you mean
that you are topsorting where nodes of the graph are packages not
versions of packages. In that case, since only one version can be
picked, if you have conflicting requirements (as above) then you're
stuck. If you topsort on versions of packages, there's no issues, but
then you probably need some way to collapse nodes when constraints
allow it to avoid having multiple compatible versions.

From leebraid at gmail.com  Fri Jan 31 16:03:17 2014
From: leebraid at gmail.com (Lee Braiden)
Date: Sat, 01 Feb 2014 00:03:17 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
Message-ID: <52EC39C5.90801@gmail.com>

On 31/01/14 23:03, Tony Arcieri wrote:
> Can anyone point to a real-world example of a dependency resolver 
> which can produce solutions which may-or-may-not contain multiple 
> versions of the same library?

This would be counterproductive.  If a library cannot be upgraded to 
1.9, or even 2.2, because some app REQUIRES 1.4, then that causes 
SERIOUS, SECURITY issues.

The ONLY realistic way I can see to solve this, is to have all higher 
version numbers of the same package be backwards compatible, and have 
incompatible packages be DIFFERENT packages, as I mentioned before.

Really, there is a contract here: an API contract.  To break 
compatibility is to break that contract.  This is a bug, and shouldn't 
happen.  If you want to make something incompatible, you simply 
shouldn't call it the same name as the thing it's incompatible with.  No 
more than you should sell a knife as a bottle-opener.  They do not 
fulfill the same contract, and to say they do is false advertising.

-- 
Lee


From bascule at gmail.com  Fri Jan 31 16:03:41 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 16:03:41 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
Message-ID: <CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>

On Fri, Jan 31, 2014 at 3:59 PM, Jack Moffitt <jack at metajack.im> wrote:

> The algorithm here is rather simple. We try to satisfy rust-logger and
>  rust-rest. rust-rest has a version (or could be a tag like 1.x) so we
> go get that. It depends on rust-json 2.0 so we get that. Then we try
> to look for rust-logger, whatever version is latest (in rustpkg this
> would mean current master since no version or tag is given). This
> pulls in rust-json 1.0 since 1.0 != 2.0 and those have specific tags.
> Everything is built and linked as normal. Whether rust-json's
> constraints are exact revisions or they are intervals (< 2.0 and >=
> 2.0 for example), makes little difference I think.


To reiterate, it sounds like you're describing every package pinning its
dependencies to a specific version, which I'd consider an antipattern.

What is to prevent a program using this (still extremely handwavey)
algorithm from depending on rust-json 1.0, 1.1, 1.2, 1.3, 1.4, 2.0, 2.1,
and 2.2 simultaneously?

What if some of these are buggy, but the fixed versions aren't used due to
version pinning?

What if rust-json 1.0 has a security issue?

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/a2d2ac5f/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 16:05:46 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:05:46 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52EC39C5.90801@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<52EC39C5.90801@gmail.com>
Message-ID: <CACTPm537MvznidDf=asA2yGNx7n374ov6z0i8pVZ22ed=iSaSw@mail.gmail.com>

I disagree. With the same analogy, I could sell you a blunt knife - you
would use it as a letter opener, and then I would fix the bug. Now you
might actually cut yourself!

I think this is a different concern. It should be up to the library author
what they deems as 'compatible'. It does not excuse the consumers of the
library to do their own testing that it produces the results they want (a
version number in any form is not a proof of correctness).


On Sat, Feb 1, 2014 at 12:03 AM, Lee Braiden <leebraid at gmail.com> wrote:

> On 31/01/14 23:03, Tony Arcieri wrote:
>
>> Can anyone point to a real-world example of a dependency resolver which
>> can produce solutions which may-or-may-not contain multiple versions of the
>> same library?
>>
>
> This would be counterproductive.  If a library cannot be upgraded to 1.9,
> or even 2.2, because some app REQUIRES 1.4, then that causes SERIOUS,
> SECURITY issues.
>
> The ONLY realistic way I can see to solve this, is to have all higher
> version numbers of the same package be backwards compatible, and have
> incompatible packages be DIFFERENT packages, as I mentioned before.
>
> Really, there is a contract here: an API contract.  To break compatibility
> is to break that contract.  This is a bug, and shouldn't happen.  If you
> want to make something incompatible, you simply shouldn't call it the same
> name as the thing it's incompatible with.  No more than you should sell a
> knife as a bottle-opener.  They do not fulfill the same contract, and to
> say they do is false advertising.
>
> --
> Lee
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/cc48f486/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 16:07:47 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:07:47 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
Message-ID: <CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>

Then you would want to know about it. No package manager for a language has
a way to see security advisories (and this is a problem). Gentoo has GLSA
which is kind of OK (better than scanning the CVE list yourself) but I feel
a language should offer a tool to do exactly this.

Just to be clear, I think what you are saying is that you want version
pinning to be dynamic? I.e. when a new version of a library dependency
becomes available, upgrade the package with that dependency?


On Sat, Feb 1, 2014 at 12:03 AM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 3:59 PM, Jack Moffitt <jack at metajack.im> wrote:
>
>> The algorithm here is rather simple. We try to satisfy rust-logger and
>>  rust-rest. rust-rest has a version (or could be a tag like 1.x) so we
>> go get that. It depends on rust-json 2.0 so we get that. Then we try
>> to look for rust-logger, whatever version is latest (in rustpkg this
>> would mean current master since no version or tag is given). This
>> pulls in rust-json 1.0 since 1.0 != 2.0 and those have specific tags.
>> Everything is built and linked as normal. Whether rust-json's
>> constraints are exact revisions or they are intervals (< 2.0 and >=
>> 2.0 for example), makes little difference I think.
>
>
> To reiterate, it sounds like you're describing every package pinning its
> dependencies to a specific version, which I'd consider an antipattern.
>
> What is to prevent a program using this (still extremely handwavey)
> algorithm from depending on rust-json 1.0, 1.1, 1.2, 1.3, 1.4, 2.0, 2.1,
> and 2.2 simultaneously?
>
> What if some of these are buggy, but the fixed versions aren't used due to
> version pinning?
>
> What if rust-json 1.0 has a security issue?
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/e939142f/attachment-0001.html>

From vladimir at slate-project.org  Fri Jan 31 16:08:19 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:08:19 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
Message-ID: <CACTPm51BTyf=3451KUsUvH66jcjM-_jQ3j6vda82-bRXWkWwuA@mail.gmail.com>

Apologies, that should have been *a language that I know of*


On Sat, Feb 1, 2014 at 12:07 AM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> Then you would want to know about it. No package manager for a language
> has a way to see security advisories (and this is a problem).
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/fab716c5/attachment.html>

From bascule at gmail.com  Fri Jan 31 16:09:21 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 16:09:21 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <52EC39C5.90801@gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<52EC39C5.90801@gmail.com>
Message-ID: <CAHOTMVLn0Koc8nryTt6sLTQfCjSSX64vpmSPerXSDLYyVuvPjA@mail.gmail.com>

On Fri, Jan 31, 2014 at 4:03 PM, Lee Braiden <leebraid at gmail.com> wrote:

> This would be counterproductive.  If a library cannot be upgraded to 1.9,
> or even 2.2, because some app REQUIRES 1.4, then that causes SERIOUS,
> SECURITY issues.
>

Yes, these are exactly the types of problems I want to help solve. Many
people on this thread are talking about pinning to specific versions of
libraries. This will prevent upgrades in the event of a security problem.

Good dependency resolvers work on constraints, not specific versions.

The ONLY realistic way I can see to solve this, is to have all higher
> version numbers of the same package be backwards compatible, and have
> incompatible packages be DIFFERENT packages, as I mentioned before.
>
> Really, there is a contract here: an API contract.


Are you familiar with semantic versioning?

http://semver.org/

Semantic Versioning would stipulate that a backwards incompatible change in
an API would necessitate a MAJOR version bump. This indicates a break in
the original contract.

Ideally if people are using multiple major versions of the same package,
and a security vulnerability is discovered which affects all versions of a
package, that the package maintainers release a hotfix for all major
versions.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/a622f995/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 16:12:33 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:12:33 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVLn0Koc8nryTt6sLTQfCjSSX64vpmSPerXSDLYyVuvPjA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<52EC39C5.90801@gmail.com>
	<CAHOTMVLn0Koc8nryTt6sLTQfCjSSX64vpmSPerXSDLYyVuvPjA@mail.gmail.com>
Message-ID: <CACTPm50P+NvTZkYwEvS-LagCGVcpSUOnGwYY83tHZ3Bk=V1jhA@mail.gmail.com>

Looking briefly over the semantic versioning page, doesn't it just mandate
a particular version format for when you break API compatibility? This is
in theory the same thing I was talking about with slots, just encoded in
the version number. It can get ridiculous as well though - see for example
openssl's version 1.0.0l?


On Sat, Feb 1, 2014 at 12:09 AM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 4:03 PM, Lee Braiden <leebraid at gmail.com> wrote:
>
>> This would be counterproductive.  If a library cannot be upgraded to 1.9,
>> or even 2.2, because some app REQUIRES 1.4, then that causes SERIOUS,
>> SECURITY issues.
>>
>
> Yes, these are exactly the types of problems I want to help solve. Many
> people on this thread are talking about pinning to specific versions of
> libraries. This will prevent upgrades in the event of a security problem.
>
> Good dependency resolvers work on constraints, not specific versions.
>
> The ONLY realistic way I can see to solve this, is to have all higher
>> version numbers of the same package be backwards compatible, and have
>> incompatible packages be DIFFERENT packages, as I mentioned before.
>>
>> Really, there is a contract here: an API contract.
>
>
> Are you familiar with semantic versioning?
>
> http://semver.org/
>
> Semantic Versioning would stipulate that a backwards incompatible change
> in an API would necessitate a MAJOR version bump. This indicates a break in
> the original contract.
>
> Ideally if people are using multiple major versions of the same package,
> and a security vulnerability is discovered which affects all versions of a
> package, that the package maintainers release a hotfix for all major
> versions.
>
> --
> Tony Arcieri
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/4dcbbd94/attachment.html>

From bascule at gmail.com  Fri Jan 31 16:12:56 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 16:12:56 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
Message-ID: <CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>

On Fri, Jan 31, 2014 at 4:07 PM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> Just to be clear, I think what you are saying is that you want version
> pinning to be dynamic? I.e. when a new version of a library dependency
> becomes available, upgrade the package with that dependency?
>

I would like a constraints-based system that is able to calculate the
latest API-compatible version of a given package based on rules less strict
than version = X.Y.Z

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/138df42b/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 16:15:00 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:15:00 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
	<CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>
Message-ID: <CACTPm52FJfKZMx8cXerPfMuDJcCPv+q6J707Atzqgp=V9EZHrA@mail.gmail.com>

The question is, what do you want the constraint-based system to do:

1) To determine API compatibility for you based on some input from the
library author? (be this semantic versioning, slots, something else)
2) To determine API compatibility automatically just by examining the
interface provided by the library and seeing if it compiles (or something
like that)


On Sat, Feb 1, 2014 at 12:12 AM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 4:07 PM, Vladimir Lushnikov <
> vladimir at slate-project.org> wrote:
>
>> Just to be clear, I think what you are saying is that you want version
>> pinning to be dynamic? I.e. when a new version of a library dependency
>> becomes available, upgrade the package with that dependency?
>>
>
> I would like a constraints-based system that is able to calculate the
> latest API-compatible version of a given package based on rules less strict
> than version = X.Y.Z
>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/16e76c0e/attachment-0001.html>

From bascule at gmail.com  Fri Jan 31 16:15:48 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 16:15:48 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm52FJfKZMx8cXerPfMuDJcCPv+q6J707Atzqgp=V9EZHrA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
	<CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>
	<CACTPm52FJfKZMx8cXerPfMuDJcCPv+q6J707Atzqgp=V9EZHrA@mail.gmail.com>
Message-ID: <CAHOTMV+cJZzWkGJ402Q5keCuG=-G=q1WwJWYHgoYVzhD2EM4fg@mail.gmail.com>

On Fri, Jan 31, 2014 at 4:15 PM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> 1) To determine API compatibility for you based on some input from the
> library author? (be this semantic versioning, slots, something else)
>

This. You should be able to lock to major and/or minor versions of a
particular package

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/249fbfbb/attachment.html>

From vladimir at slate-project.org  Fri Jan 31 16:23:43 2014
From: vladimir at slate-project.org (Vladimir Lushnikov)
Date: Sat, 1 Feb 2014 00:23:43 +0000
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMV+cJZzWkGJ402Q5keCuG=-G=q1WwJWYHgoYVzhD2EM4fg@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
	<CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>
	<CACTPm52FJfKZMx8cXerPfMuDJcCPv+q6J707Atzqgp=V9EZHrA@mail.gmail.com>
	<CAHOTMV+cJZzWkGJ402Q5keCuG=-G=q1WwJWYHgoYVzhD2EM4fg@mail.gmail.com>
Message-ID: <CACTPm51GMYbuUue3NBh+ZeLUc=9=fu3aQMOkJnQNxzU4ghSF9g@mail.gmail.com>

Is this not exactly what was being discussed? Maven doesn't support this
(but pip does for example ""Baz>=2.0, <3.0"). Portage certainly supports it
as well.


On Sat, Feb 1, 2014 at 12:15 AM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Jan 31, 2014 at 4:15 PM, Vladimir Lushnikov <
> vladimir at slate-project.org> wrote:
>
>> 1) To determine API compatibility for you based on some input from the
>> library author? (be this semantic versioning, slots, something else)
>>
>
> This. You should be able to lock to major and/or minor versions of a
> particular package
>
> --
> Tony Arcieri
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140201/e4d820ff/attachment.html>

From bascule at gmail.com  Fri Jan 31 16:36:54 2014
From: bascule at gmail.com (Tony Arcieri)
Date: Fri, 31 Jan 2014 16:36:54 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CACTPm51GMYbuUue3NBh+ZeLUc=9=fu3aQMOkJnQNxzU4ghSF9g@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
	<CACTPm521vjjchxdPKp1vE3KReSu0DR+=jjgyLHuUG6K_kBC3qA@mail.gmail.com>
	<CAHOTMV+amq6nUSSk901JvvmAyX_u1n5orHVPTEqVhwxf1Egwtg@mail.gmail.com>
	<CAP7VpsXpvRzCAaz=r0pvLsC3q7y+CgC25nRbujgvMz+QmQKqZA@mail.gmail.com>
	<-7815470346720532493@gmail297201516>
	<CAHOTMVKLzfe_up0cJC__8BTxtW-L_76HS=t90k_svjXv25JJmw@mail.gmail.com>
	<-5222466096720818471@gmail297201516>
	<CAHOTMVKxCF2KHsJsP6Q5KeM_w_smPTPyuRyqo3kGR_H+bCC1XQ@mail.gmail.com>
	<CAP7VpsX3vvZ7+P9EgsQ+kVv2rhAAPMSk3O17-oeES5u_4E4zgQ@mail.gmail.com>
	<CAHOTMVK678YJ4e-3_pc9rLXN0itUjnfFXQzGdMX+aB4CRLQ+2A@mail.gmail.com>
	<CACTPm50a9LLR0ON_TiWH0xdej-9w2QWjfZ6TusMjzp6zFLqEAQ@mail.gmail.com>
	<CAHOTMVK1JsKcxPpLRJrHWG0wcrgV9jJGwCw1L-zWJrcM4cmXDw@mail.gmail.com>
	<CACTPm52FJfKZMx8cXerPfMuDJcCPv+q6J707Atzqgp=V9EZHrA@mail.gmail.com>
	<CAHOTMV+cJZzWkGJ402Q5keCuG=-G=q1WwJWYHgoYVzhD2EM4fg@mail.gmail.com>
	<CACTPm51GMYbuUue3NBh+ZeLUc=9=fu3aQMOkJnQNxzU4ghSF9g@mail.gmail.com>
Message-ID: <CAHOTMVL1d5cRzJfMJzem_Gi55KxHKcC3eD-Ci_=Pno-vzK=X+w@mail.gmail.com>

On Fri, Jan 31, 2014 at 4:23 PM, Vladimir Lushnikov <
vladimir at slate-project.org> wrote:

> Is this not exactly what was being discussed?
>

It is! I'm still asking for a less handwavy explanation of how this would
work in a system which may-or-may-not select multiple versions of a package
depending on the given constraints, and concrete examples of how it would
work.


> Maven doesn't support this
>

Uhh, yes it does?

http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution#DependencyMediationandConflictResolution-DependencyVersionRanges

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/bfb660e5/attachment.html>

From eric.summers at me.com  Fri Jan 31 20:24:10 2014
From: eric.summers at me.com (Eric Summers)
Date: Fri, 31 Jan 2014 22:24:10 -0600
Subject: [rust-dev] "let mut" <-> "let !"
Message-ID: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>

I?m new to Rust (three days), but I thought the mut syntax felt odd in a few places.  Type definitions in particular because it is one of the few places that require padding.  Is there any reason a symbol isn?t used for mutability instead?  Forgive me if I?m too naive in Rust.

With a symbol you can drop the space:
fn drop(&mut self) { .. } <-> fn drop(&!self)

The only other common situation I've seen so for that require the space are lifetime annotations.  Maybe there is an alternate form for those?

The symbol could probably be extended to let:
let mut a = 0; <-> let !a = 0; <-> let a: !u32 = 0;
or maybe mutable setter;
let a := 0;

As other said, I think ?var' sugar feels against the design of the language.

-Eric




From pcwalton at mozilla.com  Fri Jan 31 20:27:06 2014
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 31 Jan 2014 20:27:06 -0800
Subject: [rust-dev] "let mut" <-> "let !"
In-Reply-To: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>
References: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>
Message-ID: <52EC779A.8060607@mozilla.com>

On 1/31/14 8:24 PM, Eric Summers wrote:
> I?m new to Rust (three days), but I thought the mut syntax felt odd in a few places.  Type definitions in particular because it is one of the few places that require padding.  Is there any reason a symbol isn?t used for mutability instead?  Forgive me if I?m too naive in Rust.
>
> With a symbol you can drop the space:
> fn drop(&mut self) { .. } <-> fn drop(&!self)
>
> The only other common situation I've seen so for that require the space are lifetime annotations.  Maybe there is an alternate form for those?
>
> The symbol could probably be extended to let:
> let mut a = 0; <-> let !a = 0; <-> let a: !u32 = 0;
> or maybe mutable setter;
> let a := 0;
>
> As other said, I think ?var' sugar feels against the design of the language.

     let !a = 0 is ambiguous with macros. (cf. `let! a = 0;`)

Patrick


From eric.summers at me.com  Fri Jan 31 20:35:57 2014
From: eric.summers at me.com (Eric Summers)
Date: Fri, 31 Jan 2014 22:35:57 -0600
Subject: [rust-dev] "let mut" <-> "let !"
In-Reply-To: <52EC779A.8060607@mozilla.com>
References: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>
	<52EC779A.8060607@mozilla.com>
Message-ID: <1CFF5DDA-3CAB-49C9-945E-0EA16C1CCB76@me.com>

> 
>    let !a = 0 is ambiguous with macros. (cf. `let! a = 0;`)
> 
> Patrick
> 


The symbol was hypothetical.  Maybe a different symbol or maybe only in types.  The let mut syntax didn?t look as strange to me.  The extra spaces in types felt a little more difficult to parse in my head while skimming code, but I?m sure I would get used to that.

-Eric

From eric.summers at me.com  Fri Jan 31 21:43:29 2014
From: eric.summers at me.com (Eric Summers)
Date: Fri, 31 Jan 2014 23:43:29 -0600
Subject: [rust-dev] "let mut" <-> "let !"
In-Reply-To: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>
References: <DDEBB34E-0890-4B12-8E26-84B271973D40@me.com>
Message-ID: <AC902532-A682-4856-9592-9F1D9DD71F57@me.com>


I realized my example didn?t make sense for pattern matching.

I think I like the mut syntax in let expressions, but I still like shoving the pointer next the type like I would do in C/C++ for something like fn drop(&mut self) {}.  

I guess it is somewhat rare to use mutable pointers as function parameters, so maybe not a big deal.

Sorry for extending the thread.

-Eric

From sean at seanmonstar.com  Fri Jan 31 13:11:50 2014
From: sean at seanmonstar.com (Sean McArthur)
Date: Fri, 31 Jan 2014 13:11:50 -0800
Subject: [rust-dev] Deprecating rustpkg
In-Reply-To: <CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
References: <52E7071A.50702@mozilla.com>
	<1391030003.16129.76945009.289252ED@webmail.messagingengine.com>
	<CAHOTMVKSVW8VYkhkjrQw3dP5iyXj17dPi7oe5RX21qTqs9Dxow@mail.gmail.com>
	<CADcg8=m4oHbKqpxu-nR_=7ty3CumgP=Gd4=jiScXe+QJ9xt=Ww@mail.gmail.com>
	<CAHOTMVKpQWmZ97wDfs-XGPyCOr-5BmFzm2RZ88iJYDA5ivrUyQ@mail.gmail.com>
	<CADcg8=nDAvQcijMUMHLWMoyo6h+2Wb8G9m8JsXM-_SUm=hn4KQ@mail.gmail.com>
	<CAHOTMVKEqMyWdnZMWKcqNh-NFRKHF=bfdRaR0ULZmOrnphfzJA@mail.gmail.com>
	<CA++BO6R433AoFqmG__9ENGmATWD7R8r3vAOG2CRZvyJ+gmJcPg@mail.gmail.com>
	<CAHOTMVLwb_0cG1Gyj7Pa-Bw=uPuH=eBxWX+1dhuxqSNPgrq_WA@mail.gmail.com>
	<52EAEDDB.4030402@active-4.com>
	<CAK9U+m2AkyDhatciGwaJYbZbiyROVZpxwge-nOU4V_2ZJJeRPA@mail.gmail.com>
	<CAHOTMV+a=M+yHGo0FwRTdH+FeJKqPAnt3uhYk39A9F52=6vScg@mail.gmail.com>
	<6734580107559889337@gmail297201516>
	<CAHOTMVLhJG+gRd=_UYhYAOShrJQAhh-WvFc7+xFBtkJDGzdguw@mail.gmail.com>
	<CACTPm537+cMThn1Nm27VWn-pMRgj7r01kVP1OX9Wj0mSCeswuA@mail.gmail.com>
	<CAHOTMV+0yVFyJ_t+KAy7dnSH5V7wCuEJSRAwvQSrKjLUcUMAJw@mail.gmail.com>
	<CACTPm51tM9SG28paw5944XHjXy78WS-nbajXFzNVE1f0AiAnOQ@mail.gmail.com>
	<CAHOTMV+7J8wfK-Xxv1mMHmj-HOc5OvO9jG=4ebA-Jcoj_EjnJA@mail.gmail.com>
Message-ID: <CAHrH6bP5uk58_m-OHQjfx1ovxSAUB8PZ8D7AoRJJuQBcoTPueg@mail.gmail.com>

On Fri, Jan 31, 2014 at 1:05 PM, Tony Arcieri <bascule at gmail.com> wrote:

> IMO, a system that respects semantic versioning, allows you to constrain
> the dependency to a particular *major* version without requiring pinning
> to a *specific* version.
>
> I would call anything that requires pinning to a specific version an
> antipattern. Among other things, pinning to specific versions precludes
> software updates which may be security-critical.
>
>
It's perfectly reasonable to require a certain *minor* version, since minor
versions (in semver) can include API additions that you may depend on.

Also, nodejs and npm supposedly support semver, but it's impossible to
enforce library authors actually do this, so you'll get libraries with
breaking changes going from 1.1.2 to 1.1.3 because reasons.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20140131/f15cae40/attachment.html>

