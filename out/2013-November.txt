From williamw520 at gmail.com  Fri Nov  1 03:02:20 2013
From: williamw520 at gmail.com (William Wong)
Date: Fri, 1 Nov 2013 03:02:20 -0700
Subject: [rust-dev] GZip and Deflate
Message-ID: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>

I wanted to add full compression support to Rust.  Full support means
stream compression (good for http compression) and multiple call
compression (compressing large file with multiple batches of read).  To get
to that point, the miniz.cpp and deflate API in Rust runtime need to be
enhanced to overcome a few limitations.

I've worked with the author of miniz.c (Rich Geldreich) to merge changes
into miniz.c on his codeline for the needed API for Rust, and resolved the
decompression bug in miniz's code when working with gzip'ed file.

http://code.google.com/p/miniz/issues/detail?id=25&can=1
http://code.google.com/p/miniz/issues/detail?id=23&can=1

I've implemented a full set of deflate API in Rust to support stream
compression and multiple call compression, with caller-driven and
callee-driven pipe style API.  Also I've written the Rust GZip library with
stream support like GZipReader and GZipWriter.  For testing, I've
re-implemented most of the gzip command line program on top of the Rust
GZip library.  Some performance data for the interested: Rust compression
is about 1.8 times slower, decompression is about 3 times slower than
gzip.  Overall it seems solid.  See
https://github.com/williamw520/rustyzipfor the source.

Now I need help to merge the changes into the Rust master codeline.  There
are couple things.

1. What license to assign for the new files?  I use MPL currently.
2. There's a new version of miniz.cpp needed for things to work.  Is the
Rust runtime still open for C++ file changes?
3. There are two new files for the deflate library (deflate.rs) and the
gzip library (gzip.rs).  Which Rust runtime library is the appropriate one
to put them in?
4. Should the command line tool rgzip stay in an outside codeline or be
merged into the Rust runtime?  If merging in, where is a good place for
tools?

Thanks

William
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/7be8eb46/attachment.html>

From ben.striegel at gmail.com  Fri Nov  1 08:40:18 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 1 Nov 2013 11:40:18 -0400
Subject: [rust-dev] GZip and Deflate
In-Reply-To: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
References: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
Message-ID: <CAAvrL-nzHeOnTsRP2ubSggrJpbjTCF0YtrJho8O3pHezxMwT4Q@mail.gmail.com>

I can't answer your questions, but I do want to say that this is very
interesting!

> Rust compression is about 1.8 times slower, decompression is about 3
times slower than gzip.

Have you tried profiling this to see where our bottlenecks are? It would be
great if we could use this as an opportunity to improve our performance.


On Fri, Nov 1, 2013 at 6:02 AM, William Wong <williamw520 at gmail.com> wrote:

> I wanted to add full compression support to Rust.  Full support means
> stream compression (good for http compression) and multiple call
> compression (compressing large file with multiple batches of read).  To get
> to that point, the miniz.cpp and deflate API in Rust runtime need to be
> enhanced to overcome a few limitations.
>
> I've worked with the author of miniz.c (Rich Geldreich) to merge changes
> into miniz.c on his codeline for the needed API for Rust, and resolved the
> decompression bug in miniz's code when working with gzip'ed file.
>
> http://code.google.com/p/miniz/issues/detail?id=25&can=1
> http://code.google.com/p/miniz/issues/detail?id=23&can=1
>
> I've implemented a full set of deflate API in Rust to support stream
> compression and multiple call compression, with caller-driven and
> callee-driven pipe style API.  Also I've written the Rust GZip library with
> stream support like GZipReader and GZipWriter.  For testing, I've
> re-implemented most of the gzip command line program on top of the Rust
> GZip library.  Some performance data for the interested: Rust compression
> is about 1.8 times slower, decompression is about 3 times slower than
> gzip.  Overall it seems solid.  See
> https://github.com/williamw520/rustyzip for the source.
>
> Now I need help to merge the changes into the Rust master codeline.  There
> are couple things.
>
> 1. What license to assign for the new files?  I use MPL currently.
> 2. There's a new version of miniz.cpp needed for things to work.  Is the
> Rust runtime still open for C++ file changes?
> 3. There are two new files for the deflate library (deflate.rs) and the
> gzip library (gzip.rs).  Which Rust runtime library is the appropriate
> one to put them in?
> 4. Should the command line tool rgzip stay in an outside codeline or be
> merged into the Rust runtime?  If merging in, where is a good place for
> tools?
>
> Thanks
>
> William
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/1cd5f001/attachment.html>

From pcwalton at mozilla.com  Fri Nov  1 09:14:26 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 01 Nov 2013 09:14:26 -0700
Subject: [rust-dev] GZip and Deflate
In-Reply-To: <CAAvrL-nzHeOnTsRP2ubSggrJpbjTCF0YtrJho8O3pHezxMwT4Q@mail.gmail.com>
References: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
	<CAAvrL-nzHeOnTsRP2ubSggrJpbjTCF0YtrJho8O3pHezxMwT4Q@mail.gmail.com>
Message-ID: <5273D362.8040908@mozilla.com>

On 11/1/13 8:40 AM, Benjamin Striegel wrote:
> I can't answer your questions, but I do want to say that this is very
> interesting!
>
>  > Rust compression is about 1.8 times slower, decompression is about 3
> times slower than gzip.
>
> Have you tried profiling this to see where our bottlenecks are? It would
> be great if we could use this as an opportunity to improve our performance.

It sounds like the problem is in miniz, so not in Rust code.

(BTW, compile times for small crates are very gated on decompression of 
metadata. Improvement of decompression speed improves compile times. 
Although maybe we should just switch to Snappy or something.)

Patrick


From loebel.marvin at gmail.com  Fri Nov  1 11:20:12 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Fri, 01 Nov 2013 19:20:12 +0100
Subject: [rust-dev] RFC about std::option and std::result API
Message-ID: <5273F0DC.4040702@gmail.com>

Hello everyone!

In the last week I've been trying to update both std::Result and 
std::Option's API
to match each other more, and I'd like to see the opinion of the 
community and the
Devs on a few areas it touches.

# Option today

The baseline here is Options current API, which roughly looks like this:

1. Methods for querying the variant
   - fn is_some(&self) -> bool
   - fn is_none(&self) -> bool

2. Adapter for working with references
   - fn as_ref<'r>(&'r self) -> Option<&'r T>
   - fn as_mut<'r>(&'r mut self) -> Option<&'r mut T>

3. Methods for getting to the contained value
   - fn expect(self, msg: &str) -> T
   - fn unwrap(self) -> T
   - fn unwrap_or(self, def: T) -> T
   - fn unwrap_or_else(self, f: &fn() -> T) -> T

4. Methods for transforming the contained value
   - fn map<U>(self, f: &fn(T) -> U) -> Option<U>
   - fn map_default<U>(self, def: U, f: &fn(T) -> U) -> U
   - fn mutate(&mut self, f: &fn(T) -> T) -> bool
   - fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool

5. Iterator constructors
   - fn iter<'r>(&'r self) -> OptionIterator<&'r T>
   - fn mut_iter<'r>(&'r mut self) -> OptionIterator<&'r mut T>
   - fn move_iter(self) -> OptionIterator<T>

6. Boolean-like operations on the values, eager and lazy
   - fn and<U>(self, optb: Option<U>) -> Option<U>
   - fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U>
   - fn or(self, optb: Option<T>) -> Option<T>
   - fn or_else(self, f: &fn() -> Option<T>) -> Option<T>

7. Other useful methods
   - fn take(&mut self) -> Option<T>
   - fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T>
   - fn while_some(self, blk: &fn(v: T) -> Option<T>)

8. Common special cases that are shorthand for chaining two other 
methods together.
   - fn take_unwrap(&mut self) -> T
   - fn get_ref<'a>(&'a self) -> &'a T
   - fn get_mut_ref<'a>(&'a mut self) -> &'a mut T

Based on this, I have a few areas of the API of both modules to discuss:

# Renaming `unwrap` to `get`

This is a known issue (https://github.com/mozilla/rust/issues/9784), and I
think we should just go through with it.
There are a few things that speak in favor for this:
- The name `unwrap` implies destruction of the original `Option`, which is
   not the case for implicitly copyable types, so it's a bad name.
- Ever since we got the reference adapters, Options primary
   usage is to take self by value, with `unwrap` being the main method for
   getting the value out of an Option.
   `get` is a shorter name than `unwrap`, so it would make using Option 
less painful.
- `Option` already has two shorthands for `.as_ref().unwrap()` and 
`as_mut().unwrap()`:
   `.get_ref()` and `.get_mut_ref`, so the name `get` has precedence in 
the current API.

# Renaming `map_default` and `mutate_default` to `map_or` and 
`mutate_or_set`

I can't find an issue for this, but I remember there being an informal 
agreement to
not use the `_default` prefix in methods unless they are related to the
`std::default::Default` trait, a confirmation of this would be nice.

The names `map_or` and `mutate_or_set` would fit in the current naming 
scheme.

# The problem with Result

Now, the big issue. Up until now, work on the result module tried to 
converge on
option's API, except adapted to work with Result.

For example, option has `fn or_else(self, f: &fn() -> Option<T>) -> 
Option<T>`
to evaluate a function in case of a `None` value, while result has
`pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F>`
to evaluate a function in case of an `Err` value.

However, while some of the operations are directly compatible with this 
approach,
most others require two methods each, one for the `Ok` and one for the 
`Err` variant:

- `fn unwrap(self) -> T` vs
   `fn unwrap_err(self) -> E`
- `fn expect(self, &str) -> T` vs
   `fn expect_err(self, &str) -> E`
- `fn map_default<U>(self, def: U, op: &fn(T) -> U) -> U` vs
   `fn map_err_default<F>(self, def: F, op: &fn(E) -> F) -> F`
- ... and many other methods in blocks 3, 4 and 5.

As you can see, this leads to API duplication twofold: All those methods
already exist on Option, and all those methods exist both for the `Ok` 
and the `Err`
variant.

This is not an Result-only issue: Every enum that is laid out like 
Result either
suffers the same kind of method duplication, or simply does not provide any,
instead requiring the user to match and manipulate them manually.

Examples would be `std::either::Either`, or 
`std::unstable::sync::UnsafeArcUnwrap`

To solve this problem, I'm proposing a convention for all enums that 
consist of
only newtype-like variants:

# Variant adapters for newtype variant enums

Basically, we should start the convention that every enum of the form

enum Foo<A, B, C, ...> {
     VariantA(A),
     VariantB(B),
     VariantC(C),
     ...
}

should implement two sets of methods:

1. Reference adapters for the type itself:
   - fn as_ref<'r>(&'r self) -> Foo<&'r A, &'r B, &'r C, ...>
   - fn as_mut<'r>(&'r mut self) -> Foo<&'r mut A, &'r mut B, &'r mut C, 
...>
2. Option adapters for each variant:
   - fn variant_a(self) -> Option<A>
   - fn variant_b(self) -> Option<B>
   - fn variant_c(self) -> Option<C>
   - ...

This would enable users to compose together any combination of any 
variant using
the option API, while still having full control over ownership with the 
by-ref adapters.

# Example

If we combine the proposal above with the two renamings, we get this:

- `res.unwrap_err()` becomes
   `res.err().get()`
- `res.expect("!")` becomes
   `res.ok().expect("!")`
- `res.expect_err("!")` becomes
   `res.err().expect("!")`
- `res.map_err_default(0, |a| a + 5)` becomes
   `res.err().map_or(0, |a| a + 5)`

As you can see, it becomes a bit more cumbersome to use, but not 
necessarily longer.
We can also do the same for `Result` as we do for `Option`: Keep frequently
used methods as a shortcut, even if they are expressible by combining a 
few other.

# Possible problems for Result specifically

There are two potential issues that get in the way with this approach:
- Because `ok()` throws away the `Err` variant, something like 
`unwrap()` can no longer
   print a useful error message. However, the shortcut implementations 
still could,
   and as they will probably be used the most this might not be a 
problem in practice.
- There was talk about making `Result` use an `~Error` trait object 
instead of a
   generic type `E`, which could invalidate most of this email.
   However, this could also just mean that you usually will see 
`Result<T, ~Error>`
   in the wild, for which this proposal still applies.
   Additionally, even if the Pattern becomes useless for Result, the problem
   still exists for any other newtype variant enums, so I'd like to see 
it get used
   anyway.

# Support for this pattern

Both reference adapters and variant Option adapters are fairly mechanically
implementations, so we could actually support their generation with an 
attribute
like `#[impl_enum_variant_accessors]`.

So, what are your thoughts about this? I think it would greatly increase 
composability of
enums in general and reduce the amount of boilerplate code. :)

Kimundi




From banderson at mozilla.com  Fri Nov  1 11:42:43 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 01 Nov 2013 11:42:43 -0700
Subject: [rust-dev] GZip and Deflate
In-Reply-To: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
References: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
Message-ID: <5273F623.5040502@mozilla.com>

On 11/01/2013 03:02 AM, William Wong wrote:
> I wanted to add full compression support to Rust.  Full support means 
> stream compression (good for http compression) and multiple call 
> compression (compressing large file with multiple batches of read).  
> To get to that point, the miniz.cpp and deflate API in Rust runtime 
> need to be enhanced to overcome a few limitations.
>
> I've worked with the author of miniz.c (Rich Geldreich) to merge 
> changes into miniz.c on his codeline for the needed API for Rust, and 
> resolved the decompression bug in miniz's code when working with 
> gzip'ed file.
>
> http://code.google.com/p/miniz/issues/detail?id=25&can=1
> http://code.google.com/p/miniz/issues/detail?id=23&can=1

Awesome!

>
> I've implemented a full set of deflate API in Rust to support stream 
> compression and multiple call compression, with caller-driven and  
> callee-driven pipe style API.  Also I've written the Rust GZip library 
> with stream support like GZipReader and GZipWriter.  For testing, I've 
> re-implemented most of the gzip command line program on top of the 
> Rust GZip library.  Some performance data for the interested: Rust 
> compression is about 1.8 times slower, decompression is about 3 times 
> slower than gzip.  Overall it seems solid.  See 
> https://github.com/williamw520/rustyzip for the source.

Even more awesome!

>
> Now I need help to merge the changes into the Rust master codeline.  
> There are couple things.
>
> 1. What license to assign for the new files?  I use MPL currently.

APL2/MIT dual license. Just copy the same headers that exist on all the 
other .rs files.

> 2. There's a new version of miniz.cpp needed for things to work.  Is 
> the Rust runtime still open for C++ file changes?

This change is fine.

> 3. There are two new files for the deflate library (deflate.rs 
> <http://deflate.rs>) and the gzip library (gzip.rs <http://gzip.rs>).  
> Which Rust runtime library is the appropriate one to put them in?

Replace extra::flate with these two.

> 4. Should the command line tool rgzip stay in an outside codeline or 
> be merged into the Rust runtime?  If merging in, where is a good place 
> for tools?

Not in mainline.

Note that libextra is slated to be broken up into a number of supported 
but external crates in the near future, and this will probably end up in 
its own crate. For now though I think the above strategy will work.

Regards,
Brian

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/619013be/attachment.html>

From banderson at mozilla.com  Fri Nov  1 11:44:33 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 01 Nov 2013 11:44:33 -0700
Subject: [rust-dev] GZip and Deflate
In-Reply-To: <5273F623.5040502@mozilla.com>
References: <CAMErtmEQ6qr8UuN2A9UJvjed3nnp9jj9tCENXkQQLw65b-82+w@mail.gmail.com>
	<5273F623.5040502@mozilla.com>
Message-ID: <5273F691.3060604@mozilla.com>

On 11/01/2013 11:42 AM, Brian Anderson wrote:
> On 11/01/2013 03:02 AM, William Wong wrote:
>> I wanted to add full compression support to Rust.  Full support means 
>> stream compression (good for http compression) and multiple call 
>> compression (compressing large file with multiple batches of read).  
>> To get to that point, the miniz.cpp and deflate API in Rust runtime 
>> need to be enhanced to overcome a few limitations.
>>
>> I've worked with the author of miniz.c (Rich Geldreich) to merge 
>> changes into miniz.c on his codeline for the needed API for Rust, and 
>> resolved the decompression bug in miniz's code when working with 
>> gzip'ed file.
>>
>> http://code.google.com/p/miniz/issues/detail?id=25&can=1
>> http://code.google.com/p/miniz/issues/detail?id=23&can=1
>
> Awesome!
>
>>
>> I've implemented a full set of deflate API in Rust to support stream 
>> compression and multiple call compression, with caller-driven and  
>> callee-driven pipe style API.  Also I've written the Rust GZip 
>> library with stream support like GZipReader and GZipWriter.  For 
>> testing, I've re-implemented most of the gzip command line program on 
>> top of the Rust GZip library.  Some performance data for the 
>> interested: Rust compression is about 1.8 times slower, decompression 
>> is about 3 times slower than gzip.  Overall it seems solid. See 
>> https://github.com/williamw520/rustyzip for the source.
>
> Even more awesome!
>
>>
>> Now I need help to merge the changes into the Rust master codeline.  
>> There are couple things.
>>
>> 1. What license to assign for the new files?  I use MPL currently.
>
> APL2/MIT dual license. Just copy the same headers that exist on all 
> the other .rs files.

Er, that's ASL2 (Apache License 2.0)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/c9db7b9e/attachment.html>

From banderson at mozilla.com  Fri Nov  1 12:22:44 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 01 Nov 2013 12:22:44 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273F0DC.4040702@gmail.com>
References: <5273F0DC.4040702@gmail.com>
Message-ID: <5273FF84.7050009@mozilla.com>

On 11/01/2013 11:20 AM, Marvin L?bel wrote:
> Hello everyone!
>
> In the last week I've been trying to update both std::Result and 
> std::Option's API
> to match each other more, and I'd like to see the opinion of the 
> community and the
> Devs on a few areas it touches.
>
> # Option today
>
> The baseline here is Options current API, which roughly looks like this:
>
> 1. Methods for querying the variant
>   - fn is_some(&self) -> bool
>   - fn is_none(&self) -> bool
>
> 2. Adapter for working with references
>   - fn as_ref<'r>(&'r self) -> Option<&'r T>
>   - fn as_mut<'r>(&'r mut self) -> Option<&'r mut T>
>
> 3. Methods for getting to the contained value
>   - fn expect(self, msg: &str) -> T
>   - fn unwrap(self) -> T
>   - fn unwrap_or(self, def: T) -> T
>   - fn unwrap_or_else(self, f: &fn() -> T) -> T
>
> 4. Methods for transforming the contained value
>   - fn map<U>(self, f: &fn(T) -> U) -> Option<U>
>   - fn map_default<U>(self, def: U, f: &fn(T) -> U) -> U
>   - fn mutate(&mut self, f: &fn(T) -> T) -> bool
>   - fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool
>
> 5. Iterator constructors
>   - fn iter<'r>(&'r self) -> OptionIterator<&'r T>
>   - fn mut_iter<'r>(&'r mut self) -> OptionIterator<&'r mut T>
>   - fn move_iter(self) -> OptionIterator<T>
>
> 6. Boolean-like operations on the values, eager and lazy
>   - fn and<U>(self, optb: Option<U>) -> Option<U>
>   - fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U>
>   - fn or(self, optb: Option<T>) -> Option<T>
>   - fn or_else(self, f: &fn() -> Option<T>) -> Option<T>
>
> 7. Other useful methods
>   - fn take(&mut self) -> Option<T>
>   - fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T>
>   - fn while_some(self, blk: &fn(v: T) -> Option<T>)
>
> 8. Common special cases that are shorthand for chaining two other 
> methods together.
>   - fn take_unwrap(&mut self) -> T
>   - fn get_ref<'a>(&'a self) -> &'a T
>   - fn get_mut_ref<'a>(&'a mut self) -> &'a mut T
>
> Based on this, I have a few areas of the API of both modules to discuss:
>
> # Renaming `unwrap` to `get`
>
> This is a known issue (https://github.com/mozilla/rust/issues/9784), 
> and I
> think we should just go through with it.
> There are a few things that speak in favor for this:
> - The name `unwrap` implies destruction of the original `Option`, 
> which is
>   not the case for implicitly copyable types, so it's a bad name.
> - Ever since we got the reference adapters, Options primary
>   usage is to take self by value, with `unwrap` being the main method for
>   getting the value out of an Option.
>   `get` is a shorter name than `unwrap`, so it would make using Option 
> less painful.
> - `Option` already has two shorthands for `.as_ref().unwrap()` and 
> `as_mut().unwrap()`:
>   `.get_ref()` and `.get_mut_ref`, so the name `get` has precedence in 
> the current API.


I think this (consistency) is the best argument in favor, though I do 
love how evocative the word 'unwrap' is. I will not argue against this 
change.


>
> # Renaming `map_default` and `mutate_default` to `map_or` and 
> `mutate_or_set`
>
> I can't find an issue for this, but I remember there being an informal 
> agreement to
> not use the `_default` prefix in methods unless they are related to the
> `std::default::Default` trait, a confirmation of this would be nice.
>
> The names `map_or` and `mutate_or_set` would fit in the current naming 
> scheme.

Your reasoning makes sense, and this seems to be consistent with other 
names.

>
> # The problem with Result
>
> Now, the big issue. Up until now, work on the result module tried to 
> converge on
> option's API, except adapted to work with Result.
>
> For example, option has `fn or_else(self, f: &fn() -> Option<T>) -> 
> Option<T>`
> to evaluate a function in case of a `None` value, while result has
> `pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F>`
> to evaluate a function in case of an `Err` value.
>
> However, while some of the operations are directly compatible with 
> this approach,
> most others require two methods each, one for the `Ok` and one for the 
> `Err` variant:
>
> - `fn unwrap(self) -> T` vs
>   `fn unwrap_err(self) -> E`
> - `fn expect(self, &str) -> T` vs
>   `fn expect_err(self, &str) -> E`
> - `fn map_default<U>(self, def: U, op: &fn(T) -> U) -> U` vs
>   `fn map_err_default<F>(self, def: F, op: &fn(E) -> F) -> F`
> - ... and many other methods in blocks 3, 4 and 5.
>
> As you can see, this leads to API duplication twofold: All those methods
> already exist on Option, and all those methods exist both for the `Ok` 
> and the `Err`
> variant.
>
> This is not an Result-only issue: Every enum that is laid out like 
> Result either
> suffers the same kind of method duplication, or simply does not 
> provide any,
> instead requiring the user to match and manipulate them manually.
>
> Examples would be `std::either::Either`, or 
> `std::unstable::sync::UnsafeArcUnwrap`
>
> To solve this problem, I'm proposing a convention for all enums that 
> consist of
> only newtype-like variants:
>
> # Variant adapters for newtype variant enums
>
> Basically, we should start the convention that every enum of the form
>
> enum Foo<A, B, C, ...> {
>     VariantA(A),
>     VariantB(B),
>     VariantC(C),
>     ...
> }
>
> should implement two sets of methods:
>
> 1. Reference adapters for the type itself:
>   - fn as_ref<'r>(&'r self) -> Foo<&'r A, &'r B, &'r C, ...>
>   - fn as_mut<'r>(&'r mut self) -> Foo<&'r mut A, &'r mut B, &'r mut 
> C, ...>
> 2. Option adapters for each variant:
>   - fn variant_a(self) -> Option<A>
>   - fn variant_b(self) -> Option<B>
>   - fn variant_c(self) -> Option<C>
>   - ...
>
> This would enable users to compose together any combination of any 
> variant using
> the option API, while still having full control over ownership with 
> the by-ref adapters.
>
> # Example
>
> If we combine the proposal above with the two renamings, we get this:
>
> - `res.unwrap_err()` becomes
>   `res.err().get()`
> - `res.expect("!")` becomes
>   `res.ok().expect("!")`
> - `res.expect_err("!")` becomes
>   `res.err().expect("!")`
> - `res.map_err_default(0, |a| a + 5)` becomes
>   `res.err().map_or(0, |a| a + 5)`
>
> As you can see, it becomes a bit more cumbersome to use, but not 
> necessarily longer.
> We can also do the same for `Result` as we do for `Option`: Keep 
> frequently
> used methods as a shortcut, even if they are expressible by combining 
> a few other.

My first reaction is that it's not obvious the difference between 
`is_ok` and `ok`. Also, it would seem that `ok()` is required to return 
a different type to make this work, which seems fairly burdensome. If it 
*is* required to return a different type, then the obvious thing to do 
is just transform it into `Option<T>` which is fairly nice since it just 
defers the problem to `Option` completely.

>
> # Possible problems for Result specifically
>
> There are two potential issues that get in the way with this approach:
> - Because `ok()` throws away the `Err` variant, something like 
> `unwrap()` can no longer
>   print a useful error message. However, the shortcut implementations 
> still could,
>   and as they will probably be used the most this might not be a 
> problem in practice.
> - There was talk about making `Result` use an `~Error` trait object 
> instead of a
>   generic type `E`, which could invalidate most of this email.
>   However, this could also just mean that you usually will see 
> `Result<T, ~Error>`
>   in the wild, for which this proposal still applies.
>   Additionally, even if the Pattern becomes useless for Result, the 
> problem
>   still exists for any other newtype variant enums, so I'd like to see 
> it get used
>   anyway.
>
> # Support for this pattern
>
> Both reference adapters and variant Option adapters are fairly 
> mechanically
> implementations, so we could actually support their generation with an 
> attribute
> like `#[impl_enum_variant_accessors]`.
>
> So, what are your thoughts about this? I think it would greatly 
> increase composability of
> enums in general and reduce the amount of boilerplate code. :)

My first thought is unrelated: it would be awesome if we had a lint mode 
that detected methods like `get`, `get_ref`, etc. - all these common 
patterns - and confirmed that their result type looked like what we 
expect. We could apply this to all the official libraries to try to stay 
consistent.

From pcwalton at mozilla.com  Fri Nov  1 12:29:30 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 01 Nov 2013 12:29:30 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273FF84.7050009@mozilla.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
Message-ID: <5274011A.2080408@mozilla.com>

On 11/1/13 12:22 PM, Brian Anderson wrote:
> I think this (consistency) is the best argument in favor, though I do
> love how evocative the word 'unwrap' is. I will not argue against this
> change.

I prefer `get` too. I find the argument that `unwrap` doesn't always 
move to be persuasive.

Patrick


From alex at crichton.co  Fri Nov  1 12:30:00 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 1 Nov 2013 12:30:00 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273F0DC.4040702@gmail.com>
References: <5273F0DC.4040702@gmail.com>
Message-ID: <CAFnh-mf0--gfX=j-M__vqOP1Y8b1ON55DsHy1YYBO3Diu8EcaA@mail.gmail.com>

> # Renaming `unwrap` to `get`

I would personally find this change a little odd because we still have
a large number of `unwrap` methods thorughout the codebase. Most of
these do indeed imply destruction of the enclosing type. A change like
this would mean that when you decide to write your unwrapping method
you must internally think about whether this always implies that the
outer type would be destroyed or not. In my opinion, unwrap() on
Option<int> does exactly what it should and it's just a bug vs state
of mind kind of thing. I would rather strive for consistency across
all APIs than have a special case based on whether the type just
happens to not be destroyed because the whole thing is implicitly
copyable.

From williamw520 at gmail.com  Fri Nov  1 12:49:06 2013
From: williamw520 at gmail.com (William Wong)
Date: Fri, 1 Nov 2013 12:49:06 -0700
Subject: [rust-dev] GZip and Deflate
Message-ID: <CAMErtmGKpB57u34hd63wjrA6DmHb4ONi4CTHP2iLDCPsdKJ0eg@mail.gmail.com>

Date: Fri, 1 Nov 2013 11:40:18 -0400

> From: Benjamin Striegel <ben.striegel at gmail.com>
> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: Re: [rust-dev] GZip and Deflate
> Message-ID:
>         <
> CAAvrL-nzHeOnTsRP2ubSggrJpbjTCF0YtrJho8O3pHezxMwT4Q at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> I can't answer your questions, but I do want to say that this is very
> interesting!
>
> > Rust compression is about 1.8 times slower, decompression is about 3
> times slower than gzip.
>
> Have you tried profiling this to see where our bottlenecks are? It would be
> great if we could use this as an opportunity to improve our performance.
>
>
I haven't profiled the code yet; will get to it once I get some time.  The
first priority was just to get things working correctly; there were some
tricky edge cases on some large files with different sizes.  They had been
flushed out and fixed.

Without profiling, it's uncertain to see where the bottlenecks are.  The
CPU was max'ed out so I suspect it's the compression code rather than the
IO code.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/a6a54adc/attachment.html>

From bjzaba at yahoo.com.au  Fri Nov  1 12:49:19 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 2 Nov 2013 06:49:19 +1100
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273FF84.7050009@mozilla.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
Message-ID: <553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>

> My first thought is unrelated: it would be awesome if we had a lint mode that detected methods like `get`, `get_ref`, etc. - all these common patterns - and confirmed that their result type looked like what we expect. We could apply this to all the official libraries to try to stay consistent.

This could help to ensure that our APIs could remain reasonably intact through a transition to higher kinded types.

~Brendan

From loebel.marvin at gmail.com  Fri Nov  1 12:59:34 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Fri, 01 Nov 2013 20:59:34 +0100
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273FF84.7050009@mozilla.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
Message-ID: <52740826.7090702@gmail.com>

On 11/01/2013 08:22 PM, Brian Anderson wrote:
> My first reaction is that it's not obvious the difference between 
> `is_ok` and `ok`. Also, it would seem that `ok()` is required to 
> return a different type to make this work, which seems fairly 
> burdensome. If it *is* required to return a different type, then the 
> obvious thing to do is just transform it into `Option<T>` which is 
> fairly nice since it just defers the problem to `Option` completely. 
The idea is that for example for `res: Result<T, E>`, `res.ok()` returns 
`Option<T>` and `res.err()` returns `Option<E>`. So yes, it would just 
defer to Option.

About the difference between `is_ok` and `ok` - fair enough. However I 
think the only way to make this more clear is to rename `ok()` and 
`err()` to something longer, which would make the chaining more verbose 
and has the problem that all short words that would fit are already 
heavily overloaded in rust terminology:
- `as_ok()` and `as_err()`
- `to_ok()` and `to_err()`
- `get_ok()` and `get_err()`
- `ok_get()` and `err_get()`

Maybe a abbreviation of variant would work:

- `ok_var()` and `err_var()`

Seems to read nice at least:

~~~
res.ok_var().get();
res.err_var().get();
res.err_var().expect("...");
~~~

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/2c35a4c0/attachment-0001.html>

From williamw520 at gmail.com  Fri Nov  1 13:01:26 2013
From: williamw520 at gmail.com (William Wong)
Date: Fri, 1 Nov 2013 13:01:26 -0700
Subject: [rust-dev] (no subject)
Message-ID: <CAMErtmFE4CLqRYJdds1g2xZgzT9G1Y-H38kt8uk0Sm+RfbAA8A@mail.gmail.com>

Date: Fri, 01 Nov 2013 09:14:26 -0700

> From: Patrick Walton <pcwalton at mozilla.com>
> To: rust-dev at mozilla.org
> Subject: Re: [rust-dev] GZip and Deflate
> Message-ID: <5273D362.8040908 at mozilla.com>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> On 11/1/13 8:40 AM, Benjamin Striegel wrote:
> > I can't answer your questions, but I do want to say that this is very
> > interesting!
> >
> >  > Rust compression is about 1.8 times slower, decompression is about 3
> > times slower than gzip.
> >
> > Have you tried profiling this to see where our bottlenecks are? It would
> > be great if we could use this as an opportunity to improve our
> performance.
>
> It sounds like the problem is in miniz, so not in Rust code.
>
> (BTW, compile times for small crates are very gated on decompression of
> metadata. Improvement of decompression speed improves compile times.
> Although maybe we should just switch to Snappy or something.)
>
> Patrick
>
>
I suspect that's the case but without profiling it's difficult to pinpoint
the bottleneck.

Snappy looks interesting.  I'll look into it later when I get some times.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/e9b142a5/attachment.html>

From williamw520 at gmail.com  Fri Nov  1 13:04:32 2013
From: williamw520 at gmail.com (William Wong)
Date: Fri, 1 Nov 2013 13:04:32 -0700
Subject: [rust-dev] GZip and Deflate
Message-ID: <CAMErtmGct8Jn1uSvWSQfxeeK_Ln96VMn3sde5xNCY939R_6pWQ@mail.gmail.com>

> From: Brian Anderson <banderson at mozilla.com>
> To: rust-dev at mozilla.org
> Subject: Re: [rust-dev] GZip and Deflate
> Message-ID: <5273F691.3060604 at mozilla.com>
> Content-Type: text/plain; charset="iso-8859-1"; Format="flowed"
>
> >> 1. What license to assign for the new files?  I use MPL currently.
> >
> > APL2/MIT dual license. Just copy the same headers that exist on all
> > the other .rs files.
>
> Er, that's ASL2 (Apache License 2.0)
>

 That's great.  Thanks.  I'll use that.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/0db999d6/attachment.html>

From loebel.marvin at gmail.com  Fri Nov  1 13:26:20 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Fri, 01 Nov 2013 21:26:20 +0100
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <CAFnh-mf0--gfX=j-M__vqOP1Y8b1ON55DsHy1YYBO3Diu8EcaA@mail.gmail.com>
References: <5273F0DC.4040702@gmail.com>
	<CAFnh-mf0--gfX=j-M__vqOP1Y8b1ON55DsHy1YYBO3Diu8EcaA@mail.gmail.com>
Message-ID: <52740E6C.9000906@gmail.com>

On 11/01/2013 08:30 PM, Alex Crichton wrote:
>> # Renaming `unwrap` to `get`
> I would personally find this change a little odd because we still have
> a large number of `unwrap` methods thorughout the codebase. Most of
> these do indeed imply destruction of the enclosing type. A change like
> this would mean that when you decide to write your unwrapping method
> you must internally think about whether this always implies that the
> outer type would be destroyed or not. In my opinion, unwrap() on
> Option<int> does exactly what it should and it's just a bug vs state
> of mind kind of thing. I would rather strive for consistency across
> all APIs than have a special case based on whether the type just
> happens to not be destroyed because the whole thing is implicitly
> copyable.
Imo we still keep consistency even with this rename. `get` is simply the 
more general term which we'd use for generic situations where we don't 
know anything about the type, while specific implementations can choose 
either name depending on situation.

I think it's more useful to say "use the name unwrap if the function 
does something non-trivial". For example, `ARC::unwrap()` should 
probably not be renamed to `get` because it can block the task.

From thadguidry at gmail.com  Fri Nov  1 14:24:51 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Fri, 1 Nov 2013 16:24:51 -0500
Subject: [rust-dev] (no subject)
In-Reply-To: <CAMErtmFE4CLqRYJdds1g2xZgzT9G1Y-H38kt8uk0Sm+RfbAA8A@mail.gmail.com>
References: <CAMErtmFE4CLqRYJdds1g2xZgzT9G1Y-H38kt8uk0Sm+RfbAA8A@mail.gmail.com>
Message-ID: <CAChbWaPTSaisTByo7=C+x12ff0jomth7rqujPW1jJdY6ycfn0A@mail.gmail.com>

For my data experiments, I would rather like to see an LZ4 implementation
https://code.google.com/p/lz4/  (a lossless, very, very, very, very, very,
very, very, very fast decompression, with same compression - the very's are
dependent on how many cpu cores you have :-) ) and it's BSD licensed.

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/20082608/attachment.html>

From kevin at sb.org  Fri Nov  1 21:17:05 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 1 Nov 2013 21:17:05 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <52740826.7090702@gmail.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
	<52740826.7090702@gmail.com>
Message-ID: <36BEDF4E-24FF-4ED9-BC7B-36A6FFC29A7A@sb.org>


On Nov 1, 2013, at 12:59 PM, Marvin L?bel <loebel.marvin at gmail.com> wrote:

> Maybe a abbreviation of variant would work:
> 
> - `ok_var()` and `err_var()`
> 
> Seems to read nice at least:
> 
> ~~~
> res.ok_var().get();
> res.err_var().get();
> res.err_var().expect("...");
> ~~~

"var" here makes me think "variable".

My two cents says go with `res.ok().get()` and `res.err().get()`. It's unfortunate that `ok()` can be read as if it were `is_ok()`, but I think people will get used to it pretty fast.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/f0f682bc/attachment.html>

From me at kevincantu.org  Fri Nov  1 21:33:33 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Fri, 1 Nov 2013 21:33:33 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
	<553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>
Message-ID: <CABq6+ac25i9PY2qvdNhpkGij0EWvy7Bcbyje4dzz+-Ao81ixDA@mail.gmail.com>

Yeah, many of the overlaps between these APIs should or could be expressed
as additional traits...

-- Kevin
On Nov 1, 2013 12:49 PM, "Brendan Zabarauskas" <bjzaba at yahoo.com.au> wrote:

> > My first thought is unrelated: it would be awesome if we had a lint mode
> that detected methods like `get`, `get_ref`, etc. - all these common
> patterns - and confirmed that their result type looked like what we expect.
> We could apply this to all the official libraries to try to stay consistent.
>
> This could help to ensure that our APIs could remain reasonably intact
> through a transition to higher kinded types.
>
> ~Brendan
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131101/f2c02762/attachment-0001.html>

From steve at steveklabnik.com  Fri Nov  1 23:02:15 2013
From: steve at steveklabnik.com (Steve Klabnik)
Date: Fri, 1 Nov 2013 23:02:15 -0700
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <CABq6+ac25i9PY2qvdNhpkGij0EWvy7Bcbyje4dzz+-Ao81ixDA@mail.gmail.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
	<553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>
	<CABq6+ac25i9PY2qvdNhpkGij0EWvy7Bcbyje4dzz+-Ao81ixDA@mail.gmail.com>
Message-ID: <29443F7B-1D05-451F-9259-25EE5047755D@steveklabnik.com>

Would a ruby-style ok?/ok work to replace is_ok/ok    ?

From oren at ben-kiki.org  Sat Nov  2 00:40:14 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 2 Nov 2013 09:40:14 +0200
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <29443F7B-1D05-451F-9259-25EE5047755D@steveklabnik.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
	<553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>
	<CABq6+ac25i9PY2qvdNhpkGij0EWvy7Bcbyje4dzz+-Ao81ixDA@mail.gmail.com>
	<29443F7B-1D05-451F-9259-25EE5047755D@steveklabnik.com>
Message-ID: <CADJiDhtDqAWoaH0fsN-PfvPdOkf_FPZNG-pTB=xk2yQfeFLvFw@mail.gmail.com>

I would love it if '?' was allowed at the end of any identifier, to make it
natural to name boolean variables, methods, constants, etc. Having to say
is_xxx is ugly IMO. A lint option ensuring this is only applied to boolean
typed constructs could help reduce abuse, if this is seen as an issue.
On Nov 2, 2013 8:02 AM, "Steve Klabnik" <steve at steveklabnik.com> wrote:

> Would a ruby-style ok?/ok work to replace is_ok/ok    ?
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/e45de659/attachment.html>

From andres.osinski at gmail.com  Sat Nov  2 05:38:55 2013
From: andres.osinski at gmail.com (Andres Osinski)
Date: Sat, 2 Nov 2013 10:38:55 -0200
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <CADJiDhtDqAWoaH0fsN-PfvPdOkf_FPZNG-pTB=xk2yQfeFLvFw@mail.gmail.com>
References: <5273F0DC.4040702@gmail.com> <5273FF84.7050009@mozilla.com>
	<553FA180-9ACB-460F-8DBB-5039BE8DC216@yahoo.com.au>
	<CABq6+ac25i9PY2qvdNhpkGij0EWvy7Bcbyje4dzz+-Ao81ixDA@mail.gmail.com>
	<29443F7B-1D05-451F-9259-25EE5047755D@steveklabnik.com>
	<CADJiDhtDqAWoaH0fsN-PfvPdOkf_FPZNG-pTB=xk2yQfeFLvFw@mail.gmail.com>
Message-ID: <CA+xF-PyEVPXN2bYewi3_rXV5n3g8wzZHHbBOMxVoE8-1JPR3Zw@mail.gmail.com>

A '?' suffix for boolean methods would be fantastic.

On Sat, Nov 2, 2013 at 4:40 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> I would love it if '?' was allowed at the end of any identifier, to make it
> natural to name boolean variables, methods, constants, etc. Having to say
> is_xxx is ugly IMO. A lint option ensuring this is only applied to boolean
> typed constructs could help reduce abuse, if this is seen as an issue.
>
> On Nov 2, 2013 8:02 AM, "Steve Klabnik" <steve at steveklabnik.com> wrote:
>>
>> Would a ruby-style ok?/ok work to replace is_ok/ok    ?
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Andr?s Osinski
http://www.andresosinski.com.ar/

From niko at alum.mit.edu  Sat Nov  2 08:34:57 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 2 Nov 2013 11:34:57 -0400
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273F0DC.4040702@gmail.com>
References: <5273F0DC.4040702@gmail.com>
Message-ID: <20131102153457.GE1305@Mr-Bennet>

I am generally in favor of this proposal. It seems to be a reasonable
way forward. It is unclear to me how many types would benefit from
this approach of having methods for each variant, but `Result`
certainly does.

With respect to possible confusion between `is_ok()` and `ok()` -- I
think that the presence of a boolean return type should help with
that. (That is, if you write `if foo.ok() { ... }` the compiler will
catch it readily enough)

Some of the methods on `Result`, however, can't be implemented in
terms of this approach. For example, `chain` and `chain_err` really
need to keep the `Result` return type. But I guess that's clear
enough.

One specific comment on your message:

> - There was talk about making `Result` use an `~Error` trait object
> instead of a generic type `E`, which could invalidate most of this
> email.  However, this could also just mean that you usually will see
> `Result<T, ~Error>` in the wild, for which this proposal still
> applies.  Additionally, even if the Pattern becomes useless for
> Result, the problem still exists for any other newtype variant
> enums, so I'd like to see it get used anyway.

It is not clear to me why moving to a `~Error` object would have
any effect on this proposal. `err()` would just return `Option<~Error>`
in that case, right?


Niko

From astrieanna at gmail.com  Sat Nov  2 12:10:34 2013
From: astrieanna at gmail.com (Leah Hanson)
Date: Sat, 2 Nov 2013 15:10:34 -0400
Subject: [rust-dev] How would you map one vector to a vector of a different
	element type?
Message-ID: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>

Hi,

I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.

I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just want
to be able to iterate over the Ports later.)

Since I'm not sure what looping construct to use, I tried with a for-each
loop.

~~~
let ports = for s in myvect.iter() {
          let (pport, cchan) = stream();
          do spawn {
            cchan.send(fun(*s))
          }
          pport
        };
~~~

As you  might, expect I got an error:
error: mismatched types: expected `()` but found `std::comm::Port<uint>`
(expected () but found struct std::comm::Port)

>From this, I take it that for loops must return `()`, rather than an actual
value. When I searched for a map function in the documentation, I only
found a Map type.

How would you map one vector to a vector of a different element type?

Thanks,
Leah
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/440a085e/attachment.html>

From bytbox at gmail.com  Sat Nov  2 12:23:30 2013
From: bytbox at gmail.com (Scott Lawrence)
Date: Sat, 2 Nov 2013 15:23:30 -0400 (EDT)
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
Message-ID: <alpine.LNX.2.03.1311021522260.866@localhost.localdomain>

I would think:

let ports = do myvect.iter().map { |e| something(e) }

On Sat, 2 Nov 2013, Leah Hanson wrote:

> Hi,
>
> I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.
>
> I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just want
> to be able to iterate over the Ports later.)
>
> Since I'm not sure what looping construct to use, I tried with a for-each
> loop.
>
> ~~~
> let ports = for s in myvect.iter() {
>          let (pport, cchan) = stream();
>          do spawn {
>            cchan.send(fun(*s))
>          }
>          pport
>        };
> ~~~
>
> As you  might, expect I got an error:
> error: mismatched types: expected `()` but found `std::comm::Port<uint>`
> (expected () but found struct std::comm::Port)
>
>> From this, I take it that for loops must return `()`, rather than an actual
> value. When I searched for a map function in the documentation, I only
> found a Map type.
>
> How would you map one vector to a vector of a different element type?
>
> Thanks,
> Leah
>

-- 
Scott Lawrence

From astrieanna at gmail.com  Sat Nov  2 13:04:24 2013
From: astrieanna at gmail.com (Leah Hanson)
Date: Sat, 2 Nov 2013 16:04:24 -0400
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
Message-ID: <CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>

Thanks, Scott, I think that's closer.

However, now I'm having trouble with my pointer types. Using the element
inside a spawn means that I need to capture the owned string in the right
way so that the compiler allows me to give it to the other task.

This version:
~~~
let ports = do myvect.iter().map |s| {
          let (pport, cchan) = stream();
          do spawn {
            cchan.send(fun(*s))
          }
          pport
        };
~~~
gives me pointer-type related errors:

   - error: cannot move out of dereference of & pointer
      - cchan.send(fun(*s))
   - error: cannot borrow immutable local variable as mutable
   - when I iterate over the Ports later
   - error: cannot capture variable of type `&~str`, which does not fulfill
   `Send`, in a bounded closure
   - cchan.send(fun(*s))

I also tried a version with |&s| and cchan.send(fun(s)), which gave me
different errors:

   - error: cannot move out of captured outer variable in a heap closure
   - cchan.send(fun(*s))
   - error: cannot move out of dereference of & pointer
   - on the |&s|
   - error: cannot borrow immutable local variable as mutable
   - when I iterate over the Ports later


I'm very new to Rust. What do I need to do to let the compiler know that
I'm not going to use anything in the first vec anymore? That I just want
the ~str pointers directly?

(I put the |s| outside the {} because putting it inside seemed to confuse
things -- in that case, rustc expected an identifier instead of the `let`
that comes next, so I assumed that `do v.iter().map {|s| ...}` is a syntax
error.)

Thanks,
Leah




On Sat, Nov 2, 2013 at 3:23 PM, Scott Lawrence <bytbox at gmail.com> wrote:

> I would think:
>
> let ports = do myvect.iter().map { |e| something(e) }
>
>
> On Sat, 2 Nov 2013, Leah Hanson wrote:
>
>  Hi,
>>
>> I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.
>>
>> I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just want
>> to be able to iterate over the Ports later.)
>>
>> Since I'm not sure what looping construct to use, I tried with a for-each
>> loop.
>>
>> ~~~
>> let ports = for s in myvect.iter() {
>>          let (pport, cchan) = stream();
>>          do spawn {
>>            cchan.send(fun(*s))
>>          }
>>          pport
>>        };
>> ~~~
>>
>> As you  might, expect I got an error:
>> error: mismatched types: expected `()` but found `std::comm::Port<uint>`
>> (expected () but found struct std::comm::Port)
>>
>>  From this, I take it that for loops must return `()`, rather than an
>>> actual
>>>
>> value. When I searched for a map function in the documentation, I only
>> found a Map type.
>>
>> How would you map one vector to a vector of a different element type?
>>
>> Thanks,
>> Leah
>>
>>
> --
> Scott Lawrence
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/064033e6/attachment.html>

From bjzaba at yahoo.com.au  Sat Nov  2 13:24:10 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sun, 3 Nov 2013 07:24:10 +1100
Subject: [rust-dev] How would you map one vector to a vector of a
	different element type?
In-Reply-To: <CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
	<CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>
Message-ID: <1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>

You?re trying to move the ~strs out of the vector. You?ll need to use `move_iter`:

~~~
let ports = do myvect.move_iter().map |s| {
    let (pport, cchan) = stream();
    do spawn {
        cchan.send(fun(s))
    }
    pport
}.to_owned_vec();
~~~

Also note the use of `to_owned_vec`. `map` lazily returns a `Map` iterator - you need to explicitly drain it.

(Note I haven?t tried compiling this)

~Brendan

On 3 Nov 2013, at 7:04 am, Leah Hanson <astrieanna at gmail.com> wrote:

> Thanks, Scott, I think that's closer.
> 
> However, now I'm having trouble with my pointer types. Using the element inside a spawn means that I need to capture the owned string in the right way so that the compiler allows me to give it to the other task.
> 
> This version:
> ~~~
> let ports = do myvect.iter().map |s| {
>           let (pport, cchan) = stream();
>           do spawn {
>             cchan.send(fun(*s))
>           }
>           pport
>         };
> ~~~
> gives me pointer-type related errors:
> 	? error: cannot move out of dereference of & pointer
> 		? cchan.send(fun(*s))
> 	? error: cannot borrow immutable local variable as mutable
> 		? when I iterate over the Ports later
> 	? error: cannot capture variable of type `&~str`, which does not fulfill `Send`, in a bounded closure
> 		? cchan.send(fun(*s))
> I also tried a version with |&s| and cchan.send(fun(s)), which gave me different errors:
> 	? error: cannot move out of captured outer variable in a heap closure
> 		? cchan.send(fun(*s))
> 	? error: cannot move out of dereference of & pointer
> 		? on the |&s|
> 	? error: cannot borrow immutable local variable as mutable
> 		? when I iterate over the Ports later
> 
> I'm very new to Rust. What do I need to do to let the compiler know that I'm not going to use anything in the first vec anymore? That I just want the ~str pointers directly?
> 
> (I put the |s| outside the {} because putting it inside seemed to confuse things -- in that case, rustc expected an identifier instead of the `let` that comes next, so I assumed that `do v.iter().map {|s| ...}` is a syntax error.)
> 
> Thanks,
> Leah
> 
> 
> 
> 
> On Sat, Nov 2, 2013 at 3:23 PM, Scott Lawrence <bytbox at gmail.com> wrote:
> I would think:
> 
> let ports = do myvect.iter().map { |e| something(e) }
> 
> 
> On Sat, 2 Nov 2013, Leah Hanson wrote:
> 
> Hi,
> 
> I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.
> 
> I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just want
> to be able to iterate over the Ports later.)
> 
> Since I'm not sure what looping construct to use, I tried with a for-each
> loop.
> 
> ~~~
> let ports = for s in myvect.iter() {
>          let (pport, cchan) = stream();
>          do spawn {
>            cchan.send(fun(*s))
>          }
>          pport
>        };
> ~~~
> 
> As you  might, expect I got an error:
> error: mismatched types: expected `()` but found `std::comm::Port<uint>`
> (expected () but found struct std::comm::Port)
> 
> From this, I take it that for loops must return `()`, rather than an actual
> value. When I searched for a map function in the documentation, I only
> found a Map type.
> 
> How would you map one vector to a vector of a different element type?
> 
> Thanks,
> Leah
> 
> 
> -- 
> Scott Lawrence
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From astrieanna at gmail.com  Sat Nov  2 14:05:05 2013
From: astrieanna at gmail.com (Leah Hanson)
Date: Sat, 2 Nov 2013 17:05:05 -0400
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
	<CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>
	<1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>
Message-ID: <CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>

Thanks, Brendan. :)

You?re trying to move the ~strs out of the vector. You?ll need to use
> `move_iter`:
>
Is this "moving" about moving memory around or about promising the compiler
that I won't use those elements of the vector again?


> ~~~
> let ports = do myvect.move_iter().map |s| {
>     let (pport, cchan) = stream();
>     do spawn {
>         cchan.send(fun(s))
>     }
>     pport
> }.to_owned_vec();
>

There is still a problem because something (I guess the `do spawn {...}`)
is a "heap closure".

   - error: cannot move out of captured outer variable in a heap closure
      - cchan.send(fun(s))

I think that this error message is complaining because I'm trying to move
s, the ~str that the `do spawn {...}` closes over, to a new task.
And I'm not allowed to move it because it is apparently a heap closure.
Is there some other kind of closure that does work here? Or some way to
make this not a closure?

Thanks,
Leah



On Sat, Nov 2, 2013 at 4:24 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:

> You?re trying to move the ~strs out of the vector. You?ll need to use
> `move_iter`:
>
> ~~~
> let ports = do myvect.move_iter().map |s| {
>     let (pport, cchan) = stream();
>     do spawn {
>         cchan.send(fun(s))
>     }
>     pport
> }.to_owned_vec();
> ~~~
>
> Also note the use of `to_owned_vec`. `map` lazily returns a `Map` iterator
> - you need to explicitly drain it.
>
> (Note I haven?t tried compiling this)
>
> ~Brendan
>
> On 3 Nov 2013, at 7:04 am, Leah Hanson <astrieanna at gmail.com> wrote:
>
> > Thanks, Scott, I think that's closer.
> >
> > However, now I'm having trouble with my pointer types. Using the element
> inside a spawn means that I need to capture the owned string in the right
> way so that the compiler allows me to give it to the other task.
> >
> > This version:
> > ~~~
> > let ports = do myvect.iter().map |s| {
> >           let (pport, cchan) = stream();
> >           do spawn {
> >             cchan.send(fun(*s))
> >           }
> >           pport
> >         };
> > ~~~
> > gives me pointer-type related errors:
> >       ? error: cannot move out of dereference of & pointer
> >               ? cchan.send(fun(*s))
> >       ? error: cannot borrow immutable local variable as mutable
> >               ? when I iterate over the Ports later
> >       ? error: cannot capture variable of type `&~str`, which does not
> fulfill `Send`, in a bounded closure
> >               ? cchan.send(fun(*s))
> > I also tried a version with |&s| and cchan.send(fun(s)), which gave me
> different errors:
> >       ? error: cannot move out of captured outer variable in a heap
> closure
> >               ? cchan.send(fun(*s))
> >       ? error: cannot move out of dereference of & pointer
> >               ? on the |&s|
> >       ? error: cannot borrow immutable local variable as mutable
> >               ? when I iterate over the Ports later
> >
> > I'm very new to Rust. What do I need to do to let the compiler know that
> I'm not going to use anything in the first vec anymore? That I just want
> the ~str pointers directly?
> >
> > (I put the |s| outside the {} because putting it inside seemed to
> confuse things -- in that case, rustc expected an identifier instead of the
> `let` that comes next, so I assumed that `do v.iter().map {|s| ...}` is a
> syntax error.)
> >
> > Thanks,
> > Leah
> >
> >
> >
> >
> > On Sat, Nov 2, 2013 at 3:23 PM, Scott Lawrence <bytbox at gmail.com> wrote:
> > I would think:
> >
> > let ports = do myvect.iter().map { |e| something(e) }
> >
> >
> > On Sat, 2 Nov 2013, Leah Hanson wrote:
> >
> > Hi,
> >
> > I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.
> >
> > I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just want
> > to be able to iterate over the Ports later.)
> >
> > Since I'm not sure what looping construct to use, I tried with a for-each
> > loop.
> >
> > ~~~
> > let ports = for s in myvect.iter() {
> >          let (pport, cchan) = stream();
> >          do spawn {
> >            cchan.send(fun(*s))
> >          }
> >          pport
> >        };
> > ~~~
> >
> > As you  might, expect I got an error:
> > error: mismatched types: expected `()` but found `std::comm::Port<uint>`
> > (expected () but found struct std::comm::Port)
> >
> > From this, I take it that for loops must return `()`, rather than an
> actual
> > value. When I searched for a map function in the documentation, I only
> > found a Map type.
> >
> > How would you map one vector to a vector of a different element type?
> >
> > Thanks,
> > Leah
> >
> >
> > --
> > Scott Lawrence
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/82215084/attachment-0001.html>

From tkuehn at cmu.edu  Sat Nov  2 14:20:59 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Sat, 2 Nov 2013 17:20:59 -0400
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
	<CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>
	<1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>
	<CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>
Message-ID: <CACVDHKnej_ucDVMqspJGy=jzAJX1MYqkCeRTE9v57Duh8fzYaw@mail.gmail.com>

Instead of `do spawn` try `do spawn_with(s) |s| { ... }`. Then the closure
won't close over s, but rather take it as an argument, allowing it to move
it out.

Cheers


On Sat, Nov 2, 2013 at 5:05 PM, Leah Hanson <astrieanna at gmail.com> wrote:

> Thanks, Brendan. :)
>
> You?re trying to move the ~strs out of the vector. You?ll need to use
>> `move_iter`:
>>
> Is this "moving" about moving memory around or about promising the
> compiler that I won't use those elements of the vector again?
>
>
>> ~~~
>> let ports = do myvect.move_iter().map |s| {
>>     let (pport, cchan) = stream();
>>     do spawn {
>>         cchan.send(fun(s))
>>     }
>>     pport
>> }.to_owned_vec();
>>
>
> There is still a problem because something (I guess the `do spawn {...}`)
> is a "heap closure".
>
>    - error: cannot move out of captured outer variable in a heap closure
>    - cchan.send(fun(s))
>
> I think that this error message is complaining because I'm trying to move
> s, the ~str that the `do spawn {...}` closes over, to a new task.
> And I'm not allowed to move it because it is apparently a heap closure.
> Is there some other kind of closure that does work here? Or some way to
> make this not a closure?
>
> Thanks,
> Leah
>
>
>
> On Sat, Nov 2, 2013 at 4:24 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:
>
>> You?re trying to move the ~strs out of the vector. You?ll need to use
>> `move_iter`:
>>
>> ~~~
>> let ports = do myvect.move_iter().map |s| {
>>     let (pport, cchan) = stream();
>>     do spawn {
>>         cchan.send(fun(s))
>>     }
>>     pport
>> }.to_owned_vec();
>> ~~~
>>
>> Also note the use of `to_owned_vec`. `map` lazily returns a `Map`
>> iterator - you need to explicitly drain it.
>>
>> (Note I haven?t tried compiling this)
>>
>> ~Brendan
>>
>> On 3 Nov 2013, at 7:04 am, Leah Hanson <astrieanna at gmail.com> wrote:
>>
>> > Thanks, Scott, I think that's closer.
>> >
>> > However, now I'm having trouble with my pointer types. Using the
>> element inside a spawn means that I need to capture the owned string in the
>> right way so that the compiler allows me to give it to the other task.
>> >
>> > This version:
>> > ~~~
>> > let ports = do myvect.iter().map |s| {
>> >           let (pport, cchan) = stream();
>> >           do spawn {
>> >             cchan.send(fun(*s))
>> >           }
>> >           pport
>> >         };
>> > ~~~
>> > gives me pointer-type related errors:
>> >       ? error: cannot move out of dereference of & pointer
>> >               ? cchan.send(fun(*s))
>> >       ? error: cannot borrow immutable local variable as mutable
>> >               ? when I iterate over the Ports later
>> >       ? error: cannot capture variable of type `&~str`, which does not
>> fulfill `Send`, in a bounded closure
>> >               ? cchan.send(fun(*s))
>> > I also tried a version with |&s| and cchan.send(fun(s)), which gave me
>> different errors:
>> >       ? error: cannot move out of captured outer variable in a heap
>> closure
>> >               ? cchan.send(fun(*s))
>> >       ? error: cannot move out of dereference of & pointer
>> >               ? on the |&s|
>> >       ? error: cannot borrow immutable local variable as mutable
>> >               ? when I iterate over the Ports later
>> >
>> > I'm very new to Rust. What do I need to do to let the compiler know
>> that I'm not going to use anything in the first vec anymore? That I just
>> want the ~str pointers directly?
>> >
>> > (I put the |s| outside the {} because putting it inside seemed to
>> confuse things -- in that case, rustc expected an identifier instead of the
>> `let` that comes next, so I assumed that `do v.iter().map {|s| ...}` is a
>> syntax error.)
>> >
>> > Thanks,
>> > Leah
>> >
>> >
>> >
>> >
>> > On Sat, Nov 2, 2013 at 3:23 PM, Scott Lawrence <bytbox at gmail.com>
>> wrote:
>> > I would think:
>> >
>> > let ports = do myvect.iter().map { |e| something(e) }
>> >
>> >
>> > On Sat, 2 Nov 2013, Leah Hanson wrote:
>> >
>> > Hi,
>> >
>> > I have a ~[~str]. I have code that will turn a ~str into a Port<uint>.
>> >
>> > I want to end up with a [Port<uint>]. (or ~ or @ or whatever. I just
>> want
>> > to be able to iterate over the Ports later.)
>> >
>> > Since I'm not sure what looping construct to use, I tried with a
>> for-each
>> > loop.
>> >
>> > ~~~
>> > let ports = for s in myvect.iter() {
>> >          let (pport, cchan) = stream();
>> >          do spawn {
>> >            cchan.send(fun(*s))
>> >          }
>> >          pport
>> >        };
>> > ~~~
>> >
>> > As you  might, expect I got an error:
>> > error: mismatched types: expected `()` but found `std::comm::Port<uint>`
>> > (expected () but found struct std::comm::Port)
>> >
>> > From this, I take it that for loops must return `()`, rather than an
>> actual
>> > value. When I searched for a map function in the documentation, I only
>> > found a Map type.
>> >
>> > How would you map one vector to a vector of a different element type?
>> >
>> > Thanks,
>> > Leah
>> >
>> >
>> > --
>> > Scott Lawrence
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/ea017b04/attachment.html>

From simon.sapin at exyr.org  Sat Nov  2 14:21:42 2013
From: simon.sapin at exyr.org (Simon Sapin)
Date: Sat, 02 Nov 2013 21:21:42 +0000
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>	<CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>	<1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>
	<CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>
Message-ID: <52756CE6.8070509@exyr.org>

Le 02/11/2013 21:05, Leah Hanson a ?crit :
> Thanks, Brendan. :)
>
>     You?re trying to move the ~strs out of the vector. You?ll need to
>     use `move_iter`:
>
> Is this "moving" about moving memory around or about promising the
> compiler that I won't use those elements of the vector again?

~str is an "owned" string that can only have one owner. If you move it 
(give away ownership) you can not use it anymore. The compiler verifies 
that.

This is why move_iter() consumes a vector (takes ownership), while 
iter() only gives you references (& pointers) to the elements.

This allows the memory to be freed when the owner disappears, without 
garbage collection or reference counting.


>     ~~~
>     let ports = do myvect.move_iter().map |s| {
>          let (pport, cchan) = stream();
>          do spawn {
>              cchan.send(fun(s))
>          }
>          pport
>     }.to_owned_vec();
>
>
> There is still a problem because something (I guess the `do spawn
> {...}`) is a "heap closure".
>
>   * error: cannot move out of captured outer variable in a heap closure
>       o cchan.send(fun(s))
>
> I think that this error message is complaining because I'm trying to
> move s, the ~str that the `do spawn {...}` closes over, to a new task.
> And I'm not allowed to move it because it is apparently a heap closure.
> Is there some other kind of closure that does work here? Or some way to
> make this not a closure?

I?m not sure, but you may need to use spawn_with to move something into 
a task:

do spawn_with(s) |s| { ... }

-- 
Simon Sapin

From astrieanna at gmail.com  Sat Nov  2 15:45:36 2013
From: astrieanna at gmail.com (Leah Hanson)
Date: Sat, 2 Nov 2013 18:45:36 -0400
Subject: [rust-dev] How would you map one vector to a vector of a
 different element type?
In-Reply-To: <52756CE6.8070509@exyr.org>
References: <CAKbWJsv6cXQdK1cf0pc2rspn3D+k3jvO+Gt_=1vJ-d6vO69SMg@mail.gmail.com>
	<alpine.LNX.2.03.1311021522260.866@localhost.localdomain>
	<CAKbWJssg99_VVkyFZDCTH=j3-=vDgj-TmavOBivvd=xk=c-=aw@mail.gmail.com>
	<1422576C-8467-413D-AB93-BB96924174CC@yahoo.com.au>
	<CAKbWJsvd10UHB3y08dGtwVVFys=iWx5VmS3_NvW=AXpu-RHGjw@mail.gmail.com>
	<52756CE6.8070509@exyr.org>
Message-ID: <CAKbWJss7SpTuno+9m+gA5ODWQ20uv_dT_1s0fTqsZ-HuEkH6pQ@mail.gmail.com>

Thanks! :D

It compiles now! (and works)

The working code is here:
https://github.com/astrieanna/rust-fun/blob/one_worker_per_element/pmap.rs

Best,
  Leah


On Sat, Nov 2, 2013 at 5:21 PM, Simon Sapin <simon.sapin at exyr.org> wrote:

> Le 02/11/2013 21:05, Leah Hanson a ?crit :
>
>  Thanks, Brendan. :)
>>
>>     You?re trying to move the ~strs out of the vector. You?ll need to
>>     use `move_iter`:
>>
>> Is this "moving" about moving memory around or about promising the
>> compiler that I won't use those elements of the vector again?
>>
>
> ~str is an "owned" string that can only have one owner. If you move it
> (give away ownership) you can not use it anymore. The compiler verifies
> that.
>
> This is why move_iter() consumes a vector (takes ownership), while iter()
> only gives you references (& pointers) to the elements.
>
> This allows the memory to be freed when the owner disappears, without
> garbage collection or reference counting.
>
>
>      ~~~
>>     let ports = do myvect.move_iter().map |s| {
>>          let (pport, cchan) = stream();
>>          do spawn {
>>              cchan.send(fun(s))
>>          }
>>          pport
>>     }.to_owned_vec();
>>
>>
>> There is still a problem because something (I guess the `do spawn
>> {...}`) is a "heap closure".
>>
>>   * error: cannot move out of captured outer variable in a heap closure
>>       o cchan.send(fun(s))
>>
>>
>> I think that this error message is complaining because I'm trying to
>> move s, the ~str that the `do spawn {...}` closes over, to a new task.
>> And I'm not allowed to move it because it is apparently a heap closure.
>> Is there some other kind of closure that does work here? Or some way to
>> make this not a closure?
>>
>
> I?m not sure, but you may need to use spawn_with to move something into a
> task:
>
> do spawn_with(s) |s| { ... }
>
> --
> Simon Sapin
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131102/6a5d1e79/attachment-0001.html>

From jon.mb at proinbox.com  Sat Nov  2 17:34:59 2013
From: jon.mb at proinbox.com (John Mija)
Date: Sun, 03 Nov 2013 00:34:59 +0000
Subject: [rust-dev] Checking error at opening file
Message-ID: <52759A33.9060707@proinbox.com>

How to check an error at opening a file but without closing its file 
descriptor?

use std::path;
use std::rt::io;
use std::rt::io::file;

let filename = "/some/path";
let f = file::open(&path::Path::new(filename), io::Open, io::Read);

From loebel.marvin at gmail.com  Sat Nov  2 19:09:59 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Sun, 03 Nov 2013 03:09:59 +0100
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <20131102153457.GE1305@Mr-Bennet>
References: <5273F0DC.4040702@gmail.com> <20131102153457.GE1305@Mr-Bennet>
Message-ID: <5275B077.10504@gmail.com>

On 11/02/2013 04:34 PM, Niko Matsakis wrote:
> I am generally in favor of this proposal. It seems to be a reasonable
> way forward. It is unclear to me how many types would benefit from
> this approach of having methods for each variant, but `Result`
> certainly does.
>
> With respect to possible confusion between `is_ok()` and `ok()` -- I
> think that the presence of a boolean return type should help with
> that. (That is, if you write `if foo.ok() { ... }` the compiler will
> catch it readily enough)
That's my thinking too, we're not using a statically typed language for 
nothing after all.
> Some of the methods on `Result`, however, can't be implemented in
> terms of this approach. For example, `chain` and `chain_err` really
> need to keep the `Result` return type. But I guess that's clear
> enough.
Right, `and` and `or` (which is what we call `chain` and `chain_err` 
these days) will still need to be implemented on `Result` directly, just 
like `map` and `map_err`.

In fact, the only methods that would actually fall away on todays 
`Result` would be `expect`, `expect_err`, a lone `get_ref` and the 
iterator constructors.

I'll send an mail containing a working patch in a follow up to this thread.
> One specific comment on your message:
>
>> - There was talk about making `Result` use an `~Error` trait object
>> instead of a generic type `E`, which could invalidate most of this
>> email.  However, this could also just mean that you usually will see
>> `Result<T, ~Error>` in the wild, for which this proposal still
>> applies.  Additionally, even if the Pattern becomes useless for
>> Result, the problem still exists for any other newtype variant
>> enums, so I'd like to see it get used anyway.
> It is not clear to me why moving to a `~Error` object would have
> any effect on this proposal. `err()` would just return `Option<~Error>`
> in that case, right?
Well, that would still work, that much is true. However the `as_ref` and 
`as_mut_ref` adapters might pose some problems.

Worst case we'll need to have `ok_ref`, `ok_mut`, `err_ref` and 
`err_mut` adapters instead, which would be unfortunate, but still better 
than duplicating all of `Option`s composable API across `Result`.

Kimundi

From loebel.marvin at gmail.com  Sat Nov  2 20:00:06 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Sun, 03 Nov 2013 04:00:06 +0100
Subject: [rust-dev] RFC about std::option and std::result API
In-Reply-To: <5273F0DC.4040702@gmail.com>
References: <5273F0DC.4040702@gmail.com>
Message-ID: <5275BC36.9010203@gmail.com>

I prepared a patch that renames everything as proposed with the 
exception of Option's unwrap -> get change here: 
https://github.com/Kimundi/rust/commit/752912f75f6334da87a476fffc2475a3dfa5639d

I touches ~ 300 lines, most of them being the unwrap -> get and 
unwrap_err -> err_get fallout.

In fact, only a few singular places actually needed to call a `ok()`, 
`err()` or `as_ref` adapter at all, most just unwrapped or mapped.

I discovered another issue though: Right now we require a ToStr bound on 
Results error type E. Ignoring for a moment that ToStr is on the way 
out, the idea behind that bound is that the unwrapping functions could 
provide a useful error message in the common "unwrap an Err value" case.

Changing Result to use composition through as_ref() and ok() complicates 
that goal:

- The first problem is that ok(self) -> Option<T> throws away the Error 
type, which means you'd be only ever be able to see the informative 
error message if you use the shorthand get() and err_get() methods, 
which leads to inconsistency.

- The second, more interesting problem arises with as_ref. By turning 
Result<T, E> into Result<&T, &E>, we changed the self type so that now 
an ToStr bound on &E is necessary. This could be solved by a generic 
ToStr impl of &T for all T: ToStr, however that could decrease usability 
of ToStr, as users might now get seemingly random "&" prefixes all over 
the place in their to_str() outputs.

The good news is that those two issues might cancel each other out: If 
it gets decided that a composable, Option-API-leveraging interface is 
more important for Result than potentially more usable error messages in 
case of unwrapping an Err value, then we can just remove the ToStr bound 
and provide consistent, if generic, error messages. The patch above 
takes that approach for simplicity.

Kimundi

From alex at crichton.co  Sat Nov  2 22:42:33 2013
From: alex at crichton.co (Alex Crichton)
Date: Sat, 2 Nov 2013 22:42:33 -0700
Subject: [rust-dev] Checking error at opening file
In-Reply-To: <52759A33.9060707@proinbox.com>
References: <52759A33.9060707@proinbox.com>
Message-ID: <CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>

This api is a little in flux (hopefully #10179 will land soon), but
I'm not quite sure what you mean about keeping the file descriptor
open. If there was an error opening the file, then a file descriptor
was never allocated and there's nothing to keep open. Regardless, once
my pull request lands, your example would look something like:

use std::rt::io;
use std::rt::io::File;

match io::result(|| File::open(&Path::new("/some/path")) {
  Ok(file) => { /* file was successfully opened, it existed */ }
  Err(e) => { /* file couldn't be opened, error contained in e */ }
}

On Sat, Nov 2, 2013 at 5:34 PM, John Mija <jon.mb at proinbox.com> wrote:
> How to check an error at opening a file but without closing its file
> descriptor?
>
> use std::path;
> use std::rt::io;
> use std::rt::io::file;
>
> let filename = "/some/path";
> let f = file::open(&path::Path::new(filename), io::Open, io::Read);
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From jon.mb at proinbox.com  Sun Nov  3 02:19:51 2013
From: jon.mb at proinbox.com (John Mija)
Date: Sun, 03 Nov 2013 10:19:51 +0000
Subject: [rust-dev] Checking error at opening file
In-Reply-To: <CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
References: <52759A33.9060707@proinbox.com>
	<CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
Message-ID: <52762347.4060503@proinbox.com>

Hi Alex,

I had seen an example at 
http://static.rust-lang.org/doc/master/std/rt/io/file/fn.open.html which 
closes the file at the end of a block.

I simply wants to open a file, checking if there is any error, for later 
to can read it line by line until the end of file. I was wrong using the 
term "closing its file descriptor".

El 03/11/13 05:42, Alex Crichton escribi?:
> This api is a little in flux (hopefully #10179 will land soon), but
> I'm not quite sure what you mean about keeping the file descriptor
> open. If there was an error opening the file, then a file descriptor
> was never allocated and there's nothing to keep open. Regardless, once
> my pull request lands, your example would look something like:
>
> use std::rt::io;
> use std::rt::io::File;
>
> match io::result(|| File::open(&Path::new("/some/path")) {
>    Ok(file) => { /* file was successfully opened, it existed */ }
>    Err(e) => { /* file couldn't be opened, error contained in e */ }
> }
>
> On Sat, Nov 2, 2013 at 5:34 PM, John Mija <jon.mb at proinbox.com> wrote:
>> How to check an error at opening a file but without closing its file
>> descriptor?
>>
>> use std::path;
>> use std::rt::io;
>> use std::rt::io::file;
>>
>> let filename = "/some/path";
>> let f = file::open(&path::Path::new(filename), io::Open, io::Read);
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>

From lists at dhardy.name  Sun Nov  3 04:28:59 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Sun, 03 Nov 2013 13:28:59 +0100
Subject: [rust-dev] Checking error at opening file
In-Reply-To: <52762347.4060503@proinbox.com>
References: <52759A33.9060707@proinbox.com>
	<CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
	<52762347.4060503@proinbox.com>
Message-ID: <1835411.AmDKot32ky@tph-l10036>

Well, your program needs to handle the error somehow if there is one. 
Something like this could work (though syntax may be wrong):

let file = match io::result(|| File::open(&Path::new("/some/path")) {
    Ok(f) => f /* i.e. file is set to f */
    Err(e) => fail!("cannot open file")
}

Alternatively make your function return some "error value" instead of using 
the fail!(...) macro.

On Sunday 03 November 2013 10:19:51 John Mija wrote:
> Hi Alex,
> 
> I had seen an example at
> http://static.rust-lang.org/doc/master/std/rt/io/file/fn.open.html which
> closes the file at the end of a block.
> 
> I simply wants to open a file, checking if there is any error, for later
> to can read it line by line until the end of file. I was wrong using the
> term "closing its file descriptor".
> 
> El 03/11/13 05:42, Alex Crichton escribi?:
> > This api is a little in flux (hopefully #10179 will land soon), but
> > I'm not quite sure what you mean about keeping the file descriptor
> > open. If there was an error opening the file, then a file descriptor
> > was never allocated and there's nothing to keep open. Regardless, once
> > my pull request lands, your example would look something like:
> > 
> > use std::rt::io;
> > use std::rt::io::File;
> > 
> > match io::result(|| File::open(&Path::new("/some/path")) {
> > 
> >    Ok(file) => { /* file was successfully opened, it existed */ }
> >    Err(e) => { /* file couldn't be opened, error contained in e */ }
> > 
> > }
> > 
> > On Sat, Nov 2, 2013 at 5:34 PM, John Mija <jon.mb at proinbox.com> wrote:
> >> How to check an error at opening a file but without closing its file
> >> descriptor?
> >> 
> >> use std::path;
> >> use std::rt::io;
> >> use std::rt::io::file;
> >> 
> >> let filename = "/some/path";
> >> let f = file::open(&path::Path::new(filename), io::Open, io::Read);
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131103/f106e3a6/attachment.sig>

From hatahet at gmail.com  Sun Nov  3 11:03:44 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sun, 3 Nov 2013 11:03:44 -0800
Subject: [rust-dev] Checking error at opening file
In-Reply-To: <CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
References: <52759A33.9060707@proinbox.com>
	<CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
Message-ID: <CAN1rdEwQ7zD41B-j_Sr_Y7vEXmp7iWbyEEbSnAXMXGLFqx4thw@mail.gmail.com>

Out of curiosity, why not make File::open() return a Result<> instead of
Option<> like it does now? The current implementation already seems to be
matching against the result of fs_open() and returning None if the result
is Err(). So why the extra level of indirection and raising a condition in
that case?


--
Ziad


On Sat, Nov 2, 2013 at 10:42 PM, Alex Crichton <alex at crichton.co> wrote:

> This api is a little in flux (hopefully #10179 will land soon), but
> I'm not quite sure what you mean about keeping the file descriptor
> open. If there was an error opening the file, then a file descriptor
> was never allocated and there's nothing to keep open. Regardless, once
> my pull request lands, your example would look something like:
>
> use std::rt::io;
> use std::rt::io::File;
>
> match io::result(|| File::open(&Path::new("/some/path")) {
>   Ok(file) => { /* file was successfully opened, it existed */ }
>   Err(e) => { /* file couldn't be opened, error contained in e */ }
> }
>
> On Sat, Nov 2, 2013 at 5:34 PM, John Mija <jon.mb at proinbox.com> wrote:
> > How to check an error at opening a file but without closing its file
> > descriptor?
> >
> > use std::path;
> > use std::rt::io;
> > use std::rt::io::file;
> >
> > let filename = "/some/path";
> > let f = file::open(&path::Path::new(filename), io::Open, io::Read);
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131103/c695b86b/attachment-0001.html>

From alex at crichton.co  Sun Nov  3 21:42:16 2013
From: alex at crichton.co (Alex Crichton)
Date: Sun, 3 Nov 2013 21:42:16 -0800
Subject: [rust-dev] Checking error at opening file
In-Reply-To: <CAN1rdEwQ7zD41B-j_Sr_Y7vEXmp7iWbyEEbSnAXMXGLFqx4thw@mail.gmail.com>
References: <52759A33.9060707@proinbox.com>
	<CAFnh-me1YRGNrU4BbTeWYcH7ofN2ViiBnj2YMmmRK30iJ6dgRA@mail.gmail.com>
	<CAN1rdEwQ7zD41B-j_Sr_Y7vEXmp7iWbyEEbSnAXMXGLFqx4thw@mail.gmail.com>
Message-ID: <CAFnh-mdkS0xHbSVGK1R90+QxuDQj9Ht8==L8sXyOXjXVPht+Rw@mail.gmail.com>

> Out of curiosity, why not make File::open() return a Result<> instead of
> Option<> like it does now?

This is a relic of I/O using conditions. The idea here is that if you
wanted to catch the condition, you can indeed catch it (and do
something appropriate). If you don't catch it then the task fails and
there's no need to return an Option anyway. The other idea here is
that because the error is signaled by the condition, the return value
of the function can be something that's "always successful".

In this case the definition of success is returning something which is
a Reader/Seek. The I/O library provides an implementation of
Reader/Seek on Option<T: Reader>, so in cases where we can't actually
return a reader (because of the error), None is returned.

The motivation behind this strategy is to reduce boilerplate code
necessary for handling errors in I/O. Instead if checking for errors
at each operation you can check for errors during a block of
operations (or at least I believe that's the idea).

All that being said, it's likely that conditions will be removed from
the api so the return value will indeed be Result<File, IoError> as
one might expect. This is still a little in flux now (mostly on the
error portion of the result), and as a consequence this means that
almost any I/O operation will be Result<T, Error>.

From oren at ben-kiki.org  Sun Nov  3 22:11:29 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 08:11:29 +0200
Subject: [rust-dev] Separating heaps from tasks
Message-ID: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>

I am toying with a non-trivial Rust project to get a feel for the language.
There's a pattern I keep seeing in my code which isn't easy to express in
Rust. I wonder what the "right thing to do" is here.

The pattern is as follows. I have some container, which contains some
components of different types. The container as a whole is send-able . The
components form a complex graph (with cycles).

What I'd like to do is something like this:
- Declare a pool of objects of some types, which is held by the container.
- Declare pointer-to-object whose scope is the container; that is, the
lifetime of the pointer is the lifetime of the container. The pointer can
be freely passed around, cloned, etc. but (for mutable objects), only one
mutable access is allowed at a time.

This calls for something between GC pointers and RC pointers. GC is out,
because it isn't send-able. RC is out, because it doesn't allow for loops.
So right now I use explicit pools and a semi-safe (that is, unsafe...)
"smart pointer" type. And I don't support dropping objects until the whole
container is done (which is OK in my specific app but isn't really a good
solution).

Ideally what I'd like to see is separating heaps from tasks. That is,
suppose that GC pointers had a heap attribute (like borrowed pointers have
a lifetime attribute). By default, each task has a heap, but it is also
possible to define additional heaps (like we have the static lifetime and
can also define additional lifetimes).

So, the container could hold a heap and then many components with
heap-scoped pointers. The whole thing is send-able and GC is done in the
scope of each heap on its own (like today).

There are implications on the type system (no mixing pointers between
different heaps, unless the heaps are nested) - this seems very similar to
the lifetimes type checking...

Overall this seems very symmetrical with lifetimes. Basically, lifetimes ==
static (compile-time computable) free/malloc; heaps == dynamic (run-time
computable) free/malloc.

One interesting pattern allowed by this is ad-hoc actors (there are others
of course). Currently, if one wants to write actor-style code, one ties in
the GC pointers to one heap of one actor, which means one forces the
parallelization policy to one task per actor. One could argue that the
run-time should be good enough that any aggregation of actor threads to OS
threads would be done optimally (which is a good goal); but in some apps,
to get good performance one would like to control this. If we could
separate heaps from tasks, we could spawn fewer tasks (roughly the number
of OS threads) and use application code to decide which actor runs when and
where (e.g., in combination with thread affinity to ensure better cache
locality).

At any rate - is this something that makes sense in the Rust view?
If so, is there a chance of something like that being added (a completely
separate question :-)?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/74752fed/attachment.html>

From pcwalton at mozilla.com  Sun Nov  3 22:13:48 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 03 Nov 2013 22:13:48 -0800
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
Message-ID: <52773B1C.8020406@mozilla.com>

On 11/3/13 10:11 PM, Oren Ben-Kiki wrote:
> At any rate - is this something that makes sense in the Rust view?
> If so, is there a chance of something like that being added (a
> completely separate question :-)?

Two questions:

(1) In your proposal, do the cross-thread GC pointers have mutable 
contents? If so, how do you prevent data races?

(2) Why were ARC and RWarc not sufficient?

Patrick


From danielmicay at gmail.com  Sun Nov  3 22:18:32 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 4 Nov 2013 01:18:32 -0500
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
Message-ID: <CA+DvKQL-nCDvq66pv_HsMue9YQij4uS4CqUzdaeV0+hq0Cm4Bw@mail.gmail.com>

On Mon, Nov 4, 2013 at 1:11 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I am toying with a non-trivial Rust project to get a feel for the
> language. There's a pattern I keep seeing in my code which isn't easy to
> express in Rust. I wonder what the "right thing to do" is here.
>
> The pattern is as follows. I have some container, which contains some
> components of different types. The container as a whole is send-able . The
> components form a complex graph (with cycles).
>

If there are keys, the path of least resistance is to use a map or a pair
of maps. Reference counting can allow cyclic links in data structures as
long as the ownership graph is acyclic, but Rust doesn't offer a type like
this at the moment.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/c6ae1854/attachment.html>

From oren at ben-kiki.org  Sun Nov  3 22:19:40 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 08:19:40 +0200
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <52773B1C.8020406@mozilla.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<52773B1C.8020406@mozilla.com>
Message-ID: <CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>

On Mon, Nov 4, 2013 at 8:13 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/3/13 10:11 PM, Oren Ben-Kiki wrote:
>
>> At any rate - is this something that makes sense in the Rust view?
>> If so, is there a chance of something like that being added (a
>> completely separate question :-)?
>>
>
> Two questions:
>
> (1) In your proposal, do the cross-thread GC pointers have mutable
> contents? If so, how do you prevent data races?
>

There are no cross-task data races because a heap can only be accessed by
one task at a time. This is actually tricky. The container of the heap +
components can be sent; separate components are not. I admit I'm not 100%
sure how to address that.

Preventing mutable aliasing requires an extra bit per pointer, but no
atomic operations or reference counting.


> (2) Why were ARC and RWarc not sufficient?
>

Because they don't allow cycles.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/81762ae3/attachment.html>

From pcwalton at mozilla.com  Sun Nov  3 22:20:29 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 03 Nov 2013 22:20:29 -0800
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>	<52773B1C.8020406@mozilla.com>
	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
Message-ID: <52773CAD.4040805@mozilla.com>

On 11/3/13 10:19 PM, Oren Ben-Kiki wrote:
> Because they don't allow cycles.

Aha. I personally think we should relax this restriction; it's pretty 
onerous.

Patrick


From oren at ben-kiki.org  Sun Nov  3 22:23:47 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 08:23:47 +0200
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CA+DvKQL-nCDvq66pv_HsMue9YQij4uS4CqUzdaeV0+hq0Cm4Bw@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<CA+DvKQL-nCDvq66pv_HsMue9YQij4uS4CqUzdaeV0+hq0Cm4Bw@mail.gmail.com>
Message-ID: <CADJiDhuA8M+FnEc=Cay0LUTok1CkU2Y4ktD24_CAu8hyTjB2vQ@mail.gmail.com>

Yes, using keys (or indices into a vector) is an option. There are two
problems with this.

It is pretty inefficient; one has to access the pool at any point, which
means doubling the sizes of the pointers (at least), probably more; One
needs a lot of unsafe code to allow mutating the pools; And there's the
issue of keeping multiple pools (one per type)... So it gets complex fast,
though perhaps a "sufficiently smart library" could still do a good job?



On Mon, Nov 4, 2013 at 8:18 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Mon, Nov 4, 2013 at 1:11 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> I am toying with a non-trivial Rust project to get a feel for the
>> language. There's a pattern I keep seeing in my code which isn't easy to
>> express in Rust. I wonder what the "right thing to do" is here.
>>
>> The pattern is as follows. I have some container, which contains some
>> components of different types. The container as a whole is send-able . The
>> components form a complex graph (with cycles).
>>
>
> If there are keys, the path of least resistance is to use a map or a pair
> of maps. Reference counting can allow cyclic links in data structures as
> long as the ownership graph is acyclic, but Rust doesn't offer a type like
> this at the moment.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/c273b42e/attachment-0001.html>

From oren at ben-kiki.org  Sun Nov  3 22:29:32 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 08:29:32 +0200
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <52773CAD.4040805@mozilla.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<52773B1C.8020406@mozilla.com>
	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
	<52773CAD.4040805@mozilla.com>
Message-ID: <CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>

Even if RC allowed cycles (I don't quite see how...) the whole thing
wouldn't be send-able, unless one uses ARC. But ARC has even more
performance penalties than RC... And doing cycle-supporting ARC across
tasks seems like pushing it - you might as well admit you are doing global
GC in the 1st place.


On Mon, Nov 4, 2013 at 8:20 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/3/13 10:19 PM, Oren Ben-Kiki wrote:
>
>> Because they don't allow cycles.
>>
>
> Aha. I personally think we should relax this restriction; it's pretty
> onerous.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/382befc0/attachment.html>

From pcwalton at mozilla.com  Sun Nov  3 22:32:18 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 03 Nov 2013 22:32:18 -0800
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>	<52773B1C.8020406@mozilla.com>	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>	<52773CAD.4040805@mozilla.com>
	<CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
Message-ID: <52773F72.3040209@mozilla.com>

On 11/3/13 10:29 PM, Oren Ben-Kiki wrote:
> Even if RC allowed cycles (I don't quite see how...) the whole thing
> wouldn't be send-able, unless one uses ARC. But ARC has even more
> performance penalties than RC... And doing cycle-supporting ARC across
> tasks seems like pushing it - you might as well admit you are doing
> global GC in the 1st place.

I'm not sure I agree. I wasn't thinking that we would detect cycles with 
ARC, for one thing: we'd just let them leak. Not good, but more flexible.

Unlike global GC, thread-safe reference counting has the nice property 
that you only pay for it when you use it. Thread-safe reference counting 
is used in a lot of C++ applications. Using it for everything is right 
out for performance-critical applications?it's poison in that 
concentration?but using it when you truly need it is totally fine IMHO.

Patrick


From danielmicay at gmail.com  Sun Nov  3 22:32:51 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 4 Nov 2013 01:32:51 -0500
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<52773B1C.8020406@mozilla.com>
	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
	<52773CAD.4040805@mozilla.com>
	<CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
Message-ID: <CA+DvKQ+D+iN=e7Q+W=VrGqEeyxGm2mAQDyJHvoLi1xD=rRvjWA@mail.gmail.com>

On Mon, Nov 4, 2013 at 1:29 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Even if RC allowed cycles (I don't quite see how...) the whole thing
> wouldn't be send-able, unless one uses ARC. But ARC has even more
> performance penalties than RC... And doing cycle-supporting ARC across
> tasks seems like pushing it - you might as well admit you are doing global
> GC in the 1st place.
>

It can't support ownership cycles but it can certainly support cyclic links
like `std::shared_ptr` + `std::weak_ptr` in C++. The performance penalty
for supporting sends between tasks is atomic reference counting and the
price for supporting weak pointers is an extra word per box.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/df19eec7/attachment.html>

From martindemello at gmail.com  Sun Nov  3 23:10:38 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Sun, 3 Nov 2013 23:10:38 -0800
Subject: [rust-dev] Using libextra within libstd?
Message-ID: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>

I've been looking at https://github.com/mozilla/rust/issues/6085 which
seems like it should be fairly simple to fix, however, the proposed
solution involves EnumSet from libextra.

Is it possible to use stuff from libextra within libstd? It seems to
me that it would set up a circular dependency, though that could just
be my misunderstanding the rust compilation model. If it is possible,
how would I do it? If not, what would be the proper fix for issue
#6085?

martin

From danielmicay at gmail.com  Sun Nov  3 23:11:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 4 Nov 2013 02:11:58 -0500
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
Message-ID: <CA+DvKQJ0W8oLbmkFsB4Exf3hNbb44aAJJPMt-MiSokG3vq+kRQ@mail.gmail.com>

On Mon, Nov 4, 2013 at 2:10 AM, Martin DeMello <martindemello at gmail.com>wrote:

> I've been looking at https://github.com/mozilla/rust/issues/6085 which
> seems like it should be fairly simple to fix, however, the proposed
> solution involves EnumSet from libextra.
>
> Is it possible to use stuff from libextra within libstd? It seems to
> me that it would set up a circular dependency, though that could just
> be my misunderstanding the rust compilation model. If it is possible,
> how would I do it? If not, what would be the proper fix for issue
> #6085?
>
> martin
>

No, it's not possible to use `libextra` within `libstd`. I think for now it
might be best to define the flag type manually, and factor out the
duplication with other flag types later.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/a742f142/attachment.html>

From oren at ben-kiki.org  Mon Nov  4 01:09:07 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 11:09:07 +0200
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CA+DvKQ+D+iN=e7Q+W=VrGqEeyxGm2mAQDyJHvoLi1xD=rRvjWA@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<52773B1C.8020406@mozilla.com>
	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
	<52773CAD.4040805@mozilla.com>
	<CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
	<CA+DvKQ+D+iN=e7Q+W=VrGqEeyxGm2mAQDyJHvoLi1xD=rRvjWA@mail.gmail.com>
Message-ID: <CADJiDhtQ7nSg05YxrD8aW51+-=h81UJdFy__v1dFVLK1fqbzyQ@mail.gmail.com>

ARCs have their place, sure! But "letting it leak" isn't acceptable in my
case.

Instead, in my use case, "no deletes  until the whole heap is released"
makes way more sense (heaps are small, grow a bit, and get released). Since
the lifetime of the object becomes == the lifetime of the heap, there's no
issue with cycles. There's only an issue with multiple mutations, which
like I said only needs a bit per pointer (and a non-atomic one at that as
each heap is accessed by one thread - the only thing that gets sent between
tasks is the whole heap!).

So... different use cases, different solutions. ARC is a different
trade-off. I guess the right thing to do would be to implement some
"sufficiently smart" AppendOnlyHeap<T> pointer, but this seems hard to do
(same heap can hold objects of multiple types, etc.) so for now I have some
AlmostSafeHeapPointer<T> instead :-(

Language support for heaps-separate-from-tasks would have solved it (and a
bit more)...


On Mon, Nov 4, 2013 at 8:32 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Mon, Nov 4, 2013 at 1:29 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Even if RC allowed cycles (I don't quite see how...) the whole thing
>> wouldn't be send-able, unless one uses ARC. But ARC has even more
>> performance penalties than RC... And doing cycle-supporting ARC across
>> tasks seems like pushing it - you might as well admit you are doing global
>> GC in the 1st place.
>>
>
> It can't support ownership cycles but it can certainly support cyclic
> links like `std::shared_ptr` + `std::weak_ptr` in C++. The performance
> penalty for supporting sends between tasks is atomic reference counting and
> the price for supporting weak pointers is an extra word per box.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/e4807441/attachment.html>

From dbau.pp at gmail.com  Mon Nov  4 01:59:10 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 04 Nov 2013 20:59:10 +1100
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhtQ7nSg05YxrD8aW51+-=h81UJdFy__v1dFVLK1fqbzyQ@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>	<52773B1C.8020406@mozilla.com>	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>	<52773CAD.4040805@mozilla.com>	<CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>	<CA+DvKQ+D+iN=e7Q+W=VrGqEeyxGm2mAQDyJHvoLi1xD=rRvjWA@mail.gmail.com>
	<CADJiDhtQ7nSg05YxrD8aW51+-=h81UJdFy__v1dFVLK1fqbzyQ@mail.gmail.com>
Message-ID: <52776FEE.2020004@gmail.com>

On 04/11/13 20:09, Oren Ben-Kiki wrote:
> ARCs have their place, sure! But "letting it leak" isn't acceptable in 
> my case.
>
> Instead, in my use case, "no deletes  until the whole heap is 
> released" makes way more sense (heaps are small, grow a bit, and get 
> released). Since the lifetime of the object becomes == the lifetime of 
> the heap, there's no issue with cycles. There's only an issue with 
> multiple mutations, which like I said only needs a bit per pointer 
> (and a non-atomic one at that as each heap is accessed by one thread - 
> the only thing that gets sent between tasks is the whole heap!).
>
> So... different use cases, different solutions. ARC is a different 
> trade-off. I guess the right thing to do would be to implement some 
> "sufficiently smart" AppendOnlyHeap<T> pointer, but this seems hard to 
> do (same heap can hold objects of multiple types, etc.) so for now I 
> have some AlmostSafeHeapPointer<T> instead :-(
>
> Language support for heaps-separate-from-tasks would have solved it 
> (and a bit more)...
>

Is this essentially an "arena allocator" where one can transfer the 
whole arena and all the objects allocated in it into another task?

From robertknight at gmail.com  Mon Nov  4 02:31:19 2013
From: robertknight at gmail.com (Robert Knight)
Date: Mon, 4 Nov 2013 10:31:19 +0000
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
Message-ID: <CAJGrnh0U6Ock0Q3mWGTo5mXrqmo=2F=zTzTp3uwsZVSzsZW_8Q@mail.gmail.com>

> Is it possible to use stuff from libextra within libstd?
> It seems to me that it would set up a circular dependency

Even if it was possible technically, probably not a good idea from a
maintenance perspective to have such dependencies.

On 4 November 2013 07:10, Martin DeMello <martindemello at gmail.com> wrote:
> I've been looking at https://github.com/mozilla/rust/issues/6085 which
> seems like it should be fairly simple to fix, however, the proposed
> solution involves EnumSet from libextra.
>
> Is it possible to use stuff from libextra within libstd? It seems to
> me that it would set up a circular dependency, though that could just
> be my misunderstanding the rust compilation model. If it is possible,
> how would I do it? If not, what would be the proper fix for issue
> #6085?
>
> martin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From oren at ben-kiki.org  Mon Nov  4 02:53:54 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 4 Nov 2013 12:53:54 +0200
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <52776FEE.2020004@gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
	<52773B1C.8020406@mozilla.com>
	<CADJiDhuL8wuaJa-K9PUX-CcZDegKP1ryranPu_xz2HfTq+B5Ug@mail.gmail.com>
	<52773CAD.4040805@mozilla.com>
	<CADJiDhurAqNOX1xEPwKTh-ett2rQR7DdGG3vw24aOUKnHDdAZA@mail.gmail.com>
	<CA+DvKQ+D+iN=e7Q+W=VrGqEeyxGm2mAQDyJHvoLi1xD=rRvjWA@mail.gmail.com>
	<CADJiDhtQ7nSg05YxrD8aW51+-=h81UJdFy__v1dFVLK1fqbzyQ@mail.gmail.com>
	<52776FEE.2020004@gmail.com>
Message-ID: <CADJiDhsEyMaQVHs6tyMK_GStEqr=CLOgiViQS_354S_cPb7Jig@mail.gmail.com>

Essentially, yes.


On Mon, Nov 4, 2013 at 11:59 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 04/11/13 20:09, Oren Ben-Kiki wrote:
>
>> ARCs have their place, sure! But "letting it leak" isn't acceptable in my
>> case.
>>
>> Instead, in my use case, "no deletes  until the whole heap is released"
>> makes way more sense (heaps are small, grow a bit, and get released). Since
>> the lifetime of the object becomes == the lifetime of the heap, there's no
>> issue with cycles. There's only an issue with multiple mutations, which
>> like I said only needs a bit per pointer (and a non-atomic one at that as
>> each heap is accessed by one thread - the only thing that gets sent between
>> tasks is the whole heap!).
>>
>> So... different use cases, different solutions. ARC is a different
>> trade-off. I guess the right thing to do would be to implement some
>> "sufficiently smart" AppendOnlyHeap<T> pointer, but this seems hard to do
>> (same heap can hold objects of multiple types, etc.) so for now I have some
>> AlmostSafeHeapPointer<T> instead :-(
>>
>> Language support for heaps-separate-from-tasks would have solved it (and
>> a bit more)...
>>
>>
> Is this essentially an "arena allocator" where one can transfer the whole
> arena and all the objects allocated in it into another task?
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/b76372c2/attachment.html>

From niko at alum.mit.edu  Mon Nov  4 03:22:48 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 4 Nov 2013 06:22:48 -0500
Subject: [rust-dev] Separating heaps from tasks
In-Reply-To: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
References: <CADJiDhuiWS4O2ZokG+8FigG+q3Cqe8+7sE9Fwg_6Wn9a5JB=4Q@mail.gmail.com>
Message-ID: <20131104112248.GC6816@Mr-Bennet>

This is not a complete answer to your question, but I have toyed with
the idea of an (unsafely implemented but with safe interface) message
allocation library that would partially address your use
case. Unfortunately I think that implementing it would require
higher-kinded types.

The basic would be an interface where you have an opaque "message"
that contains an arena and a root pointer (of some type `T`):

    struct Message<T<'a>> {
        priv arena: ~Arena,
        priv root: *mut T<'static>
    }

You can create a message like so:

    Message::new(|arena| {
        let obj1 = arena.alloc(|| Leaf(...));
        let obj2 = arena.alloc(|| Leaf(...));
        arena.alloc(|| Root(obj1, obj2)) // return the root
    });

You could "open" an existing message and revise its contents:

    Message::edit(msg, |arena, root| {
        ...
        root // return new root
    })

These messages could be sent to other tasks, provided of course
that they do not access managed data and so forth.

The idea is to leverage the lifetime system to guarantee that pointers
allocated from the arena do not escape. I haven't thought too hard
about this, so there might be a hole, but I think it would work like
so:

    impl<T<'a>:Isolate> Message<T> {
        fn new(f: <'a> |&'a Arena| -> &'a mut T<'a> {
            let arena = ~Arena::new();
            let root: *mut T<'static> = unsafe {
                transmute(f(&arena))
            };
            Message { arena: arena, root: root }
        }

        fn edit<'a>(m: &mut Message<'a>,
                    f: <'b> |&'b Arena, &'b mut T<'b>| -> &'b mut T<'b>) {
            m.root = unsafe {
                transmute(f(&m.arena), transmute(m.root))
            };
        }
    }

To address your use case, of course, we'd want to extend `arena` with
the ability to track the types of the memory it has allocated and
performance GC. Doing this while a message is being created or edited
would be challenging and would require hooks from the runtime to
obtain stack roots and so forth; interestingly, it'd be pretty trivial
to run the GC at deterministic times or (say) at the end of an editing
session. This might be enough for some uses cases.


Niko

[1]: http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/


On Mon, Nov 04, 2013 at 08:11:29AM +0200, Oren Ben-Kiki wrote:
> I am toying with a non-trivial Rust project to get a feel for the language.
> There's a pattern I keep seeing in my code which isn't easy to express in
> Rust. I wonder what the "right thing to do" is here.
> 
> The pattern is as follows. I have some container, which contains some
> components of different types. The container as a whole is send-able . The
> components form a complex graph (with cycles).
> 
> What I'd like to do is something like this:
> - Declare a pool of objects of some types, which is held by the container.
> - Declare pointer-to-object whose scope is the container; that is, the
> lifetime of the pointer is the lifetime of the container. The pointer can
> be freely passed around, cloned, etc. but (for mutable objects), only one
> mutable access is allowed at a time.
> 
> This calls for something between GC pointers and RC pointers. GC is out,
> because it isn't send-able. RC is out, because it doesn't allow for loops.
> So right now I use explicit pools and a semi-safe (that is, unsafe...)
> "smart pointer" type. And I don't support dropping objects until the whole
> container is done (which is OK in my specific app but isn't really a good
> solution).
> 
> Ideally what I'd like to see is separating heaps from tasks. That is,
> suppose that GC pointers had a heap attribute (like borrowed pointers have
> a lifetime attribute). By default, each task has a heap, but it is also
> possible to define additional heaps (like we have the static lifetime and
> can also define additional lifetimes).
> 
> So, the container could hold a heap and then many components with
> heap-scoped pointers. The whole thing is send-able and GC is done in the
> scope of each heap on its own (like today).
> 
> There are implications on the type system (no mixing pointers between
> different heaps, unless the heaps are nested) - this seems very similar to
> the lifetimes type checking...
> 
> Overall this seems very symmetrical with lifetimes. Basically, lifetimes ==
> static (compile-time computable) free/malloc; heaps == dynamic (run-time
> computable) free/malloc.
> 
> One interesting pattern allowed by this is ad-hoc actors (there are others
> of course). Currently, if one wants to write actor-style code, one ties in
> the GC pointers to one heap of one actor, which means one forces the
> parallelization policy to one task per actor. One could argue that the
> run-time should be good enough that any aggregation of actor threads to OS
> threads would be done optimally (which is a good goal); but in some apps,
> to get good performance one would like to control this. If we could
> separate heaps from tasks, we could spawn fewer tasks (roughly the number
> of OS threads) and use application code to decide which actor runs when and
> where (e.g., in combination with thread affinity to ensure better cache
> locality).
> 
> At any rate - is this something that makes sense in the Rust view?
> If so, is there a chance of something like that being added (a completely
> separate question :-)?

> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Mon Nov  4 10:55:02 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 10:55:02 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
Message-ID: <5277ED86.2060104@mozilla.com>

On 11/03/2013 11:10 PM, Martin DeMello wrote:
> I've been looking at https://github.com/mozilla/rust/issues/6085 which
> seems like it should be fairly simple to fix, however, the proposed
> solution involves EnumSet from libextra.
>
> Is it possible to use stuff from libextra within libstd? It seems to
> me that it would set up a circular dependency, though that could just
> be my misunderstanding the rust compilation model. If it is possible,
> how would I do it? If not, what would be the proper fix for issue
> #6085?
>

As others mentioned it's not generally possible, but just for 
curiosity's sake I'll point out that when running tests std *does* link 
to and use features from libextra. It's mind-bending and bad.

When we decide that std absolutely can't live without features from 
extra, then those features get promoted to std. The bar is pretty high 
though.

From gaetan at xeberon.net  Mon Nov  4 11:00:43 2013
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 4 Nov 2013 20:00:43 +0100
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <5277ED86.2060104@mozilla.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
Message-ID: <CANK7tAHvOYt36RmF7YyhxQTPE4b+BDeJsLRQquBV174L0y2-4w@mail.gmail.com>

hello

I'm new in the rust dev list, so sorry if the question has already been
rised.

But what is the reason to have 2 libraries std/extra? why not gathering all
in a single "std" library?

Thanks
G.

-----
Gaetan



2013/11/4 Brian Anderson <banderson at mozilla.com>

> On 11/03/2013 11:10 PM, Martin DeMello wrote:
>
>> I've been looking at https://github.com/mozilla/rust/issues/6085 which
>> seems like it should be fairly simple to fix, however, the proposed
>> solution involves EnumSet from libextra.
>>
>> Is it possible to use stuff from libextra within libstd? It seems to
>> me that it would set up a circular dependency, though that could just
>> be my misunderstanding the rust compilation model. If it is possible,
>> how would I do it? If not, what would be the proper fix for issue
>> #6085?
>>
>>
> As others mentioned it's not generally possible, but just for curiosity's
> sake I'll point out that when running tests std *does* link to and use
> features from libextra. It's mind-bending and bad.
>
> When we decide that std absolutely can't live without features from extra,
> then those features get promoted to std. The bar is pretty high though.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/365e90fc/attachment.html>

From banderson at mozilla.com  Mon Nov  4 14:33:34 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 14:33:34 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CANK7tAHvOYt36RmF7YyhxQTPE4b+BDeJsLRQquBV174L0y2-4w@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
	<CANK7tAHvOYt36RmF7YyhxQTPE4b+BDeJsLRQquBV174L0y2-4w@mail.gmail.com>
Message-ID: <527820BE.80101@mozilla.com>

On 11/04/2013 11:00 AM, Gaetan wrote:
> hello
>
> I'm new in the rust dev list, so sorry if the question has already 
> been rised.
>
> But what is the reason to have 2 libraries std/extra? why not 
> gathering all in a single "std" library?

There are a few reasons for the split between std and extra.

In general, we think the correct strategy for organizing Rust code is to 
use many small crates; one of the main reasons for this is to avoid 
large compilation times, but there are arguable modularity benefits as 
well. Personally I'd like to avoid Java's situation where there is one 
very large monolithic standard library that we have to live with in its 
entirety forever. The 'vision' currently is to have a rich ecosystem of 
officially supported packages in addition to the monolithic standard 
library. Under this scheme libextra will not exist at all, and will 
instead be broken up into a bunch of individual packages in their own 
repositories. Packages can be developed and stabilized and deprecated by 
the larger community on their own schedules, and those that fall out of 
use can disappear gracefully.

The standard library though is monolithic because it has many complex 
interdependencies and wasn't developed with any intent to be more 
modular. In my opinion the definition of std is something like 'all the 
abstractions that depend on some interface to the compiler (this 
includes primitive types, the runtime, atomics), plus those that are so 
common that most moderate-sized software will need them (various data 
structures, algorithms and OS interfaces)'.

I don't actually recall the original motivation for the split, but this 
is my current thinking.

From martindemello at gmail.com  Mon Nov  4 14:39:36 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Mon, 4 Nov 2013 14:39:36 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <5277ED86.2060104@mozilla.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
Message-ID: <CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>

How does this work without getting into a dependency loop at build time?

martin

On Mon, Nov 4, 2013 at 10:55 AM, Brian Anderson <banderson at mozilla.com> wrote:
> On 11/03/2013 11:10 PM, Martin DeMello wrote:
>>
>> I've been looking at https://github.com/mozilla/rust/issues/6085 which
>> seems like it should be fairly simple to fix, however, the proposed
>> solution involves EnumSet from libextra.
>>
>> Is it possible to use stuff from libextra within libstd? It seems to
>> me that it would set up a circular dependency, though that could just
>> be my misunderstanding the rust compilation model. If it is possible,
>> how would I do it? If not, what would be the proper fix for issue
>> #6085?
>>
>
> As others mentioned it's not generally possible, but just for curiosity's
> sake I'll point out that when running tests std *does* link to and use
> features from libextra. It's mind-bending and bad.
>
> When we decide that std absolutely can't live without features from extra,
> then those features get promoted to std. The bar is pretty high though.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From gaetan at xeberon.net  Mon Nov  4 15:09:42 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 5 Nov 2013 00:09:42 +0100
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
	<CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
Message-ID: <CANK7tAEOK9Q2pVF6MiTioGiPiU-esfbZ4SECpnjatBzer0tPsw@mail.gmail.com>

ok I  understand, it will be like python which I really like the
modularity. I'm beginning to play a little with std::os as my first rust
programming, trying to add missing methods, etc, and I think this should
quite strategic to move to libextra and then to be splitted appart, this
would solve this cyclic dependency. What do you think about it?

-----
Gaetan



2013/11/4 Martin DeMello <martindemello at gmail.com>

> How does this work without getting into a dependency loop at build time?
>
> martin
>
> On Mon, Nov 4, 2013 at 10:55 AM, Brian Anderson <banderson at mozilla.com>
> wrote:
> > On 11/03/2013 11:10 PM, Martin DeMello wrote:
> >>
> >> I've been looking at https://github.com/mozilla/rust/issues/6085 which
> >> seems like it should be fairly simple to fix, however, the proposed
> >> solution involves EnumSet from libextra.
> >>
> >> Is it possible to use stuff from libextra within libstd? It seems to
> >> me that it would set up a circular dependency, though that could just
> >> be my misunderstanding the rust compilation model. If it is possible,
> >> how would I do it? If not, what would be the proper fix for issue
> >> #6085?
> >>
> >
> > As others mentioned it's not generally possible, but just for curiosity's
> > sake I'll point out that when running tests std *does* link to and use
> > features from libextra. It's mind-bending and bad.
> >
> > When we decide that std absolutely can't live without features from
> extra,
> > then those features get promoted to std. The bar is pretty high though.
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/3bcf64c4/attachment.html>

From banderson at mozilla.com  Mon Nov  4 16:35:43 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 16:35:43 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>	<5277ED86.2060104@mozilla.com>
	<CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
Message-ID: <52783D5F.9030200@mozilla.com>

On 11/04/2013 02:39 PM, Martin DeMello wrote:
> How does this work without getting into a dependency loop at build time?

The std under test is not *actually* the standard library as seen by 
compiler and runtime; as far as the compiler is concerned it is just 
some library compiled with --test, that links to libextra and libstd (so 
when testing std there are two different copies of it in memory.. This 
has some complications since the standard library has some functionality 
(lang-items) that must not be redefined, so std has a few strategic 
'cfg' attributes thrown in to avoid that.

For the most part this set up works just fine, but occasionally can 
result in some very hard to understand errors, especially if you run 
tests of the runtime without first recompiling the standard library 
(resulting in unsafe interoperation of incompatible type definitions).

>
> martin
>
> On Mon, Nov 4, 2013 at 10:55 AM, Brian Anderson <banderson at mozilla.com> wrote:
>> On 11/03/2013 11:10 PM, Martin DeMello wrote:
>>> I've been looking at https://github.com/mozilla/rust/issues/6085 which
>>> seems like it should be fairly simple to fix, however, the proposed
>>> solution involves EnumSet from libextra.
>>>
>>> Is it possible to use stuff from libextra within libstd? It seems to
>>> me that it would set up a circular dependency, though that could just
>>> be my misunderstanding the rust compilation model. If it is possible,
>>> how would I do it? If not, what would be the proper fix for issue
>>> #6085?
>>>
>> As others mentioned it's not generally possible, but just for curiosity's
>> sake I'll point out that when running tests std *does* link to and use
>> features from libextra. It's mind-bending and bad.
>>
>> When we decide that std absolutely can't live without features from extra,
>> then those features get promoted to std. The bar is pretty high though.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Mon Nov  4 16:42:47 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 16:42:47 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CANK7tAEOK9Q2pVF6MiTioGiPiU-esfbZ4SECpnjatBzer0tPsw@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
	<CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
	<CANK7tAEOK9Q2pVF6MiTioGiPiU-esfbZ4SECpnjatBzer0tPsw@mail.gmail.com>
Message-ID: <52783F07.8090505@mozilla.com>

On 11/04/2013 03:09 PM, Gaetan wrote:
> ok I  understand, it will be like python which I really like the 
> modularity. I'm beginning to play a little with std::os as my first 
> rust programming, trying to add missing methods, etc, and I think this 
> should quite strategic to move to libextra and then to be splitted 
> appart, this would solve this cyclic dependency. What do you think 
> about it?

Things like 'mkdir' are pretty important and are increasingly tied to 
our I/O subsystem (it just moved into std::rt::io::fs), so I don't think 
it should move out of standard. Since this issue of how to represent 
OR-able flags is pretty common, the consensus seems to be to clean up 
EnumSet and move it to std. If you're interested in tackling it I opened 
an issue specifically about the move 
https://github.com/mozilla/rust/issues/10272.

>
> -----
> Gaetan
>
>
>
> 2013/11/4 Martin DeMello <martindemello at gmail.com 
> <mailto:martindemello at gmail.com>>
>
>     How does this work without getting into a dependency loop at build
>     time?
>
>     martin
>
>     On Mon, Nov 4, 2013 at 10:55 AM, Brian Anderson
>     <banderson at mozilla.com <mailto:banderson at mozilla.com>> wrote:
>     > On 11/03/2013 11:10 PM, Martin DeMello wrote:
>     >>
>     >> I've been looking at
>     https://github.com/mozilla/rust/issues/6085 which
>     >> seems like it should be fairly simple to fix, however, the proposed
>     >> solution involves EnumSet from libextra.
>     >>
>     >> Is it possible to use stuff from libextra within libstd? It
>     seems to
>     >> me that it would set up a circular dependency, though that
>     could just
>     >> be my misunderstanding the rust compilation model. If it is
>     possible,
>     >> how would I do it? If not, what would be the proper fix for issue
>     >> #6085?
>     >>
>     >
>     > As others mentioned it's not generally possible, but just for
>     curiosity's
>     > sake I'll point out that when running tests std *does* link to
>     and use
>     > features from libextra. It's mind-bending and bad.
>     >
>     > When we decide that std absolutely can't live without features
>     from extra,
>     > then those features get promoted to std. The bar is pretty high
>     though.
>     >
>     > _______________________________________________
>     > Rust-dev mailing list
>     > Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     > https://mail.mozilla.org/listinfo/rust-dev
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/10755c82/attachment.html>

From martindemello at gmail.com  Mon Nov  4 16:59:43 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Mon, 4 Nov 2013 16:59:43 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <52783F07.8090505@mozilla.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>
	<5277ED86.2060104@mozilla.com>
	<CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>
	<CANK7tAEOK9Q2pVF6MiTioGiPiU-esfbZ4SECpnjatBzer0tPsw@mail.gmail.com>
	<52783F07.8090505@mozilla.com>
Message-ID: <CAFrFfuEshzTnfEMp_Bu0ZOSeR4CTPtqAOxzRM2RmCpNzrqDtSg@mail.gmail.com>

okay, i figure niko might want to do this himself, but i've marked my
interest on the bug if he doesn't.

martin

On Mon, Nov 4, 2013 at 4:42 PM, Brian Anderson <banderson at mozilla.com> wrote:
> On 11/04/2013 03:09 PM, Gaetan wrote:
>
> ok I  understand, it will be like python which I really like the modularity.
> I'm beginning to play a little with std::os as my first rust programming,
> trying to add missing methods, etc, and I think this should quite strategic
> to move to libextra and then to be splitted appart, this would solve this
> cyclic dependency. What do you think about it?
>
>
> Things like 'mkdir' are pretty important and are increasingly tied to our
> I/O subsystem (it just moved into std::rt::io::fs), so I don't think it
> should move out of standard. Since this issue of how to represent OR-able
> flags is pretty common, the consensus seems to be to clean up EnumSet and
> move it to std. If you're interested in tackling it I opened an issue
> specifically about the move https://github.com/mozilla/rust/issues/10272.
>
>
>
> -----
> Gaetan
>
>
>
> 2013/11/4 Martin DeMello <martindemello at gmail.com>
>>
>> How does this work without getting into a dependency loop at build time?
>>
>> martin
>>
>> On Mon, Nov 4, 2013 at 10:55 AM, Brian Anderson <banderson at mozilla.com>
>> wrote:
>> > On 11/03/2013 11:10 PM, Martin DeMello wrote:
>> >>
>> >> I've been looking at https://github.com/mozilla/rust/issues/6085 which
>> >> seems like it should be fairly simple to fix, however, the proposed
>> >> solution involves EnumSet from libextra.
>> >>
>> >> Is it possible to use stuff from libextra within libstd? It seems to
>> >> me that it would set up a circular dependency, though that could just
>> >> be my misunderstanding the rust compilation model. If it is possible,
>> >> how would I do it? If not, what would be the proper fix for issue
>> >> #6085?
>> >>
>> >
>> > As others mentioned it's not generally possible, but just for
>> > curiosity's
>> > sake I'll point out that when running tests std *does* link to and use
>> > features from libextra. It's mind-bending and bad.
>> >
>> > When we decide that std absolutely can't live without features from
>> > extra,
>> > then those features get promoted to std. The bar is pretty high though.
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>

From banderson at mozilla.com  Mon Nov  4 17:03:42 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 17:03:42 -0800
Subject: [rust-dev] Using libextra within libstd?
In-Reply-To: <CAFrFfuEshzTnfEMp_Bu0ZOSeR4CTPtqAOxzRM2RmCpNzrqDtSg@mail.gmail.com>
References: <CAFrFfuEzTmL-qkWfzCjMB9T6y5NGQuNjH402stA3H9OvqHGq7w@mail.gmail.com>	<5277ED86.2060104@mozilla.com>	<CAFrFfuGV8L0GuWShMHB5ZnNNuWfR-TNX4aN7js2iQkJ5h6kaJg@mail.gmail.com>	<CANK7tAEOK9Q2pVF6MiTioGiPiU-esfbZ4SECpnjatBzer0tPsw@mail.gmail.com>	<52783F07.8090505@mozilla.com>
	<CAFrFfuEshzTnfEMp_Bu0ZOSeR4CTPtqAOxzRM2RmCpNzrqDtSg@mail.gmail.com>
Message-ID: <527843EE.6090004@mozilla.com>

On 11/04/2013 04:59 PM, Martin DeMello wrote:
> okay, i figure niko might want to do this himself, but i've marked my
> interest on the bug if he doesn't.
>

Ask niko for advice about the design, but he will be *happy* to let you 
do it, guaranteed.

From banderson at mozilla.com  Mon Nov  4 18:21:51 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 04 Nov 2013 18:21:51 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
Message-ID: <5278563F.2070507@mozilla.com>

Greetings you delightful Rustic people,

Sound the death knell for segmented stacks.

The new runtime does not implement segmented stacks and it never will. 
This decision has been brewing for some time, and now I'd like to make 
it official and lay out the reasoning for posterity.

To recap, segmented stacks are a strategy for growing stacks 
incrementally, starting from a single small stack segment, and appending 
further segments as needed in a linked list as the stack grows. This 
allows threads to be very compact so that many can be created 
concurrently. The previous Rust runtime did implement segmented stacks, 
and that experience makes us believe that the performance tradeoffs 
required are not compatible with Rust's goals as a high performance 
systems language.

The performance problems associated with segmented stacks can be 
summerized as: switching stacks has a cost. Though that cost can be 
minimized through extensive tuning and micro-optimization (much of which 
we admittedly did not pursue), it will never be free, and we've 
concluded that the effort and complexity of continuing down that route 
is not justified.

We've seen the problem manifest primarily in three areas:

* "stack thrashing" - when out of stack a function call will force an 
allocation of a new segment, which is later freed upon return. This is 
expensive even when the new stack segmented is cached. The result is 
unpredictable and severe drops in performance whenever a stack boundary 
happens to fall inside a tight loop. ([Similar concerns][1] are pushing 
Go away from a segmented stack scheme as well - they call it the "hot 
split" problem).

[1]: 
https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub

* FFI - foreign code typically expects to have large stacks, so using 
the FFI often requires switching stacks. Avoiding this overhead would 
require an elaborate and inherently unsafe system of annotation (#8822), 
increasing a burden on the FFI interface.

* LLVM libc optimizations and intrinsic fallbacks - LLVM will transform 
calls to some libc functions into intrinsics and some intrinsics into 
runtime function calls, for reasons of performance and platform 
compatibility. Obvious solutions to making these compatible with 
segmented stacks impose a high minimum stack requirement, partially 
defeating the point of a segmented stack.

Instead of segmented stacks we're going to rely on the OS and MMU to 
help us map pages lazily. Although the details aren't clear yet, I 
expect that on 64-bit platforms the number of concurrent tasks will be 
comparable to using segmented stacks. On 32-bit platforms, with their 
limited address space, the situation will not be as good, but this is a 
calculated risk that we can live without the same amount of concurrency 
there.

Regards,
Brian

From bill_myers at outlook.com  Mon Nov  4 19:50:27 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Tue, 5 Nov 2013 03:50:27 +0000
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <5278563F.2070507@mozilla.com>
References: <5278563F.2070507@mozilla.com>
Message-ID: <BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>

The advantage of segmented stacks is that blocked tasks only take up as much memory as they actually need to store state, so that for instance a network server can use a task for each connection, and still only use, say, 64 bytes per connection if that's possible instead of the number of stack pages that got allocated for previous computation (assuming an "extreme" version that allocates a stack segment on every call).

However, there is another approach that can replace segmented stacks for that purpose, namely having the compiler automatically transform blocking functions to instead return a future (with limited lifetime).

This means that segmented allocation only happens for functions that indirectly perform I/O and only allocates the exact amount of memory needed to retain state that must persistent across the blocking I/O operation, while other functions execute normally using traditional stacks.

The simplest example of this feature is async/await in C# 5, and Scala has a delimited continuation passing transformation that can be used to do the same thing.

Has this been considered for Rust?

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/ba9b49ea/attachment.html>

From thadguidry at gmail.com  Mon Nov  4 20:13:26 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 4 Nov 2013 22:13:26 -0600
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
References: <5278563F.2070507@mozilla.com>
	<BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
Message-ID: <CAChbWaP6Mm-VV8gSxQjy_uhuWkFnP8GkyPEbg6O4sZ_ocJJesA@mail.gmail.com>

Bill, memory is cheap.


On Mon, Nov 4, 2013 at 9:50 PM, Bill Myers <bill_myers at outlook.com> wrote:

> The advantage of segmented stacks is that blocked tasks only take up as
> much memory as they actually need to store state, so that for instance a
> network server can use a task for each connection, and still only use, say,
> 64 bytes per connection if that's possible instead of the number of stack
> pages that got allocated for previous computation (assuming an "extreme"
> version that allocates a stack segment on every call).
>
> However, there is another approach that can replace segmented stacks for
> that purpose, namely having the compiler automatically transform blocking
> functions to instead return a future (with limited lifetime).
>
> This means that segmented allocation only happens for functions that
> indirectly perform I/O and only allocates the exact amount of memory needed
> to retain state that must persistent across the blocking I/O operation,
> while other functions execute normally using traditional stacks.
>
> The simplest example of this feature is async/await in C# 5, and Scala has
> a delimited continuation passing transformation that can be used to do the
> same thing.
>
> Has this been considered for Rust?
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/bb77a20a/attachment.html>

From oren at ben-kiki.org  Mon Nov  4 21:21:55 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 5 Nov 2013 07:21:55 +0200
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <5278563F.2070507@mozilla.com>
References: <5278563F.2070507@mozilla.com>
Message-ID: <CADJiDhup-m03E+0oa=ZjMydNT90_JoY70dt7TOK9uuQY2Byj4Q@mail.gmail.com>

Note that as memory becomes cheaper and larger there will be more pressure
on 64-bit OS-es to switch to large pages; the number of pages needed to map
several GBs of memory today is already getting out of hand, causing TLB
misses to become a performance issue in some cases - imagine a system with
0.xTBs of memory and it becomes ludicrous.

So playing tricks with MMU and lazy page loading may not work as well as it
does with today's the small 4K page size. Of course, Rust is hardly the
only platform that would be affected :-) and ideally, it would be possible
to have more flexibility than today in choosing which page sizes are used
where in the program's address space... but it remains to be seen how
exactly this would play out.

Just a point to keep in mind...

On Tue, Nov 5, 2013 at 4:21 AM, Brian Anderson <banderson at mozilla.com>wrote:

> Instead of segmented stacks we're going to rely on the OS and MMU to help
> us map pages lazily. Although the details aren't clear yet, I expect that
> on 64-bit platforms the number of concurrent tasks will be comparable to
> using segmented stacks. On 32-bit platforms, with their limited address
> space, the situation will not be as good, but this is a calculated risk
> that we can live without the same amount of concurrency there.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/de660828/attachment.html>

From bob at redivi.com  Mon Nov  4 23:17:35 2013
From: bob at redivi.com (Bob Ippolito)
Date: Mon, 4 Nov 2013 23:17:35 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CAChbWaP6Mm-VV8gSxQjy_uhuWkFnP8GkyPEbg6O4sZ_ocJJesA@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
	<CAChbWaP6Mm-VV8gSxQjy_uhuWkFnP8GkyPEbg6O4sZ_ocJJesA@mail.gmail.com>
Message-ID: <CACwMPm9hnQhBhCoNfDNuH+15qQS69m3KsUdiqhOmMs14NdG+5A@mail.gmail.com>

Having memory is cheap, accessing it isn't.

On Monday, November 4, 2013, Thad Guidry wrote:

> Bill, memory is cheap.
>
>
> On Mon, Nov 4, 2013 at 9:50 PM, Bill Myers <bill_myers at outlook.com<javascript:_e({}, 'cvml', 'bill_myers at outlook.com');>
> > wrote:
>
>> The advantage of segmented stacks is that blocked tasks only take up as
>> much memory as they actually need to store state, so that for instance a
>> network server can use a task for each connection, and still only use, say,
>> 64 bytes per connection if that's possible instead of the number of stack
>> pages that got allocated for previous computation (assuming an "extreme"
>> version that allocates a stack segment on every call).
>>
>> However, there is another approach that can replace segmented stacks for
>> that purpose, namely having the compiler automatically transform blocking
>> functions to instead return a future (with limited lifetime).
>>
>> This means that segmented allocation only happens for functions that
>> indirectly perform I/O and only allocates the exact amount of memory needed
>> to retain state that must persistent across the blocking I/O operation,
>> while other functions execute normally using traditional stacks.
>>
>> The simplest example of this feature is async/await in C# 5, and Scala
>> has a delimited continuation passing transformation that can be used to do
>> the same thing.
>>
>> Has this been considered for Rust?
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131104/2bb35671/attachment-0001.html>

From denis.spir at gmail.com  Tue Nov  5 02:44:01 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 05 Nov 2013 11:44:01 +0100
Subject: [rust-dev] the inter-play of struct type impl, traits, & type params
Message-ID: <5278CBF1.8010900@gmail.com>

Hello,

New to Rust. Is there (already) a list for mutual help in the usage of Rust? If 
not, I guess it may be worth having one, distinct from the dev list, even if the 
language is a moving target, even for people who rather intend, at terms, to 
participate in the development. It is in fact even more needed due precisely to 
the constant change of the lang, to the fact it is mostly unknown, and to the 
state of the docs.
In the meanwhile... see below. Also please pardon wrong ideas or statements: I 
am presently discovering the language. (Also, english is a foreign lang for me.)

As an exercise in learning the language, I am trying various ways to implement 
sparse arrays (association list, trie, "modulo table" = hash table w/o hash), 
the aim being to determine the nr of entries from which it is worth switching to 
a more complicated version. But I'm far from there yet, stumbling on diverse 
issues right for the simplest bits of code. Below, I'm talking of the 
interrelation between struct type declaration & impl, type params, and traits.

type Key = uint;
struct PairList<Val> {
    ...
}
impl<Val:fmt::Default> PairList<Val> {
     ...
}
impl<Val> PairList<Val> for Iterable {
     ...
}


=== trait implementation ===

A first point which I find annoying is the splitting of impl for traits a struct 
explicitely implements. This means that each time we need to use a generic func 
for the *usage* of an *instance* of a type, we have to modify this type's 
*definition* with a new impl section for the corresponding trait(s) required by 
the generic feature. Or do I misunderstand? (This, even if the the trait is 
actually implemented, I mean the methods exist, or am I wrong again?) I find 
that exagerated.
Why not just add a declaration of the trait at the top of the struct type def?

struct PairList<Val> : Iterable {


=== impl itself ===

As a side note, I also do not understand the purpose of the impl section 
altogether. I would be happy with:

* either the methods inside the struct def:

struct PairList<Val> {
    fn push (&self, key:Key, val:Val) {...}
}

* or a simple form outside the struct def:

fn PairList.push (&self, key:Key, val:Val) {...}

It is stated somewhere that the impl section nicely separates the fields from 
the implementation, but this is a question of taste: one could trivially reply 
this section "invents" a strange notion of implementation (after all, data 
fields also are implementation, or rather also definition), and forces to tell 
apart things that logically fit together. Anyway, it's a question of 
perspective... I'd vote for the second form above, because it is a kind of 
intermediate choice. Another advantage is it gives a name to the method 
("PairList.push").


=== the meaning of impl for trait sections ===

Also, I'm not clear about whether "impl for trait" sections form a kind of 
namespace. Can there be methods with equal names in diverse such sections 
(and/or in in th impl section or section not related to traits)? If yes, then it 
would be in my view a bad idea. Instead, make a kind of standard naming scheme 
for trait methods.
Else, what do such sections mean?


=== impl & type params ===

As shown above, for a struct type with type params, we have to repeat the said 
type params in the impl section's headline, and this in fact twice! (I had a 
hard time with that point.) These repetitions make no sense, in my view, since 
the type param belongs to the struct type anyway, esp the one after "impl"; but 
this one repetition precisely is where to declare traits on type params... see 
below. I could live with the repetition after the struct type name, as if the 
type param belonged to the name of the struct type:

impl PairList<Val> {

(but as said I would happily forget about impl sections altogether)


=== traits used ===

For programmer feedback (read: debug) I need to write out pair-lists (indeed). 
An issue is that the Val type is a parameter. Since any form of structured 
output itself requires a format (if only '?') and such formats are traits (! 
why?), I need to declare this trait ("fmt::Default") as belonging to Val --yes, 
the type param... But where? I had to search for a while before stepping on the 
right place: as written above right after "impl" itself.
The logical place to make this declaration would be the concerned method, here 
'write'. But the said method does not take any Val instance as input, just self: 
so that there is no place there to declare that Val implements fmt::Default. Or 
how are we to do it?


=== universal traits ===

A distinct but related issue is this trait fmt::Default is supposed universal. 
Could type params have those universal traits? so that we don't have to declare 
them. Or better, they are not traits.


=== everything is a trait ===

Apparently, in the latest dev of Rust, about everything becomes a trait. This 
gets crazy ;-). I guess it is wrong in that it over-complicates the language, 
and there is no limit. Moreover, these layers of complication *compose*, since 
traits formally are independant. But they are not, semantically, I mean in the 
proper sense of the term: what they *mean* (or are supposed to).
There is certainly a way to use traits in an opposite manner: they represent 
functionalities of which we may know they are available when we use other 
features or types of this or that kind. Currently, traits act conversely, as a 
constant barrier to usage and expression. With traits as they are (used), it 
looks like everything is forbidden by default, and we have to discover and 
explicitely authorise any single bit of functionality.
See also "over-abstraction" below.


=== std features, esp traits ===

I love it that a range of "prelude" features are available in standard. A tiny 
improvement would be that we don't even need to prefix everything with "std::". 
(In the code above, I had to declare "use std:fmt"). Instead, just as every 
prelude feature is available as if we had explicitely imported it, make every 
(sub)module of std pretend to be at the root of the library. Meaning, whenever 
the language does not find x::y, have it search std:x:y.
This would be particularly appreciated for traits which, as it seems, we'll have 
to deal with *very* much.


=== over-abstraction ===

Traits look like, finally, de facto making ("inventing") sub-categories of 
types. There are already many such categories in principle, eg for vectors 
fix-size/var-size/dyn-size, mutable/immutable, fix-type/param-type, etc... Each 
new trait or range of related traits (eg how they are to be written or iterated) 
forms new sub-categories or panels of sub-categories. All of them in principle 
are "orthogonal" (in the sense of logically independant).

Features like generics, type params, traits, should be an opportunity for 
otherwise hyper-rigid languages, because statically typed, and like Rust aiming 
at full safety, to regain some flexibility and ease of use, while retaining 
their safety and efficiency. I guess this is what makes so-called dyn languages 
easy to use. In such a language there is one type of sequential container, and 0 
sub-category.
The features required to use such a type are at most a dozen methods plus a 
handful of operators (python) or even less, in fact about nothing (lua). Lua may 
arguably be extreme, but in Python this is enough to cover 99.9% of use cases, 
other being trivially wri tten in a few lines of code in terms of existing features.

Now, have a look at [http://static.rust-lang.org/doc/0.8/std/vec.html]: it is by 
me a webpage long of 50 screens (I use rather big fonts, right); I did not count 
the functions, but there may be more than 200 probably. And this is nearly a 
plain list, most funcs are undocumented or just with a short sentence. Actually, 
most of them seem redondant, there are tons of versions of the same features, 
depending on various variants. I guess much of this mess is due to a kind of 
over-engineering related in part to traits, or to their current usage in Rust. 
It seems the combination of traits, and their combinations with other sources of 
complication such as type params, add barriers to usage and expression.
Instead of gaining flexibility and ease of use, we get the opposite as it seems. 
We should just declare traits once and for all in the headline ot type defs, 
this just for doc and to help the compiler, and then corresponding functionality 
be available, also composing with functionality provided by other traits, and 
automatically declining into subtypes due to genericity, etc...; this, without 
any other declaration for other types, type params, and more, even less for each 
method of the type or at each function using instances of the type. I guess 
there is a way for traits to be door-openers, not barricade-fabricators. Or am I 
dreaming?

I love many things in Rust, but am afraid it ends up proving being to difficult 
to use or even learn. I'm pretty sure its core design, with some adjustments 
maybe, permits driving it toward an other, welcoming direction. I'm searching 
for a while already for a modern, flexible C with basic safety and reasonable 
performance, a language fun and exciting to program with despite the difficulty 
of lower-level coding, and think it could be Rust.

In any case, thank you very much.

Denis



From qwertie256 at gmail.com  Tue Nov  5 08:32:43 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Tue, 5 Nov 2013 09:32:43 -0700
Subject: [rust-dev] Abandoning segmented stacks in Rust
Message-ID: <CAHuo6ZCOCAOC+DdOEN+8RDkG8m0qXaJvKBsc=tvU172dTPbSNw@mail.gmail.com>

Segmented stacks aren't the only solution though.

If the concern is many tasks that block for a long time, I imagine a
mechanism to bundle a bunch of small, dormant stacks into a single page so
that the original pages could be released to the OS.

If stacks were additionally relocatable (which requires similar machinery
as precise moving GC, if I'm not mistaken) then the released pages could be
re-used for other tasks or heaps, which would be especially helpful on
32-bit. To address the problem of running out of address space on 32-bit,
small-stack tasks could request a single-page stack (plus a guard page),
which is enlarged by relocation as needed.

Combining these techniques, you might be able to have up to a million small
tasks in a 32-bit process.

From: Bill Myers <bill_myers at outlook.com>
>
> The advantage of segmented stacks is that blocked tasks only take up as
> much memory as they actually need to store state, so that for instance a
> network server can use a task for each connection, and still only use, say,
> 64 bytes per connection if that's possible instead of the number of stack
> pages that got allocated for previous computation (assuming an "extreme"
> version that allocates a stack segment on every call).
>
> However, there is another approach that can replace segmented stacks for
> that purpose, namely having the compiler automatically transform blocking
> functions to instead return a future (with limited lifetime).
>
> This means that segmented allocation only happens for functions that
> indirectly perform I/O and only allocates the exact amount of memory needed
> to retain state that must persistent across the blocking I/O operation,
> while other functions execute normally using traditional stacks.
>
> The simplest example of this feature is async/await in C# 5, and Scala has
> a delimited continuation passing transformation that can be used to do the
> same thing.
>
> Has this been considered for Rust?
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/38d2eaef/attachment.html>

From tiffany at stormbit.net  Tue Nov  5 08:47:33 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Tue, 5 Nov 2013 11:47:33 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CAKBOV9kNtmiBFhx+5bY2oFQJDvuP8qFBiiZiSKUFeipxGwoO5w@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
	<CAChbWaP6Mm-VV8gSxQjy_uhuWkFnP8GkyPEbg6O4sZ_ocJJesA@mail.gmail.com>
	<CACwMPm9hnQhBhCoNfDNuH+15qQS69m3KsUdiqhOmMs14NdG+5A@mail.gmail.com>
	<CAKBOV9kNtmiBFhx+5bY2oFQJDvuP8qFBiiZiSKUFeipxGwoO5w@mail.gmail.com>
Message-ID: <CAKBOV9=ADr=DcOv_DbriheuU2=z_W2JthwO0JX4J+oMJhhZ5Jg@mail.gmail.com>

If you really need such a small memory footprint for your tasks, I am of
the opinion that it would be less error prone (whoops, accidentally used 64
bytes of stack than I should have, now I'm using twice as much memory!) to
use an async event loop, like libevent, rather than a task model. It just
doesn't seem like it's as worthwhile - if you really need to have that faux
synchronous IO, you could use FRP.

I'm sure a lot of people would disagree with me, given the general
direction rust has been going with tasks (IO, task-local errors, etc.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/be132df7/attachment.html>

From pcwalton at mozilla.com  Tue Nov  5 09:17:23 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 05 Nov 2013 09:17:23 -0800
Subject: [rust-dev] the inter-play of struct type impl, traits,
 & type params
In-Reply-To: <5278CBF1.8010900@gmail.com>
References: <5278CBF1.8010900@gmail.com>
Message-ID: <52792823.40403@mozilla.com>

On 11/5/13 2:44 AM, spir wrote:
> Why not just add a declaration of the trait at the top of the struct
> type def?
>
> struct PairList<Val> : Iterable {

You can implement traits on types that aren't structs.

> * either the methods inside the struct def:
>
> struct PairList<Val> {
>     fn push (&self, key:Key, val:Val) {...}
> }

That seems somewhat ad-hoc IMHO, because you can implement traits on 
types that aren't structs.

>
> * or a simple form outside the struct def:
>
> fn PairList.push (&self, key:Key, val:Val) {...}
>
> It is stated somewhere that the impl section nicely separates the fields
> from the implementation, but this is a question of taste: one could
> trivially reply this section "invents" a strange notion of
> implementation (after all, data fields also are implementation, or
> rather also definition), and forces to tell apart things that logically
> fit together. Anyway, it's a question of perspective... I'd vote for the
> second form above, because it is a kind of intermediate choice. Another
> advantage is it gives a name to the method ("PairList.push").

We considered the second form, but rejected it, because if you had 
generic type parameters you'd have to repeat them over and over.

> Also, I'm not clear about whether "impl for trait" sections form a kind
> of namespace. Can there be methods with equal names in diverse such
> sections (and/or in in th impl section or section not related to
> traits)? If yes, then it would be in my view a bad idea. Instead, make a
> kind of standard naming scheme for trait methods.
> Else, what do such sections mean?

I'm not sure what this means.

> As shown above, for a struct type with type params, we have to repeat
> the said type params in the impl section's headline, and this in fact
> twice! (I had a hard time with that point.) These repetitions make no
> sense, in my view, since the type param belongs to the struct type
> anyway, esp the one after "impl"; but this one repetition precisely is
> where to declare traits on type params... see below. I could live with
> the repetition after the struct type name, as if the type param belonged
> to the name of the struct type:
>
> impl PairList<Val> {
>
> (but as said I would happily forget about impl sections altogether)

There's a big difference between:

     impl<T> SomeTrait for Foo<T> { ... }

And:

     impl SomeTrait for Foo<int> { ... }

We want to be able to tell the difference between the two at parse time.

> There is certainly a way to use traits in an opposite manner: they
> represent functionalities of which we may know they are available when
> we use other features or types of this or that kind. Currently, traits
> act conversely, as a constant barrier to usage and expression. With
> traits as they are (used), it looks like everything is forbidden by
> default, and we have to discover and explicitely authorise any single
> bit of functionality.

Rust doesn't have C++-style ad-hoc templates; instead it requires that 
you use concepts in all circumstances. There are two reasons for this: 
(a) to fix the error message problems of C++ templates; (b) to allow 
functionality to be added to existing types and used in templates 
without the C++ *argument-dependent lookup*. Given that C++ is heavily 
moving toward concepts because the error message problems at least seem 
intractable without them, I'm personally pretty happy with the decision 
that we made. It requires more organization up front, but the user 
experience of the language becomes so much nicer.

> I love it that a range of "prelude" features are available in standard.
> A tiny improvement would be that we don't even need to prefix everything
> with "std::". (In the code above, I had to declare "use std:fmt").
> Instead, just as every prelude feature is available as if we had
> explicitely imported it, make every (sub)module of std pretend to be at
> the root of the library. Meaning, whenever the language does not find
> x::y, have it search std:x:y.
> This would be particularly appreciated for traits which, as it seems,
> we'll have to deal with *very* much.

We used to do this, but we stopped. The reasons have to do with making 
imports tractable and the fact that we didn't want to wire "std" into 
the compiler more than it needs to be.

> Now, have a look at [http://static.rust-lang.org/doc/0.8/std/vec.html]:
> it is by me a webpage long of 50 screens (I use rather big fonts,
> right); I did not count the functions, but there may be more than 200
> probably. And this is nearly a plain list, most funcs are undocumented
> or just with a short sentence. Actually, most of them seem redondant,
> there are tons of versions of the same features, depending on various
> variants.

The `vec` module does need to be cleaned up, agreed.

> I guess much of this mess is due to a kind of over-engineering
> related in part to traits, or to their current usage in Rust. It seems
> the combination of traits, and their combinations with other sources of
> complication such as type params, add barriers to usage and expression.

I would caution against drawing too much of a conclusion from the `vec` 
module. Most of those traits exist just so that the standard library can 
add methods to the primitive vector type. Remember that in most other 
languages you can't add methods to primitive types at all.

If vectors weren't a built-in type, then you wouldn't have to use traits 
to define all these methods. That would be ideal if we had enough time 
to fix it before 1.0, but regrettably I don't think it'll happen. (We 
may be able to sneak it in in 2.0 backwards compatibly, however.)

Ultimately I think you want ad-hoc templates like C++/D/Nimrod. I don't 
see that happening, unfortunately: Rust is fairly firmly in the Haskell 
tradition of typeclasses for abstraction at this point.

Patrick


From pcwalton at mozilla.com  Tue Nov  5 09:18:19 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 05 Nov 2013 09:18:19 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CAHuo6ZCOCAOC+DdOEN+8RDkG8m0qXaJvKBsc=tvU172dTPbSNw@mail.gmail.com>
References: <CAHuo6ZCOCAOC+DdOEN+8RDkG8m0qXaJvKBsc=tvU172dTPbSNw@mail.gmail.com>
Message-ID: <5279285B.2070706@mozilla.com>

On 11/5/13 8:32 AM, David Piepgrass wrote:
> Segmented stacks aren't the only solution though.
>
> If the concern is many tasks that block for a long time, I imagine a
> mechanism to bundle a bunch of small, dormant stacks into a single page
> so that the original pages could be released to the OS.
>
> If stacks were additionally relocatable (which requires similar
> machinery as precise moving GC, if I'm not mistaken)

This is correct. It's conceivable (although I can't make any promises) 
that if and when LLVM supports this, we could experiment with doing what 
Go does.

Patrick

From denis.spir at gmail.com  Tue Nov  5 10:44:18 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 05 Nov 2013 19:44:18 +0100
Subject: [rust-dev] the inter-play of struct type impl, traits,
 & type params
In-Reply-To: <52792823.40403@mozilla.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
Message-ID: <52793C82.20001@gmail.com>

On 11/05/2013 06:17 PM, Patrick Walton wrote:
> On 11/5/13 2:44 AM, spir wrote:

That you very much for this complete answer, Patrick. Things are clearer.

Denis

From hatahet at gmail.com  Tue Nov  5 11:28:02 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 5 Nov 2013 11:28:02 -0800
Subject: [rust-dev] the inter-play of struct type impl, traits,
	& type params
In-Reply-To: <52792823.40403@mozilla.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
Message-ID: <CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>

On Tue, Nov 5, 2013 at 9:17 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/5/13 2:44 AM, spir wrote:
>
>> Why not just add a declaration of the trait at the top of the struct
>> type def?
>>
>> struct PairList<Val> : Iterable {
>>
>
> You can implement traits on types that aren't structs.



Isn't another effect of this is the ability to "monkey-patch" structs to
implement extra methods or traits? E.g. you can later in implement a
to_str() method for a type, or implement certain traits, like Clone or Drop.


--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/c28df8af/attachment.html>

From steven099 at gmail.com  Tue Nov  5 13:29:38 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Tue, 5 Nov 2013 16:29:38 -0500
Subject: [rust-dev] the inter-play of struct type impl, traits,
	& type params
In-Reply-To: <CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
	<CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
Message-ID: <CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>

As long as "you" are the person who owns the type, yeah, but I suspect
that's not what you mean. Coherence requires that you only implement traits
for types if you own either the trait or the type (or both). You can't
implement a 3rd party trait for a 3rd party type, since then there could be
multiple such implementations for a given (trait, type) pair, and coherence
would be broken.


On Tue, Nov 5, 2013 at 2:28 PM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Tue, Nov 5, 2013 at 9:17 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>
>> On 11/5/13 2:44 AM, spir wrote:
>>
>>> Why not just add a declaration of the trait at the top of the struct
>>> type def?
>>>
>>> struct PairList<Val> : Iterable {
>>>
>>
>> You can implement traits on types that aren't structs.
>
>
>
> Isn't another effect of this is the ability to "monkey-patch" structs to
> implement extra methods or traits? E.g. you can later in implement a
> to_str() method for a type, or implement certain traits, like Clone or Drop.
>
>
> --
> Ziad
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/ad00e2ce/attachment.html>

From banderson at mozilla.com  Tue Nov  5 13:40:58 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 05 Nov 2013 13:40:58 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
References: <5278563F.2070507@mozilla.com>
	<BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
Message-ID: <527965EA.1080604@mozilla.com>

On 11/04/2013 07:50 PM, Bill Myers wrote:
> The advantage of segmented stacks is that blocked tasks only take up 
> as much memory as they actually need to store state, so that for 
> instance a network server can use a task for each connection, and 
> still only use, say, 64 bytes per connection if that's possible 
> instead of the number of stack pages that got allocated for previous 
> computation (assuming an "extreme" version that allocates a stack 
> segment on every call).

In practice there are a number of other limitations that would ever 
prevent Rust from reducing a stack segment to 64 bytes. Rust segmented 
stacks still needed a large 'red zone' for running various bits of code, 
the most problematic being the dynamic linker. On Linux the dynamic 
linker needs about 2k of space to resolve symbols, on Mac much more. 
There are ways to work around this by writing our own dynamic linker or 
disallowing it, but there are significant obstacles to making the stack 
as small as one might want. We had the Linux minimum stack down to ~3k 
(1k for Rust code + *2k* red zone). With mmapped stacks we are always 
free to unmap pages that aren't in use, saving space.

>
> However, there is another approach that can replace segmented stacks 
> for that purpose, namely having the compiler automatically transform 
> blocking functions to instead return a future (with limited lifetime).
>
> This means that segmented allocation only happens for functions that 
> indirectly perform I/O and only allocates the exact amount of memory 
> needed to retain state that must persistent across the blocking I/O 
> operation, while other functions execute normally using traditional 
> stacks.
>
> The simplest example of this feature is async/await in C# 5, and Scala 
> has a delimited continuation passing transformation that can be used 
> to do the same thing.
>
> Has this been considered for Rust?
>

Aren't these futures fullfilled by some kind of task abstraction that 
runs on a thread pool or something? Do these tasks not have their own 
stacks? I have thought about C#'s async/await feature but decided it was 
more or less equivalent to tasks.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/5af8f687/attachment.html>

From banderson at mozilla.com  Tue Nov  5 13:42:36 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 05 Nov 2013 13:42:36 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CADJiDhup-m03E+0oa=ZjMydNT90_JoY70dt7TOK9uuQY2Byj4Q@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhup-m03E+0oa=ZjMydNT90_JoY70dt7TOK9uuQY2Byj4Q@mail.gmail.com>
Message-ID: <5279664C.6020908@mozilla.com>

On 11/04/2013 09:21 PM, Oren Ben-Kiki wrote:
> Note that as memory becomes cheaper and larger there will be more 
> pressure on 64-bit OS-es to switch to large pages; the number of pages 
> needed to map several GBs of memory today is already getting out of 
> hand, causing TLB misses to become a performance issue in some cases - 
> imagine a system with 0.xTBs of memory and it becomes ludicrous.
>
> So playing tricks with MMU and lazy page loading may not work as well 
> as it does with today's the small 4K page size. Of course, Rust is 
> hardly the only platform that would be affected :-) and ideally, it 
> would be possible to have more flexibility than today in choosing 
> which page sizes are used where in the program's address space... but 
> it remains to be seen how exactly this would play out.
>
> Just a point to keep in mind...
>

Thanks! That is an interesting point that I hadn't thought about.

From haoyi.sg at gmail.com  Tue Nov  5 14:32:34 2013
From: haoyi.sg at gmail.com (Haoyi Li)
Date: Tue, 5 Nov 2013 14:32:34 -0800
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <5279664C.6020908@mozilla.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhup-m03E+0oa=ZjMydNT90_JoY70dt7TOK9uuQY2Byj4Q@mail.gmail.com>
	<5279664C.6020908@mozilla.com>
Message-ID: <CALruUQ+eM5X36pM4sWf2z=MkxYGEiwSkfWUZP1Gw0Heb-qf5Kw@mail.gmail.com>

C# Async/Await is distinct from segmented stacks because they store the
enclosed variables as heap objects rather than on the stack; that means it
goes through the same malloc/garbage collector as any other heap objects
you create. It's purely a compiler fiction to let you write code that
'looks' like it's stack allocating variables.




On Tue, Nov 5, 2013 at 1:42 PM, Brian Anderson <banderson at mozilla.com>wrote:

> On 11/04/2013 09:21 PM, Oren Ben-Kiki wrote:
>
>> Note that as memory becomes cheaper and larger there will be more
>> pressure on 64-bit OS-es to switch to large pages; the number of pages
>> needed to map several GBs of memory today is already getting out of hand,
>> causing TLB misses to become a performance issue in some cases - imagine a
>> system with 0.xTBs of memory and it becomes ludicrous.
>>
>> So playing tricks with MMU and lazy page loading may not work as well as
>> it does with today's the small 4K page size. Of course, Rust is hardly the
>> only platform that would be affected :-) and ideally, it would be possible
>> to have more flexibility than today in choosing which page sizes are used
>> where in the program's address space... but it remains to be seen how
>> exactly this would play out.
>>
>> Just a point to keep in mind...
>>
>>
> Thanks! That is an interesting point that I hadn't thought about.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/ca4dd60b/attachment.html>

From corey at octayn.net  Tue Nov  5 14:49:02 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 5 Nov 2013 17:49:02 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <527965EA.1080604@mozilla.com>
References: <5278563F.2070507@mozilla.com>
	<BAY170-W96DE115FD82412A0FA3544F8F10@phx.gbl>
	<527965EA.1080604@mozilla.com>
Message-ID: <CA++BO6StSqNCno=20HOCUv89hyji47sX_fJy6ZxRGMwmyp5ABA@mail.gmail.com>

On Tue, Nov 5, 2013 at 4:40 PM, Brian Anderson <banderson at mozilla.com> wrote:
> On 11/04/2013 07:50 PM, Bill Myers wrote:
>
> The advantage of segmented stacks is that blocked tasks only take up as much
> memory as they actually need to store state, so that for instance a network
> server can use a task for each connection, and still only use, say, 64 bytes
> per connection if that's possible instead of the number of stack pages that
> got allocated for previous computation (assuming an "extreme" version that
> allocates a stack segment on every call).
>

>
> In practice there are a number of other limitations that would ever prevent
> Rust from reducing a stack segment to 64 bytes. Rust segmented stacks still
> needed a large 'red zone' for running various bits of code, the most
> problematic being the dynamic linker.

Plus the sysv amd64 ABI requires a 128 byte red zone under the stack anyway.

From hatahet at gmail.com  Tue Nov  5 19:34:12 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 5 Nov 2013 19:34:12 -0800
Subject: [rust-dev] the inter-play of struct type impl, traits,
	& type params
In-Reply-To: <CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
	<CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
	<CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>
Message-ID: <CAN1rdEz3kh2K0KGu5+2yCRUb0SUEiy+9oM-LD_gedygLGpfvYw@mail.gmail.com>

The following seems to work:

trait Double {
    fn double(&self) -> Self;
}

impl Double for int {
    fn double(&self) -> int {
        *self * 2
    }
}

fn main() {
    let x = 2;
    println!("{}", x.double()); // prints "4"
}



--
Ziad


On Tue, Nov 5, 2013 at 1:29 PM, Steven Blenkinsop <steven099 at gmail.com>wrote:

> As long as "you" are the person who owns the type, yeah, but I suspect
> that's not what you mean. Coherence requires that you only implement traits
> for types if you own either the trait or the type (or both). You can't
> implement a 3rd party trait for a 3rd party type, since then there could be
> multiple such implementations for a given (trait, type) pair, and coherence
> would be broken.
>
>
> On Tue, Nov 5, 2013 at 2:28 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
>
>> On Tue, Nov 5, 2013 at 9:17 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>>
>>> On 11/5/13 2:44 AM, spir wrote:
>>>
>>>> Why not just add a declaration of the trait at the top of the struct
>>>> type def?
>>>>
>>>> struct PairList<Val> : Iterable {
>>>>
>>>
>>> You can implement traits on types that aren't structs.
>>
>>
>>
>> Isn't another effect of this is the ability to "monkey-patch" structs to
>> implement extra methods or traits? E.g. you can later in implement a
>> to_str() method for a type, or implement certain traits, like Clone or Drop.
>>
>>
>> --
>> Ziad
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/76b18a0e/attachment-0001.html>

From steven099 at gmail.com  Tue Nov  5 20:25:17 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Tue, 5 Nov 2013 23:25:17 -0500
Subject: [rust-dev] the inter-play of struct type impl, traits,
	& type params
In-Reply-To: <CAN1rdEz3kh2K0KGu5+2yCRUb0SUEiy+9oM-LD_gedygLGpfvYw@mail.gmail.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
	<CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
	<CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>
	<CAN1rdEz3kh2K0KGu5+2yCRUb0SUEiy+9oM-LD_gedygLGpfvYw@mail.gmail.com>
Message-ID: <CANjmGJtLeVc0Nf6kD4g-xMWt2xMknuJC9Ycb6sU3_JwMnjVorA@mail.gmail.com>

Here you own the trait "Double". Doesn't work if you were trying to
implement a trait you hadn't just defined. The specific examples you
mentioned were Clone and Drop, so that wouldn't work.

On Tuesday, November 5, 2013, Ziad Hatahet wrote:

> The following seems to work:
>
> trait Double {
>     fn double(&self) -> Self;
> }
>
> impl Double for int {
>     fn double(&self) -> int {
>         *self * 2
>     }
> }
>
> fn main() {
>     let x = 2;
>     println!("{}", x.double()); // prints "4"
> }
>
>
>
> --
> Ziad
>
>
> On Tue, Nov 5, 2013 at 1:29 PM, Steven Blenkinsop <steven099 at gmail.com<javascript:_e({}, 'cvml', 'steven099 at gmail.com');>
> > wrote:
>
>> As long as "you" are the person who owns the type, yeah, but I suspect
>> that's not what you mean. Coherence requires that you only implement traits
>> for types if you own either the trait or the type (or both). You can't
>> implement a 3rd party trait for a 3rd party type, since then there could be
>> multiple such implementations for a given (trait, type) pair, and coherence
>> would be broken.
>>
>>
>> On Tue, Nov 5, 2013 at 2:28 PM, Ziad Hatahet <hatahet at gmail.com<javascript:_e({}, 'cvml', 'hatahet at gmail.com');>
>> > wrote:
>>
>>> On Tue, Nov 5, 2013 at 9:17 AM, Patrick Walton <pcwalton at mozilla.com<javascript:_e({}, 'cvml', 'pcwalton at mozilla.com');>
>>> > wrote:
>>>
>>>> On 11/5/13 2:44 AM, spir wrote:
>>>>
>>>>> Why not just add a declaration of the trait at the top of the struct
>>>>> type def?
>>>>>
>>>>> struct PairList<Val> : Iterable {
>>>>>
>>>>
>>>> You can implement traits on types that aren't structs.
>>>
>>>
>>>
>>> Isn't another effect of this is the ability to "monkey-patch" structs to
>>> implement extra methods or traits? E.g. you can later in implement a
>>> to_str() method for a type, or implement certain traits, like Clone or Drop.
>>>
>>>
>>> --
>>> Ziad
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml',
>>> 'Rust-dev at mozilla.org');>
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/eda37fc0/attachment.html>

From hatahet at gmail.com  Tue Nov  5 20:53:45 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 5 Nov 2013 20:53:45 -0800
Subject: [rust-dev] the inter-play of struct type impl, traits,
	& type params
In-Reply-To: <CANjmGJtLeVc0Nf6kD4g-xMWt2xMknuJC9Ycb6sU3_JwMnjVorA@mail.gmail.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
	<CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
	<CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>
	<CAN1rdEz3kh2K0KGu5+2yCRUb0SUEiy+9oM-LD_gedygLGpfvYw@mail.gmail.com>
	<CANjmGJtLeVc0Nf6kD4g-xMWt2xMknuJC9Ycb6sU3_JwMnjVorA@mail.gmail.com>
Message-ID: <CAN1rdExfEMVm07zWSpWqOHcL_=0pySuUzgBnKqdyu0hV4tssag@mail.gmail.com>

Gotcha. But it is still pretty flexible in that you are not bound to the
impls that were originally defined on the type (e.g. like C++/Java where
the list of interfaces implemented by a class are fixed). This relieves one
form writing wrapper classes in order for certain structs to adhere to
particular interfaces.

--
Ziad


On Tue, Nov 5, 2013 at 8:25 PM, Steven Blenkinsop <steven099 at gmail.com>wrote:

> Here you own the trait "Double". Doesn't work if you were trying to
> implement a trait you hadn't just defined. The specific examples you
> mentioned were Clone and Drop, so that wouldn't work.
>
>
> On Tuesday, November 5, 2013, Ziad Hatahet wrote:
>
>> The following seems to work:
>>
>> trait Double {
>>     fn double(&self) -> Self;
>> }
>>
>> impl Double for int {
>>     fn double(&self) -> int {
>>         *self * 2
>>     }
>> }
>>
>> fn main() {
>>     let x = 2;
>>     println!("{}", x.double()); // prints "4"
>> }
>>
>>
>>
>> --
>> Ziad
>>
>>
>> On Tue, Nov 5, 2013 at 1:29 PM, Steven Blenkinsop <steven099 at gmail.com>wrote:
>>
>>> As long as "you" are the person who owns the type, yeah, but I suspect
>>> that's not what you mean. Coherence requires that you only implement traits
>>> for types if you own either the trait or the type (or both). You can't
>>> implement a 3rd party trait for a 3rd party type, since then there could be
>>> multiple such implementations for a given (trait, type) pair, and coherence
>>> would be broken.
>>>
>>>
>>> On Tue, Nov 5, 2013 at 2:28 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
>>>
>>>> On Tue, Nov 5, 2013 at 9:17 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>>>>
>>>>> On 11/5/13 2:44 AM, spir wrote:
>>>>>
>>>>>> Why not just add a declaration of the trait at the top of the struct
>>>>>> type def?
>>>>>>
>>>>>> struct PairList<Val> : Iterable {
>>>>>>
>>>>>
>>>>> You can implement traits on types that aren't structs.
>>>>
>>>>
>>>>
>>>> Isn't another effect of this is the ability to "monkey-patch" structs
>>>> to implement extra methods or traits? E.g. you can later in implement a
>>>> to_str() method for a type, or implement certain traits, like Clone or Drop.
>>>>
>>>>
>>>> --
>>>> Ziad
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131105/3e132318/attachment.html>

From denis.spir at gmail.com  Tue Nov  5 23:46:14 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 06 Nov 2013 08:46:14 +0100
Subject: [rust-dev] struct def
Message-ID: <5279F3C6.2090005@gmail.com>


I can write this:
     struct Points {xs:~[uint], ys:~[uint]}
     fn main () {
        let mut ps = Points{xs:~[1u], ys:~[1u]};
        ...
     }

But I cannot write that:
     struct Points<T> {xs:~[T], ys:~[T]}
     fn main () {
        let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
        ...
     }

In the second case, I get the error:
sparse_array.rs:106:31: 106:32 error: expected one of `; }` but found `:`
sparse_array.rs:106    let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
                                                    ^

Sorry to bother you with that, I find myself unable to find the right syntactic 
schema (and could not find any example in any doc online). I'm blocked, stupidly.

     spir at ospir:~$ rust -v
     rust 0.8
     host: x86_64-unknown-linux-gnu


Also, I have a general problem with writing struct instances with the type 
apart; meaning, without any type param, I get the same error:
     struct Points {xs:~[uint], ys:~[uint]}

     fn main () {
        let mut ps : Points = {xs:~[1], ys:~[1]};
        ...
     }
==>
parse_array.rs:106:28: 106:29 error: expected one of `; }` but found `:`
sparse_array.rs:106    let mut ps : Points = {xs:~[1], ys:~[1]};
                                                 ^

More generally, I don't know why there are 2 syntactic schemas to define vars. I 
would be happy with the latter alone (despite the additional pair of spaces) 
since it is more coherent and more general in allowing temporalily uninitialised 
declarations.

Denis

From oren at ben-kiki.org  Wed Nov  6 00:00:34 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 6 Nov 2013 10:00:34 +0200
Subject: [rust-dev] struct def
In-Reply-To: <5279F3C6.2090005@gmail.com>
References: <5279F3C6.2090005@gmail.com>
Message-ID: <CADJiDhvrTRpHnyPPe6mS=6RCQUwMOko-yywbzCR0u43S4ZQn5w@mail.gmail.com>

I would think:

let mut ps = *Points* {xs:~[1], ys:~[1]};
let mut ps : *Points<uint>* = *Points* {xs:~[1], ys:~[1]};

In Haskell-speak, there is a different between the "type" and the
"constructor", even though by convention they are given the same name.


On Wed, Nov 6, 2013 at 9:46 AM, spir <denis.spir at gmail.com> wrote:

>
> I can write this:
>     struct Points {xs:~[uint], ys:~[uint]}
>     fn main () {
>        let mut ps = Points{xs:~[1u], ys:~[1u]};
>        ...
>     }
>
> But I cannot write that:
>     struct Points<T> {xs:~[T], ys:~[T]}
>     fn main () {
>        let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
>        ...
>     }
>
> In the second case, I get the error:
> sparse_array.rs:106:31: 106:32 error: expected one of `; }` but found `:`
> sparse_array.rs:106    let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
>                                                    ^
>
> Sorry to bother you with that, I find myself unable to find the right
> syntactic schema (and could not find any example in any doc online). I'm
> blocked, stupidly.
>
>     spir at ospir:~$ rust -v
>     rust 0.8
>     host: x86_64-unknown-linux-gnu
>
>
> Also, I have a general problem with writing struct instances with the type
> apart; meaning, without any type param, I get the same error:
>     struct Points {xs:~[uint], ys:~[uint]}
>
>     fn main () {
>        let mut ps : Points = {xs:~[1], ys:~[1]};
>        ...
>     }
> ==>
> parse_array.rs:106:28: 106:29 error: expected one of `; }` but found `:`
> sparse_array.rs:106    let mut ps : Points = {xs:~[1], ys:~[1]};
>                                                 ^
>
> More generally, I don't know why there are 2 syntactic schemas to define
> vars. I would be happy with the latter alone (despite the additional pair
> of spaces) since it is more coherent and more general in allowing
> temporalily uninitialised declarations.
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131106/d6af8e0a/attachment-0001.html>

From dbau.pp at gmail.com  Wed Nov  6 00:10:10 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 06 Nov 2013 19:10:10 +1100
Subject: [rust-dev] struct def
In-Reply-To: <5279F3C6.2090005@gmail.com>
References: <5279F3C6.2090005@gmail.com>
Message-ID: <5279F962.2050703@gmail.com>

On 06/11/13 18:46, spir wrote:
>
> I can write this:
>     struct Points {xs:~[uint], ys:~[uint]}
>     fn main () {
>        let mut ps = Points{xs:~[1u], ys:~[1u]};
>        ...
>     }
>
> But I cannot write that:
>     struct Points<T> {xs:~[T], ys:~[T]}
>     fn main () {
>        let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
>        ...
>     }
>
> In the second case, I get the error:
> sparse_array.rs:106:31: 106:32 error: expected one of `; }` but found `:`
> sparse_array.rs:106    let mut ps = Points<uint>{xs:~[1u], ys:~[1u]};
>                                                    ^

The correct syntax is `let mut ps = Points::<uint> { xs: ~[1u], ys: 
~[1u] };`, but this actually does nothing, it's totally ignored ( 
https://github.com/mozilla/rust/issues/9620 ). In general, type 
inference means that you can normally just write `let mut ps = Points { 
xs: ~[1u], ys: ~[1u] }` even with the generic declaration of `Points`.

>
> Sorry to bother you with that, I find myself unable to find the right 
> syntactic schema (and could not find any example in any doc online). 
> I'm blocked, stupidly.
>
>     spir at ospir:~$ rust -v
>     rust 0.8
>     host: x86_64-unknown-linux-gnu
>
>
> Also, I have a general problem with writing struct instances with the 
> type apart; meaning, without any type param, I get the same error:
>     struct Points {xs:~[uint], ys:~[uint]}
>
>     fn main () {
>        let mut ps : Points = {xs:~[1], ys:~[1]};
>        ...
>     }
> ==>
> parse_array.rs:106:28: 106:29 error: expected one of `; }` but found `:`
> sparse_array.rs:106    let mut ps : Points = {xs:~[1], ys:~[1]};
>                                                 ^

You need to write the struct name always, since { } is valid expression, 
e.g. `let x = { foo(); bar(); baz() };`. So, in this case, `let mut ps: 
Points = Points { xs: ~[1], ys: ~[1] };`.

>
> More generally, I don't know why there are 2 syntactic schemas to 
> define vars. I would be happy with the latter alone (despite the 
> additional pair of spaces) since it is more coherent and more general 
> in allowing temporalily uninitialised declarations.

Which two schema are you referring to? `let x: Type = value;` vs. `let x 
= value;`? If so, they're actually the same, the first just has the 
optional type specified.

(One can provide temporarily uninitialised declarations by just `let 
x;`, as long as the compiler has enough information to (a) know that the 
variable is assigned before every use, and (b) infer the type.)


Huon

From niko at alum.mit.edu  Wed Nov  6 06:41:14 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 6 Nov 2013 09:41:14 -0500
Subject: [rust-dev] the inter-play of struct type impl, traits,
 & type params
In-Reply-To: <CAN1rdExfEMVm07zWSpWqOHcL_=0pySuUzgBnKqdyu0hV4tssag@mail.gmail.com>
References: <5278CBF1.8010900@gmail.com> <52792823.40403@mozilla.com>
	<CAN1rdExJMbYajFxwH5YP=WOLuFVf-VJv+RmBXmDT1XRMROYsug@mail.gmail.com>
	<CANjmGJvAzadMwxofm=1+vyQpELgui2KvfJnPwJw5W_d6rPE4Yg@mail.gmail.com>
	<CAN1rdEz3kh2K0KGu5+2yCRUb0SUEiy+9oM-LD_gedygLGpfvYw@mail.gmail.com>
	<CANjmGJtLeVc0Nf6kD4g-xMWt2xMknuJC9Ycb6sU3_JwMnjVorA@mail.gmail.com>
	<CAN1rdExfEMVm07zWSpWqOHcL_=0pySuUzgBnKqdyu0hV4tssag@mail.gmail.com>
Message-ID: <20131106144114.GB18529@Mr-Bennet>

On Tue, Nov 05, 2013 at 08:53:45PM -0800, Ziad Hatahet wrote:
> This relieves one form writing wrapper classes in order for certain
> structs to adhere to particular interfaces.

Partially, yes. Where this breaks down is if you have a type from one
crate and an interface from another. We can't help you there, though
you can often workaround this problem by wrapping the type in a struct
that you created, and defining the interface on that struct type
instead.


Niko

From oren at ben-kiki.org  Wed Nov  6 10:38:13 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 6 Nov 2013 20:38:13 +0200
Subject: [rust-dev] The let keyword
Message-ID: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>

Coming from Haskell, I realize some of the background of using this syntax
form. But looking at my code, I sometimes wish I could just write `x: Foo
:= foo();` instead of `let x: Foo = foo();`. All these `let`s in the code
seem noisy. I suppose this was an explicit design decision - I wonder if
anyone can say something about why one form was used over the other?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131106/275f8ee3/attachment.html>

From catamorphism at gmail.com  Wed Nov  6 10:39:52 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Wed, 6 Nov 2013 10:39:52 -0800
Subject: [rust-dev] The let keyword
In-Reply-To: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>
References: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>
Message-ID: <CADcg8=k6UqQ6W4ZVaD5Mt1vr6ONXUHFBMu=nnAQ4PiOv4Kacbg@mail.gmail.com>

On Wed, Nov 6, 2013 at 10:38 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> Coming from Haskell, I realize some of the background of using this syntax
> form. But looking at my code, I sometimes wish I could just write `x: Foo :=
> foo();` instead of `let x: Foo = foo();`. All these `let`s in the code seem
> noisy. I suppose this was an explicit design decision - I wonder if anyone
> can say something about why one form was used over the other?

Haskell doesn't have assignment, so in Rust the `let` keyword makes it
easy to visually distinguish updates from declarations. It also makes
some of the dataflow analyses in the compiler easier (for example,
it's easier to do the analysis that tells you which variables, if any,
are used before initialization if you know where all the declarations
are).

Cheers,
Tim

>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From pcwalton at mozilla.com  Wed Nov  6 10:56:47 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 06 Nov 2013 10:56:47 -0800
Subject: [rust-dev] The let keyword
In-Reply-To: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>
References: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>
Message-ID: <527A90EF.4070100@mozilla.com>

On 11/6/13 10:38 AM, Oren Ben-Kiki wrote:
> Coming from Haskell, I realize some of the background of using this
> syntax form. But looking at my code, I sometimes wish I could just write
> `x: Foo := foo();` instead of `let x: Foo = foo();`. All these `let`s in
> the code seem noisy. I suppose this was an explicit design decision - I
> wonder if anyone can say something about why one form was used over the
> other?

`let` tells the parser that there's a pattern coming up.

Languages that do 'x := whatever' can never have destructuring without 
some sort of cover grammar hack.

Patrick


From oren at ben-kiki.org  Wed Nov  6 10:58:40 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 6 Nov 2013 20:58:40 +0200
Subject: [rust-dev] The let keyword
In-Reply-To: <527A90EF.4070100@mozilla.com>
References: <CADJiDhsyqARB-y+Xhkps31WeSqivC6Z03t4-afRkPEoa5nKGmg@mail.gmail.com>
	<527A90EF.4070100@mozilla.com>
Message-ID: <CADJiDhs4QrGmd7UTFSSv6OWf193RMz-E28FtXsO5v+JWJUBbeA@mail.gmail.com>

I didn't consider that; `pattern := expression` would require "infinite
lookahead" in the parser, I guess. Good point.

Thanks!

On Wed, Nov 6, 2013 at 8:56 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> `let` tells the parser that there's a pattern coming up.
>
> Languages that do 'x := whatever' can never have destructuring without
> some sort of cover grammar hack.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131106/4adecf27/attachment.html>

From gaetan at xeberon.net  Thu Nov  7 02:03:58 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 7 Nov 2013 11:03:58 +0100
Subject: [rust-dev] About owned pointer
Message-ID: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>

Hello

I really the concept of owned pointers, and I'm wondering if it could be
the default.

I mean, the more I use it, the more I tend to use it everywhere, and it
seem any "average" user-code (ie, not the rust compiler itself) will have a
lot of "~var" anywhere, "let i=~5", ..., more than the other variable
initialization. Look at the unit tests for libstd or libextra.

Why not having the default syntax be owned pointers, and the ~ syntax (or
another one) be the syntax for creating variable on the heap?

let i=5; // owned pointer
let j=~5; // heap value

Regards,
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/50f3dc65/attachment.html>

From robertknight at gmail.com  Thu Nov  7 02:13:29 2013
From: robertknight at gmail.com (Robert Knight)
Date: Thu, 7 Nov 2013 10:13:29 +0000
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
Message-ID: <CAJGrnh2eQnpTdbta3K1x=OBt48rfT-E-W96mQOL5MrQ70km3ig@mail.gmail.com>

> Why not having the default syntax be owned pointers, and the ~ syntax (or another one) be the syntax for creating variable on the heap?

~ does allocate on the heap. Without ~ you allocate on the stack.

Regards,
Rob.

On 7 November 2013 10:03, Gaetan <gaetan at xeberon.net> wrote:
> Hello
>
> I really the concept of owned pointers, and I'm wondering if it could be the
> default.
>
> I mean, the more I use it, the more I tend to use it everywhere, and it seem
> any "average" user-code (ie, not the rust compiler itself) will have a lot
> of "~var" anywhere, "let i=~5", ..., more than the other variable
> initialization. Look at the unit tests for libstd or libextra.
>
> Why not having the default syntax be owned pointers, and the ~ syntax (or
> another one) be the syntax for creating variable on the heap?
>
> let i=5; // owned pointer
> let j=~5; // heap value
>
> Regards,
> -----
> Gaetan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Thu Nov  7 02:18:56 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 7 Nov 2013 11:18:56 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAJGrnh2eQnpTdbta3K1x=OBt48rfT-E-W96mQOL5MrQ70km3ig@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAJGrnh2eQnpTdbta3K1x=OBt48rfT-E-W96mQOL5MrQ70km3ig@mail.gmail.com>
Message-ID: <CANK7tAGnKKA4xu0uzuA_ZeNf+oCvV7wxxoD0uw4Ewz4-9v12Sg@mail.gmail.com>

sorry for the confusion

-----
Gaetan



2013/11/7 Robert Knight <robertknight at gmail.com>

> > Why not having the default syntax be owned pointers, and the ~ syntax
> (or another one) be the syntax for creating variable on the heap?
>
> ~ does allocate on the heap. Without ~ you allocate on the stack.
>
> Regards,
> Rob.
>
> On 7 November 2013 10:03, Gaetan <gaetan at xeberon.net> wrote:
> > Hello
> >
> > I really the concept of owned pointers, and I'm wondering if it could be
> the
> > default.
> >
> > I mean, the more I use it, the more I tend to use it everywhere, and it
> seem
> > any "average" user-code (ie, not the rust compiler itself) will have a
> lot
> > of "~var" anywhere, "let i=~5", ..., more than the other variable
> > initialization. Look at the unit tests for libstd or libextra.
> >
> > Why not having the default syntax be owned pointers, and the ~ syntax (or
> > another one) be the syntax for creating variable on the heap?
> >
> > let i=5; // owned pointer
> > let j=~5; // heap value
> >
> > Regards,
> > -----
> > Gaetan
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/912cd9af/attachment.html>

From loebel.marvin at gmail.com  Thu Nov  7 02:24:38 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Thu, 07 Nov 2013 11:24:38 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
Message-ID: <527B6A66.8010300@gmail.com>

On 11/07/2013 11:03 AM, Gaetan wrote:
> I mean, the more I use it, the more I tend to use it everywhere, and 
> it seem any "average" user-code (ie, not the rust compiler itself) 
> will have a lot of "~var" anywhere, "let i=~5", ..., more than the 
> other variable initialization. Look at the unit tests for libstd or 
> libextra.
The unit tests are not necessary good code examples. In actual good rust 
code, you'd almost never need to use a heap allocated ~T if you can use 
a T on the stack.
There is also no problem with that: A ~T behaves almost exactly like a 
T, the only exceptions being that ~T is always pointer sized, and that 
~T always has a destructor, which means it always gets moved around 
instead of possibly being implicitly copied.

From loebel.marvin at gmail.com  Thu Nov  7 02:46:14 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Thu, 7 Nov 2013 11:46:14 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527B6A66.8010300@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<527B6A66.8010300@gmail.com>
Message-ID: <CANjOJE+bXoibUziOoTtx23X7V4CtL4dtmvpQcct0uY_n8tHkkg@mail.gmail.com>

Don't worry, our pointers _are_ more confusing compared to many other
languages after all. :)
Am 07.11.2013 11:25 schrieb "Marvin L?bel" <loebel.marvin at gmail.com>:

> On 11/07/2013 11:03 AM, Gaetan wrote:
>
>> I mean, the more I use it, the more I tend to use it everywhere, and it
>> seem any "average" user-code (ie, not the rust compiler itself) will have a
>> lot of "~var" anywhere, "let i=~5", ..., more than the other variable
>> initialization. Look at the unit tests for libstd or libextra.
>>
> The unit tests are not necessary good code examples. In actual good rust
> code, you'd almost never need to use a heap allocated ~T if you can use a T
> on the stack.
> There is also no problem with that: A ~T behaves almost exactly like a T,
> the only exceptions being that ~T is always pointer sized, and that ~T
> always has a destructor, which means it always gets moved around instead of
> possibly being implicitly copied.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/41856984/attachment.html>

From danielmicay at gmail.com  Thu Nov  7 13:48:06 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 7 Nov 2013 16:48:06 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
Message-ID: <CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>

On Thu, Nov 7, 2013 at 5:03 AM, Gaetan <gaetan at xeberon.net> wrote:

> Hello
>
> I really the concept of owned pointers, and I'm wondering if it could be
> the default.
>
> I mean, the more I use it, the more I tend to use it everywhere, and it
> seem any "average" user-code (ie, not the rust compiler itself) will have a
> lot of "~var" anywhere, "let i=~5", ..., more than the other variable
> initialization. Look at the unit tests for libstd or libextra.
>
> Why not having the default syntax be owned pointers, and the ~ syntax (or
> another one) be the syntax for creating variable on the heap?
>
> let i=5; // owned pointer
> let j=~5; // heap value
>
> Regards,
> -----
> Gaetan
>

Owned boxes shouldn't be commonly used. There's close to no reason to use
one for anything but a recursive data structure or in rare cases for an
owned trait object.

http://static.rust-lang.org/doc/master/tutorial.html#boxes

It's important to note that ~[T] and ~str are not owned boxes. They're just
sugar for dynamic arrays, and are common containers.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/3ef022d3/attachment.html>

From com.liigo at gmail.com  Thu Nov  7 15:32:02 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Fri, 8 Nov 2013 07:32:02 +0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
Message-ID: <CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>

> Owned boxes shouldn't be commonly used. There's close to no reason to use
one for anything but a recursive data structure or in rare cases for an
owned trait object.
>
> http://static.rust-lang.org/doc/master/tutorial.html#boxes
>
> It's important to note that ~[T] and ~str are not owned boxes. They're
just sugar for dynamic arrays, and are common containers.
>
It's so confusing. If it's not owned box, why not remove ~? Make "str"
default be dynamic should OK.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/bf8fad3a/attachment.html>

From danielmicay at gmail.com  Thu Nov  7 15:36:33 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 7 Nov 2013 18:36:33 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
Message-ID: <CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>

On Thu, Nov 7, 2013 at 6:32 PM, Liigo Zhuang <com.liigo at gmail.com> wrote:

> > Owned boxes shouldn't be commonly used. There's close to no reason to
> use one for anything but a recursive data structure or in rare cases for an
> owned trait object.
> >
> > http://static.rust-lang.org/doc/master/tutorial.html#boxes
> >
> > It's important to note that ~[T] and ~str are not owned boxes. They're
> just sugar for dynamic arrays, and are common containers.
> >
> It's so confusing. If it's not owned box, why not remove ~? Make "str"
> default be dynamic should OK.
>

It wouldn't be okay for every string literal to result in a heap allocation.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/6873076c/attachment.html>

From jfager at gmail.com  Thu Nov  7 16:49:45 2013
From: jfager at gmail.com (Jason Fager)
Date: Thu, 7 Nov 2013 19:49:45 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
Message-ID: <CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>

Can you speak a little to the practical differences between owned boxes and
~[T]/~str?  How does the difference affect how I should use each?

On Thursday, November 7, 2013, Daniel Micay wrote:

> On Thu, Nov 7, 2013 at 6:32 PM, Liigo Zhuang <com.liigo at gmail.com<javascript:_e({}, 'cvml', 'com.liigo at gmail.com');>
> > wrote:
>
>> > Owned boxes shouldn't be commonly used. There's close to no reason to
>> use one for anything but a recursive data structure or in rare cases for an
>> owned trait object.
>> >
>> > http://static.rust-lang.org/doc/master/tutorial.html#boxes
>> >
>> > It's important to note that ~[T] and ~str are not owned boxes. They're
>> just sugar for dynamic arrays, and are common containers.
>> >
>> It's so confusing. If it's not owned box, why not remove ~? Make "str"
>> default be dynamic should OK.
>>
>
> It wouldn't be okay for every string literal to result in a heap
> allocation.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/feb62345/attachment.html>

From danielmicay at gmail.com  Thu Nov  7 16:59:41 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 7 Nov 2013 19:59:41 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
Message-ID: <CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>

On Thu, Nov 7, 2013 at 7:49 PM, Jason Fager <jfager at gmail.com> wrote:

> Can you speak a little to the practical differences between owned boxes
> and ~[T]/~str?  How does the difference affect how I should use each?


I wrote the section on owned boxes in the tutorial currently in master, so
I would suggest reading that. It's very rare for there to be a use case for
an owned box outside of a recursive data structure or plugin system (traits
as objects).

The coverage in the tutorial of vectors/strings is not only lacking in
depth but is also *incorrect*, so I understand why there's a lot of
confusion about them.

Vectors/strings are containers, and aren't connected to owned boxes any
more than HashMap/TreeMap/TrieMap. I would prefer it if the syntactic sugar
didn't exist and we just had generic container literals, because it seems
to end up causing a lot of confusion.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/eb30f951/attachment.html>

From jfager at gmail.com  Thu Nov  7 17:40:27 2013
From: jfager at gmail.com (Jason Fager)
Date: Thu, 7 Nov 2013 20:40:27 -0500
Subject: [rust-dev]  About owned pointer
In-Reply-To: <CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
Message-ID: <CAFEbTaUhERRZ=48Ei4rfibcDW0y1oFmdBT7gX9EVJV70oPCrUg@mail.gmail.com>

Let me ask another way:  what's wrong with thinking of ~ just as meaning
"allocate to the heap and subject to move semantics"?  When would that
simplification bite me in the ass regarding owned boxes vs strs/vecs?

I get that I should very rarely want that for things that aren't dynamic
containers or recursive data structures.  But beyond that, am I ever going
to get myself in trouble not remembering the details of the difference
between how ~T works vs ~[T]?


On Thursday, November 7, 2013, Daniel Micay wrote:

> On Thu, Nov 7, 2013 at 7:49 PM, Jason Fager <jfager at gmail.com> wrote:
>
>> Can you speak a little to the practical differences between owned boxes
>> and ~[T]/~str?  How does the difference affect how I should use each?
>
>
> I wrote the section on owned boxes in the tutorial currently in master, so
> I would suggest reading that. It's very rare for there to be a use case for
> an owned box outside of a recursive data structure or plugin system (traits
> as objects).
>
> The coverage in the tutorial of vectors/strings is not only lacking in
> depth but is also *incorrect*, so I understand why there's a lot of
> confusion about them.
>
> Vectors/strings are containers, and aren't connected to owned boxes any
> more than HashMap/TreeMap/TrieMap. I would prefer it if the syntactic sugar
> didn't exist and we just had generic container literals, because it seems
> to end up causing a lot of confusion.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/0418c007/attachment-0001.html>

From danielmicay at gmail.com  Thu Nov  7 18:01:39 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 7 Nov 2013 21:01:39 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAFEbTaUhERRZ=48Ei4rfibcDW0y1oFmdBT7gX9EVJV70oPCrUg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
	<CAFEbTaUhERRZ=48Ei4rfibcDW0y1oFmdBT7gX9EVJV70oPCrUg@mail.gmail.com>
Message-ID: <CA+DvKQLX4v-k3U3ykMVCBH0vb2ZdPQS13SqX7RkFey7NHTOHLw@mail.gmail.com>

On Thu, Nov 7, 2013 at 8:40 PM, Jason Fager <jfager at gmail.com> wrote:

> Let me ask another way:  what's wrong with thinking of ~ just as meaning
> "allocate to the heap and subject to move semantics"?  When would that
> simplification bite me in the ass regarding owned boxes vs strs/vecs?
>
> I get that I should very rarely want that for things that aren't dynamic
> containers or recursive data structures.  But beyond that, am I ever going
> to get myself in trouble not remembering the details of the difference
> between how ~T works vs ~[T]?


The heap allocation is a means to an end rather than a useful property.
There are lots of types in the standard library with destructors, including
most of the containers. There's a deeper connection between TreeMap and an
owned box than between owned vectors and owned boxes.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131107/d06e8e92/attachment.html>

From oren at ben-kiki.org  Thu Nov  7 22:27:06 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 08:27:06 +0200
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <5278563F.2070507@mozilla.com>
References: <5278563F.2070507@mozilla.com>
Message-ID: <CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>

Does ditching segmented stacks mean we can start getting a stack trace when
a task `fail!`s? Or is this an unrelated issue?

The lack of stack traces is extremely tedious when debugging failed
assertions...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/76b5e516/attachment.html>

From corey at octayn.net  Thu Nov  7 22:40:13 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 8 Nov 2013 01:40:13 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
Message-ID: <CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>

Entirely unrelated. Do note that we have stack traces *now*, as long
as you're using gdb to get them :). Break on `rust_begin_unwind` or
"catch throw".

On Fri, Nov 8, 2013 at 1:27 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> Does ditching segmented stacks mean we can start getting a stack trace when
> a task `fail!`s? Or is this an unrelated issue?
>
> The lack of stack traces is extremely tedious when debugging failed
> assertions...
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From oren at ben-kiki.org  Thu Nov  7 22:45:53 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 08:45:53 +0200
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
Message-ID: <CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>

Good to know! The GDB stack traces leave something to be desired, though -
e.g. the way it reports closures isn't really very useful (adding source
file name and line number would be really good there). But it is certainly
better than nothing. Thanks!


On Fri, Nov 8, 2013 at 8:40 AM, Corey Richardson <corey at octayn.net> wrote:

> Entirely unrelated. Do note that we have stack traces *now*, as long
> as you're using gdb to get them :). Break on `rust_begin_unwind` or
> "catch throw".
>
> On Fri, Nov 8, 2013 at 1:27 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> > Does ditching segmented stacks mean we can start getting a stack trace
> when
> > a task `fail!`s? Or is this an unrelated issue?
> >
> > The lack of stack traces is extremely tedious when debugging failed
> > assertions...
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/47e82c97/attachment.html>

From danielmicay at gmail.com  Thu Nov  7 22:48:14 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 01:48:14 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
	<CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
Message-ID: <CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>

On Fri, Nov 8, 2013 at 1:45 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Good to know! The GDB stack traces leave something to be desired, though -
> e.g. the way it reports closures isn't really very useful (adding source
> file name and line number would be really good there). But it is certainly
> better than nothing. Thanks!
>

Rust only has boxed (type erased) closures so there's no source data to
associate with them. They're a function pointer and some data to go along
with it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/f3843a02/attachment.html>

From oren at ben-kiki.org  Thu Nov  7 22:52:56 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 08:52:56 +0200
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
	<CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
	<CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>
Message-ID: <CADJiDhsoHijzwDf+n64VNeBJOOzDnxkpFW1YOgje9+m0AzAzhA@mail.gmail.com>

How bad would it be to add another 64 bits to the "some data to go along
with it" part? I'm assuming 32 bit for file name index in some table and 32
bit for the line number in the file should be enough :-)


On Fri, Nov 8, 2013 at 8:48 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Fri, Nov 8, 2013 at 1:45 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Good to know! The GDB stack traces leave something to be desired, though
>> - e.g. the way it reports closures isn't really very useful (adding source
>> file name and line number would be really good there). But it is certainly
>> better than nothing. Thanks!
>>
>
> Rust only has boxed (type erased) closures so there's no source data to
> associate with them. They're a function pointer and some data to go along
> with it.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/bb4059aa/attachment.html>

From danielmicay at gmail.com  Thu Nov  7 22:59:17 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 01:59:17 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CADJiDhsoHijzwDf+n64VNeBJOOzDnxkpFW1YOgje9+m0AzAzhA@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
	<CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
	<CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>
	<CADJiDhsoHijzwDf+n64VNeBJOOzDnxkpFW1YOgje9+m0AzAzhA@mail.gmail.com>
Message-ID: <CA+DvKQJpjOOb+CXzRCwsWO5aCVu-is7TVUkj8DzFPAEKpOmOZg@mail.gmail.com>

On Fri, Nov 8, 2013 at 1:52 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> How bad would it be to add another 64 bits to the "some data to go along
> with it" part? I'm assuming 32 bit for file name index in some table and 32
> bit for the line number in the file should be enough :-)
>

In debug builds, no problem at all. It would mean updating all code doing
transmutes of closures and the code generation for them though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/beae5981/attachment-0001.html>

From danielmicay at gmail.com  Thu Nov  7 23:00:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 02:00:58 -0500
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CA+DvKQJpjOOb+CXzRCwsWO5aCVu-is7TVUkj8DzFPAEKpOmOZg@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
	<CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
	<CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>
	<CADJiDhsoHijzwDf+n64VNeBJOOzDnxkpFW1YOgje9+m0AzAzhA@mail.gmail.com>
	<CA+DvKQJpjOOb+CXzRCwsWO5aCVu-is7TVUkj8DzFPAEKpOmOZg@mail.gmail.com>
Message-ID: <CA+DvKQ+OS+tfUkP5EEN-2uEzv2CVgmU+3KuP--yP45c8Oz54ng@mail.gmail.com>

On Fri, Nov 8, 2013 at 1:59 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Fri, Nov 8, 2013 at 1:52 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> How bad would it be to add another 64 bits to the "some data to go along
>> with it" part? I'm assuming 32 bit for file name index in some table and 32
>> bit for the line number in the file should be enough :-)
>>
>
> In debug builds, no problem at all. It would mean updating all code doing
> transmutes of closures and the code generation for them though.
>

On second thought... it does seem like if the debug data can be associated
with functions, it's available for function pointers to them.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/85e73027/attachment.html>

From oren at ben-kiki.org  Thu Nov  7 23:29:06 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 09:29:06 +0200
Subject: [rust-dev] Abandoning segmented stacks in Rust
In-Reply-To: <CA+DvKQ+OS+tfUkP5EEN-2uEzv2CVgmU+3KuP--yP45c8Oz54ng@mail.gmail.com>
References: <5278563F.2070507@mozilla.com>
	<CADJiDhtRPMMdOtD1PCkAMqjFvdM9kX7qT_WmLaWnqU-TKV7aRw@mail.gmail.com>
	<CA++BO6S-hWjkJOhGeYL2EZfSuVe4xm6o7_vPOQOK5-Kc4R+rgw@mail.gmail.com>
	<CADJiDhtXLrRdpFcBntY9WzeCNi9XucEVnGtn4GuXCfboz4PW1g@mail.gmail.com>
	<CA+DvKQ+0oKb59gEAUAXmW1UazUX8dJc8UfEGviCXLZ-ZX89H9A@mail.gmail.com>
	<CADJiDhsoHijzwDf+n64VNeBJOOzDnxkpFW1YOgje9+m0AzAzhA@mail.gmail.com>
	<CA+DvKQJpjOOb+CXzRCwsWO5aCVu-is7TVUkj8DzFPAEKpOmOZg@mail.gmail.com>
	<CA+DvKQ+OS+tfUkP5EEN-2uEzv2CVgmU+3KuP--yP45c8Oz54ng@mail.gmail.com>
Message-ID: <CADJiDhsqEkSNQ2s0ppCSGef3mVDxVJp=r9YL+951SLsVjaUQHw@mail.gmail.com>

Added https://github.com/mozilla/rust/issues/10350 then :-)


On Fri, Nov 8, 2013 at 9:00 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Fri, Nov 8, 2013 at 1:59 AM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> On Fri, Nov 8, 2013 at 1:52 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>>> How bad would it be to add another 64 bits to the "some data to go along
>>> with it" part? I'm assuming 32 bit for file name index in some table and 32
>>> bit for the line number in the file should be enough :-)
>>>
>>
>> In debug builds, no problem at all. It would mean updating all code doing
>> transmutes of closures and the code generation for them though.
>>
>
> On second thought... it does seem like if the debug data can be associated
> with functions, it's available for function pointers to them.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/85130630/attachment.html>

From philippe.delrieu at free.fr  Thu Nov  7 23:50:58 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 08:50:58 +0100
Subject: [rust-dev] Access error for trait implemtation in multiple file
Message-ID: <527C97E2.9020904@free.fr>

Hello, rust addict.

I have a problem with rustc. I have 3 files.
The first one actions.rs contains a trait declaration :

pub trait Action {
     // process the action on server side.
     fn process(&self) -> ~str;
}

The second contains a trait implementation testaction.rs:
mod actions;


pub struct TestAction    {
     actiontype: uint
}

impl actions::Action for TestAction    {

     fn process(&self) -> ~str     {
         ~""
     }
}
  The third test the trait cast :
     mod actions;
     mod midi;

                 let element : ~testaction::TestAction = 
~testaction::TestAction{actiontype:1};
                 let actelm: ~actions::Action = element as 
~actions::Action; //error here
                 println("process element :" + actelm.process());
=> generate  error: failed to find an implementation of trait

                 let actelm: ~testaction::actions::Action = element as 
~testaction::actions::Action;  //error here
                 println("process element :" + actelm.process());
=> generate error: trait `Action` is inaccessible

If I put testaction content in the test file rustc compile.

Any idea?

Philippe Delrieu



From gaetan at xeberon.net  Fri Nov  8 00:43:37 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 8 Nov 2013 09:43:37 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
Message-ID: <CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>

I agree, I don't understand the syntax here.

Look at the Url class:


pub struct Url {
    scheme: ~str,
    user: Option<UserInfo>,
    host: ~str,
    port: Option<~str>,
    path: ~str,
    query: Query,
    fragment: Option<~str>
}

pub type Query = ~[(~str, ~str)];

fn split_char_first(s: &str, c: char) -> (~str, ~str) {
    ...
    if index+mat == len {
        return (s.slice(0, index).to_owned(), ~"");
    }
}


Isn't simpler, and easier to read, if we write it


pub struct Url {
    scheme: str,
    user: Option<UserInfo>,
    host: str,
    port: Option<str>,
    path: str,
    query: Query,
    fragment: Option<str>
}

pub type Query = [(str, str)];

fn split_char_first(s: &str, c: char) -> (str, str) {
    ...
    if index+mat == len {
        return (s.slice(0, index).to_owned(), "");
    }
}


KISS !


-----
Gaetan



2013/11/8 Jason Fager <jfager at gmail.com>

> Can you speak a little to the practical differences between owned boxes
> and ~[T]/~str?  How does the difference affect how I should use each?
>
>
> On Thursday, November 7, 2013, Daniel Micay wrote:
>
>> On Thu, Nov 7, 2013 at 6:32 PM, Liigo Zhuang <com.liigo at gmail.com> wrote:
>>
>>> > Owned boxes shouldn't be commonly used. There's close to no reason to
>>> use one for anything but a recursive data structure or in rare cases for an
>>> owned trait object.
>>> >
>>> > http://static.rust-lang.org/doc/master/tutorial.html#boxes
>>> >
>>> > It's important to note that ~[T] and ~str are not owned boxes. They're
>>> just sugar for dynamic arrays, and are common containers.
>>> >
>>> It's so confusing. If it's not owned box, why not remove ~? Make "str"
>>> default be dynamic should OK.
>>>
>>
>> It wouldn't be okay for every string literal to result in a heap
>> allocation.
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/002391ed/attachment.html>

From gaetan at xeberon.net  Fri Nov  8 00:46:32 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 8 Nov 2013 09:46:32 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
Message-ID: <CANK7tAH4f5cLt+eFohwnmpWoFRDhF-eSbkHbWM3dfCygsdLjcw@mail.gmail.com>

// An exchange heap (owned) stringlet exchange_crayons: ~str =
~"Black, BlizzardBlue, Blue";


can you clarify us?

thx!
-----
Gaetan



2013/11/8 Daniel Micay <danielmicay at gmail.com>

> On Thu, Nov 7, 2013 at 7:49 PM, Jason Fager <jfager at gmail.com> wrote:
>
>> Can you speak a little to the practical differences between owned boxes
>> and ~[T]/~str?  How does the difference affect how I should use each?
>
>
> I wrote the section on owned boxes in the tutorial currently in master, so
> I would suggest reading that. It's very rare for there to be a use case for
> an owned box outside of a recursive data structure or plugin system (traits
> as objects).
>
> The coverage in the tutorial of vectors/strings is not only lacking in
> depth but is also *incorrect*, so I understand why there's a lot of
> confusion about them.
>
> Vectors/strings are containers, and aren't connected to owned boxes any
> more than HashMap/TreeMap/TrieMap. I would prefer it if the syntactic sugar
> didn't exist and we just had generic container literals, because it seems
> to end up causing a lot of confusion.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/1a2bff8f/attachment-0001.html>

From philippe.delrieu at free.fr  Fri Nov  8 00:49:00 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 09:49:00 +0100
Subject: [rust-dev] zmq and Rust task
Message-ID: <527CA57C.1050604@free.fr>

Hello,

I don't know if it's the right place to ask but I didn't find any 
information on zmq side.
I found a strange behaviour using zmq rust binding. I start a task that 
loop and after I start another task that bind a port and way to receive 
a message. The zmq recv call block the first task that run only when the 
second task is receiving a message.

The only way I found is to use the ZMQ_NOBLOCK (1) flag but I found 
strange that a blocked task can block all other task.

I test on linux (Ubuntu 1204) with the master trunk of Rust (cloned on 
10/20/13) and the trunk of rust-zmq. My version of zmq is 3.2.4.

Any idea?

The code :

extern mod extra;
extern mod zmq;

use std::rt::io::timer;

#[main]
fn main() {
     println("hello?");

     do spawn ||    {
         loop {
              timer::sleep(500);
             println("coucou");
         }
     }

     do spawn || {
        let context = zmq::Context::new();
         let responder = context.socket(zmq::REP).unwrap();

         assert!(responder.bind("tcp://*:5555").is_ok());

         let mut msg = zmq::Message::new();
         loop {
             responder.recv(&mut msg, 0);
             do msg.with_str |s| {
                 println!("Received {}", s);
             }
             responder.send_str("World", 0);
                timer::sleep(100);
         }
     }

     timer::sleep(10000);

}

Philippe Delrieu


From alex at crichton.co  Fri Nov  8 00:53:18 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 8 Nov 2013 00:53:18 -0800
Subject: [rust-dev] Access error for trait implemtation in multiple file
In-Reply-To: <527C97E2.9020904@free.fr>
References: <527C97E2.9020904@free.fr>
Message-ID: <CAFnh-me_M09VBg+A6uarm2ygfgDY0d9chqiFxbZFmNzgj0p9CQ@mail.gmail.com>

You should be careful to declare modules only once. It looks like you
have two instances of "mod actions" in the module hierarchy, and both
modules will be compiled as separate entities (although everything
will have the same name).

If you remove the `mod actions` inside of testaction.rs you should
start making some more progress. You'll probably hit some name
resolution issues, but just be sure to import the previous declaration
of the `actions` module in the top level of the crate.

On Thu, Nov 7, 2013 at 11:50 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> Hello, rust addict.
>
> I have a problem with rustc. I have 3 files.
> The first one actions.rs contains a trait declaration :
>
> pub trait Action {
>     // process the action on server side.
>     fn process(&self) -> ~str;
> }
>
> The second contains a trait implementation testaction.rs:
> mod actions;
>
>
> pub struct TestAction    {
>     actiontype: uint
> }
>
> impl actions::Action for TestAction    {
>
>     fn process(&self) -> ~str     {
>         ~""
>     }
> }
>  The third test the trait cast :
>     mod actions;
>     mod midi;
>
>                 let element : ~testaction::TestAction =
> ~testaction::TestAction{actiontype:1};
>                 let actelm: ~actions::Action = element as ~actions::Action;
> //error here
>                 println("process element :" + actelm.process());
> => generate  error: failed to find an implementation of trait
>
>                 let actelm: ~testaction::actions::Action = element as
> ~testaction::actions::Action;  //error here
>                 println("process element :" + actelm.process());
> => generate error: trait `Action` is inaccessible
>
> If I put testaction content in the test file rustc compile.
>
> Any idea?
>
> Philippe Delrieu
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From danielmicay at gmail.com  Fri Nov  8 00:53:41 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 03:53:41 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
Message-ID: <CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>

On Fri, Nov 8, 2013 at 3:43 AM, Gaetan <gaetan at xeberon.net> wrote:

> I agree, I don't understand the syntax here.
>
> Look at the Url class:
>
>
> pub struct Url {
>     scheme: ~str,
>     user: Option<UserInfo>,
>     host: ~str,
>     port: Option<~str>,
>     path: ~str,
>     query: Query,
>     fragment: Option<~str>
> }
>
> pub type Query = ~[(~str, ~str)];
>
> fn split_char_first(s: &str, c: char) -> (~str, ~str) {
>     ...
>     if index+mat == len {
>         return (s.slice(0, index).to_owned(), ~"");
>     }
> }
>
>
> Isn't simpler, and easier to read, if we write it
>
>
> pub struct Url {
>     scheme: str,
>     user: Option<UserInfo>,
>     host: str,
>     port: Option<str>,
>     path: str,
>     query: Query,
>     fragment: Option<str>
> }
>
> pub type Query = [(str, str)];
>
> fn split_char_first(s: &str, c: char) -> (str, str) {
>     ...
>     if index+mat == len {
>         return (s.slice(0, index).to_owned(), "");
>     }
> }
>
>
> KISS !
>

It couldn't be called `str`, because `&str` is a slice.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/ab43df36/attachment.html>

From danielmicay at gmail.com  Fri Nov  8 01:01:46 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 04:01:46 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAH4f5cLt+eFohwnmpWoFRDhF-eSbkHbWM3dfCygsdLjcw@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
	<CANK7tAH4f5cLt+eFohwnmpWoFRDhF-eSbkHbWM3dfCygsdLjcw@mail.gmail.com>
Message-ID: <CA+DvKQKVHdX9RgecQxVQPfq_cX+CgvSeD13UJshdaOqt0z1=bA@mail.gmail.com>

On Fri, Nov 8, 2013 at 3:46 AM, Gaetan <gaetan at xeberon.net> wrote:

> // An exchange heap (owned) stringlet exchange_crayons: ~str = ~"Black, BlizzardBlue, Blue";
>
>
> can you clarify us?
>
> thx!
> -----
> Gaetan
>

I suggest ignoring the string/vector section in the tutorial because it's
misleading and in some places incorrect.

I'll send in a pull request removing the incorrect information.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/e2fcccd5/attachment.html>

From gaetan at xeberon.net  Fri Nov  8 01:05:38 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 8 Nov 2013 10:05:38 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQKVHdX9RgecQxVQPfq_cX+CgvSeD13UJshdaOqt0z1=bA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
	<CANK7tAH4f5cLt+eFohwnmpWoFRDhF-eSbkHbWM3dfCygsdLjcw@mail.gmail.com>
	<CA+DvKQKVHdX9RgecQxVQPfq_cX+CgvSeD13UJshdaOqt0z1=bA@mail.gmail.com>
Message-ID: <CANK7tAHerMCrn37jrgY62Y+dg9n6S0rRK2OUzvVo-OUyH9x-Jg@mail.gmail.com>

I think a clear paragraph on these cases (~ and ~[]) will help a lot the
understanding of this subtlety...

-----
Gaetan



2013/11/8 Daniel Micay <danielmicay at gmail.com>

> On Fri, Nov 8, 2013 at 3:46 AM, Gaetan <gaetan at xeberon.net> wrote:
>
>>
>> // An exchange heap (owned) stringlet exchange_crayons: ~str = ~"Black, BlizzardBlue, Blue";
>>
>>
>> can you clarify us?
>>
>> thx!
>> -----
>> Gaetan
>>
>
> I suggest ignoring the string/vector section in the tutorial because it's
> misleading and in some places incorrect.
>
> I'll send in a pull request removing the incorrect information.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/98113914/attachment.html>

From danielmicay at gmail.com  Fri Nov  8 02:07:24 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 05:07:24 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAHerMCrn37jrgY62Y+dg9n6S0rRK2OUzvVo-OUyH9x-Jg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
	<CANK7tAH4f5cLt+eFohwnmpWoFRDhF-eSbkHbWM3dfCygsdLjcw@mail.gmail.com>
	<CA+DvKQKVHdX9RgecQxVQPfq_cX+CgvSeD13UJshdaOqt0z1=bA@mail.gmail.com>
	<CANK7tAHerMCrn37jrgY62Y+dg9n6S0rRK2OUzvVo-OUyH9x-Jg@mail.gmail.com>
Message-ID: <CA+DvKQLZS8rRRKna7qa0Xe_K3ckiuh4VTJSCJQYgejfXUpSQpA@mail.gmail.com>

On Fri, Nov 8, 2013 at 4:05 AM, Gaetan <gaetan at xeberon.net> wrote:

> I think a clear paragraph on these cases (~ and ~[]) will help a lot the
> understanding of this subtlety...
>
> -----
> Gaetan
>

Here are the changes:  https://github.com/mozilla/rust/pull/10354
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/8188bd7e/attachment-0001.html>

From niko at alum.mit.edu  Fri Nov  8 03:24:24 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 8 Nov 2013 06:24:24 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
Message-ID: <20131108112424.GB23082@Mr-Bennet>

On Thu, Nov 07, 2013 at 04:48:06PM -0500, Daniel Micay wrote:
> Owned boxes shouldn't be commonly used. There's close to no reason to use
> one for anything but a recursive data structure or in rare cases for an
> owned trait object.

I don't really agree with this statement. I agree that those are the
two cases an owned pointer is mandatory, and that the choice between
`T` and `~T` is a matter of optimization, and hence something that
should be measured.

However, I don't think it's *so* unusual that one might want
pointer-sized values. Off the top of my head, here are some more
scenarios where owned pointers certainly make sense:

1. Options, particularly those that are frequently none.
   `Option<~HashMap<...>>` is a single word in size. If it is
   `None`, that's just a NULL pointer.

2. Enum variants. The size of an enum is the size of its largest
   variant. If you have:

       enum Foo {
           Opt1(uint),
           Opt2(HashMap<...>),
           Opt3(uint, uint, uint),
       }

   You are potentially wasting a lot of space, unless `Opt1` is very
   rare. You'd be better off doing something like:

       enum Foo {
           Opt1(uint),
           Opt2(~HashMap<...>),
           Opt3(~Opt3)
       }

       struct Opt3 { uint, uint, uint }




Niko

From niko at alum.mit.edu  Fri Nov  8 03:33:23 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 8 Nov 2013 06:33:23 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
Message-ID: <20131108113323.GC23082@Mr-Bennet>

On Fri, Nov 08, 2013 at 07:32:02AM +0800, Liigo Zhuang wrote:
> It's so confusing. If it's not owned box, why not remove ~? Make "str"
> default be dynamic should OK.

I am not sure why Daniel says that a `~str` or `~[]` is not an "owned
box". I guess he's using the term in some specific way. I consider
`~str` and `~[]` to be exactly the same as any other `~T` value in
usage and semantics. They are allocated on the same heap, moved from
place to place, and freed at the same time, etc.

The difference between a type like `str` or `[T]` and other types is
that `str` and `[T]` are actually a series of values: `u8` bytes and
`T` values respectively. This entails a change in representation and
is also the reason that one *must* use a pointer to refer to them,
because the number of values is not known and hence the compiler can't
calculate the size of the value.

Note that we are to some extent evolving how we handle dynamically
sized types like `str` and `[]`. Right now they are quite second class
(you can't impl them etc) but that will change. Nonetheless, it will
remain true that you can never have a *value* of type `str` or `[]`,
but most always use a pointer (either `~[]` or `&[]`).

Also note that a type like `~[T]` is in fact going to be represented
not as a single pointer but rather three pointers, thanks to work by
Daniel in fact.



Niko

From niko at alum.mit.edu  Fri Nov  8 03:37:44 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 8 Nov 2013 06:37:44 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAFEbTaUhERRZ=48Ei4rfibcDW0y1oFmdBT7gX9EVJV70oPCrUg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CA+DvKQKLrce0EJSv+vyhPkSnb1Fc5xeM3Rq429m0vyS9Kb7Jag@mail.gmail.com>
	<CAFEbTaUhERRZ=48Ei4rfibcDW0y1oFmdBT7gX9EVJV70oPCrUg@mail.gmail.com>
Message-ID: <20131108113744.GD23082@Mr-Bennet>

On Thu, Nov 07, 2013 at 08:40:27PM -0500, Jason Fager wrote:
> Let me ask another way:  what's wrong with thinking of ~ just as meaning
> "allocate to the heap and subject to move semantics"?  When would that
> simplification bite me in the ass regarding owned boxes vs strs/vecs?

I don't consider that to be a simplification, really. It sounds about
right to me. Of course a `~` pointer is not the only way to have move
semantics; any destructor will do.


Niko

From danielmicay at gmail.com  Fri Nov  8 03:46:37 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 06:46:37 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <20131108112424.GB23082@Mr-Bennet>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<20131108112424.GB23082@Mr-Bennet>
Message-ID: <CA+DvKQKW1fywo59VDg651En2qj6aa8T5h_kKX_PfdJMc28w1wA@mail.gmail.com>

On Fri, Nov 8, 2013 at 6:24 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Thu, Nov 07, 2013 at 04:48:06PM -0500, Daniel Micay wrote:
> > Owned boxes shouldn't be commonly used. There's close to no reason to use
> > one for anything but a recursive data structure or in rare cases for an
> > owned trait object.
>
> I don't really agree with this statement. I agree that those are the
> two cases an owned pointer is mandatory, and that the choice between
> `T` and `~T` is a matter of optimization, and hence something that
> should be measured.
>
> However, I don't think it's *so* unusual that one might want
> pointer-sized values. Off the top of my head, here are some more
> scenarios where owned pointers certainly make sense:
>
> 1. Options, particularly those that are frequently none.
>    `Option<~HashMap<...>>` is a single word in size. If it is
>    `None`, that's just a NULL pointer.
>
> 2. Enum variants. The size of an enum is the size of its largest
>    variant. If you have:
>
>        enum Foo {
>            Opt1(uint),
>            Opt2(HashMap<...>),
>            Opt3(uint, uint, uint),
>        }
>
>    You are potentially wasting a lot of space, unless `Opt1` is very
>    rare. You'd be better off doing something like:
>
>        enum Foo {
>            Opt1(uint),
>            Opt2(~HashMap<...>),
>            Opt3(~Opt3)
>        }
>
>        struct Opt3 { uint, uint, uint }
>
>
>
>
> Niko
>

I don't think the need to do micro-optimizations like this is *common*
though. It gets to the point where you're optimizing for the
characteristics of a specific allocator because they use different size
class buckets so trusting a profiler on one platform isn't enough.

There's a very real cost to the indirection, extra pointers in the CPU
cache, and all the landing pad stuff that ends up generated. I don't deny
that indirection can be useful for optimization, but it's unintuitive and
often not a portable improvement.

In the Boxes section I wrote for the tutorial, it includes this:

> In uncommon cases, the indirection can provide a performance gain or
memory reduction by making values smaller. However, unboxed values should
almost always be preferred.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/e3d7a84a/attachment.html>

From philippe.delrieu at free.fr  Fri Nov  8 04:15:59 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 13:15:59 +0100
Subject: [rust-dev] Access error for trait implemtation in multiple file
In-Reply-To: <CAFnh-me_M09VBg+A6uarm2ygfgDY0d9chqiFxbZFmNzgj0p9CQ@mail.gmail.com>
References: <527C97E2.9020904@free.fr>
	<CAFnh-me_M09VBg+A6uarm2ygfgDY0d9chqiFxbZFmNzgj0p9CQ@mail.gmail.com>
Message-ID: <527CD5FF.60304@free.fr>

hanks for your fast answer.
I've made some test and if I remove mod actions; in testaction.rs I have 
the error: unresolved name impl actions::Action for TestAction in 
testaction.rs
If I remove the mod actions; and keep the mod testaction; in the test.rs 
I have unresolved name in the line let actelm: ~actions::Action = 
element as ~actions::Action; for actions::Action.

I don't see what to do!!

I didn't fully understand the module management but even if I made 
something wrong rustc in my opinion shouldn't load the same module twice 
and if a module is load once it should use it for all. It make me think 
about I#ifndef in C.

Philippe Delrieu


Le 08/11/2013 09:53, Alex Crichton a ?crit :
> You should be careful to declare modules only once. It looks like you
> have two instances of "mod actions" in the module hierarchy, and both
> modules will be compiled as separate entities (although everything
> will have the same name).
>
> If you remove the `mod actions` inside of testaction.rs you should
> start making some more progress. You'll probably hit some name
> resolution issues, but just be sure to import the previous declaration
> of the `actions` module in the top level of the crate.
>
> On Thu, Nov 7, 2013 at 11:50 PM, Philippe Delrieu
> <philippe.delrieu at free.fr> wrote:
>> Hello, rust addict.
>>
>> I have a problem with rustc. I have 3 files.
>> The first one actions.rs contains a trait declaration :
>>
>> pub trait Action {
>>      // process the action on server side.
>>      fn process(&self) -> ~str;
>> }
>>
>> The second contains a trait implementation testaction.rs:
>> mod actions;
>>
>>
>> pub struct TestAction    {
>>      actiontype: uint
>> }
>>
>> impl actions::Action for TestAction    {
>>
>>      fn process(&self) -> ~str     {
>>          ~""
>>      }
>> }
>>   The third test the trait cast :
>>      mod actions;
>>      mod midi;
>>
>>                  let element : ~testaction::TestAction =
>> ~testaction::TestAction{actiontype:1};
>>                  let actelm: ~actions::Action = element as ~actions::Action;
>> //error here
>>                  println("process element :" + actelm.process());
>> => generate  error: failed to find an implementation of trait
>>
>>                  let actelm: ~testaction::actions::Action = element as
>> ~testaction::actions::Action;  //error here
>>                  println("process element :" + actelm.process());
>> => generate error: trait `Action` is inaccessible
>>
>> If I put testaction content in the test file rustc compile.
>>
>> Any idea?
>>
>> Philippe Delrieu
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>


From danielmicay at gmail.com  Fri Nov  8 04:39:59 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 07:39:59 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <20131108113323.GC23082@Mr-Bennet>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet>
Message-ID: <CA+DvKQJHFp-Dpi4bCW870VO_tcb61dNA9JVOQcRxQH4dZE9QFA@mail.gmail.com>

On Fri, Nov 8, 2013 at 6:33 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Fri, Nov 08, 2013 at 07:32:02AM +0800, Liigo Zhuang wrote:
> > It's so confusing. If it's not owned box, why not remove ~? Make "str"
> > default be dynamic should OK.
>
> I am not sure why Daniel says that a `~str` or `~[]` is not an "owned
> box". I guess he's using the term in some specific way. I consider
> `~str` and `~[]` to be exactly the same as any other `~T` value in
> usage and semantics. They are allocated on the same heap, moved from
> place to place, and freed at the same time, etc.
>
> The difference between a type like `str` or `[T]` and other types is
> that `str` and `[T]` are actually a series of values: `u8` bytes and
> `T` values respectively. This entails a change in representation and
> is also the reason that one *must* use a pointer to refer to them,
> because the number of values is not known and hence the compiler can't
> calculate the size of the value.
>
> Note that we are to some extent evolving how we handle dynamically
> sized types like `str` and `[]`. Right now they are quite second class
> (you can't impl them etc) but that will change. Nonetheless, it will
> remain true that you can never have a *value* of type `str` or `[]`,
> but most always use a pointer (either `~[]` or `&[]`).
>
> Also note that a type like `~[T]` is in fact going to be represented
> not as a single pointer but rather three pointers, thanks to work by
> Daniel in fact.
>
>
>
> Niko
>

By owned box I just mean a type you can pass to `fn foo<T>(x: ~T) { }`
rather than something that's owned and has a heap allocation. Most of the
other containers (hashmap, treemap, trie, ringbuf, priority_queue) are also
owned, sendable and have a destructor.

In my opinion, it would be better to have stronger support for library
containers and only have vector/string slices built-in to the language.
Stronger support would entail generic container literals, overloading
auto-slicing and a rooting API for the GC (when we get one).

There are good reasons to write another vector type, such as allocator
support, optimizing for small vectors or ABI compatibility with a foreign
library's vector type to avoid copying between the API boundary.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/e6c61438/attachment-0001.html>

From philippe.delrieu at free.fr  Fri Nov  8 04:52:00 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 13:52:00 +0100
Subject: [rust-dev] zmq and Rust task
Message-ID: <527CDE70.5090601@free.fr>

I found the problem. Rust schedules task in the same thread. If I stop 
the thread (the recv call sleep I think), every task stop.
So I read the doc and I see the spawn_sched method that start a new 
scheluder in a new thread.

I replace the do spawn with do 
std::task::spawn_sched(std::task::SingleThreaded) and now it work.

Philippe Delrieu



From niko at alum.mit.edu  Fri Nov  8 05:31:24 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 8 Nov 2013 08:31:24 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQJHFp-Dpi4bCW870VO_tcb61dNA9JVOQcRxQH4dZE9QFA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet>
	<CA+DvKQJHFp-Dpi4bCW870VO_tcb61dNA9JVOQcRxQH4dZE9QFA@mail.gmail.com>
Message-ID: <20131108133124.GB29803@Mr-Bennet>

On Fri, Nov 08, 2013 at 07:39:59AM -0500, Daniel Micay wrote:
> By owned box I just mean a type you can pass to `fn foo<T>(x: ~T) { }`
> rather than something that's owned and has a heap allocation.

Once the DST work is done, you will be able to pass a ~[T] to a
function like `fn foo<T>(x: ~T) { }`.


Niko

From erick.tryzelaar at gmail.com  Fri Nov  8 05:38:08 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Fri, 8 Nov 2013 08:38:08 -0500
Subject: [rust-dev] zmq and Rust task
In-Reply-To: <527CDE70.5090601@free.fr>
References: <527CDE70.5090601@free.fr>
Message-ID: <CALdfqQ+-_QzXQO89QqBeNPCeJ9CWY+L+E===o1=1X0BXwFfiNQ@mail.gmail.com>

(I maintain the bindings and this mailing list is fine for now. Bug reports
work too)

Right now rust-zmq is a pretty straightforward binding of the zeromq
library, and is not integrated with rust's scheduler. So it's not yet
preventing the user from two tasks from deadlocking. The only safe way to
deal with that is to spawn those tasks off in their own thread.

The best thing would be for us to write our own zmq implementation in rust,
but that'll take quite a while to write. Or perhaps there is some way we
can feed the ZMQ_FD of a socket to libuv to protect against task
deadlocking.

On Friday, November 8, 2013, Philippe Delrieu wrote:

> I found the problem. Rust schedules task in the same thread. If I stop the
> thread (the recv call sleep I think), every task stop.
> So I read the doc and I see the spawn_sched method that start a new
> scheluder in a new thread.
>
> I replace the do spawn with do std::task::spawn_sched(std::task::SingleThreaded)
> and now it work.
>
> Philippe Delrieu
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/7291c8a8/attachment.html>

From niko at alum.mit.edu  Fri Nov  8 06:52:22 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 8 Nov 2013 09:52:22 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQKW1fywo59VDg651En2qj6aa8T5h_kKX_PfdJMc28w1wA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<20131108112424.GB23082@Mr-Bennet>
	<CA+DvKQKW1fywo59VDg651En2qj6aa8T5h_kKX_PfdJMc28w1wA@mail.gmail.com>
Message-ID: <20131108145222.GD29803@Mr-Bennet>

On Fri, Nov 08, 2013 at 06:46:37AM -0500, Daniel Micay wrote:
> I don't think the need to do micro-optimizations like this is *common*
> though.

I honestly don't know how common or uncommon various scenarios are.
All I was doing in my e-mail was highlighting scenarios where
indirection is a good idea. I agree with you that, like anything else,
it carries cost and should not be used universally.

> It gets to the point where you're optimizing for the
> characteristics of a specific allocator because they use different size
> class buckets so trusting a profiler on one platform isn't enough.

It can get to that point, but it can easily be the case that
structures are just plain too big. As an example of *not* doing it
right, consider `ast::Expr` -- this type is currently *124 bytes* big!
This is for *every expression* in the compiler. (No wonder our memory
use is high.) I feel pretty confident we could use more indirection in
there even without having consulted the allocator bucket sizes.

In any case, the bottom line is: there is no single answer, you will
have to experiment. As a rule of thumb, I'd say that you should use
indirection (`~`) when data is "optional" -- as in, Option<T> or just
one variant of many -- so as to reduce the size for the other
case. But if the data is always present, you're *probably* better off
avoiding the `~` pointer. But both rules have exceptions.



Niko

From lists at dhardy.name  Fri Nov  8 07:47:24 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Fri, 08 Nov 2013 16:47:24 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <20131108113323.GC23082@Mr-Bennet>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet>
Message-ID: <8817533.0HqEL1HLOK@tph-l10036>

On Friday 08 November 2013 06:33:23 Niko Matsakis wrote:
> I am not sure why Daniel says that a `~str` or `~[]` is not an "owned
> box". I guess he's using the term in some specific way. I consider
> `~str` and `~[]` to be exactly the same as any other `~T` value in
> usage and semantics. They are allocated on the same heap, moved from
> place to place, and freed at the same time, etc.
> 
> The difference between a type like `str` or `[T]` and other types is
> that `str` and `[T]` are actually a series of values: `u8` bytes and
> `T` values respectively. This entails a change in representation and
> is also the reason that one *must* use a pointer to refer to them,
> because the number of values is not known and hence the compiler can't
> calculate the size of the value.
> 
> Note that we are to some extent evolving how we handle dynamically
> sized types like `str` and `[]`. Right now they are quite second class
> (you can't impl them etc) but that will change. Nonetheless, it will
> remain true that you can never have a *value* of type `str` or `[]`,
> but most always use a pointer (either `~[]` or `&[]`).
> 
> Also note that a type like `~[T]` is in fact going to be represented
> not as a single pointer but rather three pointers, thanks to work by
> Daniel in fact.

What's wrong with sticking with convention here? E.g. C++'s `string` and 
`vector<T>` are objects containing two or three pointers. D's arrays and 
`string` act the same way. Even C's dynamic arrays (`int x[]`) can be thought 
of the same way (if one avoids thinking of them as pointers).

So why not consider `str` and `[T]` conglomerates of a fixed size containing 
the pointers (start, length and capacity or whatever) needed? Semantically 
it's the same while syntactically it's simpler.

Slices will need new names of course, but I think the resulting decrease in 
confusion will be worth it. (D's developers tried to go the other way, with 
all arrays and slices being effectively copy-on-write slices, before realising 
that discrete array/slices types _were_ needed.)

DH
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/046289fa/attachment.sig>

From gaetan at xeberon.net  Fri Nov  8 07:50:48 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 8 Nov 2013 16:50:48 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <8817533.0HqEL1HLOK@tph-l10036>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
Message-ID: <CANK7tAFznyP3VQJZ21S-TEVt6_uyn_R-eQWGQ47xRw=hBC6bpQ@mail.gmail.com>

I agree

-----
Gaetan



2013/11/8 Diggory Hardy <lists at dhardy.name>

> On Friday 08 November 2013 06:33:23 Niko Matsakis wrote:
> > I am not sure why Daniel says that a `~str` or `~[]` is not an "owned
> > box". I guess he's using the term in some specific way. I consider
> > `~str` and `~[]` to be exactly the same as any other `~T` value in
> > usage and semantics. They are allocated on the same heap, moved from
> > place to place, and freed at the same time, etc.
> >
> > The difference between a type like `str` or `[T]` and other types is
> > that `str` and `[T]` are actually a series of values: `u8` bytes and
> > `T` values respectively. This entails a change in representation and
> > is also the reason that one *must* use a pointer to refer to them,
> > because the number of values is not known and hence the compiler can't
> > calculate the size of the value.
> >
> > Note that we are to some extent evolving how we handle dynamically
> > sized types like `str` and `[]`. Right now they are quite second class
> > (you can't impl them etc) but that will change. Nonetheless, it will
> > remain true that you can never have a *value* of type `str` or `[]`,
> > but most always use a pointer (either `~[]` or `&[]`).
> >
> > Also note that a type like `~[T]` is in fact going to be represented
> > not as a single pointer but rather three pointers, thanks to work by
> > Daniel in fact.
>
> What's wrong with sticking with convention here? E.g. C++'s `string` and
> `vector<T>` are objects containing two or three pointers. D's arrays and
> `string` act the same way. Even C's dynamic arrays (`int x[]`) can be
> thought
> of the same way (if one avoids thinking of them as pointers).
>
> So why not consider `str` and `[T]` conglomerates of a fixed size
> containing
> the pointers (start, length and capacity or whatever) needed? Semantically
> it's the same while syntactically it's simpler.
>
> Slices will need new names of course, but I think the resulting decrease in
> confusion will be worth it. (D's developers tried to go the other way, with
> all arrays and slices being effectively copy-on-write slices, before
> realising
> that discrete array/slices types _were_ needed.)
>
> DH
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/fd8993ea/attachment-0001.html>

From igor at mir2.org  Fri Nov  8 08:47:28 2013
From: igor at mir2.org (Igor Bukanov)
Date: Fri, 8 Nov 2013 17:47:28 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <8817533.0HqEL1HLOK@tph-l10036>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
Message-ID: <CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>

>  C++'s `string` and `vector<T>` are objects containing two or three pointers.

For that one pays performance penalty in C++ as string and vector
instances are passed by references resulting in double indirection
when accessing the elements. I suppose it could help to think about
strings in Rust similar to variable-sized structs in C like:

struct MyString {
    unsigned int bytelength;
    unsigned int data[];
};

As in Rust such struct cannot be instantiated and one typically uses
malloc/alloca to allocate instances and then just pass around the
resulting pointers.

From denis.spir at gmail.com  Fri Nov  8 09:26:49 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 08 Nov 2013 18:26:49 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
Message-ID: <527D1ED9.8000008@gmail.com>

On 11/08/2013 05:47 PM, Igor Bukanov wrote:
>>   C++'s `string` and `vector<T>` are objects containing two or three pointers.
>
> For that one pays performance penalty in C++ as string and vector
> instances are passed by references resulting in double indirection
> when accessing the elements. I suppose it could help to think about
> strings in Rust similar to variable-sized structs in C like:
>
> struct MyString {
>      unsigned int bytelength;
>      unsigned int data[];
> };
>
> As in Rust such struct cannot be instantiated and one typically uses
> malloc/alloca to allocate instances and then just pass around the
> resulting pointers.

I like this version precisely for the reason it avoids double indirection. I use 
it whenever I need "weighted strings" in C (strings that know their weight, 
Pascal strings in fact) [1]. It works fine, is easy on the implementation side, 
just terribly annoying w/o syntactic support. Same for arrays, both fixed (but 
variable, in the sense of not predefined) and dynamic size.
It's all fine in my view for a language like Rust, provided it remains an 
implementation choice. Meaning, whether the representation of say a static array 
is a {p, n} struct or such a variable-sized structs is transparent on the 
language side.

What are the present implementations of strings and arrays in Rust? And what 
about fixed size (esp for strings)?

Denis

[1] Actually, I rather just use a pointer, with the size written before the 
first string byte or array item, like true Pascal strings, but the result is the 
same.

From pcwalton at mozilla.com  Fri Nov  8 09:29:37 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 09:29:37 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <8817533.0HqEL1HLOK@tph-l10036>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>
Message-ID: <527D1F81.4030503@mozilla.com>

On 11/8/13 7:47 AM, Diggory Hardy wrote:
> What's wrong with sticking with convention here? E.g. C++'s `string` and
> `vector<T>` are objects containing two or three pointers. D's arrays and
> `string` act the same way. Even C's dynamic arrays (`int x[]`) can be thought
> of the same way (if one avoids thinking of them as pointers).

Because:

* We need slices in the language. They're important for soundness.

* We need dynamically sized types in the language in order to be sound 
around first-class trait objects.

* Given that we need slices, and we need dynamically-sized types, we can 
avoid introducing more concepts in the language by treating slices as 
just a special case of a dynamically-sized type. That is, a slice is 
nothing more than *a pointer to a dynamically-sized type*.

* The pointer sigil is notated `&`, and the dynamically-sized type is 
`[int]`. So the resulting notation is `&[int]`.

You can see slices as just pointers with a length attached; i.e. a 
pointer to multiple contiguous values. In fact, Cyclone called them "fat 
pointers" instead of "slices". In Cyclone, you wrote a slice as `int 
*fat`. (Notice the similarity to `&[int]`.)

Note that not all of this is implemented today, which is leading to some 
of the confusion in this thread. Felix Klock is currently working on it.

Patrick


From pcwalton at mozilla.com  Fri Nov  8 09:35:00 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 09:35:00 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D1ED9.8000008@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com>
Message-ID: <527D20C4.3060107@mozilla.com>

On 11/8/13 9:26 AM, spir wrote:
> What are the present implementations of strings and arrays in Rust? And
> what about fixed size (esp for strings)?

     struct RustString {
         int size;
         int cap;
         char ptr[]
     };

     typedef *RustString ~str;

(If `~` were a valid identifier character in C, that is.) ;)

But Daniel did some performance measurements and found that this had 
suboptimal performance characteristics when compared to:

     struct ~str {
         char *ptr;
         int size;
         int cap;
     }

So we're changing to the latter.

By the way, I agree with Daniel that in an ideal world none of this 
would be baked into the compiler (except syntactically), and I would 
like to take steps to move to that world post Rust 1.0. However, given 
that we have dynamically sized types and as a result we have to define 
`~str` to mean *something*, we have to build in some representation into 
the compiler.

Patrick


From ben.striegel at gmail.com  Fri Nov  8 09:38:07 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 8 Nov 2013 12:38:07 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D20C4.3060107@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
Message-ID: <CAAvrL-=nM8ijTvOndN=yOxuJiYDj0vLNEYmjDpKh1HsgRs6okA@mail.gmail.com>

> I would like to take steps to move to that world post Rust 1.0.

I'd be interested to read more about this, and the reasons why it must be
deferred until after 1.0. Is it just "too much work to do right now", or
does it require some broader ambitious feature (HKT, etc)?


On Fri, Nov 8, 2013 at 12:35 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 9:26 AM, spir wrote:
>
>> What are the present implementations of strings and arrays in Rust? And
>> what about fixed size (esp for strings)?
>>
>
>     struct RustString {
>         int size;
>         int cap;
>         char ptr[]
>     };
>
>     typedef *RustString ~str;
>
> (If `~` were a valid identifier character in C, that is.) ;)
>
> But Daniel did some performance measurements and found that this had
> suboptimal performance characteristics when compared to:
>
>     struct ~str {
>         char *ptr;
>         int size;
>         int cap;
>     }
>
> So we're changing to the latter.
>
> By the way, I agree with Daniel that in an ideal world none of this would
> be baked into the compiler (except syntactically), and I would like to take
> steps to move to that world post Rust 1.0. However, given that we have
> dynamically sized types and as a result we have to define `~str` to mean
> *something*, we have to build in some representation into the compiler.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/b53933b1/attachment.html>

From pcwalton at mozilla.com  Fri Nov  8 09:42:09 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 09:42:09 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CAAvrL-=nM8ijTvOndN=yOxuJiYDj0vLNEYmjDpKh1HsgRs6okA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>
	<CAAvrL-=nM8ijTvOndN=yOxuJiYDj0vLNEYmjDpKh1HsgRs6okA@mail.gmail.com>
Message-ID: <527D2271.1010908@mozilla.com>

On 11/8/13 9:38 AM, Benjamin Striegel wrote:
>  > I would like to take steps to move to that world post Rust 1.0.
>
> I'd be interested to read more about this, and the reasons why it must
> be deferred until after 1.0. Is it just "too much work to do right now",
> or does it require some broader ambitious feature (HKT, etc)?

IIRC Niko mentioned that it requires higher kinded types. I hadn't 
thought too much about the precise definition of the smart pointer trait.

But it's also too much work to do right now, and doesn't seem like it's 
going to get us into much trouble regarding backwards compatibility. 
Having one ultra-common smart pointer type built into the language seems 
rather harmless. After all, in C++ there is a default `operator new`, 
and having to say `new(Unique)` would be pretty annoying for the 
commonest type of pointer.

Patrick


From denis.spir at gmail.com  Fri Nov  8 09:46:20 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 08 Nov 2013 18:46:20 +0100
Subject: [rust-dev] About owned pointer -- explicit specification
In-Reply-To: <CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
Message-ID: <527D236C.4020409@gmail.com>

On 11/08/2013 09:43 AM, Gaetan wrote:
> I agree, I don't understand the syntax here.
>
> Look at the Url class:
>
>
> pub struct Url {
>      scheme: ~str,
>      user: Option<UserInfo>,
>      host: ~str,
>      port: Option<~str>,
>      path: ~str,
>      query: Query,
>      fragment: Option<~str>
> }
>
> pub type Query = ~[(~str, ~str)];
>
> fn split_char_first(s: &str, c: char) -> (~str, ~str) {
>      ...
>      if index+mat == len {
>          return (s.slice(0, index).to_owned(), ~"");
>      }
> }
>
>
> Isn't simpler, and easier to read, if we write it
>
>
> pub struct Url {
>      scheme: str,
>      user: Option<UserInfo>,
>      host: str,
>      port: Option<str>,
>      path: str,
>      query: Query,
>      fragment: Option<str>
> }
>
> pub type Query = [(str, str)];
>
> fn split_char_first(s: &str, c: char) -> (str, str) {
>      ...
>      if index+mat == len {
>          return (s.slice(0, index).to_owned(), "");
>      }
> }
>
>
> KISS !
>
>
> -----
> Gaetan

Sure! I'd strongly support that (exactly the changes you propose).
But I thought the obligation to explicitely specify the pointer type was a 
side-effect of the variety of pointer "kinds" in Rust: If in Rust one is to able 
to choose which kind of pointer is used, then, well, we must write it down 
somewhere somehow, no?
Some of the strings or arrays above (or more generally structured data), may be 
shared, referenced from other structured thingies, in which case we'd need a 
"non-owned" pointer (probably @). Or do I misunderstand?

Somewhat related but distinct, I thought we could get rid of specifying the 
pointer type for function input: seems to be always &, no? Or &mut when changed 
inside the func, but the compiler can probably tell that; also, if the param is 
not changed, having &mut does not affect the semantics anyway... Or, if pointed 
function input is not always & / &mut, systematically, in current Rust code, 
could it be anyway, without exaggerated semantic constraint or efficiency loss?

Still related but distinct, what other uses for & (and &mut) than function input?

Denis



From denis.spir at gmail.com  Fri Nov  8 09:48:15 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 08 Nov 2013 18:48:15 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
	<CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>
Message-ID: <527D23DF.4000403@gmail.com>

On 11/08/2013 09:53 AM, Daniel Micay wrote:
> It couldn't be called `str`, because `&str` is a slice.

Why couldn't str be slices? (eg somewhat like arrays are slices in D)
Also, i don't understand literals in Rust currently. Same for static arrays.

Denis

From philippe.delrieu at free.fr  Fri Nov  8 10:00:46 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 19:00:46 +0100
Subject: [rust-dev] zmq and Rust task
In-Reply-To: <CALdfqQ+-_QzXQO89QqBeNPCeJ9CWY+L+E===o1=1X0BXwFfiNQ@mail.gmail.com>
References: <527CDE70.5090601@free.fr>
	<CALdfqQ+-_QzXQO89QqBeNPCeJ9CWY+L+E===o1=1X0BXwFfiNQ@mail.gmail.com>
Message-ID: <527D26CE.9020103@free.fr>

Hi Erick,

thanks for your reply?

The spawn_sched work fine for me. You do a great job in the binding. 
Definitely it would be very good to have a zmq implementation in Rust 
but It's a lot of work and your binding seem good enough. I'll tell you 
if I found some problems.

best

Philippe Delrieu

Le 08/11/2013 14:38, Erick Tryzelaar a ?crit :
> (I maintain the bindings and this mailing list is fine for now. Bug 
> reports work too)
>
> Right now rust-zmq is a pretty straightforward binding of the zeromq 
> library, and is not integrated with rust's scheduler. So it's not yet 
> preventing the user from two tasks from deadlocking. The only safe way 
> to deal with that is to spawn those tasks off in their own thread.
>
> The best thing would be for us to write our own zmq implementation in 
> rust, but that'll take quite a while to write. Or perhaps there is 
> some way we can feed the ZMQ_FD of a socket to libuv to protect 
> against task deadlocking.
>
> On Friday, November 8, 2013, Philippe Delrieu wrote:
>
>     I found the problem. Rust schedules task in the same thread. If I
>     stop the thread (the recv call sleep I think), every task stop.
>     So I read the doc and I see the spawn_sched method that start a
>     new scheluder in a new thread.
>
>     I replace the do spawn with do
>     std::task::spawn_sched(std::task::SingleThreaded) and now it work.
>
>     Philippe Delrieu
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org
>     https://mail.mozilla.org/listinfo/rust-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/ee9dc5ca/attachment.html>

From pwalton at mozilla.com  Fri Nov  8 10:20:07 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 10:20:07 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D23DF.4000403@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
	<CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>
	<527D23DF.4000403@gmail.com>
Message-ID: <9701bd2d-235a-4236-937c-85b8381382ad@email.android.com>

Because then `str` would not be a dynamically sized type.

Please read the blog posts on dynamically sized types.

spir <denis.spir at gmail.com> wrote:
>On 11/08/2013 09:53 AM, Daniel Micay wrote:
>> It couldn't be called `str`, because `&str` is a slice.
>
>Why couldn't str be slices? (eg somewhat like arrays are slices in D)
>Also, i don't understand literals in Rust currently. Same for static
>arrays.
>
>Denis
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/3d144aa0/attachment.html>

From denis.spir at gmail.com  Fri Nov  8 10:38:18 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 08 Nov 2013 19:38:18 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <9701bd2d-235a-4236-937c-85b8381382ad@email.android.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
	<CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>
	<527D23DF.4000403@gmail.com>
	<9701bd2d-235a-4236-937c-85b8381382ad@email.android.com>
Message-ID: <527D2F9A.5060609@gmail.com>

On 11/08/2013 07:20 PM, Patrick Walton wrote:
> Because then `str` would not be a dynamically sized type.

(I'm not convinced --yet-- strings *must* have dynamic size at all, as I never 
need this feature even if I do quite a lot of text processing. When generating 
runtime produced strings, I'd rather concat all bits at once at the very end, 
thus knowing the final size. No support for this is needed: one never writes 
into a growable string buffer, instead always concat all at once. But this may 
be another, distinct story. And there may be use cases I'm unaware of, even 
common ones.)

> Please read the blog posts on dynamically sized types.

All right, I'll do.
PS: Except I cannot find them.
Don't seem listed in the list of blog post at 
https://github.com/mozilla/rust/wiki/Docs
Also not in the archives of your own blog at: 
http://pcwalton.github.io/blog/archives/

Denis

> spir <denis.spir at gmail.com> wrote:
>> On 11/08/2013 09:53 AM, Daniel Micay wrote:
>>> It couldn't be called `str`, because `&str` is a slice.
>>
>> Why couldn't str be slices? (eg somewhat like arrays are slices in D)
>> Also, i don't understand literals in Rust currently. Same for static
>> arrays.
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>

From igor at mir2.org  Fri Nov  8 10:50:01 2013
From: igor at mir2.org (Igor Bukanov)
Date: Fri, 8 Nov 2013 19:50:01 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D20C4.3060107@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
Message-ID: <CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>

On 8 November 2013 18:35, Patrick Walton <pcwalton at mozilla.com> wrote:
> But Daniel did some performance measurements and found that this had
> suboptimal performance characteristics when compared to:
>
>     struct ~str {
>         char *ptr;
>         int size;
>         int cap;
>     }
>
> So we're changing to the latter.

Does this mean that when ~str is passed as a parameter the compiler
copies 3 words and that makes things faster?

From loebel.marvin at gmail.com  Fri Nov  8 10:56:39 2013
From: loebel.marvin at gmail.com (=?ISO-8859-1?Q?Marvin_L=F6bel?=)
Date: Fri, 08 Nov 2013 19:56:39 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
Message-ID: <527D33E7.4040007@gmail.com>

On 11/08/2013 07:50 PM, Igor Bukanov wrote:
> On 8 November 2013 18:35, Patrick Walton <pcwalton at mozilla.com> wrote:
>> But Daniel did some performance measurements and found that this had
>> suboptimal performance characteristics when compared to:
>>
>>      struct ~str {
>>          char *ptr;
>>          int size;
>>          int cap;
>>      }
>>
>> So we're changing to the latter.
> Does this mean that when ~str is passed as a parameter the compiler
> copies 3 words and that makes things faster?
According to https://github.com/mozilla/rust/issues/8981, yes and yes 
apparently. :)

You rarely pass around a ~[T] directly anyway, usually you work with 
slices to them, which right now consist of exactly two words. (Though 
that might change to three words too for unrelated consistency reasons)

Other speed improvements come from the fact that empty vectors no longer 
allocate, and that you no longer need to dereference a pointer into heap 
memory to get the size of an vector.



From oren at ben-kiki.org  Fri Nov  8 11:33:42 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 21:33:42 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D33E7.4040007@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
Message-ID: <CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>

Now I'm confused; doesn't this mean str is fixed size, so the proposal to
just use "str" for the 3-word struct and have ~str and &str just be the
normal thing makes sense after all?

On Fri, Nov 8, 2013 at 8:56 PM, Marvin L?bel <loebel.marvin at gmail.com>wrote:

> On 11/08/2013 07:50 PM, Igor Bukanov wrote:
>
>> On 8 November 2013 18:35, Patrick Walton <pcwalton at mozilla.com> wrote:
>>
>>> But Daniel did some performance measurements and found that this had
>>> suboptimal performance characteristics when compared to:
>>>
>>>      struct ~str {
>>>          char *ptr;
>>>          int size;
>>>          int cap;
>>>      }
>>>
>>> So we're changing to the latter.
>>>
>> Does this mean that when ~str is passed as a parameter the compiler
>> copies 3 words and that makes things faster?
>>
> According to https://github.com/mozilla/rust/issues/8981, yes and yes
> apparently. :)
>
> You rarely pass around a ~[T] directly anyway, usually you work with
> slices to them, which right now consist of exactly two words. (Though that
> might change to three words too for unrelated consistency reasons)
>
> Other speed improvements come from the fact that empty vectors no longer
> allocate, and that you no longer need to dereference a pointer into heap
> memory to get the size of an vector.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/0afb3aae/attachment-0001.html>

From alex at crichton.co  Fri Nov  8 11:36:32 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 8 Nov 2013 11:36:32 -0800
Subject: [rust-dev] Access error for trait implemtation in multiple file
In-Reply-To: <527CD5FF.60304@free.fr>
References: <527C97E2.9020904@free.fr>
	<CAFnh-me_M09VBg+A6uarm2ygfgDY0d9chqiFxbZFmNzgj0p9CQ@mail.gmail.com>
	<527CD5FF.60304@free.fr>
Message-ID: <CAFnh-mc-=w5UspLmzPQShEP+0gQO57q-FFCxK63Qofp-bQQXng@mail.gmail.com>

I would recommend reading about Rust's module system at
http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
to get more familiar with how things work.

You may also want to read about how import statements work at
http://static.rust-lang.org/doc/master/rust.html#use-declarations to
get an idea of how to bring these names into scope.

In rust's module system, you don't really load modules per-se, but
rather insert them at certain points in the namespace hierarchy. It's
perfectly valid to insert the same module at multiple locations in the
hierarchy, but I agree that this may not always have the expected
behavior. This probably warrants a lint mode for this which is warn by
default about inserting the same file into the module hierarchy twice,

On Fri, Nov 8, 2013 at 4:15 AM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> hanks for your fast answer.
> I've made some test and if I remove mod actions; in testaction.rs I have the
> error: unresolved name impl actions::Action for TestAction in testaction.rs
> If I remove the mod actions; and keep the mod testaction; in the test.rs I
> have unresolved name in the line let actelm: ~actions::Action = element as
> ~actions::Action; for actions::Action.
>
> I don't see what to do!!
>
> I didn't fully understand the module management but even if I made something
> wrong rustc in my opinion shouldn't load the same module twice and if a
> module is load once it should use it for all. It make me think about
> I#ifndef in C.
>
> Philippe Delrieu
>
>
> Le 08/11/2013 09:53, Alex Crichton a ?crit :
>>
>> You should be careful to declare modules only once. It looks like you
>>
>> have two instances of "mod actions" in the module hierarchy, and both
>> modules will be compiled as separate entities (although everything
>> will have the same name).
>>
>> If you remove the `mod actions` inside of testaction.rs you should
>> start making some more progress. You'll probably hit some name
>> resolution issues, but just be sure to import the previous declaration
>> of the `actions` module in the top level of the crate.
>>
>> On Thu, Nov 7, 2013 at 11:50 PM, Philippe Delrieu
>> <philippe.delrieu at free.fr> wrote:
>>>
>>> Hello, rust addict.
>>>
>>> I have a problem with rustc. I have 3 files.
>>> The first one actions.rs contains a trait declaration :
>>>
>>> pub trait Action {
>>>      // process the action on server side.
>>>      fn process(&self) -> ~str;
>>> }
>>>
>>> The second contains a trait implementation testaction.rs:
>>> mod actions;
>>>
>>>
>>> pub struct TestAction    {
>>>      actiontype: uint
>>> }
>>>
>>> impl actions::Action for TestAction    {
>>>
>>>      fn process(&self) -> ~str     {
>>>          ~""
>>>      }
>>> }
>>>   The third test the trait cast :
>>>      mod actions;
>>>      mod midi;
>>>
>>>                  let element : ~testaction::TestAction =
>>> ~testaction::TestAction{actiontype:1};
>>>                  let actelm: ~actions::Action = element as
>>> ~actions::Action;
>>> //error here
>>>                  println("process element :" + actelm.process());
>>> => generate  error: failed to find an implementation of trait
>>>
>>>                  let actelm: ~testaction::actions::Action = element as
>>> ~testaction::actions::Action;  //error here
>>>                  println("process element :" + actelm.process());
>>> => generate error: trait `Action` is inaccessible
>>>
>>> If I put testaction content in the test file rustc compile.
>>>
>>> Any idea?
>>>
>>> Philippe Delrieu
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ben.striegel at gmail.com  Fri Nov  8 12:39:44 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Fri, 8 Nov 2013 15:39:44 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D2F9A.5060609@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CA+DvKQK7f7+j9dTOiNeuzXb221MSTutHaTn-Uerf0pMzwHUu_Q@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<CA+DvKQ+k1T_JFGnX9Ou2g51HPs1HWuHri1JJNyN-KWubUEfETg@mail.gmail.com>
	<CAFEbTaUE4sq3dTUDSojTB8n8_AJg6iHp+1HsYjHbdH5qHmXErg@mail.gmail.com>
	<CANK7tAEf71R5GtfAAVtVU5J3f0LHAqsLkmFE1RjqFfZW6-sL-Q@mail.gmail.com>
	<CA+DvKQJe=EvaGh-F-TcG36FP_WyzkvirZBREfPebuceHx_FJ6g@mail.gmail.com>
	<527D23DF.4000403@gmail.com>
	<9701bd2d-235a-4236-937c-85b8381382ad@email.android.com>
	<527D2F9A.5060609@gmail.com>
Message-ID: <CAAvrL-mrUFe4+ANEJh9HhEBiOyMWsiCs1M2mQRztmhUP2rjh_A@mail.gmail.com>

> Except I cannot find them.

The dynamically-sized type posts are sort of scattered all over Niko's
blog. You can start here:

http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/

for a general overview.


On Fri, Nov 8, 2013 at 1:38 PM, spir <denis.spir at gmail.com> wrote:

> On 11/08/2013 07:20 PM, Patrick Walton wrote:
>
>> Because then `str` would not be a dynamically sized type.
>>
>
> (I'm not convinced --yet-- strings *must* have dynamic size at all, as I
> never need this feature even if I do quite a lot of text processing. When
> generating runtime produced strings, I'd rather concat all bits at once at
> the very end, thus knowing the final size. No support for this is needed:
> one never writes into a growable string buffer, instead always concat all
> at once. But this may be another, distinct story. And there may be use
> cases I'm unaware of, even common ones.)
>
>
>  Please read the blog posts on dynamically sized types.
>>
>
> All right, I'll do.
> PS: Except I cannot find them.
> Don't seem listed in the list of blog post at https://github.com/mozilla/
> rust/wiki/Docs
> Also not in the archives of your own blog at: http://pcwalton.github.io/
> blog/archives/
>
> Denis
>
>  spir <denis.spir at gmail.com> wrote:
>>
>>> On 11/08/2013 09:53 AM, Daniel Micay wrote:
>>>
>>>> It couldn't be called `str`, because `&str` is a slice.
>>>>
>>>
>>> Why couldn't str be slices? (eg somewhat like arrays are slices in D)
>>> Also, i don't understand literals in Rust currently. Same for static
>>> arrays.
>>>
>>> Denis
>>> _______________________________________________
>>>
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>  _______________________________________________
>
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/da97f5da/attachment.html>

From philippe.delrieu at free.fr  Fri Nov  8 12:50:48 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 08 Nov 2013 21:50:48 +0100
Subject: [rust-dev] Access error for trait implemtation in multiple file
In-Reply-To: <CAFnh-mc-=w5UspLmzPQShEP+0gQO57q-FFCxK63Qofp-bQQXng@mail.gmail.com>
References: <527C97E2.9020904@free.fr>
	<CAFnh-me_M09VBg+A6uarm2ygfgDY0d9chqiFxbZFmNzgj0p9CQ@mail.gmail.com>
	<527CD5FF.60304@free.fr>
	<CAFnh-mc-=w5UspLmzPQShEP+0gQO57q-FFCxK63Qofp-bQQXng@mail.gmail.com>
Message-ID: <527D4EA8.40400@free.fr>

I solve my problem by using absolute path every where. It's ok but I 
can't use the source file in another program with another root module.

Philippe Delrieu

I've read the tutorial



Le 08/11/2013 20:36, Alex Crichton a ?crit :
> I would recommend reading about Rust's module system at
> http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
> to get more familiar with how things work.
>
> You may also want to read about how import statements work at
> http://static.rust-lang.org/doc/master/rust.html#use-declarations to
> get an idea of how to bring these names into scope.
>
> In rust's module system, you don't really load modules per-se, but
> rather insert them at certain points in the namespace hierarchy. It's
> perfectly valid to insert the same module at multiple locations in the
> hierarchy, but I agree that this may not always have the expected
> behavior. This probably warrants a lint mode for this which is warn by
> default about inserting the same file into the module hierarchy twice,
>


From pcwalton at mozilla.com  Fri Nov  8 13:22:22 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 13:22:22 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
Message-ID: <527D560E.5030807@mozilla.com>

On 11/8/13 11:33 AM, Oren Ben-Kiki wrote:
> Now I'm confused; doesn't this mean str is fixed size, so the proposal
> to just use "str" for the 3-word struct and have ~str and &str just be
> the normal thing makes sense after all?

No, `str` is not fixed-size. An *owned pointer* to a string is 
fixed-size (as all pointers are), but the string *itself* is dynamically 
sized.

The size of pointers changes based on the kind of thing they point to.

Patrick


From oren at ben-kiki.org  Fri Nov  8 14:00:12 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 00:00:12 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D560E.5030807@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
Message-ID: <CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>

So, the core question is whether we think of str as an object or as a
pointer. Either we see it as an object (with fixed size, 3 words), which
internally holds a nested pointer to a dynamically-sized region of
characters; or we see it as a direct smart pointer to this array.

The "physics" of str seem to be the former, but the abstraction presented
to the programmer is the latter. Of course, there's also value in providing
clean abstractions, but this is a leaky one. For example, it isn't very
clean to have a concrete type T which allows ~T, &T, @T, *T but forbids
having a simple T (unless one is talking about a trait, which str isn't).
It is weird and causes all sort of edge cases when trying to write generic
code.

Also, str != ~[u8] (for good reason). The internal array is hidden anyway,
so pretending to be a smart pointer to it doesn't make a lot of sense to
me. Of course there's a very related issue of whether we see a vector as a
smart pointer or as an object, so even if str was == ~[u8] it would
probably still make sense to view it as an object :-)

In general, in a system language, one wants the low-level abstractions
(such as "str") to be close to the "physics", so people would be able to
easily reason about the code behavior. This would also lend support to the
proposal of seeing str as a struct and not as a pointer.


On Fri, Nov 8, 2013 at 11:22 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 11:33 AM, Oren Ben-Kiki wrote:
>
>> Now I'm confused; doesn't this mean str is fixed size, so the proposal
>> to just use "str" for the 3-word struct and have ~str and &str just be
>> the normal thing makes sense after all?
>>
>
> No, `str` is not fixed-size. An *owned pointer* to a string is fixed-size
> (as all pointers are), but the string *itself* is dynamically sized.
>
> The size of pointers changes based on the kind of thing they point to.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/fad08ea4/attachment.html>

From pcwalton at mozilla.com  Fri Nov  8 14:04:45 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:04:45 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
Message-ID: <527D5FFD.8070008@mozilla.com>

On 11/8/13 2:00 PM, Oren Ben-Kiki wrote:
> So, the core question is whether we think of str as an object or as a
> pointer. Either we see it as an object (with fixed size, 3 words), which
> internally holds a nested pointer to a dynamically-sized region of
> characters; or we see it as a direct smart pointer to this array.
>
> The "physics" of str seem to be the former, but the abstraction
> presented to the programmer is the latter. Of course, there's also value
> in providing clean abstractions, but this is a leaky one. For example,
> it isn't very clean to have a concrete type T which allows ~T, &T, @T,
> *T but forbids having a simple T (unless one is talking about a trait,
> which str isn't). It is weird and causes all sort of edge cases when
> trying to write generic code.

You're arguing that we shouldn't have dynamically sized types, but I ask 
what your solution to `~Trait` is then.

Patrick


From pcwalton at mozilla.com  Fri Nov  8 14:06:58 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:06:58 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
Message-ID: <527D6082.7030507@mozilla.com>

On 11/8/13 2:00 PM, Oren Ben-Kiki wrote:
> Also, str != ~[u8] (for good reason). The internal array is hidden
> anyway, so pretending to be a smart pointer to it doesn't make a lot of
> sense to me. Of course there's a very related issue of whether we see a
> vector as a smart pointer or as an object, so even if str was == ~[u8]
> it would probably still make sense to view it as an object :-)

No! Read the thread! You need `&str and `&'static str` for performance 
as well as `~str`.

Patrick


From oren at ben-kiki.org  Fri Nov  8 14:08:34 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 00:08:34 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D5FFD.8070008@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D5FFD.8070008@mozilla.com>
Message-ID: <CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>

I don't follow. ~Trait is a pointer, and therefore its size is fixed. There
are checks in place to prevent using a trait as a type (there's a nice
error message from the compiler saying "using trait as a type" :-)... So
the Trait in ~Trait isn't a _type_, right? :-)

On Sat, Nov 9, 2013 at 12:04 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 2:00 PM, Oren Ben-Kiki wrote:
>
>> So, the core question is whether we think of str as an object or as a
>> pointer. Either we see it as an object (with fixed size, 3 words), which
>> internally holds a nested pointer to a dynamically-sized region of
>> characters; or we see it as a direct smart pointer to this array.
>>
>> The "physics" of str seem to be the former, but the abstraction
>> presented to the programmer is the latter. Of course, there's also value
>> in providing clean abstractions, but this is a leaky one. For example,
>> it isn't very clean to have a concrete type T which allows ~T, &T, @T,
>> *T but forbids having a simple T (unless one is talking about a trait,
>> which str isn't). It is weird and causes all sort of edge cases when
>> trying to write generic code.
>>
>
> You're arguing that we shouldn't have dynamically sized types, but I ask
> what your solution to `~Trait` is then.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/5a7c91b9/attachment-0001.html>

From pcwalton at mozilla.com  Fri Nov  8 14:09:39 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:09:39 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>
	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
Message-ID: <527D6123.4040501@mozilla.com>

On 11/8/13 2:08 PM, Oren Ben-Kiki wrote:
>
> I don't follow. ~Trait is a pointer, and therefore its size is fixed.
> There are checks in place to prevent using a trait as a type (there's a
> nice error message from the compiler saying "using trait as a type"
> :-)... So the Trait in ~Trait isn't a _type_, right? :-)

No, the `Trait` in `~Trait` is a type under the dynamically sized types 
proposal. It is a type, just a dynamically sized one.

Patrick


From oren at ben-kiki.org  Fri Nov  8 14:10:22 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 00:10:22 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6082.7030507@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
Message-ID: <CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>

Yes, the down side is another level of indirection. This could be optimized
away for &'static str, but not for &str. Good point.


On Sat, Nov 9, 2013 at 12:06 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 2:00 PM, Oren Ben-Kiki wrote:
>
>> Also, str != ~[u8] (for good reason). The internal array is hidden
>> anyway, so pretending to be a smart pointer to it doesn't make a lot of
>> sense to me. Of course there's a very related issue of whether we see a
>> vector as a smart pointer or as an object, so even if str was == ~[u8]
>> it would probably still make sense to view it as an object :-)
>>
>
> No! Read the thread! You need `&str and `&'static str` for performance as
> well as `~str`.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/a4eb7d41/attachment.html>

From oren at ben-kiki.org  Fri Nov  8 14:12:17 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 00:12:17 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6123.4040501@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D5FFD.8070008@mozilla.com>
	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
	<527D6123.4040501@mozilla.com>
Message-ID: <CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>

Is there a place where one can see new proposals (is it all in the issues
list in github and/or here, or is there a 3rd place?)

E.g. there's the whole lets-get-rid-of-@, and now is the 1st time I heard
there's a "dynamically sized types" proposal... well, other than in passing
in this thread, that is.


On Sat, Nov 9, 2013 at 12:09 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 2:08 PM, Oren Ben-Kiki wrote:
>
>>
>> I don't follow. ~Trait is a pointer, and therefore its size is fixed.
>> There are checks in place to prevent using a trait as a type (there's a
>> nice error message from the compiler saying "using trait as a type"
>> :-)... So the Trait in ~Trait isn't a _type_, right? :-)
>>
>
> No, the `Trait` in `~Trait` is a type under the dynamically sized types
> proposal. It is a type, just a dynamically sized one.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/8f4da052/attachment.html>

From banderson at mozilla.com  Fri Nov  8 14:19:30 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 08 Nov 2013 14:19:30 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6082.7030507@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
Message-ID: <527D6372.6060300@mozilla.com>

On 11/08/2013 02:06 PM, Patrick Walton wrote:
> On 11/8/13 2:00 PM, Oren Ben-Kiki wrote:
>> Also, str != ~[u8] (for good reason). The internal array is hidden
>> anyway, so pretending to be a smart pointer to it doesn't make a lot of
>> sense to me. Of course there's a very related issue of whether we see a
>> vector as a smart pointer or as an object, so even if str was == ~[u8]
>> it would probably still make sense to view it as an object :-)
>
> No! Read the thread! You need `&str and `&'static str` for performance 
> as well as `~str`.

This thread is has been running off the rails a bit. Let's all please 
take a step back. This subject is one of the most subtle areas of Rust's 
type system, is in flux, and a lot of our plans about it are scattered 
across various places and passed around through informal conversation. 
It's understandable that there's confusion and debate here.

From pcwalton at mozilla.com  Fri Nov  8 14:21:36 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:21:36 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
Message-ID: <527D63F0.1030004@mozilla.com>

On 11/8/13 2:10 PM, Oren Ben-Kiki wrote:
> Yes, the down side is another level of indirection. This could be
> optimized away for &'static str, but not for &str. Good point.

I apologize for snapping at you.

This thread has become not particularly productive. I'm welcome to 
alternative suggestions, but I'd like to suggest that any proposal needs 
to accommodate:

1. A coherent story for smart pointers to existential types in which the 
size is not known (e.g. `~Trait`).

2. Accommodation for extending the language for custom smart pointers.

3. A story for vectors, including custom ones.

4. Garbage-collected vectors and strings.

5. Lifetime-bounded pointers to array slices. Array slices must not 
allow access outside the bounds of the slice, even if those elements are 
within the original array.

6. C-like levels of efficiency for vectors and arrays, without extra 
levels of indirection.

7. The ability to push onto a unique array if capacity is available 
without copying all the elements.

8. Constant strings stored in static memory, without life-before-main.

9. Memory safety.

10. Unicode safety for strings: ensuring that all strings have valid 
UTF-8 in them at all times.

There are probably more, but that's my initial list.

I know that many people don't like the fact that, syntactically, vectors 
and strings have a sigil in front of them, but please consider that 
there are many design constraints here. What works for another language 
may not work for Rust, because of these constraints.

Note that I *am* open to other possibilities :) I don't mean to shut 
people down! But the design space here is very limited.

Patrick


From pcwalton at mozilla.com  Fri Nov  8 14:27:44 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:27:44 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>
	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
Message-ID: <527D6560.2050908@mozilla.com>

On 11/8/13 2:12 PM, Oren Ben-Kiki wrote:
> Is there a place where one can see new proposals (is it all in the
> issues list in github and/or here, or is there a 3rd place?)
>
> E.g. there's the whole lets-get-rid-of-@, and now is the 1st time I
> heard there's a "dynamically sized types" proposal... well, other than
> in passing in this thread, that is.

Here's the stuff we have on dynamically sized types (DSTs):

https://github.com/mozilla/rust/issues/6308

http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/

http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/

Notice that the representation changes discussed in Niko's initial blog 
post are out of date. We aren't planning to do them, since there doesn't 
seem to be a soundness problem with having smart pointers like like `~` 
having different representations depending on what they point to.

Patrick


From pcwalton at mozilla.com  Fri Nov  8 14:32:16 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:32:16 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6372.6060300@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>
	<527D6372.6060300@mozilla.com>
Message-ID: <527D6670.7030205@mozilla.com>

On 11/8/13 2:19 PM, Brian Anderson wrote:
> This thread is has been running off the rails a bit. Let's all please
> take a step back. This subject is one of the most subtle areas of Rust's
> type system, is in flux, and a lot of our plans about it are scattered
> across various places and passed around through informal conversation.
> It's understandable that there's confusion and debate here.

Agreed, and again, my apologies.

Patrick


From oren at ben-kiki.org  Fri Nov  8 14:37:25 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 00:37:25 +0200
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6670.7030205@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com> <527D6372.6060300@mozilla.com>
	<527D6670.7030205@mozilla.com>
Message-ID: <CADJiDhvB0coes=2wGB+FFt7QS_BEYC7Z8DmAi+MA5GkfvZd-3A@mail.gmail.com>

No need to apologize. You are quite right, this is tricky and there's a
good reason for the current design choices (perhaps there are better, but
they are far from obvious). I wish I could put more time into deep thinking
about this... which, of course, you can :-)


On Sat, Nov 9, 2013 at 12:32 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 2:19 PM, Brian Anderson wrote:
>
>> This thread is has been running off the rails a bit. Let's all please
>> take a step back. This subject is one of the most subtle areas of Rust's
>> type system, is in flux, and a lot of our plans about it are scattered
>> across various places and passed around through informal conversation.
>> It's understandable that there's confusion and debate here.
>>
>
> Agreed, and again, my apologies.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/cd7fa452/attachment-0001.html>

From dbau.pp at gmail.com  Fri Nov  8 14:43:45 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 09 Nov 2013 09:43:45 +1100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6560.2050908@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
	<527D6560.2050908@mozilla.com>
Message-ID: <527D6921.3080806@gmail.com>

On 09/11/13 09:27, Patrick Walton wrote:
> On 11/8/13 2:12 PM, Oren Ben-Kiki wrote:
>> Is there a place where one can see new proposals (is it all in the
>> issues list in github and/or here, or is there a 3rd place?)
>>
>> E.g. there's the whole lets-get-rid-of-@, and now is the 1st time I
>> heard there's a "dynamically sized types" proposal... well, other than
>> in passing in this thread, that is.
>
> Here's the stuff we have on dynamically sized types (DSTs):
>
> https://github.com/mozilla/rust/issues/6308
>
> http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/ 
>
>
> http://smallcultfollowing.com/babysteps/blog/2013/05/13/recurring-closures-and-dynamically-sized-types/ 
>
>
> Notice that the representation changes discussed in Niko's initial 
> blog post are out of date. We aren't planning to do them, since there 
> doesn't seem to be a soundness problem with having smart pointers like 
> like `~` having different representations depending on what they point 
> to.

This will make transmuting ~ to get a * (e.g., to allocate memory for 
storage in an Rc, with automatic clean-up by transmuting back to ~ on 
destruction) harder to get right, won't it?

>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From pcwalton at mozilla.com  Fri Nov  8 14:44:52 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:44:52 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6921.3080806@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>	<527D6560.2050908@mozilla.com>
	<527D6921.3080806@gmail.com>
Message-ID: <527D6964.1080508@mozilla.com>

On 11/8/13 2:43 PM, Huon Wilson wrote:
> This will make transmuting ~ to get a * (e.g., to allocate memory for
> storage in an Rc, with automatic clean-up by transmuting back to ~ on
> destruction) harder to get right, won't it?

You'll want a `Sized` bound, I think.

Patrick


From dbau.pp at gmail.com  Fri Nov  8 14:46:38 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 09 Nov 2013 09:46:38 +1100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6964.1080508@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>	<527D6560.2050908@mozilla.com>	<527D6921.3080806@gmail.com>
	<527D6964.1080508@mozilla.com>
Message-ID: <527D69CE.1080301@gmail.com>

On 09/11/13 09:44, Patrick Walton wrote:
> On 11/8/13 2:43 PM, Huon Wilson wrote:
>> This will make transmuting ~ to get a * (e.g., to allocate memory for
>> storage in an Rc, with automatic clean-up by transmuting back to ~ on
>> destruction) harder to get right, won't it?
>
> You'll want a `Sized` bound, I think.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Ah, of course. Presumably this means that `Rc<Trait>` or `Rc<str>` would 
require a separate code-path?


Huon

From pcwalton at mozilla.com  Fri Nov  8 14:47:31 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 14:47:31 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D69CE.1080301@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>	<527D6560.2050908@mozilla.com>	<527D6921.3080806@gmail.com>	<527D6964.1080508@mozilla.com>
	<527D69CE.1080301@gmail.com>
Message-ID: <527D6A03.4010700@mozilla.com>

On 11/8/13 2:46 PM, Huon Wilson wrote:
> On 09/11/13 09:44, Patrick Walton wrote:
>> On 11/8/13 2:43 PM, Huon Wilson wrote:
>>> This will make transmuting ~ to get a * (e.g., to allocate memory for
>>> storage in an Rc, with automatic clean-up by transmuting back to ~ on
>>> destruction) harder to get right, won't it?
>>
>> You'll want a `Sized` bound, I think.
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> Ah, of course. Presumably this means that `Rc<Trait>` or `Rc<str>` would
> require a separate code-path?

Right. They'll have to be separate. Maybe we'll need an `UnsizedTrait` 
or `UnsizedVector` trait as well... we'll have to see.

Patrick


From danielmicay at gmail.com  Fri Nov  8 14:48:25 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 17:48:25 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6921.3080806@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D5FFD.8070008@mozilla.com>
	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
	<527D6123.4040501@mozilla.com>
	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
	<527D6560.2050908@mozilla.com> <527D6921.3080806@gmail.com>
Message-ID: <CA+DvKQL8WbFg8enGZ0V_XTQvP99Bd-C4ZAGt19Hc6kk8hyU7zw@mail.gmail.com>

On Fri, Nov 8, 2013 at 5:43 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

>
> This will make transmuting ~ to get a * (e.g., to allocate memory for
> storage in an Rc, with automatic clean-up by transmuting back to ~ on
> destruction) harder to get right, won't it?
>

FWIW, the only reason to do that right now is to support the current
managed pointer scheme. It could be replaced by a proper rooting API.
Unique pointers don't support allocators, so any containers/pointers with
allocator support already need to abandon managed pointer support.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/23135cd7/attachment.html>

From igor at mir2.org  Fri Nov  8 15:06:51 2013
From: igor at mir2.org (Igor Bukanov)
Date: Sat, 9 Nov 2013 00:06:51 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
Message-ID: <CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>

On 8 November 2013 23:10, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> Yes, the down side is another level of indirection. This could be optimized
> away for &'static str, but not for &str. Good point.

The level of indirection comes from passing strings as &str, not just
as a plain str. But this raises the question. For immutable values
implementing &T parameter as T should not be observable from the safe
code, right? If so why not to declare that &T as a parameter is not a
pointer but rather a hint to use the fastest way to pass an instance
of T to the function. Then one can use &str as a parameter without any
performance impact due to indirection even if str itself is
fixed-sized 3-word block pointing to the heap allocated data.

From dbau.pp at gmail.com  Fri Nov  8 15:08:38 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 09 Nov 2013 10:08:38 +1100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
Message-ID: <527D6EF6.2080608@gmail.com>

On 09/11/13 10:06, Igor Bukanov wrote:
> On 8 November 2013 23:10, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>> Yes, the down side is another level of indirection. This could be optimized
>> away for &'static str, but not for &str. Good point.
> The level of indirection comes from passing strings as &str, not just
> as a plain str. But this raises the question. For immutable values
> implementing &T parameter as T should not be observable from the safe
> code, right? If so why not to declare that &T as a parameter is not a
> pointer but rather a hint to use the fastest way to pass an instance
> of T to the function. Then one can use &str as a parameter without any
> performance impact due to indirection even if str itself is
> fixed-sized 3-word block pointing to the heap allocated data.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

`&T` is pointer-sized but `T` isn't always.

(I believe that LLVM will optimise references to pass-by-value in 
certain circumstances; presumably when functions are internal to a 
compilation unit.)

Huon

From pcwalton at mozilla.com  Fri Nov  8 15:10:09 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 15:10:09 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
Message-ID: <527D6F51.5060507@mozilla.com>

On 11/8/13 3:06 PM, Igor Bukanov wrote:
> On 8 November 2013 23:10, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>> Yes, the down side is another level of indirection. This could be optimized
>> away for &'static str, but not for &str. Good point.
>
> The level of indirection comes from passing strings as &str, not just
> as a plain str. But this raises the question. For immutable values
> implementing &T parameter as T should not be observable from the safe
> code, right? If so why not to declare that &T as a parameter is not a
> pointer but rather a hint to use the fastest way to pass an instance
> of T to the function. Then one can use &str as a parameter without any
> performance impact due to indirection even if str itself is
> fixed-sized 3-word block pointing to the heap allocated data.

For one, you can pass substrings as `&str`. Those can't be optimized 
away so easily.

Patrick

From danielmicay at gmail.com  Fri Nov  8 15:11:45 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 18:11:45 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
Message-ID: <CA+DvKQLXOmWFi1DGy-qqJXVCEpDBdNT_1f1edxCTm5u=Po9zfA@mail.gmail.com>

On Fri, Nov 8, 2013 at 6:06 PM, Igor Bukanov <igor at mir2.org> wrote:

> On 8 November 2013 23:10, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> > Yes, the down side is another level of indirection. This could be
> optimized
> > away for &'static str, but not for &str. Good point.
>
> The level of indirection comes from passing strings as &str, not just
> as a plain str. But this raises the question. For immutable values
> implementing &T parameter as T should not be observable from the safe
> code, right? If so why not to declare that &T as a parameter is not a
> pointer but rather a hint to use the fastest way to pass an instance
> of T to the function. Then one can use &str as a parameter without any
> performance impact due to indirection even if str itself is
> fixed-sized 3-word block pointing to the heap allocated data.
>

The only way you could avoid pointer indirection is by making the element
length part of the type, like fixed-size vectors. For strings, there's not
really a clearly meaningful element length (bytes? code points? graphemes?).

An alternate vector/string doing small string optimization makes more sense
to me.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/e9f4dac8/attachment.html>

From igor at mir2.org  Fri Nov  8 15:13:09 2013
From: igor at mir2.org (Igor Bukanov)
Date: Sat, 9 Nov 2013 00:13:09 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6EF6.2080608@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
	<527D6EF6.2080608@gmail.com>
Message-ID: <CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>

On 9 November 2013 00:08, Huon Wilson <dbau.pp at gmail.com> wrote:
> `&T` is pointer-sized but `T` isn't always.

If the size of &T is not known, then obviously such optimization is
not applicable, The point is about &T where T is fixed-sized 1-4 word
thing.

>
> (I believe that LLVM will optimise references to pass-by-value in certain
> circumstances; presumably when functions are internal to a compilation
> unit.)

But what about declaring that such optimization is always valid and
even require it on the level of ABI?

From pcwalton at mozilla.com  Fri Nov  8 15:15:05 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 15:15:05 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>	<527D6EF6.2080608@gmail.com>
	<CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>
Message-ID: <527D7079.4080309@mozilla.com>

On 11/8/13 3:13 PM, Igor Bukanov wrote:
> On 9 November 2013 00:08, Huon Wilson <dbau.pp at gmail.com> wrote:
>> `&T` is pointer-sized but `T` isn't always.
>
> If the size of &T is not known, then obviously such optimization is
> not applicable, The point is about &T where T is fixed-sized 1-4 word
> thing.
>
>>
>> (I believe that LLVM will optimise references to pass-by-value in certain
>> circumstances; presumably when functions are internal to a compilation
>> unit.)
>
> But what about declaring that such optimization is always valid and
> even require it on the level of ABI?

I don't see how you can without defeating separate compilation. If I am 
a function:

     fn f(s: ~str) {}

It is `f`'s responsibility to free `s` at the end. That can't be done if 
this optimization has been performed.

Patrick


From danielmicay at gmail.com  Fri Nov  8 15:15:29 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 8 Nov 2013 18:15:29 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
	<527D6EF6.2080608@gmail.com>
	<CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>
Message-ID: <CA+DvKQ+9nnOT=9BdZ31CYhmWKhqR0dVLfvjmpUAvPrM3Q=hhxw@mail.gmail.com>

On Fri, Nov 8, 2013 at 6:13 PM, Igor Bukanov <igor at mir2.org> wrote:

> On 9 November 2013 00:08, Huon Wilson <dbau.pp at gmail.com> wrote:
> > `&T` is pointer-sized but `T` isn't always.
>
> If the size of &T is not known, then obviously such optimization is
> not applicable, The point is about &T where T is fixed-sized 1-4 word
> thing.
>
> >
> > (I believe that LLVM will optimise references to pass-by-value in certain
> > circumstances; presumably when functions are internal to a compilation
> > unit.)
>
> But what about declaring that such optimization is always valid and
> even require it on the level of ABI?


If you're using dynamic linking, the call overhead makes the cost of having
an extra pointer in the CPU cache irrelevant.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/017e286b/attachment.html>

From wuyunlong at msn.com  Fri Nov  8 15:31:18 2013
From: wuyunlong at msn.com (wuyunlong)
Date: Sat, 9 Nov 2013 07:31:18 +0800
Subject: [rust-dev] Help: How to execute the owned method "produce_obj"?
In-Reply-To: <mailman.24521.1383952122.24866.rust-dev@mozilla.org>
References: <mailman.24521.1383952122.24866.rust-dev@mozilla.org>
Message-ID: <COL402-EAS152845C70592D163154E8FDAFF20@phx.gbl>

struct Pool<T>{
        produce_obj : ~fn()->T,
        elements : ~[T]
}

impl<T:Send> Pool<T>{

         fn new_obj(&mut self){
              let obj = self. ... ;// Here ,how to execute method "produce_obj" ?
              self.elements.push(obj);
         }
}

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/5eb8b44b/attachment.html>

From oren at ben-kiki.org  Fri Nov  8 15:33:23 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 01:33:23 +0200
Subject: [rust-dev] Help: How to execute the owned method "produce_obj"?
In-Reply-To: <COL402-EAS152845C70592D163154E8FDAFF20@phx.gbl>
References: <mailman.24521.1383952122.24866.rust-dev@mozilla.org>
	<COL402-EAS152845C70592D163154E8FDAFF20@phx.gbl>
Message-ID: <CADJiDhsQLhWwCoS-_w58o9k+pz0PVMqtFyeQbKZ7g16v2HxypQ@mail.gmail.com>

It wouldn't be self.something because it doesn't take a self argument.
Try Pool::produce_obj::<T>(...) ?
Or add a self argument to it and then call it normally.


On Sat, Nov 9, 2013 at 1:31 AM, wuyunlong <wuyunlong at msn.com> wrote:

> struct Pool<T>{
>         produce_obj : ~fn()->T,
>         elements : ~[T]
> }
>
> impl<T:Send> Pool<T>{
>
>          fn new_obj(&mut self){
>               let obj = self. ... ;*// Here ,how to execute method
> "produce_obj" ?*
>               self.elements.push(obj);
>          }
> }
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/790eb513/attachment-0001.html>

From igor at mir2.org  Fri Nov  8 15:38:17 2013
From: igor at mir2.org (Igor Bukanov)
Date: Sat, 9 Nov 2013 00:38:17 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D7079.4080309@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
	<527D6EF6.2080608@gmail.com>
	<CADd11yUm0um1ALr0syfNa=E3=RbZfaz1P5v9qHtK7z9=yJfSNg@mail.gmail.com>
	<527D7079.4080309@mozilla.com>
Message-ID: <CADd11yWG9gSB0-kOGKrS4YijzzhNHN0NHrD2ip1BarZ7AT6ADg@mail.gmail.com>

On 9 November 2013 00:15, Patrick Walton <pcwalton at mozilla.com> wrote:
> I don't see how you can without defeating separate compilation. If I am a
> function:
>
>     fn f(s: ~str) {}
>
> It is `f`'s responsibility to free `s` at the end. That can't be done if
> this optimization has been performed.

This is about only optimizing fn f(t: &T) cases. Suppose one has a
custom 3-word struct with a destructor. Then with the current setup
one cannot hope that &T as a parameter would be just as efficient as
3-word ~str as the compiler uses an extra indirection. So the idea is
to say to the programmer: do not worry about this and always use &T as
a parameter type - the compiler will optimize it using the best mode
using internally pass-by-value if necessary.

With such optimization in place there would be no difference between
~str and struct MyStruct {s: ~str} as both ~str and &MyStruct as a
parameter generates exactly the same code.

From micah at micahchalmer.net  Fri Nov  8 15:44:35 2013
From: micah at micahchalmer.net (Micah Chalmer)
Date: Fri, 08 Nov 2013 18:44:35 -0500
Subject: [rust-dev] Help: How to execute the owned method "produce_obj"?
In-Reply-To: <CADJiDhsQLhWwCoS-_w58o9k+pz0PVMqtFyeQbKZ7g16v2HxypQ@mail.gmail.com>
References: <mailman.24521.1383952122.24866.rust-dev@mozilla.org>
	<COL402-EAS152845C70592D163154E8FDAFF20@phx.gbl>
	<CADJiDhsQLhWwCoS-_w58o9k+pz0PVMqtFyeQbKZ7g16v2HxypQ@mail.gmail.com>
Message-ID: <27ea4d97-b71c-4394-a3c6-084a18dd5696@email.android.com>

This should work:

let obj = (self.produce_obj)();


-------- Original Message --------
From: Oren Ben-Kiki <oren at ben-kiki.org>
Sent: Fri Nov 08 18:33:23 EST 2013
To: wuyunlong <wuyunlong at msn.com>
Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
Subject: Re: [rust-dev] Help: How to execute the owned method "produce_obj"?

It wouldn't be self.something because it doesn't take a self argument.
Try Pool::produce_obj::<T>(...) ?
Or add a self argument to it and then call it normally.


On Sat, Nov 9, 2013 at 1:31 AM, wuyunlong <wuyunlong at msn.com> wrote:

> struct Pool<T>{
>         produce_obj : ~fn()->T,
>         elements : ~[T]
> }
>
> impl<T:Send> Pool<T>{
>
>          fn new_obj(&mut self){
>               let obj = self. ... ;*// Here ,how to execute method
> "produce_obj" ?*
>               self.elements.push(obj);
>          }
> }
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


------------------------------------------------------------------------

_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/42e55760/attachment.html>

From oren at ben-kiki.org  Fri Nov  8 16:59:53 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 02:59:53 +0200
Subject: [rust-dev] State of private
Message-ID: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>

I find that in several cases I would like to have sibling modules access
private members, that is, allow "foo::bar::Bar" access the private members
of "foo::baz::Baz", but disallow any code in "qux::*" from accessing these
members.

Currently in these cases I am forced to expose as public stuff that really
should be private, or merge too much code into one module.

In a word, is this even possible, or is planned to be possible? I know
there have been some hot debates on visibility and accessibility and
modules and crates, and I don't want to re-open it :-) I just want to know
what the state of affairs is.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/c95b0a74/attachment.html>

From slabode at aim.com  Fri Nov  8 17:57:46 2013
From: slabode at aim.com (SiegeLord)
Date: Fri, 8 Nov 2013 20:57:46 -0500 (EST)
Subject: [rust-dev] State of private
In-Reply-To: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
Message-ID: <8D0AB0638784B86-CE8-22D7D@webmail-vm013.sysops.aol.com>

> I find that in several cases I would like to have sibling modules
> access private members, that is, allow "foo::bar::Bar" access the
> private members of "foo::baz::Baz", but disallow any code in
> "qux::*" from accessing these members.

The solution to prevent qux::* from accessing privates of bar and
baz is to introduce a private barrier module, and manually re-export
a subset of the internal API across that barrier. It'll look sort of 
like
this:

pub mod foo
{
    pub use self::barrier::bar::pub_bar;
    pub use self::barrier::baz::pub_baz;

    mod barrier
    {
        pub mod bar
        {
            pub fn priv_bar() {}
            pub fn pub_bar() { ::foo::barrier::baz::priv_baz(); }
        }

        pub mod baz
        {
            pub fn priv_baz() {}
            pub fn pub_baz() { ::foo::barrier::bar::priv_bar(); }
        }
    }
}

pub mod qux
{
    pub fn test()
    {
        // Can't do it, as barrier is private
        // ::foo::barrier::bar::priv_bar;
        ::foo::pub_bar();
        ::foo::pub_baz();
    }
}

-SL

From catamorphism at gmail.com  Fri Nov  8 18:54:33 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Fri, 8 Nov 2013 18:54:33 -0800
Subject: [rust-dev] Changing roles
Message-ID: <CADcg8==D+RmWtq4k9_Nd-yX_DodFkcojXzGAZuDz2vgMZ1a49w@mail.gmail.com>

Hi, Rustic individuals --

I'm going to be changing roles from paid contributor to Rust, to
volunteer. My last day working at Mozilla will be a week from now,
November 15.

While I still intend to contribute to Rust, after the 15th I will no
longer be the owner of rustpkg. I have been talking with other core
team members about identifying a new owner for rustpkg so that work on
it will progress, and I'm confident that we will have an arrangement
in place by the time I leave. If there are rustpkg bugs you would like
me to try to fix in my remaining week, please @-mention me
(catamorphism) in a comment on the relevant github issue.
https://etherpad.mozilla.org/Rustpkg-priorities shows my idea of the
priorities.

For those interested in participating in OPW, don't worry, almost
nothing is changing -- I'll still be the mentor for Rust. However,
Larissa Shapiro (see
https://wiki.mozilla.org/GNOME_Outreach_December2013 ) will be the
coordinator and will answer any general questions about applying to
work on a Mozilla project through OPW.

It's been truly an honor to get to work on a project like Rust as my
full-time job, due in no small part to Rust's large and vibrant
community of volunteers. It would already be motivating to know that
my work enables the range of interesting projects that people are
using Rust for. It adds another level of excitement to know that many
of those people are working on Rust, and writing applications in Rust,
for sheer pleasure, with no immediate external reward.

I'll still be on the mailing list and IRC channel, so this isn't
goodbye. If you're interested in what I'm up to next, I'll probably be
keeping track of it on my blog ( http://tim.dreamwidth.org/ ).

Cheers,
Tim

-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From alex at crichton.co  Fri Nov  8 19:31:23 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 8 Nov 2013 19:31:23 -0800
Subject: [rust-dev] State of private
In-Reply-To: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
Message-ID: <CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>

> I just want to know what the state of affairs is.

The current state of affairs in terms of visibility and privacy in the
languages is "defined and implemented with possible bugs." What's
documented in the manual/tutorial is what is intended and currently
implemented in the compiler, and if there is a deviation from those
semantics then that's a bug which needs to be fixed.

That being said, nothing is truly set in stone until we're backwards
compatible (in theory), but there's a fairly large consensus that the
current set of privacy/visibility rules are what we indeed want. I
would certainly be willing to talk about other concrete proposals! It
gets more difficult to change what we have as time goes by, but if a
new idea is lightyears better than what we currently have, it's worth
knowing about at least.

From banderson at mozilla.com  Fri Nov  8 20:41:59 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 08 Nov 2013 20:41:59 -0800
Subject: [rust-dev] Changing roles
In-Reply-To: <CADcg8==D+RmWtq4k9_Nd-yX_DodFkcojXzGAZuDz2vgMZ1a49w@mail.gmail.com>
References: <CADcg8==D+RmWtq4k9_Nd-yX_DodFkcojXzGAZuDz2vgMZ1a49w@mail.gmail.com>
Message-ID: <527DBD17.4090100@mozilla.com>

On 11/08/2013 06:54 PM, Tim Chevalier wrote:
> Hi, Rustic individuals --
>
> I'm going to be changing roles from paid contributor to Rust, to
> volunteer. My last day working at Mozilla will be a week from now,
> November 15.
>

It's been a great experience working with you, Tim. You are are an 
amazing asset to the Rust community, and a good friend. I'll see you around.

Regards,
Brian

From kevin at sb.org  Fri Nov  8 21:36:15 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 8 Nov 2013 21:36:15 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D63F0.1030004@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
Message-ID: <AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>

On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> I know that many people don't like the fact that, syntactically, vectors and strings have a sigil in front of them, but please consider that there are many design constraints here. What works for another language may not work for Rust, because of these constraints.

Personally, I find it great that they have a sigil in front of them. It reminds me that they're stored in the heap.

-Kevin

From danielmicay at gmail.com  Fri Nov  8 21:38:40 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 9 Nov 2013 00:38:40 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
Message-ID: <CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>

On Sat, Nov 9, 2013 at 12:36 AM, Kevin Ballard <kevin at sb.org> wrote:

> On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
> > I know that many people don't like the fact that, syntactically, vectors
> and strings have a sigil in front of them, but please consider that there
> are many design constraints here. What works for another language may not
> work for Rust, because of these constraints.
>
> Personally, I find it great that they have a sigil in front of them. It
> reminds me that they're stored in the heap.
>
> -Kevin


Since library containers, smart pointers and other types don't have them, I
don't think it's helpful in that regard.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/5f38f636/attachment.html>

From kevin at sb.org  Fri Nov  8 21:43:47 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 8 Nov 2013 21:43:47 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
Message-ID: <559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>

On Nov 8, 2013, at 9:38 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Nov 9, 2013 at 12:36 AM, Kevin Ballard <kevin at sb.org> wrote:
> On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> 
> > I know that many people don't like the fact that, syntactically, vectors and strings have a sigil in front of them, but please consider that there are many design constraints here. What works for another language may not work for Rust, because of these constraints.
> 
> Personally, I find it great that they have a sigil in front of them. It reminds me that they're stored in the heap.
> 
> -Kevin
> 
> Since library containers, smart pointers and other types don't have them, I don't think it's helpful in that regard.

Well no, you can't assume that the absence of a sigil means the absence of heap storage. But for types that are possibly not stored on the heap, such as str (which can be &'static str) and [T] (which can be a fixed-size stack-allocated vector), the ~ is a useful distinction.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/115efb19/attachment.html>

From pcwalton at mozilla.com  Fri Nov  8 22:14:44 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 22:14:44 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQLXOmWFi1DGy-qqJXVCEpDBdNT_1f1edxCTm5u=Po9zfA@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>	<CADd11yVW-UFRQ49SX_Ai_nf5T-qFch5qwbEUL72u-zHXn9kPNQ@mail.gmail.com>
	<CA+DvKQLXOmWFi1DGy-qqJXVCEpDBdNT_1f1edxCTm5u=Po9zfA@mail.gmail.com>
Message-ID: <527DD2D4.8010109@mozilla.com>

On 11/8/13 3:11 PM, Daniel Micay wrote:
> The only way you could avoid pointer indirection is by making the
> element length part of the type, like fixed-size vectors. For strings,
> there's not really a clearly meaningful element length (bytes? code
> points? graphemes?).
>
> An alternate vector/string doing small string optimization makes more
> sense to me.

I think it's worth thinking about how to allow for custom vector/string 
implementations in this scenario. There are a couple of directions I can 
see us going:

1. Keep `~[T]` as today and implement overloadable literal syntax for 
`SmallString`/`SmallVector`.

Or:

2. Implement things like `SmallString`/`SmallVector` as custom smart 
pointers that know how to store elements of a vector inline. These kind 
of custom smart pointers would be hard-wired to particular kinds of 
DSTs. So, for example, we could imagine:

     let x: SmallVector<[int]> = new(SmallVector) [ 1, 2, 3, 4 ];

Option (2) is intriguing to me, because it allows us to possibly get 
away with not having literal syntax and taking advantage of DSTs to get 
us the benefits of custom vector/string representations. But it seems 
too good to be true :) There may be something I'm missing...

Patrick


From oren at ben-kiki.org  Fri Nov  8 22:43:16 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 22:43:16 -0800
Subject: [rust-dev] State of private
In-Reply-To: <CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
	<CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
Message-ID: <CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>

Many thanks for the replies.

My problem is actually in accessing private methods/members of a struct
defined in a different, but "very closely related" module. It seems @
nikomatsakis <https://github.com/nikomatsakis> is saying in the final text
comment of https://github.com/mozilla/rust/issues/8215 that it is not
possible to specify methods/members that are only accessible from within a
small set of modules; they are either completely public, or private to a
single module.

Looking at the same thread, I see nobody asked about a possibility of
keeping the existing rules, but also adding a "friend" keyword at the
module level; that is, if a module foo says "friend mod bar", then the
module bar can access any private stuff in the module foo. I'm not very
enamored of the friend keyword in C++, but it seems to me that having it
only in module level greatly simplifies things. Also, in a Rust context, it
seems it would cut down on much of the boilerplate code needed by barrier
modules (which is not to say that re-exporting isn't a very useful feature
as of itself).

I don't want to re-open old discussions - is this something that was
considered and rejected before?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/dee906ef/attachment.html>

From pcwalton at mozilla.com  Fri Nov  8 22:44:41 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 22:44:41 -0800
Subject: [rust-dev] State of private
In-Reply-To: <CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>	<CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
	<CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
Message-ID: <527DD9D9.6030306@mozilla.com>

On 11/8/13 10:43 PM, Oren Ben-Kiki wrote:
> Looking at the same thread, I see nobody asked about a possibility of
> keeping the existing rules, but also adding a "friend" keyword at the
> module level; that is, if a module foo says "friend mod bar", then the
> module bar can access any private stuff in the module foo. I'm not very
> enamored of the friend keyword in C++, but it seems to me that having it
> only in module level greatly simplifies things. Also, in a Rust context,
> it seems it would cut down on much of the boilerplate code needed by
> barrier modules (which is not to say that re-exporting isn't a very
> useful feature as of itself).
>
> I don't want to re-open old discussions - is this something that was
> considered and rejected before?

Nobody has proposed it AFAIK. I personally think it's not likely to be a 
Rust 1.0 feature, but I wouldn't necessarily be opposed in general.

Patrick


From danielmicay at gmail.com  Fri Nov  8 22:49:52 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 9 Nov 2013 01:49:52 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
Message-ID: <CA+DvKQLRxZ+ks_t3h0pjLmWeiKYj3CoNB2RPnMyxSjTPYjuo-w@mail.gmail.com>

On Sat, Nov 9, 2013 at 12:43 AM, Kevin Ballard <kevin at sb.org> wrote:

>
> Well no, you can't assume that the absence of a sigil means the absence of
> heap storage. But for types that are possibly *not* stored on the heap,
> such as str (which can be &'static str) and [T] (which can be a fixed-size
> stack-allocated vector), the ~ is a useful distinction.
>
> -Kevin
>

Slices are just a view into some block of memory and are truly a low-level
building block without any incentive for reimplementation.

Rust's built-in vector/string types lack allocator support, so alternate
implementations will end up being created. There's also a need for small
vectors/strings, and perhaps reference-counted slices.

LLVM is a good example of a modern, performance-concious C++ project. Here
are the approximate counts for the various vector types:

ArrayRef: 1276
(fixed-size vectors aren't used through a C++11-style template, the number
is probably 10k or 20k)
std::vector: 3078
SmallVector: 5076

std::string: 3648
StringRef: 4596
SmallString: 493

C++11 also supports reference counted slices of memory via
`std::shared_ptr`, but I'm unsure if LLVM uses a similar type.

This would be the following set of types:

* &[T]
* [T, ..N]
* Vec<T>
* SmallVec<T, N>

* &str
* Str
* SmallStr<T, N>

* RcSlice<T>
* RcMutSlice<T>

With support for allocators like the C++ standard library, it's messier
since Rust lacks default type parameters:

* &[T]
* [T, ..N]
* Vec<T, A>
* SmallVec<T, N, A>

* &str
* Str<A>
* SmallStr<T, N, A>

* RcSlice<T, A>
* RcMutSlice<T, A>

This is what I plan on implementing for rust-core, regardless of whether I
convince anyone it's a good idea for the standard library.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/54676f53/attachment-0001.html>

From pcwalton at mozilla.com  Fri Nov  8 22:52:46 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 22:52:46 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA+DvKQLRxZ+ks_t3h0pjLmWeiKYj3CoNB2RPnMyxSjTPYjuo-w@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<CA+DvKQLRxZ+ks_t3h0pjLmWeiKYj3CoNB2RPnMyxSjTPYjuo-w@mail.gmail.com>
Message-ID: <527DDBBE.3090502@mozilla.com>

On 11/8/13 10:49 PM, Daniel Micay wrote:
> This is what I plan on implementing for rust-core, regardless of whether
> I convince anyone it's a good idea for the standard library.

I do think the Rust standard library should support allocators and small 
vector optimization, for what it's worth.

Patrick


From corey at octayn.net  Fri Nov  8 22:55:40 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 9 Nov 2013 01:55:40 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527DDBBE.3090502@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<CA+DvKQLRxZ+ks_t3h0pjLmWeiKYj3CoNB2RPnMyxSjTPYjuo-w@mail.gmail.com>
	<527DDBBE.3090502@mozilla.com>
Message-ID: <CA++BO6TdddiTdexjKqfTJPR_6KRtafOZESMeXTZw7UMZ1SHCfg@mail.gmail.com>

On Sat, Nov 9, 2013 at 1:52 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 11/8/13 10:49 PM, Daniel Micay wrote:
>>
>> This is what I plan on implementing for rust-core, regardless of whether
>> I convince anyone it's a good idea for the standard library.
>
>
> I do think the Rust standard library should support allocators and small
> vector optimization, for what it's worth.
>

Would you add default type parameters to the language or just use a
separate type for allocator-aware containers? (The third option, have
them *all* be allocator aware, makes for horrendous UI)

From pcwalton at mozilla.com  Fri Nov  8 22:58:21 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 08 Nov 2013 22:58:21 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CA++BO6TdddiTdexjKqfTJPR_6KRtafOZESMeXTZw7UMZ1SHCfg@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>	<527D63F0.1030004@mozilla.com>	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>	<CA+DvKQLRxZ+ks_t3h0pjLmWeiKYj3CoNB2RPnMyxSjTPYjuo-w@mail.gmail.com>	<527DDBBE.3090502@mozilla.com>
	<CA++BO6TdddiTdexjKqfTJPR_6KRtafOZESMeXTZw7UMZ1SHCfg@mail.gmail.com>
Message-ID: <527DDD0D.1040306@mozilla.com>

On 11/8/13 10:55 PM, Corey Richardson wrote:
> Would you add default type parameters to the language or just use a
> separate type for allocator-aware containers? (The third option, have
> them *all* be allocator aware, makes for horrendous UI)

Probably using a separate type, but I wouldn't rule out the first 
option. Mostly I just wanted to make it clear that allocators and small 
vector optimization *are* on the table for the Rust standard library.

For one thing, these are important optimizations for Web browser 
engines, and I don't want to leave that performance on the table when 
we've come so far with the lifetime/borrowing system.

Patrick


From oren at ben-kiki.org  Fri Nov  8 22:59:46 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 8 Nov 2013 22:59:46 -0800
Subject: [rust-dev] State of private
In-Reply-To: <527DD9D9.6030306@mozilla.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
	<CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
	<CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
	<527DD9D9.6030306@mozilla.com>
Message-ID: <CADJiDhsi9PZbMo7f6eMFKTE7FTNAHyCWgrjEmK8g=1PR8GeSaA@mail.gmail.com>

I added https://github.com/mozilla/rust/issues/10383 in the hope that
enough people would find it useful and it would end up in 1.0 after all :-)

In the meanwhile, I'll have to re-think my design to see if I can package
all the private members in a separate structure, or something like that.

Thanks,

Oren Ben-Kiki

On Fri, Nov 8, 2013 at 10:44 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/8/13 10:43 PM, Oren Ben-Kiki wrote:
>
>> Looking at the same thread, I see nobody asked about a possibility of
>> keeping the existing rules, but also adding a "friend" keyword at the
>> module level...
>>
>
> Nobody has proposed it AFAIK. I personally think it's not likely to be a
> Rust 1.0 feature, but I wouldn't necessarily be opposed in general.
>
> Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131108/374e584b/attachment.html>

From corey at octayn.net  Sat Nov  9 04:21:00 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 9 Nov 2013 07:21:00 -0500
Subject: [rust-dev] These Weeks in Rust
Message-ID: <CA++BO6Q0JT-22xtQRCuoU2x8r=Ac9AnR0qEZu9ApPCmGO3gyGA@mail.gmail.com>

Welcome to a mega-*This Week in Rust*. I was swamped this past week with
schoolwork, so TWiR was put off. This week's combines the past two weeks of
progress. These past two weeks were fairly exciting in terms of language and
library progress. The next few weeks should be even more exciting.


# What's cooking on master?

There were 108 PRs merged these past two weeks.

## Breaking Changes

- The very long-awaited [enum discriminant size
  patch](https://github.com/mozilla/rust/pull/9613) has landed. This will
  affect FFI. Size of enum discriminant is now configurable via the `repr`
  attribute, and will by default shrink to the smallest needed.
- The extension traits for `Reader` and `Writer` have [been transformed into
  default methods on their respective
  trait](https://github.com/mozilla/rust/pull/10079).
- Non-string literals are now
  [disallowed](https://github.com/mozilla/rust/pull/10166) in attributes.
- Type parameters are now
  [forbidden](https://github.com/mozilla/rust/pull/10189) on inner statics
  (statics inside functions).
- The interface to flush stdout [has
  changed](https://github.com/mozilla/rust/pull/10218). It was previously
  unsound by allowing aliased `&mut`.
- `Result`'s API has changed [quite a
  bit](https://github.com/mozilla/rust/pull/10119), to be more consistent with
  `Option`, and hopefully simpler.
- Linker arguments [no longer](https://github.com/mozilla/rust/pull/10199)
  propagate across crates. This means that if you link to a crate, its linker
  arguments won't be automatically added when your crate is linked.
- The memory intrinsics [have been
  simplified](https://github.com/mozilla/rust/pull/10251). A single intrinsic
  for `memcpy`/`memmove`/`memset` is now exposed, rather than one per
      platform.
- `#[link(name = "...")]` is now [taken into
  account](https://github.com/mozilla/rust/pull/10260) by rustc when creating
  build artifacts.
- `std::rt::io::file` [has been fleshed out and
  tweaked](https://github.com/mozilla/rust/pull/10179). In particular, it has
  been renamed to `std::rt::io::fs`, many previously-free functions are now
  associated functions on `std::rt::io::File`, and `FileInfo` has been renamed
  to `FileStat`.

## Other Changes

- Calling variadic functions with the C FFI [is now
  implemented](https://github.com/mozilla/rust/pull/10064). This is a pretty
  sweet change. The only thing missing in our C FFI now is unions.
- We [now have](https://github.com/mozilla/rust/pull/10243) octal numeric
  literals, for all your esoteric numeric needs!
- An `Any` type [has been added](https://github.com/mozilla/rust/pull/9967),
  and it is now possible to retrieve the object a task failed with. Previously
  tasks could only fail with a string, now they can fail with anything.
- A `concat!` syntax extension [has been
  added](https://github.com/mozilla/rust/pull/9740) for compile-time string
  concatenation.
- Timers are [now also ports](https://github.com/mozilla/rust/pull/10083), and
  the creator of a timer can cancel it.
- `proc` is [now sugar](https://github.com/mozilla/rust/pull/10132) for `~once
  fn`.
- The section in the tutorial on vectors and strings [has been
  rewritten](https://github.com/mozilla/rust/pull/10354) for correctness with
  modern Rust.
- A bunch of C++ has been removed and rewritten. [Thread
  creation](https://github.com/mozilla/rust/pull/10290), [memory
  regions](https://github.com/mozilla/rust/pull/10094) (used for debugging and
  `@`-boxes, from what I can tell), and an [unused
  `array_list`](https://github.com/mozilla/rust/pull/10163/files).
- Bounds check failures are [now marked as a cold
  path](https://github.com/mozilla/rust/pull/10113), and a `cold` [function
  attribute](https://github.com/mozilla/rust/pull/10127) has been added.
- The build system [can cross-compile to iOS
  now](https://github.com/mozilla/rust/pull/10203), even though Rust doesn't
  actually run on that platform (yet!).
- `std::rand` [now implements the Gamma
  distribution](https://github.com/mozilla/rust/pull/10223).
- Cross-crate destructor inlining [now
  works](https://github.com/mozilla/rust/pull/10242).
- A `type_id` intrinsic [has been
  added](https://github.com/mozilla/rust/pull/10182).
- Everything in the runtime that uses `libuv` has been [split into its own
  crate](https://github.com/mozilla/rust/pull/10058). This means that the
  runtime really is pluggable: you can implement your own event loop and so
  forth.

## New Contributors

Welcome to our new contributors!

- Brian
- Carol Willing
- Dirkjan Bussink
- Guillaume Pinot
- Gyorgy Andrasek
- Joshua Yanovski
- Mat Carberry
- Noufal Ibrahim
- Robert Irelan
- Tomas Sedovic
- niftynif
- sh8281.kim

At .85 new contributors a day, we'll soon dwarf every other language in the
"awesome volunteer" category.

# Weekly Meetings

Last week's
[meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-29)
discussed segmented stacks (spoiler: [they're not coming
back](https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html) )
and placement new (we want it, how do we want it?).

This week's
[meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-05)
discussed the future of libextra, more stack things, octal literals, vector
representation, and temporary ("rvalue") lifetimes.

# Announcements etc

- **Reminder from ~~the Ministry of Truth~~ ChrisMorgan**: Rust is awesome.
- Rust Sk?ne, [has an event page
  now](http://www.foocafe.org/event/a-friendly-introduction-to-rust). It will
  be December 3 at 17:30 in Foo Cafe.
- [Integermingled Parameter
  Lists](http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/),
  and [take
  2](http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/).
- [speculate](https://github.com/haxney/speculate) - a parallel speculative
  execution library.
- [mcchat](https://github.com/luqmana/mcchat) - a pure-Rust Minecraft chat
  client.

From illissius at gmail.com  Sat Nov  9 05:50:16 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 9 Nov 2013 14:50:16 +0100
Subject: [rust-dev] State of private
In-Reply-To: <CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
	<CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
	<CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
Message-ID: <CAPNUp08CzwbUV1nFkXGYSPzPb9Bc=+jXpeiHMB08acVYrGvk9w@mail.gmail.com>

On Sat, Nov 9, 2013 at 7:43 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Many thanks for the replies.
>
> My problem is actually in accessing private methods/members of a struct
> defined in a different, but "very closely related" module. It seems @
> nikomatsakis <https://github.com/nikomatsakis> is saying in the final
> text comment of https://github.com/mozilla/rust/issues/8215 that it is
> not possible to specify methods/members that are only accessible from
> within a small set of modules; they are either completely public, or
> private to a single module.
>

FWIW, I think this might also be partially addressed by my earlier proposal
to remove methods as a distinct concept, and just allow using dot-syntax
with any function? (I have a draft of a follow-up to that thread that's
been sitting there for two weeks... sigh.)

It wouldn't help with struct members though, which is interesting. Maybe
the import syntax could be extended to accomodate that?

E.g.

    mod a { pub struct Point { x: int, y: int } }

    mod b { use a::Point; } // currently exists, import all fields

    mod c { use a::Point { * }; } // also import all fields

    mod d { use a::Point { }; } // import no fields

    mod e { use a::Point { x }; } // import only x, not y

Then you could play similar games with struct fields as with items.

-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/3828d655/attachment-0001.html>

From denis.spir at gmail.com  Sat Nov  9 05:53:00 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 09 Nov 2013 14:53:00 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>	<20131108113323.GC23082@Mr-Bennet>
	<8817533.0HqEL1HLOK@tph-l10036>	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>	<527D1ED9.8000008@gmail.com>
	<527D20C4.3060107@mozilla.com>	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>	<527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D6082.7030507@mozilla.com>	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>	<527D63F0.1030004@mozilla.com>	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
Message-ID: <527E3E3C.3040108@gmail.com>

On 11/09/2013 06:43 AM, Kevin Ballard wrote:> On Nov 8, 2013, at 9:38 PM, Daniel 
Micay <danielmicay at gmail.com> wrote:
>
>> On Sat, Nov 9, 2013 at 12:36 AM, Kevin Ballard <kevin at sb.org> wrote:
>> On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>>
>>> I know that many people don't like the fact that, syntactically, vectors and strings have a sigil in front of them, but please consider that there are many design constraints here. What works for another language may not work for Rust, because of these constraints.
>>
>> Personally, I find it great that they have a sigil in front of them. It reminds me that they're stored in the heap.
>>
>> -Kevin
>>
>> Since library containers, smart pointers and other types don't have them, I don't think it's helpful in that regard.
>
> Well no, you can't assume that the absence of a sigil means the absence of heap storage. But for types that are possibly not stored on the heap, such as str (which can be &'static str) and [T] (which can be a fixed-size stack-allocated vector), the ~ is a useful distinction.
>
> -Kevin

Can we, then, even consider the opposite: having a sigil for static data (mainly 
literal strings stored in static mem, I'd say) or generally non-heap data (thus 
including eg static arrays stored on stack)? The advantage is that this restores 
coherence between all heap of heap data.
I'd use '$'! (what else can this sign be good for, anyway? ;-)

[But where should the sigil go? In front of the data literal, as in
	let stst = $"Hello, world!";
	let nums = $[1,2,3];
or in front of the type, or of the id itself?]

Also, is it at all possible, in the long term maybe, to consider letting the 
compiler choose where to store, in cases where a possible pointer is 
meaningless, that is it does not express a true reference (shared object, that 
a.x is also b.y), instead is used for technical or efficiency reasons (that 
memory is not elastic!, for avoiding copy, etc...)?

Denis

From oren at ben-kiki.org  Sat Nov  9 05:55:13 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 9 Nov 2013 05:55:13 -0800
Subject: [rust-dev] State of private
In-Reply-To: <CAPNUp08CzwbUV1nFkXGYSPzPb9Bc=+jXpeiHMB08acVYrGvk9w@mail.gmail.com>
References: <CADJiDhvHC9bsdzHeAZ1p33kF8P-B0AcOi0c6VaFZ8HF3ULRi5Q@mail.gmail.com>
	<CAFnh-mfCuVSAWs41Ytm9N+W5MRd6XiRzj83Brh77noz5Vu5=CA@mail.gmail.com>
	<CADJiDhs8YuYLKWnCviE0SYdiPvmR_5itstK5g=HeRu7HKyhFuA@mail.gmail.com>
	<CAPNUp08CzwbUV1nFkXGYSPzPb9Bc=+jXpeiHMB08acVYrGvk9w@mail.gmail.com>
Message-ID: <CADJiDhszdg-wB6ZCxCrf3W2iy=c4nH6cK1iN9uw_U-1Lg8=oEA@mail.gmail.com>

Well... you could consider each member as if it was implemented by accessor
method, and control these "methods" even if it was an actual member; of
course, also provide a the same syntax for accessing actual members and
method-defined-members... but I think this is too far from the current Rust
direction.

A friend keyword, on the other hand, should be pretty simple to implement
and is a rather minor tweak to the existing system.


On Sat, Nov 9, 2013 at 5:50 AM, G?bor Lehel <illissius at gmail.com> wrote:

>
> On Sat, Nov 9, 2013 at 7:43 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> Many thanks for the replies.
>>
>> My problem is actually in accessing private methods/members of a struct
>> defined in a different, but "very closely related" module. It seems @
>> nikomatsakis <https://github.com/nikomatsakis> is saying in the final
>> text comment of https://github.com/mozilla/rust/issues/8215 that it is
>> not possible to specify methods/members that are only accessible from
>> within a small set of modules; they are either completely public, or
>> private to a single module.
>>
>
> FWIW, I think this might also be partially addressed by my earlier
> proposal to remove methods as a distinct concept, and just allow using
> dot-syntax with any function? (I have a draft of a follow-up to that thread
> that's been sitting there for two weeks... sigh.)
>
> It wouldn't help with struct members though, which is interesting. Maybe
> the import syntax could be extended to accomodate that?
>
> E.g.
>
>     mod a { pub struct Point { x: int, y: int } }
>
>     mod b { use a::Point; } // currently exists, import all fields
>
>     mod c { use a::Point { * }; } // also import all fields
>
>     mod d { use a::Point { }; } // import no fields
>
>     mod e { use a::Point { x }; } // import only x, not y
>
> Then you could play similar games with struct fields as with items.
>
> --
> Your ship was destroyed in a monadic eruption.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/e68a296f/attachment.html>

From simon80 at gmail.com  Sat Nov  9 11:13:50 2013
From: simon80 at gmail.com (Simon Ruggier)
Date: Sat, 9 Nov 2013 14:13:50 -0500
Subject: [rust-dev] Faster communication between tasks
In-Reply-To: <CAFyaas1-s9T7+bpf+oWR1=bHE=rebGob85yuxvYngrb0_Uwssg@mail.gmail.com>
References: <CAFyaas2SBNYUvzUOsf2TBHn05dCPce8G4QNhPygQQuAX58YdKQ@mail.gmail.com>
	<52700CB8.8010706@mozilla.com>
	<CAFyaas1-s9T7+bpf+oWR1=bHE=rebGob85yuxvYngrb0_Uwssg@mail.gmail.com>
Message-ID: <CAFyaas0mEQs1hiz2rLjjLVVWSh2MH1_mAsbwFCeKC7iUB7pD6Q@mail.gmail.com>

Hi all, I've tentatively come up with a design that would allow the sender
to reallocate the buffer as necessary, with very little added performance
cost. The sending side would bear the cost of reallocation, and there would
be an extra test that receivers would have to make every time they process
an item (no extra atomic operations needed). However, it may be a few weeks
or more before I have a working implementation to demonstrate, so I figured
it might be worthwhile to mention now that I'll be working on this.

Also, I think it would be interesting to investigate doing something like
the Linux kernel's deadlock detection[1], but generalized to apply to
bounded queues, and implemented as a static check. I know little about
this, but even so, I can see how it would be an enormous amount of work. On
the other hand, I would have thought the same thing about the memory safety
rules that Rust enforces. I'm hopeful that this will eventually be possible
as well.

[1] https://www.kernel.org/doc/Documentation/lockdep-design.txt

On Wed, Oct 30, 2013 at 12:55 AM, Simon Ruggier <simon80 at gmail.com> wrote:

> On Tue, Oct 29, 2013 at 3:30 PM, Brian Anderson <banderson at mozilla.com>wrote:
>
>>  On 10/28/2013 10:02 PM, Simon Ruggier wrote:
>>
>> Greetings fellow Rustians!
>>
>> First of all, thanks for working on such a great language. I really like
>> the clean syntax, increased safety, separation of data from function
>> definitions, and freedom from having to declare duplicate method prototypes
>> in header files.
>>
>> I've been working on an alternate way to communicate between tasks in
>> Rust, following the same approach as the LMAX Disruptor.[1] I'm hoping to
>> eventually offer a superset of the functionality in the pipes API, and
>> replace them as the default communication mechanism between tasks. Just as
>> with concurrency in general, my main motivation in implementing this is to
>> improve performance. For more information about the disruptor approach,
>> there's a lot of information linked from their home page, in a variety of
>> formats.
>>
>>
>> This is really exciting work. Thanks for pursuing it. I've been
>> interested in exploring something like Disruptor in Rust. The current
>> channel types in Rust are indeed slow, and fixing them is the topic of
>> https://github.com/mozilla/rust/issues/8568.
>>
>
> I'll start paying attention to that. The Morrison & Afek 2013 paper looks
> like something I should read.
>
>
>>
>>
>> This is my first major contribution of new functionality to an
>> open-source project, so I didn't want to discuss it in advance until I had
>> a working system to demonstrate. I currently have a very basic proof of
>> concept that achieves almost two orders of magnitude better performance
>> than the pipes API. On my hardware[2], I currently see throughput of about
>> 27 million items per second when synchronizing with a double-checked wait
>> condition protocol between sender and receivers, 80+ million items with no
>> blocking (i.e. busy waiting), and anywhere from 240,000 to 600,000 when
>> using pipes. The LMAX Disruptor library gets up to 110 million items per
>> second on the same hardware (using busy waiting and yielding), so there's
>> definitely still room for significant improvement.
>>
>>
>> Those are awesome results!
>>
>
> Thanks! When I first brought it up, it was getting about 14 million with
> the busy waiting. Minimizing the number of atomic operations (even with
> relaxed memory ordering) makes a big difference in performance. The 2/3
> drop in performance with the blocking wait strategy comes from merely doing
> a read-modify-write operation on every send (it currently uses atomic swap,
> I haven't experimented with others yet). To be fair, the only result I can
> take credit for is the blocking algorithm. The other ideas are straight
> from the original disruptor.
>
>
>> I've put the code up on GitHub (I'm using rustc from master).[3]
>> Currently, single and multi-stage pipelines of receivers are supported,
>> while many features are missing, like multiple concurrent senders, multiple
>> concurrent receivers, or mutation of the items as they pass through the
>> pipeline. However, given what I have so far, now is probably the right time
>> to start soliciting feedback and advice. I'm looking for review,
>> suggestions/constructive criticism, and guidance about contributing this to
>> the Rust codebase.
>>
>>
>> I'm not deeply familiar with Disruptor, but I believe that it uses
>> bounded queues. My general feeling thus far is that, as the general 'go-to'
>> channel type, people should not be using bounded queues that block the
>> sender when full because of the potential for unexpected deadlocks. I could
>> be convinced otherwise though if it's just not possible to have reasonably
>> fast unbounded channels. Note that I don't think it's critical for the
>> general-purpose channel to be as fast as possible - it's more important to
>> be convenient.
>>
>
> Yes, it does. I'm divided on this, because unbounded queues can also lead
> to memory exhaustion and added latency, but I suspect that for many use
> cases, you're right. For performance critical code, I think there's
> probably no argument: if a queue is too large, it starts causing latency
> problems (like with bufferbloat). A queue that accepts an unlimited number
> of items is like an API that doesn't let the caller know about errors. The
> caller needs to know that there's a large queue, and adjust its behaviour.
> Because of this, I doubt any performance-critical application would find it
> truly optimal to use unbounded queues. My opinion on this is strongly
> influenced by this post:
>
> http://mechanical-sympathy.blogspot.co.uk/2012/05/apply-back-pressure-when-overloaded.html
>
> For general usage, though, I need to do more research. Any application
> where latency is relevant really should be designed to deal with
> back-pressure from queues, but there may be some batch job style use cases
> where, as you say, it isn't worth the extra effort. On the other hand, it's
> relevant to think about how deadlocks occur, and decide whether or not it's
> reasonable for developers to expect to be able to do those things. I'll
> look into this and see what I come up with.
>
> If there were some general way to mitigate the deadlock issue within the
> runtime, it would also solve this problem.
>
> As a last resort, I suspect that I could probably figure out a way to have
> the sender resize the buffer when it fills, copy the elements over, and
> then switch the consumers over to the larger buffer. I don't know if I
> could do it without affecting the fast path on the receiver side.
>
> Please keep working on this. I'm excited to see your results.
>>
>
> I appreciate the encouragement :)
>
>
>>
>> Thanks,
>> Simon
>>
>> [1] http://lmax-exchange.github.io/disruptor/
>> [2] A 2.66GHz Intel P8800 CPU running in a Thinkpad T500 on Linux x86_64
>> [3] https://github.com/sruggier/rust-disruptor
>>
>>
>> _______________________________________________
>> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/4d34dc23/attachment-0001.html>

From niko at alum.mit.edu  Sat Nov  9 11:31:40 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 9 Nov 2013 14:31:40 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D69CE.1080301@gmail.com>
References: <527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D5FFD.8070008@mozilla.com>
	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
	<527D6123.4040501@mozilla.com>
	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
	<527D6560.2050908@mozilla.com> <527D6921.3080806@gmail.com>
	<527D6964.1080508@mozilla.com> <527D69CE.1080301@gmail.com>
Message-ID: <20131109193140.GB18720@Mr-Bennet>

On Sat, Nov 09, 2013 at 09:46:38AM +1100, Huon Wilson wrote:
> Ah, of course. Presumably this means that `Rc<Trait>` or `Rc<str>`
> would require a separate code-path?

I've been thinking about this somewhat. I'm not sure if this is true.
And in fact while both `Trait` and `str` are "dynamically sized
types", they are not comparable and must be considered separately.

1. The type `Trait` is in fact not a type at all, it's shorthand for a
type that the compiler "forgot" (jargon: an "existential type"). That
is, every Every instance of `Rc<Trait>` in fact began its life as a
`Rc<T>` for some known `T`, and the user "cast away" (pun intended)
the `T` to make an object:

    Rc<T> as Rc<Trait>

At runtime, this kind of cast (which, as an aside, I hope will no
longer have to be explicit soon, it's quite tedious) pairs up the
`Rc<T>` with a vtable. So in fact `Rc<Trait>` requires no
"participation" on the part of `Rc<T>`, but we will have to figure out
some niggly details like how the compiler decides what type parameters
can be changed from `T` to `Trait` and so forth. 

2. True dynamically sized types like `[T]` and `str` are different,
because they require fat pointers in place of thin ones. Until
recently I was thinking we'd just (for now anyway) prohibit `Rc` and
`Gc` etc from being instantiated with a DST. However, I was thinking
recently that since `Rc<T>` and `Gc<T>` would build on `*T`, perhaps
we can just define `*[T]` and `*str` to be the same sort of fat
pointers, and things will work out rather nicely once everything is
monomorphized.  I have to think this over, but it's a promising idea.

There are some complications for `Gc<[T]>`; when one traverses a
pointer to this garbage-collected box, one must be sure to carry along
the length information about the vector. But this doesn't seem
unsolveable.



Niko

From niko at alum.mit.edu  Sat Nov  9 11:36:17 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 9 Nov 2013 14:36:17 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D6921.3080806@gmail.com>
References: <527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D5FFD.8070008@mozilla.com>
	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>
	<527D6123.4040501@mozilla.com>
	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>
	<527D6560.2050908@mozilla.com> <527D6921.3080806@gmail.com>
Message-ID: <20131109193617.GC18720@Mr-Bennet>

On Sat, Nov 09, 2013 at 09:43:45AM +1100, Huon Wilson wrote:
> This will make transmuting ~ to get a * (e.g., to allocate memory for
> storage in an Rc, with automatic clean-up by transmuting back to ~ on
> destruction) harder to get right, won't it?

See my other e-mail about choosing a representation for `*T`. I am
currently thinking that the representation of `~T`, `&T`, and `*T`
should be the same for all `T`. I think this addresses a number of
issues and opens up new capabilities, though it does mean an unused
"capacity" word for `&[T]` and `*[T]`. See issue #10295.

Anyway, I am not sure if I am making sense -- I'd say this calls for a
long-winded blog post. Or more likely 2 or 3. I spent some time
yesterday working out some of the details for supporting custom
allocators as well as higher-kinded types, so I've got a lot to write
about...


Niko

From denis.spir at gmail.com  Sat Nov  9 13:04:40 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 09 Nov 2013 22:04:40 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <20131109193617.GC18720@Mr-Bennet>
References: <527D33E7.4040007@gmail.com>	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>	<527D560E.5030807@mozilla.com>	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>	<527D5FFD.8070008@mozilla.com>	<CADJiDhsfugqMdKiAFuC=LssMG=Yj68L3GkGBipKC-nM8uxeRWg@mail.gmail.com>	<527D6123.4040501@mozilla.com>	<CADJiDhvvvNepTAHFSuObsHg5mPsqHjhx1+KShCpasZfG6VJPkg@mail.gmail.com>	<527D6560.2050908@mozilla.com>
	<527D6921.3080806@gmail.com> <20131109193617.GC18720@Mr-Bennet>
Message-ID: <527EA368.6070008@gmail.com>

On 11/09/2013 08:36 PM, Niko Matsakis wrote:
> See my other e-mail about choosing a representation for `*T`. I am
> currently thinking that the representation of `~T`, `&T`, and `*T`
> should be the same for all `T`. I think this addresses a number of
> issues and opens up new capabilities, though it does mean an unused
> "capacity" word for `&[T]` and `*[T]`. See issue #10295.

Well, you may need it in fact. When I did implement slices for a trial (more or 
inspired by and copying D), I used this free word as a flag (with value 0) 
saying that extension is not allowed: one cannot push items into or concatenate 
a slice. Otherwise, arrays and slices are the same kind of thing; and in my 
case, there was a single type, as in D, arrays just are "original" slices, 
slices are arrays, except one cannot extend them.
The remaining issue is, as in D again, the case of an array, of which slices 
exist, that later gets extended: in the general case (where extension requires 
realloc elsewhere), this invalids slices. Reason why I ended up concluding 
slices should only exist for fix-size thingies; anyway it's the case in practice 
afaik, since slices are extensively used (and a huge efficiency gain) on strings 
mainly.
The D design, as I see it, thus brings a low level of safety; but their goal, on 
this point, is not to reach a level as high as Rust aims, I guess. Would be 
happy to read your thoughts on such topics.

Denis

From danielmicay at gmail.com  Sat Nov  9 14:21:00 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 9 Nov 2013 17:21:00 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <527E3E3C.3040108@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<527E3E3C.3040108@gmail.com>
Message-ID: <CA+DvKQKozn28Qy-1hW_fJed3gUb_+cRJAVfFfJXyejMXLLbe5g@mail.gmail.com>

On Sat, Nov 9, 2013 at 8:53 AM, spir <denis.spir at gmail.com> wrote:

>
> Can we, then, even consider the opposite: having a sigil for static data
> (mainly literal strings stored in static mem, I'd say) or generally
> non-heap data (thus including eg static arrays stored on stack)? The
> advantage is that this restores coherence between all heap of heap data.
> I'd use '$'! (what else can this sign be good for, anyway? ;-)
>
> [But where should the sigil go? In front of the data literal, as in
>         let stst = $"Hello, world!";
>         let nums = $[1,2,3];
> or in front of the type, or of the id itself?]
>
> Also, is it at all possible, in the long term maybe, to consider letting
> the compiler choose where to store, in cases where a possible pointer is
> meaningless, that is it does not express a true reference (shared object,
> that a.x is also b.y), instead is used for technical or efficiency reasons
> (that memory is not elastic!, for avoiding copy, etc...)?
>
> Denis


All variables in Rust are stack-allocated values. A unique pointer is a
pointer stored on the stack, and may be defined as a library type.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131109/eaec79cf/attachment.html>

From matthieu.monrocq at gmail.com  Sun Nov 10 04:59:52 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 10 Nov 2013 13:59:52 +0100
Subject: [rust-dev] Faster communication between tasks
In-Reply-To: <CAFyaas0mEQs1hiz2rLjjLVVWSh2MH1_mAsbwFCeKC7iUB7pD6Q@mail.gmail.com>
References: <CAFyaas2SBNYUvzUOsf2TBHn05dCPce8G4QNhPygQQuAX58YdKQ@mail.gmail.com>
	<52700CB8.8010706@mozilla.com>
	<CAFyaas1-s9T7+bpf+oWR1=bHE=rebGob85yuxvYngrb0_Uwssg@mail.gmail.com>
	<CAFyaas0mEQs1hiz2rLjjLVVWSh2MH1_mAsbwFCeKC7iUB7pD6Q@mail.gmail.com>
Message-ID: <CAKE6Rfj9Tp1afW0zMG+D58U=tqoFOhzg_FzfD4rxOZjOZUiazw@mail.gmail.com>

On Sat, Nov 9, 2013 at 8:13 PM, Simon Ruggier <simon80 at gmail.com> wrote:

> Hi all, I've tentatively come up with a design that would allow the sender
> to reallocate the buffer as necessary, with very little added performance
> cost. The sending side would bear the cost of reallocation, and there would
> be an extra test that receivers would have to make every time they process
> an item (no extra atomic operations needed). However, it may be a few weeks
> or more before I have a working implementation to demonstrate, so I figured
> it might be worthwhile to mention now that I'll be working on this.
>
> Also, I think it would be interesting to investigate doing something like
> the Linux kernel's deadlock detection[1], but generalized to apply to
> bounded queues, and implemented as a static check. I know little about
> this, but even so, I can see how it would be an enormous amount of work. On
> the other hand, I would have thought the same thing about the memory safety
> rules that Rust enforces. I'm hopeful that this will eventually be possible
> as well.
>
> [1] https://www.kernel.org/doc/Documentation/lockdep-design.txt
>
>
A static proof seems extremely difficult; it would be a significant
addition to the type system, affecting the closure types (did they, or not,
embedded a channel/port at creation ?). In addition, I am unsure of how
transfer of closures through channels would pan out.

On the other hand, dynamic detection (such as done on @ pointers for
mutability), seems possible.

-- Matthieu


> On Wed, Oct 30, 2013 at 12:55 AM, Simon Ruggier <simon80 at gmail.com> wrote:
>
>> On Tue, Oct 29, 2013 at 3:30 PM, Brian Anderson <banderson at mozilla.com>wrote:
>>
>>>  On 10/28/2013 10:02 PM, Simon Ruggier wrote:
>>>
>>> Greetings fellow Rustians!
>>>
>>> First of all, thanks for working on such a great language. I really like
>>> the clean syntax, increased safety, separation of data from function
>>> definitions, and freedom from having to declare duplicate method prototypes
>>> in header files.
>>>
>>> I've been working on an alternate way to communicate between tasks in
>>> Rust, following the same approach as the LMAX Disruptor.[1] I'm hoping to
>>> eventually offer a superset of the functionality in the pipes API, and
>>> replace them as the default communication mechanism between tasks. Just as
>>> with concurrency in general, my main motivation in implementing this is to
>>> improve performance. For more information about the disruptor approach,
>>> there's a lot of information linked from their home page, in a variety of
>>> formats.
>>>
>>>
>>> This is really exciting work. Thanks for pursuing it. I've been
>>> interested in exploring something like Disruptor in Rust. The current
>>> channel types in Rust are indeed slow, and fixing them is the topic of
>>> https://github.com/mozilla/rust/issues/8568.
>>>
>>
>> I'll start paying attention to that. The Morrison & Afek 2013 paper looks
>> like something I should read.
>>
>>
>>>
>>>
>>> This is my first major contribution of new functionality to an
>>> open-source project, so I didn't want to discuss it in advance until I had
>>> a working system to demonstrate. I currently have a very basic proof of
>>> concept that achieves almost two orders of magnitude better performance
>>> than the pipes API. On my hardware[2], I currently see throughput of about
>>> 27 million items per second when synchronizing with a double-checked wait
>>> condition protocol between sender and receivers, 80+ million items with no
>>> blocking (i.e. busy waiting), and anywhere from 240,000 to 600,000 when
>>> using pipes. The LMAX Disruptor library gets up to 110 million items per
>>> second on the same hardware (using busy waiting and yielding), so there's
>>> definitely still room for significant improvement.
>>>
>>>
>>> Those are awesome results!
>>>
>>
>> Thanks! When I first brought it up, it was getting about 14 million with
>> the busy waiting. Minimizing the number of atomic operations (even with
>> relaxed memory ordering) makes a big difference in performance. The 2/3
>> drop in performance with the blocking wait strategy comes from merely doing
>> a read-modify-write operation on every send (it currently uses atomic swap,
>> I haven't experimented with others yet). To be fair, the only result I can
>> take credit for is the blocking algorithm. The other ideas are straight
>> from the original disruptor.
>>
>>
>>> I've put the code up on GitHub (I'm using rustc from master).[3]
>>> Currently, single and multi-stage pipelines of receivers are supported,
>>> while many features are missing, like multiple concurrent senders, multiple
>>> concurrent receivers, or mutation of the items as they pass through the
>>> pipeline. However, given what I have so far, now is probably the right time
>>> to start soliciting feedback and advice. I'm looking for review,
>>> suggestions/constructive criticism, and guidance about contributing this to
>>> the Rust codebase.
>>>
>>>
>>> I'm not deeply familiar with Disruptor, but I believe that it uses
>>> bounded queues. My general feeling thus far is that, as the general 'go-to'
>>> channel type, people should not be using bounded queues that block the
>>> sender when full because of the potential for unexpected deadlocks. I could
>>> be convinced otherwise though if it's just not possible to have reasonably
>>> fast unbounded channels. Note that I don't think it's critical for the
>>> general-purpose channel to be as fast as possible - it's more important to
>>> be convenient.
>>>
>>
>> Yes, it does. I'm divided on this, because unbounded queues can also lead
>> to memory exhaustion and added latency, but I suspect that for many use
>> cases, you're right. For performance critical code, I think there's
>> probably no argument: if a queue is too large, it starts causing latency
>> problems (like with bufferbloat). A queue that accepts an unlimited number
>> of items is like an API that doesn't let the caller know about errors. The
>> caller needs to know that there's a large queue, and adjust its behaviour.
>> Because of this, I doubt any performance-critical application would find it
>> truly optimal to use unbounded queues. My opinion on this is strongly
>> influenced by this post:
>>
>> http://mechanical-sympathy.blogspot.co.uk/2012/05/apply-back-pressure-when-overloaded.html
>>
>> For general usage, though, I need to do more research. Any application
>> where latency is relevant really should be designed to deal with
>> back-pressure from queues, but there may be some batch job style use cases
>> where, as you say, it isn't worth the extra effort. On the other hand, it's
>> relevant to think about how deadlocks occur, and decide whether or not it's
>> reasonable for developers to expect to be able to do those things. I'll
>> look into this and see what I come up with.
>>
>> If there were some general way to mitigate the deadlock issue within the
>> runtime, it would also solve this problem.
>>
>> As a last resort, I suspect that I could probably figure out a way to
>> have the sender resize the buffer when it fills, copy the elements over,
>> and then switch the consumers over to the larger buffer. I don't know if I
>> could do it without affecting the fast path on the receiver side.
>>
>> Please keep working on this. I'm excited to see your results.
>>>
>>
>> I appreciate the encouragement :)
>>
>>
>>>
>>> Thanks,
>>> Simon
>>>
>>> [1] http://lmax-exchange.github.io/disruptor/
>>> [2] A 2.66GHz Intel P8800 CPU running in a Thinkpad T500 on Linux x86_64
>>> [3] https://github.com/sruggier/rust-disruptor
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131110/6a636e0c/attachment-0001.html>

From lists at dhardy.name  Mon Nov 11 02:02:33 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Mon, 11 Nov 2013 11:02:33 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527D1F81.4030503@mozilla.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<8817533.0HqEL1HLOK@tph-l10036> <527D1F81.4030503@mozilla.com>
Message-ID: <1387267.xlRjlI7P1N@tph-l10036>

Thanks for the clarification. The current design actually makes sense to me 
after re-reading about dynamically sized types.

On Friday 08 November 2013 09:29:37 Patrick Walton wrote:
> On 11/8/13 7:47 AM, Diggory Hardy wrote:
> > What's wrong with sticking with convention here? E.g. C++'s `string` and
> > `vector<T>` are objects containing two or three pointers. D's arrays and
> > `string` act the same way. Even C's dynamic arrays (`int x[]`) can be
> > thought of the same way (if one avoids thinking of them as pointers).
> 
> Because:
> 
> * We need slices in the language. They're important for soundness.
> 
> * We need dynamically sized types in the language in order to be sound
> around first-class trait objects.
> 
> * Given that we need slices, and we need dynamically-sized types, we can
> avoid introducing more concepts in the language by treating slices as
> just a special case of a dynamically-sized type. That is, a slice is
> nothing more than *a pointer to a dynamically-sized type*.
> 
> * The pointer sigil is notated `&`, and the dynamically-sized type is
> `[int]`. So the resulting notation is `&[int]`.
> 
> You can see slices as just pointers with a length attached; i.e. a
> pointer to multiple contiguous values. In fact, Cyclone called them "fat
> pointers" instead of "slices". In Cyclone, you wrote a slice as `int
> *fat`. (Notice the similarity to `&[int]`.)
> 
> Note that not all of this is implemented today, which is leading to some
> of the confusion in this thread. Felix Klock is currently working on it.
> 
> Patrick
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/477d1452/attachment.sig>

From denis.spir at gmail.com  Mon Nov 11 03:55:50 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 11 Nov 2013 12:55:50 +0100
Subject: [rust-dev] formats 'Standard' {} and 'Poly' {:?}
Message-ID: <5280C5C6.40003@gmail.com>

Hello,

Well, I wonder if we could exchange those formats. Here is how they work:

fn main () {
     struct P {i:uint, j:uint};
     let (b, u, i, x, c, s, a, p) =
         (false, 1u, -1, -1.11, 'c', "abc", [1,2,3], P{i:1,j:2});
     let z : Option<uint> = None;

     // Poly
     println!("{:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?}",
         b, u, i, x, c, s, a, p, z);
     // ==> false 1u -1 -1.11 'c' "abc" [1, 2, 3] main::P{i: 1u, j: 2u}

     // Standard
     println!("{} {} {} {} {} {}",
         b, u, i, x, c, s);
     // ==> false 1 -1 -1.11 c abc
}

The format 'Poly" {:?}:
* works for all types, including app defined, does not require trait definition 
or declaration
* just does the right thing, telling the programmer all what is needed
   in an exact and complete manner (except "main::" is too much maybe)

The format 'Standard' {}:
* requires definition of trait 'Standard' for complex types (arrays, structs, 
enums), as well as its declaration for type variables
* is ambiguous about chars and strings, as well integers (signed?)

In other words, 'poly' gives us back the notation of data, as we (would) have 
noted them in code. Also, its tells us the type, if implicitely, except for the 
exact size of a number. This information is what we need in the general case for 
all kinds of feedback in program testing, diagnosis, debugging... The standard 
notation of data is not always the best possible form, but it always does the 
job and we are used to it. I guess we'll constantly use it for our own feedback.

For this reason, I'd like to exchange the notations of these formats: have Poly 
be {} so that we are less annoyed at typing it. And call with a meaningful name, 
such as Notation, Literal or... Standard.

I have no idea what the other format (the one currently noted {} and called 
Standard) is good for. I'd say it can be used as part of user output, but we 
already have good type-specific formats for that. Maybe this format is a 
polyvalent form of those specialised formats, so that we don't need to choose: 
then call *this one* "poly"... Also, noting this one {:?} would make sense.

Denis



From corey at octayn.net  Mon Nov 11 03:58:39 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 11 Nov 2013 06:58:39 -0500
Subject: [rust-dev] formats 'Standard' {} and 'Poly' {:?}
In-Reply-To: <5280C5C6.40003@gmail.com>
References: <5280C5C6.40003@gmail.com>
Message-ID: <CA++BO6RQ8FXu+3kq8MJ+F3SkJbtBqNNrN37KkVGDLXALq7RjmQ@mail.gmail.com>

Poly uses reflection, is fairly slow, and is intended only for
debugging. `{}` is used for lots of things. It's used quite novelly
for HTML formatting in rustdoc.

On Mon, Nov 11, 2013 at 6:55 AM, spir <denis.spir at gmail.com> wrote:
> Hello,
>
> Well, I wonder if we could exchange those formats. Here is how they work:
>
> fn main () {
>     struct P {i:uint, j:uint};
>     let (b, u, i, x, c, s, a, p) =
>         (false, 1u, -1, -1.11, 'c', "abc", [1,2,3], P{i:1,j:2});
>     let z : Option<uint> = None;
>
>     // Poly
>     println!("{:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?}",
>         b, u, i, x, c, s, a, p, z);
>     // ==> false 1u -1 -1.11 'c' "abc" [1, 2, 3] main::P{i: 1u, j: 2u}
>
>     // Standard
>     println!("{} {} {} {} {} {}",
>         b, u, i, x, c, s);
>     // ==> false 1 -1 -1.11 c abc
> }
>
> The format 'Poly" {:?}:
> * works for all types, including app defined, does not require trait
> definition or declaration
> * just does the right thing, telling the programmer all what is needed
>   in an exact and complete manner (except "main::" is too much maybe)
>
> The format 'Standard' {}:
> * requires definition of trait 'Standard' for complex types (arrays,
> structs, enums), as well as its declaration for type variables
> * is ambiguous about chars and strings, as well integers (signed?)
>
> In other words, 'poly' gives us back the notation of data, as we (would)
> have noted them in code. Also, its tells us the type, if implicitely, except
> for the exact size of a number. This information is what we need in the
> general case for all kinds of feedback in program testing, diagnosis,
> debugging... The standard notation of data is not always the best possible
> form, but it always does the job and we are used to it. I guess we'll
> constantly use it for our own feedback.
>
> For this reason, I'd like to exchange the notations of these formats: have
> Poly be {} so that we are less annoyed at typing it. And call with a
> meaningful name, such as Notation, Literal or... Standard.
>
> I have no idea what the other format (the one currently noted {} and called
> Standard) is good for. I'd say it can be used as part of user output, but we
> already have good type-specific formats for that. Maybe this format is a
> polyvalent form of those specialised formats, so that we don't need to
> choose: then call *this one* "poly"... Also, noting this one {:?} would make
> sense.
>
> Denis
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From danielmicay at gmail.com  Mon Nov 11 04:18:05 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 11 Nov 2013 07:18:05 -0500
Subject: [rust-dev] formats 'Standard' {} and 'Poly' {:?}
In-Reply-To: <5280C5C6.40003@gmail.com>
References: <5280C5C6.40003@gmail.com>
Message-ID: <CA+DvKQKEJfLFUWP12wQcZUjoDLd=Erna0yZ+gsK=vJ-WzaJr7Q@mail.gmail.com>

On Mon, Nov 11, 2013 at 6:55 AM, spir <denis.spir at gmail.com> wrote:

> Hello,
>
> Well, I wonder if we could exchange those formats. Here is how they work:
>
> fn main () {
>     struct P {i:uint, j:uint};
>     let (b, u, i, x, c, s, a, p) =
>         (false, 1u, -1, -1.11, 'c', "abc", [1,2,3], P{i:1,j:2});
>     let z : Option<uint> = None;
>
>     // Poly
>     println!("{:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?} {:?}",
>         b, u, i, x, c, s, a, p, z);
>     // ==> false 1u -1 -1.11 'c' "abc" [1, 2, 3] main::P{i: 1u, j: 2u}
>
>     // Standard
>     println!("{} {} {} {} {} {}",
>         b, u, i, x, c, s);
>     // ==> false 1 -1 -1.11 c abc
> }
>
> The format 'Poly" {:?}:
> * works for all types, including app defined, does not require trait
> definition or declaration
> * just does the right thing, telling the programmer all what is needed
>   in an exact and complete manner (except "main::" is too much maybe)
>
> The format 'Standard' {}:
> * requires definition of trait 'Standard' for complex types (arrays,
> structs, enums), as well as its declaration for type variables
> * is ambiguous about chars and strings, as well integers (signed?)
>
> In other words, 'poly' gives us back the notation of data, as we (would)
> have noted them in code. Also, its tells us the type, if implicitely,
> except for the exact size of a number. This information is what we need in
> the general case for all kinds of feedback in program testing, diagnosis,
> debugging... The standard notation of data is not always the best possible
> form, but it always does the job and we are used to it. I guess we'll
> constantly use it for our own feedback.
>
> For this reason, I'd like to exchange the notations of these formats: have
> Poly be {} so that we are less annoyed at typing it. And call with a
> meaningful name, such as Notation, Literal or... Standard.
>
> I have no idea what the other format (the one currently noted {} and
> called Standard) is good for. I'd say it can be used as part of user
> output, but we already have good type-specific formats for that. Maybe this
> format is a polyvalent form of those specialised formats, so that we don't
> need to choose: then call *this one* "poly"... Also, noting this one {:?}
> would make sense.
>
> Denis
>

The reflection-based `{:?}` doesn't follow the privacy rules, so it will
never be a format with a stable output. The low-level implementation
details of a type aren't a sensible format for any application to be using.

I don't think `std::reflect` and `std::repr` should even be available
outside of debug builds because they're a huge backwards incompatibility
hazard and prevent Rust from exposing a stable ABI for a reasonable subset
of the standard library.

I think the following is a great example:

```
use std::hashmap::HashMap;

fn main() {
    let mut xs = HashMap::new();
    xs.insert(5, 5);
    println!("{:?}", xs);
}
```

The output is not even usable for debugging, unless what you're debugging
is the hash table implementation:

```
std::hashmap::HashMap<int,int>{k0: 16592526953366606085u64, k1:
12349690536349946653u64, resize_at: 24u, size: 1u, buckets: ~[None, None,
None, None, None, None, None, None,
Some(std::hashmap::Bucket<int,int>{hash: 10818539429618494536u, key: 5,
value: 5}), None, None, None, None, None, None, None, None, None, None,
None, None, None, None, None, None, None, None, None, None, None, None,
None]}
```

Any type containing a hash table or a tree is going to have totally
unusable output too. It quickly becomes unusable for anything that's not a
thin wrapper around primitive types.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/b4d23782/attachment.html>

From denis.spir at gmail.com  Mon Nov 11 04:44:04 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 11 Nov 2013 13:44:04 +0100
Subject: [rust-dev] returning an item from a collection
Message-ID: <5280D114.8010907@gmail.com>

Hello,

I am searching for the easy or standard way to return an item from a collection. 
Here is a fictional example showing the issue:

struct Coll<Item> {
     items : ~[Item]
}

impl<Item> Coll<Item> {
     fn first (&self) -> Item {
         // this line is for comments below:
         let it =  self.items[0];            // error
         return it;
     }
}

fn main () {
     let coll = Coll{items:~[1,2,3]};
     println!("first : {:?}", coll.first());
}

==>
_.rs:12:18: 12:30 error: cannot move out of dereference of & pointer
_.rs:12         let it =  self.items[0];

I could not find any clue in docs. Have tried several approaches, finally 
succeeded with the following:

impl<Item:Clone> Coll<Item> {
     fn first (&self) -> Item {
         let it =  self.items[0].clone();
         return it;
     }
}

I find that surprising. A few questions:
* What does the error *mean* ?
* Is this solution the right way?
* What alternatives exist, if any?
* What is the difference between copy and clone?
* Why does clone work and not simple copy?

About the latter 2 questions, well, for me,
     y = x
just copies x into y [1]; and clone is just a synonym of copy. Where am I wrong? 
That we copy should remove any pointer safety question, shouldn't it? (This 
consideration was my lead to find a solution.) Again, where am I wrong?

The doc of the module 'clone' reads:
<< The Clone trait for types that cannot be "implicitly copied"

In Rust, some simple types are "implicitly copyable" and when you assign them or 
pass them as arguments, the receiver will get a copy, leaving the original value 
in place. These types do not require allocation to copy and do not have 
finalizers (i.e. they do not contain owned boxes or implement Drop), so the 
compiler considers them cheap and safe to copy. For other types copies must be 
made explicitly, by convention implementing the Clone trait and calling the 
clone method. >>

This is all good and makes sense for me. But then, in the first code example 
above, the compiler does not know anything about the "copy-ability" of Val 
specimens. How does it then interpret the line:
     let it =  self.items[0];
The only way to make sense of that is to copy, isn't it? What else? Then, the 
language should require Val to declare the trait Clone, shouldn't it? And there 
should not be a need for an explicit copy via the clone method in my view... 
Again, what other sense but copying does the compiler assign to a simple 
assignment "y=x" ?

Finally, is it so that for generic collections, item types must always be 
declared the Clone trait, else we just cannot read them? Same for generic struct 
fields? (If I add a field of type Item in Coll, I also cannot read it out 
without error.)

Denis

[1] shallow copy: the pointer, if x is a pointer, the "fa?ade" struct is x is 
such an thing, etc...



From oren at ben-kiki.org  Mon Nov 11 05:10:03 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 11 Nov 2013 15:10:03 +0200
Subject: [rust-dev] formats 'Standard' {} and 'Poly' {:?}
In-Reply-To: <CA+DvKQKEJfLFUWP12wQcZUjoDLd=Erna0yZ+gsK=vJ-WzaJr7Q@mail.gmail.com>
References: <5280C5C6.40003@gmail.com>
	<CA+DvKQKEJfLFUWP12wQcZUjoDLd=Erna0yZ+gsK=vJ-WzaJr7Q@mail.gmail.com>
Message-ID: <CADJiDhuoK9o+tgLNEpXP-qcYu6uSmOS32PvOQpvF5088KSOhSA@mail.gmail.com>

I thought the trait for `{}` was called `Default`. At any rate, I also
don't understand why we need both `{}` and `{:s}`, `{:i}`, etc. There's
some reason for `{:x}` (change the output base to hexadecimal), but that's
about it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/eec0ef6d/attachment.html>

From denis.spir at gmail.com  Mon Nov 11 05:17:01 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 11 Nov 2013 14:17:01 +0100
Subject: [rust-dev] formats 'Standard' {} and 'Poly' {:?}
In-Reply-To: <CA+DvKQKEJfLFUWP12wQcZUjoDLd=Erna0yZ+gsK=vJ-WzaJr7Q@mail.gmail.com>
References: <5280C5C6.40003@gmail.com>
	<CA+DvKQKEJfLFUWP12wQcZUjoDLd=Erna0yZ+gsK=vJ-WzaJr7Q@mail.gmail.com>
Message-ID: <5280D8CD.3040008@gmail.com>

On 11/11/2013 01:18 PM, Daniel Micay wrote:
> The reflection-based `{:?}` doesn't follow the privacy rules, so it will
> never be a format with a stable output. The low-level implementation
> details of a type aren't a sensible format for any application to be using.

Provided it goes on doing the right thing, meaning ~ reproducing data notation, 
I'm happy with it.

> I don't think `std::reflect` and `std::repr` should even be available
> outside of debug builds because they're a huge backwards incompatibility
> hazard and prevent Rust from exposing a stable ABI for a reasonable subset
> of the standard library.

It is for programmer feedback anyway. If 'poly' is removed, I cry. It promises 
to be the best and most common tool Rust provides to programmers.

A way to solve that issue, preventing this format to be mis-used for app output, 
may be to have funcs specific for programmer feedback, which in standard use 
'poly' [1]. Other writing funcs, for app output, would not normally use it.

More generally, it may be a good idea to (more) clearly separate "meta" features 
for programmer help from app modelling features.

> I think the following is a great example:
>
> ```
> use std::hashmap::HashMap;
>
> fn main() {
>      let mut xs = HashMap::new();
>      xs.insert(5, 5);
>      println!("{:?}", xs);
> }
> ```
>
> The output is not even usable for debugging, unless what you're debugging
> is the hash table implementation:

You are right. But the reason for a programmer to print out a hashmap should be 
to debig it. Else, we should ask for different or more precise data (eg, its 
size, or the buckets).

> ```
> std::hashmap::HashMap<int,int>{k0: 16592526953366606085u64, k1:
> 12349690536349946653u64, resize_at: 24u, size: 1u, buckets: ~[None, None,
> None, None, None, None, None, None,
> Some(std::hashmap::Bucket<int,int>{hash: 10818539429618494536u, key: 5,
> value: 5}), None, None, None, None, None, None, None, None, None, None,
> None, None, None, None, None, None, None, None, None, None, None, None,
> None]}
> ```
>
> Any type containing a hash table or a tree is going to have totally
> unusable output too. It quickly becomes unusable for anything that's not a
> thin wrapper around primitive types.

As said, it cannot be perfect in all cases. At times, we will need custom 
formats even for programmer feedback. Alternative: change the 'poly' format for 
hashtables. (But as it is, is looks good to me: it says what we need, and can 
barely be made more compact or readable.)

What I would change is presenting structs (maybe arrays as well) in multiline 
format whenever some of their fields (items) are complex. This would give:

std::hashmap::HashMap<int,int> {
     k0: 16592526953366606085u64,
     k1: 12349690536349946653u64,
     resize_at: 24u,
     size: 1u,
     buckets: ~[None, None,
None, None, None, None, None, None,
Some(std::hashmap::Bucket<int,int>{hash: 10818539429618494536u, key: 5,
value: 5}), None, None, None, None, None, None, None, None, None, None,
None, None, None, None, None, None, None, None, None, None, None, None,
None]
}

Denis

[1] When the language lets me do it, such a programmfeedback func is the first 
utility I write. I call it "note" (as they write data notation) or note* when I 
can have several of them.

From pnkfelix at mozilla.com  Mon Nov 11 05:47:27 2013
From: pnkfelix at mozilla.com (Felix Klock)
Date: Mon, 11 Nov 2013 05:47:27 -0800 (PST)
Subject: [rust-dev] returning an item from a collection
In-Reply-To: <5280D114.8010907@gmail.com>
References: <5280D114.8010907@gmail.com>
Message-ID: <501973145.8294345.1384177647691.JavaMail.zimbra@mozilla.com>

Denis (cc'ing rust-dev)-

> How does it then interpret the line:
>      let it =  self.items[0];
> The only way to make sense of that is to copy, isn't it? What else?

An assignment expression can denote either a copy or a *move* of the right-hand-side into the left-hand-side. 

Note that your goal ("returning an item from a collection") is unclear, in that I cannot tell whether you want to move item out of the collection, or make a copy of it, or provide a shared reference to the item in the collection (but without removing it from the collection).

Anyway, the error message says "cannot move out of dereference of & pointer"

In this case, the assignment expression is being interpreted as an attempt to move content out of self.items[0].  But you cannot move the item out of the l-value denoted 
by that expression, for a couple different reasons (such as: `&self` is an immutable borrow, so you cannot modify it;  and also, even if you changed the borrow to be a mutable borrow, you still could not use the expression you want to extract the first item, since the vector needs something to replace the content that was removed).

Maybe you are more used to languages like Java/Scheme/ML/Haskell/etc, where a parameter or local variable denotes a *reference* to the value in question, and thus can be freely copied?  To get that effect in Rust, and thus allow multiple references to some shared piece of state, you need to use some explicit pointer/reference type.

Here is some code to illustrate what I'm saying.  Note that you should probably favor a data-structure representation where you can call the vec `pop()` method rather than `shift()`; compare the source code for each in vec.rs to see why.

```rust
struct Coll<Item> {
     items : ~[Item]
}

impl<Item> Coll<Item> {
     // *Moves* the first element out of self.
     // (Doing so requires that we mutably-borrow self.)
     fn first (&mut self) -> Item {
         //     ^^^ this is new

         let it =  self.items.shift();
         //                   ^^^^^ so is this
         return it;
     }

     // Provides reference to first element of self.
     fn first_ref<'a> (&'a self) -> &'a Item {
         // Note: The lifetime 'a tells us that the reference will
         // survive only as long as the immutable-borrow of self.
         let it =  &'a self.items[0];
         return it;
     }
}

fn main () {
     let mut coll = Coll{items:~[1,2,3]};
     //  ^^^ this is also new.

     {
        // This {} block acts effectively as the lifetime 'a for the
        // call to first_ref.

        // First lets take a reference, `fref`, into coll...
        let fref = coll.first_ref();
        println!("first ref : {:?}", fref);
        println!("coll : {:?}", coll);
        // ... which will only live until here...
     }

     // ... which is important, because we need to *mutably*
     // borrow `coll` in order to invoke `first()` here.
     println!("first : {:?}", coll.first());
     println!("coll : {:?}", coll);
}

```

Cheers,
-Felix

----- Original Message -----
From: "spir" <denis.spir at gmail.com>
To: "Rust-dev" <rust-dev at mozilla.org>
Sent: Monday, November 11, 2013 1:44:04 PM
Subject: [rust-dev] returning an item from a collection

Hello,

I am searching for the easy or standard way to return an item from a collection. 
Here is a fictional example showing the issue:

struct Coll<Item> {
     items : ~[Item]
}

impl<Item> Coll<Item> {
     fn first (&self) -> Item {
         // this line is for comments below:
         let it =  self.items[0];            // error
         return it;
     }
}

fn main () {
     let coll = Coll{items:~[1,2,3]};
     println!("first : {:?}", coll.first());
}

==>
_.rs:12:18: 12:30 error: cannot move out of dereference of & pointer
_.rs:12         let it =  self.items[0];

I could not find any clue in docs. Have tried several approaches, finally 
succeeded with the following:

impl<Item:Clone> Coll<Item> {
     fn first (&self) -> Item {
         let it =  self.items[0].clone();
         return it;
     }
}

I find that surprising. A few questions:
* What does the error *mean* ?
* Is this solution the right way?
* What alternatives exist, if any?
* What is the difference between copy and clone?
* Why does clone work and not simple copy?

About the latter 2 questions, well, for me,
     y = x
just copies x into y [1]; and clone is just a synonym of copy. Where am I wrong? 
That we copy should remove any pointer safety question, shouldn't it? (This 
consideration was my lead to find a solution.) Again, where am I wrong?

The doc of the module 'clone' reads:
<< The Clone trait for types that cannot be "implicitly copied"

In Rust, some simple types are "implicitly copyable" and when you assign them or 
pass them as arguments, the receiver will get a copy, leaving the original value 
in place. These types do not require allocation to copy and do not have 
finalizers (i.e. they do not contain owned boxes or implement Drop), so the 
compiler considers them cheap and safe to copy. For other types copies must be 
made explicitly, by convention implementing the Clone trait and calling the 
clone method. >>

This is all good and makes sense for me. But then, in the first code example 
above, the compiler does not know anything about the "copy-ability" of Val 
specimens. How does it then interpret the line:
     let it =  self.items[0];
The only way to make sense of that is to copy, isn't it? What else? Then, the 
language should require Val to declare the trait Clone, shouldn't it? And there 
should not be a need for an explicit copy via the clone method in my view... 
Again, what other sense but copying does the compiler assign to a simple 
assignment "y=x" ?

Finally, is it so that for generic collections, item types must always be 
declared the Clone trait, else we just cannot read them? Same for generic struct 
fields? (If I add a field of type Item in Coll, I also cannot read it out 
without error.)

Denis

[1] shallow copy: the pointer, if x is a pointer, the "fa?ade" struct is x is 
such an thing, etc...


_______________________________________________
Rust-dev mailing list
Rust-dev at mozilla.org
https://mail.mozilla.org/listinfo/rust-dev

From denis.spir at gmail.com  Mon Nov 11 06:48:37 2013
From: denis.spir at gmail.com (spir)
Date: Mon, 11 Nov 2013 15:48:37 +0100
Subject: [rust-dev] returning an item from a collection
In-Reply-To: <501973145.8294345.1384177647691.JavaMail.zimbra@mozilla.com>
References: <5280D114.8010907@gmail.com>
	<501973145.8294345.1384177647691.JavaMail.zimbra@mozilla.com>
Message-ID: <5280EE45.7020905@gmail.com>

On 11/11/2013 02:47 PM, Felix Klock wrote:
> Denis (cc'ing rust-dev)-

Thank you very much, Felix, for this clear and exhaustive reply.

>> How does it then interpret the line:
>>       let it =  self.items[0];
>> The only way to make sense of that is to copy, isn't it? What else?
>
> An assignment expression can denote either a copy or a *move* of the right-hand-side into the left-hand-side.
>
> Note that your goal ("returning an item from a collection") is unclear, in that I cannot tell whether you want to move item out of the collection, or make a copy of it, or provide a shared reference to the item in the collection (but without removing it from the collection).

All right. Seems 'move' is to be understood quite literally, no? The datum 
so-to-say ceases to exist at its original place?
I want to copy because (or so it seels to me) it is the standard need: we want 
something "equivalent". (By copy I do not mean deep copy or copy of contents or 
of target, for a data structure, collection, or pointer. Just the "fa?ade".)

> Anyway, the error message says "cannot move out of dereference of & pointer"
>
> In this case, the assignment expression is being interpreted as an attempt to move content out of self.items[0].  But you cannot move the item out of the l-value denoted
> by that expression, for a couple different reasons (such as: `&self` is an immutable borrow, so you cannot modify it;  and also, even if you changed the borrow to be a mutable borrow, you still could not use the expression you want to extract the first item, since the vector needs something to replace the content that was removed).

More or less what I understood, but thank to you clearer.

> Maybe you are more used to languages like Java/Scheme/ML/Haskell/etc, where a parameter or local variable denotes a *reference* to the value in question, and thus can be freely copied?  To get that effect in Rust, and thus allow multiple references to some shared piece of state, you need to use some explicit pointer/reference type.
>
> Here is some code to illustrate what I'm saying.  Note that you should probably favor a data-structure representation where you can call the vec `pop()` method rather than `shift()`; compare the source code for each in vec.rs to see why.
>
> ```rust
> struct Coll<Item> {
>       items : ~[Item]
> }
>
> impl<Item> Coll<Item> {
>       // *Moves* the first element out of self.
>       // (Doing so requires that we mutably-borrow self.)
>       fn first (&mut self) -> Item {
>           //     ^^^ this is new
>
>           let it =  self.items.shift();
>           //                   ^^^^^ so is this
>           return it;
>       }
>
>       // Provides reference to first element of self.
>       fn first_ref<'a> (&'a self) -> &'a Item {
>           // Note: The lifetime 'a tells us that the reference will
>           // survive only as long as the immutable-borrow of self.
>           let it =  &'a self.items[0];
>           return it;
>       }
> }
>
> fn main () {
>       let mut coll = Coll{items:~[1,2,3]};
>       //  ^^^ this is also new.
>
>       {
>          // This {} block acts effectively as the lifetime 'a for the
>          // call to first_ref.
>
>          // First lets take a reference, `fref`, into coll...
>          let fref = coll.first_ref();
>          println!("first ref : {:?}", fref);
>          println!("coll : {:?}", coll);
>          // ... which will only live until here...
>       }
>
>       // ... which is important, because we need to *mutably*
>       // borrow `coll` in order to invoke `first()` here.
>       println!("first : {:?}", coll.first());
>       println!("coll : {:?}", coll);
> }
>
> ```

All right! I'll keep this code aside for whenever I need these alternatives (ref 
or move). I conclude that for reading or returning an item by copy, using clone 
is the right way to go (if the item type is a variable). Correct?

Also, what does
	let y = x;
mean in Rust if x's type is constant (as opposed to a generic type var)? Does it 
depend on the exact type? and specifically what happens in the case of simple, 
atomic, type?

> Cheers,
> -Felix

From catamorphism at gmail.com  Mon Nov 11 11:33:34 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 11 Nov 2013 11:33:34 -0800
Subject: [rust-dev] List of rustpkg packages on wiki (add your own!)
Message-ID: <CADcg8==FLYT_3=ck-mo7ZUm5a26XQQF3X2U=xHRnYdRxxBJtDg@mail.gmail.com>

Hi all --

I started making a list of Rust packages that build with rustpkg, on the wiki:

https://github.com/mozilla/rust/wiki/Rustpkg

If I left out yours, add it! (And if I included yours but shouldn't
have, then remove it; I was going through RustCI and finding the ones
with a lib.rs file :-)

With hope, the central package database (
https://github.com/mozilla/rust/issues/10041 ) will obviate the need
for this list, but in the meantime, let's maintain the list
informally.

Cheers,
Tim

-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From oren at ben-kiki.org  Mon Nov 11 12:16:24 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Mon, 11 Nov 2013 22:16:24 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
Message-ID: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>

I googled around and this has been asked before several times; there are
answers that use obsolete syntax and Rust concepts, so I thought it might
be a good idea to revisit the issue.

The basic use case is having some trait, and having some (base/mixin)
struct implementing it. Now, one wants to have a 2nd (derived/importing)
struct implementing the trait, based on the 1st struct implementation
(including its data members).

I'm not certain what the idiomatic Rust answers to this common use case is,
today.

One can obviously simply duplicate the data members and the trait
implementation, if the size of the code is small enough. This is very WET
though.

One can have the derived/importing class contain a member of the base/mixin
struct, then delegate each and every trait function to it (providing
overrides where needed). This is pretty tedious and results with a lot of
boilerplate code. Performance would probably suffer. It is also difficult
to override methods that are invoked by imported methods.

One can write the 1st struct in a way that is intended to be overridden,
e.g. by providing a trait with a "get base" accessor and using that all
over the place. This makes the base struct code uglier (and, I think, less
efficient), but results in less boilerplate code in the derived class. It
makes overrides much trickier though. In general seems pretty restricted.

One can implement a bunch of macros to automate injecting the common code
into derived structs (I think - I'm not clear whether macros are allowed to
add methods and members to a struct). Setting up the macros "isn't fun",
especially when one wants to take overrides into account.

If there another option? Which one is more "idiomatic" Rust code?

There are many options that would require compiler/language support...
these basically automate the above approaches.

Personally I am fond of a somewhat unusual approach I first saw in Sather
(I think), which was to automate the macro based approach. That is, define
"implementation inheritance" (actually, "mixins") as a source-level
operation.

The source code of the imported/reused members from the base (mixin) struct
would be (logically anyway) pasted inside the definition of the
derived/importing struct, and then compiled as usual.

This is very simple to define (it is basically similar to "use" - in fact,
this resonates with the idea of changing the division of labor between
structs and modules, but it is a separate discussion).

It allows for great flexibility: one can import only specific methods and
members, providing a different implementation for others; Using the ability
to import something under a different name, it is possible to wrap the
imported methods with additional functionality (foo { ...;
renamed_imported_foo(); ... }), etc.

So, this provides the functionality of "virtual functions" (an imported
function calling one that is redefined - that is, not imported but
implemented locally - will get the overriden behavior). At the same time,
unlike "virtual functions", it still allows for aggressive optimizations
(since when compiling a struct, all methods are fully known and can be
inlined etc.).

It sidesteps a lot of sticky issues with a vtable-sharing oriented approach
(like in C++). For example, re-importing would cause multiple definitions
of the same member/method.

It even allows for separate compilation (if the object file contains the
AST tucked in it somewhere), and for reuse of compiled methods (if they
don't invoke overriden methods - but that may be tricky to implement).

At any rate, I'm not claiming this is necessarily the best approach for
Rust; I'm just wondering, what is the proposed way to address this use
case? None of the manual approaches seems very appealing (unless there's a
better one I missed).

Thanks,

Oren Ben-Kiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/9fd8715c/attachment.html>

From greg at kinostudios.com  Mon Nov 11 12:27:39 2013
From: greg at kinostudios.com (Greg)
Date: Mon, 11 Nov 2013 15:27:39 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
Message-ID: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>

Dear Mozilla, rust devs, and memory-safe enthusiasts everywhere,

I'm very happy with the safety improvements that Rust brings.

This is true innovation.

At the same time, I am disappointed and quite concerned about Rust's unimaginative syntax.

It seems to preserve decades of poor decision-making from C++.

The FAQ states: "The syntax is still evolving"

I hope this is still true today. Syntax plays a significant role in safety:

1. Simple syntax makes software easier to write.
2. Simple syntax makes software easier to understand.
3. Simple syntax makes inserting a backdoor into an open source project more difficult.
4. Simple syntax leads to fewer mistakes.

Were I to have written Rust, I would have modeled its syntax after Clojure/Lisp/Scheme instead of C++ [1]. By this point, I'm aware that this is unlikely to happen.

However, I would like to ask the Rust architects to seriously consider this issue, and ask themselves what syntax they can remove from the language while maintaining type-safety.

Removing syntax should not raise any fears that the language will lose any features or flexibility.

To the contrary, a simpler syntax will likely lead to increased flexibility and possibilities. Lisp has demonstrated unequivocally.

"Typed Clojure" may provide the authors with needed inspiration:

https://github.com/clojure/core.typed/wiki
https://s3.amazonaws.com/github/downloads/frenchy64/papers/ambrose-honours.pdf

Kind regards,
Greg

[1] https://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/9cce2564/attachment.sig>

From catamorphism at gmail.com  Mon Nov 11 12:33:15 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 11 Nov 2013 12:33:15 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
Message-ID: <CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>

Hi, Greg --

At this state in Rust's development, we are unlikely to make any major
changes to Rust's syntax. Literally years of effort have gone into
desgining the syntax, and at this point in the language's development,
our focus is on making any non-backwards-compatible changes in
preparation for releasing 1.0.

I encourage you to check out Rust's syntax extension / macro system:

http://static.rust-lang.org/doc/master/tutorial-macros.html

and explore how that can be used to extend the base syntax.

Cheers,
Tim


On Mon, Nov 11, 2013 at 12:27 PM, Greg <greg at kinostudios.com> wrote:
> Dear Mozilla, rust devs, and memory-safe enthusiasts everywhere,
>
> I'm very happy with the safety improvements that Rust brings.
>
> This is true innovation.
>
> At the same time, I am disappointed and quite concerned about Rust's unimaginative syntax.
>
> It seems to preserve decades of poor decision-making from C++.
>
> The FAQ states: "The syntax is still evolving"
>
> I hope this is still true today. Syntax plays a significant role in safety:
>
> 1. Simple syntax makes software easier to write.
> 2. Simple syntax makes software easier to understand.
> 3. Simple syntax makes inserting a backdoor into an open source project more difficult.
> 4. Simple syntax leads to fewer mistakes.
>
> Were I to have written Rust, I would have modeled its syntax after Clojure/Lisp/Scheme instead of C++ [1]. By this point, I'm aware that this is unlikely to happen.
>
> However, I would like to ask the Rust architects to seriously consider this issue, and ask themselves what syntax they can remove from the language while maintaining type-safety.
>
> Removing syntax should not raise any fears that the language will lose any features or flexibility.
>
> To the contrary, a simpler syntax will likely lead to increased flexibility and possibilities. Lisp has demonstrated unequivocally.
>
> "Typed Clojure" may provide the authors with needed inspiration:
>
> https://github.com/clojure/core.typed/wiki
> https://s3.amazonaws.com/github/downloads/frenchy64/papers/ambrose-honours.pdf
>
> Kind regards,
> Greg
>
> [1] https://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/
>
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From gmaxwell at gmail.com  Mon Nov 11 12:35:40 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 11 Nov 2013 12:35:40 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
Message-ID: <CAAS2fgT6eooNFMmGnx-Jjrwt04uvbA5LFju=dpvPw3iOKCNXiw@mail.gmail.com>

On Mon, Nov 11, 2013 at 12:27 PM, Greg <greg at kinostudios.com> wrote:
> Dear Mozilla, rust devs, and memory-safe enthusiasts everywhere,
>
> I'm very happy with the safety improvements that Rust brings.
>
> This is true innovation.
>
> At the same time, I am disappointed and quite concerned about Rust's unimaginative syntax.
[...]

I'm not a rust developer? so consider my comments accordingly worthless.

But what you're asking for here is very non-specific. Basically you
expect that I should study a number of other languages in general and
then infer which specific syntactic changes you might prefer. I think
thats asking a little too much.

My general impression is that the time for broad bike-shedding of the
whole syntactic strategy has passed, ... but regardless of how broad
or narrow the changes you hope to see happen, specific and actionable
examples of places where the current syntax creates avoidable traps
for programmers (esp. where they can't be fixed with a suitable use of
macros) would likely be much more helpful than a general call for
syntax minimalism.

From greg at kinostudios.com  Mon Nov 11 12:41:46 2013
From: greg at kinostudios.com (Greg)
Date: Mon, 11 Nov 2013 15:41:46 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
Message-ID: <D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>

> At this state in Rust's development, we are unlikely to make any major
> changes to Rust's syntax. 

*cries*

> I encourage you to check out Rust's syntax extension / macro system:
> http://static.rust-lang.org/doc/master/tutorial-macros.html

*clicks link*

O_O

*cries more*

:'-(

I'm not sure what stage I'm at right now: https://en.wikipedia.org/wiki/K%C3%BCbler-Ross_model#Stages

Either 3 (Bargaining), or 4 (Depression).

- Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

On Nov 11, 2013, at 3:33 PM, Tim Chevalier <catamorphism at gmail.com> wrote:

> Hi, Greg --
> 
> At this state in Rust's development, we are unlikely to make any major
> changes to Rust's syntax. Literally years of effort have gone into
> desgining the syntax, and at this point in the language's development,
> our focus is on making any non-backwards-compatible changes in
> preparation for releasing 1.0.
> 
> I encourage you to check out Rust's syntax extension / macro system:
> 
> http://static.rust-lang.org/doc/master/tutorial-macros.html
> 
> and explore how that can be used to extend the base syntax.
> 
> Cheers,
> Tim
> 
> 
> On Mon, Nov 11, 2013 at 12:27 PM, Greg <greg at kinostudios.com> wrote:
>> Dear Mozilla, rust devs, and memory-safe enthusiasts everywhere,
>> 
>> I'm very happy with the safety improvements that Rust brings.
>> 
>> This is true innovation.
>> 
>> At the same time, I am disappointed and quite concerned about Rust's unimaginative syntax.
>> 
>> It seems to preserve decades of poor decision-making from C++.
>> 
>> The FAQ states: "The syntax is still evolving"
>> 
>> I hope this is still true today. Syntax plays a significant role in safety:
>> 
>> 1. Simple syntax makes software easier to write.
>> 2. Simple syntax makes software easier to understand.
>> 3. Simple syntax makes inserting a backdoor into an open source project more difficult.
>> 4. Simple syntax leads to fewer mistakes.
>> 
>> Were I to have written Rust, I would have modeled its syntax after Clojure/Lisp/Scheme instead of C++ [1]. By this point, I'm aware that this is unlikely to happen.
>> 
>> However, I would like to ask the Rust architects to seriously consider this issue, and ask themselves what syntax they can remove from the language while maintaining type-safety.
>> 
>> Removing syntax should not raise any fears that the language will lose any features or flexibility.
>> 
>> To the contrary, a simpler syntax will likely lead to increased flexibility and possibilities. Lisp has demonstrated unequivocally.
>> 
>> "Typed Clojure" may provide the authors with needed inspiration:
>> 
>> https://github.com/clojure/core.typed/wiki
>> https://s3.amazonaws.com/github/downloads/frenchy64/papers/ambrose-honours.pdf
>> 
>> Kind regards,
>> Greg
>> 
>> [1] https://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/
>> 
>> --
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
> 
> 
> 
> -- 
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed it."
> -- Zora Neale Hurston

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/cb9bec68/attachment-0001.sig>

From corey at octayn.net  Mon Nov 11 12:46:01 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 11 Nov 2013 15:46:01 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
Message-ID: <CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>

On Mon, Nov 11, 2013 at 3:41 PM, Greg <greg at kinostudios.com> wrote:
>> At this state in Rust's development, we are unlikely to make any major
>> changes to Rust's syntax.
>
> *cries*
>

I don't think Rust can succeed as a language if it massively differs,
visually, from the language it intends to offset (C++).

From greg at kinostudios.com  Mon Nov 11 13:07:58 2013
From: greg at kinostudios.com (Greg)
Date: Mon, 11 Nov 2013 16:07:58 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
Message-ID: <D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>

> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).


Yes, I agree, and that's why I wrote:

	"By this point, I'm aware that this is unlikely to happen."

I think it's still possible to simplify Rust's existing syntax while maintaining the features it offers.

I am hoping that the developers of Rust will consider this issue important enough to put more thought into it.

I am aware that I am jumping into an issue at a point in time that's considered "late in the game".

From the outside, I can say (with confidence), that Rust is still a nearly unheard-of language, and therefore it still has wiggle-room for improvement, even if the Rust developers and community, because they have been immersed in the language for quite some time, cannot see that this is in fact true.

I also believe Tim when he said that years of effort went into designing the syntax.

However, during those many years, did any of the brains that were involved in designing the syntax seriously consider Clojure's syntax, or Typed Clojure?

I'm almost certain that the answer is "no" (partly because these languages/dialects did not exist at the time).

What about Lua, which is more C-like?

Or CoffeeScript?

Looking at the "Influenced By" section on Wikipedia seems to indicate that the answer to these questions is, again, "no".

The list contains some bad role models (in terms of syntactic elegance and simplicity): C++, Haskell, OCaml, and Ruby.

Thankfully Common Lisp is mentioned. Although, of the Lisps I'm familiar with, Common Lisp has the ugliest syntax (still better than C++ though).

This is all to say that, from what I can tell, simplicity and elegance of syntax was not a design requirement (or goal) that the Rust developers had in mind.

And I think that's quite unfortunate for Rust.

I'm sorry I was not able to provide this feedback years ago when it might have been more helpful. I only recently became aware of Rust.

- Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

On Nov 11, 2013, at 3:46 PM, Corey Richardson <corey at octayn.net> wrote:

> On Mon, Nov 11, 2013 at 3:41 PM, Greg <greg at kinostudios.com> wrote:
>>> At this state in Rust's development, we are unlikely to make any major
>>> changes to Rust's syntax.
>> 
>> *cries*
>> 
> 
> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/844407c4/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/844407c4/attachment.sig>

From andrew.webb at gmail.com  Mon Nov 11 13:12:31 2013
From: andrew.webb at gmail.com (Andrew Webb)
Date: Tue, 12 Nov 2013 10:12:31 +1300
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
Message-ID: <CAF8L9wouYR6jc+Oyx2F3ScbxBNzi_dT_i5hiBhYR73rq0K=5jg@mail.gmail.com>

Hi,

I am just a lurker as well, so take all of this with a good dose of salt...


> At the same time, I am disappointed and quite concerned about Rust's
> unimaginative syntax.
>

It seems to preserve decades of poor decision-making from C++.
>
>
Personally, I find it very pleasant. There are a few things I would have
done differently (mostly to do using full names for e.g., function), but
that is all window dressing.



>
> To the contrary, a simpler syntax will likely lead to increased
> flexibility and possibilities. Lisp has demonstrated unequivocally.
>
> "Typed Clojure" may provide the authors with needed inspiration:
>
>
Clojure is my main language, so don't take this as an attack on it (or
lisps in general), but the "flexibility" that those languages show is at
least in part due to the dynamic type system. Even typed clojure (and typed
racket)  are dynamically typed, but with posthoc type checking. Although
there are many benefits to dynamic typing, neither efficiency, nor provable
safety are usually counted amongst them.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/3ffcced3/attachment.html>

From corey at octayn.net  Mon Nov 11 13:28:27 2013
From: corey at octayn.net (Corey Richardson)
Date: Mon, 11 Nov 2013 16:28:27 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
Message-ID: <CA++BO6TD2zzqBfLmvf4Q8omYs4SYG6rCueFVCcdUCFrqNjgg4g@mail.gmail.com>

On Mon, Nov 11, 2013 at 4:07 PM, Greg <greg at kinostudios.com> wrote:
> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).
>
> Yes, I agree, and that's why I wrote:
>
> "By this point, I'm aware that this is unlikely to happen."
>
> I think it's still possible to simplify Rust's existing syntax while
> maintaining the features it offers.
>

My point is that the familiar syntax *is* a feature. What
simplifications do you propose? I think everyone is mostly happy with
the syntax at this point, so your proposed changes and justification
are going to be very pursuasive, and followed by a PR, for there to be
a chance of them being accepted.

From pcwalton at mozilla.com  Mon Nov 11 13:43:43 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 06:43:43 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
Message-ID: <52814F8F.3020609@mozilla.com>

On 11/12/13 5:16 AM, Oren Ben-Kiki wrote:
> I googled around and this has been asked before several times; there are
> answers that use obsolete syntax and Rust concepts, so I thought it
> might be a good idea to revisit the issue.
>
> The basic use case is having some trait, and having some (base/mixin)
> struct implementing it. Now, one wants to have a 2nd (derived/importing)
> struct implementing the trait, based on the 1st struct implementation
> (including its data members).

There are proposals for this, if I understand you correctly. This is 
needed in Servo.

http://smallcultfollowing.com/babysteps/blog/2013/10/24/single-inheritance/

Patrick

From thadguidry at gmail.com  Mon Nov 11 14:00:45 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 11 Nov 2013 16:00:45 -0600
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA++BO6TD2zzqBfLmvf4Q8omYs4SYG6rCueFVCcdUCFrqNjgg4g@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CA++BO6TD2zzqBfLmvf4Q8omYs4SYG6rCueFVCcdUCFrqNjgg4g@mail.gmail.com>
Message-ID: <CAChbWaMyU+sBcoUeaWx_fVnD=LW6JmguOse9nT3AtwgGSuiqAA@mail.gmail.com>

>From the outside looking in...

I do not see anything preventing Greg from producing many macros or an
entire syntax sub-system to emulate and empower him with any sugary
languages that he might prefer or desire.  It is just going to be quite a
bit of work for him, but he could do it himself, if we wanted to turn
Rust's syntax into something closer to Type Clojure or create a DSL.

 Is that not true ?



On Mon, Nov 11, 2013 at 3:28 PM, Corey Richardson <corey at octayn.net> wrote:

> On Mon, Nov 11, 2013 at 4:07 PM, Greg <greg at kinostudios.com> wrote:
> > I don't think Rust can succeed as a language if it massively differs,
> > visually, from the language it intends to offset (C++).
> >
> > Yes, I agree, and that's why I wrote:
> >
> > "By this point, I'm aware that this is unlikely to happen."
> >
> > I think it's still possible to simplify Rust's existing syntax while
> > maintaining the features it offers.
> >
>
> My point is that the familiar syntax *is* a feature. What
> simplifications do you propose? I think everyone is mostly happy with
> the syntax at this point, so your proposed changes and justification
> are going to be very pursuasive, and followed by a PR, for there to be
> a chance of them being accepted.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/917ad41b/attachment-0001.html>

From banderson at mozilla.com  Mon Nov 11 14:01:53 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 11 Nov 2013 14:01:53 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
Message-ID: <528153D1.1030003@mozilla.com>

On 11/11/2013 01:07 PM, Greg wrote:
>> I don't think Rust can succeed as a language if it massively differs,
>> visually, from the language it intends to offset (C++).
>
> Yes, I agree, and that's why I wrote:
>
> /"By this point, I'm aware that this is unlikely to happen."/
>
> I think it's still possible to simplify Rust's existing syntax while 
> maintaining the features it offers.
>
> I am hoping that the developers of Rust will consider this issue 
> important enough to put more thought into it.
>
> I am aware that I am jumping into an issue at a point in time that's 
> considered "late in the game".
>
> From the outside, I can say (with confidence), that Rust is still a 
> nearly unheard-of language, and therefore it still has wiggle-room for 
> improvement, even if the Rust developers and community, because they 
> have been immersed in the language for quite some time, cannot see 
> that this is in fact true.
>
> I also believe Tim when he said that years of effort went into 
> designing the syntax.
>
> However, during those many years, did any of the brains that were 
> involved in designing the syntax seriously consider Clojure's syntax, 
> or Typed Clojure?
>
> I'm almost certain that the answer is "no" (partly because these 
> languages/dialects did not exist at the time).
>
> What about Lua, which is more C-like?
>
> Or CoffeeScript?
>
> Looking at the "Influenced By" section on Wikipedia seems to indicate 
> that the answer to these questions is, again, "no".

The answer is 'yes'. The designers of Rust are well aware of these 
languages and many others and have debated syntax issues repeatedly (as 
it is the most beloved pasttime of language designers). The current 
syntax was designed very intentionally the way it is.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/ce2fec45/attachment.html>

From niko at alum.mit.edu  Mon Nov 11 14:16:46 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 11 Nov 2013 17:16:46 -0500
Subject: [rust-dev] returning an item from a collection
In-Reply-To: <5280EE45.7020905@gmail.com>
References: <5280D114.8010907@gmail.com>
	<501973145.8294345.1384177647691.JavaMail.zimbra@mozilla.com>
	<5280EE45.7020905@gmail.com>
Message-ID: <20131111221646.GC14427@Mr-Bennet>

On Mon, Nov 11, 2013 at 03:48:37PM +0100, spir wrote:
> Also, what does
> 	let y = x;
> mean in Rust if x's type is constant (as opposed to a generic type
> var)? Does it depend on the exact type? and specifically what happens
> in the case of simple, atomic, type?

The meaning is:

- shallow copy the data from x into y;
- if x has a type that cannot be copied (e.g., `~T`), invalidate x
  so that it can no longer be used ("move").


Niko

From clements at brinckerhoff.org  Mon Nov 11 15:12:27 2013
From: clements at brinckerhoff.org (John Clements)
Date: Mon, 11 Nov 2013 15:12:27 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
Message-ID: <A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>


On Nov 11, 2013, at 1:07 PM, Greg wrote:

>> I don't think Rust can succeed as a language if it massively differs,
>> visually, from the language it intends to offset (C++).
> 
> Yes, I agree, and that's why I wrote:
> 
> 	"By this point, I'm aware that this is unlikely to happen."
> 

...

> However, during those many years, did any of the brains that were involved in designing the syntax seriously consider Clojure's syntax, or Typed Clojure?
> 
> I'm almost certain that the answer is "no" (partly because these languages/dialects did not exist at the time).
> 
> What about Lua, which is more C-like?
> 
> Or CoffeeScript?

Greg, thanks for your comments!

In fact, nearly all of the designers of Rust are deeply familiar with the syntactic conventions of these and other languages.  Speaking only for myself, I come from Racket, and I'm a strong proponent of fully parenthesized syntaxes.

But! 

Rust is not that language.  As you suggest (and others confirm), that train left the station long, long ago. The choice of the Rust team to adopt a C++-like syntax was very deliberate, and I'm confident that the members of this team still believe that was the right choice.

With that said, though, Rust is a new and exciting language; if you can think of improvements, try coding them up and see what you get! In my experience, the Rust developers are always happy to hear from volunteers who are excited about the language and have concrete pull requests. If you had the energy to build an alternate front-end using a parenthesized syntax, I'm sure there are others that would give it a try. Me, for instance!

All the best,

John Clements


From gaetan at xeberon.net  Mon Nov 11 15:21:37 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 12 Nov 2013 00:21:37 +0100
Subject: [rust-dev] About owned pointer
In-Reply-To: <527E3E3C.3040108@gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<527E3E3C.3040108@gmail.com>
Message-ID: <CANK7tAEKQ7X4yEWh1PtiJi6=3RWnzQeK=vVrGrS+jGm1BJD6YQ@mail.gmail.com>

Just an humble opinion.

I kind of like saying that the code i write must be beautiful. The langage
should allow to write "beautiful" code. It is more than a personnal point
of view, it is also very important. if it is a pain in the ... to use an
essential feature, or if i will never remember how to do it without copy
paste because there is no "logic" behind it, i will have a bad opinion on
the langage itself.

The real question are:
- as a typicial rust programmer, will i see the usage of "str" or "~str" as
logic or will i have to copy paste some sample code each time "because it
works this way in rust"
- the boilder plates theory. Can i avoid them? I think a good modern
language should allow me to avoid writing useless code, each time the same
things. That is the real mess with C++.

Gaetan

Le samedi 9 novembre 2013, spir a ?crit :

> On 11/09/2013 06:43 AM, Kevin Ballard wrote:> On Nov 8, 2013, at 9:38 PM,
> Daniel Micay <danielmicay at gmail.com> wrote:
>
>>
>>  On Sat, Nov 9, 2013 at 12:36 AM, Kevin Ballard <kevin at sb.org> wrote:
>>> On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>>>
>>>  I know that many people don't like the fact that, syntactically,
>>>> vectors and strings have a sigil in front of them, but please consider that
>>>> there are many design constraints here. What works for another language may
>>>> not work for Rust, because of these constraints.
>>>>
>>>
>>> Personally, I find it great that they have a sigil in front of them. It
>>> reminds me that they're stored in the heap.
>>>
>>> -Kevin
>>>
>>> Since library containers, smart pointers and other types don't have
>>> them, I don't think it's helpful in that regard.
>>>
>>
>> Well no, you can't assume that the absence of a sigil means the absence
>> of heap storage. But for types that are possibly not stored on the heap,
>> such as str (which can be &'static str) and [T] (which can be a fixed-size
>> stack-allocated vector), the ~ is a useful distinction.
>>
>> -Kevin
>>
>
> Can we, then, even consider the opposite: having a sigil for static data
> (mainly literal strings stored in static mem, I'd say) or generally
> non-heap data (thus including eg static arrays stored on stack)? The
> advantage is that this restores coherence between all heap of heap data.
> I'd use '$'! (what else can this sign be good for, anyway? ;-)
>
> [But where should the sigil go? In front of the data literal, as in
>         let stst = $"Hello, world!";
>         let nums = $[1,2,3];
> or in front of the type, or of the id itself?]
>
> Also, is it at all possible, in the long term maybe, to consider letting
> the compiler choose where to store, in cases where a possible pointer is
> meaningless, that is it does not express a true reference (shared object,
> that a.x is also b.y), instead is used for technical or efficiency reasons
> (that memory is not elastic!, for avoiding copy, etc...)?
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>


-- 
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/48eeaea2/attachment.html>

From catamorphism at gmail.com  Mon Nov 11 15:27:42 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 11 Nov 2013 15:27:42 -0800
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAEKQ7X4yEWh1PtiJi6=3RWnzQeK=vVrGrS+jGm1BJD6YQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<527E3E3C.3040108@gmail.com>
	<CANK7tAEKQ7X4yEWh1PtiJi6=3RWnzQeK=vVrGrS+jGm1BJD6YQ@mail.gmail.com>
Message-ID: <CADcg8=k05ZKE59==szcLiU6qTL9hS6388VGx3mB6_kiaCe6r6g@mail.gmail.com>

On Mon, Nov 11, 2013 at 3:21 PM, Gaetan <gaetan at xeberon.net> wrote:
> Just an humble opinion.
>
> I kind of like saying that the code i write must be beautiful. The langage
> should allow to write "beautiful" code. It is more than a personnal point of
> view, it is also very important. if it is a pain in the ... to use an
> essential feature, or if i will never remember how to do it without copy
> paste because there is no "logic" behind it, i will have a bad opinion on
> the langage itself.

Of course, "beauty" is subjective. Personally, I see it as
language-independent, and don't find it any harder to write beautiful
code in Rust than in any other language I know. It's certainly easier
than in some languages, since I don't have to spend as much time
debugging run-time errors and can spend that time making my code
aesthetically better.

>
> The real question are:
> - as a typicial rust programmer, will i see the usage of "str" or "~str" as
> logic or will i have to copy paste some sample code each time "because it
> works this way in rust"

Once you gain experience with Rust, this will seem natural. You reason
about whether you're passing data by value or by reference (i.e.
borrowed pointer) anyway, and Rust just makes that distinction more
explicit.

> - the boilder plates theory. Can i avoid them? I think a good modern
> language should allow me to avoid writing useless code, each time the same
> things. That is the real mess with C++.

I'm not sure what your question is here, sorry.

Cheers,
Tim

>
> Gaetan
>
>
> Le samedi 9 novembre 2013, spir a ?crit :
>
>> On 11/09/2013 06:43 AM, Kevin Ballard wrote:> On Nov 8, 2013, at 9:38 PM,
>> Daniel Micay <danielmicay at gmail.com> wrote:
>>>
>>>
>>>> On Sat, Nov 9, 2013 at 12:36 AM, Kevin Ballard <kevin at sb.org> wrote:
>>>> On Nov 8, 2013, at 2:21 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>>>>
>>>>> I know that many people don't like the fact that, syntactically,
>>>>> vectors and strings have a sigil in front of them, but please consider that
>>>>> there are many design constraints here. What works for another language may
>>>>> not work for Rust, because of these constraints.
>>>>
>>>>
>>>> Personally, I find it great that they have a sigil in front of them. It
>>>> reminds me that they're stored in the heap.
>>>>
>>>> -Kevin
>>>>
>>>> Since library containers, smart pointers and other types don't have
>>>> them, I don't think it's helpful in that regard.
>>>
>>>
>>> Well no, you can't assume that the absence of a sigil means the absence
>>> of heap storage. But for types that are possibly not stored on the heap,
>>> such as str (which can be &'static str) and [T] (which can be a fixed-size
>>> stack-allocated vector), the ~ is a useful distinction.
>>>
>>> -Kevin
>>
>>
>> Can we, then, even consider the opposite: having a sigil for static data
>> (mainly literal strings stored in static mem, I'd say) or generally non-heap
>> data (thus including eg static arrays stored on stack)? The advantage is
>> that this restores coherence between all heap of heap data.
>> I'd use '$'! (what else can this sign be good for, anyway? ;-)
>>
>> [But where should the sigil go? In front of the data literal, as in
>>         let stst = $"Hello, world!";
>>         let nums = $[1,2,3];
>> or in front of the type, or of the id itself?]
>>
>> Also, is it at all possible, in the long term maybe, to consider letting
>> the compiler choose where to store, in cases where a possible pointer is
>> meaningless, that is it does not express a true reference (shared object,
>> that a.x is also b.y), instead is used for technical or efficiency reasons
>> (that memory is not elastic!, for avoiding copy, etc...)?
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> --
> -----
> Gaetan
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From gaetan at xeberon.net  Mon Nov 11 15:52:01 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 12 Nov 2013 00:52:01 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528153D1.1030003@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
Message-ID: <CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>

Can we have Two rust?

The first one would be easy to learn, easy to read, and do most of ones
would expect: on demand garbage collector, traits, Owned pointers,...

The second one would include all advanced feature we actually don t
need everyday.

Of course, we don t want to split the language, but rather pr?sent the
current things differently. The tutorials are a good starting point
however, the rest of the documentations are quite complex. I would be very
delighted to help on this matter. There could be some effort on
simplification of the API (std/extra): provides just "the right functions"
first, and allow all flexibility in a second step, maybe in an "advanced
functions" parts in each API doc.

For instance url.rs. To parse a string, you have to write this:

let u = url::from_str(urlstring).unwrap();

I would propose this solution:

let u = parse_url(urlstring);


=> simpler, easier to read, easier to remember !
Of course, the unwrap thing would still be here.

base64.rs:

let s = [52, 53, 54].to_base64(STANDARD);


=> why adding the "standard" argument? One will ALWAYS want the "STANDARD"
method of creating the base64 representation of some bytes, why not adding
this argument as default.

There are some minor change to the API that would help a lot the learning
of this language, along with adding more code sample in the documentation.

After year of writing C++ code with complex API (boost) I enjoy writing
with python which seems to provide just the right methods I need.

I'll willing to help, but I don't easily find a easy starting point :)

Gaetan

Le lundi 11 novembre 2013, Brian Anderson a ?crit :

>  On 11/11/2013 01:07 PM, Greg wrote:
>
>  I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).
>
>
>  Yes, I agree, and that's why I wrote:
>
>  * "By this point, I'm aware that this is unlikely to happen."*
>
>  I think it's still possible to simplify Rust's existing syntax while
> maintaining the features it offers.
>
>  I am hoping that the developers of Rust will consider this issue
> important enough to put more thought into it.
>
>  I am aware that I am jumping into an issue at a point in time that's
> considered "late in the game".
>
>  From the outside, I can say (with confidence), that Rust is still a
> nearly unheard-of language, and therefore it still has wiggle-room for
> improvement, even if the Rust developers and community, because they have
> been immersed in the language for quite some time, cannot see that this is
> in fact true.
>
>  I also believe Tim when he said that years of effort went into designing
> the syntax.
>
>  However, during those many years, did any of the brains that were
> involved in designing the syntax seriously consider Clojure's syntax, or
> Typed Clojure?
>
>  I'm almost certain that the answer is "no" (partly because these
> languages/dialects did not exist at the time).
>
>  What about Lua, which is more C-like?
>
>  Or CoffeeScript?
>
>  Looking at the "Influenced By" section on Wikipedia seems to indicate
> that the answer to these questions is, again, "no".
>
>
> The answer is 'yes'. The designers of Rust are well aware of these
> languages and many others and have debated syntax issues repeatedly (as it
> is the most beloved pasttime of language designers). The current syntax was
> designed very intentionally the way it is.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/b81a0524/attachment.html>

From greg at kinostudios.com  Mon Nov 11 16:00:49 2013
From: greg at kinostudios.com (Greg)
Date: Mon, 11 Nov 2013 19:00:49 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
Message-ID: <2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>

Thanks John, for the friendly email. :-)

> The choice of the Rust team to adopt a C++-like syntax was very deliberate, and I'm confident that the members of this team still believe that was the right choice.

I wonder, right for what reason? Do they actually *like* it? I wrote a lot of code in C++ back in the day. Can't touch the stuff anymore. *shudders*

Or is it 'right' because it's familiar to C++ developers?

I should have mentioned Java in my original post to the list.

Java is relevant for a few reasons:

1. It has been around for a long time.
2. It's quite popular.
3. It's C-like, familiar, and attempts to implement some safety into the language
4. Its syntax is fairly simple (compared to C++).

And most significantly of all:

5. It has gone through some significant syntactic changes, _years_ after being well established and well known.

For example, Java 1.5 added Generics to the language (a simplified version of C++ templates).

The recent Java has added anonymous functions (lambdas).

Other well established languages have also made significant changes to their syntax well after their first birthday. Objective-C, for example, added properties and Automatic Reference Counting in with it turned 2.0.

It also added syntax for various literals (arrays, maps, etc.): http://clang.llvm.org/docs/ObjectiveCLiterals.html

So, given the history of these well established languages, I think there's still plenty of opportunity for change with Rust. More so, in fact, due to its alpha status. It's easier to remove syntax while a language is young, and Rust is still very young.

> With that said, though, Rust is a new and exciting language; if you can think of improvements, try coding them up and see what you get! In my experience, the Rust developers are always happy to hear from volunteers who are excited about the language and have concrete pull requests. If you had the energy to build an alternate front-end using a parenthesized syntax, I'm sure there are others that would give it a try. Me, for instance!

I'd love to, but zero time at the moment. :-(

Also, I'm not simply advocating a parenthesis-based syntax (though that would be *awesome*!). I think the present syntax is malleable and can be simplified and improved while retaining its C-ness for the sake of developers who haven't quite yet expanded their minds... :-p

Cheers,
Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

On Nov 11, 2013, at 6:12 PM, John Clements <clements at brinckerhoff.org> wrote:

> 
> On Nov 11, 2013, at 1:07 PM, Greg wrote:
> 
>>> I don't think Rust can succeed as a language if it massively differs,
>>> visually, from the language it intends to offset (C++).
>> 
>> Yes, I agree, and that's why I wrote:
>> 
>> 	"By this point, I'm aware that this is unlikely to happen."
>> 
> 
> ...
> 
>> However, during those many years, did any of the brains that were involved in designing the syntax seriously consider Clojure's syntax, or Typed Clojure?
>> 
>> I'm almost certain that the answer is "no" (partly because these languages/dialects did not exist at the time).
>> 
>> What about Lua, which is more C-like?
>> 
>> Or CoffeeScript?
> 
> Greg, thanks for your comments!
> 
> In fact, nearly all of the designers of Rust are deeply familiar with the syntactic conventions of these and other languages.  Speaking only for myself, I come from Racket, and I'm a strong proponent of fully parenthesized syntaxes.
> 
> But! 
> 
> Rust is not that language.  As you suggest (and others confirm), that train left the station long, long ago. The choice of the Rust team to adopt a C++-like syntax was very deliberate, and I'm confident that the members of this team still believe that was the right choice.
> 
> With that said, though, Rust is a new and exciting language; if you can think of improvements, try coding them up and see what you get! In my experience, the Rust developers are always happy to hear from volunteers who are excited about the language and have concrete pull requests. If you had the energy to build an alternate front-end using a parenthesized syntax, I'm sure there are others that would give it a try. Me, for instance!
> 
> All the best,
> 
> John Clements
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/5bad2676/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/5bad2676/attachment.sig>

From catamorphism at gmail.com  Mon Nov 11 16:01:07 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 11 Nov 2013 16:01:07 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
Message-ID: <CADcg8=n9hpw-3Dd1M7_Lg_SLeuNDpmqKvKTpSCQKf9KWKPT5tQ@mail.gmail.com>

On Mon, Nov 11, 2013 at 3:52 PM, Gaetan <gaetan at xeberon.net> wrote:
> Can we have Two rust?
>
> The first one would be easy to learn, easy to read, and do most of ones
> would expect: on demand garbage collector, traits, Owned pointers,...
>
> The second one would include all advanced feature we actually don t need
> everyday.
>
> Of course, we don t want to split the language, but rather pr?sent the
> current things differently. The tutorials are a good starting point however,
> the rest of the documentations are quite complex. I would be very delighted
> to help on this matter. There could be some effort on simplification of the
> API (std/extra): provides just "the right functions" first, and allow all
> flexibility in a second step, maybe in an "advanced functions" parts in each
> API doc.

We always welcome documentation patches!

A more ambitious project would be to add "language levels" to Rust
(like Racket has). If you were interested in pursuing this, you would
want to discuss it with members of the core team. I doubt it would be
accepted as a patch in the short term (since it's not a 1.0 priority),
but in the long term, it's certainly possible.

Cheers,
Tim

>
> For instance url.rs. To parse a string, you have to write this:
>
> let u = url::from_str(urlstring).unwrap();
>
> I would propose this solution:
>
> let u = parse_url(urlstring);
>
>
> => simpler, easier to read, easier to remember !
> Of course, the unwrap thing would still be here.
>
> base64.rs:
>
> let s = [52, 53, 54].to_base64(STANDARD);
>
>
> => why adding the "standard" argument? One will ALWAYS want the "STANDARD"
> method of creating the base64 representation of some bytes, why not adding
> this argument as default.
>
> There are some minor change to the API that would help a lot the learning of
> this language, along with adding more code sample in the documentation.
>
> After year of writing C++ code with complex API (boost) I enjoy writing with
> python which seems to provide just the right methods I need.
>
> I'll willing to help, but I don't easily find a easy starting point :)
>
> Gaetan
>
> Le lundi 11 novembre 2013, Brian Anderson a ?crit :
>
>> On 11/11/2013 01:07 PM, Greg wrote:
>>
>> I don't think Rust can succeed as a language if it massively differs,
>> visually, from the language it intends to offset (C++).
>>
>>
>> Yes, I agree, and that's why I wrote:
>>
>> "By this point, I'm aware that this is unlikely to happen."
>>
>> I think it's still possible to simplify Rust's existing syntax while
>> maintaining the features it offers.
>>
>> I am hoping that the developers of Rust will consider this issue important
>> enough to put more thought into it.
>>
>> I am aware that I am jumping into an issue at a point in time that's
>> considered "late in the game".
>>
>> From the outside, I can say (with confidence), that Rust is still a nearly
>> unheard-of language, and therefore it still has wiggle-room for improvement,
>> even if the Rust developers and community, because they have been immersed
>> in the language for quite some time, cannot see that this is in fact true.
>>
>> I also believe Tim when he said that years of effort went into designing
>> the syntax.
>>
>> However, during those many years, did any of the brains that were involved
>> in designing the syntax seriously consider Clojure's syntax, or Typed
>> Clojure?
>>
>> I'm almost certain that the answer is "no" (partly because these
>> languages/dialects did not exist at the time).
>>
>> What about Lua, which is more C-like?
>>
>> Or CoffeeScript?
>>
>> Looking at the "Influenced By" section on Wikipedia seems to indicate that
>> the answer to these questions is, again, "no".
>>
>>
>> The answer is 'yes'. The designers of Rust are well aware of these
>> languages and many others and have debated syntax issues repeatedly (as it
>> is the most beloved pasttime of language designers). The current syntax was
>> designed very intentionally the way it is.
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From danielmicay at gmail.com  Mon Nov 11 16:01:34 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 11 Nov 2013 19:01:34 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
Message-ID: <CA+DvKQJ1URrdapvacXFYzAjVF6MoBX27B+bCuFJJqMkp8dty8g@mail.gmail.com>

On Mon, Nov 11, 2013 at 6:52 PM, Gaetan <gaetan at xeberon.net> wrote:

>
> For instance url.rs. To parse a string, you have to write this:
>
> let u = url::from_str(urlstring).unwrap();
>
> I would propose this solution:
>
> let u = parse_url(urlstring);
>
>
> => simpler, easier to read, easier to remember !
> Of course, the unwrap thing would still be here.
>

Rust generally uses sum types to report errors. The `from_str` method
doesn't work for all inputs, so it returns `None` in those cases. The
ability to handle errors does need to be there, and forcing a concious
decision on how to handle common, easily recoverable errors makes a lot of
sense to me.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/a9e3c0f5/attachment.html>

From catamorphism at gmail.com  Mon Nov 11 16:05:29 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Mon, 11 Nov 2013 16:05:29 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
	<2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>
Message-ID: <CADcg8=kKn72F3LeCnS7i2DBA8vFS=f4B17b2Df0uzLRXC=1J7w@mail.gmail.com>

Mod hat: This thread has become pretty off-topic. Let's wind it down
and move any specific questions or concrete proposals regarding Rust
to a new, separate thread.

Please familiarize yourself with the "Conduct" section of
https://github.com/mozilla/rust/wiki/Note-development-policy ,
particularly these parts:

"Respect that people have differences of opinion and that every design
or implementation choice carries a trade-off and numerous costs. There
is seldom a right answer.
Please keep unstructured critique to a minimum. If you have solid
ideas you want to experiment with, make a fork and see how it works."

In particular, discussing the merits or lack thereof of C or Java
syntax is out of scope for this mailing list. I understand that this
subject came up because it was cited as a reason for Rust's syntax,
but as several people have said, these decisions have been made and
won't be revisited (except, *perhaps*, in the presence of a concrete
proposal and preferably an implementation). Also, please avoid
suggesting that people who do or don't like a particular syntax
haven't expanded their mind; it's okay for different people to have
different opinions about language design, and choosing any one
approach doesn't mean we think less of people who prefer other ones.

Cheers,
Tim


On Mon, Nov 11, 2013 at 4:00 PM, Greg <greg at kinostudios.com> wrote:
> Thanks John, for the friendly email. :-)
>
> The choice of the Rust team to adopt a C++-like syntax was very deliberate,
> and I'm confident that the members of this team still believe that was the
> right choice.
>
>
> I wonder, right for what reason? Do they actually *like* it? I wrote a lot
> of code in C++ back in the day. Can't touch the stuff anymore. *shudders*
>
> Or is it 'right' because it's familiar to C++ developers?
>
> I should have mentioned Java in my original post to the list.
>
> Java is relevant for a few reasons:
>
> 1. It has been around for a long time.
> 2. It's quite popular.
> 3. It's C-like, familiar, and attempts to implement some safety into the
> language
> 4. Its syntax is fairly simple (compared to C++).
>
> And most significantly of all:
>
> 5. It has gone through some significant syntactic changes, _years_ after
> being well established and well known.
>
> For example, Java 1.5 added Generics to the language (a simplified version
> of C++ templates).
>
> The recent Java has added anonymous functions (lambdas).
>
> Other well established languages have also made significant changes to their
> syntax well after their first birthday. Objective-C, for example, added
> properties and Automatic Reference Counting in with it turned 2.0.
>
> It also added syntax for various literals (arrays, maps, etc.):
> http://clang.llvm.org/docs/ObjectiveCLiterals.html
>
> So, given the history of these well established languages, I think there's
> still plenty of opportunity for change with Rust. More so, in fact, due to
> its alpha status. It's easier to remove syntax while a language is young,
> and Rust is still very young.
>
> With that said, though, Rust is a new and exciting language; if you can
> think of improvements, try coding them up and see what you get! In my
> experience, the Rust developers are always happy to hear from volunteers who
> are excited about the language and have concrete pull requests. If you had
> the energy to build an alternate front-end using a parenthesized syntax, I'm
> sure there are others that would give it a try. Me, for instance!
>
>
> I'd love to, but zero time at the moment. :-(
>
> Also, I'm not simply advocating a parenthesis-based syntax (though that
> would be *awesome*!). I think the present syntax is malleable and can be
> simplified and improved while retaining its C-ness for the sake of
> developers who haven't quite yet expanded their minds... :-p
>
> Cheers,
> Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> On Nov 11, 2013, at 6:12 PM, John Clements <clements at brinckerhoff.org>
> wrote:
>
>
> On Nov 11, 2013, at 1:07 PM, Greg wrote:
>
> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).
>
>
> Yes, I agree, and that's why I wrote:
>
> "By this point, I'm aware that this is unlikely to happen."
>
>
> ...
>
> However, during those many years, did any of the brains that were involved
> in designing the syntax seriously consider Clojure's syntax, or Typed
> Clojure?
>
> I'm almost certain that the answer is "no" (partly because these
> languages/dialects did not exist at the time).
>
> What about Lua, which is more C-like?
>
> Or CoffeeScript?
>
>
> Greg, thanks for your comments!
>
> In fact, nearly all of the designers of Rust are deeply familiar with the
> syntactic conventions of these and other languages.  Speaking only for
> myself, I come from Racket, and I'm a strong proponent of fully
> parenthesized syntaxes.
>
> But!
>
> Rust is not that language.  As you suggest (and others confirm), that train
> left the station long, long ago. The choice of the Rust team to adopt a
> C++-like syntax was very deliberate, and I'm confident that the members of
> this team still believe that was the right choice.
>
> With that said, though, Rust is a new and exciting language; if you can
> think of improvements, try coding them up and see what you get! In my
> experience, the Rust developers are always happy to hear from volunteers who
> are excited about the language and have concrete pull requests. If you had
> the energy to build an alternate front-end using a parenthesized syntax, I'm
> sure there are others that would give it a try. Me, for instance!
>
> All the best,
>
> John Clements
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From greg at kinostudios.com  Mon Nov 11 16:24:10 2013
From: greg at kinostudios.com (Greg)
Date: Mon, 11 Nov 2013 19:24:10 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CADcg8=kKn72F3LeCnS7i2DBA8vFS=f4B17b2Df0uzLRXC=1J7w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
	<2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>
	<CADcg8=kKn72F3LeCnS7i2DBA8vFS=f4B17b2Df0uzLRXC=1J7w@mail.gmail.com>
Message-ID: <39EE4677-087C-4383-83C1-CF79A0FFC9AB@kinostudios.com>

On Nov 11, 2013, at 7:05 PM, Tim Chevalier <catamorphism at gmail.com> wrote:
> Also, please avoid
> suggesting that people who do or don't like a particular syntax
> haven't expanded their mind; it's okay for different people to have
> different opinions about language design, and choosing any one
> approach doesn't mean we think less of people who prefer other ones.

I probably could have phrased that better to avoid misunderstandings. No offense was intended.

The comment is a reference to anyone who is unfamiliar with the syntax of non-C-type languages. It's not a reference to anyone familiar with various syntaxes (C-type and others) and prefers C++.

No superiority-complex, condescension, or anything of that sort was intended, please don't misunderstand.

Kind regards,
Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/3b2cfcd5/attachment.sig>

From pcwalton at mozilla.com  Mon Nov 11 16:59:23 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 09:59:23 +0900
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
	<2E45FBF8-8124-45AA-994B-92559C6FB5B8@kinostudios.com>
Message-ID: <52817D6B.2050608@mozilla.com>

On 11/12/13 9:00 AM, Greg wrote:
> Thanks John, for the friendly email. :-)
>
>> The choice of the Rust team to adopt a C++-like syntax was very
>> deliberate, and I'm confident that the members of this team still
>> believe that was the right choice.
>
> I wonder, right for what reason? Do they actually */like*/ it? I wrote a
> lot of code in C++ back in the day. Can't touch the stuff anymore.
> *shudders*

I prefer C-like (Algol-like, if you want to be pedantic :)) syntax to 
S-expressions.

Patrick


From bjzaba at yahoo.com.au  Mon Nov 11 17:15:21 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Tue, 12 Nov 2013 12:15:21 +1100
Subject: [rust-dev] About owned pointer
In-Reply-To: <CANK7tAEKQ7X4yEWh1PtiJi6=3RWnzQeK=vVrGrS+jGm1BJD6YQ@mail.gmail.com>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
	<CADd11yX3kNX2QDDCgi5JKhYLHqKqX6N0xsf09ir7NpUbONLh_Q@mail.gmail.com>
	<527D1ED9.8000008@gmail.com> <527D20C4.3060107@mozilla.com>
	<CADd11yX7iFJtnW+cgU72ehPPdz1TgOh5Ni35MMrFO1kr2BRbkQ@mail.gmail.com>
	<527D33E7.4040007@gmail.com>
	<CADJiDhs3X1rPdRHmUiP+AAxnEqrboxstnmRM2-MLSwRK+Gf6nA@mail.gmail.com>
	<527D560E.5030807@mozilla.com>
	<CADJiDhvO0L+DAXM_F4Mz510SKWZOZ+=kw7NNMJFTU3117tq+6g@mail.gmail.com>
	<527D6082.7030507@mozilla.com>
	<CADJiDhuFye56Fba22+X3QP9d-1-ZrkUF7sjojRQAQrTvZT-DXg@mail.gmail.com>
	<527D63F0.1030004@mozilla.com>
	<AE59C4AF-99DD-4742-9BE5-A4ED3950B886@sb.org>
	<CA+DvKQKYJaBEHUqhZZCdDOBB6znp_Uuq86aP5gHJnYmkQgqCSg@mail.gmail.com>
	<559DC61A-0CD3-4B74-9A6F-3B8C3A5E734E@sb.org>
	<527E3E3C.3040108@gmail.com>
	<CANK7tAEKQ7X4yEWh1PtiJi6=3RWnzQeK=vVrGrS+jGm1BJD6YQ@mail.gmail.com>
Message-ID: <32422932-E7DC-4EB3-865B-DF95023BDC32@yahoo.com.au>

On 12 Nov 2013, at 10:21 am, Gaetan <gaetan at xeberon.net> wrote:

> - as a typicial rust programmer, will i see the usage of "str" or "~str" as logic or will i have to copy paste some sample code each time "because it works this way in rust?

This is what I thought at first, but once you use it for a while it will become natural, and you will find the distinction very useful. Just give it a chance before you jump to conclusions - you won?t regret it! :)

> - the boilder plates theory. Can i avoid them? I think a good modern language should allow me to avoid writing useless code, each time the same things. That is the real mess with C++.

They are not useless - `~str`, `&str`, `&'a str` and `&'static str` all convey extremely important semantic information both to the programmer and to the compiler. Changing `~str` to `str` would cause more inconsistencies (what about the borrowed pointers?) with a loss of the afore mentioned semantic information.

~Brendan

From bjzaba at yahoo.com.au  Mon Nov 11 17:23:54 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Tue, 12 Nov 2013 12:23:54 +1100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
Message-ID: <290552A5-BEB7-4326-B336-FC982D1C60B8@yahoo.com.au>

On 12 Nov 2013, at 10:12 am, John Clements <clements at brinckerhoff.org> wrote:

> If you had the energy to build an alternate front-end using a parenthesized syntax, I'm sure there are others that would give it a try. Me, for instance!

It would be nice if we could:

- A: desugar Rust into a small kernel language
- B: allow rustc to take in some sort of raw AST data (not sure if that?s already possible)
- C: have a way of outputting the AST data in a certain syntax.

That would allow folks like me to have a nice Haskelly syntax as well as an s-expr style!

Heh.

~Brendan


From sfackler at gmail.com  Mon Nov 11 17:35:05 2013
From: sfackler at gmail.com (Steven Fackler)
Date: Mon, 11 Nov 2013 17:35:05 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <290552A5-BEB7-4326-B336-FC982D1C60B8@yahoo.com.au>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
	<290552A5-BEB7-4326-B336-FC982D1C60B8@yahoo.com.au>
Message-ID: <CANb7cF55E0EYqWwbBgc0hOiM9+0n6HDHE8gTDbdRgz559LVSjA@mail.gmail.com>

> base64.rs:
>    let s = [52, 53, 54].to_base64(STANDARD);
>
> => why adding the "standard" argument? One will ALWAYS want the
"STANDARD" method of creating the base64 representation of some bytes, why
not adding this argument as default.

That is not true. If you are going to be putting the Base64 encoded data
into a URL you're going to have to use URL_SAFE instead of STANDARD. If
you're trying to send an email, you'll need to use MIME instead of
STANDARD. If you're talking to a service that requires one of the ~10 other
variants of Base64, you'll need to use a custom config struct.

Steven Fackler


On Mon, Nov 11, 2013 at 5:23 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:

> On 12 Nov 2013, at 10:12 am, John Clements <clements at brinckerhoff.org>
> wrote:
>
> > If you had the energy to build an alternate front-end using a
> parenthesized syntax, I'm sure there are others that would give it a try.
> Me, for instance!
>
> It would be nice if we could:
>
> - A: desugar Rust into a small kernel language
> - B: allow rustc to take in some sort of raw AST data (not sure if that?s
> already possible)
> - C: have a way of outputting the AST data in a certain syntax.
>
> That would allow folks like me to have a nice Haskelly syntax as well as
> an s-expr style!
>
> Heh.
>
> ~Brendan
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131111/abdc884c/attachment.html>

From oren at ben-kiki.org  Mon Nov 11 23:32:06 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 09:32:06 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <52814F8F.3020609@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
Message-ID: <CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>

Ah, thanks. I wasn't aware of that. I should start tracking that RSS feed...

I am very concerned that single-inheritance takes the language in the wrong
direction. I feel that a more mixin-oriented solution would better match
Rust's traits based type system. I posted a comment the blog entry you
gave, which I assume is a more appropriate venue than this thread...?

Either way, I gather there's no current idiomatic pattern for this - we are
waiting until some solution is agreed upon (and implemented :-)

Thanks,

Oren.


On Mon, Nov 11, 2013 at 11:43 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/12/13 5:16 AM, Oren Ben-Kiki wrote:
>
>> I googled around and this has been asked before several times; there are
>> answers that use obsolete syntax and Rust concepts, so I thought it
>> might be a good idea to revisit the issue.
>>
>> The basic use case is having some trait, and having some (base/mixin)
>> struct implementing it. Now, one wants to have a 2nd (derived/importing)
>> struct implementing the trait, based on the 1st struct implementation
>> (including its data members).
>>
>
> There are proposals for this, if I understand you correctly. This is
> needed in Servo.
>
> http://smallcultfollowing.com/babysteps/blog/2013/10/24/
> single-inheritance/
>
> Patrick
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/d09b23d6/attachment.html>

From pcwalton at mozilla.com  Mon Nov 11 23:43:44 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 16:43:44 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
Message-ID: <5281DC30.8040402@mozilla.com>

On 11/12/13 4:32 PM, Oren Ben-Kiki wrote:
> Ah, thanks. I wasn't aware of that. I should start tracking that RSS feed...
>
> I am very concerned that single-inheritance takes the language in the
> wrong direction. I feel that a more mixin-oriented solution would better
> match Rust's traits based type system. I posted a comment the blog entry
> you gave, which I assume is a more appropriate venue than this thread...?

Your solution does not match the performance of single inheritance, 
because it has virtual method calls for every field access from the 
"outside" of the trait.

We don't want single inheritance because we're enamored with Java or 
anything, we want it because nothing that we've been able to come up 
with matches the performance that the prefix property on fields buys 
you. C++ code can be very fast for a reason.

We considered Go's anonymous fields but rejected them because they don't 
support virtual methods at the same time as field embedding.

Patrick


From oren at ben-kiki.org  Mon Nov 11 23:53:18 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 09:53:18 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5281DC30.8040402@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
Message-ID: <CADJiDhsx_nos68pyW-CqD4oTZ-oLzutv5oW02tANCdbLGML=vg@mail.gmail.com>

"Your solution does not match the performance of single inheritance,
because it has virtual method calls for every field access from the
"outside" of the trait."

Sorry, I don't follow.

Access to members from outside of the traits would require accessing the
concrete type. Since the approach I described used source transformation,
then this would just be a normal data member access, as efficient as single
inheritance.

Put another way, there's no difference for member access from within and
from outside the trait; both are interpreted as normal data member access
given the concrete struct (which includes the reused data members somewhere
in it).

pub struct FooS { member: int; }

pub struct BarS { ... reuse FooS::*; ... }
// Gets expanded to:
pub struct BarS { ... member: int; ... }
// Then compiled normally

/* Either inside or outside any trait, doesn't matter */ {
    bar: BarS = ...;
    bar.member; // Just a normal data member access
}
impl AnyTraitAtAll for BarS {
    ... {
        self.member; // Still just a normal data member access
    }
    reuse SomeMixin::*; // Doesn't matter, `member` is still just a normal
data member
}



On Tue, Nov 12, 2013 at 9:43 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/12/13 4:32 PM, Oren Ben-Kiki wrote:
>
>> Ah, thanks. I wasn't aware of that. I should start tracking that RSS
>> feed...
>>
>> I am very concerned that single-inheritance takes the language in the
>> wrong direction. I feel that a more mixin-oriented solution would better
>> match Rust's traits based type system. I posted a comment the blog entry
>> you gave, which I assume is a more appropriate venue than this thread...?
>>
>
> Your solution does not match the performance of single inheritance,
> because it has virtual method calls for every field access from the
> "outside" of the trait.
>
> We don't want single inheritance because we're enamored with Java or
> anything, we want it because nothing that we've been able to come up with
> matches the performance that the prefix property on fields buys you. C++
> code can be very fast for a reason.
>
> We considered Go's anonymous fields but rejected them because they don't
> support virtual methods at the same time as field embedding.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/f3c69085/attachment.html>

From pcwalton at mozilla.com  Mon Nov 11 23:56:16 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 16:56:16 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhsx_nos68pyW-CqD4oTZ-oLzutv5oW02tANCdbLGML=vg@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>	<5281DC30.8040402@mozilla.com>
	<CADJiDhsx_nos68pyW-CqD4oTZ-oLzutv5oW02tANCdbLGML=vg@mail.gmail.com>
Message-ID: <5281DF20.6030500@mozilla.com>

On 11/12/13 4:53 PM, Oren Ben-Kiki wrote:
> "Your solution does not match the performance of single inheritance,
> because it has virtual method calls for every field access from the
> "outside" of the trait."
>
> Sorry, I don't follow.
>
> Access to members from outside of the traits would require accessing the
> concrete type. Since the approach I described used source
> transformation, then this would just be a normal data member access, as
> efficient as single inheritance.

Oh, source transformation. I didn't read closely. That won't work as a 
replacement for single inheritance because it doesn't provide truly 
existential types--for example, an array of heterogeneous objects all of 
which share a common prefix.

Patrick


From gaetan at xeberon.net  Tue Nov 12 00:15:03 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 12 Nov 2013 09:15:03 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANb7cF55E0EYqWwbBgc0hOiM9+0n6HDHE8gTDbdRgz559LVSjA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<A878E0B0-1A0F-4A52-A917-5A0C51D56631@brinckerhoff.org>
	<290552A5-BEB7-4326-B336-FC982D1C60B8@yahoo.com.au>
	<CANb7cF55E0EYqWwbBgc0hOiM9+0n6HDHE8gTDbdRgz559LVSjA@mail.gmail.com>
Message-ID: <CANK7tAHN0u17avoJC_M5EU4iJOwQMpkDWzP4yS1YhcnnBqzOTw@mail.gmail.com>

The name itself is "standard", like "it is the default settings"...
 Le 12 nov. 2013 02:35, "Steven Fackler" <sfackler at gmail.com> a ?crit :

> > base64.rs:
> >    let s = [52, 53, 54].to_base64(STANDARD);
> >
> > => why adding the "standard" argument? One will ALWAYS want the
> "STANDARD" method of creating the base64 representation of some bytes, why
> not adding this argument as default.
>
> That is not true. If you are going to be putting the Base64 encoded data
> into a URL you're going to have to use URL_SAFE instead of STANDARD. If
> you're trying to send an email, you'll need to use MIME instead of
> STANDARD. If you're talking to a service that requires one of the ~10 other
> variants of Base64, you'll need to use a custom config struct.
>
> Steven Fackler
>
>
> On Mon, Nov 11, 2013 at 5:23 PM, Brendan Zabarauskas <bjzaba at yahoo.com.au>wrote:
>
>> On 12 Nov 2013, at 10:12 am, John Clements <clements at brinckerhoff.org>
>> wrote:
>>
>> > If you had the energy to build an alternate front-end using a
>> parenthesized syntax, I'm sure there are others that would give it a try.
>> Me, for instance!
>>
>> It would be nice if we could:
>>
>> - A: desugar Rust into a small kernel language
>> - B: allow rustc to take in some sort of raw AST data (not sure if that?s
>> already possible)
>> - C: have a way of outputting the AST data in a certain syntax.
>>
>> That would allow folks like me to have a nice Haskelly syntax as well as
>> an s-expr style!
>>
>> Heh.
>>
>> ~Brendan
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/110636e2/attachment.html>

From oren at ben-kiki.org  Tue Nov 12 00:17:49 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 10:17:49 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5281DF20.6030500@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<CADJiDhsx_nos68pyW-CqD4oTZ-oLzutv5oW02tANCdbLGML=vg@mail.gmail.com>
	<5281DF20.6030500@mozilla.com>
Message-ID: <CADJiDhsgXcassnEn60NTOr=wtGVwjLoPknPdCKR==k1LbqZWNQ@mail.gmail.com>

The Rust way to do that would be to have an array of objects that all
implement the needed trait. But that would mean that access to the data
members would be a "virtual function call", while access to the data
members of the new kind of traits you described would be cheap.

I think that introducing two kinds of traits would have non-obvious
implications on the type system, in addition to saddling us with all the
pains of a single-inheritance types hierarchy system.

Also, assuming you do introduce two types of traits, for the reason you
described, making implementation reuse a feature of _only_ one kind of
traits feels very wrong. There should be some way to do reasonable
implementation reuse for the current kind of traits as well.

You could view the new kind of traits you described as a special case of
what I described. In fact you could say that `pub struct Foo : Bar { ... }`
means exactly `pub struct Foo { reuse Bar::*; ... }`, and also allow the
kind of pointer casts/heterogeneous arrays you are talking about.

Or, we could move in the direction of anonymous members, which should also
allow for the kind of pointer casts/heterogeneous arrays you want... These
would offer a somewhat different tradeoff than the source code
transformation approach, so you might like them better :-)



On Tue, Nov 12, 2013 at 9:56 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/12/13 4:53 PM, Oren Ben-Kiki wrote:
>
>> "Your solution does not match the performance of single inheritance,
>> because it has virtual method calls for every field access from the
>> "outside" of the trait."
>>
>> Sorry, I don't follow.
>>
>> Access to members from outside of the traits would require accessing the
>> concrete type. Since the approach I described used source
>> transformation, then this would just be a normal data member access, as
>> efficient as single inheritance.
>>
>
> Oh, source transformation. I didn't read closely. That won't work as a
> replacement for single inheritance because it doesn't provide truly
> existential types--for example, an array of heterogeneous objects all of
> which share a common prefix.
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/6c3673c2/attachment.html>

From pcwalton at mozilla.com  Tue Nov 12 00:28:00 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 17:28:00 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhsgXcassnEn60NTOr=wtGVwjLoPknPdCKR==k1LbqZWNQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>	<5281DC30.8040402@mozilla.com>	<CADJiDhsx_nos68pyW-CqD4oTZ-oLzutv5oW02tANCdbLGML=vg@mail.gmail.com>	<5281DF20.6030500@mozilla.com>
	<CADJiDhsgXcassnEn60NTOr=wtGVwjLoPknPdCKR==k1LbqZWNQ@mail.gmail.com>
Message-ID: <5281E690.1080901@mozilla.com>

On 11/12/13 5:17 PM, Oren Ben-Kiki wrote:
> I think that introducing two kinds of traits would have non-obvious
> implications on the type system

Example?

> in addition to saddling us with all the
> pains of a single-inheritance types hierarchy system.

I don't think so. In any case.

> Also, assuming you do introduce two types of traits, for the reason you
> described, making implementation reuse a feature of _only_ one kind of
> traits feels very wrong. There should be some way to do reasonable
> implementation reuse for the current kind of traits as well.

The general way to do that is to make accessors and mutators in the 
trait for fields. If we want sugar for accessors and mutators (i.e. 
properties), then we can cross that bridge later.

> You could view the new kind of traits you described as a special case of
> what I described. In fact you could say that `pub struct Foo : Bar { ...
> }` means exactly `pub struct Foo { reuse Bar::*; ... }`, and also allow
> the kind of pointer casts/heterogeneous arrays you are talking about.

How would that enforce the prefix property?

> Or, we could move in the direction of anonymous members, which should
> also allow for the kind of pointer casts/heterogeneous arrays you
> want... These would offer a somewhat different tradeoff than the source
> code transformation approach, so you might like them better :-)

No, they don't work for all the use cases. You cannot downcast with 
anonymous fields. You also cannot mix them with virtual methods in the 
Go implementation.

Patrick


From denis.spir at gmail.com  Tue Nov 12 01:53:52 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 12 Nov 2013 10:53:52 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
Message-ID: <5281FAB0.4050602@gmail.com>

On 11/11/2013 09:46 PM, Corey Richardson wrote:
> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).

I don't think Rust can succeed as a language if it massively resembles
the language it intends to offset (C++).

Denis

From illissius at gmail.com  Tue Nov 12 01:59:16 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 12 Nov 2013 10:59:16 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <5281FAB0.4050602@gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<5281FAB0.4050602@gmail.com>
Message-ID: <CAPNUp0_Bfb1sH8a-eB+Ts5zEjXsVDic84-YttyuvrHcfQ4ojoA@mail.gmail.com>

Does anyone have empirical data (or even anecdotes) about whether or not
C++ hackers find Rust's syntax appealing? :-)


On Tue, Nov 12, 2013 at 10:53 AM, spir <denis.spir at gmail.com> wrote:

> On 11/11/2013 09:46 PM, Corey Richardson wrote:
>
>> I don't think Rust can succeed as a language if it massively differs,
>> visually, from the language it intends to offset (C++).
>>
>
> I don't think Rust can succeed as a language if it massively resembles
>
> the language it intends to offset (C++).
>
> Denis
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/9e17ce4f/attachment.html>

From lists at dhardy.name  Tue Nov 12 02:35:22 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Tue, 12 Nov 2013 11:35:22 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CAPNUp0_Bfb1sH8a-eB+Ts5zEjXsVDic84-YttyuvrHcfQ4ojoA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<5281FAB0.4050602@gmail.com>
	<CAPNUp0_Bfb1sH8a-eB+Ts5zEjXsVDic84-YttyuvrHcfQ4ojoA@mail.gmail.com>
Message-ID: <6471572.234dVfOntQ@tph-l10036>

My opinion is that clear semantics and good documentation is much more 
important than familiar syntax. Besides, it's not too closely C++ syntax; for 
example `let x : T = v` is much closer to Scala's `val x : T = v` than C++'s 
`T x = v`. (This is a good choice, as anyone who know's why C++ has a 
`typename` keyword will realise.)

But why is this discussion continuing here? The developers have already stated 
that major type changes are not an option for Rust 1.0. I have been 
considering some (fairly major) syntax variations myself, but here is not the 
place; if you want to try out some other syntax then why not write a compiler 
extension which allows the option of different syntax through a different file 
extension (e.g. .rs2) or some such switch?

I for one am not convinced that pure syntax changes can make that big a 
difference; far more interesting would be an interactive IDE which lets the 
programmer write plain English (or restricted English or German or Japanese or 
whatever you like) and attempts to infer what code is meant. Of course English 
is not precise enough to specify exact code (without a _lot_ of words), so the 
interesting part would be how to make the IDE smart enough and interact with 
the programmer well enough to produce good code easily. (The point of this in 
the first place is to allow the programmer to write things like "sort this 
list" or "give me an n*n identity matrix" without expecting the programmer to 
know in advance how the relevant APIs work.)

On Tuesday 12 November 2013 10:59:16 G?bor Lehel wrote:
> Does anyone have empirical data (or even anecdotes) about whether or not
> C++ hackers find Rust's syntax appealing? :-)
> 
> On Tue, Nov 12, 2013 at 10:53 AM, spir <denis.spir at gmail.com> wrote:
> > On 11/11/2013 09:46 PM, Corey Richardson wrote:
> >> I don't think Rust can succeed as a language if it massively differs,
> >> visually, from the language it intends to offset (C++).
> > 
> > I don't think Rust can succeed as a language if it massively resembles
> > 
> > the language it intends to offset (C++).
> > 
> > Denis
> > 
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/f7b89e77/attachment-0001.sig>

From denis.spir at gmail.com  Tue Nov 12 02:46:43 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 12 Nov 2013 11:46:43 +0100
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
Message-ID: <52820713.6060001@gmail.com>

On 11/11/2013 09:16 PM, Oren Ben-Kiki wrote:
> At any rate, I'm not claiming this is necessarily the best approach for
> Rust; I'm just wondering, what is the proposed way to address this use
> case? None of the manual approaches seems very appealing (unless there's a
> better one I missed).

My preferred approach is explicite derivation. May look like:

     struct S1 {
         x1 : uint,
         x2 : uint,
         x3 : uint = 1,
         x4 : uint = 1,

         fn f1 () {...},
         fn f2 () {...},
     }

     struct S2 [: S1] {      // optional subtyping for polymorphism
         x1 : uint,          // same field
         x2 : uint = 2,      // same field, with std value
         x3 : uint = 1,      // same field, same std value
         x4 : uint = 2,      // same field, diff std value
         x5 : uint,          // new field
         x6 : uint = 2,      // new field,  with std value

         fn f1 () = S1.f1,   // same func,  same value (reuse)
         fn f2 () {...},     // same func,  diff value (override)
         fn f3 () {...},     // new func
     }

     // more structs derived from S1

An advantage is that each new type is completely defined on place; except for 
the body of reused functions, but one still has the signature and knows where 
the body is to be found.

This apparently brings no novel issue and avoids a few know problems due to 
conventional "inductive" or "recursive" inheritance. All methods are right here. 
In theory and practice, I guess, one can well reuse from various existing types 
any suitable method; or more generally any role, trait, in ordinary sense of the 
terms. In case of conflict, the user explicitely states which one is intended, 
and there is no diamond problem.

But the main gain in my view is that this scheme provides very good 
auto-documentation, I guess. I have however no idea of how to implement that in 
a static lang, esp the subtyping aspect (but do think it's no more complicated, 
maybe even less) (I implemented it in Lua, rather easy).

Denis


From gaetan at xeberon.net  Tue Nov 12 02:49:18 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 12 Nov 2013 11:49:18 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <6471572.234dVfOntQ@tph-l10036>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<5281FAB0.4050602@gmail.com>
	<CAPNUp0_Bfb1sH8a-eB+Ts5zEjXsVDic84-YttyuvrHcfQ4ojoA@mail.gmail.com>
	<6471572.234dVfOntQ@tph-l10036>
Message-ID: <CANK7tAFGUP0kXoA_xWMJG=UXU-oASJpEdXhjeYkarj_pfx_oSw@mail.gmail.com>

More concretely, a good ide with completion, the right snippets and
contextual help is very helpful for learning new language.

I thing this could be a good idea to have an official set of "snippets",
typical every day codes, that can be used to create a common contextual
helps for editors (vim, sublim,...)

When i arrive in a new language, i m used to gather the common "experience"
and write some automatisation tool and documentation to have a unique point
of entry for all "what should i do in this situation". This covers:
- code styling
- source organisation
- file handling (open/close)
- error handling
- for python, import lines organisation
- argument passing...
Le 12 nov. 2013 11:35, "Diggory Hardy" <lists at dhardy.name> a ?crit :

> My opinion is that clear semantics and good documentation is much more
> important than familiar syntax. Besides, it's not too closely C++ syntax;
> for
> example `let x : T = v` is much closer to Scala's `val x : T = v` than
> C++'s
> `T x = v`. (This is a good choice, as anyone who know's why C++ has a
> `typename` keyword will realise.)
>
> But why is this discussion continuing here? The developers have already
> stated
> that major type changes are not an option for Rust 1.0. I have been
> considering some (fairly major) syntax variations myself, but here is not
> the
> place; if you want to try out some other syntax then why not write a
> compiler
> extension which allows the option of different syntax through a different
> file
> extension (e.g. .rs2) or some such switch?
>
> I for one am not convinced that pure syntax changes can make that big a
> difference; far more interesting would be an interactive IDE which lets the
> programmer write plain English (or restricted English or German or
> Japanese or
> whatever you like) and attempts to infer what code is meant. Of course
> English
> is not precise enough to specify exact code (without a _lot_ of words), so
> the
> interesting part would be how to make the IDE smart enough and interact
> with
> the programmer well enough to produce good code easily. (The point of this
> in
> the first place is to allow the programmer to write things like "sort this
> list" or "give me an n*n identity matrix" without expecting the programmer
> to
> know in advance how the relevant APIs work.)
>
> On Tuesday 12 November 2013 10:59:16 G?bor Lehel wrote:
> > Does anyone have empirical data (or even anecdotes) about whether or not
> > C++ hackers find Rust's syntax appealing? :-)
> >
> > On Tue, Nov 12, 2013 at 10:53 AM, spir <denis.spir at gmail.com> wrote:
> > > On 11/11/2013 09:46 PM, Corey Richardson wrote:
> > >> I don't think Rust can succeed as a language if it massively differs,
> > >> visually, from the language it intends to offset (C++).
> > >
> > > I don't think Rust can succeed as a language if it massively resembles
> > >
> > > the language it intends to offset (C++).
> > >
> > > Denis
> > >
> > > _______________________________________________
> > > Rust-dev mailing list
> > > Rust-dev at mozilla.org
> > > https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/3f8371cf/attachment.html>

From oren at ben-kiki.org  Tue Nov 12 03:18:31 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 13:18:31 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <52820713.6060001@gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52820713.6060001@gmail.com>
Message-ID: <CADJiDhtm2L5uq_C6o1A-DdVCzKDOazcXWn2DyeB_WApAwsrnkA@mail.gmail.com>

It does force one to repeat all the members and all the function
signatures, which is (1) pretty tedious and (2) fragile, as making change
to the base would require making the same changes "everywhere".

The reuse-as-macro idea is to automate this process, so changes would
propagate without changing all the places in the code that use the mixin.

Another difference is that if f1 invokes f2, in the manual method, f1 will
invoke the original f2, while in the reuse-as-macro approach, it would
invoke the new f2.

Otherwise, this is basically the same thing, only manual.

Oren.



On Tue, Nov 12, 2013 at 12:46 PM, spir <denis.spir at gmail.com> wrote:

> On 11/11/2013 09:16 PM, Oren Ben-Kiki wrote:
>
>> At any rate, I'm not claiming this is necessarily the best approach for
>> Rust; I'm just wondering, what is the proposed way to address this use
>> case? None of the manual approaches seems very appealing (unless there's a
>> better one I missed).
>>
>
> My preferred approach is explicite derivation. May look like:
>
>     struct S1 {
>         x1 : uint,
>         x2 : uint,
>         x3 : uint = 1,
>         x4 : uint = 1,
>
>         fn f1 () {...},
>         fn f2 () {...},
>     }
>
>     struct S2 [: S1] {      // optional subtyping for polymorphism
>         x1 : uint,          // same field
>         x2 : uint = 2,      // same field, with std value
>         x3 : uint = 1,      // same field, same std value
>         x4 : uint = 2,      // same field, diff std value
>         x5 : uint,          // new field
>         x6 : uint = 2,      // new field,  with std value
>
>         fn f1 () = S1.f1,   // same func,  same value (reuse)
>         fn f2 () {...},     // same func,  diff value (override)
>         fn f3 () {...},     // new func
>     }
>
>     // more structs derived from S1
>
> An advantage is that each new type is completely defined on place; except
> for the body of reused functions, but one still has the signature and knows
> where the body is to be found.
>
> This apparently brings no novel issue and avoids a few know problems due
> to conventional "inductive" or "recursive" inheritance. All methods are
> right here. In theory and practice, I guess, one can well reuse from
> various existing types any suitable method; or more generally any role,
> trait, in ordinary sense of the terms. In case of conflict, the user
> explicitely states which one is intended, and there is no diamond problem.
>
> But the main gain in my view is that this scheme provides very good
> auto-documentation, I guess. I have however no idea of how to implement
> that in a static lang, esp the subtyping aspect (but do think it's no more
> complicated, maybe even less) (I implemented it in Lua, rather easy).
>
> Denis
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/9656ddd4/attachment.html>

From denis.spir at gmail.com  Tue Nov 12 04:24:52 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 12 Nov 2013 13:24:52 +0100
Subject: [rust-dev] linking to cells inside a data structure
Message-ID: <52821E14.5010509@gmail.com>

Hello Rust people,

A data structure holds (unpointed) cells in an array. Then, a number of linked 
lists part of the data structure link to those same cells. What is the right 
Rust way to do that? I cannot have the language accept the instruction 
establishing a link, whatever kind of pointer I use (both for self and for cells).

Code and/or details on demand.

Denis

PS: It is in fact a hash table [1] which buckets are link lists as usually, but 
the cells are stored in an array instead of spread around the memory at the 
allocator's convenience ;-). First advantage is indeed entries are in order.
(To move on in the meanwhile, I'll remove this aspect.)

[1] Actually a "mod table" since keys are uints, there is no hash, only modulo.

From cadencemarseille at gmail.com  Tue Nov 12 04:41:50 2013
From: cadencemarseille at gmail.com (Cadence Marseille)
Date: Tue, 12 Nov 2013 07:41:50 -0500
Subject: [rust-dev] Interest in OptionStr?
Message-ID: <CAH+UCjMowYDRM4+Zw0BZg9yvsc6tmwK8W8c_UoU1NGpoe6+spQ@mail.gmail.com>

Hi,

I was thinking about a small enhancement for Option<S> objects where S: Str
that would add a utility method for returning a slice option.

There is some code in rust-pcre,
https://github.com/cadencemarseille/rust-pcre/blob/d833054/src/pcre/mod.rs#L137,
that I think illustrates what I am trying to achieve.  I want to use
pattern matching, but both of these versions fail to compile:

        match self.opt_err {
            None => format!("compilation failed at offset {:u}",
self.erroffset as uint),
            Some(s) => format!("compilation failed at offset {:u}: {:s}",
self.erroffset as uint, s)
        }

(error: cannot move out of dereference of & pointer).  Makes sense.  This
is fixed by clone()ing self.opt_err.

        match self.opt_err.clone().map(|s| s.as_slice()) {
            None => format!("compilation failed at offset {:u}",
self.erroffset as uint),
            Some(s) => format!("compilation failed at offset {:u}: {:s}",
self.erroffset as uint, s)
        }

(error: borrowed value does not live long enough).  Also makes sense.

I want to avoid the clone(), so I thought that maybe an additional utility
method is needed to return a slice option given an Option<S: Str>.

I have tried this idea out with:

use std::option::Option;

trait OptionStr {
    fn as_slice<'a>(&'a self) -> Option<&'a str>;
}

impl<S: Str> OptionStr for Option<S> {
    #[inline]
    fn as_slice<'a>(&'a self) -> Option<&'a str> {
        match *self {
            Some(ref s) => Some(s.as_slice()),
            None => None
        }
    }
}

fn main() {
    let opt_str = Some(~"hello world!");
    match opt_str.as_slice() {
        Some(s) => println(s),
        None => return
    }
}

I don't think that the OptionStr would need an into_owned() method (like
Str.into_owned()<http://static.rust-lang.org/doc/master/std/str/trait.Str.html#tymethod.into_owned>)
because that can be done with map: opt_str.map(|s| s.into_owned()).

Does this sound like a good idea?  I can put together a Pull Request if
there is interest in this.

Cadence
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/c56a580e/attachment-0001.html>

From oren at ben-kiki.org  Tue Nov 12 04:51:53 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 14:51:53 +0200
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <52821E14.5010509@gmail.com>
References: <52821E14.5010509@gmail.com>
Message-ID: <CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>

I have been struggling with variants of this for a while and there's no
"best" solution.

First, if the array holds values (as opposed to pointers to values), then
pretty much your only option is to replace your pointers with indices to
the array. You'd need access to the container to access the values, of
course. But this is the only safe way because adding into the array may
relocate it, invalidating all pointers.

If your array holds pointers, then you can do something; e.g., store Rc<T>
in the array cells and also in the places you want to link to the values.
If reference cycles are an issue you can use @T instead of Rc<T> (keep in
mind this will change to Gc<T> or something in the future).

If sending the whole thing is an issue, you are pretty much forced to use
Arc<T> (and forget about reference cycles). And, of course, each of these
(Rc, @, Arc) has a different name if you want mutation (RcMut, @mut, ArcRW).

In performance-critical code I sometimes give up and just have an array of
~T and use an unsafe ptr to T in all my other references... which is OK as
long as these only live as long as the container, but I get zero compiler
support for that. I wish there was a way to say "this borrowed pointer
lives only as long as its container". That doesn't seem to be in the cards
though :-(


On Tue, Nov 12, 2013 at 2:24 PM, spir <denis.spir at gmail.com> wrote:

> Hello Rust people,
>
> A data structure holds (unpointed) cells in an array. Then, a number of
> linked lists part of the data structure link to those same cells. What is
> the right Rust way to do that? I cannot have the language accept the
> instruction establishing a link, whatever kind of pointer I use (both for
> self and for cells).
>
> Code and/or details on demand.
>
> Denis
>
> PS: It is in fact a hash table [1] which buckets are link lists as
> usually, but the cells are stored in an array instead of spread around the
> memory at the allocator's convenience ;-). First advantage is indeed
> entries are in order.
> (To move on in the meanwhile, I'll remove this aspect.)
>
> [1] Actually a "mod table" since keys are uints, there is no hash, only
> modulo.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/58795c03/attachment.html>

From micah at micahchalmer.net  Tue Nov 12 05:01:42 2013
From: micah at micahchalmer.net (Micah Chalmer)
Date: Tue, 12 Nov 2013 08:01:42 -0500
Subject: [rust-dev] Interest in OptionStr?
In-Reply-To: <CAH+UCjMowYDRM4+Zw0BZg9yvsc6tmwK8W8c_UoU1NGpoe6+spQ@mail.gmail.com>
References: <CAH+UCjMowYDRM4+Zw0BZg9yvsc6tmwK8W8c_UoU1NGpoe6+spQ@mail.gmail.com>
Message-ID: <C80F2035-C3E1-42B8-B8A6-6244F59BCCCA@micahchalmer.net>

This will work for your pattern match without cloning:

        match self.opt_err {
            None => format!("compilation failed at offset {:u}", self.erroffset as uint),
            Some(ref s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, *s)
        }    

It takes a reference to the string instead of moving it.  You end up with a pointer to a pointer (&~) which is why you have to explicitly dereference it when you use it.

-Micah

On Nov 12, 2013, at 7:41 AM, Cadence Marseille <cadencemarseille at gmail.com> wrote:

> Hi,
> 
> I was thinking about a small enhancement for Option<S> objects where S: Str that would add a utility method for returning a slice option.
> 
> There is some code in rust-pcre, https://github.com/cadencemarseille/rust-pcre/blob/d833054/src/pcre/mod.rs#L137, that I think illustrates what I am trying to achieve.  I want to use pattern matching, but both of these versions fail to compile:
> 
>         match self.opt_err {
>             None => format!("compilation failed at offset {:u}", self.erroffset as uint),
>             Some(s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, s)
>         }
> 
> (error: cannot move out of dereference of & pointer).  Makes sense.  This is fixed by clone()ing self.opt_err.
> 
>         match self.opt_err.clone().map(|s| s.as_slice()) {
>             None => format!("compilation failed at offset {:u}", self.erroffset as uint),
>             Some(s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, s)
>         }
> 
> (error: borrowed value does not live long enough).  Also makes sense.
> 
> I want to avoid the clone(), so I thought that maybe an additional utility method is needed to return a slice option given an Option<S: Str>.
> 
> I have tried this idea out with:
> 
> use std::option::Option;
> 
> trait OptionStr {
>     fn as_slice<'a>(&'a self) -> Option<&'a str>;
> }
> 
> impl<S: Str> OptionStr for Option<S> {
>     #[inline]
>     fn as_slice<'a>(&'a self) -> Option<&'a str> {
>         match *self {
>             Some(ref s) => Some(s.as_slice()),
>             None => None
>         }
>     }
> }
> 
> fn main() {
>     let opt_str = Some(~"hello world!");
>     match opt_str.as_slice() {
>         Some(s) => println(s),
>         None => return
>     }
> }
> 
> I don't think that the OptionStr would need an into_owned() method (like Str.into_owned()) because that can be done with map: opt_str.map(|s| s.into_owned()).
> 
> Does this sound like a good idea?  I can put together a Pull Request if there is interest in this.
> 
> Cadence
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/8e82e0d0/attachment.html>

From pcwalton at mozilla.com  Tue Nov 12 05:13:09 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 12 Nov 2013 22:13:09 +0900
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
References: <52821E14.5010509@gmail.com>
	<CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
Message-ID: <52822965.7090004@mozilla.com>

On 11/12/13 9:51 PM, Oren Ben-Kiki wrote:
> If sending the whole thing is an issue, you are pretty much forced to
> use Arc<T> (and forget about reference cycles). And, of course, each of
> these (Rc, @, Arc) has a different name if you want mutation (RcMut,
> @mut, ArcRW).

I think having to choose between thread-safe and non-thread-safe 
reference counting is just part of systems programming. But the mutation 
part is painful. I'd like to move most code that uses `@mut` and friends 
to the `Slot` pattern that I'm starting to use in Servo, whereby you 
wrap individual fields in `Slot`s and just use `.get()` and `.set()`, 
instead of making the entire object mutable. So for example:

     struct MyObject {
         x: Slot<int>,
         y: Slot<int>,
     }

     let obj = Rc::new(MyObject {
         x: Slot::init(1),
         y: Slot::init(2),
     });
     println!("{} {}", obj.x.get(), obj.y.get());
     obj.x.set(obj.x.get() * 2);
     obj.y.set(obj.y.get() * 3);

The biggest nice thing about this is that you don't have to worry about 
all of those dynamic borrow failures. (Slots support borrowing in case 
you have to have a reference to the value for some reason, but `.get()` 
and `.set()` are preferred, as sticking to those will prevent you from 
ever having dynamic borrow check failures.)

The other nice thing is you don't have to use separate mutable smart 
pointers. You can write `Rc<whatever>` instead of `RcMut<whatever>`.

> In performance-critical code I sometimes give up and just have an array
> of ~T and use an unsafe ptr to T in all my other references... which is
> OK as long as these only live as long as the container, but I get zero
> compiler support for that. I wish there was a way to say "this borrowed
> pointer lives only as long as its container". That doesn't seem to be in
> the cards though :-(

I don't know how to make that sound, unfortunately, other than using an 
arena and allocating all the nodes into it (losing the ability to 
deallocate individual nodes).

Patrick


From oren at ben-kiki.org  Tue Nov 12 05:27:18 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 15:27:18 +0200
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <52822965.7090004@mozilla.com>
References: <52821E14.5010509@gmail.com>
	<CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
	<52822965.7090004@mozilla.com>
Message-ID: <CADJiDhtah4fukAXZfn1+dvp4BEOv1h9x1Uwiiomtpd8Xicfinw@mail.gmail.com>

Yes, you lose the ability to deallocate individual nodes. Pretty hard to
express in a type system. Still I wish I could at least have the compiler
help me to ensure my unsafe pointers never escape the lifetime of the
container; right now I must trust the programmer (and in my case, the
container basically lives as long as the program, anyway).

Slots sound nice. Is the idea that one would do Rc<T> for read-only access
and Rc<Slot<T>> for mutable access? How does this protect against multiple
mutations "at once"?

On Tue, Nov 12, 2013 at 3:13 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

>
>> In performance-critical code I sometimes give up and just have an array
>> of ~T and use an unsafe ptr to T in all my other references... which is
>> OK as long as these only live as long as the container, but I get zero
>> compiler support for that. I wish there was a way to say "this borrowed
>> pointer lives only as long as its container". That doesn't seem to be in
>> the cards though :-(
>>
>
> I don't know how to make that sound, unfortunately, other than using an
> arena and allocating all the nodes into it (losing the ability to
> deallocate individual nodes).
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/57efb0dd/attachment-0001.html>

From denis.spir at gmail.com  Tue Nov 12 05:52:47 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 12 Nov 2013 14:52:47 +0100
Subject: [rust-dev] copying pointers
Message-ID: <528232AF.40906@gmail.com>

Hello,

The ref manual speaks of copying pointers 
[http://static.rust-lang.org/doc/0.8/rust.html#pointer-types]:

<<
Managed pointers (@)
     These point to managed heap allocations (or "boxes") in the task-local, 
managed heap. Managed pointers are written @content, for example @int means a 
managed pointer to a managed box containing an integer. Copying a managed 
pointer is a "shallow" operation: it involves only copying the pointer itself 
(as well as any reference-count or GC-barriers required by the managed heap). 
Dropping a managed pointer does not necessarily release the box it points to; 
the lifecycles of managed boxes are subject to an unspecified garbage collection 
algorithm.

Owning pointers (~)
     These point to owned heap allocations (or "boxes") in the shared, 
inter-task heap. Each owned box has a single owning pointer; pointer and pointee 
retain a 1:1 relationship at all times. Owning pointers are written ~content, 
for example ~int means an owning pointer to an owned box containing an integer. 
Copying an owned box is a "deep" operation: it involves allocating a new owned 
box and copying the contents of the old box into the new box. Releasing an 
owning pointer immediately releases its corresponding owned box.

Borrowed pointers (&)
     These point to memory owned by some other value. Borrowed pointers arise by 
(automatic) conversion from owning pointers, managed pointers, or by applying 
the borrowing operator & to some other value, including lvalues, rvalues or 
temporaries. Borrowed pointers are written &content, or in some cases &f/content 
for some lifetime-variable f, for example &int means a borrowed pointer to an 
integer. Copying a borrowed pointer is a "shallow" operation: it involves only 
copying the pointer itself. Releasing a borrowed pointer typically has no effect 
on the value it points to, with the exception of temporary values, which are 
released when the last borrowed pointer to them is released.
>>

But what is the syntax to do that? I always get errors related to moving, which 
i don' twant to do. In particular, how does one establish or modify link list links?

Denis

From cadencemarseille at gmail.com  Tue Nov 12 05:58:51 2013
From: cadencemarseille at gmail.com (Cadence Marseille)
Date: Tue, 12 Nov 2013 08:58:51 -0500
Subject: [rust-dev] Interest in OptionStr?
In-Reply-To: <C80F2035-C3E1-42B8-B8A6-6244F59BCCCA@micahchalmer.net>
References: <CAH+UCjMowYDRM4+Zw0BZg9yvsc6tmwK8W8c_UoU1NGpoe6+spQ@mail.gmail.com>
	<C80F2035-C3E1-42B8-B8A6-6244F59BCCCA@micahchalmer.net>
Message-ID: <CAH+UCjPq434PyMJqk6v5pgHSk1wcbcJ5dkpL4Cv4VcHeMmXDzA@mail.gmail.com>

Thank you, Micah.  Your suggestion and L?o Testard's suggestion using
s.as_slice() (emailed off-list) work well.

Cadence


On Tue, Nov 12, 2013 at 8:01 AM, Micah Chalmer <micah at micahchalmer.net>wrote:

> This will work for your pattern match without cloning:
>
>         match self.opt_err {
>             None => format!("compilation failed at offset {:u}",
> self.erroffset as uint),
>             Some(ref s) => format!("compilation failed at offset {:u}:
> {:s}", self.erroffset as uint, *s)
>         }
>
> It takes a reference to the string instead of moving it.  You end up with
> a pointer to a pointer (&~) which is why you have to explicitly dereference
> it when you use it.
>
> -Micah
>
> On Nov 12, 2013, at 7:41 AM, Cadence Marseille <cadencemarseille at gmail.com>
> wrote:
>
> Hi,
>
> I was thinking about a small enhancement for Option<S> objects where S:
> Str that would add a utility method for returning a slice option.
>
> There is some code in rust-pcre,
> https://github.com/cadencemarseille/rust-pcre/blob/d833054/src/pcre/mod.rs#L137,
> that I think illustrates what I am trying to achieve.  I want to use
> pattern matching, but both of these versions fail to compile:
>
>         match self.opt_err {
>             None => format!("compilation failed at offset {:u}",
> self.erroffset as uint),
>             Some(s) => format!("compilation failed at offset {:u}: {:s}",
> self.erroffset as uint, s)
>         }
>
> (error: cannot move out of dereference of & pointer).  Makes sense.  This
> is fixed by clone()ing self.opt_err.
>
>         match self.opt_err.clone().map(|s| s.as_slice()) {
>             None => format!("compilation failed at offset {:u}",
> self.erroffset as uint),
>             Some(s) => format!("compilation failed at offset {:u}: {:s}",
> self.erroffset as uint, s)
>         }
>
> (error: borrowed value does not live long enough).  Also makes sense.
>
> I want to avoid the clone(), so I thought that maybe an additional utility
> method is needed to return a slice option given an Option<S: Str>.
>
> I have tried this idea out with:
>
> use std::option::Option;
>
> trait OptionStr {
>     fn as_slice<'a>(&'a self) -> Option<&'a str>;
> }
>
> impl<S: Str> OptionStr for Option<S> {
>     #[inline]
>     fn as_slice<'a>(&'a self) -> Option<&'a str> {
>         match *self {
>             Some(ref s) => Some(s.as_slice()),
>             None => None
>         }
>     }
> }
>
> fn main() {
>     let opt_str = Some(~"hello world!");
>     match opt_str.as_slice() {
>         Some(s) => println(s),
>         None => return
>     }
> }
>
> I don't think that the OptionStr would need an into_owned() method (like
> Str.into_owned()<http://static.rust-lang.org/doc/master/std/str/trait.Str.html#tymethod.into_owned>)
> because that can be done with map: opt_str.map(|s| s.into_owned()).
>
> Does this sound like a good idea?  I can put together a Pull Request if
> there is interest in this.
>
> Cadence
>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/8e437dc4/attachment.html>

From leo.testard at gmail.com  Tue Nov 12 06:01:11 2013
From: leo.testard at gmail.com (=?iso-8859-1?Q?L=E9o_Testard?=)
Date: Tue, 12 Nov 2013 15:01:11 +0100
Subject: [rust-dev] Interest in OptionStr?
In-Reply-To: <CAH+UCjPq434PyMJqk6v5pgHSk1wcbcJ5dkpL4Cv4VcHeMmXDzA@mail.gmail.com>
References: <CAH+UCjMowYDRM4+Zw0BZg9yvsc6tmwK8W8c_UoU1NGpoe6+spQ@mail.gmail.com>
	<C80F2035-C3E1-42B8-B8A6-6244F59BCCCA@micahchalmer.net>
	<CAH+UCjPq434PyMJqk6v5pgHSk1wcbcJ5dkpL4Cv4VcHeMmXDzA@mail.gmail.com>
Message-ID: <248BC260-A6D9-49C8-B161-C98FDC6D6827@gmail.com>

Hello
Sorry for the mail being sent off-list. Here's what I suggested in case it helps somebody else:

   match opt_err {
        None => format!("compilation failed at offset {:u}", 0u),
        Some(ref s) => format!("compilation failed at offset {:u}: {:s}", 0u, s.as_slice())
    };

Le 12 nov. 2013 ? 14:58, Cadence Marseille <cadencemarseille at gmail.com> a ?crit :

> Thank you, Micah.  Your suggestion and L?o Testard's suggestion using s.as_slice() (emailed off-list) work well.
> 
> Cadence
> 
> 
> On Tue, Nov 12, 2013 at 8:01 AM, Micah Chalmer <micah at micahchalmer.net> wrote:
> This will work for your pattern match without cloning:
> 
>         match self.opt_err {
>             None => format!("compilation failed at offset {:u}", self.erroffset as uint),
>             Some(ref s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, *s)
>         }    
> 
> It takes a reference to the string instead of moving it.  You end up with a pointer to a pointer (&~) which is why you have to explicitly dereference it when you use it.
> 
> -Micah
> 
> On Nov 12, 2013, at 7:41 AM, Cadence Marseille <cadencemarseille at gmail.com> wrote:
> 
>> Hi,
>> 
>> I was thinking about a small enhancement for Option<S> objects where S: Str that would add a utility method for returning a slice option.
>> 
>> There is some code in rust-pcre, https://github.com/cadencemarseille/rust-pcre/blob/d833054/src/pcre/mod.rs#L137, that I think illustrates what I am trying to achieve.  I want to use pattern matching, but both of these versions fail to compile:
>> 
>>         match self.opt_err {
>>             None => format!("compilation failed at offset {:u}", self.erroffset as uint),
>>             Some(s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, s)
>>         }
>> 
>> (error: cannot move out of dereference of & pointer).  Makes sense.  This is fixed by clone()ing self.opt_err.
>> 
>>         match self.opt_err.clone().map(|s| s.as_slice()) {
>>             None => format!("compilation failed at offset {:u}", self.erroffset as uint),
>>             Some(s) => format!("compilation failed at offset {:u}: {:s}", self.erroffset as uint, s)
>>         }
>> 
>> (error: borrowed value does not live long enough).  Also makes sense.
>> 
>> I want to avoid the clone(), so I thought that maybe an additional utility method is needed to return a slice option given an Option<S: Str>.
>> 
>> I have tried this idea out with:
>> 
>> use std::option::Option;
>> 
>> trait OptionStr {
>>     fn as_slice<'a>(&'a self) -> Option<&'a str>;
>> }
>> 
>> impl<S: Str> OptionStr for Option<S> {
>>     #[inline]
>>     fn as_slice<'a>(&'a self) -> Option<&'a str> {
>>         match *self {
>>             Some(ref s) => Some(s.as_slice()),
>>             None => None
>>         }
>>     }
>> }
>> 
>> fn main() {
>>     let opt_str = Some(~"hello world!");
>>     match opt_str.as_slice() {
>>         Some(s) => println(s),
>>         None => return
>>     }
>> }
>> 
>> I don't think that the OptionStr would need an into_owned() method (like Str.into_owned()) because that can be done with map: opt_str.map(|s| s.into_owned()).
>> 
>> Does this sound like a good idea?  I can put together a Pull Request if there is interest in this.
>> 
>> Cadence
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/3e3f531b/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/3e3f531b/attachment-0001.sig>

From denis.spir at gmail.com  Tue Nov 12 06:06:59 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 12 Nov 2013 15:06:59 +0100
Subject: [rust-dev] copying pointers
In-Reply-To: <528232AF.40906@gmail.com>
References: <528232AF.40906@gmail.com>
Message-ID: <52823603.1030901@gmail.com>

PS: What would be, in fact, the rusty way for a simplissim linked list. I use 
Option<~Cell> for now, to have something clean (None) to end the list, since 
Rust looks rather functional. But as always with Option this way quite obscures 
and complicates the code (Some() expressions, match expressions...). I'd rather 
just use a NULL pointer, for here it is fully safe. But this does not look rusty 
at all, I guess.
What is your view?

Denis





From oren at ben-kiki.org  Tue Nov 12 06:21:08 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Tue, 12 Nov 2013 16:21:08 +0200
Subject: [rust-dev] copying pointers
In-Reply-To: <52823603.1030901@gmail.com>
References: <528232AF.40906@gmail.com>
	<52823603.1030901@gmail.com>
Message-ID: <CADJiDhv6mwsQ4R_cwPgF3+LfaUSuaZWXr9Pvm_eknVgcNRCRpg@mail.gmail.com>

For linked lists with no cycles, why not use Option<Rc<T>> (or RcMut)?


On Tue, Nov 12, 2013 at 4:06 PM, spir <denis.spir at gmail.com> wrote:

> PS: What would be, in fact, the rusty way for a simplissim linked list. I
> use Option<~Cell> for now, to have something clean (None) to end the list,
> since Rust looks rather functional. But as always with Option this way
> quite obscures and complicates the code (Some() expressions, match
> expressions...). I'd rather just use a NULL pointer, for here it is fully
> safe. But this does not look rusty at all, I guess.
> What is your view?
>
>
> Denis
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/a3e3a122/attachment.html>

From corey at octayn.net  Tue Nov 12 08:11:42 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 12 Nov 2013 11:11:42 -0500
Subject: [rust-dev] copying pointers
In-Reply-To: <528232AF.40906@gmail.com>
References: <528232AF.40906@gmail.com>
Message-ID: <CA++BO6QiTzrryEoz0st=4FfV-Mj8xtYyicAFAFb5N5+2OWasmg@mail.gmail.com>

#[feature(managed_boxes)];

#[deriving(Clone)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) { }
}

fn main() {
    let x = ~Foo;
    let y = @Foo;
    let _z = Foo;
    let z = &_z;

    // needs a clone since just `a = x` would be a move
    let a: ~Foo = x.clone();
    // just copies the pointer (and bumps the refcount)
    let b: @Foo = y;
    // copies the pointer
    let c = z;
    // *NOT* allowed; would be a move out of a borrowed pointer, which
is not allowed since borrowed
    // pointers don't have ownership.
    // let d = *z;
}


On Tue, Nov 12, 2013 at 8:52 AM, spir <denis.spir at gmail.com> wrote:
> Hello,
>
> The ref manual speaks of copying pointers
> [http://static.rust-lang.org/doc/0.8/rust.html#pointer-types]:
>
> <<
> Managed pointers (@)
>     These point to managed heap allocations (or "boxes") in the task-local,
> managed heap. Managed pointers are written @content, for example @int means
> a managed pointer to a managed box containing an integer. Copying a managed
> pointer is a "shallow" operation: it involves only copying the pointer
> itself (as well as any reference-count or GC-barriers required by the
> managed heap). Dropping a managed pointer does not necessarily release the
> box it points to; the lifecycles of managed boxes are subject to an
> unspecified garbage collection algorithm.
>
> Owning pointers (~)
>     These point to owned heap allocations (or "boxes") in the shared,
> inter-task heap. Each owned box has a single owning pointer; pointer and
> pointee retain a 1:1 relationship at all times. Owning pointers are written
> ~content, for example ~int means an owning pointer to an owned box
> containing an integer. Copying an owned box is a "deep" operation: it
> involves allocating a new owned box and copying the contents of the old box
> into the new box. Releasing an owning pointer immediately releases its
> corresponding owned box.
>
> Borrowed pointers (&)
>     These point to memory owned by some other value. Borrowed pointers arise
> by (automatic) conversion from owning pointers, managed pointers, or by
> applying the borrowing operator & to some other value, including lvalues,
> rvalues or temporaries. Borrowed pointers are written &content, or in some
> cases &f/content for some lifetime-variable f, for example &int means a
> borrowed pointer to an integer. Copying a borrowed pointer is a "shallow"
> operation: it involves only copying the pointer itself. Releasing a borrowed
> pointer typically has no effect on the value it points to, with the
> exception of temporary values, which are released when the last borrowed
> pointer to them is released.
>>>
>>>
>
> But what is the syntax to do that? I always get errors related to moving,
> which i don' twant to do. In particular, how does one establish or modify
> link list links?
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From thadguidry at gmail.com  Tue Nov 12 09:11:31 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Tue, 12 Nov 2013 11:11:31 -0600
Subject: [rust-dev] RosettaCode.org and Color of a Screen Pixel
Message-ID: <CAChbWaO5R_DxhZxCJRmQ+aa2wMqL-quETpcWx2yCpMzu87kMWQ@mail.gmail.com>

Curious if Rust has a way to get the Color of a Screen Pixel yet ?

http://rosettacode.org/wiki/Color_of_a_screen_pixel

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/870d622f/attachment.html>

From tiffany at stormbit.net  Tue Nov 12 09:15:58 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Tue, 12 Nov 2013 12:15:58 -0500
Subject: [rust-dev] Fwd:  Please simplify the syntax for Great Justice
In-Reply-To: <CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
Message-ID: <CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>

On Mon, Nov 11, 2013 at 4:07 PM, Greg <greg at kinostudios.com> wrote:

> I think it's still possible to simplify Rust's existing syntax while
> maintaining the features it offers.
>

You haven't actually explained which syntax you want to remove.


> I'm almost certain that the answer is "no" (partly because these
> languages/dialects did not exist at the time).
>

The language is very similar in semantics to OCaml, to say that Rust is
only inspired by C++ would be a lie.

What about Lua, which is more C-like?
>

You've obviously never used Lua, it's nothing like C.

Or CoffeeScript?
>

Coffeescript is the exact opposite of what you ask - it's a superset of
javascript that adds some syntax sugar. The fact it compiles to very
readable javascript is a testament to this.


> The list contains some bad role models (in terms of syntactic elegance and
> simplicity): C++, Haskell, OCaml, and Ruby.
>

I seriously doubt your taste in syntax if you think Haskell and OCaml are
undesirable.


> Thankfully Common Lisp is mentioned. Although, of the Lisps I'm familiar
> with, Common Lisp has the ugliest syntax (still better than C++ though).
>

You are clearly misusing the word "syntax"... Common lisp's syntax consists
of only S-exprs and the quote sugar, as other lisps do.

This is all to say that, from what I can tell, simplicity and elegance of
> syntax was not a design requirement (or goal) that the Rust developers had
> in mind.
>

The goal of Rust was to produce a type-safe, memory-safe, programmer-safe
programming language, in the niche of system's languages.

And I think that's quite unfortunate for Rust.
>

It's quite unfortunate that the language doesn't abide by your nebulous,
sparsely defined ideas of what a "good" language looks like?


> I'm sorry I was not able to provide this feedback years ago when it might
> have been more helpful. I only recently became aware of Rust.
>

I doubt it would have been taken seriously then.


> - Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> On Nov 11, 2013, at 3:46 PM, Corey Richardson <corey at octayn.net> wrote:
>
> On Mon, Nov 11, 2013 at 3:41 PM, Greg <greg at kinostudios.com> wrote:
>
> At this state in Rust's development, we are unlikely to make any major
> changes to Rust's syntax.
>
>
> *cries*
>
>
> I don't think Rust can succeed as a language if it massively differs,
> visually, from the language it intends to offset (C++).
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/21567026/attachment-0001.html>

From corey at octayn.net  Tue Nov 12 09:20:34 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 12 Nov 2013 12:20:34 -0500
Subject: [rust-dev] RosettaCode.org and Color of a Screen Pixel
In-Reply-To: <CAChbWaO5R_DxhZxCJRmQ+aa2wMqL-quETpcWx2yCpMzu87kMWQ@mail.gmail.com>
References: <CAChbWaO5R_DxhZxCJRmQ+aa2wMqL-quETpcWx2yCpMzu87kMWQ@mail.gmail.com>
Message-ID: <CA++BO6QGYvpr8ScXhxd8oKg9tnp+HWMyx9pJwVG72uYkREkptQ@mail.gmail.com>

With the xlib bindings it'd look a lot like the C version.

On Tue, Nov 12, 2013 at 12:11 PM, Thad Guidry <thadguidry at gmail.com> wrote:
> Curious if Rust has a way to get the Color of a Screen Pixel yet ?
>
> http://rosettacode.org/wiki/Color_of_a_screen_pixel
>
> --
> -Thad
> +ThadGuidry
> Thad on LinkedIn
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From greg at kinostudios.com  Tue Nov 12 09:37:33 2013
From: greg at kinostudios.com (Greg)
Date: Tue, 12 Nov 2013 12:37:33 -0500
Subject: [rust-dev] Fwd:  Please simplify the syntax for Great Justice
In-Reply-To: <CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
Message-ID: <21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>

On Nov 12, 2013, at 12:15 PM, Tiffany Bennett <tiffany at stormbit.net> wrote:
> [.. a bunch of flamebait ..]

Sorry, not gonna bite.

I think there was one reply-worthy comment buried in there, perhaps a tacit request for remove-worthy syntax examples?

I can point out syntax that I don't like, but I think it'd be more productive to simultaneously offer alternatives, and I haven't studied Rust in enough depth to where I'd be comfortable doing that.

Here are some areas that caught my eye in the Doc-language-FAQ on Github. If I were to start using Rust, I'd research these in more depth to try and simplify the syntax:

1. ~[Option<Bucket<K,V>>]

2.  fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) -> LinearMap<K,V>

3.  fn contains_key(&self, k: &K)

My approach would be to try and get rid of templates through better type inference in the compiler. I'd introduce the common brace literal syntax for maps that can be found in JS and elsewhere, and perhaps additional literal syntax (ala ObjC + Clojure).

I'd also look at the symbols '~', '@', and '&', and see what could be done to remove or simplify those.

I'd look to see whether ARC could be used instead of garbage collection, and whether that would have an impact on syntax or not.

There's also the question of whether symbols (ala Lisp/Scheme/Clojure) could be useful in simplifying the language and making it more versatile.

Finally, if all else fails, I'd go for broke and S-expr the whole thing. :-p

- Greg

P.S. Accusing me of lying, and then misrepresenting what I said, is not going to take this conversation down a productive path. You'll probably just end up getting ignored (or worse).

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/fd4432af/attachment.sig>

From catamorphism at gmail.com  Tue Nov 12 09:43:53 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 12 Nov 2013 09:43:53 -0800
Subject: [rust-dev] Closing this thread [Was: Re: Fwd: Please simplify the
 syntax for Great Justice]
Message-ID: <CADcg8==VrD5TTcVMzUAA9M17mw+5eEMpbk+NCQP23w4Jcv0Cjg@mail.gmail.com>

Hi folks --

I already requested that this thread end, and from here on I'm going
to place anyone who replies to this thread further (with the same
subject line or quoting anything from the same thread) on temporary
moderation. For any specific discussion about Rust that originates
from this thread, you're welcome to start a new thread about it with a
new subject line.

Tim (list co-moderator)


On Tue, Nov 12, 2013 at 9:37 AM, Greg <greg at kinostudios.com> wrote:
> On Nov 12, 2013, at 12:15 PM, Tiffany Bennett <tiffany at stormbit.net> wrote:
>> [.. a bunch of flamebait ..]
>
> Sorry, not gonna bite.
>
> I think there was one reply-worthy comment buried in there, perhaps a tacit request for remove-worthy syntax examples?
>
> I can point out syntax that I don't like, but I think it'd be more productive to simultaneously offer alternatives, and I haven't studied Rust in enough depth to where I'd be comfortable doing that.
>
> Here are some areas that caught my eye in the Doc-language-FAQ on Github. If I were to start using Rust, I'd research these in more depth to try and simplify the syntax:
>
> 1. ~[Option<Bucket<K,V>>]
>
> 2.  fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) -> LinearMap<K,V>
>
> 3.  fn contains_key(&self, k: &K)
>
> My approach would be to try and get rid of templates through better type inference in the compiler. I'd introduce the common brace literal syntax for maps that can be found in JS and elsewhere, and perhaps additional literal syntax (ala ObjC + Clojure).
>
> I'd also look at the symbols '~', '@', and '&', and see what could be done to remove or simplify those.
>
> I'd look to see whether ARC could be used instead of garbage collection, and whether that would have an impact on syntax or not.
>
> There's also the question of whether symbols (ala Lisp/Scheme/Clojure) could be useful in simplifying the language and making it more versatile.
>
> Finally, if all else fails, I'd go for broke and S-expr the whole thing. :-p
>
> - Greg
>
> P.S. Accusing me of lying, and then misrepresenting what I said, is not going to take this conversation down a productive path. You'll probably just end up getting ignored (or worse).
>
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From tiffany at stormbit.net  Tue Nov 12 10:00:43 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Tue, 12 Nov 2013 13:00:43 -0500
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
Message-ID: <CAKBOV9k+EHg4jgkRJqogPGthAOW6QPiRYXJmi07YegVwYwus_A@mail.gmail.com>

On Tue, Nov 12, 2013 at 12:37 PM, Greg <greg at kinostudios.com> wrote:

> On Nov 12, 2013, at 12:15 PM, Tiffany Bennett <tiffany at stormbit.net>
> wrote:
> > [.. a bunch of flamebait ..]
>
> Sorry, not gonna bite.
>
> I think there was one reply-worthy comment buried in there, perhaps a
> tacit request for remove-worthy syntax examples?
>
> I can point out syntax that I don't like, but I think it'd be more
> productive to simultaneously offer alternatives, and I haven't studied Rust
> in enough depth to where I'd be comfortable doing that.
>
> Here are some areas that caught my eye in the Doc-language-FAQ on Github.
> If I were to start using Rust, I'd research these in more depth to try and
> simplify the syntax:
>
> 1. ~[Option<Bucket<K,V>>]
>
> 2.  fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) ->
> LinearMap<K,V>
>
> 3.  fn contains_key(&self, k: &K)
>
> My approach would be to try and get rid of templates through better type
> inference in the compiler. I'd introduce the common brace literal syntax
> for maps that can be found in JS and elsewhere, and perhaps additional
> literal syntax (ala ObjC + Clojure).
>

Type inference for function signatures leads to programmer errors where it
infers the wrong type. You seem to have the idea that much of this syntax
is unnecessary, when it really is - all of it is important to specifying
exactly what you mean. In a system's language like Rust, there are a lot of
things that you could mean. You should try providing real examples of how
you could simplify the examples you provided.


> I'd also look at the symbols '~', '@', and '&', and see what could be done
> to remove or simplify those.
>

Anything you do to simplify Rust's memory management will be of detriment
to the language, because it is an important part of Rust's ability to
function as a system's language. Each of those symbols has an important
meaning in regards to memory management - ~ being RAII-like, @ being
garbage collected (and now behind a feature gate while everyone figures out
whether to keep the symbol or just use RC<T>/GC<T>), & is a way to take
temporary references to something.


> I'd look to see whether ARC could be used instead of garbage collection,
> and whether that would have an impact on syntax or not.
>

ARC /is/ garbage collection. It's an atomic reference counter that can be
sent between tasks.


> There's also the question of whether symbols (ala Lisp/Scheme/Clojure)
> could be useful in simplifying the language and making it more versatile.
>
> Finally, if all else fails, I'd go for broke and S-expr the whole thing.
> :-p
>

I've tried implementing an S-expr based language myself, and the benefits
are really not as great as they first seem. One thing you eventually
realize is that although lisp has an incredible macro system, needing
macros in the first place is often a sign of a type system that isn't
powerful enough to express many concepts. Do you often see macros used in
languages like Haskell or Idris?


> - Greg
>
> P.S. Accusing me of lying, and then misrepresenting what I said, is not
> going to take this conversation down a productive path. You'll probably
> just end up getting ignored (or worse).
>
> --
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/af4da2a3/attachment.html>

From tiffany at stormbit.net  Tue Nov 12 10:03:56 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Tue, 12 Nov 2013 13:03:56 -0500
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <CADcg8=kC0r88G1083N=MQoVvcf-fkO5E6KdjY-5Oj27tJPs+Yw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<CADcg8=kC0r88G1083N=MQoVvcf-fkO5E6KdjY-5Oj27tJPs+Yw@mail.gmail.com>
Message-ID: <CAKBOV9nLoXXHUX3NCQHAmmWD1MAqVF-yg-=BwGMJiSG2i=h1hw@mail.gmail.com>

Sorry, I did go a bit overboard

On Tue, Nov 12, 2013 at 12:48 PM, Tim Chevalier <catamorphism at gmail.com>wrote:

> Hey Tiffany --
>
> Just wanted to let you know that I thought this was a totally
> appropriate email on your part :-) Normally I would warn about the
> code of conduct, but tbh, in this case I think Greg deserved it.
>
> Just my opinion, of course, and not the official opinion of the team :-)
>
> That said, when you want to shut people down in the future (a role
> that is very much needed given the number of cranks that Rust
> attracts, especially now that neither I nor Graydon will be mods after
> this week), try to do it in a way that you can argue is "kind and
> courteous" (as per the conduct section of
> https://github.com/mozilla/rust/wiki/Note-development-policy ), so
> that the other list mods will have no reason to criticize it :-)
>
> Cheers,
> Tim
>
>
> On Tue, Nov 12, 2013 at 9:15 AM, Tiffany Bennett <tiffany at stormbit.net>
> wrote:
> > On Mon, Nov 11, 2013 at 4:07 PM, Greg <greg at kinostudios.com> wrote:
> >>
> >> I think it's still possible to simplify Rust's existing syntax while
> >> maintaining the features it offers.
> >
> >
> > You haven't actually explained which syntax you want to remove.
> >
> >>
> >> I'm almost certain that the answer is "no" (partly because these
> >> languages/dialects did not exist at the time).
> >
> >
> > The language is very similar in semantics to OCaml, to say that Rust is
> only
> > inspired by C++ would be a lie.
> >
> >> What about Lua, which is more C-like?
> >
> >
> > You've obviously never used Lua, it's nothing like C.
> >
> >> Or CoffeeScript?
> >
> >
> > Coffeescript is the exact opposite of what you ask - it's a superset of
> > javascript that adds some syntax sugar. The fact it compiles to very
> > readable javascript is a testament to this.
> >
> >>
> >> The list contains some bad role models (in terms of syntactic elegance
> and
> >> simplicity): C++, Haskell, OCaml, and Ruby.
> >
> >
> > I seriously doubt your taste in syntax if you think Haskell and OCaml are
> > undesirable.
> >
> >>
> >> Thankfully Common Lisp is mentioned. Although, of the Lisps I'm familiar
> >> with, Common Lisp has the ugliest syntax (still better than C++ though).
> >
> >
> > You are clearly misusing the word "syntax"... Common lisp's syntax
> consists
> > of only S-exprs and the quote sugar, as other lisps do.
> >
> >> This is all to say that, from what I can tell, simplicity and elegance
> of
> >> syntax was not a design requirement (or goal) that the Rust developers
> had
> >> in mind.
> >
> >
> > The goal of Rust was to produce a type-safe, memory-safe, programmer-safe
> > programming language, in the niche of system's languages.
> >
> >> And I think that's quite unfortunate for Rust.
> >
> >
> > It's quite unfortunate that the language doesn't abide by your nebulous,
> > sparsely defined ideas of what a "good" language looks like?
> >
> >>
> >> I'm sorry I was not able to provide this feedback years ago when it
> might
> >> have been more helpful. I only recently became aware of Rust.
> >
> >
> > I doubt it would have been taken seriously then.
> >
> >>
> >> - Greg
> >>
> >> --
> >> Please do not email me anything that you are not comfortable also
> sharing
> >> with the NSA.
> >>
> >> On Nov 11, 2013, at 3:46 PM, Corey Richardson <corey at octayn.net> wrote:
> >>
> >> On Mon, Nov 11, 2013 at 3:41 PM, Greg <greg at kinostudios.com> wrote:
> >>
> >> At this state in Rust's development, we are unlikely to make any major
> >> changes to Rust's syntax.
> >>
> >>
> >> *cries*
> >>
> >>
> >> I don't think Rust can succeed as a language if it massively differs,
> >> visually, from the language it intends to offset (C++).
> >>
> >>
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> >
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
>
> --
> Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
> "If you are silent about your pain, they'll kill you and say you enjoyed
> it."
> -- Zora Neale Hurston
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/d7c8fd85/attachment-0001.html>

From catamorphism at gmail.com  Tue Nov 12 10:10:13 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 12 Nov 2013 10:10:13 -0800
Subject: [rust-dev] Closing this thread [Was: Re: Fwd: Please simplify
 the syntax for Great Justice]
Message-ID: <CADcg8=m1iDCFqx_pQ6TWSpbMvvHdnP9bzanJR72dJweguM_qTg@mail.gmail.com>

I've placed the list on full moderation for now, which will hopefully
be for less than 12 hours. Sorry -- I or other mods will approve
on-topic postings as they come on, but unfortunately Mailman doesn't
have a way to freeze a single thread (that I know of).

Cheers,
Tim


On Tue, Nov 12, 2013 at 9:43 AM, Tim Chevalier <catamorphism at gmail.com> wrote:
> Hi folks --
>
> I already requested that this thread end, and from here on I'm going
> to place anyone who replies to this thread further (with the same
> subject line or quoting anything from the same thread) on temporary
> moderation. For any specific discussion about Rust that originates
> from this thread, you're welcome to start a new thread about it with a
> new subject line.
>
> Tim (list co-moderator)
>

From kevin at sb.org  Tue Nov 12 10:57:34 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 10:57:34 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5281DC30.8040402@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
Message-ID: <81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>

On Nov 11, 2013, at 11:43 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> We considered Go's anonymous fields but rejected them because they don't support virtual methods at the same time as field embedding.

I don?t follow. Why do Go?s anonymous fields not support virtual methods at the same time as field embedding?

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/f13d4fec/attachment.html>

From kevin at sb.org  Tue Nov 12 11:07:50 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 11:07:50 -0800
Subject: [rust-dev] Danger of throwing exceptions through Rust code
Message-ID: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>

Right now, Rust does not support catching task failure from within a task, it only supports preventing task failure from cascading into other tasks. My understanding is that this limitation is done because of safety; if a task unwinds through a few frames of code, and then stops unwinding, data structure invariants may have been broken by the unwinding, leaving the task in an unsafe state. Is this correct?

Given this assumption, my worry now is about task unwinding outside of the control of Rust. Namely, if I?m using Rust to write a library with extern ?C? functions, or I?m providing callbacks to C code from within Rust, (and my Rust code calls back into C at some point), then it?s very possible for the called C code to throw an exception that is then caught in the calling C code a few frames up. The net effect is that the thread will unwind through my Rust code, but it will then be caught before unwinding any further, potentially leaving any data structures in an invalid state (assuming that there?s still Rust code higher up on this same stack that cares).

Has this been considered before? Is this actually a danger or am I just being paranoid?

-Kevin

From rusty.gates at icloud.com  Tue Nov 12 11:17:32 2013
From: rusty.gates at icloud.com (Tommi)
Date: Tue, 12 Nov 2013 21:17:32 +0200
Subject: [rust-dev] Could the compiler elide unused static items?
Message-ID: <C6C56E5B-2AC2-42D9-9366-E3223E01EE22@icloud.com>

Could the compiler figure out if a static item is not used and then elide it altogether. Or does it do this already?

I can use the following idiom in C++ (can't do it in Rust though) to have the compiler elide static data (large lookup tables in library code for example) if the end-user doesn't use it:

template <int n>
class Data
{
	static_assert(n == 42, "");

	template <int>
	friend int get_value(int);

	static const int values[3];
};

template <int n>
const int Data<n>::values[3] = { 1, 2, 3 };

template <int n = 42>
int get_value(int idx)
{
	return Data<n>::values[idx];
}

If the end-user never calls get_value(...), then Data never gets instantiated and the (potentially large) array never exists.

-Tommi


From corey at octayn.net  Tue Nov 12 11:27:33 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 12 Nov 2013 14:27:33 -0500
Subject: [rust-dev] Could the compiler elide unused static items?
In-Reply-To: <C6C56E5B-2AC2-42D9-9366-E3223E01EE22@icloud.com>
References: <C6C56E5B-2AC2-42D9-9366-E3223E01EE22@icloud.com>
Message-ID: <CA++BO6RnhDrjXdo+gV+HpLYFCbXm=ZGveY_9q+qwApnseoq4jw@mail.gmail.com>

On Tue, Nov 12, 2013 at 2:17 PM, Tommi <rusty.gates at icloud.com> wrote:
> Could the compiler figure out if a static item is not used and then elide it altogether. Or does it do this already?
>

If it's a `pub static`, and you're compiling a library, it cannot be
removed. But if it's just static and it's never used, it can and will
be optimized out. Example:

static X: [u8, ..30_000_000] = [1, ..30_000_000];

fn main() {
    println("Look ma, small binary!");
}


When compiled with optimization, the resulting executable is 12K. Without, 29M.

From corey at octayn.net  Tue Nov 12 11:22:11 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 12 Nov 2013 14:22:11 -0500
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
Message-ID: <CA++BO6STu2tmahZq=4HzHBrdAZz_C7aWd1yH=6niO56mVPk1sg@mail.gmail.com>

Is it possible for data low in the stack to propagate upwards through
the stack before function return? It seems like if this were to be an
issue, you would need to move into something parent gives you, at
which point you no longer have ownership and unwinding won't destroy
it.

It seems like the lifetime system prevents this from being a problem.

I think Rust *could* have catchable exceptions, you just wouldn't be
allowed to use anything that can throw when constructing a value. That
way, everything is fully constructed when an exception happens, so
destructors can never run on inconsistent state and resources won't
leak.

Maybe there's something I'm missing, though.

On Tue, Nov 12, 2013 at 2:07 PM, Kevin Ballard <kevin at sb.org> wrote:
> Right now, Rust does not support catching task failure from within a task, it only supports preventing task failure from cascading into other tasks. My understanding is that this limitation is done because of safety; if a task unwinds through a few frames of code, and then stops unwinding, data structure invariants may have been broken by the unwinding, leaving the task in an unsafe state. Is this correct?
>
> Given this assumption, my worry now is about task unwinding outside of the control of Rust. Namely, if I?m using Rust to write a library with extern ?C? functions, or I?m providing callbacks to C code from within Rust, (and my Rust code calls back into C at some point), then it?s very possible for the called C code to throw an exception that is then caught in the calling C code a few frames up. The net effect is that the thread will unwind through my Rust code, but it will then be caught before unwinding any further, potentially leaving any data structures in an invalid state (assuming that there?s still Rust code higher up on this same stack that cares).
>
> Has this been considered before? Is this actually a danger or am I just being paranoid?
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From alex at crichton.co  Tue Nov 12 11:35:08 2013
From: alex at crichton.co (Alex Crichton)
Date: Tue, 12 Nov 2013 11:35:08 -0800
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
Message-ID: <CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>

You're correct about the safeness of catching failure at a task
boundary. Rust's invariants about spawning a task involve knowing a
fair bit about what's allowable to share between a task boundary, and
that allows us to reason about the failure unwinding to the task
boundary being a safe operation (as opposed to stopping unwinding at
an arbitrary location).

I'm not entirely sure what you mean by throwing an exception from C (I
think there are many flavors of doing this). Right now we implement
unwinding via C++ exceptions. When a task unwinds, it actually throws
a magical uint token which then triggers all the C++ machinery for
unwinding the stack. When compiling with LLVM, we using LLVM's invoke
instruction + landing pads to generate our "cleanup locations", and
LLVM will codegen the right code such that all the landing pads are
invoked during unwinding. What this means is that the C++ exception
throwing infrastructure will probably fly right past all C code
because none of it is hooked into the exception handling stuff of C++.
This may mean, however, that intermediate C++ code may have landing
pads run (not entirely sure).

All that being said, that's just how it's currently implemented today.
I don't think that we're guaranteeing this sort of behavior to always
happen. It will probably always be the case that C stack frames are
always sailed past during unwinding, but we may implement unwinding
via precise stack tables and manual stack unwinding at some point
which wouldn't trigger C++ landing pads (or use LLVM's landing pad
infrastructure the same way that we're using it today).

Right now it's basically the case that intermingling C with Rust stack
frames and then triggering failure will only trigger unwinding in rust
functions (what does it mean to unwind in C?), and I'm not sure I'd
recommend that as a safe strategy for implementing bindings to a C
function (all intermediate C allocations are leaked).

Does that make sense? It may not quite answer your question, but
hopefully that clears up at least a little bit about how it's
implemented today.

On Tue, Nov 12, 2013 at 11:07 AM, Kevin Ballard <kevin at sb.org> wrote:
> Right now, Rust does not support catching task failure from within a task, it only supports preventing task failure from cascading into other tasks. My understanding is that this limitation is done because of safety; if a task unwinds through a few frames of code, and then stops unwinding, data structure invariants may have been broken by the unwinding, leaving the task in an unsafe state. Is this correct?
>
> Given this assumption, my worry now is about task unwinding outside of the control of Rust. Namely, if I?m using Rust to write a library with extern ?C? functions, or I?m providing callbacks to C code from within Rust, (and my Rust code calls back into C at some point), then it?s very possible for the called C code to throw an exception that is then caught in the calling C code a few frames up. The net effect is that the thread will unwind through my Rust code, but it will then be caught before unwinding any further, potentially leaving any data structures in an invalid state (assuming that there?s still Rust code higher up on this same stack that cares).
>
> Has this been considered before? Is this actually a danger or am I just being paranoid?
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From danielmicay at gmail.com  Tue Nov 12 11:50:06 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 12 Nov 2013 14:50:06 -0500
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
Message-ID: <CA+DvKQ+UsywJcpu5vX62Q3WF4BEOjK73o_RFU88Zv3oSV4NxgQ@mail.gmail.com>

On Tue, Nov 12, 2013 at 2:35 PM, Alex Crichton <alex at crichton.co> wrote:

> You're correct about the safeness of catching failure at a task
> boundary. Rust's invariants about spawning a task involve knowing a
> fair bit about what's allowable to share between a task boundary, and
> that allows us to reason about the failure unwinding to the task
> boundary being a safe operation (as opposed to stopping unwinding at
> an arbitrary location).
>
> I'm not entirely sure what you mean by throwing an exception from C (I
> think there are many flavors of doing this). Right now we implement
> unwinding via C++ exceptions. When a task unwinds, it actually throws
> a magical uint token which then triggers all the C++ machinery for
> unwinding the stack. When compiling with LLVM, we using LLVM's invoke
> instruction + landing pads to generate our "cleanup locations", and
> LLVM will codegen the right code such that all the landing pads are
> invoked during unwinding. What this means is that the C++ exception
> throwing infrastructure will probably fly right past all C code
> because none of it is hooked into the exception handling stuff of C++.
> This may mean, however, that intermediate C++ code may have landing
> pads run (not entirely sure).
>
> All that being said, that's just how it's currently implemented today.
> I don't think that we're guaranteeing this sort of behavior to always
> happen. It will probably always be the case that C stack frames are
> always sailed past during unwinding, but we may implement unwinding
> via precise stack tables and manual stack unwinding at some point
> which wouldn't trigger C++ landing pads (or use LLVM's landing pad
> infrastructure the same way that we're using it today).
>
> Right now it's basically the case that intermingling C with Rust stack
> frames and then triggering failure will only trigger unwinding in rust
> functions (what does it mean to unwind in C?), and I'm not sure I'd
> recommend that as a safe strategy for implementing bindings to a C
> function (all intermediate C allocations are leaked).
>
> Does that make sense? It may not quite answer your question, but
> hopefully that clears up at least a little bit about how it's
> implemented today.
>

It's undefined behaviour for a C++ function to throw an exception past an
`extern "C"` boundary so Rust doesn't need to worry about a need to handle
exceptions from foreign libraries.

In practice, compilers will often build code with support for passing
through exceptions but it's not required and C cannot maintain the
invariants required for safety in the face of unwinding. It's simply not
safe to pass Rust functions directly as callbacks into C if they aren't
known to never throw.

Rust isn't committed to using the C++ exception personality so
interoperability with unwrapped C++ libraries just isn't on the table at
this point. It actually *doesn't* even use the C++ exception personality
because there are hooks to reset the used stack space.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/cdaf0303/attachment.html>

From ecreed at cs.washington.edu  Tue Nov 12 12:10:42 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Tue, 12 Nov 2013 12:10:42 -0800
Subject: [rust-dev] copying pointers
In-Reply-To: <CADJiDhv6mwsQ4R_cwPgF3+LfaUSuaZWXr9Pvm_eknVgcNRCRpg@mail.gmail.com>
References: <528232AF.40906@gmail.com> <52823603.1030901@gmail.com>
	<CADJiDhv6mwsQ4R_cwPgF3+LfaUSuaZWXr9Pvm_eknVgcNRCRpg@mail.gmail.com>
Message-ID: <CANbMr6EXS0G7MhCc2MidQaS-iRAu0j4+LjMVYGFWaFyHVO6JmA@mail.gmail.com>

I'd suggest extra::list, but it looks a little dated.


On Tue, Nov 12, 2013 at 6:21 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> For linked lists with no cycles, why not use Option<Rc<T>> (or RcMut)?
>
>
> On Tue, Nov 12, 2013 at 4:06 PM, spir <denis.spir at gmail.com> wrote:
>
>> PS: What would be, in fact, the rusty way for a simplissim linked list. I
>> use Option<~Cell> for now, to have something clean (None) to end the list,
>> since Rust looks rather functional. But as always with Option this way
>> quite obscures and complicates the code (Some() expressions, match
>> expressions...). I'd rather just use a NULL pointer, for here it is fully
>> safe. But this does not look rusty at all, I guess.
>> What is your view?
>>
>>
>> Denis
>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/9636eb78/attachment.html>

From pcwalton at mozilla.com  Tue Nov 12 13:22:00 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 13 Nov 2013 06:22:00 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
Message-ID: <52829BF8.3000200@mozilla.com>

On 11/13/13 3:57 AM, Kevin Ballard wrote:
> On Nov 11, 2013, at 11:43 PM, Patrick Walton <pcwalton at mozilla.com
> <mailto:pcwalton at mozilla.com>> wrote:
>
>> We considered Go's anonymous fields but rejected them because they
>> don't support virtual methods at the same time as field embedding.
>
> I don?t follow. Why do Go?s anonymous fields not support virtual methods
> at the same time as field embedding?

I want to write this but I can't:

     package main

     import "fmt"

     type A struct {
         x int
     }

     type B struct {
         A
         y int
     }

     type C struct {
         A
         z int
     }

     func(self *B) Foo() {
         fmt.Printf("Hello!")
     }

     func(self *B) Upcast() *A {
         return &self.A
     }

     func(self *C) Foo() {
         fmt.Printf("Goodbye!")
     }

     func(self *C) Upcast() *A {
         return &self.A
     }

     func main() {
         myArray := []*A {
             (&B { A: A { x: 1 }, y: 2 }).Upcast(),
             (&C { A: A { x: 3 }, z: 4 }).Upcast(),
         }
         for i := 0; i < 2; i++ {
             myArray[i].Foo()
         }
     }

Error:

     prog.go:41: myArray[i].Foo undefined (type *A has no field or 
method Foo)

You can't really write the thing you need to write inside `Upcast` to 
make this code work. You would need to use an interface instead, but 
then interfaces don't support shared fields, just like in Rust, leading 
to the same problem.

Patrick


From catamorphism at gmail.com  Tue Nov 12 17:00:30 2013
From: catamorphism at gmail.com (Tim Chevalier)
Date: Tue, 12 Nov 2013 17:00:30 -0800
Subject: [rust-dev] Closing this thread [Was: Re: Fwd: Please simplify
 the syntax for Great Justice]
In-Reply-To: <CADcg8=m1iDCFqx_pQ6TWSpbMvvHdnP9bzanJR72dJweguM_qTg@mail.gmail.com>
References: <CADcg8=m1iDCFqx_pQ6TWSpbMvvHdnP9bzanJR72dJweguM_qTg@mail.gmail.com>
Message-ID: <CADcg8=n4BB_nG6mFYDSpgEF6iZ_DuB_BFnrDAE8yMYc8go4dZw@mail.gmail.com>

The list is no longer on moderation. Posts from subscribers should go
through to the list without moderator intervention now.

Sorry for any inconvenience.

Cheers,
Tim


On Tue, Nov 12, 2013 at 10:10 AM, Tim Chevalier <catamorphism at gmail.com> wrote:
> I've placed the list on full moderation for now, which will hopefully
> be for less than 12 hours. Sorry -- I or other mods will approve
> on-topic postings as they come on, but unfortunately Mailman doesn't
> have a way to freeze a single thread (that I know of).
>
> Cheers,
> Tim
>
>
> On Tue, Nov 12, 2013 at 9:43 AM, Tim Chevalier <catamorphism at gmail.com> wrote:
>> Hi folks --
>>
>> I already requested that this thread end, and from here on I'm going
>> to place anyone who replies to this thread further (with the same
>> subject line or quoting anything from the same thread) on temporary
>> moderation. For any specific discussion about Rust that originates
>> from this thread, you're welcome to start a new thread about it with a
>> new subject line.
>>
>> Tim (list co-moderator)
>>



-- 
Tim Chevalier * http://catamorphism.org/ * Often in error, never in doubt
"If you are silent about your pain, they'll kill you and say you enjoyed it."
-- Zora Neale Hurston

From kevin at sb.org  Tue Nov 12 18:42:49 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 18:42:49 -0800
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
Message-ID: <E5D3A6BC-0849-4F8D-AF5C-11FF52CD9D65@sb.org>

I guess I was being too vague when I said ?C exceptions?, because you?re right, that?s not actually a specific thing. More concretely, I was thinking of either C++ exceptions, or Obj-C exceptions.

One situation I was thinking of would be a rust library that exposes `extern ?C?` functions. Let?s say one of these functions, frob(), takes an `extern ?C?` callback and calls it. Now let?s say I?m writing an Obj-C app, and I do something like the following:

static void callback() {
    [NSException raise:@?Foo Exception? format:@?I just felt like unwinding?];
}

@try {
    frob(callback)
}
@catch (NSException *e) {
    NSLog(@?I caught my exception!?);
}

This will unwind through the Rust code, before being caught again. It?s hard to come up with a scenario where this actually results in unsafe state within the rust library, but let?s say `frob()` uses some sort of shared state (e.g. a RWArc<>), and is in the middle of modifying the shared state in a way that causes invariants to be broken temporarily. If unwinding happens when the invariants are in the broken state, then they?ll be left in the broken state and the next bit of Rust code that tries to access this shared state will likely blow up.

This is obviously pretty contrived, but the question is, is this legal to do, and if so, do we need to do anything?

Daniel?s response says that it?s undefined for a C++ function to throw an exception past an `extern ?C?` boundary. This is something I did not know. But what about Obj-C exceptions? I haven?t heard about any undefined behavior regarding Obj-C exceptions. It is generally recognized that throwing an Obj-C exception past a framework boundary is unsafe (i.e. throwing an exception in user code that unwinds through Foundation code), but this is because Obj-C code rarely bothers with @try/@finally and doesn?t have stack objects, so unwinding through code that doesn?t expect it will often leave data structures in invalid states.

If all forms of unwinding are considered to be undefined when passing through an `extern ?C?` boundary, then I guess we can consider this issue to be covered by undefined behavior. Although this doesn?t make me particularly happy, because it means that it may be impossible to truly contain the unsafety in FFI functions. One possible way to mitigate this would be to provide a way to wrap an FFI function with a stub that catches C++/Obj-C exceptions (I think Obj-C exceptions are unified with the C++ exception machinery on all modern platforms (i.e. not 32-bit PPC, and I?m not sure about 32-bit x86)) and triggers task failure. This would mean any attempt to unwind through a Rust function (using C++ or Obj-C exceptions) would be contained, after a fashion.

Though this does raise another question. What if a C++ function calls a Rust function, and the Rust function triggers task failure? Is it possible for the C++ function to catch the task failure using a catch(?) block? Furthermore, since Daniel said it?s undefined for a C++ exception to be thrown past an `extern ?C?` boundary, does this mean that it?s technically undefined for Rust to trigger task failure in any function that?s rooted in an `extern ?C?` function?

-Kevin

On Nov 12, 2013, at 11:35 AM, Alex Crichton <alex at crichton.co> wrote:

> You're correct about the safeness of catching failure at a task
> boundary. Rust's invariants about spawning a task involve knowing a
> fair bit about what's allowable to share between a task boundary, and
> that allows us to reason about the failure unwinding to the task
> boundary being a safe operation (as opposed to stopping unwinding at
> an arbitrary location).
> 
> I'm not entirely sure what you mean by throwing an exception from C (I
> think there are many flavors of doing this). Right now we implement
> unwinding via C++ exceptions. When a task unwinds, it actually throws
> a magical uint token which then triggers all the C++ machinery for
> unwinding the stack. When compiling with LLVM, we using LLVM's invoke
> instruction + landing pads to generate our "cleanup locations", and
> LLVM will codegen the right code such that all the landing pads are
> invoked during unwinding. What this means is that the C++ exception
> throwing infrastructure will probably fly right past all C code
> because none of it is hooked into the exception handling stuff of C++.
> This may mean, however, that intermediate C++ code may have landing
> pads run (not entirely sure).
> 
> All that being said, that's just how it's currently implemented today.
> I don't think that we're guaranteeing this sort of behavior to always
> happen. It will probably always be the case that C stack frames are
> always sailed past during unwinding, but we may implement unwinding
> via precise stack tables and manual stack unwinding at some point
> which wouldn't trigger C++ landing pads (or use LLVM's landing pad
> infrastructure the same way that we're using it today).
> 
> Right now it's basically the case that intermingling C with Rust stack
> frames and then triggering failure will only trigger unwinding in rust
> functions (what does it mean to unwind in C?), and I'm not sure I'd
> recommend that as a safe strategy for implementing bindings to a C
> function (all intermediate C allocations are leaked).
> 
> Does that make sense? It may not quite answer your question, but
> hopefully that clears up at least a little bit about how it's
> implemented today.
> 
> On Tue, Nov 12, 2013 at 11:07 AM, Kevin Ballard <kevin at sb.org> wrote:
>> Right now, Rust does not support catching task failure from within a task, it only supports preventing task failure from cascading into other tasks. My understanding is that this limitation is done because of safety; if a task unwinds through a few frames of code, and then stops unwinding, data structure invariants may have been broken by the unwinding, leaving the task in an unsafe state. Is this correct?
>> 
>> Given this assumption, my worry now is about task unwinding outside of the control of Rust. Namely, if I?m using Rust to write a library with extern ?C? functions, or I?m providing callbacks to C code from within Rust, (and my Rust code calls back into C at some point), then it?s very possible for the called C code to throw an exception that is then caught in the calling C code a few frames up. The net effect is that the thread will unwind through my Rust code, but it will then be caught before unwinding any further, potentially leaving any data structures in an invalid state (assuming that there?s still Rust code higher up on this same stack that cares).
>> 
>> Has this been considered before? Is this actually a danger or am I just being paranoid?
>> 
>> -Kevin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/bf78da4c/attachment-0001.html>

From rusty.gates at icloud.com  Tue Nov 12 19:01:40 2013
From: rusty.gates at icloud.com (Tommi)
Date: Wed, 13 Nov 2013 05:01:40 +0200
Subject: [rust-dev] Could the compiler elide unused static items?
In-Reply-To: <CA++BO6RnhDrjXdo+gV+HpLYFCbXm=ZGveY_9q+qwApnseoq4jw@mail.gmail.com>
References: <C6C56E5B-2AC2-42D9-9366-E3223E01EE22@icloud.com>
	<CA++BO6RnhDrjXdo+gV+HpLYFCbXm=ZGveY_9q+qwApnseoq4jw@mail.gmail.com>
Message-ID: <BA48299A-44AA-46F0-A813-F785DF4C40D5@icloud.com>

Previously I replied incorrectly to the mail, so I'm replying to it anew just to show how the discussion went from here on. Still learning mailing lists, sorry.

These are the missing posts:

On 2013-11-12, at 21:42, Corey Richardson <corey at octayn.net> wrote:

> On Tue, Nov 12, 2013 at 2:39 PM, Tommi <rusty.gates at icloud.com> wrote:
>> I didn't think it would be optimized out of the library code. What I meant was: would the static item be optimized out if the end-user statically links to a library where is some 'pub static' item, which the end-user's code never directly nor indirectly uses?
>> 
> 
> We do not have static linking or LTO, so not. But, once we do, there's
> no reason it wouldn't be.



From danielmicay at gmail.com  Tue Nov 12 19:06:14 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 12 Nov 2013 22:06:14 -0500
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <E5D3A6BC-0849-4F8D-AF5C-11FF52CD9D65@sb.org>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
	<E5D3A6BC-0849-4F8D-AF5C-11FF52CD9D65@sb.org>
Message-ID: <CA+DvKQLZJmBsi2fFEsNQfQy0-5j2gSAKjmBShn0YmqxV5s5R4Q@mail.gmail.com>

On Tue, Nov 12, 2013 at 9:42 PM, Kevin Ballard <kevin at sb.org> wrote:

> I guess I was being too vague when I said ?C exceptions?, because you?re
> right, that?s not actually a specific thing. More concretely, I was
> thinking of either C++ exceptions, or Obj-C exceptions.
>
> One situation I was thinking of would be a rust library that exposes
> `extern ?C?` functions. Let?s say one of these functions, frob(), takes an
> `extern ?C?` callback and calls it. Now let?s say I?m writing an Obj-C app,
> and I do something like the following:
>
> static void callback() {
>     [NSException raise:@?Foo Exception? format:@?I just felt like
> unwinding?];
> }
>
> @try {
>     frob(callback)
> }
> @catch (NSException *e) {
>     NSLog(@?I caught my exception!?);
> }
>
> This will unwind through the Rust code, before being caught again. It?s
> hard to come up with a scenario where this actually results in unsafe state
> within the rust library, but let?s say `frob()` uses some sort of shared
> state (e.g. a RWArc<>), and is in the middle of modifying the shared state
> in a way that causes invariants to be broken temporarily. If unwinding
> happens when the invariants are in the broken state, then they?ll be left
> in the broken state and the next bit of Rust code that tries to access this
> shared state will likely blow up.
>
> This is obviously pretty contrived, but the question is, is this legal to
> do, and if so, do we need to do anything?
>
> Daniel?s response says that it?s undefined for a C++ function to throw an
> exception past an `extern ?C?` boundary. This is something I did not know.
> But what about Obj-C exceptions? I haven?t heard about any undefined
> behavior regarding Obj-C exceptions. It is generally recognized that
> throwing an Obj-C exception past a framework boundary is unsafe (i.e.
> throwing an exception in user code that unwinds through Foundation code),
> but this is because Obj-C code rarely bothers with @try/@finally and
> doesn?t have stack objects, so unwinding through code that doesn?t expect
> it will often leave data structures in invalid states.
>
> If all forms of unwinding are considered to be undefined when passing
> through an `extern ?C?` boundary, then I guess we can consider this issue
> to be covered by undefined behavior. Although this doesn?t make me
> particularly happy, because it means that it may be impossible to truly
> contain the unsafety in FFI functions. One possible way to mitigate this
> would be to provide a way to wrap an FFI function with a stub that catches
> C++/Obj-C exceptions (I *think* Obj-C exceptions are unified with the C++
> exception machinery on all modern platforms (i.e. not 32-bit PPC, and I?m
> not sure about 32-bit x86)) and triggers task failure. This would mean any
> attempt to unwind through a Rust function (using C++ or Obj-C exceptions)
> would be contained, after a fashion.
>
> Though this does raise another question. What if a C++ function calls a
> Rust function, and the Rust function triggers task failure? Is it possible
> for the C++ function to catch the task failure using a catch(?) block?
> Furthermore, since Daniel said it?s undefined for a C++ exception to be
> thrown past an `extern ?C?` boundary, does this mean that it?s technically
> undefined for Rust to trigger task failure in any function that?s rooted in
> an `extern ?C?` function?
>
> -Kevin
>

It's completely possible to write safe bindings to a C++ library. The
process involves wrapping the whole thing with `extern "C"` functions using
catch blocks for any function possibly throwing an exception. Keep in mind
that libraries already have to do this to support usage from most other
languages, so it's a sunken cost.

If a library takes a callback, writing safe Rust bindings isn't going to
turn out well. Rust functions can fail, so the Rust API can't pass an
arbitrary function to the callback.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/8eb88b3e/attachment.html>

From pcwalton at mozilla.com  Tue Nov 12 19:18:25 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 13 Nov 2013 12:18:25 +0900
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CA+DvKQLZJmBsi2fFEsNQfQy0-5j2gSAKjmBShn0YmqxV5s5R4Q@mail.gmail.com>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>	<E5D3A6BC-0849-4F8D-AF5C-11FF52CD9D65@sb.org>
	<CA+DvKQLZJmBsi2fFEsNQfQy0-5j2gSAKjmBShn0YmqxV5s5R4Q@mail.gmail.com>
Message-ID: <5282EF81.6000207@mozilla.com>

On 11/13/13 12:06 PM, Daniel Micay wrote:
> It's completely possible to write safe bindings to a C++ library. The
> process involves wrapping the whole thing with `extern "C"` functions
> using catch blocks for any function possibly throwing an exception. Keep
> in mind that libraries already have to do this to support usage from
> most other languages, so it's a sunken cost.
>
> If a library takes a callback, writing safe Rust bindings isn't going to
> turn out well. Rust functions can fail, so the Rust API can't pass an
> arbitrary function to the callback.

Yeah, this has been a concern for a while (years). Maybe we should have 
an unsafe "catch" just for this case, to allow turning a Rust failure 
into a C-style error code.

Patrick


From kevin at sb.org  Tue Nov 12 19:18:23 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 19:18:23 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <52829BF8.3000200@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
Message-ID: <E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>

On Nov 12, 2013, at 1:22 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/13/13 3:57 AM, Kevin Ballard wrote:
>> On Nov 11, 2013, at 11:43 PM, Patrick Walton <pcwalton at mozilla.com
>> <mailto:pcwalton at mozilla.com>> wrote:
>> 
>>> We considered Go's anonymous fields but rejected them because they
>>> don't support virtual methods at the same time as field embedding.
>> 
>> I don?t follow. Why do Go?s anonymous fields not support virtual methods
>> at the same time as field embedding?
> 
> I want to write this but I can't:
> 
>     [elided for brevity]
> 
>    func main() {
>        myArray := []*A {
>            (&B { A: A { x: 1 }, y: 2 }).Upcast(),
>            (&C { A: A { x: 3 }, z: 4 }).Upcast(),
>        }
>        for i := 0; i < 2; i++ {
>            myArray[i].Foo()
>        }
>    }
> 
> Error:
> 
>    prog.go:41: myArray[i].Foo undefined (type *A has no field or method Foo)
> 
> You can't really write the thing you need to write inside `Upcast` to make this code work. You would need to use an interface instead, but then interfaces don't support shared fields, just like in Rust, leading to the same problem.

Don?t you need a trait in Rust in order to have virtual methods anyway? So the same fundamental problem is there; the machinery to support virtual methods does not support shared fields.

The trick with the proposed single inheritance model is that traits are modified so they can access shared field, by virtue of ?extending a struct?. Presumably this is rather simple with single inheritance, because you know all substructs have the super as a prefix, and thus the trait implementation can ignore all the extra fields in the substruct.

But I don?t see why this can?t also be done with embedded fields. You lose the prefix property, but I don?t think it?s necessary to implement this. The virtual table would just need to store the field offset for the sub-struct that provides the method, so when you call a virtual method, you can ?slice? the parent object (to use Go?s terminology) such that the method?s receiver is the sub-struct itself.

Here?s a sample:

struct A {
    x: int
}

struct B {
    y: int
}

struct C {
    A,
    B,
    z: int
}

trait ATrait : A {
    fn foo(&self);
}

trait BTrait: B {
    fn bar(&self);
}

impl ATrait for A {
    fn foo(&self) {
        println!("This is A: {}", self.x);
    }
}

impl BTrait for B {
    fn bar(&self) {
        println!("This is B: {}", self.y);
    }
}

fn main() {
    let myAs = [A{ x: 1 } as ~ATrait,
                C{ A: A{ x: 2 }, B: B{ y: 3 }, z: 4 } as ~ATrait];
    for a in myAs.iter() {
        a.foo();
    }
    let myBs = [B{ y: 1 } as ~BTrait,
                C{ A: A{ x: 2 }, B: B{ y: 3 }, z: 4} as ~BTrait];
    for b in myBs.iter() {
        b.bar();
    }
}

In the case of calling b.bar() on the C object, this would be equivalent to b.B.bar().

I think it?s reasonable that traits could still only extend a single struct (I believe that relaxing this would require an extra deref on every field access, which is no fun). The point is that trait implementations know the type they?re being implemented on, and therefore having non-prefixed sub-structs is not a problem.

The only penalty this approach has (that comes to mind) over the single-inheritance model is that, because of the loss of the prefix property, any field access on the trait object itself will require looking up the field offset in the virtual table. But trait objects already use the virtual table for everything else, and the actual trait implementations don?t require this, so I don?t think it?s problematic to require a virtual table lookup on trait object field access.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/7ed80c95/attachment-0001.html>

From slabode at aim.com  Tue Nov 12 19:36:17 2013
From: slabode at aim.com (SiegeLord)
Date: Tue, 12 Nov 2013 22:36:17 -0500
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <5282EF81.6000207@mozilla.com>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>	<E5D3A6BC-0849-4F8D-AF5C-11FF52CD9D65@sb.org>
	<CA+DvKQLZJmBsi2fFEsNQfQy0-5j2gSAKjmBShn0YmqxV5s5R4Q@mail.gmail.com>
	<5282EF81.6000207@mozilla.com>
Message-ID: <5282F3B1.2080901@aim.com>

On 11/12/2013 10:18 PM, Patrick Walton wrote:
> On 11/13/13 12:06 PM, Daniel Micay wrote:
>> If a library takes a callback, writing safe Rust bindings isn't going to
>> turn out well. Rust functions can fail, so the Rust API can't pass an
>> arbitrary function to the callback.
>
> Yeah, this has been a concern for a while (years). Maybe we should have
> an unsafe "catch" just for this case, to allow turning a Rust failure
> into a C-style error code.
>
> Patrick

Is that not, essentially, just spawning a task inside the Rust callback 
and catching the result (via task::try)?

-SL


From pcwalton at mozilla.com  Tue Nov 12 21:01:08 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 13 Nov 2013 14:01:08 +0900
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
Message-ID: <52830794.3070504@mozilla.com>

On 11/13/13 12:18 PM, Kevin Ballard wrote:
> The only penalty this approach has (that comes to mind) over the
> single-inheritance model is that, because of the loss of the prefix
> property, any field access on the trait object itself will require
> looking up the field offset in the virtual table. But trait objects
> already use the virtual table for everything else, and the actual trait
> implementations don?t require this, so I don?t think it?s problematic to
> require a virtual table lookup on trait object field access.

I think it is. This is a performance cost over C++ that is just too 
risky. Note that browser reflow is very much gated on the ability to 
load and store fields from a constant offset. I think we stand a good 
chance of losing to the competition if we do this.

Patrick


From kevin at sb.org  Tue Nov 12 22:26:17 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 22:26:17 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <52830794.3070504@mozilla.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
Message-ID: <129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>

On Nov 12, 2013, at 9:01 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/13/13 12:18 PM, Kevin Ballard wrote:
>> The only penalty this approach has (that comes to mind) over the
>> single-inheritance model is that, because of the loss of the prefix
>> property, any field access on the trait object itself will require
>> looking up the field offset in the virtual table. But trait objects
>> already use the virtual table for everything else, and the actual trait
>> implementations don?t require this, so I don?t think it?s problematic to
>> require a virtual table lookup on trait object field access.
> 
> I think it is. This is a performance cost over C++ that is just too risky. Note that browser reflow is very much gated on the ability to load and store fields from a constant offset. I think we stand a good chance of losing to the competition if we do this.

How does C++ multiple inheritance deal with this? I've never looked much at the actual implementation. Specifically, if I have something like

  #include <iostream>

  class A {
  public:
    int x = 1;
    virtual ~A() = default;
  };

  class B {
  public:
    int y = 2;
    virtual ~B() = default;
  };

  class C: public A, public B {
  public:
    int z = 3;
  };

  int main(int argc, char *argv[]) {
    B *someB = new C();
    std::cout << "y: " << someB->y << std::endl;
  }

I assume that `someB` really is a pointer to an instance `B`, somewhere within the enclosing instance of `C`. I also assume that the vtable for this instance of `B` contains a pointer back to the root `C` (or perhaps an offset back to the root `C`, so the vtable can be shared). This would allow field access and non-virtual methods to work exactly as they do on a non-virtual class, and virtual methods would look up the root C object before resolving (and dynamic_cast<> would use this as well).

Why can't something similar be done in Rust? I assume a ~Trait right now is a pair of pointers: a pointer to the wrapped object, and a pointer to the vtable. Stick the offset from the embedded field back to its parent in the vtable, and have the value pointer in the trait point to the portion of the wrapped value that represents the struct that the trait inherits from. This obviously means that traits are then required to only inherit from a single struct, but I think that's reasonable. And even that restriction could be lifted if ~Trait objects could be represented using an array of pointers (one to each inherited struct), e.g. ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is not worth doing.

Anyway, if the trait object contains the pointer to the inherited struct, then field access would still be a constant offset, and virtual method calls could be done by looking up the "master" pointer from the vtable, just as I assume C++ multiple inheritance does.

-Kevin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/bae4ec60/attachment.p7s>

From kevin at sb.org  Tue Nov 12 22:30:16 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 12 Nov 2013 22:30:16 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
Message-ID: <9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>

On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:

> And even that restriction could be lifted if ~Trait objects could be represented using an array of pointers (one to each inherited struct), e.g. ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is not worth doing.

Upon further reflection, this  would need to be done anyway because of the ability to combine traits. If I have

trait TraitA : A {}
trait TraitB : B {}

and I want to use ~TraitA+TraitB then I would need a "fat" trait. Although in this case the number of value pointers is equal to the number of combined traits, so it's a bit more sensible to allow for "fat" trait pointers here.

-Kevin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131112/acd7aa4f/attachment.p7s>

From oren at ben-kiki.org  Tue Nov 12 23:36:50 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 09:36:50 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
Message-ID: <CADJiDhuYyq6OOWb9jSDbkVtO10RXhZWDxm2pe7y0oFFDvuYSBA@mail.gmail.com>

It seems the argument on single-inheritance hinges on the following use
case:

struct Foo { foo: int }

struct Bar : Foo { bar: bar }

fn main() {
    let myFoos = [Foo{ foo: 1 } as ~Foo, Bar{ foo: Foo{foo: 1}, bar: 2} as
~Foo];
    for myFoo in myFoos.iter() {
        myFoo.foo; // Fixed offset access
    }
}

If I understand correctly, this member access is vital for Servo.

At the same time, I (and I think others) would like to see some form of a
flexible implementation reuse for traits, with the understanding the
invoking trait methods incurs the cost of a virtual function anyway.

I think it is "obvious" that the same mechanism can't do both. So how about
a compromise? There would be two mechanisms, but we'll make them play nice
with each other.

Mechanism #1: Struct-traits.
Mechanism #3: Anonymous fields.

struct Foo { foo: int }

// Note: Use "Foo" as a trait.
// Any type implementing "Foo" has a publicly-reachable "Foo" member at
offset 0.
// The trait "Foo" allows constant-offset access to all the "Foo" data
members.
fn use_foo<T: Foo>(ptr: &T) -> int {
    ptr.foo // Fixed offset
}

// By construction, Bar implements the Foo struct-trait
struct Bar {
    Foo;
    bar: int;
}

(It is also possible to add a new syntax "struct Bar : Foo { bar int }", if
this is seen as clearer, but IMO it isn't really needed).

// Baz also implements Foo by construction.
struct Baz {
    Bar;
    baz: int;
}

// Qux doesn't implement Foo.
struct Qux {
    qux: int,
    Foo
}

As for non-struct traits, anonymous fields would provide a default
implementation. That is, suppose that:

impl Trait for Foo { ... }

Then one would be need to write (explicitly!):

impl Trait for Bar {} // Just use the default from Foo

Or:

impl Trait for Bar { ... override some of the methods ... };

(I think it is a bad idea to have traits be implemented implicitly just
because one anonymous field implements them; IMVHO an explicit "impl Trait
for Container" is a "very good idea").

This way you can have your cake and eat it 2. I think it is pretty clean -
traits do arbitrary mixin things with virtual-function cost (_with_
implementation reuse); And there's a "by definition single inheritance"
special access-my-data-members-at-fixed-offset trait whose existence does
not impact the power of the normal mixin traits in any way.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/1ac9e14b/attachment-0001.html>

From vadimcn at gmail.com  Wed Nov 13 00:02:30 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 00:02:30 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks in
	Rust)
Message-ID: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>

Hi,
I would like to float a proposal (or three :-), regarding "greenlets" in
Rust.  For those unfamiliar with greenlets, they are a tool for writing
concurrent code, similar to Rust's tasks, but much more light-weight in
terms of memory consumption (especially now that segmented stacks are no
more).

I think there are some scenarios where low memory consumption per-task is
still important, 64-bit address spaces notwithstanding.   A typical one
would be a pub-sub server, which needs to maintain a massive number of
simple I/O workflows, where I/O channels are idle most of the time.

So here we go (in the order of increasing craziness):

1. Recently I've learned how Python
greenlets<http://greenlet.readthedocs.org/>are
implemented <http://stackoverflow.com/a/17447308>.  I believe that the same
approach could work in Rust:

Basically, greenlets are spawned using the same stack as the parent
greenlet, just like a normal function call.  When a greenlet is suspended,
it copies the portion of the stack used up since its' spawning to the
heap.  When one is re-activated, the saved memory is copied back where it
came from (having first saved stack of the previous active greenlet,- if
they overlap).

Since greenlets don't need to save "red zone" of the stack, the amount of
data per instance is precisely what is actually used.

There are also downsides, of course:
- greenlets are bound to the thread that spawned them,
- two memcpy's are needed when switching between them.

In the case of Python, though, there's one further optimization: since
Python's stack frames live on the heap, in most cases, there nothing on the
hardware stack that a greenlet needs saving!   As a bonus, it can now be
resumed at any stack position, so no saving of previous greenlet's stack is
needed.  The only time when a full save occurs is when there are foreign
stack frames on the stack.


2. Well, can Rust do the same?   What if we came up with an attribute, say,
[#stackless], which causes a function to allocate it's stack frame on the
heap and put all local vars there?    The only things on the actual
hardware stack would then be the function's arguments, the return address,
the saved base pointer and the pointer to that heap-alllocated frame.
With the exception of base pointers, all these things are
position-independent, I believe.   And base pointer chain can be easily
fixed up if/when stack is moved.

So if we had that, and the whole greenlet's stack consisted of such
functions, and there was a way for the "switch_to_greenlet()" function to
detect that, then such greenlet's stack would be relocatable and could be
resumed at any position in the thread's stack (or even in another thread!)
with minimal memory copying, just like in Python.

Of course, the [#stackless] functions would be slower than the normal ones,
but in the scenario I've outlined in the beginning, it shouldn't be a
problem.


3.  Unfortunately, in order for the above scheme to work, all I/O methods,
(which are typically where yields happen), would need to be marked as
[#stackless]...  This would affect the performance of "normal" code using
the same API, which is undesirable.

Okay, but usually there are not *that *many things that point into the
stack in a typical program.  I can think of only three things: references
to stack-allocated buffers, base pointer chains and references to
caller-allocated return values.
- The first one can be lived without - just allocate buffers on the heap.
- The second one - see above.
- The last one is more tricky, but for the sake of argument, let's assume
that we restricted function signatures such that only register-allocated
types can be returned.

Let's say we came up with a way to mark up functions that may yield to
another greenlet, and also with a way to prohibit taking address of
stack-allocated variables for the duration of calls to yielding functions.
These restrictions would be annoying, but not overly so, as long as you had
to obey them only in functions that are intended to be run in a greenlet.
On the plus side, the hardware stack contents would now be relocatable.

In this setup, everything could proceed as usual, using the hardware stack,
until execution came to a  blocking I/O call.   At that point, the
scheduler would check if running inside a greenlet, copy greenlet's stack
to the heap and switch off to another greenlet.  Otherwise, it would do the
same thing it does now, i.e. switch tasks.


So, what do you say, rustafarians?   Does any of that make any sense?

Vadim


On Tue, Nov 5, 2013 at 9:18 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/5/13 8:32 AM, David Piepgrass wrote:
>
>> Segmented stacks aren't the only solution though.
>>
>> If the concern is many tasks that block for a long time, I imagine a
>> mechanism to bundle a bunch of small, dormant stacks into a single page
>> so that the original pages could be released to the OS.
>>
>>
>>
>> *If stacks were additionally relocatable (which requires similar
>> machinery as precise moving GC, if I'm not mistaken) *
>
>
> This is correct. It's conceivable (although I can't make any promises)
> that if and when LLVM supports this, we could experiment with doing what Go
> does.
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/f73a05d1/attachment.html>

From ecreed at cs.washington.edu  Wed Nov 13 00:27:21 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Wed, 13 Nov 2013 00:27:21 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
Message-ID: <CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>

Here's how I would do it using just existing Rust (assuming this hasn't all
changed under me in the past couple months).
NB: I haven't actually tried compiling this, but I'm pretty sure it (or
something like it) would work.

Nice properties over this solution:
- Doesn't require language extensions (although syntax sugar wouldn't be
unwelcome)
- Doesn't require trait objects (i.e. static dispatch is possible)
- Only need to implement one method for each derived type (super) in
addition to overridden methods
- Supports multiple inheritance in two ways (and avoids the diamond problem
I think -- not a C++ expert so I may have misunderstood that)
      + no default parent and programmer must select which parent to use
before calling
      + implementer-chosen default parent and programmer can chose to use a
different parent if desired

Neutral?:
- Doesn't enforce or care about the prefix property. Not sure if that still
matters so much w/o dynamic dispatch.

Downsides:
- Performance of delegation depends on LLVM's ability to inline (I think).
- Does require repeating all the methods once (for delegating default
implementations)

// The base type
struct Base {
    data : int;
}

// Characterize it's extensible behavior in a trait
trait Trait {
    fn method(&self);
}

// Implement the base behavior
impl Trait for Base {
    fn method(&self) { ... }
}

// Extension of trait that supports upcasting to existing implementations
trait DerivingTrait<P : Trait> : Trait {
    // one extra method for accessing a parent's implementation. ideally
this would be inlined by the compiler
    fn super(&self) -> P;
    // default implementations for all the methods in Trait let us avoid
writing delegation everywhere manually
    fn method(&self) {
         self.super().method() // just delegate to parent
    }
}

// Single inheritance
struct Single {
    parent: Base,
    moreData: int,
}

impl DerivingTrait<Base> for Single {
    fn super(&self) -> Base { self.parent }
}

// Overriding behavior
struct Override {
    parent: Base,
    otherData: u8,
}

impl DerivingTrait<Base> for Override {
    fn super(&self) -> Base { self.parent }
    fn method(&self) { ... }
}

// Multiple inheritance
struct Multiple {
    single: Single,
    override: Override,
    evenMoreData: ~str,
}

// must specify which parent's implementation we want (could hide wrapping
inside of as_* methods impl'd on Multiple if you like)
// if we want one of them as the default, then we can impl DerivingTrait on
Multiple directly
struct MultipleAsSingle(Multiple);
struct MultipleAsOverride(Multiple);

impl DerivingTrait<Single> for MultipleAsSingle {
    fn super(&self) -> Single { self.single }
}

impl DerivingTrait<Override> for MultipleAsOverride {
    fn super(&self) -> Override { self.override }
}

fn main() {
    let base = Base { ... };
    let single = Single { ... };
    let override = Override { ... };
    let multiple = Multiple { ... };

    base.method();
    base.super(); // compile time error

    single.method(); // =inline delegation=> single.super().method()
=inline upcast=> single.base.method()
    override.method(); // done! no delegating
    MultipleAsSingle(multiple).method(); // =delegate=>
MAS(multiple).super().method() =upcast=> multiple.single.method()
=delegate=> multiple.single.super().method() =upcast=>
multiple.single.base.method()
    MutlipleAsOverride(multiple).method(); // =delegate=>
MAO(multiple).super().method() =upcast=> multiple.override.method()
}

Thoughts?

Eric


On Tue, Nov 12, 2013 at 10:30 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:
>
> > And even that restriction could be lifted if ~Trait objects could be
> represented using an array of pointers (one to each inherited struct), e.g.
> ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is
> not worth doing.
>
> Upon further reflection, this  would need to be done anyway because of the
> ability to combine traits. If I have
>
> trait TraitA : A {}
> trait TraitB : B {}
>
> and I want to use ~TraitA+TraitB then I would need a "fat" trait. Although
> in this case the number of value pointers is equal to the number of
> combined traits, so it's a bit more sensible to allow for "fat" trait
> pointers here.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/2ba51e35/attachment.html>

From mozilla at mcpherrin.ca  Wed Nov 13 00:49:49 2013
From: mozilla at mcpherrin.ca (Matthew McPherrin)
Date: Wed, 13 Nov 2013 00:49:49 -0800
Subject: [rust-dev] Rust compiler running on ARM?
In-Reply-To: <CA++BO6TupD3=bbrV0c8UWbYRitnOKqCayfAAf=kHpvwLOjccCg@mail.gmail.com>
References: <CADd11yWpFmqmefWt_kMXCo_E7YKu=Uzvt7==Q5kfTGtHX=YWmQ@mail.gmail.com>
	<CA++BO6TupD3=bbrV0c8UWbYRitnOKqCayfAAf=kHpvwLOjccCg@mail.gmail.com>
Message-ID: <CAMYrfj++sMrJR225cLBKeasj0Y+evn00AauL9dHusC_q7mDRqg@mail.gmail.com>

Luqman got rustc running on ARM.  Builds are maybe here:
http://luqman.ca/rust-builds/

On Mon, Oct 21, 2013 at 12:42 AM, Corey Richardson <corey at octayn.net> wrote:
> I've yet to see or hear of a rustc running native on ARM, though it
> shouldn't be impossible to cross-build rustc for native ARM: we can
> already target ARM just fine.
>
> On Mon, Oct 21, 2013 at 2:01 AM, Igor Bukanov <igor at mir2.org> wrote:
>> What is the current status of ARM support in Rust? In particularly I
>> am interested in running the compiler on an ARM Chromebook.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ecreed at cs.washington.edu  Wed Nov 13 01:01:22 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Wed, 13 Nov 2013 01:01:22 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
Message-ID: <CANbMr6HdBkmnkA-HJGoKxZ=bwg5AXYgQUkhpq=qb535j_CL55w@mail.gmail.com>

The big issue I see right away (assuming I read this correctly and
greenlets can still access the stack that existed when they were created),
is that now mutable state on the stack is *shared* between greenlets and
therefore can experience *data races* (impossible for tasks b/c they don't
share memory), so they sound wildly unsafe to me.

There may be some other issues that arise from the shared stack prefix
property:
- If a greenlet moves something on the stack, then other greenlets now have
access to invalidated memory
- You can no longer assume that you have sole access things pointed to by
unique pointers, which would probably invalidate a lot of existing
assumptions.

Eric


On Wed, Nov 13, 2013 at 12:02 AM, Vadim <vadimcn at gmail.com> wrote:

> Hi,
> I would like to float a proposal (or three :-), regarding "greenlets" in
> Rust.  For those unfamiliar with greenlets, they are a tool for writing
> concurrent code, similar to Rust's tasks, but much more light-weight in
> terms of memory consumption (especially now that segmented stacks are no
> more).
>
> I think there are some scenarios where low memory consumption per-task is
> still important, 64-bit address spaces notwithstanding.   A typical one
> would be a pub-sub server, which needs to maintain a massive number of
> simple I/O workflows, where I/O channels are idle most of the time.
>
> So here we go (in the order of increasing craziness):
>
> 1. Recently I've learned how Python greenlets<http://greenlet.readthedocs.org/>are
> implemented <http://stackoverflow.com/a/17447308>.  I believe that the
> same approach could work in Rust:
>
> Basically, greenlets are spawned using the same stack as the parent
> greenlet, just like a normal function call.  When a greenlet is suspended,
> it copies the portion of the stack used up since its' spawning to the
> heap.  When one is re-activated, the saved memory is copied back where it
> came from (having first saved stack of the previous active greenlet,- if
> they overlap).
>
> Since greenlets don't need to save "red zone" of the stack, the amount of
> data per instance is precisely what is actually used.
>
> There are also downsides, of course:
> - greenlets are bound to the thread that spawned them,
> - two memcpy's are needed when switching between them.
>
> In the case of Python, though, there's one further optimization: since
> Python's stack frames live on the heap, in most cases, there nothing on the
> hardware stack that a greenlet needs saving!   As a bonus, it can now be
> resumed at any stack position, so no saving of previous greenlet's stack is
> needed.  The only time when a full save occurs is when there are foreign
> stack frames on the stack.
>
>
> 2. Well, can Rust do the same?   What if we came up with an attribute,
> say, [#stackless], which causes a function to allocate it's stack frame on
> the heap and put all local vars there?    The only things on the actual
> hardware stack would then be the function's arguments, the return address,
> the saved base pointer and the pointer to that heap-alllocated frame.
> With the exception of base pointers, all these things are
> position-independent, I believe.   And base pointer chain can be easily
> fixed up if/when stack is moved.
>
> So if we had that, and the whole greenlet's stack consisted of such
> functions, and there was a way for the "switch_to_greenlet()" function to
> detect that, then such greenlet's stack would be relocatable and could be
> resumed at any position in the thread's stack (or even in another thread!)
> with minimal memory copying, just like in Python.
>
> Of course, the [#stackless] functions would be slower than the normal
> ones, but in the scenario I've outlined in the beginning, it shouldn't be a
> problem.
>
>
> 3.  Unfortunately, in order for the above scheme to work, all I/O methods,
> (which are typically where yields happen), would need to be marked as
> [#stackless]...  This would affect the performance of "normal" code using
> the same API, which is undesirable.
>
> Okay, but usually there are not *that *many things that point into the
> stack in a typical program.  I can think of only three things: references
> to stack-allocated buffers, base pointer chains and references to
> caller-allocated return values.
> - The first one can be lived without - just allocate buffers on the heap.
> - The second one - see above.
> - The last one is more tricky, but for the sake of argument, let's assume
> that we restricted function signatures such that only register-allocated
> types can be returned.
>
> Let's say we came up with a way to mark up functions that may yield to
> another greenlet, and also with a way to prohibit taking address of
> stack-allocated variables for the duration of calls to yielding functions.
> These restrictions would be annoying, but not overly so, as long as you
> had to obey them only in functions that are intended to be run in a
> greenlet.
> On the plus side, the hardware stack contents would now be relocatable.
>
> In this setup, everything could proceed as usual, using the hardware
> stack, until execution came to a  blocking I/O call.   At that point, the
> scheduler would check if running inside a greenlet, copy greenlet's stack
> to the heap and switch off to another greenlet.  Otherwise, it would do the
> same thing it does now, i.e. switch tasks.
>
>
> So, what do you say, rustafarians?   Does any of that make any sense?
>
> Vadim
>
>
> On Tue, Nov 5, 2013 at 9:18 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>
>> On 11/5/13 8:32 AM, David Piepgrass wrote:
>>
>>> Segmented stacks aren't the only solution though.
>>>
>>> If the concern is many tasks that block for a long time, I imagine a
>>> mechanism to bundle a bunch of small, dormant stacks into a single page
>>> so that the original pages could be released to the OS.
>>>
>>>
>>>
>>> *If stacks were additionally relocatable (which requires similar
>>> machinery as precise moving GC, if I'm not mistaken) *
>>
>>
>> This is correct. It's conceivable (although I can't make any promises)
>> that if and when LLVM supports this, we could experiment with doing what Go
>> does.
>>
>> Patrick
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/aaf83410/attachment.html>

From oren at ben-kiki.org  Wed Nov 13 01:25:10 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 11:25:10 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
Message-ID: <CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>

This is probably as good as we can get in the current system (I do
something similar in my code today).

I also think you probably need both "super" and "mut_super", so it would be
two methods to implement instead of one (still pretty good). I wonder
whether it is possible to write a macro that automates writing these
boilerplate methods?

The key weakness is that (I think) the compiler can't inline the accesses
to "super" so that you end up with a chain of virtual function calls every
time it is accessed, so performance would be pretty bad.


On Wed, Nov 13, 2013 at 10:27 AM, Eric Reed <ecreed at cs.washington.edu>wrote:

> Here's how I would do it using just existing Rust (assuming this hasn't
> all changed under me in the past couple months).
> NB: I haven't actually tried compiling this, but I'm pretty sure it (or
> something like it) would work.
>
> Nice properties over this solution:
> - Doesn't require language extensions (although syntax sugar wouldn't be
> unwelcome)
> - Doesn't require trait objects (i.e. static dispatch is possible)
> - Only need to implement one method for each derived type (super) in
> addition to overridden methods
> - Supports multiple inheritance in two ways (and avoids the diamond
> problem I think -- not a C++ expert so I may have misunderstood that)
>       + no default parent and programmer must select which parent to use
> before calling
>       + implementer-chosen default parent and programmer can chose to use
> a different parent if desired
>
> Neutral?:
> - Doesn't enforce or care about the prefix property. Not sure if that
> still matters so much w/o dynamic dispatch.
>
> Downsides:
> - Performance of delegation depends on LLVM's ability to inline (I think).
> - Does require repeating all the methods once (for delegating default
> implementations)
>
> // The base type
> struct Base {
>     data : int;
> }
>
> // Characterize it's extensible behavior in a trait
> trait Trait {
>     fn method(&self);
> }
>
> // Implement the base behavior
> impl Trait for Base {
>     fn method(&self) { ... }
> }
>
> // Extension of trait that supports upcasting to existing implementations
> trait DerivingTrait<P : Trait> : Trait {
>     // one extra method for accessing a parent's implementation. ideally
> this would be inlined by the compiler
>     fn super(&self) -> P;
>     // default implementations for all the methods in Trait let us avoid
> writing delegation everywhere manually
>     fn method(&self) {
>          self.super().method() // just delegate to parent
>     }
> }
>
> // Single inheritance
> struct Single {
>     parent: Base,
>     moreData: int,
> }
>
> impl DerivingTrait<Base> for Single {
>     fn super(&self) -> Base { self.parent }
> }
>
> // Overriding behavior
> struct Override {
>     parent: Base,
>     otherData: u8,
> }
>
> impl DerivingTrait<Base> for Override {
>     fn super(&self) -> Base { self.parent }
>     fn method(&self) { ... }
> }
>
> // Multiple inheritance
> struct Multiple {
>     single: Single,
>     override: Override,
>     evenMoreData: ~str,
> }
>
> // must specify which parent's implementation we want (could hide wrapping
> inside of as_* methods impl'd on Multiple if you like)
> // if we want one of them as the default, then we can impl DerivingTrait
> on Multiple directly
> struct MultipleAsSingle(Multiple);
> struct MultipleAsOverride(Multiple);
>
> impl DerivingTrait<Single> for MultipleAsSingle {
>     fn super(&self) -> Single { self.single }
> }
>
> impl DerivingTrait<Override> for MultipleAsOverride {
>     fn super(&self) -> Override { self.override }
> }
>
> fn main() {
>     let base = Base { ... };
>     let single = Single { ... };
>     let override = Override { ... };
>     let multiple = Multiple { ... };
>
>     base.method();
>     base.super(); // compile time error
>
>     single.method(); // =inline delegation=> single.super().method()
> =inline upcast=> single.base.method()
>     override.method(); // done! no delegating
>     MultipleAsSingle(multiple).method(); // =delegate=>
> MAS(multiple).super().method() =upcast=> multiple.single.method()
> =delegate=> multiple.single.super().method() =upcast=>
> multiple.single.base.method()
>     MutlipleAsOverride(multiple).method(); // =delegate=>
> MAO(multiple).super().method() =upcast=> multiple.override.method()
> }
>
> Thoughts?
>
> Eric
>
>
> On Tue, Nov 12, 2013 at 10:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>
>> On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>> > And even that restriction could be lifted if ~Trait objects could be
>> represented using an array of pointers (one to each inherited struct), e.g.
>> ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is
>> not worth doing.
>>
>> Upon further reflection, this  would need to be done anyway because of
>> the ability to combine traits. If I have
>>
>> trait TraitA : A {}
>> trait TraitB : B {}
>>
>> and I want to use ~TraitA+TraitB then I would need a "fat" trait.
>> Although in this case the number of value pointers is equal to the number
>> of combined traits, so it's a bit more sensible to allow for "fat" trait
>> pointers here.
>>
>> -Kevin
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/24780814/attachment-0001.html>

From ecreed at cs.washington.edu  Wed Nov 13 02:21:18 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Wed, 13 Nov 2013 02:21:18 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
Message-ID: <CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>

I'm not clear on why LLVM wouldn't be able to inline super() calls. It's
static dispatch, so it knows exactly what function is being called.


On Wed, Nov 13, 2013 at 1:25 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> This is probably as good as we can get in the current system (I do
> something similar in my code today).
>
> I also think you probably need both "super" and "mut_super", so it would
> be two methods to implement instead of one (still pretty good). I wonder
> whether it is possible to write a macro that automates writing these
> boilerplate methods?
>
> The key weakness is that (I think) the compiler can't inline the accesses
> to "super" so that you end up with a chain of virtual function calls every
> time it is accessed, so performance would be pretty bad.
>
>
> On Wed, Nov 13, 2013 at 10:27 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> Here's how I would do it using just existing Rust (assuming this hasn't
>> all changed under me in the past couple months).
>> NB: I haven't actually tried compiling this, but I'm pretty sure it (or
>> something like it) would work.
>>
>> Nice properties over this solution:
>> - Doesn't require language extensions (although syntax sugar wouldn't be
>> unwelcome)
>> - Doesn't require trait objects (i.e. static dispatch is possible)
>> - Only need to implement one method for each derived type (super) in
>> addition to overridden methods
>> - Supports multiple inheritance in two ways (and avoids the diamond
>> problem I think -- not a C++ expert so I may have misunderstood that)
>>       + no default parent and programmer must select which parent to use
>> before calling
>>       + implementer-chosen default parent and programmer can chose to use
>> a different parent if desired
>>
>> Neutral?:
>> - Doesn't enforce or care about the prefix property. Not sure if that
>> still matters so much w/o dynamic dispatch.
>>
>> Downsides:
>> - Performance of delegation depends on LLVM's ability to inline (I think).
>> - Does require repeating all the methods once (for delegating default
>> implementations)
>>
>> // The base type
>> struct Base {
>>     data : int;
>> }
>>
>> // Characterize it's extensible behavior in a trait
>> trait Trait {
>>     fn method(&self);
>> }
>>
>> // Implement the base behavior
>> impl Trait for Base {
>>     fn method(&self) { ... }
>> }
>>
>> // Extension of trait that supports upcasting to existing implementations
>> trait DerivingTrait<P : Trait> : Trait {
>>     // one extra method for accessing a parent's implementation. ideally
>> this would be inlined by the compiler
>>     fn super(&self) -> P;
>>     // default implementations for all the methods in Trait let us avoid
>> writing delegation everywhere manually
>>     fn method(&self) {
>>          self.super().method() // just delegate to parent
>>     }
>> }
>>
>> // Single inheritance
>> struct Single {
>>     parent: Base,
>>     moreData: int,
>> }
>>
>> impl DerivingTrait<Base> for Single {
>>     fn super(&self) -> Base { self.parent }
>> }
>>
>> // Overriding behavior
>> struct Override {
>>     parent: Base,
>>     otherData: u8,
>> }
>>
>> impl DerivingTrait<Base> for Override {
>>     fn super(&self) -> Base { self.parent }
>>     fn method(&self) { ... }
>>  }
>>
>> // Multiple inheritance
>> struct Multiple {
>>     single: Single,
>>     override: Override,
>>     evenMoreData: ~str,
>> }
>>
>> // must specify which parent's implementation we want (could hide
>> wrapping inside of as_* methods impl'd on Multiple if you like)
>> // if we want one of them as the default, then we can impl DerivingTrait
>> on Multiple directly
>> struct MultipleAsSingle(Multiple);
>> struct MultipleAsOverride(Multiple);
>>
>> impl DerivingTrait<Single> for MultipleAsSingle {
>>     fn super(&self) -> Single { self.single }
>> }
>>
>> impl DerivingTrait<Override> for MultipleAsOverride {
>>     fn super(&self) -> Override { self.override }
>> }
>>
>> fn main() {
>>     let base = Base { ... };
>>     let single = Single { ... };
>>     let override = Override { ... };
>>     let multiple = Multiple { ... };
>>
>>     base.method();
>>     base.super(); // compile time error
>>
>>     single.method(); // =inline delegation=> single.super().method()
>> =inline upcast=> single.base.method()
>>     override.method(); // done! no delegating
>>     MultipleAsSingle(multiple).method(); // =delegate=>
>> MAS(multiple).super().method() =upcast=> multiple.single.method()
>> =delegate=> multiple.single.super().method() =upcast=>
>> multiple.single.base.method()
>>     MutlipleAsOverride(multiple).method(); // =delegate=>
>> MAO(multiple).super().method() =upcast=> multiple.override.method()
>> }
>>
>> Thoughts?
>>
>> Eric
>>
>>
>> On Tue, Nov 12, 2013 at 10:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>>> On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> > And even that restriction could be lifted if ~Trait objects could be
>>> represented using an array of pointers (one to each inherited struct), e.g.
>>> ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is
>>> not worth doing.
>>>
>>> Upon further reflection, this  would need to be done anyway because of
>>> the ability to combine traits. If I have
>>>
>>> trait TraitA : A {}
>>> trait TraitB : B {}
>>>
>>> and I want to use ~TraitA+TraitB then I would need a "fat" trait.
>>> Although in this case the number of value pointers is equal to the number
>>> of combined traits, so it's a bit more sensible to allow for "fat" trait
>>> pointers here.
>>>
>>> -Kevin
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/df1d57c4/attachment.html>

From danielmicay at gmail.com  Wed Nov 13 02:45:19 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 05:45:19 -0500
Subject: [rust-dev] The future of M:N threading
Message-ID: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>

Before getting right into the gritty details about why I think we should think
about a path away from M:N scheduling, I'll go over the details of the
concurrency model we currently use.

Rust uses a user-mode scheduler to cooperatively schedule many tasks onto OS
threads. Due to the lack of preemption, tasks need to manually yield control
back to the scheduler. Performing I/O with the standard library will block the
*task*, but yield control back to the scheduler until the I/O is completed.

The scheduler manages a thread pool where the unit of work is a task rather
than a queue of closures to be executed or data to be pass to a function. A
task consists of a stack, register context and task-local storage much like an
OS thread.

In the world of high-performance computing, this is a proven model for
maximizing throughput for CPU-bound tasks. By abandoning preemption, there's
zero overhead from context switches. For socket servers with only negligible
server-side computations the avoidance of context switching is a boon for
scalability and predictable performance.

# Lightweight?

Rust's tasks are often called *lightweight* but at least on Linux the only
optimization is the lack of preemption. Since segmented stacks have been
dropped, the resident/virtual memory usage will be identical.

# Spawning performance

An OS thread can actually spawn nearly as fast as a Rust task on a system with
one CPU. On a multi-core system, there's a high chance of the new thread being
spawned on a different CPU resulting in a performance loss.

Sample C program, if you need to see it to believe it:

```
#include <pthread.h>
#include <err.h>

static const size_t n_thread = 100000;

static void *foo(void *arg) {
    return arg;
}

int main(void) {
    for (size_t i = 0; i < n_thread; i++) {
        pthread_attr_t attr;
        if (pthread_attr_init(&attr) < 0) {
            return 1;
        }
        if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) < 0) {
            return 1;
        }
        pthread_t thread;
        if (pthread_create(&thread, &attr, foo, NULL) < 0) {
            return 1;
        }
    }
    pthread_exit(NULL);
}
```

Sample Rust program:

```
fn main() {
    for _ in range(0, 100000) {
        do spawn {
        }
    }
}
```

For both programs, I get around 0.9s consistently when pinned to a core. The
Rust version drops to 1.1s when not pinned and the OS thread one to about 2s.
It drops further when asked to allocate 8MiB stacks like C is doing, and will
drop more when it has to do `mmap` and `mprotect` calls like the pthread API.

# Asynchronous I/O

Rust's requirements for asynchronous I/O would be filled well by direct usage
of IOCP on Windows. However, Linux only has solid support for non-blocking
sockets because file operations usually just retrieve a result from cache and
do not truly have to block. This results in libuv being significantly slower
than blocking I/O for most common cases for the sake of scalable socket
servers.

On modern systems with flash memory, including mobile, there is a *consistent*
and relatively small worst-case latency for accessing data on the disk so
blocking is essentially a non-issue. Memory mapped I/O is also an incredibly
important feature for I/O performance, and there's almost no reason to use
traditional I/O on 64-bit. However, it's a no-go with M:N scheduling because
the page faults block the thread.

# Overview

Advantages:

* lack of preemptive/fair scheduling, leading to higher throughput
* very fast context switches to other tasks on the same scheduler thread

Disadvantages:

* lack of preemptive/fair scheduling (lower-level model)
* poor profiler/debugger support
* async I/O stack is much slower for the common case; for example stat is 35x
  slower when run in a loop for an mlocate-like utility
* true blocking code will still block a scheduler thread
* most existing libraries use blocking I/O and OS threads
* cannot directly use fast and easy to use linker-supported thread-local data
* many existing libraries rely on thread-local storage, so there's a need to be
  wary of hidden yields in Rust function calls and it's very difficult to
  expose a safe interface to these libraries
* every level of a CPU architecture adding registers needs explicit support
  from Rust, and it must be selected at runtime when not targeting a specific
  CPU (this is currently not done correctly)

# User-mode scheduling

Windows 7 introduced user-mode scheduling[1] to replace fibers on 64-bit.
Google implemented the same thing for Linux (perhaps even before Windows 7 was
released), and plans on pushing for it upstream.[2] The linked video does a
better job of covering this than I can.

User-mode scheduling provides a 1:1 threading model including full support for
normal thread-local data and existing debuggers/profilers. It can yield to the
scheduler on system calls and page faults. The operating system is responsible
for details like context switching, so a large maintenance/portability burden
is dealt with. It narrows down the above disadvantage list to just the point
about not having preemptive/fair scheduling and doesn't introduce any new ones.

I hope this is where concurrency is headed, and I hope Rust doesn't miss this
boat by concentrating too much on libuv. I think it would allow us to simply
drop support for pseudo-blocking I/O in the Go style and ignore asynchronous
I/O and non-blocking sockets in the standard library. It may be useful to have
the scheduler use them, but it wouldn't be essential.

[1] http://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85).aspx
[2] http://www.youtube.com/watch?v=KXuZi9aeGTw

From danielmicay at gmail.com  Wed Nov 13 02:55:16 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 05:55:16 -0500
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
Message-ID: <CA+DvKQJjVzjN5jCek02yhUqaU-C-rZW6cb_G7Cm9LXmshZcQoA@mail.gmail.com>

> It may be useful to have the scheduler use them, but it wouldn't be essential.

To clarify this, it definitely wouldn't make sense to design *fake*
asynchronous APIs on top of threads anymore.

On Linux, we would probably only want to use non-blocking sockets and
even that might become unnecessary.

From oren at ben-kiki.org  Wed Nov 13 03:46:25 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 13:46:25 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
Message-ID: <CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>

The call isn't statically dispatched when I invoke a method via a trait
pointer. So it seems when I invoke any trait function, I pay double the
cost of a virtual function call instead of one... I suppose it isn't _too_
bad, but it still hurts.



On Wed, Nov 13, 2013 at 12:21 PM, Eric Reed <ecreed at cs.washington.edu>wrote:

> I'm not clear on why LLVM wouldn't be able to inline super() calls. It's
> static dispatch, so it knows exactly what function is being called.
>
>
> On Wed, Nov 13, 2013 at 1:25 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> This is probably as good as we can get in the current system (I do
>> something similar in my code today).
>>
>> I also think you probably need both "super" and "mut_super", so it would
>> be two methods to implement instead of one (still pretty good). I wonder
>> whether it is possible to write a macro that automates writing these
>> boilerplate methods?
>>
>> The key weakness is that (I think) the compiler can't inline the accesses
>> to "super" so that you end up with a chain of virtual function calls every
>> time it is accessed, so performance would be pretty bad.
>>
>>
>> On Wed, Nov 13, 2013 at 10:27 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>>
>>> Here's how I would do it using just existing Rust (assuming this hasn't
>>> all changed under me in the past couple months).
>>> NB: I haven't actually tried compiling this, but I'm pretty sure it (or
>>> something like it) would work.
>>>
>>> Nice properties over this solution:
>>> - Doesn't require language extensions (although syntax sugar wouldn't be
>>> unwelcome)
>>> - Doesn't require trait objects (i.e. static dispatch is possible)
>>> - Only need to implement one method for each derived type (super) in
>>> addition to overridden methods
>>> - Supports multiple inheritance in two ways (and avoids the diamond
>>> problem I think -- not a C++ expert so I may have misunderstood that)
>>>       + no default parent and programmer must select which parent to use
>>> before calling
>>>       + implementer-chosen default parent and programmer can chose to
>>> use a different parent if desired
>>>
>>> Neutral?:
>>> - Doesn't enforce or care about the prefix property. Not sure if that
>>> still matters so much w/o dynamic dispatch.
>>>
>>> Downsides:
>>> - Performance of delegation depends on LLVM's ability to inline (I
>>> think).
>>> - Does require repeating all the methods once (for delegating default
>>> implementations)
>>>
>>> // The base type
>>> struct Base {
>>>     data : int;
>>> }
>>>
>>> // Characterize it's extensible behavior in a trait
>>> trait Trait {
>>>     fn method(&self);
>>> }
>>>
>>> // Implement the base behavior
>>> impl Trait for Base {
>>>     fn method(&self) { ... }
>>> }
>>>
>>> // Extension of trait that supports upcasting to existing implementations
>>> trait DerivingTrait<P : Trait> : Trait {
>>>     // one extra method for accessing a parent's implementation. ideally
>>> this would be inlined by the compiler
>>>     fn super(&self) -> P;
>>>     // default implementations for all the methods in Trait let us avoid
>>> writing delegation everywhere manually
>>>     fn method(&self) {
>>>          self.super().method() // just delegate to parent
>>>     }
>>> }
>>>
>>> // Single inheritance
>>> struct Single {
>>>     parent: Base,
>>>     moreData: int,
>>> }
>>>
>>> impl DerivingTrait<Base> for Single {
>>>     fn super(&self) -> Base { self.parent }
>>> }
>>>
>>> // Overriding behavior
>>> struct Override {
>>>     parent: Base,
>>>     otherData: u8,
>>> }
>>>
>>> impl DerivingTrait<Base> for Override {
>>>     fn super(&self) -> Base { self.parent }
>>>     fn method(&self) { ... }
>>>  }
>>>
>>> // Multiple inheritance
>>> struct Multiple {
>>>     single: Single,
>>>     override: Override,
>>>     evenMoreData: ~str,
>>> }
>>>
>>> // must specify which parent's implementation we want (could hide
>>> wrapping inside of as_* methods impl'd on Multiple if you like)
>>> // if we want one of them as the default, then we can impl DerivingTrait
>>> on Multiple directly
>>> struct MultipleAsSingle(Multiple);
>>> struct MultipleAsOverride(Multiple);
>>>
>>> impl DerivingTrait<Single> for MultipleAsSingle {
>>>     fn super(&self) -> Single { self.single }
>>> }
>>>
>>> impl DerivingTrait<Override> for MultipleAsOverride {
>>>     fn super(&self) -> Override { self.override }
>>> }
>>>
>>> fn main() {
>>>     let base = Base { ... };
>>>     let single = Single { ... };
>>>     let override = Override { ... };
>>>     let multiple = Multiple { ... };
>>>
>>>     base.method();
>>>     base.super(); // compile time error
>>>
>>>     single.method(); // =inline delegation=> single.super().method()
>>> =inline upcast=> single.base.method()
>>>     override.method(); // done! no delegating
>>>     MultipleAsSingle(multiple).method(); // =delegate=>
>>> MAS(multiple).super().method() =upcast=> multiple.single.method()
>>> =delegate=> multiple.single.super().method() =upcast=>
>>> multiple.single.base.method()
>>>     MutlipleAsOverride(multiple).method(); // =delegate=>
>>> MAO(multiple).super().method() =upcast=> multiple.override.method()
>>> }
>>>
>>> Thoughts?
>>>
>>> Eric
>>>
>>>
>>> On Tue, Nov 12, 2013 at 10:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>
>>>> On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>> > And even that restriction could be lifted if ~Trait objects could be
>>>> represented using an array of pointers (one to each inherited struct), e.g.
>>>> ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is
>>>> not worth doing.
>>>>
>>>> Upon further reflection, this  would need to be done anyway because of
>>>> the ability to combine traits. If I have
>>>>
>>>> trait TraitA : A {}
>>>> trait TraitB : B {}
>>>>
>>>> and I want to use ~TraitA+TraitB then I would need a "fat" trait.
>>>> Although in this case the number of value pointers is equal to the number
>>>> of combined traits, so it's a bit more sensible to allow for "fat" trait
>>>> pointers here.
>>>>
>>>> -Kevin
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/bdf8a4a2/attachment-0001.html>

From denis.spir at gmail.com  Wed Nov 13 04:55:56 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 13 Nov 2013 13:55:56 +0100
Subject: [rust-dev] mutability cascade
Message-ID: <528376DC.1060901@gmail.com>

Hello,

I have an error "cannot assign to immutable field". However, it is mutable as I 
understand according to "inherited mutability" rule exposed in the tutorial 
(section 'Structs'). The field in question is in a struct itself item of an 
array, itself field in a super-structure (lol!) which is self. All this happens 
in a method called on "&mut self". (And the compiler lets me change self 
elsewhere in the same method.)
Thus, what is wrong? Or is it so that the mutability cascade is broken due to 
the array? How then restore it and be able to change a struct item's field? I 
guess arrays are mutable by default aren't they? (Or else, here it should due to 
inherited mutability, since it is a field of a mutable struct.)
What do I miss?
[Code below untested yet due to error.]

     fn expand (&mut self) {
         // A mod table expands by doubling its list bucket capacity.
         // Double array of lists, initially filled with NO_CELL values.
         let NO_CELL : uint = -1 as uint;    // flag for end-of-list
         self.n_lists *= 2;
         self.lists = vec::from_elem(self.n_lists, NO_CELL);

         // replace cells into correct lists according to new key modulo.
         let mut i_list : uint;
         let mut i_cell : uint = 0;
         for cell in self.cells.iter() {
             // Link cell at start of correct list.
             i_list = cell.key % self.n_lists;
             cell.i_next = self.lists[i_list];           // ERROR ***
             self.lists[i_list] = i_cell;
             i_cell += 1;
         }
     }

I take the opportunity to ask whether there's an (i, item) iterator for arrays.

Thank you,
Denis

From dbau.pp at gmail.com  Wed Nov 13 05:06:30 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 14 Nov 2013 00:06:30 +1100
Subject: [rust-dev] mutability cascade
In-Reply-To: <528376DC.1060901@gmail.com>
References: <528376DC.1060901@gmail.com>
Message-ID: <52837956.3080409@gmail.com>

On 13/11/13 23:55, spir wrote:
> Hello,
>
> I have an error "cannot assign to immutable field". However, it is 
> mutable as I understand according to "inherited mutability" rule 
> exposed in the tutorial (section 'Structs'). The field in question is 
> in a struct itself item of an array, itself field in a super-structure 
> (lol!) which is self. All this happens in a method called on "&mut 
> self". (And the compiler lets me change self elsewhere in the same 
> method.)
> Thus, what is wrong? Or is it so that the mutability cascade is broken 
> due to the array? How then restore it and be able to change a struct 
> item's field? I guess arrays are mutable by default aren't they? (Or 
> else, here it should due to inherited mutability, since it is a field 
> of a mutable struct.)
> What do I miss?

You need to use the .mut_iter() method, [T].iter() yields &T references, 
while the former yields &mut T references (and can only be used on 
vectors that have mutable contents, like ~[T] in a mutable slot, or &mut 
[T] or @mut [T]).

http://static.rust-lang.org/doc/master/std/vec/trait.MutableVector.html#tymethod.mut_iter

(Unfortunately the docs are not good with respect to built-in types. 
Methods can only be implemented on built-ins via traits, and the 
indication that the built-ins implement a trait is only shown on the 
page for the trait itself.)

> [Code below untested yet due to error.]
>
>     fn expand (&mut self) {
>         // A mod table expands by doubling its list bucket capacity.
>         // Double array of lists, initially filled with NO_CELL values.
>         let NO_CELL : uint = -1 as uint;    // flag for end-of-list
>         self.n_lists *= 2;
>         self.lists = vec::from_elem(self.n_lists, NO_CELL);
>
>         // replace cells into correct lists according to new key modulo.
>         let mut i_list : uint;
>         let mut i_cell : uint = 0;
>         for cell in self.cells.iter() {
>             // Link cell at start of correct list.
>             i_list = cell.key % self.n_lists;
>             cell.i_next = self.lists[i_list];           // ERROR ***
>             self.lists[i_list] = i_cell;
>             i_cell += 1;
>         }
>     }
>
> I take the opportunity to ask whether there's an (i, item) iterator 
> for arrays.

You can use the .enumerate() method on iterators, so

     for (i, cell) in self.mut_iter().enumerate() {
         ...
     }

http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html#method.enumerate


(Also, you will possibly meet with mutable borrow complaints (I'm not 
100% sure of this), which you can address by destructuring self, so that 
the compiler knows all the borrows are disjoint:

     let StructName { lists: ref mut lists, cells: ref mut cells, 
n_lists: ref mut n_lists } = *self;

and then use `lists`, `cells` and `n_lists` (they are just &mut 
references pointing to the corresponding fields of self).)

Huon


From redbrain at gcc.gnu.org  Wed Nov 13 07:53:06 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Wed, 13 Nov 2013 15:53:06 +0000
Subject: [rust-dev] typing in rust
Message-ID: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>

Hey all

I am still learning but i just tried something which i expected to give an
error but works:

fn test () -> int {
  1
}

fn main () {
  let test = test ();
  println (format! ("{}", test));
}

I guess on compilation the names are mangled against their types or
something so you can differentiate between test the function and test the
variable. Not sure would be nice to get some clarification what this
behavior is.

Thanks

--Phil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/ba1768a0/attachment.html>

From bytbox at gmail.com  Wed Nov 13 07:54:20 2013
From: bytbox at gmail.com (Scott Lawrence)
Date: Wed, 13 Nov 2013 10:54:20 -0500 (EST)
Subject: [rust-dev] typing in rust
In-Reply-To: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
Message-ID: <alpine.LNX.2.03.1311131053240.861@localhost.localdomain>

I would think that `test()` (the function) is in scope for the duration of 
`let test =`, and then the new definition masks the old one. Similarly,

let x = 2;
let x = x + 2;

If you change the last line to /call/ test(), you should get an error.

On Wed, 13 Nov 2013, Philip Herron wrote:

> Hey all
>
> I am still learning but i just tried something which i expected to give an
> error but works:
>
> fn test () -> int {
>  1
> }
>
> fn main () {
>  let test = test ();
>  println (format! ("{}", test));
> }
>
> I guess on compilation the names are mangled against their types or
> something so you can differentiate between test the function and test the
> variable. Not sure would be nice to get some clarification what this
> behavior is.
>
> Thanks
>
> --Phil
>

-- 
Scott Lawrence

From redbrain at gcc.gnu.org  Wed Nov 13 08:03:46 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Wed, 13 Nov 2013 16:03:46 +0000
Subject: [rust-dev] typing in rust
In-Reply-To: <alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
Message-ID: <CAEvRberb6HS9a_5NSQqHsb0PTX5AXtS+hjSwGHeyyCJ-wrCTMA@mail.gmail.com>

Hey

Ahh that makes sense!

Thanks


On 13 November 2013 15:54, Scott Lawrence <bytbox at gmail.com> wrote:

> I would think that `test()` (the function) is in scope for the duration of
> `let test =`, and then the new definition masks the old one. Similarly,
>
> let x = 2;
> let x = x + 2;
>
> If you change the last line to /call/ test(), you should get an error.
>
>
> On Wed, 13 Nov 2013, Philip Herron wrote:
>
>  Hey all
>>
>> I am still learning but i just tried something which i expected to give an
>> error but works:
>>
>> fn test () -> int {
>>  1
>> }
>>
>> fn main () {
>>  let test = test ();
>>  println (format! ("{}", test));
>> }
>>
>> I guess on compilation the names are mangled against their types or
>> something so you can differentiate between test the function and test the
>> variable. Not sure would be nice to get some clarification what this
>> behavior is.
>>
>> Thanks
>>
>> --Phil
>>
>>
> --
> Scott Lawrence
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/487f960a/attachment.html>

From niko at alum.mit.edu  Wed Nov 13 08:06:11 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 13 Nov 2013 11:06:11 -0500
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
References: <52821E14.5010509@gmail.com>
	<CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
Message-ID: <20131113160611.GB17283@Mr-Bennet>

On Tue, Nov 12, 2013 at 02:51:53PM +0200, Oren Ben-Kiki wrote:
> First, if the array holds values (as opposed to pointers to values), then
> pretty much your only option is to replace your pointers with indices to
> the array. You'd need access to the container to access the values, of
> course. But this is the only safe way because adding into the array may
> relocate it, invalidating all pointers.

Using newtype'd indices is my personal preference at the moment. I
find it works out quite elegantly in practice for self-contained data
structures.

> I wish there was a way to say "this borrowed pointer lives only as
> long as its container". That doesn't seem to be in the cards though
> :-(

I wouldn't go that far. I do hope for us to solve this elegantly in
the future. But it's true that there is enough on our plate and I don't
want to think it right now. But we basically covered this in prior
threads, iirc. [1, 2]

The idea of a lifetime that means "as long as the struct it is
attached to" is a solid one, but I don't think we can do that AND
permit the struct to be moved without something like the `Message` [1]
type I sketched out. Otherwise I don't know how we could guarantee
that there are no outstanding borrowed pointers at the time of move --
well, I take that back: we could possibly permit `return` statements
that exit the struct's current scope, but that's it.


Niko

[1] https://mail.mozilla.org/pipermail/rust-dev/2013-November/006304.html
[2] https://mail.mozilla.org/pipermail/rust-dev/2013-October/006172.html
    For some reason, I can't find a link in the archives to the message that
    I sent, only Oren's reply, but you can see it quoted below.

From niko at alum.mit.edu  Wed Nov 13 08:08:49 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 13 Nov 2013 11:08:49 -0500
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <52822965.7090004@mozilla.com>
References: <52821E14.5010509@gmail.com>
	<CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
	<52822965.7090004@mozilla.com>
Message-ID: <20131113160849.GC17283@Mr-Bennet>

> I don't know how to make that sound, unfortunately, other than using
> an arena and allocating all the nodes into it (losing the ability to
> deallocate individual nodes).

Arenas don't require that you lose the ability to deallocate
individual nodes. See my thoughts in #10444. Briefly, the idea is that
the arena allocation returns an affine type like `ArenaAlloc<'self>`.
You can then have a free method that consumes this instance and adds
it to a free list to be reused for future allocation.




Niko

From oren at ben-kiki.org  Wed Nov 13 08:10:53 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 18:10:53 +0200
Subject: [rust-dev] linking to cells inside a data structure
In-Reply-To: <20131113160849.GC17283@Mr-Bennet>
References: <52821E14.5010509@gmail.com>
	<CADJiDhvUFgjCZp2qTPa20t5vJ7JhCC0uAJ8-ZeojcpRC+9pekQ@mail.gmail.com>
	<52822965.7090004@mozilla.com> <20131113160849.GC17283@Mr-Bennet>
Message-ID: <CADJiDhugv8ApP2AZCA9aQ7hD6ZjRUxiH=DmSQ5SoEqBFPiK7jw@mail.gmail.com>

You are right that the compiler needs to ensure no pointers escape the
struct itself, so it is OK to move it (and all the pointers it includes).
Intuitively this would require another level of static type checking
(whether there are existing outside-the-struct borrowed pointers at any
point), probably not easy to do.


On Wed, Nov 13, 2013 at 6:08 PM, Niko Matsakis <niko at alum.mit.edu> wrote:

> > I don't know how to make that sound, unfortunately, other than using
> > an arena and allocating all the nodes into it (losing the ability to
> > deallocate individual nodes).
>
> Arenas don't require that you lose the ability to deallocate
> individual nodes. See my thoughts in #10444. Briefly, the idea is that
> the arena allocation returns an affine type like `ArenaAlloc<'self>`.
> You can then have a free method that consumes this instance and adds
> it to a free list to be reused for future allocation.
>
>
>
>
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/ceb13d07/attachment.html>

From bytemr at gmail.com  Wed Nov 13 08:25:31 2013
From: bytemr at gmail.com (Joshua Rodgers)
Date: Wed, 13 Nov 2013 09:25:31 -0700
Subject: [rust-dev] typing in rust
In-Reply-To: <alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
Message-ID: <CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>

I'm curious as to why this is valid, though?  This makes sense if you're
inside a new or nested scope, but why is it valid inside the same scope as
illustrated in the code example?

I can understand it from the perspective that I need to mask a function
name (but that's a nested scope to me, at that point).


On Wed, Nov 13, 2013 at 8:54 AM, Scott Lawrence <bytbox at gmail.com> wrote:

> I would think that `test()` (the function) is in scope for the duration of
> `let test =`, and then the new definition masks the old one. Similarly,
>
> let x = 2;
> let x = x + 2;
>
> If you change the last line to /call/ test(), you should get an error.
>
>
> On Wed, 13 Nov 2013, Philip Herron wrote:
>
>  Hey all
>>
>> I am still learning but i just tried something which i expected to give an
>> error but works:
>>
>> fn test () -> int {
>>  1
>> }
>>
>> fn main () {
>>  let test = test ();
>>  println (format! ("{}", test));
>> }
>>
>> I guess on compilation the names are mangled against their types or
>> something so you can differentiate between test the function and test the
>> variable. Not sure would be nice to get some clarification what this
>> behavior is.
>>
>> Thanks
>>
>> --Phil
>>
>>
> --
> Scott Lawrence
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/31487d47/attachment.html>

From rusty.gates at icloud.com  Wed Nov 13 08:28:50 2013
From: rusty.gates at icloud.com (Tommi)
Date: Wed, 13 Nov 2013 18:28:50 +0200
Subject: [rust-dev] UFCS / Pseudo-members
Message-ID: <9070A8BB-B007-4FBE-9F99-AFEEA38A1A09@icloud.com>

There's been talk about Uniform Function (Call) Syntax (sometimes called pseudo-members, which I think is a more informative term) and I just wanted chime in too.

There are two completely different goals UFCS tries to help to achieve:
1) Better encapsulation
http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197

2) The dream of highly reusable code (through "component programming")
http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321

Although, I think this video explains "component programming" better and it's a pretty entertaining talk too:
http://www.youtube.com/watch?v=0cX1f41Fnkc

-Tommi

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/c2e242dd/attachment.html>

From niko at alum.mit.edu  Wed Nov 13 08:30:00 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 13 Nov 2013 11:30:00 -0500
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
Message-ID: <20131113163000.GD17283@Mr-Bennet>

The interplay between exceptions and foreign code is a complicated
topic. Here are some miscellaneous thoughts.

1. I don't believe there is any memory safety reason we could not
   support catchable exceptions in Rust. The main concern is
   more one of good design; it's difficult to recover meaningfully
   and correctly from an exception. Generally the best thing to do,
   particularly in an interactive application, is to catch the
   exception up at a high level (an event loop, say) and try to
   throw away all the affected state and start over. Tasks provide
   a wonderful abstraction for doing this, of course.

2. Now, that said, some exceptions are expected and should be caught.
   File not found and so forth. Java recognized this distinction and
   called those checked exceptions; for various reasons, this is a
   pain in the neck to work with. But erasing the distinction, as many
   other languages chose to do, has its downsides. Currently the Rust
   path seems to be the same as Haskell -- use the return type,
   specifically `Result<>` or something similar, to indicate common
   error conditions. If you think about it, this is very analogous to
   what Java does, but because we are using types, we support
   parameteric error handling -- that is, you can have generic
   wrappers that return a `Result` iff the thing they are wrapping
   returns a `Result` (which Java can't do).

3. Presuming we want to keep the above philosophy (which I personally
   like, I find exception handlers to be awkward at the best of
   times), there is still the question of what to do when a C library
   fails. The C library will (typically) indicate this by returning
   an error code in some fashion. Ideally, the Rust task would observe
   this error code and then fail in response. OK, so far so good.

     (If the callee does not signal errors by returning a result code,
      then Rust probably won't be able to respond to it. We can't
      generate cleanup code for every possible exception scheme. So I
      think the best thing here would be for the author to insert a
      shim that intercepts exceptions and translates them to a return
      code.)

4. Problems start to occur though when you have interleaved C and Rust
   code, such as Rust1 -> C -> Rust2. Now what happens if the Rust task
   fails? A well-designed C callback API will include a way for the
   Rust task to indicate failure, probably a return code. So, in an
   ideal world, the Rust code would return this error code when
   failing.  Of course, we can't know in advance what error code would
   be needed, so that implies that Rust2 must have some way
   to catch the failure and translate it into the C error code.
   Hopefully this will cause the C code to unwind and return an error
   to Rust1, which can then fail! again. This process can be repeated
   as needed.

5. But what do we do if some C library doens't include error return
   codes, or doesn't (necessarily) unwind in response to an error?
   This is a hard question and I think there is no single right
   answer, instead the person wrapping the library will have to find
   the right answer for their particular case. For example, Rust1 and
   Rust2 could communicate using TLS, so that an exception occurring
   in Rust2 can (eventually) be re-raised in Rust1, even if the C code
   doesn't consider the possibility of failure. Or maybe the author
   just doesn't really care if Rust2 fails and they just swallow the
   failure, violating Rust's failure semantics (because they know
   better than us for their particular case anyhow).

6. Some would argue that based on that last point, we might as well
   just permit catch anywhere, and discourage its use. I am
   sympathetic to this as well though I think Rust's general approach
   to error handling (which we stole from Erlang) is really the
   more robust one: when things go wrong, tear it all up, then build
   it back up again. Still, perhaps community norms are enough here.



Niko



On Tue, Nov 12, 2013 at 11:07:50AM -0800, Kevin Ballard wrote:
> Right now, Rust does not support catching task failure from within a task, it only supports preventing task failure from cascading into other tasks. My understanding is that this limitation is done because of safety; if a task unwinds through a few frames of code, and then stops unwinding, data structure invariants may have been broken by the unwinding, leaving the task in an unsafe state. Is this correct?
> 
> Given this assumption, my worry now is about task unwinding outside of the control of Rust. Namely, if I?m using Rust to write a library with extern ?C? functions, or I?m providing callbacks to C code from within Rust, (and my Rust code calls back into C at some point), then it?s very possible for the called C code to throw an exception that is then caught in the calling C code a few frames up. The net effect is that the thread will unwind through my Rust code, but it will then be caught before unwinding any further, potentially leaving any data structures in an invalid state (assuming that there?s still Rust code higher up on this same stack that cares).
> 
> Has this been considered before? Is this actually a danger or am I just being paranoid?
> 
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From denis.spir at gmail.com  Wed Nov 13 08:35:52 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 13 Nov 2013 17:35:52 +0100
Subject: [rust-dev] mutability cascade
In-Reply-To: <52837956.3080409@gmail.com>
References: <528376DC.1060901@gmail.com> <52837956.3080409@gmail.com>
Message-ID: <5283AA68.8080800@gmail.com>

On 11/13/2013 02:06 PM, Huon Wilson wrote:
> On 13/11/13 23:55, spir wrote:
>> Hello,
>>
>> I have an error "cannot assign to immutable field". [...]
>
> You need to use the .mut_iter() method, [T].iter() yields &T references, while
> the former yields &mut T references (and can only be used on vectors that have
> mutable contents, like ~[T] in a mutable slot, or &mut [T] or @mut [T]).
>
> http://static.rust-lang.org/doc/master/std/vec/trait.MutableVector.html#tymethod.mut_iter

Right, that's it, i guess.
PS: tested: works fine!

> (Unfortunately the docs are not good with respect to built-in types. Methods can
> only be implemented on built-ins via traits, and the indication that the
> built-ins implement a trait is only shown on the page for the trait itself.)

Actually, the vec module's doc tells which traits are implemented 
[http://static.rust-lang.org/doc/0.8/std/vec/index.html]. However, it's just too 
much at once for newcomers, in my opinion. There may be a subset of simple, base 
functionality for vectors (but as someone said, the vec module needs 
reorganisation).

>> I take the opportunity to ask whether there's an (i, item) iterator for arrays.
>
> You can use the .enumerate() method on iterators, so
>
>      for (i, cell) in self.mut_iter().enumerate() {
>          ...
>      }
>
> http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html#method.enumerate

Right what I needed!
PS: tested: works fine!

> (Also, you will possibly meet with mutable borrow complaints (I'm not 100% sure
> of this), which you can address by destructuring self, so that the compiler
> knows all the borrows are disjoint:
>
>      let StructName { lists: ref mut lists, cells: ref mut cells, n_lists: ref
> mut n_lists } = *self;
>
> and then use `lists`, `cells` and `n_lists` (they are just &mut references
> pointing to the corresponding fields of self).)
>
> Huon

Haven't met this issue yet, but I keep the pattern under the pillow for later usage.

Thank you very much, Huon, for all this clear information.

Denis

From ben.striegel at gmail.com  Wed Nov 13 08:50:08 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 13 Nov 2013 11:50:08 -0500
Subject: [rust-dev] typing in rust
In-Reply-To: <CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
	<CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
Message-ID: <CAAvrL-mDLUki44twR0vysTMhiLFTE=Lf7qaUVbhvK65m3+T6Pg@mail.gmail.com>

> but why is it valid inside the same scope as illustrated in the code
example?

One use is to allow you to alter the mutability of variables as needed
(often referred to as "freezing" and "thawing"):

    let x = 2;  // this is immutable
    ...  // do stuff that requires x to be immutable
    let mut x = x;  // make x mutable
    ... // do stuff that requires x to be mutable
    let x = x;  // make x immutable again

And yes, the fact that that last line isn't a no-op is definitely something
to watch out for. :)


On Wed, Nov 13, 2013 at 11:25 AM, Joshua Rodgers <bytemr at gmail.com> wrote:

> I'm curious as to why this is valid, though?  This makes sense if you're
> inside a new or nested scope, but why is it valid inside the same scope as
> illustrated in the code example?
>
> I can understand it from the perspective that I need to mask a function
> name (but that's a nested scope to me, at that point).
>
>
> On Wed, Nov 13, 2013 at 8:54 AM, Scott Lawrence <bytbox at gmail.com> wrote:
>
>> I would think that `test()` (the function) is in scope for the duration
>> of `let test =`, and then the new definition masks the old one. Similarly,
>>
>> let x = 2;
>> let x = x + 2;
>>
>> If you change the last line to /call/ test(), you should get an error.
>>
>>
>> On Wed, 13 Nov 2013, Philip Herron wrote:
>>
>>  Hey all
>>>
>>> I am still learning but i just tried something which i expected to give
>>> an
>>> error but works:
>>>
>>> fn test () -> int {
>>>  1
>>> }
>>>
>>> fn main () {
>>>  let test = test ();
>>>  println (format! ("{}", test));
>>> }
>>>
>>> I guess on compilation the names are mangled against their types or
>>> something so you can differentiate between test the function and test the
>>> variable. Not sure would be nice to get some clarification what this
>>> behavior is.
>>>
>>> Thanks
>>>
>>> --Phil
>>>
>>>
>> --
>> Scott Lawrence
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/b3ae3f6d/attachment.html>

From vadimcn at gmail.com  Wed Nov 13 09:06:14 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 09:06:14 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CANbMr6HdBkmnkA-HJGoKxZ=bwg5AXYgQUkhpq=qb535j_CL55w@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
	<CANbMr6HdBkmnkA-HJGoKxZ=bwg5AXYgQUkhpq=qb535j_CL55w@mail.gmail.com>
Message-ID: <CADecdi+jAvzG=YZRP=1JJdY0oftJT=d7kWGJeroqQMtBwSWGOA@mail.gmail.com>

They don't share state.   The language-level semantics of greenlets is the
same as that of tasks, except that they are scheduled cooperatively.    All
these games with the stack should be unobservable on Rust level.


On Wed, Nov 13, 2013 at 1:01 AM, Eric Reed <ecreed at cs.washington.edu> wrote:

> The big issue I see right away (assuming I read this correctly and
> greenlets can still access the stack that existed when they were created),
> is that now mutable state on the stack is *shared* between greenlets and
> therefore can experience *data races* (impossible for tasks b/c they
> don't share memory), so they sound wildly unsafe to me.
>
> There may be some other issues that arise from the shared stack prefix
> property:
> - If a greenlet moves something on the stack, then other greenlets now
> have access to invalidated memory
> - You can no longer assume that you have sole access things pointed to by
> unique pointers, which would probably invalidate a lot of existing
> assumptions.
>
> Eric
>
>
> On Wed, Nov 13, 2013 at 12:02 AM, Vadim <vadimcn at gmail.com> wrote:
>
>> Hi,
>> I would like to float a proposal (or three :-), regarding "greenlets" in
>> Rust.  For those unfamiliar with greenlets, they are a tool for writing
>> concurrent code, similar to Rust's tasks, but much more light-weight in
>> terms of memory consumption (especially now that segmented stacks are no
>> more).
>>
>> I think there are some scenarios where low memory consumption per-task is
>> still important, 64-bit address spaces notwithstanding.   A typical one
>> would be a pub-sub server, which needs to maintain a massive number of
>> simple I/O workflows, where I/O channels are idle most of the time.
>>
>> So here we go (in the order of increasing craziness):
>>
>> 1. Recently I've learned how Python greenlets<http://greenlet.readthedocs.org/>are
>> implemented <http://stackoverflow.com/a/17447308>.  I believe that the
>> same approach could work in Rust:
>>
>> Basically, greenlets are spawned using the same stack as the parent
>> greenlet, just like a normal function call.  When a greenlet is suspended,
>> it copies the portion of the stack used up since its' spawning to the
>> heap.  When one is re-activated, the saved memory is copied back where it
>> came from (having first saved stack of the previous active greenlet,- if
>> they overlap).
>>
>> Since greenlets don't need to save "red zone" of the stack, the amount of
>> data per instance is precisely what is actually used.
>>
>> There are also downsides, of course:
>> - greenlets are bound to the thread that spawned them,
>> - two memcpy's are needed when switching between them.
>>
>> In the case of Python, though, there's one further optimization: since
>> Python's stack frames live on the heap, in most cases, there nothing on the
>> hardware stack that a greenlet needs saving!   As a bonus, it can now be
>> resumed at any stack position, so no saving of previous greenlet's stack is
>> needed.  The only time when a full save occurs is when there are foreign
>> stack frames on the stack.
>>
>>
>> 2. Well, can Rust do the same?   What if we came up with an attribute,
>> say, [#stackless], which causes a function to allocate it's stack frame on
>> the heap and put all local vars there?    The only things on the actual
>> hardware stack would then be the function's arguments, the return address,
>> the saved base pointer and the pointer to that heap-alllocated frame.
>> With the exception of base pointers, all these things are
>> position-independent, I believe.   And base pointer chain can be easily
>> fixed up if/when stack is moved.
>>
>> So if we had that, and the whole greenlet's stack consisted of such
>> functions, and there was a way for the "switch_to_greenlet()" function to
>> detect that, then such greenlet's stack would be relocatable and could be
>> resumed at any position in the thread's stack (or even in another thread!)
>> with minimal memory copying, just like in Python.
>>
>> Of course, the [#stackless] functions would be slower than the normal
>> ones, but in the scenario I've outlined in the beginning, it shouldn't be a
>> problem.
>>
>>
>> 3.  Unfortunately, in order for the above scheme to work, all I/O
>> methods, (which are typically where yields happen), would need to be marked
>> as [#stackless]...  This would affect the performance of "normal" code
>> using the same API, which is undesirable.
>>
>> Okay, but usually there are not *that *many things that point into the
>> stack in a typical program.  I can think of only three things: references
>> to stack-allocated buffers, base pointer chains and references to
>> caller-allocated return values.
>> - The first one can be lived without - just allocate buffers on the heap.
>> - The second one - see above.
>> - The last one is more tricky, but for the sake of argument, let's assume
>> that we restricted function signatures such that only register-allocated
>> types can be returned.
>>
>> Let's say we came up with a way to mark up functions that may yield to
>> another greenlet, and also with a way to prohibit taking address of
>> stack-allocated variables for the duration of calls to yielding functions.
>> These restrictions would be annoying, but not overly so, as long as you
>> had to obey them only in functions that are intended to be run in a
>> greenlet.
>> On the plus side, the hardware stack contents would now be relocatable.
>>
>> In this setup, everything could proceed as usual, using the hardware
>> stack, until execution came to a  blocking I/O call.   At that point, the
>> scheduler would check if running inside a greenlet, copy greenlet's stack
>> to the heap and switch off to another greenlet.  Otherwise, it would do the
>> same thing it does now, i.e. switch tasks.
>>
>>
>> So, what do you say, rustafarians?   Does any of that make any sense?
>>
>> Vadim
>>
>>
>> On Tue, Nov 5, 2013 at 9:18 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>>
>>> On 11/5/13 8:32 AM, David Piepgrass wrote:
>>>
>>>> Segmented stacks aren't the only solution though.
>>>>
>>>> If the concern is many tasks that block for a long time, I imagine a
>>>> mechanism to bundle a bunch of small, dormant stacks into a single page
>>>> so that the original pages could be released to the OS.
>>>>
>>>>
>>>>
>>>> *If stacks were additionally relocatable (which requires similar
>>>> machinery as precise moving GC, if I'm not mistaken) *
>>>
>>>
>>> This is correct. It's conceivable (although I can't make any promises)
>>> that if and when LLVM supports this, we could experiment with doing what Go
>>> does.
>>>
>>> Patrick
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/8003a0e6/attachment.html>

From me at kevincantu.org  Wed Nov 13 09:09:06 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Wed, 13 Nov 2013 09:09:06 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CADecdi+jAvzG=YZRP=1JJdY0oftJT=d7kWGJeroqQMtBwSWGOA@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
	<CANbMr6HdBkmnkA-HJGoKxZ=bwg5AXYgQUkhpq=qb535j_CL55w@mail.gmail.com>
	<CADecdi+jAvzG=YZRP=1JJdY0oftJT=d7kWGJeroqQMtBwSWGOA@mail.gmail.com>
Message-ID: <CABq6+ads7TrxsR3B0TcQS9vi8Nj8HwMArFc_MsMKJ85XaxSz4g@mail.gmail.com>

I thought tasks were a type of greenlet, or vice versa.

What's your proposal, exactly?

Kevin
On Nov 13, 2013 9:06 AM, "Vadim" <vadimcn at gmail.com> wrote:

> They don't share state.   The language-level semantics of greenlets is the
> same as that of tasks, except that they are scheduled cooperatively.    All
> these games with the stack should be unobservable on Rust level.
>
>
> On Wed, Nov 13, 2013 at 1:01 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> The big issue I see right away (assuming I read this correctly and
>> greenlets can still access the stack that existed when they were created),
>> is that now mutable state on the stack is *shared* between greenlets and
>> therefore can experience *data races* (impossible for tasks b/c they
>> don't share memory), so they sound wildly unsafe to me.
>>
>> There may be some other issues that arise from the shared stack prefix
>> property:
>> - If a greenlet moves something on the stack, then other greenlets now
>> have access to invalidated memory
>> - You can no longer assume that you have sole access things pointed to by
>> unique pointers, which would probably invalidate a lot of existing
>> assumptions.
>>
>> Eric
>>
>>
>> On Wed, Nov 13, 2013 at 12:02 AM, Vadim <vadimcn at gmail.com> wrote:
>>
>>> Hi,
>>> I would like to float a proposal (or three :-), regarding "greenlets" in
>>> Rust.  For those unfamiliar with greenlets, they are a tool for writing
>>> concurrent code, similar to Rust's tasks, but much more light-weight in
>>> terms of memory consumption (especially now that segmented stacks are no
>>> more).
>>>
>>> I think there are some scenarios where low memory consumption per-task
>>> is still important, 64-bit address spaces notwithstanding.   A typical one
>>> would be a pub-sub server, which needs to maintain a massive number of
>>> simple I/O workflows, where I/O channels are idle most of the time.
>>>
>>> So here we go (in the order of increasing craziness):
>>>
>>> 1. Recently I've learned how Python greenlets<http://greenlet.readthedocs.org/>are
>>> implemented <http://stackoverflow.com/a/17447308>.  I believe that the
>>> same approach could work in Rust:
>>>
>>> Basically, greenlets are spawned using the same stack as the parent
>>> greenlet, just like a normal function call.  When a greenlet is suspended,
>>> it copies the portion of the stack used up since its' spawning to the
>>> heap.  When one is re-activated, the saved memory is copied back where it
>>> came from (having first saved stack of the previous active greenlet,- if
>>> they overlap).
>>>
>>> Since greenlets don't need to save "red zone" of the stack, the amount
>>> of data per instance is precisely what is actually used.
>>>
>>> There are also downsides, of course:
>>> - greenlets are bound to the thread that spawned them,
>>> - two memcpy's are needed when switching between them.
>>>
>>> In the case of Python, though, there's one further optimization: since
>>> Python's stack frames live on the heap, in most cases, there nothing on the
>>> hardware stack that a greenlet needs saving!   As a bonus, it can now be
>>> resumed at any stack position, so no saving of previous greenlet's stack is
>>> needed.  The only time when a full save occurs is when there are foreign
>>> stack frames on the stack.
>>>
>>>
>>> 2. Well, can Rust do the same?   What if we came up with an attribute,
>>> say, [#stackless], which causes a function to allocate it's stack frame on
>>> the heap and put all local vars there?    The only things on the actual
>>> hardware stack would then be the function's arguments, the return address,
>>> the saved base pointer and the pointer to that heap-alllocated frame.
>>> With the exception of base pointers, all these things are
>>> position-independent, I believe.   And base pointer chain can be easily
>>> fixed up if/when stack is moved.
>>>
>>> So if we had that, and the whole greenlet's stack consisted of such
>>> functions, and there was a way for the "switch_to_greenlet()" function to
>>> detect that, then such greenlet's stack would be relocatable and could be
>>> resumed at any position in the thread's stack (or even in another thread!)
>>> with minimal memory copying, just like in Python.
>>>
>>> Of course, the [#stackless] functions would be slower than the normal
>>> ones, but in the scenario I've outlined in the beginning, it shouldn't be a
>>> problem.
>>>
>>>
>>> 3.  Unfortunately, in order for the above scheme to work, all I/O
>>> methods, (which are typically where yields happen), would need to be marked
>>> as [#stackless]...  This would affect the performance of "normal" code
>>> using the same API, which is undesirable.
>>>
>>> Okay, but usually there are not *that *many things that point into the
>>> stack in a typical program.  I can think of only three things: references
>>> to stack-allocated buffers, base pointer chains and references to
>>> caller-allocated return values.
>>> - The first one can be lived without - just allocate buffers on the heap.
>>> - The second one - see above.
>>> - The last one is more tricky, but for the sake of argument, let's
>>> assume that we restricted function signatures such that only
>>> register-allocated types can be returned.
>>>
>>> Let's say we came up with a way to mark up functions that may yield to
>>> another greenlet, and also with a way to prohibit taking address of
>>> stack-allocated variables for the duration of calls to yielding functions.
>>> These restrictions would be annoying, but not overly so, as long as you
>>> had to obey them only in functions that are intended to be run in a
>>> greenlet.
>>> On the plus side, the hardware stack contents would now be relocatable.
>>>
>>> In this setup, everything could proceed as usual, using the hardware
>>> stack, until execution came to a  blocking I/O call.   At that point, the
>>> scheduler would check if running inside a greenlet, copy greenlet's stack
>>> to the heap and switch off to another greenlet.  Otherwise, it would do the
>>> same thing it does now, i.e. switch tasks.
>>>
>>>
>>> So, what do you say, rustafarians?   Does any of that make any sense?
>>>
>>> Vadim
>>>
>>>
>>> On Tue, Nov 5, 2013 at 9:18 AM, Patrick Walton <pcwalton at mozilla.com>wrote:
>>>
>>>> On 11/5/13 8:32 AM, David Piepgrass wrote:
>>>>
>>>>> Segmented stacks aren't the only solution though.
>>>>>
>>>>> If the concern is many tasks that block for a long time, I imagine a
>>>>> mechanism to bundle a bunch of small, dormant stacks into a single page
>>>>> so that the original pages could be released to the OS.
>>>>>
>>>>>
>>>>>
>>>>> *If stacks were additionally relocatable (which requires similar
>>>>> machinery as precise moving GC, if I'm not mistaken) *
>>>>
>>>>
>>>> This is correct. It's conceivable (although I can't make any promises)
>>>> that if and when LLVM supports this, we could experiment with doing what Go
>>>> does.
>>>>
>>>> Patrick
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/681c94ce/attachment-0001.html>

From nicolas at boulay.name  Wed Nov 13 08:35:36 2013
From: nicolas at boulay.name (Nicolas Boulay)
Date: Wed, 13 Nov 2013 17:35:36 +0100
Subject: [rust-dev] about Rust and static memory allocation
Message-ID: <CAH+PdrCpgP_h-5T2edmsaTLNVqzUtsnsHhndxNKyG9cbZACeaw@mail.gmail.com>

Hello,

I?m an hardware  scientist, working for a software compagny. I had follow
some open cpu design like F-cpu, and the langage design of Lisaac. I?m an
expert in C programming, and have some skills in ocaml, perl, c++, java.

In synchrone langage (Lustre/Scade), there is no dynamic memory allocation.
This kind of langage have the data inside function (or ?block?), the
opposite way of object langage with method beside the data. It?s like
having ?static? variable in the C sens, but a different one for each call
site. There is no loops in Lustre, only high order function like map and
fold operation, that duplicate the variable for each call. Having such
feature, reduce the need a dynamic allocation and garbage collector.

I think this looks new and strange, but Lustre are used since 10 years in
real time safety critical software. This kind of (static, compile time)
memory allocation could be a great help for long running, fast and
responsive system. I know you target a 1.0 release but this could ease the
write of software without any dynamic memory allocation.

Do you think, this could be implemented in rust ?

Regards,

Nicolas Boulay
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/3a1f2653/attachment.html>

From ecreed at cs.washington.edu  Wed Nov 13 10:08:05 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Wed, 13 Nov 2013 10:08:05 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
Message-ID: <CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>

I'm not sure I follow.
My implementation doesn't use any trait pointers, so the only time there
were would be a trait pointer is if you casted to ~Trait yourself.
In that case, only the original method call would be dynamic dispatch; all
the internal calls (delegating and upcasting) are still static dispatch.
So my version doesn't pay for any dynamic dispatch over what the programmer
is already paying for.


On Wed, Nov 13, 2013 at 3:46 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> The call isn't statically dispatched when I invoke a method via a trait
> pointer. So it seems when I invoke any trait function, I pay double the
> cost of a virtual function call instead of one... I suppose it isn't _too_
> bad, but it still hurts.
>
>
>
> On Wed, Nov 13, 2013 at 12:21 PM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> I'm not clear on why LLVM wouldn't be able to inline super() calls. It's
>> static dispatch, so it knows exactly what function is being called.
>>
>>
>> On Wed, Nov 13, 2013 at 1:25 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>>> This is probably as good as we can get in the current system (I do
>>> something similar in my code today).
>>>
>>> I also think you probably need both "super" and "mut_super", so it would
>>> be two methods to implement instead of one (still pretty good). I wonder
>>> whether it is possible to write a macro that automates writing these
>>> boilerplate methods?
>>>
>>> The key weakness is that (I think) the compiler can't inline the
>>> accesses to "super" so that you end up with a chain of virtual function
>>> calls every time it is accessed, so performance would be pretty bad.
>>>
>>>
>>> On Wed, Nov 13, 2013 at 10:27 AM, Eric Reed <ecreed at cs.washington.edu>wrote:
>>>
>>>> Here's how I would do it using just existing Rust (assuming this hasn't
>>>> all changed under me in the past couple months).
>>>> NB: I haven't actually tried compiling this, but I'm pretty sure it (or
>>>> something like it) would work.
>>>>
>>>> Nice properties over this solution:
>>>> - Doesn't require language extensions (although syntax sugar wouldn't
>>>> be unwelcome)
>>>> - Doesn't require trait objects (i.e. static dispatch is possible)
>>>> - Only need to implement one method for each derived type (super) in
>>>> addition to overridden methods
>>>> - Supports multiple inheritance in two ways (and avoids the diamond
>>>> problem I think -- not a C++ expert so I may have misunderstood that)
>>>>       + no default parent and programmer must select which parent to
>>>> use before calling
>>>>       + implementer-chosen default parent and programmer can chose to
>>>> use a different parent if desired
>>>>
>>>> Neutral?:
>>>> - Doesn't enforce or care about the prefix property. Not sure if that
>>>> still matters so much w/o dynamic dispatch.
>>>>
>>>> Downsides:
>>>> - Performance of delegation depends on LLVM's ability to inline (I
>>>> think).
>>>> - Does require repeating all the methods once (for delegating default
>>>> implementations)
>>>>
>>>> // The base type
>>>> struct Base {
>>>>     data : int;
>>>> }
>>>>
>>>> // Characterize it's extensible behavior in a trait
>>>> trait Trait {
>>>>     fn method(&self);
>>>> }
>>>>
>>>> // Implement the base behavior
>>>> impl Trait for Base {
>>>>     fn method(&self) { ... }
>>>> }
>>>>
>>>> // Extension of trait that supports upcasting to existing
>>>> implementations
>>>> trait DerivingTrait<P : Trait> : Trait {
>>>>     // one extra method for accessing a parent's implementation.
>>>> ideally this would be inlined by the compiler
>>>>     fn super(&self) -> P;
>>>>     // default implementations for all the methods in Trait let us
>>>> avoid writing delegation everywhere manually
>>>>     fn method(&self) {
>>>>          self.super().method() // just delegate to parent
>>>>     }
>>>> }
>>>>
>>>> // Single inheritance
>>>> struct Single {
>>>>     parent: Base,
>>>>     moreData: int,
>>>> }
>>>>
>>>> impl DerivingTrait<Base> for Single {
>>>>     fn super(&self) -> Base { self.parent }
>>>> }
>>>>
>>>> // Overriding behavior
>>>> struct Override {
>>>>     parent: Base,
>>>>     otherData: u8,
>>>> }
>>>>
>>>> impl DerivingTrait<Base> for Override {
>>>>     fn super(&self) -> Base { self.parent }
>>>>     fn method(&self) { ... }
>>>>  }
>>>>
>>>> // Multiple inheritance
>>>> struct Multiple {
>>>>     single: Single,
>>>>     override: Override,
>>>>     evenMoreData: ~str,
>>>> }
>>>>
>>>> // must specify which parent's implementation we want (could hide
>>>> wrapping inside of as_* methods impl'd on Multiple if you like)
>>>> // if we want one of them as the default, then we can impl
>>>> DerivingTrait on Multiple directly
>>>> struct MultipleAsSingle(Multiple);
>>>> struct MultipleAsOverride(Multiple);
>>>>
>>>> impl DerivingTrait<Single> for MultipleAsSingle {
>>>>     fn super(&self) -> Single { self.single }
>>>> }
>>>>
>>>> impl DerivingTrait<Override> for MultipleAsOverride {
>>>>     fn super(&self) -> Override { self.override }
>>>> }
>>>>
>>>> fn main() {
>>>>     let base = Base { ... };
>>>>     let single = Single { ... };
>>>>     let override = Override { ... };
>>>>     let multiple = Multiple { ... };
>>>>
>>>>     base.method();
>>>>     base.super(); // compile time error
>>>>
>>>>     single.method(); // =inline delegation=> single.super().method()
>>>> =inline upcast=> single.base.method()
>>>>     override.method(); // done! no delegating
>>>>     MultipleAsSingle(multiple).method(); // =delegate=>
>>>> MAS(multiple).super().method() =upcast=> multiple.single.method()
>>>> =delegate=> multiple.single.super().method() =upcast=>
>>>> multiple.single.base.method()
>>>>     MutlipleAsOverride(multiple).method(); // =delegate=>
>>>> MAO(multiple).super().method() =upcast=> multiple.override.method()
>>>> }
>>>>
>>>> Thoughts?
>>>>
>>>> Eric
>>>>
>>>>
>>>> On Tue, Nov 12, 2013 at 10:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>>> On Nov 12, 2013, at 10:26 PM, Kevin Ballard <kevin at sb.org> wrote:
>>>>>
>>>>> > And even that restriction could be lifted if ~Trait objects could be
>>>>> represented using an array of pointers (one to each inherited struct), e.g.
>>>>> ([*A,*B,*C],*vtable) instead of just (*A,*vtable), though I suspect this is
>>>>> not worth doing.
>>>>>
>>>>> Upon further reflection, this  would need to be done anyway because of
>>>>> the ability to combine traits. If I have
>>>>>
>>>>> trait TraitA : A {}
>>>>> trait TraitB : B {}
>>>>>
>>>>> and I want to use ~TraitA+TraitB then I would need a "fat" trait.
>>>>> Although in this case the number of value pointers is equal to the number
>>>>> of combined traits, so it's a bit more sensible to allow for "fat" trait
>>>>> pointers here.
>>>>>
>>>>> -Kevin
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/a6e92be6/attachment.html>

From bjzaba at yahoo.com.au  Wed Nov 13 10:13:25 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Thu, 14 Nov 2013 05:13:25 +1100
Subject: [rust-dev] typing in rust
In-Reply-To: <CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
	<CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
Message-ID: <CE590BA7-8414-4E5F-8302-0B399901FDF7@yahoo.com.au>

SML also shares these semantics when it comes to bindings. That is, a subsequent binding to the same identifier can ?mask? those that proceed it, even if they are in the same scope and the bound values are of different types. Once a value has had its identifier masked, it can no longer be accessed.

I assume this behaviour was passed on to Ocaml, and Rust inherited it from there. Rust was originally written in Ocaml, and has drawn many influences from there. I personally find it useful from time to time.

~Brendan

On 14 Nov 2013, at 3:25 am, Joshua Rodgers <bytemr at gmail.com> wrote:

> I'm curious as to why this is valid, though?  This makes sense if you're inside a new or nested scope, but why is it valid inside the same scope as illustrated in the code example?
> 
> I can understand it from the perspective that I need to mask a function name (but that's a nested scope to me, at that point).
> 
> 
> On Wed, Nov 13, 2013 at 8:54 AM, Scott Lawrence <bytbox at gmail.com> wrote:
> I would think that `test()` (the function) is in scope for the duration of `let test =`, and then the new definition masks the old one. Similarly,
> 
> let x = 2;
> let x = x + 2;
> 
> If you change the last line to /call/ test(), you should get an error.
> 
> 
> On Wed, 13 Nov 2013, Philip Herron wrote:
> 
> Hey all
> 
> I am still learning but i just tried something which i expected to give an
> error but works:
> 
> fn test () -> int {
>  1
> }
> 
> fn main () {
>  let test = test ();
>  println (format! ("{}", test));
> }
> 
> I guess on compilation the names are mangled against their types or
> something so you can differentiate between test the function and test the
> variable. Not sure would be nice to get some clarification what this
> behavior is.
> 
> Thanks
> 
> --Phil
> 
> 
> -- 
> Scott Lawrence
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From danielmicay at gmail.com  Wed Nov 13 10:20:10 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 13:20:10 -0500
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
Message-ID: <CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>

On Wed, Nov 13, 2013 at 3:02 AM, Vadim <vadimcn at gmail.com> wrote:
> Hi,
> I would like to float a proposal (or three :-), regarding "greenlets" in
> Rust.  For those unfamiliar with greenlets, they are a tool for writing
> concurrent code, similar to Rust's tasks, but much more light-weight in
> terms of memory consumption (especially now that segmented stacks are no
> more).
>
> I think there are some scenarios where low memory consumption per-task is
> still important, 64-bit address spaces notwithstanding.   A typical one
> would be a pub-sub server, which needs to maintain a massive number of
> simple I/O workflows, where I/O channels are idle most of the time.
>
> So here we go (in the order of increasing craziness):
>
> 1. Recently I've learned how Python greenlets are implemented.  I believe
> that the same approach could work in Rust:
>
> Basically, greenlets are spawned using the same stack as the parent
> greenlet, just like a normal function call.  When a greenlet is suspended,
> it copies the portion of the stack used up since its' spawning to the heap.
> When one is re-activated, the saved memory is copied back where it came from
> (having first saved stack of the previous active greenlet,- if they
> overlap).
>
> Since greenlets don't need to save "red zone" of the stack, the amount of
> data per instance is precisely what is actually used.
>
> There are also downsides, of course:
> - greenlets are bound to the thread that spawned them,
> - two memcpy's are needed when switching between them.
>
> In the case of Python, though, there's one further optimization: since
> Python's stack frames live on the heap, in most cases, there nothing on the
> hardware stack that a greenlet needs saving!   As a bonus, it can now be
> resumed at any stack position, so no saving of previous greenlet's stack is
> needed.  The only time when a full save occurs is when there are foreign
> stack frames on the stack.
>
>
> 2. Well, can Rust do the same?   What if we came up with an attribute, say,
> [#stackless], which causes a function to allocate it's stack frame on the
> heap and put all local vars there?    The only things on the actual hardware
> stack would then be the function's arguments, the return address, the saved
> base pointer and the pointer to that heap-alllocated frame.   With the
> exception of base pointers, all these things are position-independent, I
> believe.   And base pointer chain can be easily fixed up if/when stack is
> moved.
>
> So if we had that, and the whole greenlet's stack consisted of such
> functions, and there was a way for the "switch_to_greenlet()" function to
> detect that, then such greenlet's stack would be relocatable and could be
> resumed at any position in the thread's stack (or even in another thread!)
> with minimal memory copying, just like in Python.
>
> Of course, the [#stackless] functions would be slower than the normal ones,
> but in the scenario I've outlined in the beginning, it shouldn't be a
> problem.
>
>
> 3.  Unfortunately, in order for the above scheme to work, all I/O methods,
> (which are typically where yields happen), would need to be marked as
> [#stackless]...  This would affect the performance of "normal" code using
> the same API, which is undesirable.
>
> Okay, but usually there are not that many things that point into the stack
> in a typical program.  I can think of only three things: references to
> stack-allocated buffers, base pointer chains and references to
> caller-allocated return values.
> - The first one can be lived without - just allocate buffers on the heap.
> - The second one - see above.
> - The last one is more tricky, but for the sake of argument, let's assume
> that we restricted function signatures such that only register-allocated
> types can be returned.
>
> Let's say we came up with a way to mark up functions that may yield to
> another greenlet, and also with a way to prohibit taking address of
> stack-allocated variables for the duration of calls to yielding functions.
> These restrictions would be annoying, but not overly so, as long as you had
> to obey them only in functions that are intended to be run in a greenlet.
> On the plus side, the hardware stack contents would now be relocatable.
>
> In this setup, everything could proceed as usual, using the hardware stack,
> until execution came to a  blocking I/O call.   At that point, the scheduler
> would check if running inside a greenlet, copy greenlet's stack to the heap
> and switch off to another greenlet.  Otherwise, it would do the same thing
> it does now, i.e. switch tasks.
>
>
> So, what do you say, rustafarians?   Does any of that make any sense?
>
> Vadim

Rust has no way to move a stack/value and update the pointers to it. A
fundamental property of borrowed pointers is that they're just
integers in memory at runtime without any boxing or type information.

From oren at ben-kiki.org  Wed Nov 13 10:28:17 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 20:28:17 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
Message-ID: <CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>

Hmmm. Perhaps I was too hasty. It would be interesting to look at the
generated binary code and see if it actually work this way...

On Wed, Nov 13, 2013 at 8:08 PM, Eric Reed <ecreed at cs.washington.edu> wrote:

> I'm not sure I follow.
> My implementation doesn't use any trait pointers, so the only time there
> were would be a trait pointer is if you casted to ~Trait yourself.
> In that case, only the original method call would be dynamic dispatch; all
> the internal calls (delegating and upcasting) are still static dispatch.
> So my version doesn't pay for any dynamic dispatch over what the
> programmer is already paying for.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/806a1bda/attachment.html>

From alex at crichton.co  Wed Nov 13 10:32:11 2013
From: alex at crichton.co (Alex Crichton)
Date: Wed, 13 Nov 2013 10:32:11 -0800
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
Message-ID: <CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>

The situation may not be as dire as you think. The runtime is still in a state
of flux, and don't forget that in one summer the entire runtime was rewritten in
rust and was entirely redesigned. I personally still think that M:N is a viable
model for various applications, and it seems especially unfortunate to just
remove everything because it's not tailored for all use cases.

Rust made an explicit design decision early on to pursue lightweight/green
tasks, and it was made with the understanding that there were drawbacks to the
strategy. Using libuv as a backend for driving I/O was also an explicit decision
with known drawbacks.

That being said, I do not believe that all is lost. I don't believe that the
rust standard library as-is today can support *every* use case, but it's getting
to a point where it can get pretty close. In the recent redesign of the I/O
implementation, all I/O was abstracted behind trait objects that are synchronous
in their interface. This I/O interface is all implemented in librustuv by
talking to the rust scheduler under the hood. Additionally, in pull #10457, I'm
starting to add support for a native implementation of this I/O interface. The
great boon of this strategy is that all std::io primitives have no idea if their
underlying interface is native and blocking or libuv and asynchronous. The exact
same rust code works for one as it does for the other.

I personally don't see why the same strategy shouldn't work for the task model
as well. When you link a program to the librustuv crate, then you're choosing to
have a runtime with M:N scheduling and asynchronous I/O. Perhaps, though, if you
didn't link to librustuv, you would get 1:1 scheduling with blocking I/O. You
would still have all the benefits of the standard library's communication
primitives, spawning primitives, I/O, task-local-storage etc. The only
difference is that everything would be powered by OS-level threads instead of
rust-level green tasks.

I would very much like to see a standard library which supports this
abstraction, and I believe that it is very realistically possible. Right now we
have an EventLoop interface which defines interacting with I/O that is the
abstraction between asynchronous I/O and blocking I/O. This sounds like
we need a more formalized Scheduler interface which abstracts M:N scheduling vs
1:1 scheduling.

The main goal of all of this would be to allow the same exact rust code to work
in both M:N and 1:1 environments. This ability would allow authors to specialize
their code for their task at-hand. Those writing web servers would be sure to
link to librustuv, but those writing command-line utilities would simply just
omit librustuv. Additionally, as a library author, I don't really care which
implementation you're using. I can write a mysql database driver and then you as
a consumer of my library decided whether my network calls are blocking or not.

This is a fairly new concept to me (I haven't thought much about it before), but
this sounds like it may be the right way forward to addressing your concerns
without compromising too much existing functionality. There would certainly be
plenty of work to do in this realm, and I'm not sure if this goal would block
the 1.0 milestone or not. Ideally, this would be a completely
backwards-compatible change, but there would perhaps be unintended consequences.
As always, this would need plenty of discussion to see whether this is even a
reasonable strategy to take.


On Wed, Nov 13, 2013 at 2:45 AM, Daniel Micay <danielmicay at gmail.com> wrote:
> Before getting right into the gritty details about why I think we should think
> about a path away from M:N scheduling, I'll go over the details of the
> concurrency model we currently use.
>
> Rust uses a user-mode scheduler to cooperatively schedule many tasks onto OS
> threads. Due to the lack of preemption, tasks need to manually yield control
> back to the scheduler. Performing I/O with the standard library will block the
> *task*, but yield control back to the scheduler until the I/O is completed.
>
> The scheduler manages a thread pool where the unit of work is a task rather
> than a queue of closures to be executed or data to be pass to a function. A
> task consists of a stack, register context and task-local storage much like an
> OS thread.
>
> In the world of high-performance computing, this is a proven model for
> maximizing throughput for CPU-bound tasks. By abandoning preemption, there's
> zero overhead from context switches. For socket servers with only negligible
> server-side computations the avoidance of context switching is a boon for
> scalability and predictable performance.
>
> # Lightweight?
>
> Rust's tasks are often called *lightweight* but at least on Linux the only
> optimization is the lack of preemption. Since segmented stacks have been
> dropped, the resident/virtual memory usage will be identical.
>
> # Spawning performance
>
> An OS thread can actually spawn nearly as fast as a Rust task on a system with
> one CPU. On a multi-core system, there's a high chance of the new thread being
> spawned on a different CPU resulting in a performance loss.
>
> Sample C program, if you need to see it to believe it:
>
> ```
> #include <pthread.h>
> #include <err.h>
>
> static const size_t n_thread = 100000;
>
> static void *foo(void *arg) {
>     return arg;
> }
>
> int main(void) {
>     for (size_t i = 0; i < n_thread; i++) {
>         pthread_attr_t attr;
>         if (pthread_attr_init(&attr) < 0) {
>             return 1;
>         }
>         if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) < 0) {
>             return 1;
>         }
>         pthread_t thread;
>         if (pthread_create(&thread, &attr, foo, NULL) < 0) {
>             return 1;
>         }
>     }
>     pthread_exit(NULL);
> }
> ```
>
> Sample Rust program:
>
> ```
> fn main() {
>     for _ in range(0, 100000) {
>         do spawn {
>         }
>     }
> }
> ```
>
> For both programs, I get around 0.9s consistently when pinned to a core. The
> Rust version drops to 1.1s when not pinned and the OS thread one to about 2s.
> It drops further when asked to allocate 8MiB stacks like C is doing, and will
> drop more when it has to do `mmap` and `mprotect` calls like the pthread API.
>
> # Asynchronous I/O
>
> Rust's requirements for asynchronous I/O would be filled well by direct usage
> of IOCP on Windows. However, Linux only has solid support for non-blocking
> sockets because file operations usually just retrieve a result from cache and
> do not truly have to block. This results in libuv being significantly slower
> than blocking I/O for most common cases for the sake of scalable socket
> servers.
>
> On modern systems with flash memory, including mobile, there is a *consistent*
> and relatively small worst-case latency for accessing data on the disk so
> blocking is essentially a non-issue. Memory mapped I/O is also an incredibly
> important feature for I/O performance, and there's almost no reason to use
> traditional I/O on 64-bit. However, it's a no-go with M:N scheduling because
> the page faults block the thread.
>
> # Overview
>
> Advantages:
>
> * lack of preemptive/fair scheduling, leading to higher throughput
> * very fast context switches to other tasks on the same scheduler thread
>
> Disadvantages:
>
> * lack of preemptive/fair scheduling (lower-level model)
> * poor profiler/debugger support
> * async I/O stack is much slower for the common case; for example stat is 35x
>   slower when run in a loop for an mlocate-like utility
> * true blocking code will still block a scheduler thread
> * most existing libraries use blocking I/O and OS threads
> * cannot directly use fast and easy to use linker-supported thread-local data
> * many existing libraries rely on thread-local storage, so there's a need to be
>   wary of hidden yields in Rust function calls and it's very difficult to
>   expose a safe interface to these libraries
> * every level of a CPU architecture adding registers needs explicit support
>   from Rust, and it must be selected at runtime when not targeting a specific
>   CPU (this is currently not done correctly)
>
> # User-mode scheduling
>
> Windows 7 introduced user-mode scheduling[1] to replace fibers on 64-bit.
> Google implemented the same thing for Linux (perhaps even before Windows 7 was
> released), and plans on pushing for it upstream.[2] The linked video does a
> better job of covering this than I can.
>
> User-mode scheduling provides a 1:1 threading model including full support for
> normal thread-local data and existing debuggers/profilers. It can yield to the
> scheduler on system calls and page faults. The operating system is responsible
> for details like context switching, so a large maintenance/portability burden
> is dealt with. It narrows down the above disadvantage list to just the point
> about not having preemptive/fair scheduling and doesn't introduce any new ones.
>
> I hope this is where concurrency is headed, and I hope Rust doesn't miss this
> boat by concentrating too much on libuv. I think it would allow us to simply
> drop support for pseudo-blocking I/O in the Go style and ignore asynchronous
> I/O and non-blocking sockets in the standard library. It may be useful to have
> the scheduler use them, but it wouldn't be essential.
>
> [1] http://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85).aspx
> [2] http://www.youtube.com/watch?v=KXuZi9aeGTw
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ecreed at cs.washington.edu  Wed Nov 13 10:35:45 2013
From: ecreed at cs.washington.edu (Eric Reed)
Date: Wed, 13 Nov 2013 10:35:45 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
Message-ID: <CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>

Indeed. I haven't looked at what it would generate at all. I'm just working
off my understanding of the semantics. What LLVM actually does is an
entirely different question.


On Wed, Nov 13, 2013 at 10:28 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Hmmm. Perhaps I was too hasty. It would be interesting to look at the
> generated binary code and see if it actually work this way...
>
> On Wed, Nov 13, 2013 at 8:08 PM, Eric Reed <ecreed at cs.washington.edu>wrote:
>
>> I'm not sure I follow.
>> My implementation doesn't use any trait pointers, so the only time there
>> were would be a trait pointer is if you casted to ~Trait yourself.
>> In that case, only the original method call would be dynamic dispatch;
>> all the internal calls (delegating and upcasting) are still static dispatch.
>> So my version doesn't pay for any dynamic dispatch over what the
>> programmer is already paying for.
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/ab5a7bcc/attachment-0001.html>

From erick.tryzelaar at gmail.com  Wed Nov 13 10:44:57 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Wed, 13 Nov 2013 10:44:57 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
	<CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>
Message-ID: <CALdfqQL-w7jfp_64YgTVD=ZBQDs1FtvDG-kbOLoWwKfX9ndjbg@mail.gmail.com>

This approach is not all that different different from my plan to implement
generators:

https://github.com/mozilla/rust/issues/7746

My current thinking is that a generator is really the combination between
storing the local variables in a structure instead of on the stack, and a
state machine to jump between each of the generator steps. Without thinking
too deeply into it, I suspect that the main difference between a generator
and a coroutine/greenlet is whether or not that structure is stored on the
stack or on the heap. I'm not quite sure how we'll handle passing data into
a coroutine, maybe we can reserve a slot in the environment structure for
passed in values, and the compiler can guarantee no one accesses that value
until it's been set. Unfortunately this'll requires a bunch of scary
compiler magic to get it all to work. But I don't think it's impossible.



On Wed, Nov 13, 2013 at 10:20 AM, Daniel Micay <danielmicay at gmail.com>wrote:

> On Wed, Nov 13, 2013 at 3:02 AM, Vadim <vadimcn at gmail.com> wrote:
> > Hi,
> > I would like to float a proposal (or three :-), regarding "greenlets" in
> > Rust.  For those unfamiliar with greenlets, they are a tool for writing
> > concurrent code, similar to Rust's tasks, but much more light-weight in
> > terms of memory consumption (especially now that segmented stacks are no
> > more).
> >
> > I think there are some scenarios where low memory consumption per-task is
> > still important, 64-bit address spaces notwithstanding.   A typical one
> > would be a pub-sub server, which needs to maintain a massive number of
> > simple I/O workflows, where I/O channels are idle most of the time.
> >
> > So here we go (in the order of increasing craziness):
> >
> > 1. Recently I've learned how Python greenlets are implemented.  I believe
> > that the same approach could work in Rust:
> >
> > Basically, greenlets are spawned using the same stack as the parent
> > greenlet, just like a normal function call.  When a greenlet is
> suspended,
> > it copies the portion of the stack used up since its' spawning to the
> heap.
> > When one is re-activated, the saved memory is copied back where it came
> from
> > (having first saved stack of the previous active greenlet,- if they
> > overlap).
> >
> > Since greenlets don't need to save "red zone" of the stack, the amount of
> > data per instance is precisely what is actually used.
> >
> > There are also downsides, of course:
> > - greenlets are bound to the thread that spawned them,
> > - two memcpy's are needed when switching between them.
> >
> > In the case of Python, though, there's one further optimization: since
> > Python's stack frames live on the heap, in most cases, there nothing on
> the
> > hardware stack that a greenlet needs saving!   As a bonus, it can now be
> > resumed at any stack position, so no saving of previous greenlet's stack
> is
> > needed.  The only time when a full save occurs is when there are foreign
> > stack frames on the stack.
> >
> >
> > 2. Well, can Rust do the same?   What if we came up with an attribute,
> say,
> > [#stackless], which causes a function to allocate it's stack frame on the
> > heap and put all local vars there?    The only things on the actual
> hardware
> > stack would then be the function's arguments, the return address, the
> saved
> > base pointer and the pointer to that heap-alllocated frame.   With the
> > exception of base pointers, all these things are position-independent, I
> > believe.   And base pointer chain can be easily fixed up if/when stack is
> > moved.
> >
> > So if we had that, and the whole greenlet's stack consisted of such
> > functions, and there was a way for the "switch_to_greenlet()" function to
> > detect that, then such greenlet's stack would be relocatable and could be
> > resumed at any position in the thread's stack (or even in another
> thread!)
> > with minimal memory copying, just like in Python.
> >
> > Of course, the [#stackless] functions would be slower than the normal
> ones,
> > but in the scenario I've outlined in the beginning, it shouldn't be a
> > problem.
> >
> >
> > 3.  Unfortunately, in order for the above scheme to work, all I/O
> methods,
> > (which are typically where yields happen), would need to be marked as
> > [#stackless]...  This would affect the performance of "normal" code using
> > the same API, which is undesirable.
> >
> > Okay, but usually there are not that many things that point into the
> stack
> > in a typical program.  I can think of only three things: references to
> > stack-allocated buffers, base pointer chains and references to
> > caller-allocated return values.
> > - The first one can be lived without - just allocate buffers on the heap.
> > - The second one - see above.
> > - The last one is more tricky, but for the sake of argument, let's assume
> > that we restricted function signatures such that only register-allocated
> > types can be returned.
> >
> > Let's say we came up with a way to mark up functions that may yield to
> > another greenlet, and also with a way to prohibit taking address of
> > stack-allocated variables for the duration of calls to yielding
> functions.
> > These restrictions would be annoying, but not overly so, as long as you
> had
> > to obey them only in functions that are intended to be run in a greenlet.
> > On the plus side, the hardware stack contents would now be relocatable.
> >
> > In this setup, everything could proceed as usual, using the hardware
> stack,
> > until execution came to a  blocking I/O call.   At that point, the
> scheduler
> > would check if running inside a greenlet, copy greenlet's stack to the
> heap
> > and switch off to another greenlet.  Otherwise, it would do the same
> thing
> > it does now, i.e. switch tasks.
> >
> >
> > So, what do you say, rustafarians?   Does any of that make any sense?
> >
> > Vadim
>
> Rust has no way to move a stack/value and update the pointers to it. A
> fundamental property of borrowed pointers is that they're just
> integers in memory at runtime without any boxing or type information.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/78a55f05/attachment.html>

From spam at scientician.net  Wed Nov 13 10:48:05 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Wed, 13 Nov 2013 19:48:05 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
Message-ID: <l60hgr$go4$1@ger.gmane.org>

On 2013-11-13 11:45, Daniel Micay wrote:
> Before getting right into the gritty details about why I think we should think
[--snip--]

Very interesting video about the kernel (in future) perhaps interacting
more closesly with user-space about scheduling decisions and threads,
thus reducing overhead and perhaps eliminating the *need* for M:N.

Having said that, M:N seems to work for Haskell where they recently
showed near-perfect scalability to 42 cores for a web server (beating
out nginx and apache handily, even on absolute numbers). For the life of
me I can't find the PDF/paper reference right now, but I'll try to
follow up with a proper reference. Perhaps there's some magical
properties of Haskell with make that less problematic than for Rust, but...

Anyway, of course we all *hope* that tricks like M:N won't be necessary
in the future, but how soon can we hope that the future arrives? ;)

Regards,


From bill_myers at outlook.com  Wed Nov 13 10:49:28 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 13 Nov 2013 18:49:28 +0000
Subject: [rust-dev] C# async for Rust
Message-ID: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>

I see several proposals for the future of Rust tasks, and I think one of the best approaches is being overlooked, and that is something similar to async in C# (http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx).

In C#, the "async" keyword can be applied to functions and it causes the compiler to transform a function that returns T into a function that returns a Task<T> (which is C#'s name for a future of type T) representing the potentially asynchronous computation.

Blocking is representing by using the "await" keyword on a future (typically returned by a call to another "async" function), and it causes the compiler to perform a Continuation-Passing Style transformation, and attach the continuation to the future, returning another future representing the composed computation.

I/O functions are designed to return futures, so in this system blocking causes all calling "async" functions to return, building up a chain of continuations on the heap, which is equivalent to the machine stack in a current-Rust task, but which is as small as needed, and is only used for call chains that block.

In Rust, this transformation is much more delicate, because the resulting return value futures must have a lifetime that is the smallest among all the arguments to the function, if those arguments are needed by the continuation, and the argument types must be "shareable" between parallel forks (e.g. std::rc::Rc is not shareable because RC manipulation is non-atomic).

However, it is possible to restrict the system to use non-delimited continuations instead of the delimited continuations and futures, which would avoid this problem, since futures cannot be used explicitly anymore (at the cost of making flexible parallelism impossible).

In this latter case, it would be equivalent to the current task system, except for requiring blocking functions to be marked "async"; the "await" keyword would not be required, since it would effectively become compulsory if there are no first-class futures returned for async functions.

Advantages:
- Functions and interfaces that can perform I/O or can block are clearly marked by a keyword
- Can have billions of blocked tasks (with hundreds of gigabytes of RAM) since the memory used by each blocked task is truly minimized because it's on the heap

Disadvantages:
- Requires an heap allocation for every function call to an async function (to hold the continuation data)
- Non-"async" functions cannot call "async" functions, so interfaces must be explicitly marked as async or not
- Requires to implement the transform in the compiler

Microsoft switched to this paradigm in the latest version of C# and in the Windows RT API, and it might be an appropriate choice for Rust too.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/2cedf9ed/attachment.html>

From vadimcn at gmail.com  Wed Nov 13 10:50:52 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 10:50:52 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
	<CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>
Message-ID: <CADecdiKZJky0tHtyw1+qhRvgrqkfk9uYi_hT-Un-o4EMsq4Z=g@mail.gmail.com>

I do realize that.  What I am proposing does not require updating pointers
to the moved stack, because there would be none (I believe).


On Wed, Nov 13, 2013 at 10:20 AM, Daniel Micay <danielmicay at gmail.com>wrote:

> On Wed, Nov 13, 2013 at 3:02 AM, Vadim <vadimcn at gmail.com> wrote:
> > Hi,
> > I would like to float a proposal (or three :-), regarding "greenlets" in
> > Rust.  For those unfamiliar with greenlets, they are a tool for writing
> > concurrent code, similar to Rust's tasks, but much more light-weight in
> > terms of memory consumption (especially now that segmented stacks are no
> > more).
> >
> > I think there are some scenarios where low memory consumption per-task is
> > still important, 64-bit address spaces notwithstanding.   A typical one
> > would be a pub-sub server, which needs to maintain a massive number of
> > simple I/O workflows, where I/O channels are idle most of the time.
> >
> > So here we go (in the order of increasing craziness):
> >
> > 1. Recently I've learned how Python greenlets are implemented.  I believe
> > that the same approach could work in Rust:
> >
> > Basically, greenlets are spawned using the same stack as the parent
> > greenlet, just like a normal function call.  When a greenlet is
> suspended,
> > it copies the portion of the stack used up since its' spawning to the
> heap.
> > When one is re-activated, the saved memory is copied back where it came
> from
> > (having first saved stack of the previous active greenlet,- if they
> > overlap).
> >
> > Since greenlets don't need to save "red zone" of the stack, the amount of
> > data per instance is precisely what is actually used.
> >
> > There are also downsides, of course:
> > - greenlets are bound to the thread that spawned them,
> > - two memcpy's are needed when switching between them.
> >
> > In the case of Python, though, there's one further optimization: since
> > Python's stack frames live on the heap, in most cases, there nothing on
> the
> > hardware stack that a greenlet needs saving!   As a bonus, it can now be
> > resumed at any stack position, so no saving of previous greenlet's stack
> is
> > needed.  The only time when a full save occurs is when there are foreign
> > stack frames on the stack.
> >
> >
> > 2. Well, can Rust do the same?   What if we came up with an attribute,
> say,
> > [#stackless], which causes a function to allocate it's stack frame on the
> > heap and put all local vars there?    The only things on the actual
> hardware
> > stack would then be the function's arguments, the return address, the
> saved
> > base pointer and the pointer to that heap-alllocated frame.   With the
> > exception of base pointers, all these things are position-independent, I
> > believe.   And base pointer chain can be easily fixed up if/when stack is
> > moved.
> >
> > So if we had that, and the whole greenlet's stack consisted of such
> > functions, and there was a way for the "switch_to_greenlet()" function to
> > detect that, then such greenlet's stack would be relocatable and could be
> > resumed at any position in the thread's stack (or even in another
> thread!)
> > with minimal memory copying, just like in Python.
> >
> > Of course, the [#stackless] functions would be slower than the normal
> ones,
> > but in the scenario I've outlined in the beginning, it shouldn't be a
> > problem.
> >
> >
> > 3.  Unfortunately, in order for the above scheme to work, all I/O
> methods,
> > (which are typically where yields happen), would need to be marked as
> > [#stackless]...  This would affect the performance of "normal" code using
> > the same API, which is undesirable.
> >
> > Okay, but usually there are not that many things that point into the
> stack
> > in a typical program.  I can think of only three things: references to
> > stack-allocated buffers, base pointer chains and references to
> > caller-allocated return values.
> > - The first one can be lived without - just allocate buffers on the heap.
> > - The second one - see above.
> > - The last one is more tricky, but for the sake of argument, let's assume
> > that we restricted function signatures such that only register-allocated
> > types can be returned.
> >
> > Let's say we came up with a way to mark up functions that may yield to
> > another greenlet, and also with a way to prohibit taking address of
> > stack-allocated variables for the duration of calls to yielding
> functions.
> > These restrictions would be annoying, but not overly so, as long as you
> had
> > to obey them only in functions that are intended to be run in a greenlet.
> > On the plus side, the hardware stack contents would now be relocatable.
> >
> > In this setup, everything could proceed as usual, using the hardware
> stack,
> > until execution came to a  blocking I/O call.   At that point, the
> scheduler
> > would check if running inside a greenlet, copy greenlet's stack to the
> heap
> > and switch off to another greenlet.  Otherwise, it would do the same
> thing
> > it does now, i.e. switch tasks.
> >
> >
> > So, what do you say, rustafarians?   Does any of that make any sense?
> >
> > Vadim
>
> Rust has no way to move a stack/value and update the pointers to it. A
> fundamental property of borrowed pointers is that they're just
> integers in memory at runtime without any boxing or type information.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/42789f87/attachment-0001.html>

From spam at scientician.net  Wed Nov 13 10:57:31 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Wed, 13 Nov 2013 19:57:31 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <l60hgr$go4$1@ger.gmane.org>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
Message-ID: <l60i2h$l2i$1@ger.gmane.org>

On 2013-11-13 19:48, Bardur Arantsson wrote:
> Having said that, M:N seems to work for Haskell where they recently
> showed near-perfect scalability to 42 cores for a web server (beating
> out nginx and apache handily, even on absolute numbers). For the life of
> me I can't find the PDF/paper reference right now, but I'll try to
> follow up with a proper reference.

Oh, I think this is it:

http://www.reddit.com/r/haskell/comments/1k6fsl/mio_a_highperformance_multicore_io_manager_for/



From fw at deneb.enyo.de  Wed Nov 13 11:24:56 2013
From: fw at deneb.enyo.de (Florian Weimer)
Date: Wed, 13 Nov 2013 20:24:56 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	(Daniel Micay's message of "Wed, 13 Nov 2013 05:45:19 -0500")
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
Message-ID: <871u2k85pz.fsf@mid.deneb.enyo.de>

* Daniel Micay:

> Rust's tasks are often called *lightweight* but at least on Linux the only
> optimization is the lack of preemption. Since segmented stacks have been
> dropped, the resident/virtual memory usage will be identical.

Doesn't the lack of a corresponding kernel thread save something on
the kernel side?

In the C benchmark, the thread attribute should be created outside the
loop.

From vadimcn at gmail.com  Wed Nov 13 11:29:31 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 11:29:31 -0800
Subject: [rust-dev] Greenlets in Rust (was: Abandoning segmented stacks
	in Rust)
In-Reply-To: <CALdfqQL-w7jfp_64YgTVD=ZBQDs1FtvDG-kbOLoWwKfX9ndjbg@mail.gmail.com>
References: <CADecdi+ULwLsJnSvw4m81ZhK4T8e0B+46+5R5Q6ng1veAHoeqQ@mail.gmail.com>
	<CA+DvKQLvmhas00Ov5jvKxgT8aUhkK9Y8UnNOVpx5q2VRgYcjDg@mail.gmail.com>
	<CALdfqQL-w7jfp_64YgTVD=ZBQDs1FtvDG-kbOLoWwKfX9ndjbg@mail.gmail.com>
Message-ID: <CADecdi+bF=Ph9OC2WPJeMQMr_hiskG0-PqeLjborhZytwQW5xA@mail.gmail.com>

Yes and no:

- State machine generators are not "true" coroutines in that they are
single-level only.   Yes, you can nest them, but it's rather tricky to do
that efficiently and transparently to the programmer.
- In order to use a generator, the caller has to be aware that he is
dealing with one.  Generators tend to "infect" the whole callstack.  I mean
look at C# - once you have async function at the leaf level, you need to
make its' callers async as well, at least up to the level where you spawn a
bunch of them and then can afford to block your thread.
- Async I/O using generators requires different API than blocking I/O.
With greenlets this *might *be avoidable.
- Greenlets can accommodate even foreign frames being on the stack (say, a
call into C library, which calls back into Rust), event though this is not
optimal for greenlet switching performance.

That said, generators also have their uses.  For example, greenlets would
be too heavy to implement container iterators on top of them - because of
the context switch overhead.   Perhaps Rust needs both.  I would like to
hear what others think.

PS: Incidentally, I am also brewing a proposal for how that Python-style
generators could be done in Rust, but it isn't quite ready yet...




On Wed, Nov 13, 2013 at 10:44 AM, Erick Tryzelaar <erick.tryzelaar at gmail.com
> wrote:

> This approach is not all that different different from my plan to
> implement generators:
>
> https://github.com/mozilla/rust/issues/7746
>
> My current thinking is that a generator is really the combination between
> storing the local variables in a structure instead of on the stack, and a
> state machine to jump between each of the generator steps. Without thinking
> too deeply into it, I suspect that the main difference between a generator
> and a coroutine/greenlet is whether or not that structure is stored on the
> stack or on the heap. I'm not quite sure how we'll handle passing data into
> a coroutine, maybe we can reserve a slot in the environment structure for
> passed in values, and the compiler can guarantee no one accesses that value
> until it's been set. Unfortunately this'll requires a bunch of scary
> compiler magic to get it all to work. But I don't think it's impossible.
>
>
>
> On Wed, Nov 13, 2013 at 10:20 AM, Daniel Micay <danielmicay at gmail.com>wrote:
>
>> On Wed, Nov 13, 2013 at 3:02 AM, Vadim <vadimcn at gmail.com> wrote:
>> > Hi,
>> > I would like to float a proposal (or three :-), regarding "greenlets" in
>> > Rust.  For those unfamiliar with greenlets, they are a tool for writing
>> > concurrent code, similar to Rust's tasks, but much more light-weight in
>> > terms of memory consumption (especially now that segmented stacks are no
>> > more).
>> >
>> > I think there are some scenarios where low memory consumption per-task
>> is
>> > still important, 64-bit address spaces notwithstanding.   A typical one
>> > would be a pub-sub server, which needs to maintain a massive number of
>> > simple I/O workflows, where I/O channels are idle most of the time.
>> >
>> > So here we go (in the order of increasing craziness):
>> >
>> > 1. Recently I've learned how Python greenlets are implemented.  I
>> believe
>> > that the same approach could work in Rust:
>> >
>> > Basically, greenlets are spawned using the same stack as the parent
>> > greenlet, just like a normal function call.  When a greenlet is
>> suspended,
>> > it copies the portion of the stack used up since its' spawning to the
>> heap.
>> > When one is re-activated, the saved memory is copied back where it came
>> from
>> > (having first saved stack of the previous active greenlet,- if they
>> > overlap).
>> >
>> > Since greenlets don't need to save "red zone" of the stack, the amount
>> of
>> > data per instance is precisely what is actually used.
>> >
>> > There are also downsides, of course:
>> > - greenlets are bound to the thread that spawned them,
>> > - two memcpy's are needed when switching between them.
>> >
>> > In the case of Python, though, there's one further optimization: since
>> > Python's stack frames live on the heap, in most cases, there nothing on
>> the
>> > hardware stack that a greenlet needs saving!   As a bonus, it can now be
>> > resumed at any stack position, so no saving of previous greenlet's
>> stack is
>> > needed.  The only time when a full save occurs is when there are foreign
>> > stack frames on the stack.
>> >
>> >
>> > 2. Well, can Rust do the same?   What if we came up with an attribute,
>> say,
>> > [#stackless], which causes a function to allocate it's stack frame on
>> the
>> > heap and put all local vars there?    The only things on the actual
>> hardware
>> > stack would then be the function's arguments, the return address, the
>> saved
>> > base pointer and the pointer to that heap-alllocated frame.   With the
>> > exception of base pointers, all these things are position-independent, I
>> > believe.   And base pointer chain can be easily fixed up if/when stack
>> is
>> > moved.
>> >
>> > So if we had that, and the whole greenlet's stack consisted of such
>> > functions, and there was a way for the "switch_to_greenlet()" function
>> to
>> > detect that, then such greenlet's stack would be relocatable and could
>> be
>> > resumed at any position in the thread's stack (or even in another
>> thread!)
>> > with minimal memory copying, just like in Python.
>> >
>> > Of course, the [#stackless] functions would be slower than the normal
>> ones,
>> > but in the scenario I've outlined in the beginning, it shouldn't be a
>> > problem.
>> >
>> >
>> > 3.  Unfortunately, in order for the above scheme to work, all I/O
>> methods,
>> > (which are typically where yields happen), would need to be marked as
>> > [#stackless]...  This would affect the performance of "normal" code
>> using
>> > the same API, which is undesirable.
>> >
>> > Okay, but usually there are not that many things that point into the
>> stack
>> > in a typical program.  I can think of only three things: references to
>> > stack-allocated buffers, base pointer chains and references to
>> > caller-allocated return values.
>> > - The first one can be lived without - just allocate buffers on the
>> heap.
>> > - The second one - see above.
>> > - The last one is more tricky, but for the sake of argument, let's
>> assume
>> > that we restricted function signatures such that only register-allocated
>> > types can be returned.
>> >
>> > Let's say we came up with a way to mark up functions that may yield to
>> > another greenlet, and also with a way to prohibit taking address of
>> > stack-allocated variables for the duration of calls to yielding
>> functions.
>> > These restrictions would be annoying, but not overly so, as long as you
>> had
>> > to obey them only in functions that are intended to be run in a
>> greenlet.
>> > On the plus side, the hardware stack contents would now be relocatable.
>> >
>> > In this setup, everything could proceed as usual, using the hardware
>> stack,
>> > until execution came to a  blocking I/O call.   At that point, the
>> scheduler
>> > would check if running inside a greenlet, copy greenlet's stack to the
>> heap
>> > and switch off to another greenlet.  Otherwise, it would do the same
>> thing
>> > it does now, i.e. switch tasks.
>> >
>> >
>> > So, what do you say, rustafarians?   Does any of that make any sense?
>> >
>> > Vadim
>>
>> Rust has no way to move a stack/value and update the pointers to it. A
>> fundamental property of borrowed pointers is that they're just
>> integers in memory at runtime without any boxing or type information.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/5cd82646/attachment.html>

From danielmicay at gmail.com  Wed Nov 13 11:29:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 14:29:03 -0500
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <871u2k85pz.fsf@mid.deneb.enyo.de>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<871u2k85pz.fsf@mid.deneb.enyo.de>
Message-ID: <CA+DvKQKsQipfPw4r4Ba92UNhEvVNnH+WGRbkvdgMtM9Z=NnMLg@mail.gmail.com>

On Wed, Nov 13, 2013 at 2:24 PM, Florian Weimer <fw at deneb.enyo.de> wrote:
> * Daniel Micay:
>
>> Rust's tasks are often called *lightweight* but at least on Linux the only
>> optimization is the lack of preemption. Since segmented stacks have been
>> dropped, the resident/virtual memory usage will be identical.
>
> Doesn't the lack of a corresponding kernel thread save something on
> the kernel side?
>
> In the C benchmark, the thread attribute should be created outside the
> loop.

The scheduler resources necessary for a thread are insignificant due
to the ~8K RES (4K in userland, 4K overhead) and 8M VIRT required for
the stack. Linux/FreeBSD are also fully capable of scheduling a very
large number threads.

From danielmicay at gmail.com  Wed Nov 13 11:30:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 14:30:58 -0500
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <l60hgr$go4$1@ger.gmane.org>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
Message-ID: <CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>

On Wed, Nov 13, 2013 at 1:48 PM, Bardur Arantsson <spam at scientician.net> wrote:
> On 2013-11-13 11:45, Daniel Micay wrote:
>> Before getting right into the gritty details about why I think we should think
> [--snip--]
>
> Very interesting video about the kernel (in future) perhaps interacting
> more closesly with user-space about scheduling decisions and threads,
> thus reducing overhead and perhaps eliminating the *need* for M:N.
>
> Having said that, M:N seems to work for Haskell where they recently
> showed near-perfect scalability to 42 cores for a web server (beating
> out nginx and apache handily, even on absolute numbers). For the life of
> me I can't find the PDF/paper reference right now, but I'll try to
> follow up with a proper reference. Perhaps there's some magical
> properties of Haskell with make that less problematic than for Rust, but...
>
> Anyway, of course we all *hope* that tricks like M:N won't be necessary
> in the future, but how soon can we hope that the future arrives? ;)
>
> Regards,

Haskell is a fully managed language with a precise garbage collector
and doesn't use a traditional call stack so lightweight threads are a
sunken cost. Rust tasks won't be comparably lightweight without
segmented stacks and reinventing most of the standard C library like
Go has to do. Go has precise
garbage collector and could move to relocatable contiguous stacks in
the future.

It's known that M:N scheduling is a viable way of building a socket
server. I'm only questioning whether it's worth making compromises for
every other use case to micro-optimize context switches out of socket
servers and make them scalable on platforms with poor support for the
1:1 threading model (OS X).

From danielmicay at gmail.com  Wed Nov 13 11:32:10 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 14:32:10 -0500
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
Message-ID: <CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>

On Wed, Nov 13, 2013 at 1:32 PM, Alex Crichton <alex at crichton.co> wrote:
> The situation may not be as dire as you think. The runtime is still in a state
> of flux, and don't forget that in one summer the entire runtime was rewritten in
> rust and was entirely redesigned. I personally still think that M:N is a viable
> model for various applications, and it seems especially unfortunate to just
> remove everything because it's not tailored for all use cases.
>
> Rust made an explicit design decision early on to pursue lightweight/green
> tasks, and it was made with the understanding that there were drawbacks to the
> strategy. Using libuv as a backend for driving I/O was also an explicit decision
> with known drawbacks.
>
> That being said, I do not believe that all is lost. I don't believe that the
> rust standard library as-is today can support *every* use case, but it's getting
> to a point where it can get pretty close. In the recent redesign of the I/O
> implementation, all I/O was abstracted behind trait objects that are synchronous
> in their interface. This I/O interface is all implemented in librustuv by
> talking to the rust scheduler under the hood. Additionally, in pull #10457, I'm
> starting to add support for a native implementation of this I/O interface. The
> great boon of this strategy is that all std::io primitives have no idea if their
> underlying interface is native and blocking or libuv and asynchronous. The exact
> same rust code works for one as it does for the other.
>
> I personally don't see why the same strategy shouldn't work for the task model
> as well. When you link a program to the librustuv crate, then you're choosing to
> have a runtime with M:N scheduling and asynchronous I/O. Perhaps, though, if you
> didn't link to librustuv, you would get 1:1 scheduling with blocking I/O. You
> would still have all the benefits of the standard library's communication
> primitives, spawning primitives, I/O, task-local-storage etc. The only
> difference is that everything would be powered by OS-level threads instead of
> rust-level green tasks.
>
> I would very much like to see a standard library which supports this
> abstraction, and I believe that it is very realistically possible. Right now we
> have an EventLoop interface which defines interacting with I/O that is the
> abstraction between asynchronous I/O and blocking I/O. This sounds like
> we need a more formalized Scheduler interface which abstracts M:N scheduling vs
> 1:1 scheduling.
>
> The main goal of all of this would be to allow the same exact rust code to work
> in both M:N and 1:1 environments. This ability would allow authors to specialize
> their code for their task at-hand. Those writing web servers would be sure to
> link to librustuv, but those writing command-line utilities would simply just
> omit librustuv. Additionally, as a library author, I don't really care which
> implementation you're using. I can write a mysql database driver and then you as
> a consumer of my library decided whether my network calls are blocking or not.
>
> This is a fairly new concept to me (I haven't thought much about it before), but
> this sounds like it may be the right way forward to addressing your concerns
> without compromising too much existing functionality. There would certainly be
> plenty of work to do in this realm, and I'm not sure if this goal would block
> the 1.0 milestone or not. Ideally, this would be a completely
> backwards-compatible change, but there would perhaps be unintended consequences.
> As always, this would need plenty of discussion to see whether this is even a
> reasonable strategy to take.

The same Rust code won't work with both 1:1 threading and M:N
threading though. It's nearly impossible to expose safe bindings to a
library like NSS with a heavy dependency on thread-local storage. With
task pinning, the libraries could pin the task to the thread they were
initialized on, but the interface is going to be much lower level than
C. It will need a context object with all the functions as methods for
the application to shove into task-local storage.

I don't think it's possible to build completely lossless abstractions
over the differences in TLS and I/O. A library supporting both will
have an inferior API to a library with only 1:1 threading.

There's an expectation that a language will work with a profiler like
callgrind or provide these tools itself. Go comes with an
implementation of CPU/memory profiling and analysis of M:N threading.
Where are Rust's versions of these tools?

The robust, proven solution is 1:1 threading and many operating
systems used M:N threading before dropping it due to the significant
drawbacks. The move to more expensive fair CPU scheduling didn't
happen by historical accident.

An M:N threading implementation is nothing but a performance
optimization for the HPC and socket server use cases to avoid context
switches. I'm not willing to make compromises in semantics or
performance for other use cases to support this.

I want Rust to be a viable replacement for C, C++, Java, C# and other
languages but I don't see it happening with the standard library, so
I'll just put my full effort behind developing an alternative.

From spam at scientician.net  Wed Nov 13 11:41:44 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Wed, 13 Nov 2013 20:41:44 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<l60hgr$go4$1@ger.gmane.org>
	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
Message-ID: <l60kle$o1m$1@ger.gmane.org>

On 2013-11-13 20:30, Daniel Micay wrote:
> On Wed, Nov 13, 2013 at 1:48 PM, Bardur Arantsson <spam at scientician.net> wrote:
>> On 2013-11-13 11:45, Daniel Micay wrote:
>>> Before getting right into the gritty details about why I think we should think
>> [--snip--]
>>
>> Very interesting video about the kernel (in future) perhaps interacting
>> more closesly with user-space about scheduling decisions and threads,
>> thus reducing overhead and perhaps eliminating the *need* for M:N.
>>
>> Having said that, M:N seems to work for Haskell where they recently
>> showed near-perfect scalability to 42 cores for a web server (beating
>> out nginx and apache handily, even on absolute numbers). For the life of
>> me I can't find the PDF/paper reference right now, but I'll try to
>> follow up with a proper reference. Perhaps there's some magical
>> properties of Haskell with make that less problematic than for Rust, but...
>>
>> Anyway, of course we all *hope* that tricks like M:N won't be necessary
>> in the future, but how soon can we hope that the future arrives? ;)
>>
>> Regards,
> 
> Haskell is a fully managed language with a precise garbage collector
> and doesn't use a traditional call stack so lightweight threads are a
> sunken cost. Rust tasks won't be comparably lightweight without
> segmented stacks and reinventing most of the standard C library like
> Go has to do. Go has precise
> garbage collector and could move to relocatable contiguous stacks in
> the future.
> 

I haven't been following too closely, so... I'm guessing a whole-program
CPS transform is out of the picture?

> It's known that M:N scheduling is a viable way of building a socket
> server. I'm only questioning whether it's worth making compromises for
> every other use case to micro-optimize context switches out of socket
> servers and make them scalable on platforms with poor support for the
> 1:1 threading model (OS X).

Indeed, and abolutely correct. As long as the language semantics
supports "thread-like" approach to concurrency (without shared state),
you'll be golden. I think the point in the video[2] about non-blocking
is bang on. In practice it's much more difficult to be *explicitly*
async and it should just be delegated to the language/runtime. There are
some things humans just aren't good at.

Regards,


From fw at deneb.enyo.de  Wed Nov 13 11:54:25 2013
From: fw at deneb.enyo.de (Florian Weimer)
Date: Wed, 13 Nov 2013 20:54:25 +0100
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <CA+DvKQ+UsywJcpu5vX62Q3WF4BEOjK73o_RFU88Zv3oSV4NxgQ@mail.gmail.com>
	(Daniel Micay's message of "Tue, 12 Nov 2013 14:50:06 -0500")
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
	<CAFnh-mf0Xh6iJpL1D047YiGQtwX7Uy60t01YgsC5SAbjUpdD-g@mail.gmail.com>
	<CA+DvKQ+UsywJcpu5vX62Q3WF4BEOjK73o_RFU88Zv3oSV4NxgQ@mail.gmail.com>
Message-ID: <87wqkc6pse.fsf@mid.deneb.enyo.de>

* Daniel Micay:

> It's undefined behaviour for a C++ function to throw an exception past an
> `extern "C"` boundary

I don't think this is true.  Certainly GCC supports throwing from C as
an extension (if the C side has been compiled with -fexceptions), and
requires that non-throwing functions are explicitly annotated, even if
they have C linkage.


From thadguidry at gmail.com  Wed Nov 13 11:59:49 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Wed, 13 Nov 2013 13:59:49 -0600
Subject: [rust-dev] Danger of throwing exceptions through Rust code
In-Reply-To: <20131113163000.GD17283@Mr-Bennet>
References: <CF0B67F8-880C-4FDE-BE96-1A4CA08F230A@sb.org>
	<20131113163000.GD17283@Mr-Bennet>
Message-ID: <CAChbWaNRqyCv0c7U-cVtvwU83xPC5XKM1HLE7kuRrSiKLW9O4g@mail.gmail.com>

In awe,

Niko does a fantastic job of breaking things down.  Give that guy a raise
already. ;)

And he brings the most important point of all in this discussion.
 "Sometimes authors care and sometimes they don't"

Maybe the important distinction is "how" the author wraps the library, to
bring about better failure semantics, regardless if the author needs them
or not, at least they are available to care about or not ?

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/92ad4676/attachment.html>

From info at bnoordhuis.nl  Wed Nov 13 12:08:50 2013
From: info at bnoordhuis.nl (Ben Noordhuis)
Date: Wed, 13 Nov 2013 21:08:50 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
Message-ID: <CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>

On Wed, Nov 13, 2013 at 11:45 AM, Daniel Micay <danielmicay at gmail.com> wrote:
> Rust's requirements for asynchronous I/O would be filled well by direct usage
> of IOCP on Windows. However, Linux only has solid support for non-blocking
> sockets because file operations usually just retrieve a result from cache and
> do not truly have to block. This results in libuv being significantly slower
> than blocking I/O for most common cases for the sake of scalable socket
> servers.

Libuv maintainer here.  Libuv's current approach to dealing with
blocking I/O is fairly crude: it offloads everything to a rather
unsophisticated thread pool.  There is plenty of room for improvement.

So far relatively little effort has gone into optimizing file I/O
because it's not very critical for node.js.  I've been looking for an
excuse to spend more time on it so please file issues or post
suggestions.  If you have test cases or benchmarks where libuv is
significantly lagging, please point me to them and I'll see what I can
do.

Apropos IOCP, it's no panacea.  It has the same issue that native AIO
on Linux has: it can silently turn asynchronous operations into
synchronous ones.  It's sometimes useful but it's not a general
solution for all things AIO.

> On modern systems with flash memory, including mobile, there is a *consistent*
> and relatively small worst-case latency for accessing data on the disk so
> blocking is essentially a non-issue.

I'm not sure if I can agree with that.  One of the issues with
blocking I/O is that the calling thread gets rescheduled when the
operation cannot be completed immediately.  Depending on workload and
system scheduler, it may get penalized when blocking often.

From vadimcn at gmail.com  Wed Nov 13 12:13:38 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 12:13:38 -0800
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
Message-ID: <CADecdiLP_1w1qssperZ72ewSu9C_EXMHYSOW21fmA2k+rKKNgA@mail.gmail.com>

On Wed, Nov 13, 2013 at 10:49 AM, Bill Myers <bill_myers at outlook.com> wrote:

> I see several proposals for the future of Rust tasks, and I think one of
> the best approaches is being overlooked, and that is something similar to
> async in C# (http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx
> ).
>
> In C#, the "async" keyword can be applied to functions and it causes the
> compiler to transform a function that returns T into a function that
> returns a Task<T> (which is C#'s name for a future of type T) representing
> the potentially asynchronous computation.
>
> Blocking is representing by using the "await" keyword on a future
> (typically returned by a call to another "async" function), and it causes
> the compiler to perform a Continuation-Passing Style transformation, and
> attach the continuation to the future, returning another future
> representing the composed computation.
>
> I/O functions are designed to return futures, so in this system blocking
> causes all calling "async" functions to return, building up a chain of
> continuations on the heap, which is equivalent to the machine stack in a
> current-Rust task, but which is as small as needed, and is only used for
> call chains that block.
>
> In Rust, this transformation is much more delicate, because the resulting
> return value futures must have a lifetime that is the smallest among all
> the arguments to the function, if those arguments are needed by the
> continuation, and the argument types must be "shareable" between parallel
> forks (e.g. std::rc::Rc is not shareable because RC manipulation is
> non-atomic).
>

Can you please elaborate on this point?   What arguments are you talking
about here, and why future's lifetime needs to be restricted?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/0391277c/attachment.html>

From martindemello at gmail.com  Wed Nov 13 12:37:40 2013
From: martindemello at gmail.com (Martin DeMello)
Date: Wed, 13 Nov 2013 12:37:40 -0800
Subject: [rust-dev] typing in rust
In-Reply-To: <CE590BA7-8414-4E5F-8302-0B399901FDF7@yahoo.com.au>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
	<CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
	<CE590BA7-8414-4E5F-8302-0B399901FDF7@yahoo.com.au>
Message-ID: <CAFrFfuEYG0R6Qr9M_urJSTfT3mt2ou=aN5fn+z4h9dg5M2xX7g@mail.gmail.com>

What ML does differently is having the syntax of let bindings
explicitly introduce a new scope by being terminated with 'in' - e.g.
you'd say

let test = test () in
println (format! ("{}", test));

which would make the behaviour unsurprising.

martin

On Wed, Nov 13, 2013 at 10:13 AM, Brendan Zabarauskas
<bjzaba at yahoo.com.au> wrote:
> SML also shares these semantics when it comes to bindings. That is, a subsequent binding to the same identifier can ?mask? those that proceed it, even if they are in the same scope and the bound values are of different types. Once a value has had its identifier masked, it can no longer be accessed.
>
> I assume this behaviour was passed on to Ocaml, and Rust inherited it from there. Rust was originally written in Ocaml, and has drawn many influences from there. I personally find it useful from time to time.
>
> ~Brendan
>
> On 14 Nov 2013, at 3:25 am, Joshua Rodgers <bytemr at gmail.com> wrote:
>
>> I'm curious as to why this is valid, though?  This makes sense if you're inside a new or nested scope, but why is it valid inside the same scope as illustrated in the code example?
>>
>> I can understand it from the perspective that I need to mask a function name (but that's a nested scope to me, at that point).
>>
>>
>> On Wed, Nov 13, 2013 at 8:54 AM, Scott Lawrence <bytbox at gmail.com> wrote:
>> I would think that `test()` (the function) is in scope for the duration of `let test =`, and then the new definition masks the old one. Similarly,
>>
>> let x = 2;
>> let x = x + 2;
>>
>> If you change the last line to /call/ test(), you should get an error.
>>
>>
>> On Wed, 13 Nov 2013, Philip Herron wrote:
>>
>> Hey all
>>
>> I am still learning but i just tried something which i expected to give an
>> error but works:
>>
>> fn test () -> int {
>>  1
>> }
>>
>> fn main () {
>>  let test = test ();
>>  println (format! ("{}", test));
>> }
>>
>> I guess on compilation the names are mangled against their types or
>> something so you can differentiate between test the function and test the
>> variable. Not sure would be nice to get some clarification what this
>> behavior is.
>>
>> Thanks
>>
>> --Phil
>>
>>
>> --
>> Scott Lawrence
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From igor at mir2.org  Wed Nov 13 12:41:10 2013
From: igor at mir2.org (Igor Bukanov)
Date: Wed, 13 Nov 2013 21:41:10 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <l60kle$o1m$1@ger.gmane.org>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
	<l60kle$o1m$1@ger.gmane.org>
Message-ID: <CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>

On 13 November 2013 20:41, Bardur Arantsson <spam at scientician.net> wrote:

> In practice it's much more difficult to be *explicitly*
> async and it should just be delegated to the language/runtime. There are
> some things humans just aren't good at.

I suspect Rust makes asynchronous programming significantly more
bearable. Programming in JS in that style is often painful due to the
noise of all those function() { } spread through the code and bugs
connected with accessing stuff that should only be ready later. Rust
nicely addresses that with shorter syntax for closures/macros and move
semantics.

So an experiment of writing in asynchronous style in Rust and
comparing that with C++/JS/other languages would be very useful to
judge.

From dteller at mozilla.com  Wed Nov 13 12:43:39 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Wed, 13 Nov 2013 21:43:39 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<l60hgr$go4$1@ger.gmane.org>	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>	<l60kle$o1m$1@ger.gmane.org>
	<CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>
Message-ID: <5283E47B.8030901@mozilla.com>

For what it's worth, writing async code in JS has become very bearable:
http://taskjs.org/

Cheers,
 David

On 11/13/13 9:41 PM, Igor Bukanov wrote:
> I suspect Rust makes asynchronous programming significantly more
> bearable. Programming in JS in that style is often painful due to the
> noise of all those function() { } spread through the code and bugs
> connected with accessing stuff that should only be ready later. Rust
> nicely addresses that with shorter syntax for closures/macros and move
> semantics.
> 
> So an experiment of writing in asynchronous style in Rust and
> comparing that with C++/JS/other languages would be very useful to
> judge.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 


-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From james at mansionfamily.plus.com  Wed Nov 13 12:51:01 2013
From: james at mansionfamily.plus.com (james)
Date: Wed, 13 Nov 2013 20:51:01 +0000
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
Message-ID: <5283E635.7040505@mansionfamily.plus.com>

On 13/11/2013 19:30, Daniel Micay wrote:
> It's known that M:N scheduling is a viable way of building a socket
> server. I'm only questioning whether it's worth making compromises for
> every other use case to micro-optimize context switches out of socket
> servers and make them scalable on platforms with poor support for the
> 1:1 threading model (OS X).
I take great issue with some of what you write:
  - there is an assumption that lightweight is useful primarily for 
'socket servers'
  - you say things are not problems, if they are not problems on Linux, 
for some
   unspecified version of Linux.

For the former: you seem to disregard the benefits that actor-based systems
with very lightweight tasks can have.  For the latter, well, not 
everyone uses Linux,
all the time, and I had though Rust was supposed to be portable, and by 
that I
would expect good performance to be portable as well as syntax.

I had high hopes of Rust having lightweight segmented stacks and precise 
per-task
GC and portability too.  Sort of Erlang with type safety and AOT 
compilation with a
sane model.

But now much of this seems abandoned or clearly a long way out and it is 
becoming
more like C++ with some functional bits, and  I can get that with Scala 
and F# now.

James, in sadness.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/700223ed/attachment-0001.html>

From igor at mir2.org  Wed Nov 13 12:52:58 2013
From: igor at mir2.org (Igor Bukanov)
Date: Wed, 13 Nov 2013 21:52:58 +0100
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
Message-ID: <CADd11yX98Nks3AddcfTJJxNkUP4f8wDRg8MPSh5h+WL6joOWew@mail.gmail.com>

On 13 November 2013 19:49, Bill Myers <bill_myers at outlook.com> wrote:
> Advantages:
> - Functions and interfaces that can perform I/O or can block are clearly
> marked by a keyword

This is similar to IO Monad in Haskell. Adding that to previously pure
computational code is painful, but on the other hand it does emphasis
that computational code != IO code and minimizing mixing between two
typically leads to better design overall.

From oren at ben-kiki.org  Wed Nov 13 13:22:30 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Wed, 13 Nov 2013 23:22:30 +0200
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283E635.7040505@mansionfamily.plus.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
	<5283E635.7040505@mansionfamily.plus.com>
Message-ID: <CADJiDhsUBn5uyQoV1Rto8=gZZvn4JLy8+N=eDieQ8s44Ou3iUw@mail.gmail.com>

On Wed, Nov 13, 2013 at 10:51 PM, james <james at mansionfamily.plus.com>wrote:

>  On 13/11/2013 19:30, Daniel Micay wrote:
>  I had high hopes of Rust having lightweight segmented stacks and precise
> per-task
> GC and portability too.  Sort of Erlang with type safety and AOT
> compilation with a
> sane model.
>

That's something I'd also love to see! The "Erlang with type safety and
compilation" is definitely something I was (am!) expecting from Rust.

(I think Rust could be a good basis for distributed actor-style systems,
due to the owned pointers it is clear how to send messages from one machine
to another, but that's another story...)


> But now much of this seems abandoned or clearly a long way out and it is
> becoming
> more like C++ with some functional bits, and  I can get that with Scala
> and F# now.
>

To be fair, Scala and F# are still VM languages while Rust is compiled. And
I _hope_ "not all is lost", so that Rust would still be friendly to
actor-style programs (as well as to socket-server style programs). It does
seem the focus has shifted away from this :-(

I find it more scary that Rust might be turning towards a "universal
platform for implementing your own pointers/scheduler/abstractions" rather
than an "opinionated platform providing a great set of
pointers/scheduler/abstractions". The need to allow for "any and every"
pattern combined with "extract the last 1% of performance" has IMO poisoned
C++; I was drawn to Rust as "take the good parts, bake them into the
language, and ignore the rest, even at some reasonable performance cost".

It is somewhat ironic that Rust, which at times has a much "lower level"
feel to it, provides essential higher-level features like algebraic types
and pattern matching and generics, while a "more abstract" language like Go
doesn't. As an application developer who doesn't care about the last 15% of
the performance, but cares a lot about productivity, I can't help but wish
for a happy medium between the two :-)

At any rate, language design is _hard_. Rust is actually doing pretty
well... and one can drastically evolve the runtime/scheduler over time -
even provide different versions for different needs. It is much harder to
fix the basic language abstractions, which Rust gets pretty well.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/d216445e/attachment.html>

From igor at mir2.org  Wed Nov 13 13:41:20 2013
From: igor at mir2.org (Igor Bukanov)
Date: Wed, 13 Nov 2013 22:41:20 +0100
Subject: [rust-dev] Rust compiler running on ARM?
In-Reply-To: <CAMYrfj++sMrJR225cLBKeasj0Y+evn00AauL9dHusC_q7mDRqg@mail.gmail.com>
References: <CADd11yWpFmqmefWt_kMXCo_E7YKu=Uzvt7==Q5kfTGtHX=YWmQ@mail.gmail.com>
	<CA++BO6TupD3=bbrV0c8UWbYRitnOKqCayfAAf=kHpvwLOjccCg@mail.gmail.com>
	<CAMYrfj++sMrJR225cLBKeasj0Y+evn00AauL9dHusC_q7mDRqg@mail.gmail.com>
Message-ID: <CADd11yUYHapphG0uBnP0TNEr0aDzJy640D+xenu0NnqAx3hD+w@mail.gmail.com>

It seems floating point code generation is broken for armhf as the
following trivial program hangs after printing 1 with
rust-0.9-pre-3b0d486-arm-
unknown-linux-gnueabihf.zip . Should I file a
bug about that?

enum Test {
    A(f64),
    B(f64)
}

impl Test {
    fn draw(&self) {
   println!("1");
        match *self {
             A(x) => println!("A {}", x),
            B(x) => println!("B {}", x)
        }
   println!("2");
    }
}

fn main() {
    let s = A(0.1);
    s.draw();
}


On 13 November 2013 09:49, Matthew McPherrin <mozilla at mcpherrin.ca> wrote:
> Luqman got rustc running on ARM.  Builds are maybe here:
> http://luqman.ca/rust-builds/
>
> On Mon, Oct 21, 2013 at 12:42 AM, Corey Richardson <corey at octayn.net> wrote:
>> I've yet to see or hear of a rustc running native on ARM, though it
>> shouldn't be impossible to cross-build rustc for native ARM: we can
>> already target ARM just fine.
>>
>> On Mon, Oct 21, 2013 at 2:01 AM, Igor Bukanov <igor at mir2.org> wrote:
>>> What is the current status of ARM support in Rust? In particularly I
>>> am interested in running the compiler on an ARM Chromebook.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev

From pcwalton at mozilla.com  Wed Nov 13 13:45:08 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 14 Nov 2013 06:45:08 +0900
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
	<CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>
Message-ID: <5283F2E4.8040802@mozilla.com>

On 11/14/13 4:32 AM, Daniel Micay wrote:
> The same Rust code won't work with both 1:1 threading and M:N
> threading though. It's nearly impossible to expose safe bindings to a
> library like NSS with a heavy dependency on thread-local storage. With
> task pinning, the libraries could pin the task to the thread they were
> initialized on, but the interface is going to be much lower level than
> C. It will need a context object with all the functions as methods for
> the application to shove into task-local storage.

I don't understand this. If a library uses native TLS, then I think a 
reasonable implementation strategy in an M:N scheduler is to just 
perform the task pinning, and then the implementation will be the same 
as the 1:1 scheduler since TLS will be available.

> I don't think it's possible to build completely lossless abstractions
> over the differences in TLS and I/O. A library supporting both will
> have an inferior API to a library with only 1:1 threading.

Without specifics I'm not convinced. I/O is, at its core, about these 
things:

* A `Reader` and `Writer` trait, along with a couple of supporting traits.

* Opening files, network streams, and other handles, and RAII-based 
destructors to close them.

TLS is, at its core, about these things:

* Declaring and initializing a TLS slot.

* Writing and reading data to and from that TLS slot.

These interfaces remain the same regardless of whether M:N or 1:1 is 
used. Now it may well be the case that they're so different that no 
implementations can reasonably be shared for performance reasons: you 
don't even want a runtime check to see whether we're in M:N or 1:1 
scheduling mode. But it seems to me that that is what `#[cfg]` is for: 
if we decide that 1:1 scheduling is sufficiently mature on the host OS 
we can just not even compile M:N scheduling and hardwire in 1:1, 
eliminating the runtime tax.

It may also be the case that there are some APIs that we can only 
surface in 1:1 and M:N (Built-in TLS variables come to mind for the 
former; scheduling modes come to mind for the latter.) That's fine; 
along the edges we can surface those APIs without compromising the core 
set of abstractions.

Moving from one to another may not be as simple as "flip a switch and 
recompile your app", but it should be reasonable to have an app that 
works in both with minor `#[cfg]` changes. And this is an important use 
case: consider a game that does heavy computation and wants maximum 
performance on Windows 7 and iOS, for example.

> There's an expectation that a language will work with a profiler like
> callgrind or provide these tools itself. Go comes with an
> implementation of CPU/memory profiling and analysis of M:N threading.
> Where are Rust's versions of these tools?

We haven't written them yet, but we can. But perf and Instruments work 
reasonably well with the M:N threads already. Enough to find the hot 
spots in the call graph rooted at a particular function, which is 90% of 
what you want profilers for.

> The robust, proven solution is 1:1 threading and many operating
> systems used M:N threading before dropping it due to the significant
> drawbacks. The move to more expensive fair CPU scheduling didn't
> happen by historical accident.

I find the argument that 1:1 threading is where things are going 
persuasive. But we still need to support systems that are in place 
today, as well as systems in which M:N currently performs better and may 
continue to in the future. It sounds like Windows is in good shape, but 
Linux doesn't have the user-mode scheduling patches yet, and I don't 
know what Apple's plans are for Mac OS X. Those are all important 
platforms for us, and for others.

I'm personally fine with looking into migrating away from M:N scheduling 
on some platforms, but I think it would be a shame to fracture the 
community to do it by forking the standard library. More on that below.

> An M:N threading implementation is nothing but a performance
> optimization for the HPC and socket server use cases to avoid context
> switches. I'm not willing to make compromises in semantics or
> performance for other use cases to support this.

We're developing a language for many use cases. M:N is useful for some 
cases and on some platforms, while 1:1 is useful for others. Part of 
what a general-purpose systems language should strive to do is to 
provide abstractions that allow for portability to the greatest extent 
possible.

> I want Rust to be a viable replacement for C, C++, Java, C# and other
> languages but I don't see it happening with the standard library, so
> I'll just put my full effort behind developing an alternative.

I hope you reconsider. As I said before, I think that, even if the 
implementation needs to be totally different, there is little point in 
duplicating traits like `Reader` and `Writer` and `TcpStream`. 
Divergence is just going to fragment the nascent community. One of the 
main reasons that those languages have been successful is that, in all 
of them, the core set of APIs are consistent and available everywhere. I 
don't want a situation whereby half of the Rust community will be 
writing libraries that depend on `libstd` and half will be writing 
libraries that depend on `rust-core`, when most of the libraries work 
just fine in either. For example, `lmath` is just linear algebra; it 
would be a shame if it had to choose a camp over needless API differences.

If we need to split out the Rust standard library into a core set of 
interfaces that remain the same across different implementations, then I 
think it would be much more productive to talk about doing that. I've 
reviewed rust-core and I don't really see any fundamental differences 
that prevent compatibility with the standard library--in fact, I'd 
really like to try to just merge them: pulling in the I/O as the "native 
I/O" module, eliminating redundant traits from libstd, eliminating 
conditions, taking whichever algorithms are faster, and so on. We can 
find and shake out bugs as we go.

Patrick


From dteller at mozilla.com  Wed Nov 13 13:46:33 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Wed, 13 Nov 2013 22:46:33 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>
Message-ID: <5283F339.6040201@mozilla.com>

On 11/13/13 9:08 PM, Ben Noordhuis wrote:
> Libuv maintainer here.  Libuv's current approach to dealing with
> blocking I/O is fairly crude: it offloads everything to a rather
> unsophisticated thread pool.  There is plenty of room for improvement.
> 
> So far relatively little effort has gone into optimizing file I/O
> because it's not very critical for node.js.  I've been looking for an
> excuse to spend more time on it so please file issues or post
> suggestions.  If you have test cases or benchmarks where libuv is
> significantly lagging, please point me to them and I'll see what I can
> do.

If, by any chance, I find time, I would be interested in giving a hand.
(I'm the main dev of Mozilla's OS.File)


[...]
>> On modern systems with flash memory, including mobile, there is a *consistent*
>> and relatively small worst-case latency for accessing data on the disk so
>> blocking is essentially a non-issue.

Well, for some systems, that's possible, but in the wild, that's not
realistic. Firefox Telemetry shows unpredictable worst-case latencies
that can be very long (I am talking multi-seconds worst-case, and 800 ms
rather common cases).

> I'm not sure if I can agree with that.  One of the issues with
> blocking I/O is that the calling thread gets rescheduled when the
> operation cannot be completed immediately.  Depending on workload and
> system scheduler, it may get penalized when blocking often.

Is that an issue? I tend to assume that a thread that does I/O should
expect being rescheduled often.

Cheers,
 David

-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From bill_myers at outlook.com  Wed Nov 13 14:12:54 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 13 Nov 2013 22:12:54 +0000
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CADd11yX98Nks3AddcfTJJxNkUP4f8wDRg8MPSh5h+WL6joOWew@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>,
	<CADd11yX98Nks3AddcfTJJxNkUP4f8wDRg8MPSh5h+WL6joOWew@mail.gmail.com>
Message-ID: <BAY170-W266AB52A7AEA5AB4E5C831F8F90@phx.gbl>




> This is similar to IO Monad in Haskell. Adding that to previously pure
> computational code is painful, but on the other hand it does emphasis
> that computational code != IO code and minimizing mixing between two
> typically leads to better design overall.

Yes, but you can have the compiler automatically transform normal code into the equivalent of Haskell's "do notation", which is what C# does with async.

Basically code like this:

async fn foo() -> uint {
let a: int = compute_a();
let b: int = compute_b();
let c: char = await read_char();
let r: uint = compute_r(a, b, c);
return r;
}

becomes after the compiler performs CPS transform:

// assume that we have trait Continuation<T> {fn continue<T>(~self, v: T);}
// assume that cps_read_char is provided by the runtime and tells a main loop to read a char and then schedule a new task running the passed continuation

struct foo_Continuation(~Continuation<uint>, int, int);

fn cps_foo(continuation: ~Continuation<uint>) {
let a: int = compute_a();
let b: int = compute_b();
return cps_read_char(~foo_Continuation(continuation, a, b));
}

impl Continuation<char> for foo_Continuation
{
fn continue(~self, c: char) {
let (continuation, a, b) = *self;
let r = compute_r(a, b, c);
continuation.continue(r);
}
}

and then a future-based version can also be generated by the compiler based on the CPS transform results:
// assume that Continuation<T> is implemented on TaskFuture<T> and causes the TaskFuture to be completed with the value

fn future_foo() -> ~TaskFuture<int> {
    let f = ~TaskFuture::new();
    cps_foo(f);
    return f;
}

Note that if foo() had taken a borrowed pointer with lifetime 'a, then the CPS version becomes unsafe, and TaskFuture would also need an 'a parameter.

Also, one can use a borrowed pointer instead of an owned pointer for continuations and futures, but then they need to be waited on before its lifetime region ends.


 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/ed18ff3e/attachment-0001.html>

From danielmicay at gmail.com  Wed Nov 13 14:15:09 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 17:15:09 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
Message-ID: <CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>

On Wed, Nov 13, 2013 at 1:49 PM, Bill Myers <bill_myers at outlook.com> wrote:
> I see several proposals for the future of Rust tasks, and I think one of the
> best approaches is being overlooked, and that is something similar to async
> in C# (http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx).
>
> In C#, the "async" keyword can be applied to functions and it causes the
> compiler to transform a function that returns T into a function that returns
> a Task<T> (which is C#'s name for a future of type T) representing the
> potentially asynchronous computation.
>
> Blocking is representing by using the "await" keyword on a future (typically
> returned by a call to another "async" function), and it causes the compiler
> to perform a Continuation-Passing Style transformation, and attach the
> continuation to the future, returning another future representing the
> composed computation.
>
> I/O functions are designed to return futures, so in this system blocking
> causes all calling "async" functions to return, building up a chain of
> continuations on the heap, which is equivalent to the machine stack in a
> current-Rust task, but which is as small as needed, and is only used for
> call chains that block.
>
> In Rust, this transformation is much more delicate, because the resulting
> return value futures must have a lifetime that is the smallest among all the
> arguments to the function, if those arguments are needed by the
> continuation, and the argument types must be "shareable" between parallel
> forks (e.g. std::rc::Rc is not shareable because RC manipulation is
> non-atomic).
>
> However, it is possible to restrict the system to use non-delimited
> continuations instead of the delimited continuations and futures, which
> would avoid this problem, since futures cannot be used explicitly anymore
> (at the cost of making flexible parallelism impossible).
>
> In this latter case, it would be equivalent to the current task system,
> except for requiring blocking functions to be marked "async"; the "await"
> keyword would not be required, since it would effectively become compulsory
> if there are no first-class futures returned for async functions.
>
> Advantages:
> - Functions and interfaces that can perform I/O or can block are clearly
> marked by a keyword
> - Can have billions of blocked tasks (with hundreds of gigabytes of RAM)
> since the memory used by each blocked task is truly minimized because it's
> on the heap
>
> Disadvantages:
> - Requires an heap allocation for every function call to an async function
> (to hold the continuation data)
> - Non-"async" functions cannot call "async" functions, so interfaces must be
> explicitly marked as async or not
> - Requires to implement the transform in the compiler
>
> Microsoft switched to this paradigm in the latest version of C# and in the
> Windows RT API, and it might be an appropriate choice for Rust too.

The issue with async/await is that while it maps very well to the AIO
primitives like IOCP and POSIX AIO, it doesn't map well to something
that's solid on Linux. It's just not how I/O is done on the platform.
It uses *non-blocking* I/O so scale up socket servers, with
notification of ready state rather than completion state. This doesn't
work for file system access though.

There's a significant performance hit from moving maybe-blocking I/O
calls into thread pools to fit a square peg into a round hole.

From danielmicay at gmail.com  Wed Nov 13 14:26:06 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 17:26:06 -0500
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>
Message-ID: <CA+DvKQ+DEP+TX7kVZsqfQDGCNvkeBnUddc0mrkRSncUhMM+f5w@mail.gmail.com>

On Wed, Nov 13, 2013 at 3:08 PM, Ben Noordhuis <info at bnoordhuis.nl> wrote:
> On Wed, Nov 13, 2013 at 11:45 AM, Daniel Micay <danielmicay at gmail.com> wrote:
>> Rust's requirements for asynchronous I/O would be filled well by direct usage
>> of IOCP on Windows. However, Linux only has solid support for non-blocking
>> sockets because file operations usually just retrieve a result from cache and
>> do not truly have to block. This results in libuv being significantly slower
>> than blocking I/O for most common cases for the sake of scalable socket
>> servers.
>
> Libuv maintainer here.  Libuv's current approach to dealing with
> blocking I/O is fairly crude: it offloads everything to a rather
> unsophisticated thread pool.  There is plenty of room for improvement.
>
> So far relatively little effort has gone into optimizing file I/O
> because it's not very critical for node.js.  I've been looking for an
> excuse to spend more time on it so please file issues or post
> suggestions.  If you have test cases or benchmarks where libuv is
> significantly lagging, please point me to them and I'll see what I can
> do.

I expect that regardless of how much effort will be put into libuv, it
won't be *as fast* as blocking I/O for the common small scale cases
most people care about. Rust wants to appeal to C++ programmers, and
it isn't going to do that if there's anything more than a 10-15%
performance hit (for CPU-bound or IO-bound work).

In a 64-bit world, even traditional blocking I/O looks pretty bad when
you can memory map everything on many disks many times over.

> Apropos IOCP, it's no panacea.  It has the same issue that native AIO
> on Linux has: it can silently turn asynchronous operations into
> synchronous ones.  It's sometimes useful but it's not a general
> solution for all things AIO.
>
>> On modern systems with flash memory, including mobile, there is a *consistent*
>> and relatively small worst-case latency for accessing data on the disk so
>> blocking is essentially a non-issue.
>
> I'm not sure if I can agree with that.  One of the issues with
> blocking I/O is that the calling thread gets rescheduled when the
> operation cannot be completed immediately.  Depending on workload and
> system scheduler, it may get penalized when blocking often.

Assuming Google lands their user-mode scheduling work, we would have
control over the scheduling of tasks with I/O-bound workloads. They
could be queued in a round-robin style, or weighted by whatever we
consider important (arrival time of a request, etc.).

This is already available on the 64-bit versions of Windows
7/8/Server, and I don't think we need to worry about XP/Vista as even
security updates will be cut off soon and tasks won't scale any better
than threads on 32-bit.

It would make sense to keep using libuv for cases where it's faster
than the blocking calls, but we wouldn't *have* to use it because
control would be returned to the scheduler on a blocking call or page
fault.

From bill_myers at outlook.com  Wed Nov 13 14:32:37 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 13 Nov 2013 22:32:37 +0000
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>,
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
Message-ID: <BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>

> The issue with async/await is that while it maps very well to the AIO
> primitives like IOCP and POSIX AIO, it doesn't map well to something
> that's solid on Linux. It's just not how I/O is done on the platform.
> It uses *non-blocking* I/O so scale up socket servers, with
> notification of ready state rather than completion state. This doesn't
> work for file system access though.

Well, I/O would work exactly the same as the current libuv-based Rust tasks approach, except that one needs a stack for each CPU thread and not for each task, because task creation functions return when a task wants to block, and thus there is no stack to save and restore.

On Linux, the epoll interface allows to implement this, and I think it's what libuv uses.

The only problem is that Linux doesn't really support asynchronously resolving file paths to inodes (aka opening files), but that can be done on a dedicated thread pool, with the advantage that the threads don't do anything, so they don't have zombie stacks.

The problem with blocking on all threads/the 1:1 thread model is that if you do a computation that requires 8MB of stack, and then block with a shallow call stack, the 8MB of stack are not freed, so you waste 8MB per TCP connection in a TCP server example, which means that on a system with 32GB RAM you can only service 4096 TCP connections without swapping to disk instead of millions.

A dedicated thread pool for blocking I/O doesn't have this issue 
because it can run with only 4KB stack or so since it doesn't do 
anything stack intensive, and the number of its threads can be limited 
without user-visible results.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/6154cd5f/attachment.html>

From pcwalton at mozilla.com  Wed Nov 13 14:37:22 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 14 Nov 2013 07:37:22 +0900
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283F2E4.8040802@mozilla.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>	<CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>
	<5283F2E4.8040802@mozilla.com>
Message-ID: <5283FF22.7020106@mozilla.com>

On 11/14/13 6:45 AM, Patrick Walton wrote:
> If we need to split out the Rust standard library into a core set of
> interfaces that remain the same across different implementations, then I
> think it would be much more productive to talk about doing that. I've
> reviewed rust-core and I don't really see any fundamental differences
> that prevent compatibility with the standard library--in fact, I'd
> really like to try to just merge them: pulling in the I/O as the "native
> I/O" module, eliminating redundant traits from libstd, eliminating
> conditions, taking whichever algorithms are faster, and so on. We can
> find and shake out bugs as we go.

To be more specific, here's how I propose to move forward.

1. Finish fleshing out the native I/O in libstd to achieve parity with 
the uv-based I/O.

2. Provide pthread-based implementations of `task::spawn`.

3. Provide native TLS with a matching API to the task-local storage API.

4. Figure out what to do about ports and channels and failure in 1:1 
scheduling.

At this point we will have a task story for 1:1 scheduling that mirrors 
the M:N scheduling. We will then have a solid basis to decide what the 
defaults should be on each platform. If we decide that 1:1 scheduling is 
the best fit for all platforms, we can then consider dumping the M:N 
scheduling.

At the same time, I would like to suggest that rust-core track the APIs 
of libstd and file bugs/PRs to get APIs changed if there are problems, 
to avoid fragmenting downstream libraries.

I welcome discussion on this strategy and hope that it's acceptable to 
everyone.

Patrick


From dbau.pp at gmail.com  Wed Nov 13 14:43:10 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 14 Nov 2013 09:43:10 +1100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283FF22.7020106@mozilla.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>	<CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>	<5283F2E4.8040802@mozilla.com>
	<5283FF22.7020106@mozilla.com>
Message-ID: <5284007E.4000204@gmail.com>

On 14/11/13 09:37, Patrick Walton wrote:
> On 11/14/13 6:45 AM, Patrick Walton wrote:
>> If we need to split out the Rust standard library into a core set of
>> interfaces that remain the same across different implementations, then I
>> think it would be much more productive to talk about doing that. I've
>> reviewed rust-core and I don't really see any fundamental differences
>> that prevent compatibility with the standard library--in fact, I'd
>> really like to try to just merge them: pulling in the I/O as the "native
>> I/O" module, eliminating redundant traits from libstd, eliminating
>> conditions, taking whichever algorithms are faster, and so on. We can
>> find and shake out bugs as we go.
>
> To be more specific, here's how I propose to move forward.
>
> 1. Finish fleshing out the native I/O in libstd to achieve parity with 
> the uv-based I/O.

Coincidentally, Alex opened #10457 in the last day which makes things 
like println() work with without libuv (and without the runtime!).

https://github.com/mozilla/rust/pull/10457

Examples: https://github.com/mozilla/rust/pull/10457/files#diff-10


Huon

From dteller at mozilla.com  Wed Nov 13 14:44:33 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Wed, 13 Nov 2013 23:44:33 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283FF22.7020106@mozilla.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>	<CA+DvKQJ84Xa2-Gv_gsSYjzi9GRGpYVT8ttfRDaR++zDC3V9ckw@mail.gmail.com>	<5283F2E4.8040802@mozilla.com>
	<5283FF22.7020106@mozilla.com>
Message-ID: <528400D1.10007@mozilla.com>

On 11/13/13 11:37 PM, Patrick Walton wrote:
> 1. Finish fleshing out the native I/O in libstd to achieve parity with
> the uv-based I/O.

You may be interested in taking a look at the API of OS.File. The design
is rather different to libuv, as it is meant (only) for file I/O rather
than (mostly) net I/O.

In particular, we to:
- minimize the total amount of I/O required (so as to save battery);
- take advantage of high-level primitives provided by the OS wherever
available;
- expose OS-specific features, rather than just ~Posix;
- use a single worker thread, to avoid causing disk thrashing.

Cheers,
 David

-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From bill_myers at outlook.com  Wed Nov 13 14:51:46 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 13 Nov 2013 22:51:46 +0000
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>, ,
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>,
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
Message-ID: <BAY170-W87F25CBAC0B22EDBF0DADAF8F90@phx.gbl>

Although, on second thought, one could just free the unused part of the user mode stack whenever a thread blocks, either in the user mode code (i.e. using madvise MADV_DONTNEED or equivalent to discard everything below the stack pointer modulo the page size, perhaps minus the page size) or automatically in a modified kernel, and thus greatly reduce the worst case.

It's still going to have higher overhead than the CPS continuations on the heap, because the stack will tend to have holes where dead variables live, for aligning to page boundaries, and you also keep around the kernel stack and kernel scheduler objects.

And it doesn't work on 32-bit, because you cannot have more than around 2048 tasks with megabyte-sized task stacks (which is way too low for several usages), and unfortunately there are lots of 32-bit-only smartphones and tablets that should probably be supported.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/f7cdc0bb/attachment-0001.html>

From pcwalton at mozilla.com  Wed Nov 13 14:55:13 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 14 Nov 2013 07:55:13 +0900
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283E635.7040505@mansionfamily.plus.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<l60hgr$go4$1@ger.gmane.org>	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
	<5283E635.7040505@mansionfamily.plus.com>
Message-ID: <52840351.8070802@mozilla.com>

On 11/14/13 5:51 AM, james wrote:
> I had high hopes of Rust having lightweight segmented stacks and precise
> per-task
> GC and portability too.  Sort of Erlang with type safety and AOT
> compilation with a
> sane model.

None of this has changed, except for segmented stacks. Regarding 
segmented stacks, I think they should be viewed as a means to an end 
(scalability) rather than an end in and of themselves. 64-bit hardware 
and lazy OS-level page mapping is just another means to achieve the same 
end.

Patrick


From danielmicay at gmail.com  Wed Nov 13 15:03:15 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 18:03:15 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W87F25CBAC0B22EDBF0DADAF8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<BAY170-W87F25CBAC0B22EDBF0DADAF8F90@phx.gbl>
Message-ID: <CA+DvKQ+UOeyh_tMcASWqGPgjAAW30gsEEWBSm1H4v+c5WDHL0w@mail.gmail.com>

On Wed, Nov 13, 2013 at 5:51 PM, Bill Myers <bill_myers at outlook.com> wrote:
> Although, on second thought, one could just free the unused part of the user
> mode stack whenever a thread blocks, either in the user mode code (i.e.
> using madvise MADV_DONTNEED or equivalent to discard everything below the
> stack pointer modulo the page size, perhaps minus the page size) or
> automatically in a modified kernel, and thus greatly reduce the worst case.
>
> It's still going to have higher overhead than the CPS continuations on the
> heap, because the stack will tend to have holes where dead variables live,
> for aligning to page boundaries, and you also keep around the kernel stack
> and kernel scheduler objects.
>
> And it doesn't work on 32-bit, because you cannot have more than around 2048
> tasks with megabyte-sized task stacks (which is way too low for several
> usages), and unfortunately there are lots of 32-bit-only smartphones and
> tablets that should probably be supported.
>

We don't need to worry about scaling on existing phones and tablets.
They have short lifetimes, and most of them don't even receive
security updates. The iPhone 5S is already 64-bit and Android vendors
will move too, especially since they traditionally ship a lot more
memory in even mid-level phones.

From danielmicay at gmail.com  Wed Nov 13 15:10:27 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 18:10:27 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
Message-ID: <CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>

On Wed, Nov 13, 2013 at 5:32 PM, Bill Myers <bill_myers at outlook.com> wrote:
>> The issue with async/await is that while it maps very well to the AIO
>> primitives like IOCP and POSIX AIO, it doesn't map well to something
>> that's solid on Linux. It's just not how I/O is done on the platform.
>> It uses *non-blocking* I/O so scale up socket servers, with
>> notification of ready state rather than completion state. This doesn't
>> work for file system access though.
>
> Well, I/O would work exactly the same as the current libuv-based Rust tasks
> approach, except that one needs a stack for each CPU thread and not for each
> task, because task creation functions return when a task wants to block, and
> thus there is no stack to save and restore.
>
> On Linux, the epoll interface allows to implement this, and I think it's
> what libuv uses.

The epoll interface only allows waiting for ready (not completion)
state from sockets. It does not work for file system input/output or
meta operations. As a hack, timers, signals and pluggable events have
been exposed as file descriptors with ready events but nothing for
truly doing non-blocking file I/O. The libuv implementation of
non-socket I/O uses thread pools on Linux. Note that *writes* to
sockets are still potentially blocking and a thread pool might be used
even for that.

> The only problem is that Linux doesn't really support asynchronously
> resolving file paths to inodes (aka opening files), but that can be done on
> a dedicated thread pool, with the advantage that the threads don't do
> anything, so they don't have zombie stacks.

The file metadata cache is small enough that there's no point in
considering it blocking. You might as well considering memory accesses
blocking at that extreme, because they might require fetching memory
to the CPU cache.

> The problem with blocking on all threads/the 1:1 thread model is that if you
> do a computation that requires 8MB of stack, and then block with a shallow
> call stack, the 8MB of stack are not freed, so you waste 8MB per TCP
> connection in a TCP server example, which means that on a system with 32GB
> RAM you can only service 4096 TCP connections without swapping to disk
> instead of millions.

There's no difference between M:N scheduling and 1:1 scheduling in
regards to resource usage and stacks. Every task has to have a stack.

> A dedicated thread pool for blocking I/O doesn't have this issue because it
> can run with only 4KB stack or so since it doesn't do anything stack
> intensive, and the number of its threads can be limited without user-visible
> results.

Using a thread pool for blocking I/O is a significant performance
issue. Is it okay for small operating to be 5x, 10x, 20x or 30x slower
than C in a *systems language*? Perhaps 15%, but context switches to
and from a thread pool aren't going to get you that.

It's always going to be much slower to pretend Linux I/O is
non-blocking via layers of indirection and dispatching to other
threads. The model Rust wants to use is appreciated enough that the
Linux kernel will likely support it directly via 1:1 threading like
Win7/8 already do.

From dteller at mozilla.com  Wed Nov 13 15:21:50 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Thu, 14 Nov 2013 00:21:50 +0100
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
Message-ID: <5284098E.4050302@mozilla.com>

On Thu Nov 14 00:10:27 2013, Daniel Micay wrote:
>> The only problem is that Linux doesn't really support asynchronously
>> resolving file paths to inodes (aka opening files), but that can be done on
>> a dedicated thread pool, with the advantage that the threads don't do
>> anything, so they don't have zombie stacks.
>
> The file metadata cache is small enough that there's no point in
> considering it blocking. You might as well considering memory accesses
> blocking at that extreme, because they might require fetching memory
> to the CPU cache.

Are you sure about that? If my memory serves, you still need to fetch it
from disk in most cases. On platforms in which devices have a mechanical
component, even trivial accesses can end up very expensive in case of
disk thrashing and/or sleeping disk.

Cheers,
 David

-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From vadimcn at gmail.com  Wed Nov 13 15:25:22 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 15:25:22 -0800
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQ+UOeyh_tMcASWqGPgjAAW30gsEEWBSm1H4v+c5WDHL0w@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<BAY170-W87F25CBAC0B22EDBF0DADAF8F90@phx.gbl>
	<CA+DvKQ+UOeyh_tMcASWqGPgjAAW30gsEEWBSm1H4v+c5WDHL0w@mail.gmail.com>
Message-ID: <CADecdiJd7CT5D5mZWjf9-tSoXFYqtxSdJzx34V1JCwNZvj8JXw@mail.gmail.com>

But I guarantee you that a smaller form factor devices will appear in short
order, and they won't use 64-bit CPUs, because in the beginning they won't
have anywhere close to 4GB RAM, so a 64-bit memory bus and MMU will be an
overkill for them.  And the cycle will repeat...
Even in the phones and PCs, many sub-components contain their own 32-bit
controllers, and those need to be programmed too.   And Rust is aiming for
this niche, doesn't it?

I think you are getting dangerously close to the argument that "we don't
need to optimize code, because Moore's law will take care of performance"
:-)




On Wed, Nov 13, 2013 at 3:03 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Wed, Nov 13, 2013 at 5:51 PM, Bill Myers <bill_myers at outlook.com>
> wrote:
> > Although, on second thought, one could just free the unused part of the
> user
> > mode stack whenever a thread blocks, either in the user mode code (i.e.
> > using madvise MADV_DONTNEED or equivalent to discard everything below the
> > stack pointer modulo the page size, perhaps minus the page size) or
> > automatically in a modified kernel, and thus greatly reduce the worst
> case.
> >
> > It's still going to have higher overhead than the CPS continuations on
> the
> > heap, because the stack will tend to have holes where dead variables
> live,
> > for aligning to page boundaries, and you also keep around the kernel
> stack
> > and kernel scheduler objects.
> >
> > And it doesn't work on 32-bit, because you cannot have more than around
> 2048
> > tasks with megabyte-sized task stacks (which is way too low for several
> > usages), and unfortunately there are lots of 32-bit-only smartphones and
> > tablets that should probably be supported.
> >
>
> We don't need to worry about scaling on existing phones and tablets.
> They have short lifetimes, and most of them don't even receive
> security updates. The iPhone 5S is already 64-bit and Android vendors
> will move too, especially since they traditionally ship a lot more
> memory in even mid-level phones.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/c6c90cfa/attachment.html>

From vadimcn at gmail.com  Wed Nov 13 15:29:45 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 13 Nov 2013 15:29:45 -0800
Subject: [rust-dev] C# async for Rust
In-Reply-To: <5284098E.4050302@mozilla.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
	<5284098E.4050302@mozilla.com>
Message-ID: <CADecdiK8-ss9D2-OVgikAvMkaC5_J6Cz8yidXgNsoJzkON8CLg@mail.gmail.com>

Yes, that.   And what about network file systems or removable drives, which
were just plugged in?  Can't expect all that stuff to be cached.

But even for local storage, I doubt that metadata for the entire volume is
cached in RAM at all times.


On Wed, Nov 13, 2013 at 3:21 PM, David Rajchenbach-Teller <
dteller at mozilla.com> wrote:

> On Thu Nov 14 00:10:27 2013, Daniel Micay wrote:
> >> The only problem is that Linux doesn't really support asynchronously
> >> resolving file paths to inodes (aka opening files), but that can be
> done on
> >> a dedicated thread pool, with the advantage that the threads don't do
> >> anything, so they don't have zombie stacks.
> >
> > The file metadata cache is small enough that there's no point in
> > considering it blocking. You might as well considering memory accesses
> > blocking at that extreme, because they might require fetching memory
> > to the CPU cache.
>
> Are you sure about that? If my memory serves, you still need to fetch it
> from disk in most cases. On platforms in which devices have a mechanical
> component, even trivial accesses can end up very expensive in case of
> disk thrashing and/or sleeping disk.
>
> Cheers,
>  David
>
> --
> David Rajchenbach-Teller, PhD
>  Performance Team, Mozilla
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/53e3694b/attachment-0001.html>

From danielmicay at gmail.com  Wed Nov 13 15:56:53 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 18:56:53 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <5284098E.4050302@mozilla.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
	<5284098E.4050302@mozilla.com>
Message-ID: <CA+DvKQ+2NKM4okVmQ=O7uCUFjcDOUs7rhzkauoBchsxGeANMwA@mail.gmail.com>

On Wed, Nov 13, 2013 at 6:21 PM, David Rajchenbach-Teller
<dteller at mozilla.com> wrote:
> On Thu Nov 14 00:10:27 2013, Daniel Micay wrote:
>>> The only problem is that Linux doesn't really support asynchronously
>>> resolving file paths to inodes (aka opening files), but that can be done on
>>> a dedicated thread pool, with the advantage that the threads don't do
>>> anything, so they don't have zombie stacks.
>>
>> The file metadata cache is small enough that there's no point in
>> considering it blocking. You might as well considering memory accesses
>> blocking at that extreme, because they might require fetching memory
>> to the CPU cache.
>
> Are you sure about that? If my memory serves, you still need to fetch it
> from disk in most cases. On platforms in which devices have a mechanical
> component, even trivial accesses can end up very expensive in case of
> disk thrashing and/or sleeping disk.
>
> Cheers,
>  David
>
> --
> David Rajchenbach-Teller, PhD
>  Performance Team, Mozilla

Mechanical disks are already dead in mobile though, and will be dead
elsewhere by the time Rust is widely used. It's normal for all of the
metadata to remain in cache, but obviously not page cache. Either way,
Linux doesn't expose non-blocking file primitives and (fast) AIO is
only a dream at this point. The glibc implementation of POSIX AIO uses
threads and blocking I/O.

From kevin at sb.org  Wed Nov 13 16:19:32 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 13 Nov 2013 16:19:32 -0800
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQ+2NKM4okVmQ=O7uCUFjcDOUs7rhzkauoBchsxGeANMwA@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
	<5284098E.4050302@mozilla.com>
	<CA+DvKQ+2NKM4okVmQ=O7uCUFjcDOUs7rhzkauoBchsxGeANMwA@mail.gmail.com>
Message-ID: <08963D5D-E882-4D75-986E-FA6095D260CD@sb.org>

On Nov 13, 2013, at 3:56 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Wed, Nov 13, 2013 at 6:21 PM, David Rajchenbach-Teller
> <dteller at mozilla.com> wrote:
>> On Thu Nov 14 00:10:27 2013, Daniel Micay wrote:
>>>> The only problem is that Linux doesn't really support asynchronously
>>>> resolving file paths to inodes (aka opening files), but that can be done on
>>>> a dedicated thread pool, with the advantage that the threads don't do
>>>> anything, so they don't have zombie stacks.
>>> 
>>> The file metadata cache is small enough that there's no point in
>>> considering it blocking. You might as well considering memory accesses
>>> blocking at that extreme, because they might require fetching memory
>>> to the CPU cache.
>> 
>> Are you sure about that? If my memory serves, you still need to fetch it
>> from disk in most cases. On platforms in which devices have a mechanical
>> component, even trivial accesses can end up very expensive in case of
>> disk thrashing and/or sleeping disk.
>> 
>> Cheers,
>> David
>> 
>> --
>> David Rajchenbach-Teller, PhD
>> Performance Team, Mozilla
> 
> Mechanical disks are already dead in mobile though, and will be dead
> elsewhere by the time Rust is widely used.

In consumer devices, perhaps. But in large data arrays, probably not so much.

Also, don?t forget that there?s more to a filesystem than just local drives. What about network-mounted filesystems?

> It's normal for all of the metadata to remain in cache, but obviously not page cache. Either way,
> Linux doesn't expose non-blocking file primitives and (fast) AIO is
> only a dream at this point. The glibc implementation of POSIX AIO uses
> threads and blocking I/O.

Does ?all of the metadata? mean everything that stat() returns, or are you talking about a limited subset here? Because if it?s the former, then I?m pretty sure all stat metadata for the filesystem does not necessarily reside in cache at the same time. This should be obvious for anyone who?s used a VCS with a gigantic project, and waited for it to stat() all the files to see if they changed.

And this is doubly-true for network filesystems.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131113/7c41bc49/attachment.html>

From danielmicay at gmail.com  Wed Nov 13 16:33:12 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 19:33:12 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <08963D5D-E882-4D75-986E-FA6095D260CD@sb.org>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
	<5284098E.4050302@mozilla.com>
	<CA+DvKQ+2NKM4okVmQ=O7uCUFjcDOUs7rhzkauoBchsxGeANMwA@mail.gmail.com>
	<08963D5D-E882-4D75-986E-FA6095D260CD@sb.org>
Message-ID: <CA+DvKQK4zci-6rC0uogFPcKKOtKXX12v-=9H3enetEexbDvhwA@mail.gmail.com>

The `stat` calls are potentially blocking, so what do you do beyond
blocking a thread? Ideally the current thread, to avoid a context
switch to and from another core - especially since it will often not
block. There's nothing else you can do without a horrible performance
reduction in the common case.

From danielmicay at gmail.com  Wed Nov 13 16:36:57 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 13 Nov 2013 19:36:57 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQK4zci-6rC0uogFPcKKOtKXX12v-=9H3enetEexbDvhwA@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<BAY170-W598530C684253E4EB58BDFF8F90@phx.gbl>
	<CA+DvKQKKAKPAZaX5CLgtXCi8dBgZU01_82n1cNkTUxJS1qEohQ@mail.gmail.com>
	<5284098E.4050302@mozilla.com>
	<CA+DvKQ+2NKM4okVmQ=O7uCUFjcDOUs7rhzkauoBchsxGeANMwA@mail.gmail.com>
	<08963D5D-E882-4D75-986E-FA6095D260CD@sb.org>
	<CA+DvKQK4zci-6rC0uogFPcKKOtKXX12v-=9H3enetEexbDvhwA@mail.gmail.com>
Message-ID: <CA+DvKQLihiSYTcyB6_TsJXER41VG3hY=NByXpBmyQnFPbnvTOA@mail.gmail.com>

On Wed, Nov 13, 2013 at 7:33 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> The `stat` calls are potentially blocking, so what do you do beyond
> blocking a thread? Ideally the current thread, to avoid a context
> switch to and from another core - especially since it will often not
> block. There's nothing else you can do without a horrible performance
> reduction in the common case.

Of course, if it does block, you really have no idea whether `stat`
calls elsewhere will block because the drives could be arranged in any
fashion, and you don't know what's in the cache. The best you can do
is make the calls and have the I/O scheduler plan them out in a
reasonable way. If you only make one at a time, it's not going to go
nearly as quickly.

From alex at crichton.co  Wed Nov 13 17:55:54 2013
From: alex at crichton.co (Alex Crichton)
Date: Wed, 13 Nov 2013 17:55:54 -0800
Subject: [rust-dev] about Rust and static memory allocation
In-Reply-To: <CAH+PdrCpgP_h-5T2edmsaTLNVqzUtsnsHhndxNKyG9cbZACeaw@mail.gmail.com>
References: <CAH+PdrCpgP_h-5T2edmsaTLNVqzUtsnsHhndxNKyG9cbZACeaw@mail.gmail.com>
Message-ID: <CAFnh-mcuoqJxjUL49G-ni-_6g+QtLjc+AhM2LwE2wP_HrS1XgQ@mail.gmail.com>

Right now the compiler will not do anything fancy in terms of changing
allocations to static or not, but rust does provide some amount of
support for patterns like this.

There is a lint mode #[deny(heap_memory)] you can use to statically
ensure that there is no heap-allocated memory in your program. Rust
also allows you to control how all your local variables are allocated,
so the compiler will never magically make an allocation behind the
scenes that you aren't aware of.

Were those the kinds of static analysis that you were looking for?

On Wed, Nov 13, 2013 at 8:35 AM, Nicolas Boulay <nicolas at boulay.name> wrote:
> Hello,
>
> I?m an hardware  scientist, working for a software compagny. I had follow
> some open cpu design like F-cpu, and the langage design of Lisaac. I?m an
> expert in C programming, and have some skills in ocaml, perl, c++, java.
>
>
> In synchrone langage (Lustre/Scade), there is no dynamic memory allocation.
> This kind of langage have the data inside function (or ?block?), the
> opposite way of object langage with method beside the data. It?s like having
> ?static? variable in the C sens, but a different one for each call site.
> There is no loops in Lustre, only high order function like map and fold
> operation, that duplicate the variable for each call. Having such feature,
> reduce the need a dynamic allocation and garbage collector.
>
>
> I think this looks new and strange, but Lustre are used since 10 years in
> real time safety critical software. This kind of (static, compile time)
> memory allocation could be a great help for long running, fast and
> responsive system. I know you target a 1.0 release but this could ease the
> write of software without any dynamic memory allocation.
>
>
> Do you think, this could be implemented in rust ?
>
>
> Regards,
>
> Nicolas Boulay
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From rusty.gates at icloud.com  Wed Nov 13 19:50:05 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 14 Nov 2013 05:50:05 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument to
	binary operators
Message-ID: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>

let mut n = 11;
let p: &int = &123;

p + n; // OK
n + p; // error: mismatched types: expected `int` but found `&int`

Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
fn add(&self, rhs: &RHS) -> Result;

-Tommi


From dbau.pp at gmail.com  Wed Nov 13 19:54:44 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 14 Nov 2013 14:54:44 +1100
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
Message-ID: <52844984.1040401@gmail.com>

On 14/11/13 14:50, Tommi wrote:
> let mut n = 11;
> let p: &int = &123;
>
> p + n; // OK
> n + p; // error: mismatched types: expected `int` but found `&int`
>
> Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
> fn add(&self, rhs: &RHS) -> Result;
>
> -Tommi
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

This is https://github.com/mozilla/rust/issues/8895 . I believe it is 
caused by the implementation details of the overloaded-operator 
desugaring (a + b is equivalent to `a.add(&b)`, so auto-deref allows for 
`a: &T` with `b: T`), I personally think the more sensible resolution 
would be for `p + n` to be disallowed as well as `n + p`.

Huon

From rusty.gates at icloud.com  Wed Nov 13 20:20:46 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 14 Nov 2013 06:20:46 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <52844984.1040401@gmail.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<52844984.1040401@gmail.com>
Message-ID: <8EBDE92C-6F12-48BB-A230-79F4FFA220A5@icloud.com>

On 2013-11-14, at 5:54, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 14/11/13 14:50, Tommi wrote:
>> let mut n = 11;
>> let p: &int = &123;
>> 
>> p + n; // OK
>> n + p; // error: mismatched types: expected `int` but found `&int`
>> 
>> Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
>> fn add(&self, rhs: &RHS) -> Result;
>> 
>> -Tommi
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> This is https://github.com/mozilla/rust/issues/8895 . I believe it is caused by the implementation details of the overloaded-operator desugaring (a + b is equivalent to `a.add(&b)`, so auto-deref allows for `a: &T` with `b: T`), I personally think the more sensible resolution would be for `p + n` to be disallowed as well as `n + p`.
> 
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


Thanks, I tried to search for a bug report for this but didn't manage to find that one. To me it makes perfect sense that p + n would work because if a + b is specified to be "just" syntactic sugar for a.add(b), then a + b should behave exactly like a.add(b), with implicit pointer dereferencing and all that good stuff. But, I don't understand why is it a.add(&b) like you said, though.

By the way, I would hate all of this behavior if Rust had pointer arithmetic, but luckily it doesn't seem to have it.

-Tommi


From rusty.gates at icloud.com  Wed Nov 13 21:00:09 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 14 Nov 2013 07:00:09 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <8EBDE92C-6F12-48BB-A230-79F4FFA220A5@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<52844984.1040401@gmail.com>
	<8EBDE92C-6F12-48BB-A230-79F4FFA220A5@icloud.com>
Message-ID: <EB3AA7EF-5DBD-4C6B-B1AD-970A67379EF9@icloud.com>

On 2013-11-14, at 6:20, Tommi <rusty.gates at icloud.com> wrote:

> On 2013-11-14, at 5:54, Huon Wilson <dbau.pp at gmail.com> wrote:
> 
>> On 14/11/13 14:50, Tommi wrote:
>>> let mut n = 11;
>>> let p: &int = &123;
>>> 
>>> p + n; // OK
>>> n + p; // error: mismatched types: expected `int` but found `&int`
>>> 
>>> Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
>>> fn add(&self, rhs: &RHS) -> Result;
>>> 
>>> -Tommi
>>> 
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> This is https://github.com/mozilla/rust/issues/8895 . I believe it is caused by the implementation details of the overloaded-operator desugaring (a + b is equivalent to `a.add(&b)`, so auto-deref allows for `a: &T` with `b: T`), I personally think the more sensible resolution would be for `p + n` to be disallowed as well as `n + p`.
>> 
>> Huon
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> Thanks, I tried to search for a bug report for this but didn't manage to find that one. To me it makes perfect sense that p + n would work because if a + b is specified to be "just" syntactic sugar for a.add(b), then a + b should behave exactly like a.add(b), with implicit pointer dereferencing and all that good stuff. But, I don't understand why is it a.add(&b) like you said, though.
> 
> By the way, I would hate all of this behavior if Rust had pointer arithmetic, but luckily it doesn't seem to have it.
> 
> -Tommi
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


You're right in that it's not a bug in built-in types, but affects user-defined types also. But n.add(p) works just fine, while n.add(&p) doesn't:

struct Num { n: int }

impl Add<Num, Num> for Num {
    fn add(&self, other: &Num) -> Num { Num { n: self.n + other.n } }
}

fn main() {
    let n = 11i;
    let p = &22i;

    p + n; // OK
    n + p; // error: mismatched types: expected `int` but found `&int`
    n.add(p); // OK
    n.add(&p); // error: mismatched types: expected `&int` but found `&&int`

    let n = Num { n: 11 };
    let p = &Num { n: 22 };

    p + n; // OK
    n + p; // error: mismatched types: expected `Num` but found `&Num`
    n.add(p); // OK
    n.add(&p); // error: mismatched types: expected `&Num` but found `&&Num`
}

-Tommi


From dbau.pp at gmail.com  Wed Nov 13 21:12:31 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 14 Nov 2013 16:12:31 +1100
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <EB3AA7EF-5DBD-4C6B-B1AD-970A67379EF9@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<52844984.1040401@gmail.com>
	<8EBDE92C-6F12-48BB-A230-79F4FFA220A5@icloud.com>
	<EB3AA7EF-5DBD-4C6B-B1AD-970A67379EF9@icloud.com>
Message-ID: <52845BBF.70509@gmail.com>

On 14/11/13 16:00, Tommi wrote:
> On 2013-11-14, at 6:20, Tommi <rusty.gates at icloud.com> wrote:
>
>> On 2013-11-14, at 5:54, Huon Wilson <dbau.pp at gmail.com> wrote:
>>
>>> On 14/11/13 14:50, Tommi wrote:
>>>> let mut n = 11;
>>>> let p: &int = &123;
>>>>
>>>> p + n; // OK
>>>> n + p; // error: mismatched types: expected `int` but found `&int`
>>>>
>>>> Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
>>>> fn add(&self, rhs: &RHS) -> Result;
>>>>
>>>> -Tommi
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>> This is https://github.com/mozilla/rust/issues/8895 . I believe it is caused by the implementation details of the overloaded-operator desugaring (a + b is equivalent to `a.add(&b)`, so auto-deref allows for `a: &T` with `b: T`), I personally think the more sensible resolution would be for `p + n` to be disallowed as well as `n + p`.
>>>
>>> Huon
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>> Thanks, I tried to search for a bug report for this but didn't manage to find that one. To me it makes perfect sense that p + n would work because if a + b is specified to be "just" syntactic sugar for a.add(b), then a + b should behave exactly like a.add(b), with implicit pointer dereferencing and all that good stuff. But, I don't understand why is it a.add(&b) like you said, though.
>>
>> By the way, I would hate all of this behavior if Rust had pointer arithmetic, but luckily it doesn't seem to have it.
>>
>> -Tommi
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> You're right in that it's not a bug in built-in types, but affects user-defined types also. But n.add(p) works just fine, while n.add(&p) doesn't:
>
> struct Num { n: int }
>
> impl Add<Num, Num> for Num {
>      fn add(&self, other: &Num) -> Num { Num { n: self.n + other.n } }
> }
>
> fn main() {
>      let n = 11i;
>      let p = &22i;
>
>      p + n; // OK
>      n + p; // error: mismatched types: expected `int` but found `&int`
>      n.add(p); // OK
>      n.add(&p); // error: mismatched types: expected `&int` but found `&&int`
>
>      let n = Num { n: 11 };
>      let p = &Num { n: 22 };
>
>      p + n; // OK
>      n + p; // error: mismatched types: expected `Num` but found `&Num`
>      n.add(p); // OK
>      n.add(&p); // error: mismatched types: expected `&Num` but found `&&Num`
> }
>
> -Tommi

p has type &Num, which matches the type signature of add for Num, so it 
is expected that it compiles. And, &p has type & &Num, which doesn't 
match the signature of add for Num and so correspondingly doesn't 
compile. Similarly, for the + sugar, `n + p` and `n.add(&p)` (with the 
extra &) are the same (despite the error messages having one fewer 
layers of &).


The operator traits all take references because they (in the common 
case) don't want ownership of their arguments. If they didn't take 
references (i.e. `fn add(self, other: Num) -> Num`) then something like

   bigint_1.add(&bigint_2) // bigint_1 + bigint_2

would likely require

   bigint_1.clone().add(bigint_2.clone()) // bigint_1.clone() + 
bigint_2.clone()

if one wanted to reuse the values in bigint_1 and bigint_2 later.


The current definitions of the traits means that the operator desugaring 
needs to implicitly add the references (that is a + b -> a.add(&b), 
rather than a.add(b)`) to match the type signature, or else we'd be 
forced to write `x + &1` everywhere.

(Just to be clear the auto-deref only happens on the "self" value, i.e. 
the value on which you are calling the method, not any arguments.)


Huon

From spam at scientician.net  Wed Nov 13 21:23:42 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Thu, 14 Nov 2013 06:23:42 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<l60hgr$go4$1@ger.gmane.org>	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>	<l60kle$o1m$1@ger.gmane.org>
	<CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>
Message-ID: <l61mok$712$1@ger.gmane.org>

On 2013-11-13 21:41, Igor Bukanov wrote:
> On 13 November 2013 20:41, Bardur Arantsson <spam at scientician.net> wrote:
> 
>> In practice it's much more difficult to be *explicitly*
>> async and it should just be delegated to the language/runtime. There are
>> some things humans just aren't good at.
> 
> I suspect Rust makes asynchronous programming significantly more
> bearable. Programming in JS in that style is often painful due to the
> noise of all those function() { } spread through the code and bugs
> connected with accessing stuff that should only be ready later. Rust
> nicely addresses that with shorter syntax for closures/macros and move
> semantics.
> 
> So an experiment of writing in asynchronous style in Rust and
> comparing that with C++/JS/other languages would be very useful to
> judge.
> 

It's *not* a matter of just making the syntax "lighter". Asynchronous
callbacks lead to "the pyramid of doom" (as Dave Herman puts it) of
nested callback functions.

Unfortunately, instead of actually fixing the underlying problem (which
is the need for an explicit callback model in the first place), the
ECMAScript committee seems to have gone with

  function foo*(...) {
    yield ....;
  }

which is lighter syntax but still absurd. (To bear fair they also have
extreme constraints of backward compatibility.)

Python has also (to my great disappointment) gone this route, but there
you can't even tell "from the outside" if a function is async-safe --
it's not part of its interface syntactically, but it's of huge
importance in practice.

My overall point is: Why should the *programmer* be segregating
functions into asynchronous and synchronous? We have computers and
compilers which are more than capable than doing this for us at this point!

Regards,



From rusty.gates at icloud.com  Wed Nov 13 21:35:06 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 14 Nov 2013 07:35:06 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <52845BBF.70509@gmail.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<52844984.1040401@gmail.com>
	<8EBDE92C-6F12-48BB-A230-79F4FFA220A5@icloud.com>
	<EB3AA7EF-5DBD-4C6B-B1AD-970A67379EF9@icloud.com>
	<52845BBF.70509@gmail.com>
Message-ID: <9D2409F0-4634-479C-91A9-EA856C4DA296@icloud.com>

On 2013-11-14, at 7:12, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 14/11/13 16:00, Tommi wrote:
>> On 2013-11-14, at 6:20, Tommi <rusty.gates at icloud.com> wrote:
>> 
>> You're right in that it's not a bug in built-in types, but affects user-defined types also. But n.add(p) works just fine, while n.add(&p) doesn't:
>> 
>> struct Num { n: int }
>> 
>> impl Add<Num, Num> for Num {
>>     fn add(&self, other: &Num) -> Num { Num { n: self.n + other.n } }
>> }
>> 
>> fn main() {
>>     let n = 11i;
>>     let p = &22i;
>> 
>>     p + n; // OK
>>     n + p; // error: mismatched types: expected `int` but found `&int`
>>     n.add(p); // OK
>>     n.add(&p); // error: mismatched types: expected `&int` but found `&&int`
>> 
>>     let n = Num { n: 11 };
>>     let p = &Num { n: 22 };
>> 
>>     p + n; // OK
>>     n + p; // error: mismatched types: expected `Num` but found `&Num`
>>     n.add(p); // OK
>>     n.add(&p); // error: mismatched types: expected `&Num` but found `&&Num`
>> }
>> 
>> -Tommi
> 
> p has type &Num, which matches the type signature of add for Num, so it is expected that it compiles. And, &p has type & &Num, which doesn't match the signature of add for Num and so correspondingly doesn't compile. Similarly, for the + sugar, `n + p` and `n.add(&p)` (with the extra &) are the same (despite the error messages having one fewer layers of &).

Right, I actually had failed to realize that those two different error messages are effectively the same.


> The current definitions of the traits means that the operator desugaring needs to implicitly add the references (that is a + b -> a.add(&b), rather than a.add(b)`) to match the type signature, or else we'd be forced to write `x + &1` everywhere.

I think this is what the operator de-sugaring should do:

If b is lvalue:
a + b -> a.add(b)

and...

If b is rvalue:
a + b -> a.add(&b)

-Tommi


From spam at scientician.net  Wed Nov 13 21:36:47 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Thu, 14 Nov 2013 06:36:47 +0100
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
Message-ID: <l61nh5$d81$1@ger.gmane.org>

On 2013-11-13 23:15, Daniel Micay wrote:
> The issue with async/await is that while it maps very well to the AIO
> primitives like IOCP and POSIX AIO, it doesn't map well to something
> that's solid on Linux.

Then help fix Linux. (Yes, I'm serious.)

> It's just not how I/O is done on the platform.
> It uses *non-blocking* I/O so scale up socket servers, with
> notification of ready state rather than completion state. This doesn't
> work for file system access though.
> 
> There's a significant performance hit from moving maybe-blocking I/O
> calls into thread pools to fit a square peg into a round hole.
> 

And your proposed solution for this is to force *everything* into a
round hole?

You'd essentially be forcing every single socket server-type application
to implement their *own* thread pool mechanism. Which (assuming Windows
IOCPs work well) would be suboptimal on Windows and an extra
interoperability concern when sharing code which lives atop a "socket
server".

The JVM world is actually doing this experiment and it has led to a huge
mess of non-interoperable and non-composable code. I would urge anyone
to *not* follow the same route.

Regards,



From danielmicay at gmail.com  Wed Nov 13 21:42:13 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 00:42:13 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <l61nh5$d81$1@ger.gmane.org>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<l61nh5$d81$1@ger.gmane.org>
Message-ID: <CA+DvKQL+nKqxaY_xN+QoKM7-=LNNV4o-09GiY+=S5i3jpjh9uQ@mail.gmail.com>

On Thu, Nov 14, 2013 at 12:36 AM, Bardur Arantsson <spam at scientician.net> wrote:
> On 2013-11-13 23:15, Daniel Micay wrote:
>> The issue with async/await is that while it maps very well to the AIO
>> primitives like IOCP and POSIX AIO, it doesn't map well to something
>> that's solid on Linux.
>
> Then help fix Linux. (Yes, I'm serious.)
>
>> It's just not how I/O is done on the platform.
>> It uses *non-blocking* I/O so scale up socket servers, with
>> notification of ready state rather than completion state. This doesn't
>> work for file system access though.
>>
>> There's a significant performance hit from moving maybe-blocking I/O
>> calls into thread pools to fit a square peg into a round hole.
>>
>
> And your proposed solution for this is to force *everything* into a
> round hole?
>
> You'd essentially be forcing every single socket server-type application
> to implement their *own* thread pool mechanism. Which (assuming Windows
> IOCPs work well) would be suboptimal on Windows and an extra
> interoperability concern when sharing code which lives atop a "socket
> server".
>
> The JVM world is actually doing this experiment and it has led to a huge
> mess of non-interoperable and non-composable code. I would urge anyone
> to *not* follow the same route.
>
> Regards,

I suggest reading the content I posted to the list then, going into
depth about the drawbacks of the current system and how user-mode 1:1
scheduling maintains the same advantages without many of the
disadvantages. There's a link to the Microsoft documentation on the
implementation (replacing Windows fibers) we could be using right now.
It's not entirely necessary to have it on Linux because threads scale
well, but it would be nice.

From banderson at mozilla.com  Wed Nov 13 21:50:14 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 13 Nov 2013 21:50:14 -0800
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
Message-ID: <52846496.2060508@mozilla.com>

Thanks for the great reply, Alex. This is the approach we are going to 
take. Rust is not going to move away from green threads; the plan is to 
support both use cases in the standard library.

On 11/13/2013 10:32 AM, Alex Crichton wrote:
> The situation may not be as dire as you think. The runtime is still in a state
> of flux, and don't forget that in one summer the entire runtime was rewritten in
> rust and was entirely redesigned. I personally still think that M:N is a viable
> model for various applications, and it seems especially unfortunate to just
> remove everything because it's not tailored for all use cases.
>
> Rust made an explicit design decision early on to pursue lightweight/green
> tasks, and it was made with the understanding that there were drawbacks to the
> strategy. Using libuv as a backend for driving I/O was also an explicit decision
> with known drawbacks.
>
> That being said, I do not believe that all is lost. I don't believe that the
> rust standard library as-is today can support *every* use case, but it's getting
> to a point where it can get pretty close. In the recent redesign of the I/O
> implementation, all I/O was abstracted behind trait objects that are synchronous
> in their interface. This I/O interface is all implemented in librustuv by
> talking to the rust scheduler under the hood. Additionally, in pull #10457, I'm
> starting to add support for a native implementation of this I/O interface. The
> great boon of this strategy is that all std::io primitives have no idea if their
> underlying interface is native and blocking or libuv and asynchronous. The exact
> same rust code works for one as it does for the other.
>
> I personally don't see why the same strategy shouldn't work for the task model
> as well. When you link a program to the librustuv crate, then you're choosing to
> have a runtime with M:N scheduling and asynchronous I/O. Perhaps, though, if you
> didn't link to librustuv, you would get 1:1 scheduling with blocking I/O. You
> would still have all the benefits of the standard library's communication
> primitives, spawning primitives, I/O, task-local-storage etc. The only
> difference is that everything would be powered by OS-level threads instead of
> rust-level green tasks.
>
> I would very much like to see a standard library which supports this
> abstraction, and I believe that it is very realistically possible. Right now we
> have an EventLoop interface which defines interacting with I/O that is the
> abstraction between asynchronous I/O and blocking I/O. This sounds like
> we need a more formalized Scheduler interface which abstracts M:N scheduling vs
> 1:1 scheduling.
>
> The main goal of all of this would be to allow the same exact rust code to work
> in both M:N and 1:1 environments. This ability would allow authors to specialize
> their code for their task at-hand. Those writing web servers would be sure to
> link to librustuv, but those writing command-line utilities would simply just
> omit librustuv. Additionally, as a library author, I don't really care which
> implementation you're using. I can write a mysql database driver and then you as
> a consumer of my library decided whether my network calls are blocking or not.
>
> This is a fairly new concept to me (I haven't thought much about it before), but
> this sounds like it may be the right way forward to addressing your concerns
> without compromising too much existing functionality. There would certainly be
> plenty of work to do in this realm, and I'm not sure if this goal would block
> the 1.0 milestone or not. Ideally, this would be a completely
> backwards-compatible change, but there would perhaps be unintended consequences.
> As always, this would need plenty of discussion to see whether this is even a
> reasonable strategy to take.
>
>
> On Wed, Nov 13, 2013 at 2:45 AM, Daniel Micay <danielmicay at gmail.com> wrote:
>> Before getting right into the gritty details about why I think we should think
>> about a path away from M:N scheduling, I'll go over the details of the
>> concurrency model we currently use.
>>
>> Rust uses a user-mode scheduler to cooperatively schedule many tasks onto OS
>> threads. Due to the lack of preemption, tasks need to manually yield control
>> back to the scheduler. Performing I/O with the standard library will block the
>> *task*, but yield control back to the scheduler until the I/O is completed.
>>
>> The scheduler manages a thread pool where the unit of work is a task rather
>> than a queue of closures to be executed or data to be pass to a function. A
>> task consists of a stack, register context and task-local storage much like an
>> OS thread.
>>
>> In the world of high-performance computing, this is a proven model for
>> maximizing throughput for CPU-bound tasks. By abandoning preemption, there's
>> zero overhead from context switches. For socket servers with only negligible
>> server-side computations the avoidance of context switching is a boon for
>> scalability and predictable performance.
>>
>> # Lightweight?
>>
>> Rust's tasks are often called *lightweight* but at least on Linux the only
>> optimization is the lack of preemption. Since segmented stacks have been
>> dropped, the resident/virtual memory usage will be identical.
>>
>> # Spawning performance
>>
>> An OS thread can actually spawn nearly as fast as a Rust task on a system with
>> one CPU. On a multi-core system, there's a high chance of the new thread being
>> spawned on a different CPU resulting in a performance loss.
>>
>> Sample C program, if you need to see it to believe it:
>>
>> ```
>> #include <pthread.h>
>> #include <err.h>
>>
>> static const size_t n_thread = 100000;
>>
>> static void *foo(void *arg) {
>>      return arg;
>> }
>>
>> int main(void) {
>>      for (size_t i = 0; i < n_thread; i++) {
>>          pthread_attr_t attr;
>>          if (pthread_attr_init(&attr) < 0) {
>>              return 1;
>>          }
>>          if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) < 0) {
>>              return 1;
>>          }
>>          pthread_t thread;
>>          if (pthread_create(&thread, &attr, foo, NULL) < 0) {
>>              return 1;
>>          }
>>      }
>>      pthread_exit(NULL);
>> }
>> ```
>>
>> Sample Rust program:
>>
>> ```
>> fn main() {
>>      for _ in range(0, 100000) {
>>          do spawn {
>>          }
>>      }
>> }
>> ```
>>
>> For both programs, I get around 0.9s consistently when pinned to a core. The
>> Rust version drops to 1.1s when not pinned and the OS thread one to about 2s.
>> It drops further when asked to allocate 8MiB stacks like C is doing, and will
>> drop more when it has to do `mmap` and `mprotect` calls like the pthread API.
>>
>> # Asynchronous I/O
>>
>> Rust's requirements for asynchronous I/O would be filled well by direct usage
>> of IOCP on Windows. However, Linux only has solid support for non-blocking
>> sockets because file operations usually just retrieve a result from cache and
>> do not truly have to block. This results in libuv being significantly slower
>> than blocking I/O for most common cases for the sake of scalable socket
>> servers.
>>
>> On modern systems with flash memory, including mobile, there is a *consistent*
>> and relatively small worst-case latency for accessing data on the disk so
>> blocking is essentially a non-issue. Memory mapped I/O is also an incredibly
>> important feature for I/O performance, and there's almost no reason to use
>> traditional I/O on 64-bit. However, it's a no-go with M:N scheduling because
>> the page faults block the thread.
>>
>> # Overview
>>
>> Advantages:
>>
>> * lack of preemptive/fair scheduling, leading to higher throughput
>> * very fast context switches to other tasks on the same scheduler thread
>>
>> Disadvantages:
>>
>> * lack of preemptive/fair scheduling (lower-level model)
>> * poor profiler/debugger support
>> * async I/O stack is much slower for the common case; for example stat is 35x
>>    slower when run in a loop for an mlocate-like utility
>> * true blocking code will still block a scheduler thread
>> * most existing libraries use blocking I/O and OS threads
>> * cannot directly use fast and easy to use linker-supported thread-local data
>> * many existing libraries rely on thread-local storage, so there's a need to be
>>    wary of hidden yields in Rust function calls and it's very difficult to
>>    expose a safe interface to these libraries
>> * every level of a CPU architecture adding registers needs explicit support
>>    from Rust, and it must be selected at runtime when not targeting a specific
>>    CPU (this is currently not done correctly)
>>
>> # User-mode scheduling
>>
>> Windows 7 introduced user-mode scheduling[1] to replace fibers on 64-bit.
>> Google implemented the same thing for Linux (perhaps even before Windows 7 was
>> released), and plans on pushing for it upstream.[2] The linked video does a
>> better job of covering this than I can.
>>
>> User-mode scheduling provides a 1:1 threading model including full support for
>> normal thread-local data and existing debuggers/profilers. It can yield to the
>> scheduler on system calls and page faults. The operating system is responsible
>> for details like context switching, so a large maintenance/portability burden
>> is dealt with. It narrows down the above disadvantage list to just the point
>> about not having preemptive/fair scheduling and doesn't introduce any new ones.
>>
>> I hope this is where concurrency is headed, and I hope Rust doesn't miss this
>> boat by concentrating too much on libuv. I think it would allow us to simply
>> drop support for pseudo-blocking I/O in the Go style and ignore asynchronous
>> I/O and non-blocking sockets in the standard library. It may be useful to have
>> the scheduler use them, but it wouldn't be essential.
>>
>> [1] http://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85).aspx
>> [2] http://www.youtube.com/watch?v=KXuZi9aeGTw
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From rossberg at mpi-sws.org  Wed Nov 13 23:05:41 2013
From: rossberg at mpi-sws.org (Andreas Rossberg)
Date: Thu, 14 Nov 2013 08:05:41 +0100
Subject: [rust-dev] typing in rust
In-Reply-To: <CAFrFfuEYG0R6Qr9M_urJSTfT3mt2ou=aN5fn+z4h9dg5M2xX7g@mail.gmail.com>
References: <CAEvRberQrG_Y870TK7wwcCAYfnHH_=jkT58j6HNzL7_y63ZJ2A@mail.gmail.com>
	<alpine.LNX.2.03.1311131053240.861@localhost.localdomain>
	<CANYWgQAh0PvtjM1Lj8+_QvMfEnMi-r9Zr8g-9YSSTpJKDWvDYw@mail.gmail.com>
	<CE590BA7-8414-4E5F-8302-0B399901FDF7@yahoo.com.au>
	<CAFrFfuEYG0R6Qr9M_urJSTfT3mt2ou=aN5fn+z4h9dg5M2xX7g@mail.gmail.com>
Message-ID: <6EB1D754-96CD-4703-B0DD-31686BE95ED9@mpi-sws.org>

On Nov 13, 2013, at 21:37 , Martin DeMello <martindemello at gmail.com> wrote:
> What ML does differently is having the syntax of let bindings
> explicitly introduce a new scope by being terminated with 'in' - e.g.
> you'd say
> 
> let test = test () in
> println (format! ("{}", test));

In OCaml, not so in Standard ML:

  let
    fun m() = ?Hello"
    val m = m() ^ ? world"
  in
    print m
  end

And even in OCaml you can do it in other contexts:

  module M =
  struct
    let m() = ?Hello?
    let m = m() ^ ? world
  end

/Andreas


> On Wed, Nov 13, 2013 at 10:13 AM, Brendan Zabarauskas
> <bjzaba at yahoo.com.au> wrote:
>> SML also shares these semantics when it comes to bindings. That is, a subsequent binding to the same identifier can ?mask? those that proceed it, even if they are in the same scope and the bound values are of different types. Once a value has had its identifier masked, it can no longer be accessed.
>> 
>> I assume this behaviour was passed on to Ocaml, and Rust inherited it from there. Rust was originally written in Ocaml, and has drawn many influences from there. I personally find it useful from time to time.
>> 
>> ~Brendan
>> 
>> On 14 Nov 2013, at 3:25 am, Joshua Rodgers <bytemr at gmail.com> wrote:
>> 
>>> I'm curious as to why this is valid, though?  This makes sense if you're inside a new or nested scope, but why is it valid inside the same scope as illustrated in the code example?
>>> 
>>> I can understand it from the perspective that I need to mask a function name (but that's a nested scope to me, at that point).
>>> 
>>> 
>>> On Wed, Nov 13, 2013 at 8:54 AM, Scott Lawrence <bytbox at gmail.com> wrote:
>>> I would think that `test()` (the function) is in scope for the duration of `let test =`, and then the new definition masks the old one. Similarly,
>>> 
>>> let x = 2;
>>> let x = x + 2;
>>> 
>>> If you change the last line to /call/ test(), you should get an error.
>>> 
>>> 
>>> On Wed, 13 Nov 2013, Philip Herron wrote:
>>> 
>>> Hey all
>>> 
>>> I am still learning but i just tried something which i expected to give an
>>> error but works:
>>> 
>>> fn test () -> int {
>>> 1
>>> }
>>> 
>>> fn main () {
>>> let test = test ();
>>> println (format! ("{}", test));
>>> }
>>> 
>>> I guess on compilation the names are mangled against their types or
>>> something so you can differentiate between test the function and test the
>>> variable. Not sure would be nice to get some clarification what this
>>> behavior is.
>>> 
>>> Thanks
>>> 
>>> --Phil
>>> 
>>> 
>>> --
>>> Scott Lawrence
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From marijnh at gmail.com  Thu Nov 14 01:00:54 2013
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Thu, 14 Nov 2013 10:00:54 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <l61mok$712$1@ger.gmane.org>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<l60hgr$go4$1@ger.gmane.org>
	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>
	<l60kle$o1m$1@ger.gmane.org>
	<CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>
	<l61mok$712$1@ger.gmane.org>
Message-ID: <CAJnHWXtEoJgJt79ENF6vuC=CecN8eLzWLnc_RHdv4B0xFDVr-Q@mail.gmail.com>

> Unfortunately, instead of actually fixing the underlying problem [?] the ECMAScript committee seems to have gone with [?] which is lighter syntax but still absurd.

Flaming other languages / committees is very much not the point of
this mailing list. Try to stay on topic and dispassionate.

On Thu, Nov 14, 2013 at 6:23 AM, Bardur Arantsson <spam at scientician.net> wrote:
> On 2013-11-13 21:41, Igor Bukanov wrote:
>> On 13 November 2013 20:41, Bardur Arantsson <spam at scientician.net> wrote:
>>
>>> In practice it's much more difficult to be *explicitly*
>>> async and it should just be delegated to the language/runtime. There are
>>> some things humans just aren't good at.
>>
>> I suspect Rust makes asynchronous programming significantly more
>> bearable. Programming in JS in that style is often painful due to the
>> noise of all those function() { } spread through the code and bugs
>> connected with accessing stuff that should only be ready later. Rust
>> nicely addresses that with shorter syntax for closures/macros and move
>> semantics.
>>
>> So an experiment of writing in asynchronous style in Rust and
>> comparing that with C++/JS/other languages would be very useful to
>> judge.
>>
>
> It's *not* a matter of just making the syntax "lighter". Asynchronous
> callbacks lead to "the pyramid of doom" (as Dave Herman puts it) of
> nested callback functions.
>
> Unfortunately, instead of actually fixing the underlying problem (which
> is the need for an explicit callback model in the first place), the
> ECMAScript committee seems to have gone with
>
>   function foo*(...) {
>     yield ....;
>   }
>
> which is lighter syntax but still absurd. (To bear fair they also have
> extreme constraints of backward compatibility.)
>
> Python has also (to my great disappointment) gone this route, but there
> you can't even tell "from the outside" if a function is async-safe --
> it's not part of its interface syntactically, but it's of huge
> importance in practice.
>
> My overall point is: Why should the *programmer* be segregating
> functions into asynchronous and synchronous? We have computers and
> compilers which are more than capable than doing this for us at this point!
>
> Regards,
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From spam at scientician.net  Thu Nov 14 01:24:57 2013
From: spam at scientician.net (Bardur Arantsson)
Date: Thu, 14 Nov 2013 10:24:57 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <CAJnHWXtEoJgJt79ENF6vuC=CecN8eLzWLnc_RHdv4B0xFDVr-Q@mail.gmail.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>	<l60hgr$go4$1@ger.gmane.org>	<CA+DvKQKmzJ2HNPWcCff4J82GToHhwEvjkU4Qwe5qwyq6t9Z44w@mail.gmail.com>	<l60kle$o1m$1@ger.gmane.org>	<CADd11yVdGJ8G7_RfTpgHWR0TN_Gn3JJzLppCULBp=BaeALxMJQ@mail.gmail.com>	<l61mok$712$1@ger.gmane.org>
	<CAJnHWXtEoJgJt79ENF6vuC=CecN8eLzWLnc_RHdv4B0xFDVr-Q@mail.gmail.com>
Message-ID: <l624sv$p56$1@ger.gmane.org>

On 2013-11-14 10:00, Marijn Haverbeke wrote:
>> Unfortunately, instead of actually fixing the underlying problem [?] the ECMAScript committee seems to have gone with [?] which is lighter syntax but still absurd.
> 
> Flaming other languages / committees is very much not the point of
> this mailing list. Try to stay on topic and dispassionate.

Apologies. (However, I think you might also have quoted the very next
sentence which explains that I understand that they were working under
different constraints.)

Regards,


From igor at mir2.org  Thu Nov 14 02:27:58 2013
From: igor at mir2.org (Igor Bukanov)
Date: Thu, 14 Nov 2013 11:27:58 +0100
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQL+nKqxaY_xN+QoKM7-=LNNV4o-09GiY+=S5i3jpjh9uQ@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<l61nh5$d81$1@ger.gmane.org>
	<CA+DvKQL+nKqxaY_xN+QoKM7-=LNNV4o-09GiY+=S5i3jpjh9uQ@mail.gmail.com>
Message-ID: <CADd11yVmGaaETMJx7A3NQq1YyX--eSC0tSv09es6s8Oyo8qcyQ@mail.gmail.com>

On 14 November 2013 06:42, Daniel Micay <danielmicay at gmail.com> wrote:
> There's a link to the Microsoft documentation on the
> implementation (replacing Windows fibers) we could be using right now.
> It's not entirely necessary to have it on Linux because threads scale
> well, but it would be nice.

It is exactly Microsoft that added async keywords to C#. So they know
that UMS does not cover all their needs. Plus various Linux servers
with long-term support (32 bit RedHat 5 is alive and kicking...) make
sure that the need for scalable IO without UMS will exist for a long
time even if UMS will be available with the latest kernels. It also
interesting that both MS documentation and that Google video talk
emphases on compatibility with existing applications and tools and I
doubt that one can both compatibility and optimal performance.

From thadguidry at gmail.com  Thu Nov 14 07:01:28 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 14 Nov 2013 09:01:28 -0600
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <52846496.2060508@mozilla.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAFnh-meUtybxofVbMZNz2uEaCJA=95JwD9PsAQ337SyYfwm97w@mail.gmail.com>
	<52846496.2060508@mozilla.com>
Message-ID: <CAChbWaOYpZRRKWQA359yKEqHmi0Ye04FpQJ73BQL7WKipe_C_w@mail.gmail.com>

Great !  Glad to hear that the plan is to support both use cases by
abstracting M:N and 1:1 eventually.  That will go a long way towards my
later experiments with ETL (extract, transform, load) under various OS's
and multi-core architectures using parallel task flow (I still don't know
what I will call the flow type...lolol)

On Wed, Nov 13, 2013 at 11:50 PM, Brian Anderson <banderson at mozilla.com>wrote:

> Thanks for the great reply, Alex. This is the approach we are going to
> take. Rust is not going to move away from green threads; the plan is to
> support both use cases in the standard library.
>
>
> On 11/13/2013 10:32 AM, Alex Crichton wrote:
>
>> The situation may not be as dire as you think. The runtime is still in a
>> state
>> of flux, and don't forget that in one summer the entire runtime was
>> rewritten in
>> rust and was entirely redesigned. I personally still think that M:N is a
>> viable
>> model for various applications, and it seems especially unfortunate to
>> just
>> remove everything because it's not tailored for all use cases.
>>
>> Rust made an explicit design decision early on to pursue lightweight/green
>> tasks, and it was made with the understanding that there were drawbacks
>> to the
>> strategy. Using libuv as a backend for driving I/O was also an explicit
>> decision
>> with known drawbacks.
>>
>> That being said, I do not believe that all is lost. I don't believe that
>> the
>> rust standard library as-is today can support *every* use case, but it's
>> getting
>> to a point where it can get pretty close. In the recent redesign of the
>> I/O
>> implementation, all I/O was abstracted behind trait objects that are
>> synchronous
>> in their interface. This I/O interface is all implemented in librustuv by
>> talking to the rust scheduler under the hood. Additionally, in pull
>> #10457, I'm
>> starting to add support for a native implementation of this I/O
>> interface. The
>> great boon of this strategy is that all std::io primitives have no idea
>> if their
>> underlying interface is native and blocking or libuv and asynchronous.
>> The exact
>> same rust code works for one as it does for the other.
>>
>> I personally don't see why the same strategy shouldn't work for the task
>> model
>> as well. When you link a program to the librustuv crate, then you're
>> choosing to
>> have a runtime with M:N scheduling and asynchronous I/O. Perhaps, though,
>> if you
>> didn't link to librustuv, you would get 1:1 scheduling with blocking I/O.
>> You
>> would still have all the benefits of the standard library's communication
>> primitives, spawning primitives, I/O, task-local-storage etc. The only
>> difference is that everything would be powered by OS-level threads
>> instead of
>> rust-level green tasks.
>>
>> I would very much like to see a standard library which supports this
>> abstraction, and I believe that it is very realistically possible. Right
>> now we
>> have an EventLoop interface which defines interacting with I/O that is the
>> abstraction between asynchronous I/O and blocking I/O. This sounds like
>> we need a more formalized Scheduler interface which abstracts M:N
>> scheduling vs
>> 1:1 scheduling.
>>
>> The main goal of all of this would be to allow the same exact rust code
>> to work
>> in both M:N and 1:1 environments. This ability would allow authors to
>> specialize
>> their code for their task at-hand. Those writing web servers would be
>> sure to
>> link to librustuv, but those writing command-line utilities would simply
>> just
>> omit librustuv. Additionally, as a library author, I don't really care
>> which
>> implementation you're using. I can write a mysql database driver and then
>> you as
>> a consumer of my library decided whether my network calls are blocking or
>> not.
>>
>> This is a fairly new concept to me (I haven't thought much about it
>> before), but
>> this sounds like it may be the right way forward to addressing your
>> concerns
>> without compromising too much existing functionality. There would
>> certainly be
>> plenty of work to do in this realm, and I'm not sure if this goal would
>> block
>> the 1.0 milestone or not. Ideally, this would be a completely
>> backwards-compatible change, but there would perhaps be unintended
>> consequences.
>> As always, this would need plenty of discussion to see whether this is
>> even a
>> reasonable strategy to take.
>>
>>
>> On Wed, Nov 13, 2013 at 2:45 AM, Daniel Micay <danielmicay at gmail.com>
>> wrote:
>>
>>> Before getting right into the gritty details about why I think we should
>>> think
>>> about a path away from M:N scheduling, I'll go over the details of the
>>> concurrency model we currently use.
>>>
>>> Rust uses a user-mode scheduler to cooperatively schedule many tasks
>>> onto OS
>>> threads. Due to the lack of preemption, tasks need to manually yield
>>> control
>>> back to the scheduler. Performing I/O with the standard library will
>>> block the
>>> *task*, but yield control back to the scheduler until the I/O is
>>> completed.
>>>
>>> The scheduler manages a thread pool where the unit of work is a task
>>> rather
>>> than a queue of closures to be executed or data to be pass to a
>>> function. A
>>> task consists of a stack, register context and task-local storage much
>>> like an
>>> OS thread.
>>>
>>> In the world of high-performance computing, this is a proven model for
>>> maximizing throughput for CPU-bound tasks. By abandoning preemption,
>>> there's
>>> zero overhead from context switches. For socket servers with only
>>> negligible
>>> server-side computations the avoidance of context switching is a boon for
>>> scalability and predictable performance.
>>>
>>> # Lightweight?
>>>
>>> Rust's tasks are often called *lightweight* but at least on Linux the
>>> only
>>> optimization is the lack of preemption. Since segmented stacks have been
>>> dropped, the resident/virtual memory usage will be identical.
>>>
>>> # Spawning performance
>>>
>>> An OS thread can actually spawn nearly as fast as a Rust task on a
>>> system with
>>> one CPU. On a multi-core system, there's a high chance of the new thread
>>> being
>>> spawned on a different CPU resulting in a performance loss.
>>>
>>> Sample C program, if you need to see it to believe it:
>>>
>>> ```
>>> #include <pthread.h>
>>> #include <err.h>
>>>
>>> static const size_t n_thread = 100000;
>>>
>>> static void *foo(void *arg) {
>>>      return arg;
>>> }
>>>
>>> int main(void) {
>>>      for (size_t i = 0; i < n_thread; i++) {
>>>          pthread_attr_t attr;
>>>          if (pthread_attr_init(&attr) < 0) {
>>>              return 1;
>>>          }
>>>          if (pthread_attr_setdetachstate(&attr,
>>> PTHREAD_CREATE_DETACHED) < 0) {
>>>              return 1;
>>>          }
>>>          pthread_t thread;
>>>          if (pthread_create(&thread, &attr, foo, NULL) < 0) {
>>>              return 1;
>>>          }
>>>      }
>>>      pthread_exit(NULL);
>>> }
>>> ```
>>>
>>> Sample Rust program:
>>>
>>> ```
>>> fn main() {
>>>      for _ in range(0, 100000) {
>>>          do spawn {
>>>          }
>>>      }
>>> }
>>> ```
>>>
>>> For both programs, I get around 0.9s consistently when pinned to a core.
>>> The
>>> Rust version drops to 1.1s when not pinned and the OS thread one to
>>> about 2s.
>>> It drops further when asked to allocate 8MiB stacks like C is doing, and
>>> will
>>> drop more when it has to do `mmap` and `mprotect` calls like the pthread
>>> API.
>>>
>>> # Asynchronous I/O
>>>
>>> Rust's requirements for asynchronous I/O would be filled well by direct
>>> usage
>>> of IOCP on Windows. However, Linux only has solid support for
>>> non-blocking
>>> sockets because file operations usually just retrieve a result from
>>> cache and
>>> do not truly have to block. This results in libuv being significantly
>>> slower
>>> than blocking I/O for most common cases for the sake of scalable socket
>>> servers.
>>>
>>> On modern systems with flash memory, including mobile, there is a
>>> *consistent*
>>> and relatively small worst-case latency for accessing data on the disk so
>>> blocking is essentially a non-issue. Memory mapped I/O is also an
>>> incredibly
>>> important feature for I/O performance, and there's almost no reason to
>>> use
>>> traditional I/O on 64-bit. However, it's a no-go with M:N scheduling
>>> because
>>> the page faults block the thread.
>>>
>>> # Overview
>>>
>>> Advantages:
>>>
>>> * lack of preemptive/fair scheduling, leading to higher throughput
>>> * very fast context switches to other tasks on the same scheduler thread
>>>
>>> Disadvantages:
>>>
>>> * lack of preemptive/fair scheduling (lower-level model)
>>> * poor profiler/debugger support
>>> * async I/O stack is much slower for the common case; for example stat
>>> is 35x
>>>    slower when run in a loop for an mlocate-like utility
>>> * true blocking code will still block a scheduler thread
>>> * most existing libraries use blocking I/O and OS threads
>>> * cannot directly use fast and easy to use linker-supported thread-local
>>> data
>>> * many existing libraries rely on thread-local storage, so there's a
>>> need to be
>>>    wary of hidden yields in Rust function calls and it's very difficult
>>> to
>>>    expose a safe interface to these libraries
>>> * every level of a CPU architecture adding registers needs explicit
>>> support
>>>    from Rust, and it must be selected at runtime when not targeting a
>>> specific
>>>    CPU (this is currently not done correctly)
>>>
>>> # User-mode scheduling
>>>
>>> Windows 7 introduced user-mode scheduling[1] to replace fibers on 64-bit.
>>> Google implemented the same thing for Linux (perhaps even before Windows
>>> 7 was
>>> released), and plans on pushing for it upstream.[2] The linked video
>>> does a
>>> better job of covering this than I can.
>>>
>>> User-mode scheduling provides a 1:1 threading model including full
>>> support for
>>> normal thread-local data and existing debuggers/profilers. It can yield
>>> to the
>>> scheduler on system calls and page faults. The operating system is
>>> responsible
>>> for details like context switching, so a large maintenance/portability
>>> burden
>>> is dealt with. It narrows down the above disadvantage list to just the
>>> point
>>> about not having preemptive/fair scheduling and doesn't introduce any
>>> new ones.
>>>
>>> I hope this is where concurrency is headed, and I hope Rust doesn't miss
>>> this
>>> boat by concentrating too much on libuv. I think it would allow us to
>>> simply
>>> drop support for pseudo-blocking I/O in the Go style and ignore
>>> asynchronous
>>> I/O and non-blocking sockets in the standard library. It may be useful
>>> to have
>>> the scheduler use them, but it wouldn't be essential.
>>>
>>> [1] http://msdn.microsoft.com/en-us/library/windows/desktop/
>>> dd627187(v=vs.85).aspx
>>> [2] http://www.youtube.com/watch?v=KXuZi9aeGTw
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/42de819e/attachment-0001.html>

From d.glazman at partner.samsung.com  Thu Nov 14 07:03:36 2013
From: d.glazman at partner.samsung.com (Daniel Glazman)
Date: Thu, 14 Nov 2013 16:03:36 +0100
Subject: [rust-dev] Rust docs
Message-ID: <5284E648.1000301@partner.samsung.com>

Hello rust-dev,

I would like to make a comment I feel is important about both the Rust
tutorial and manual. Please don't misunderstand me, no flame here, I
am sending this message to help. I think good docs are extremely
important to increase the size of a community, and in particular make
more people contribute to Servo (the reason why I'm here).

If the Reference Manual for Rust tries to be complete and does not try
to avoid language complexity, it can be from time to time hard to read
because of one thing: examples are not well or often enough explained
and are often too complex given the section they belong too. It's for
instance difficult for the reader to understand an example of section
n that uses notions explained only in section n+4.

The Tutorial is the entry point for all people willing to investigate
Rust and/or contribute to Servo. I think that document is super
precious, super-important. Unfortunately, I don't think it is really a
tutorial but only a lighter manual. Examples are here even more
important than in the case of the Manual above. A good Tutorial is
often built around one single programming task that becomes more and
more complex as more features of the language are read and
known. Furthermore, the Tutorial has clearly adopted the language
complexity of the reference manual, something that I think should be
in general avoided. I also think all examples should be buildable
and produce a readable result on the console even if that result is a
build or execution error. That would drastically help the reader.

All in all, I think the Tutorial needs some love and probably a
technical writer who is not working on the guts of Rust, someone who
could vulgarize the notions of the Manual into an easy-to-read,
simple-to-experiment, step-by-step tutorial and avoiding in general
vocabulary inherited from programming language science.

Best regards,

</Daniel>

From corey at octayn.net  Thu Nov 14 07:38:53 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 14 Nov 2013 10:38:53 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <5284E648.1000301@partner.samsung.com>
References: <5284E648.1000301@partner.samsung.com>
Message-ID: <CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>

On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
<d.glazman at partner.samsung.com> wrote:
> The Tutorial is the entry point for all people willing to investigate
> Rust and/or contribute to Servo. I think that document is super
> precious, super-important. Unfortunately, I don't think it is really a
> tutorial but only a lighter manual. Examples are here even more
> important than in the case of the Manual above. A good Tutorial is
> often built around one single programming task that becomes more and
> more complex as more features of the language are read and
> known. Furthermore, the Tutorial has clearly adopted the language
> complexity of the reference manual, something that I think should be
> in general avoided. I also think all examples should be buildable
> and produce a readable result on the console even if that result is a
> build or execution error. That would drastically help the reader.
>
> All in all, I think the Tutorial needs some love and probably a
> technical writer who is not working on the guts of Rust, someone who
> could vulgarize the notions of the Manual into an easy-to-read,
> simple-to-experiment, step-by-step tutorial and avoiding in general
> vocabulary inherited from programming language science.
>

I agree, partially. I think "Rust for Rubyists" fills this role quite
well for now. Generally I  think the language tutorial should not try
to hide complexity or paper over things, at the very least so it can
be complete and correct. I think the Python tutorial is a good
benchmark. We might even be able to rip off the Python tutorial's
structure wholesale.

The "on-boarding" process is still very rough. Maybe some sort of
live-comment system would work well for finding pain points, where one
can add comments/feedback while reading the tutorial.

From redbrain at gcc.gnu.org  Thu Nov 14 07:51:23 2013
From: redbrain at gcc.gnu.org (Philip Herron)
Date: Thu, 14 Nov 2013 15:51:23 +0000
Subject: [rust-dev] Rust docs
In-Reply-To: <CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
Message-ID: <CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>

I would defineltly like to see a clone of the python tutorial because it
really does it so well going inch by inch building up what way things work
i am not a web developer but would love to write content i wonder is it
possible to start a github project for this using sphinx i think it uses
isn't it?


On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:

> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> <d.glazman at partner.samsung.com> wrote:
> > The Tutorial is the entry point for all people willing to investigate
> > Rust and/or contribute to Servo. I think that document is super
> > precious, super-important. Unfortunately, I don't think it is really a
> > tutorial but only a lighter manual. Examples are here even more
> > important than in the case of the Manual above. A good Tutorial is
> > often built around one single programming task that becomes more and
> > more complex as more features of the language are read and
> > known. Furthermore, the Tutorial has clearly adopted the language
> > complexity of the reference manual, something that I think should be
> > in general avoided. I also think all examples should be buildable
> > and produce a readable result on the console even if that result is a
> > build or execution error. That would drastically help the reader.
> >
> > All in all, I think the Tutorial needs some love and probably a
> > technical writer who is not working on the guts of Rust, someone who
> > could vulgarize the notions of the Manual into an easy-to-read,
> > simple-to-experiment, step-by-step tutorial and avoiding in general
> > vocabulary inherited from programming language science.
> >
>
> I agree, partially. I think "Rust for Rubyists" fills this role quite
> well for now. Generally I  think the language tutorial should not try
> to hide complexity or paper over things, at the very least so it can
> be complete and correct. I think the Python tutorial is a good
> benchmark. We might even be able to rip off the Python tutorial's
> structure wholesale.
>
> The "on-boarding" process is still very rough. Maybe some sort of
> live-comment system would work well for finding pain points, where one
> can add comments/feedback while reading the tutorial.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/7361ce13/attachment.html>

From thadguidry at gmail.com  Thu Nov 14 08:21:46 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Thu, 14 Nov 2013 10:21:46 -0600
Subject: [rust-dev] Rust docs
In-Reply-To: <CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
Message-ID: <CAChbWaOxs-1=CojWkiEthPbPON1R7aiNiu0ykHB_OcSZ6ef9Jg@mail.gmail.com>

Corey,

Could we get that comments/feedback ability into the tutorial easily ?  I
agree that would be a good start in improving things.


On Thu, Nov 14, 2013 at 9:38 AM, Corey Richardson <corey at octayn.net> wrote:

> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> <d.glazman at partner.samsung.com> wrote:
> > The Tutorial is the entry point for all people willing to investigate
> > Rust and/or contribute to Servo. I think that document is super
> > precious, super-important. Unfortunately, I don't think it is really a
> > tutorial but only a lighter manual. Examples are here even more
> > important than in the case of the Manual above. A good Tutorial is
> > often built around one single programming task that becomes more and
> > more complex as more features of the language are read and
> > known. Furthermore, the Tutorial has clearly adopted the language
> > complexity of the reference manual, something that I think should be
> > in general avoided. I also think all examples should be buildable
> > and produce a readable result on the console even if that result is a
> > build or execution error. That would drastically help the reader.
> >
> > All in all, I think the Tutorial needs some love and probably a
> > technical writer who is not working on the guts of Rust, someone who
> > could vulgarize the notions of the Manual into an easy-to-read,
> > simple-to-experiment, step-by-step tutorial and avoiding in general
> > vocabulary inherited from programming language science.
> >
>
> I agree, partially. I think "Rust for Rubyists" fills this role quite
> well for now. Generally I  think the language tutorial should not try
> to hide complexity or paper over things, at the very least so it can
> be complete and correct. I think the Python tutorial is a good
> benchmark. We might even be able to rip off the Python tutorial's
> structure wholesale.
>
> The "on-boarding" process is still very rough. Maybe some sort of
> live-comment system would work well for finding pain points, where one
> can add comments/feedback while reading the tutorial.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/56237d25/attachment.html>

From erick.tryzelaar at gmail.com  Thu Nov 14 08:35:05 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 14 Nov 2013 08:35:05 -0800
Subject: [rust-dev] Call for speakers at the next Bay Area meetup
Message-ID: <CALdfqQLPyYHv8DdXnjR4HvQ3k8nzYP+MLDqP6s+JOQeCBzz4EQ@mail.gmail.com>

Good morning Rustics,

The second Bay Area meetup is happening in 6 days:

http://www.meetup.com/Rust-Bay-Area/events/143439552/

Patrick will be giving a presentation about Sprocketnes along with a few
others giving some lightning talks. I'd like to start planning for the next
one in December/January. Would anyone like to give a 30 minute - 1 hour
presentation? If so, please let me know the subject and when you'd be
available to speak.

Thanks!
-Erick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/4df883a3/attachment-0001.html>

From corey at octayn.net  Thu Nov 14 08:36:07 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 14 Nov 2013 11:36:07 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <CAChbWaOxs-1=CojWkiEthPbPON1R7aiNiu0ykHB_OcSZ6ef9Jg@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAChbWaOxs-1=CojWkiEthPbPON1R7aiNiu0ykHB_OcSZ6ef9Jg@mail.gmail.com>
Message-ID: <CA++BO6S2GLFPCn691eWSOYicyVXhsztfgEWt-yTVzFsgj_-PxQ@mail.gmail.com>

I've never setup such a system. I imagine it'd need some
infrastructure in place.

On Thu, Nov 14, 2013 at 11:21 AM, Thad Guidry <thadguidry at gmail.com> wrote:
> Corey,
>
> Could we get that comments/feedback ability into the tutorial easily ?  I
> agree that would be a good start in improving things.
>
>
> On Thu, Nov 14, 2013 at 9:38 AM, Corey Richardson <corey at octayn.net> wrote:
>>
>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>> <d.glazman at partner.samsung.com> wrote:
>> > The Tutorial is the entry point for all people willing to investigate
>> > Rust and/or contribute to Servo. I think that document is super
>> > precious, super-important. Unfortunately, I don't think it is really a
>> > tutorial but only a lighter manual. Examples are here even more
>> > important than in the case of the Manual above. A good Tutorial is
>> > often built around one single programming task that becomes more and
>> > more complex as more features of the language are read and
>> > known. Furthermore, the Tutorial has clearly adopted the language
>> > complexity of the reference manual, something that I think should be
>> > in general avoided. I also think all examples should be buildable
>> > and produce a readable result on the console even if that result is a
>> > build or execution error. That would drastically help the reader.
>> >
>> > All in all, I think the Tutorial needs some love and probably a
>> > technical writer who is not working on the guts of Rust, someone who
>> > could vulgarize the notions of the Manual into an easy-to-read,
>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>> > vocabulary inherited from programming language science.
>> >
>>
>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>> well for now. Generally I  think the language tutorial should not try
>> to hide complexity or paper over things, at the very least so it can
>> be complete and correct. I think the Python tutorial is a good
>> benchmark. We might even be able to rip off the Python tutorial's
>> structure wholesale.
>>
>> The "on-boarding" process is still very rough. Maybe some sort of
>> live-comment system would work well for finding pain points, where one
>> can add comments/feedback while reading the tutorial.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> --
> -Thad
> +ThadGuidry
> Thad on LinkedIn

From niko at alum.mit.edu  Thu Nov 14 08:57:43 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Thu, 14 Nov 2013 11:57:43 -0500
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
Message-ID: <20131114165743.GC6546@Mr-Bennet>

This is to some extent in flux (see bug #10337). But the branch I am
working on actually reports *both* usages as errors. The correct code
would be:

   *p + n
   n + *p

Basically, a binary operator like `l + r` is translated to something
similar to the following (which assumes universal function notation,
not yet implemented):

   Add::add(&l, &r)

In other words, no autoderef or other transformation takes place.  We
just look for a matching trait. Instead we just pass the values in by
reference. The reason for passing by reference is so that you can
compare linear types more naturally (i.e., `~[1, 2, 3]`).

I still consider the precise behavior of overloaded operators somewhat
experimental, but I know that I am not happy with the current one,
which is quite ad hoc.


Niko

 On Thu, Nov 14, 2013 at 05:50:05AM +0200, Tommi wrote:
> let mut n = 11;
> let p: &int = &123;
> 
> p + n; // OK
> n + p; // error: mismatched types: expected `int` but found `&int`
> 
> Shouldn't this error be considered a compiler-bug? The Add trait says '&' for rhs after all:
> fn add(&self, rhs: &RHS) -> Result;
> 
> -Tommi
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From gaetan at xeberon.net  Thu Nov 14 08:58:12 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 17:58:12 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
Message-ID: <CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>

I would love helping on this matter, I'm use to setting up automatic
documentation generation (rst, sphinx, doxygen,...).

-----
Gaetan



2013/11/14 Philip Herron <redbrain at gcc.gnu.org>

> I would defineltly like to see a clone of the python tutorial because it
> really does it so well going inch by inch building up what way things work
> i am not a web developer but would love to write content i wonder is it
> possible to start a github project for this using sphinx i think it uses
> isn't it?
>
>
> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>
>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>> <d.glazman at partner.samsung.com> wrote:
>> > The Tutorial is the entry point for all people willing to investigate
>> > Rust and/or contribute to Servo. I think that document is super
>> > precious, super-important. Unfortunately, I don't think it is really a
>> > tutorial but only a lighter manual. Examples are here even more
>> > important than in the case of the Manual above. A good Tutorial is
>> > often built around one single programming task that becomes more and
>> > more complex as more features of the language are read and
>> > known. Furthermore, the Tutorial has clearly adopted the language
>> > complexity of the reference manual, something that I think should be
>> > in general avoided. I also think all examples should be buildable
>> > and produce a readable result on the console even if that result is a
>> > build or execution error. That would drastically help the reader.
>> >
>> > All in all, I think the Tutorial needs some love and probably a
>> > technical writer who is not working on the guts of Rust, someone who
>> > could vulgarize the notions of the Manual into an easy-to-read,
>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>> > vocabulary inherited from programming language science.
>> >
>>
>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>> well for now. Generally I  think the language tutorial should not try
>> to hide complexity or paper over things, at the very least so it can
>> be complete and correct. I think the Python tutorial is a good
>> benchmark. We might even be able to rip off the Python tutorial's
>> structure wholesale.
>>
>> The "on-boarding" process is still very rough. Maybe some sort of
>> live-comment system would work well for finding pain points, where one
>> can add comments/feedback while reading the tutorial.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/00640e41/attachment.html>

From tessyjoseph1992 at gmail.com  Thu Nov 14 09:29:03 2013
From: tessyjoseph1992 at gmail.com (tessy joseph)
Date: Thu, 14 Nov 2013 12:29:03 -0500
Subject: [rust-dev] Rust-dev Digest, Vol 41, Issue 76
In-Reply-To: <mailman.25668.1384446929.24866.rust-dev@mozilla.org>
References: <mailman.25668.1384446929.24866.rust-dev@mozilla.org>
Message-ID: <CALva2=V4eGwmj9iEOKH4Uz7NOnK11_6Gh9kgN=N5MK57-26EKA@mail.gmail.com>

Hi

I am interested in contributing mozilla.especially to know more about
RUST.I tried installing it on my Ubuntu.after make && make install I am
getting an error.please report the issue
https://gist.github.com/Tessie/7470406
Regards
Tessy


On Thu, Nov 14, 2013 at 11:35 AM, <rust-dev-request at mozilla.org> wrote:

> Send Rust-dev mailing list submissions to
>         rust-dev at mozilla.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://mail.mozilla.org/listinfo/rust-dev
> or, via email, send a message with subject or body 'help' to
>         rust-dev-request at mozilla.org
>
> You can reach the person managing the list at
>         rust-dev-owner at mozilla.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Rust-dev digest..."
>
>
> Today's Topics:
>
>    1.  Rust docs (Daniel Glazman)
>    2. Re:  Rust docs (Corey Richardson)
>    3. Re:  Rust docs (Philip Herron)
>    4. Re:  Rust docs (Thad Guidry)
>    5.  Call for speakers at the next Bay Area meetup (Erick Tryzelaar)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Thu, 14 Nov 2013 16:03:36 +0100
> From: Daniel Glazman <d.glazman at partner.samsung.com>
> To: rust-dev at mozilla.org
> Subject: [rust-dev] Rust docs
> Message-ID: <5284E648.1000301 at partner.samsung.com>
> Content-Type: text/plain; charset=ISO-8859-1
>
> Hello rust-dev,
>
> I would like to make a comment I feel is important about both the Rust
> tutorial and manual. Please don't misunderstand me, no flame here, I
> am sending this message to help. I think good docs are extremely
> important to increase the size of a community, and in particular make
> more people contribute to Servo (the reason why I'm here).
>
> If the Reference Manual for Rust tries to be complete and does not try
> to avoid language complexity, it can be from time to time hard to read
> because of one thing: examples are not well or often enough explained
> and are often too complex given the section they belong too. It's for
> instance difficult for the reader to understand an example of section
> n that uses notions explained only in section n+4.
>
> The Tutorial is the entry point for all people willing to investigate
> Rust and/or contribute to Servo. I think that document is super
> precious, super-important. Unfortunately, I don't think it is really a
> tutorial but only a lighter manual. Examples are here even more
> important than in the case of the Manual above. A good Tutorial is
> often built around one single programming task that becomes more and
> more complex as more features of the language are read and
> known. Furthermore, the Tutorial has clearly adopted the language
> complexity of the reference manual, something that I think should be
> in general avoided. I also think all examples should be buildable
> and produce a readable result on the console even if that result is a
> build or execution error. That would drastically help the reader.
>
> All in all, I think the Tutorial needs some love and probably a
> technical writer who is not working on the guts of Rust, someone who
> could vulgarize the notions of the Manual into an easy-to-read,
> simple-to-experiment, step-by-step tutorial and avoiding in general
> vocabulary inherited from programming language science.
>
> Best regards,
>
> </Daniel>
>
>
> ------------------------------
>
> Message: 2
> Date: Thu, 14 Nov 2013 10:38:53 -0500
> From: Corey Richardson <corey at octayn.net>
> To: Daniel Glazman <d.glazman at partner.samsung.com>
> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: Re: [rust-dev] Rust docs
> Message-ID:
>         <
> CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg at mail.gmail.com>
> Content-Type: text/plain; charset=UTF-8
>
> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> <d.glazman at partner.samsung.com> wrote:
> > The Tutorial is the entry point for all people willing to investigate
> > Rust and/or contribute to Servo. I think that document is super
> > precious, super-important. Unfortunately, I don't think it is really a
> > tutorial but only a lighter manual. Examples are here even more
> > important than in the case of the Manual above. A good Tutorial is
> > often built around one single programming task that becomes more and
> > more complex as more features of the language are read and
> > known. Furthermore, the Tutorial has clearly adopted the language
> > complexity of the reference manual, something that I think should be
> > in general avoided. I also think all examples should be buildable
> > and produce a readable result on the console even if that result is a
> > build or execution error. That would drastically help the reader.
> >
> > All in all, I think the Tutorial needs some love and probably a
> > technical writer who is not working on the guts of Rust, someone who
> > could vulgarize the notions of the Manual into an easy-to-read,
> > simple-to-experiment, step-by-step tutorial and avoiding in general
> > vocabulary inherited from programming language science.
> >
>
> I agree, partially. I think "Rust for Rubyists" fills this role quite
> well for now. Generally I  think the language tutorial should not try
> to hide complexity or paper over things, at the very least so it can
> be complete and correct. I think the Python tutorial is a good
> benchmark. We might even be able to rip off the Python tutorial's
> structure wholesale.
>
> The "on-boarding" process is still very rough. Maybe some sort of
> live-comment system would work well for finding pain points, where one
> can add comments/feedback while reading the tutorial.
>
>
> ------------------------------
>
> Message: 3
> Date: Thu, 14 Nov 2013 15:51:23 +0000
> From: Philip Herron <redbrain at gcc.gnu.org>
> To: Corey Richardson <corey at octayn.net>
> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: Re: [rust-dev] Rust docs
> Message-ID:
>         <
> CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> I would defineltly like to see a clone of the python tutorial because it
> really does it so well going inch by inch building up what way things work
> i am not a web developer but would love to write content i wonder is it
> possible to start a github project for this using sphinx i think it uses
> isn't it?
>
>
> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>
> > On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> > <d.glazman at partner.samsung.com> wrote:
> > > The Tutorial is the entry point for all people willing to investigate
> > > Rust and/or contribute to Servo. I think that document is super
> > > precious, super-important. Unfortunately, I don't think it is really a
> > > tutorial but only a lighter manual. Examples are here even more
> > > important than in the case of the Manual above. A good Tutorial is
> > > often built around one single programming task that becomes more and
> > > more complex as more features of the language are read and
> > > known. Furthermore, the Tutorial has clearly adopted the language
> > > complexity of the reference manual, something that I think should be
> > > in general avoided. I also think all examples should be buildable
> > > and produce a readable result on the console even if that result is a
> > > build or execution error. That would drastically help the reader.
> > >
> > > All in all, I think the Tutorial needs some love and probably a
> > > technical writer who is not working on the guts of Rust, someone who
> > > could vulgarize the notions of the Manual into an easy-to-read,
> > > simple-to-experiment, step-by-step tutorial and avoiding in general
> > > vocabulary inherited from programming language science.
> > >
> >
> > I agree, partially. I think "Rust for Rubyists" fills this role quite
> > well for now. Generally I  think the language tutorial should not try
> > to hide complexity or paper over things, at the very least so it can
> > be complete and correct. I think the Python tutorial is a good
> > benchmark. We might even be able to rip off the Python tutorial's
> > structure wholesale.
> >
> > The "on-boarding" process is still very rough. Maybe some sort of
> > live-comment system would work well for finding pain points, where one
> > can add comments/feedback while reading the tutorial.
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/7361ce13/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 4
> Date: Thu, 14 Nov 2013 10:21:46 -0600
> From: Thad Guidry <thadguidry at gmail.com>
> To: Corey Richardson <corey at octayn.net>
> Cc: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: Re: [rust-dev] Rust docs
> Message-ID:
>         <CAChbWaOxs-1=
> CojWkiEthPbPON1R7aiNiu0ykHB_OcSZ6ef9Jg at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Corey,
>
> Could we get that comments/feedback ability into the tutorial easily ?  I
> agree that would be a good start in improving things.
>
>
> On Thu, Nov 14, 2013 at 9:38 AM, Corey Richardson <corey at octayn.net>
> wrote:
>
> > On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> > <d.glazman at partner.samsung.com> wrote:
> > > The Tutorial is the entry point for all people willing to investigate
> > > Rust and/or contribute to Servo. I think that document is super
> > > precious, super-important. Unfortunately, I don't think it is really a
> > > tutorial but only a lighter manual. Examples are here even more
> > > important than in the case of the Manual above. A good Tutorial is
> > > often built around one single programming task that becomes more and
> > > more complex as more features of the language are read and
> > > known. Furthermore, the Tutorial has clearly adopted the language
> > > complexity of the reference manual, something that I think should be
> > > in general avoided. I also think all examples should be buildable
> > > and produce a readable result on the console even if that result is a
> > > build or execution error. That would drastically help the reader.
> > >
> > > All in all, I think the Tutorial needs some love and probably a
> > > technical writer who is not working on the guts of Rust, someone who
> > > could vulgarize the notions of the Manual into an easy-to-read,
> > > simple-to-experiment, step-by-step tutorial and avoiding in general
> > > vocabulary inherited from programming language science.
> > >
> >
> > I agree, partially. I think "Rust for Rubyists" fills this role quite
> > well for now. Generally I  think the language tutorial should not try
> > to hide complexity or paper over things, at the very least so it can
> > be complete and correct. I think the Python tutorial is a good
> > benchmark. We might even be able to rip off the Python tutorial's
> > structure wholesale.
> >
> > The "on-boarding" process is still very rough. Maybe some sort of
> > live-comment system would work well for finding pain points, where one
> > can add comments/feedback while reading the tutorial.
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/56237d25/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 5
> Date: Thu, 14 Nov 2013 08:35:05 -0800
> From: Erick Tryzelaar <erick.tryzelaar at gmail.com>
> To: "rust-dev at mozilla.org" <rust-dev at mozilla.org>
> Subject: [rust-dev] Call for speakers at the next Bay Area meetup
> Message-ID:
>         <
> CALdfqQLPyYHv8DdXnjR4HvQ3k8nzYP+MLDqP6s+JOQeCBzz4EQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Good morning Rustics,
>
> The second Bay Area meetup is happening in 6 days:
>
> http://www.meetup.com/Rust-Bay-Area/events/143439552/
>
> Patrick will be giving a presentation about Sprocketnes along with a few
> others giving some lightning talks. I'd like to start planning for the next
> one in December/January. Would anyone like to give a 30 minute - 1 hour
> presentation? If so, please let me know the subject and when you'd be
> available to speak.
>
> Thanks!
> -Erick
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/4df883a3/attachment.html
> >
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
> ------------------------------
>
> End of Rust-dev Digest, Vol 41, Issue 76
> ****************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/bf80d969/attachment-0001.html>

From ben.striegel at gmail.com  Thu Nov 14 09:30:25 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 14 Nov 2013 12:30:25 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
Message-ID: <CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>

I would welcome such an effort, and suggest that it live as its own
project, outside of the Rust repo. We really aren't set up currently to
handle rapid and frequent documentation changes. Once it gets to a
reasonable level of maturity we could then give it a mention from the main
tutorial, and then once it's ready we could replace the current tutorial
entirely.


On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:

> I would love helping on this matter, I'm use to setting up automatic
> documentation generation (rst, sphinx, doxygen,...).
>
> -----
> Gaetan
>
>
>
> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
>
>> I would defineltly like to see a clone of the python tutorial because it
>> really does it so well going inch by inch building up what way things work
>> i am not a web developer but would love to write content i wonder is it
>> possible to start a github project for this using sphinx i think it uses
>> isn't it?
>>
>>
>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>>
>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>>> <d.glazman at partner.samsung.com> wrote:
>>> > The Tutorial is the entry point for all people willing to investigate
>>> > Rust and/or contribute to Servo. I think that document is super
>>> > precious, super-important. Unfortunately, I don't think it is really a
>>> > tutorial but only a lighter manual. Examples are here even more
>>> > important than in the case of the Manual above. A good Tutorial is
>>> > often built around one single programming task that becomes more and
>>> > more complex as more features of the language are read and
>>> > known. Furthermore, the Tutorial has clearly adopted the language
>>> > complexity of the reference manual, something that I think should be
>>> > in general avoided. I also think all examples should be buildable
>>> > and produce a readable result on the console even if that result is a
>>> > build or execution error. That would drastically help the reader.
>>> >
>>> > All in all, I think the Tutorial needs some love and probably a
>>> > technical writer who is not working on the guts of Rust, someone who
>>> > could vulgarize the notions of the Manual into an easy-to-read,
>>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>>> > vocabulary inherited from programming language science.
>>> >
>>>
>>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>>> well for now. Generally I  think the language tutorial should not try
>>> to hide complexity or paper over things, at the very least so it can
>>> be complete and correct. I think the Python tutorial is a good
>>> benchmark. We might even be able to rip off the Python tutorial's
>>> structure wholesale.
>>>
>>> The "on-boarding" process is still very rough. Maybe some sort of
>>> live-comment system would work well for finding pain points, where one
>>> can add comments/feedback while reading the tutorial.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/97ce3aa8/attachment.html>

From ben.striegel at gmail.com  Thu Nov 14 09:38:16 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Thu, 14 Nov 2013 12:38:16 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
Message-ID: <CAAvrL-nWPPGrcCxFD2Wh8r9UNEpDM798xW_B=_GC6CsL+i6eug@mail.gmail.com>

And by replace I mean we could relegate the current tutorial to an
"advanced" tutorial or somesuch.


On Thu, Nov 14, 2013 at 12:30 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> I would welcome such an effort, and suggest that it live as its own
> project, outside of the Rust repo. We really aren't set up currently to
> handle rapid and frequent documentation changes. Once it gets to a
> reasonable level of maturity we could then give it a mention from the main
> tutorial, and then once it's ready we could replace the current tutorial
> entirely.
>
>
> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
>
>> I would love helping on this matter, I'm use to setting up automatic
>> documentation generation (rst, sphinx, doxygen,...).
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
>>
>>> I would defineltly like to see a clone of the python tutorial because it
>>> really does it so well going inch by inch building up what way things work
>>> i am not a web developer but would love to write content i wonder is it
>>> possible to start a github project for this using sphinx i think it uses
>>> isn't it?
>>>
>>>
>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>>>
>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>>>> <d.glazman at partner.samsung.com> wrote:
>>>> > The Tutorial is the entry point for all people willing to investigate
>>>> > Rust and/or contribute to Servo. I think that document is super
>>>> > precious, super-important. Unfortunately, I don't think it is really a
>>>> > tutorial but only a lighter manual. Examples are here even more
>>>> > important than in the case of the Manual above. A good Tutorial is
>>>> > often built around one single programming task that becomes more and
>>>> > more complex as more features of the language are read and
>>>> > known. Furthermore, the Tutorial has clearly adopted the language
>>>> > complexity of the reference manual, something that I think should be
>>>> > in general avoided. I also think all examples should be buildable
>>>> > and produce a readable result on the console even if that result is a
>>>> > build or execution error. That would drastically help the reader.
>>>> >
>>>> > All in all, I think the Tutorial needs some love and probably a
>>>> > technical writer who is not working on the guts of Rust, someone who
>>>> > could vulgarize the notions of the Manual into an easy-to-read,
>>>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>>>> > vocabulary inherited from programming language science.
>>>> >
>>>>
>>>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>>>> well for now. Generally I  think the language tutorial should not try
>>>> to hide complexity or paper over things, at the very least so it can
>>>> be complete and correct. I think the Python tutorial is a good
>>>> benchmark. We might even be able to rip off the Python tutorial's
>>>> structure wholesale.
>>>>
>>>> The "on-boarding" process is still very rough. Maybe some sort of
>>>> live-comment system would work well for finding pain points, where one
>>>> can add comments/feedback while reading the tutorial.
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/efaa4516/attachment.html>

From gaetan at xeberon.net  Thu Nov 14 09:39:16 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 18:39:16 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
Message-ID: <CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>

do you have a buildbot or jenkins for the rust ?
I don't think travis could push html pages to a remote repository, do it?

-----
Gaetan



2013/11/14 Benjamin Striegel <ben.striegel at gmail.com>

> I would welcome such an effort, and suggest that it live as its own
> project, outside of the Rust repo. We really aren't set up currently to
> handle rapid and frequent documentation changes. Once it gets to a
> reasonable level of maturity we could then give it a mention from the main
> tutorial, and then once it's ready we could replace the current tutorial
> entirely.
>
>
> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
>
>> I would love helping on this matter, I'm use to setting up automatic
>> documentation generation (rst, sphinx, doxygen,...).
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
>>
>>> I would defineltly like to see a clone of the python tutorial because it
>>> really does it so well going inch by inch building up what way things work
>>> i am not a web developer but would love to write content i wonder is it
>>> possible to start a github project for this using sphinx i think it uses
>>> isn't it?
>>>
>>>
>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>>>
>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>>>> <d.glazman at partner.samsung.com> wrote:
>>>> > The Tutorial is the entry point for all people willing to investigate
>>>> > Rust and/or contribute to Servo. I think that document is super
>>>> > precious, super-important. Unfortunately, I don't think it is really a
>>>> > tutorial but only a lighter manual. Examples are here even more
>>>> > important than in the case of the Manual above. A good Tutorial is
>>>> > often built around one single programming task that becomes more and
>>>> > more complex as more features of the language are read and
>>>> > known. Furthermore, the Tutorial has clearly adopted the language
>>>> > complexity of the reference manual, something that I think should be
>>>> > in general avoided. I also think all examples should be buildable
>>>> > and produce a readable result on the console even if that result is a
>>>> > build or execution error. That would drastically help the reader.
>>>> >
>>>> > All in all, I think the Tutorial needs some love and probably a
>>>> > technical writer who is not working on the guts of Rust, someone who
>>>> > could vulgarize the notions of the Manual into an easy-to-read,
>>>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>>>> > vocabulary inherited from programming language science.
>>>> >
>>>>
>>>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>>>> well for now. Generally I  think the language tutorial should not try
>>>> to hide complexity or paper over things, at the very least so it can
>>>> be complete and correct. I think the Python tutorial is a good
>>>> benchmark. We might even be able to rip off the Python tutorial's
>>>> structure wholesale.
>>>>
>>>> The "on-boarding" process is still very rough. Maybe some sort of
>>>> live-comment system would work well for finding pain points, where one
>>>> can add comments/feedback while reading the tutorial.
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/455ce64d/attachment-0001.html>

From corey at octayn.net  Thu Nov 14 09:43:11 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 14 Nov 2013 12:43:11 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
	<CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>
Message-ID: <CA++BO6RvdopV_qzpQEo0A57=pP=OuftGE2U8N7FtNmLo0XO72g@mail.gmail.com>

Travis could, but then anyone could (since the travis.yml is public
and it'd need credentials to the repo). We have a buildbot,
buildbot.rust-lang.org

On Thu, Nov 14, 2013 at 12:39 PM, Gaetan <gaetan at xeberon.net> wrote:
> do you have a buildbot or jenkins for the rust ?
> I don't think travis could push html pages to a remote repository, do it?
>
> -----
> Gaetan
>
>
>
> 2013/11/14 Benjamin Striegel <ben.striegel at gmail.com>
>>
>> I would welcome such an effort, and suggest that it live as its own
>> project, outside of the Rust repo. We really aren't set up currently to
>> handle rapid and frequent documentation changes. Once it gets to a
>> reasonable level of maturity we could then give it a mention from the main
>> tutorial, and then once it's ready we could replace the current tutorial
>> entirely.
>>
>>
>> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
>>>
>>> I would love helping on this matter, I'm use to setting up automatic
>>> documentation generation (rst, sphinx, doxygen,...).
>>>
>>> -----
>>> Gaetan
>>>
>>>
>>>
>>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
>>>>
>>>> I would defineltly like to see a clone of the python tutorial because it
>>>> really does it so well going inch by inch building up what way things work i
>>>> am not a web developer but would love to write content i wonder is it
>>>> possible to start a github project for this using sphinx i think it uses
>>>> isn't it?
>>>>
>>>>
>>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>>>>>
>>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>>>>> <d.glazman at partner.samsung.com> wrote:
>>>>> > The Tutorial is the entry point for all people willing to investigate
>>>>> > Rust and/or contribute to Servo. I think that document is super
>>>>> > precious, super-important. Unfortunately, I don't think it is really
>>>>> > a
>>>>> > tutorial but only a lighter manual. Examples are here even more
>>>>> > important than in the case of the Manual above. A good Tutorial is
>>>>> > often built around one single programming task that becomes more and
>>>>> > more complex as more features of the language are read and
>>>>> > known. Furthermore, the Tutorial has clearly adopted the language
>>>>> > complexity of the reference manual, something that I think should be
>>>>> > in general avoided. I also think all examples should be buildable
>>>>> > and produce a readable result on the console even if that result is a
>>>>> > build or execution error. That would drastically help the reader.
>>>>> >
>>>>> > All in all, I think the Tutorial needs some love and probably a
>>>>> > technical writer who is not working on the guts of Rust, someone who
>>>>> > could vulgarize the notions of the Manual into an easy-to-read,
>>>>> > simple-to-experiment, step-by-step tutorial and avoiding in general
>>>>> > vocabulary inherited from programming language science.
>>>>> >
>>>>>
>>>>> I agree, partially. I think "Rust for Rubyists" fills this role quite
>>>>> well for now. Generally I  think the language tutorial should not try
>>>>> to hide complexity or paper over things, at the very least so it can
>>>>> be complete and correct. I think the Python tutorial is a good
>>>>> benchmark. We might even be able to rip off the Python tutorial's
>>>>> structure wholesale.
>>>>>
>>>>> The "on-boarding" process is still very rough. Maybe some sort of
>>>>> live-comment system would work well for finding pain points, where one
>>>>> can add comments/feedback while reading the tutorial.
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From gaetan at xeberon.net  Thu Nov 14 09:50:48 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 18:50:48 +0100
Subject: [rust-dev] library name libstd and libextra
Message-ID: <CANK7tAEUGFtm2yY1pagFmK3cPPPhk7ooNsB28Bx1ObB+E6e2xQ@mail.gmail.com>

I have a question about the two files "libextra" and "libstd" that are
installed by rust compiler.

Can they be called by any normal average program?

If so, shouldn't we document how?
If this has no sense, I suggest to rename them to something like
"libruststd" or "librustextra" to avoid naming conflict with system
libraries. We can also move to a subdirectory of /usr/lib, like
/usr/lib/rust.

What do you think about this?
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/cfc424e0/attachment.html>

From gaetan at xeberon.net  Thu Nov 14 09:51:57 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 18:51:57 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CA++BO6RvdopV_qzpQEo0A57=pP=OuftGE2U8N7FtNmLo0XO72g@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
	<CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>
	<CA++BO6RvdopV_qzpQEo0A57=pP=OuftGE2U8N7FtNmLo0XO72g@mail.gmail.com>
Message-ID: <CANK7tAF_PgXOqk1BFVY-J3itQiQv2ji_4qAMbLGHqUveuD1w9w@mail.gmail.com>

good :)

so, what is missing to have an automatic generation of html page from a
github page?

-----
Gaetan



2013/11/14 Corey Richardson <corey at octayn.net>

> Travis could, but then anyone could (since the travis.yml is public
> and it'd need credentials to the repo). We have a buildbot,
> buildbot.rust-lang.org
>
> On Thu, Nov 14, 2013 at 12:39 PM, Gaetan <gaetan at xeberon.net> wrote:
> > do you have a buildbot or jenkins for the rust ?
> > I don't think travis could push html pages to a remote repository, do it?
> >
> > -----
> > Gaetan
> >
> >
> >
> > 2013/11/14 Benjamin Striegel <ben.striegel at gmail.com>
> >>
> >> I would welcome such an effort, and suggest that it live as its own
> >> project, outside of the Rust repo. We really aren't set up currently to
> >> handle rapid and frequent documentation changes. Once it gets to a
> >> reasonable level of maturity we could then give it a mention from the
> main
> >> tutorial, and then once it's ready we could replace the current tutorial
> >> entirely.
> >>
> >>
> >> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
> >>>
> >>> I would love helping on this matter, I'm use to setting up automatic
> >>> documentation generation (rst, sphinx, doxygen,...).
> >>>
> >>> -----
> >>> Gaetan
> >>>
> >>>
> >>>
> >>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
> >>>>
> >>>> I would defineltly like to see a clone of the python tutorial because
> it
> >>>> really does it so well going inch by inch building up what way things
> work i
> >>>> am not a web developer but would love to write content i wonder is it
> >>>> possible to start a github project for this using sphinx i think it
> uses
> >>>> isn't it?
> >>>>
> >>>>
> >>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
> >>>>>
> >>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> >>>>> <d.glazman at partner.samsung.com> wrote:
> >>>>> > The Tutorial is the entry point for all people willing to
> investigate
> >>>>> > Rust and/or contribute to Servo. I think that document is super
> >>>>> > precious, super-important. Unfortunately, I don't think it is
> really
> >>>>> > a
> >>>>> > tutorial but only a lighter manual. Examples are here even more
> >>>>> > important than in the case of the Manual above. A good Tutorial is
> >>>>> > often built around one single programming task that becomes more
> and
> >>>>> > more complex as more features of the language are read and
> >>>>> > known. Furthermore, the Tutorial has clearly adopted the language
> >>>>> > complexity of the reference manual, something that I think should
> be
> >>>>> > in general avoided. I also think all examples should be buildable
> >>>>> > and produce a readable result on the console even if that result
> is a
> >>>>> > build or execution error. That would drastically help the reader.
> >>>>> >
> >>>>> > All in all, I think the Tutorial needs some love and probably a
> >>>>> > technical writer who is not working on the guts of Rust, someone
> who
> >>>>> > could vulgarize the notions of the Manual into an easy-to-read,
> >>>>> > simple-to-experiment, step-by-step tutorial and avoiding in general
> >>>>> > vocabulary inherited from programming language science.
> >>>>> >
> >>>>>
> >>>>> I agree, partially. I think "Rust for Rubyists" fills this role quite
> >>>>> well for now. Generally I  think the language tutorial should not try
> >>>>> to hide complexity or paper over things, at the very least so it can
> >>>>> be complete and correct. I think the Python tutorial is a good
> >>>>> benchmark. We might even be able to rip off the Python tutorial's
> >>>>> structure wholesale.
> >>>>>
> >>>>> The "on-boarding" process is still very rough. Maybe some sort of
> >>>>> live-comment system would work well for finding pain points, where
> one
> >>>>> can add comments/feedback while reading the tutorial.
> >>>>> _______________________________________________
> >>>>> Rust-dev mailing list
> >>>>> Rust-dev at mozilla.org
> >>>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>>
> >>>>
> >>>> _______________________________________________
> >>>> Rust-dev mailing list
> >>>> Rust-dev at mozilla.org
> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >>>>
> >>>
> >>>
> >>> _______________________________________________
> >>> Rust-dev mailing list
> >>> Rust-dev at mozilla.org
> >>> https://mail.mozilla.org/listinfo/rust-dev
> >>>
> >>
> >>
> >> _______________________________________________
> >> Rust-dev mailing list
> >> Rust-dev at mozilla.org
> >> https://mail.mozilla.org/listinfo/rust-dev
> >>
> >
> >
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/56efbf10/attachment.html>

From corey at octayn.net  Thu Nov 14 09:56:56 2013
From: corey at octayn.net (Corey Richardson)
Date: Thu, 14 Nov 2013 12:56:56 -0500
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAF_PgXOqk1BFVY-J3itQiQv2ji_4qAMbLGHqUveuD1w9w@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
	<CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>
	<CA++BO6RvdopV_qzpQEo0A57=pP=OuftGE2U8N7FtNmLo0XO72g@mail.gmail.com>
	<CANK7tAF_PgXOqk1BFVY-J3itQiQv2ji_4qAMbLGHqUveuD1w9w@mail.gmail.com>
Message-ID: <CA++BO6S9V4EQPBBiL4qBDWfhqg0FS99BmcBxgbARYvzNO0PWbQ@mail.gmail.com>

We *do* do automatic generation. It uses the markdown in `doc`.
tutorial.md, and rust.md is the manual.

On Thu, Nov 14, 2013 at 12:51 PM, Gaetan <gaetan at xeberon.net> wrote:
> good :)
>
> so, what is missing to have an automatic generation of html page from a
> github page?
>
> -----
> Gaetan
>
>
>
> 2013/11/14 Corey Richardson <corey at octayn.net>
>>
>> Travis could, but then anyone could (since the travis.yml is public
>> and it'd need credentials to the repo). We have a buildbot,
>> buildbot.rust-lang.org
>>
>> On Thu, Nov 14, 2013 at 12:39 PM, Gaetan <gaetan at xeberon.net> wrote:
>> > do you have a buildbot or jenkins for the rust ?
>> > I don't think travis could push html pages to a remote repository, do
>> > it?
>> >
>> > -----
>> > Gaetan
>> >
>> >
>> >
>> > 2013/11/14 Benjamin Striegel <ben.striegel at gmail.com>
>> >>
>> >> I would welcome such an effort, and suggest that it live as its own
>> >> project, outside of the Rust repo. We really aren't set up currently to
>> >> handle rapid and frequent documentation changes. Once it gets to a
>> >> reasonable level of maturity we could then give it a mention from the
>> >> main
>> >> tutorial, and then once it's ready we could replace the current
>> >> tutorial
>> >> entirely.
>> >>
>> >>
>> >> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
>> >>>
>> >>> I would love helping on this matter, I'm use to setting up automatic
>> >>> documentation generation (rst, sphinx, doxygen,...).
>> >>>
>> >>> -----
>> >>> Gaetan
>> >>>
>> >>>
>> >>>
>> >>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
>> >>>>
>> >>>> I would defineltly like to see a clone of the python tutorial because
>> >>>> it
>> >>>> really does it so well going inch by inch building up what way things
>> >>>> work i
>> >>>> am not a web developer but would love to write content i wonder is it
>> >>>> possible to start a github project for this using sphinx i think it
>> >>>> uses
>> >>>> isn't it?
>> >>>>
>> >>>>
>> >>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net> wrote:
>> >>>>>
>> >>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
>> >>>>> <d.glazman at partner.samsung.com> wrote:
>> >>>>> > The Tutorial is the entry point for all people willing to
>> >>>>> > investigate
>> >>>>> > Rust and/or contribute to Servo. I think that document is super
>> >>>>> > precious, super-important. Unfortunately, I don't think it is
>> >>>>> > really
>> >>>>> > a
>> >>>>> > tutorial but only a lighter manual. Examples are here even more
>> >>>>> > important than in the case of the Manual above. A good Tutorial is
>> >>>>> > often built around one single programming task that becomes more
>> >>>>> > and
>> >>>>> > more complex as more features of the language are read and
>> >>>>> > known. Furthermore, the Tutorial has clearly adopted the language
>> >>>>> > complexity of the reference manual, something that I think should
>> >>>>> > be
>> >>>>> > in general avoided. I also think all examples should be buildable
>> >>>>> > and produce a readable result on the console even if that result
>> >>>>> > is a
>> >>>>> > build or execution error. That would drastically help the reader.
>> >>>>> >
>> >>>>> > All in all, I think the Tutorial needs some love and probably a
>> >>>>> > technical writer who is not working on the guts of Rust, someone
>> >>>>> > who
>> >>>>> > could vulgarize the notions of the Manual into an easy-to-read,
>> >>>>> > simple-to-experiment, step-by-step tutorial and avoiding in
>> >>>>> > general
>> >>>>> > vocabulary inherited from programming language science.
>> >>>>> >
>> >>>>>
>> >>>>> I agree, partially. I think "Rust for Rubyists" fills this role
>> >>>>> quite
>> >>>>> well for now. Generally I  think the language tutorial should not
>> >>>>> try
>> >>>>> to hide complexity or paper over things, at the very least so it can
>> >>>>> be complete and correct. I think the Python tutorial is a good
>> >>>>> benchmark. We might even be able to rip off the Python tutorial's
>> >>>>> structure wholesale.
>> >>>>>
>> >>>>> The "on-boarding" process is still very rough. Maybe some sort of
>> >>>>> live-comment system would work well for finding pain points, where
>> >>>>> one
>> >>>>> can add comments/feedback while reading the tutorial.
>> >>>>> _______________________________________________
>> >>>>> Rust-dev mailing list
>> >>>>> Rust-dev at mozilla.org
>> >>>>> https://mail.mozilla.org/listinfo/rust-dev
>> >>>>
>> >>>>
>> >>>>
>> >>>> _______________________________________________
>> >>>> Rust-dev mailing list
>> >>>> Rust-dev at mozilla.org
>> >>>> https://mail.mozilla.org/listinfo/rust-dev
>> >>>>
>> >>>
>> >>>
>> >>> _______________________________________________
>> >>> Rust-dev mailing list
>> >>> Rust-dev at mozilla.org
>> >>> https://mail.mozilla.org/listinfo/rust-dev
>> >>>
>> >>
>> >>
>> >> _______________________________________________
>> >> Rust-dev mailing list
>> >> Rust-dev at mozilla.org
>> >> https://mail.mozilla.org/listinfo/rust-dev
>> >>
>> >
>> >
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>
>

From tessyjoseph1992 at gmail.com  Thu Nov 14 09:57:01 2013
From: tessyjoseph1992 at gmail.com (tessy joseph)
Date: Thu, 14 Nov 2013 12:57:01 -0500
Subject: [rust-dev] Compiler hitting an unexpected failure path
Message-ID: <CALva2=X7NHhp=t7z8xSd6vU45RoBOPkyoGuSg_AMS6Y1CnGYnA@mail.gmail.com>

Hi

I was trying to install RUST on my ubuntu local system.I could not complete
after make && make install.I also tried sudo make install.Both of them
failed .I got this note;Bug reported Compiler hitting unexpected failure
path

https://gist.github.com/Tessie/7470406

Regards
Tessy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/d1a25e18/attachment.html>

From me at kevincantu.org  Thu Nov 14 10:04:37 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Thu, 14 Nov 2013 10:04:37 -0800
Subject: [rust-dev] library name libstd and libextra
In-Reply-To: <CANK7tAEUGFtm2yY1pagFmK3cPPPhk7ooNsB28Bx1ObB+E6e2xQ@mail.gmail.com>
References: <CANK7tAEUGFtm2yY1pagFmK3cPPPhk7ooNsB28Bx1ObB+E6e2xQ@mail.gmail.com>
Message-ID: <CABq6+aexDP33nv-p4F9dj+xVnmW5o+FXB9zB64R-8y5pAk3H9w@mail.gmail.com>

These standard libraries are already packaged for use and documented on the
homepage.  The import for std is implied, and for the second you just need
this:

extern mod extra;


Cheers,
Kevin



On Thu, Nov 14, 2013 at 9:50 AM, Gaetan <gaetan at xeberon.net> wrote:

>
> I have a question about the two files "libextra" and "libstd" that are
> installed by rust compiler.
>
> Can they be called by any normal average program?
>
> If so, shouldn't we document how?
> If this has no sense, I suggest to rename them to something like
> "libruststd" or "librustextra" to avoid naming conflict with system
> libraries. We can also move to a subdirectory of /usr/lib, like
> /usr/lib/rust.
>
> What do you think about this?
> -----
> Gaetan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/d3012959/attachment.html>

From me at kevincantu.org  Thu Nov 14 10:07:00 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Thu, 14 Nov 2013 10:07:00 -0800
Subject: [rust-dev] Compiler hitting an unexpected failure path
In-Reply-To: <CALva2=X7NHhp=t7z8xSd6vU45RoBOPkyoGuSg_AMS6Y1CnGYnA@mail.gmail.com>
References: <CALva2=X7NHhp=t7z8xSd6vU45RoBOPkyoGuSg_AMS6Y1CnGYnA@mail.gmail.com>
Message-ID: <CABq6+aer5KBQYtTyB3myRHu6G9XRvZ4sbmFckvBxZ6cj0eeMtQ@mail.gmail.com>

Definitely looks like an internal compiler error (a.k.a. an ICE).  If you
happen to have the time, run it again with more logging (like that error
message says) and file an issue on GitHub!  :D

Kevin



On Thu, Nov 14, 2013 at 9:57 AM, tessy joseph <tessyjoseph1992 at gmail.com>wrote:

> Hi
>
> I was trying to install RUST on my ubuntu local system.I could not
> complete after make && make install.I also tried sudo make install.Both of
> them failed .I got this note;Bug reported Compiler hitting unexpected
> failure path
>
> https://gist.github.com/Tessie/7470406
>
> Regards
> Tessy
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/ac7cf838/attachment.html>

From gaetan at xeberon.net  Thu Nov 14 10:17:15 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 19:17:15 +0100
Subject: [rust-dev] library name libstd and libextra
In-Reply-To: <CABq6+aexDP33nv-p4F9dj+xVnmW5o+FXB9zB64R-8y5pAk3H9w@mail.gmail.com>
References: <CANK7tAEUGFtm2yY1pagFmK3cPPPhk7ooNsB28Bx1ObB+E6e2xQ@mail.gmail.com>
	<CABq6+aexDP33nv-p4F9dj+xVnmW5o+FXB9zB64R-8y5pAk3H9w@mail.gmail.com>
Message-ID: <CANK7tAEesofHzFbMFTtJUpq4Aud+WTSbGs9LXiix9_9CqNVKMA@mail.gmail.com>

I speak about the file names: /usr/local/lib/libstd... And
/usr/local/lib/libextra

Le jeudi 14 novembre 2013, Kevin Cantu a ?crit :

> These standard libraries are already packaged for use and documented on
> the homepage.  The import for std is implied, and for the second you just
> need this:
>
> extern mod extra;
>
>
> Cheers,
> Kevin
>
>
>
> On Thu, Nov 14, 2013 at 9:50 AM, Gaetan <gaetan at xeberon.net<javascript:_e({}, 'cvml', 'gaetan at xeberon.net');>
> > wrote:
>
>>
>> I have a question about the two files "libextra" and "libstd" that are
>> installed by rust compiler.
>>
>> Can they be called by any normal average program?
>>
>> If so, shouldn't we document how?
>> If this has no sense, I suggest to rename them to something like
>> "libruststd" or "librustextra" to avoid naming conflict with system
>> libraries. We can also move to a subdirectory of /usr/lib, like
>> /usr/lib/rust.
>>
>> What do you think about this?
>> -----
>> Gaetan
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org <javascript:_e({}, 'cvml', 'Rust-dev at mozilla.org');>
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>

-- 
-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/08066449/attachment.html>

From alex at crichton.co  Thu Nov 14 10:20:11 2013
From: alex at crichton.co (Alex Crichton)
Date: Thu, 14 Nov 2013 10:20:11 -0800
Subject: [rust-dev] Compiler hitting an unexpected failure path
In-Reply-To: <CALva2=X7NHhp=t7z8xSd6vU45RoBOPkyoGuSg_AMS6Y1CnGYnA@mail.gmail.com>
References: <CALva2=X7NHhp=t7z8xSd6vU45RoBOPkyoGuSg_AMS6Y1CnGYnA@mail.gmail.com>
Message-ID: <CAFnh-mdZF3vwn=nFY8Em4eT9cS1W_5z24BUU6dzyUEp67eOBBA@mail.gmail.com>

It looks like you're compiling a fairly old version of the compiler, I
would recommend that you update to the master branch instead of using
older copies (we're a fast-moving target right now!)

On Thu, Nov 14, 2013 at 9:57 AM, tessy joseph <tessyjoseph1992 at gmail.com> wrote:
> Hi
>
> I was trying to install RUST on my ubuntu local system.I could not complete
> after make && make install.I also tried sudo make install.Both of them
> failed .I got this note;Bug reported Compiler hitting unexpected failure
> path
>
> https://gist.github.com/Tessie/7470406
>
> Regards
> Tessy
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From kevin at sb.org  Thu Nov 14 10:47:19 2013
From: kevin at sb.org (Kevin Ballard)
Date: Thu, 14 Nov 2013 10:47:19 -0800
Subject: [rust-dev] library name libstd and libextra
In-Reply-To: <CANK7tAEesofHzFbMFTtJUpq4Aud+WTSbGs9LXiix9_9CqNVKMA@mail.gmail.com>
References: <CANK7tAEUGFtm2yY1pagFmK3cPPPhk7ooNsB28Bx1ObB+E6e2xQ@mail.gmail.com>
	<CABq6+aexDP33nv-p4F9dj+xVnmW5o+FXB9zB64R-8y5pAk3H9w@mail.gmail.com>
	<CANK7tAEesofHzFbMFTtJUpq4Aud+WTSbGs9LXiix9_9CqNVKMA@mail.gmail.com>
Message-ID: <E95983E1-9DE7-4B37-8E35-20290645B25B@sb.org>

I was initially concerned, like you, about putting such generic-sounding libraries in /usr/local/lib, but of course that?s not the full name. On the current machine (whose rust is slightly out of date, so this may not match the name you have), libstd is actually

/usr/local/lib/libstd-6c65cf4b443341b1-0.9-pre.dylib

I?m not aware of any other system that adds hashes to library names like rust does, so it seems like a pretty good distinction without needing to namespace them or put ?rust? in the name.

-Kevin

On Nov 14, 2013, at 10:17 AM, Gaetan <gaetan at xeberon.net> wrote:

> I speak about the file names: /usr/local/lib/libstd... And /usr/local/lib/libextra
> 
> Le jeudi 14 novembre 2013, Kevin Cantu a ?crit :
> These standard libraries are already packaged for use and documented on the homepage.  The import for std is implied, and for the second you just need this:
> extern mod extra;
> 
> Cheers,
> Kevin
> 
> 
> 
> On Thu, Nov 14, 2013 at 9:50 AM, Gaetan <gaetan at xeberon.net> wrote:
> 
> I have a question about the two files "libextra" and "libstd" that are installed by rust compiler.
> 
> Can they be called by any normal average program?
> 
> If so, shouldn't we document how?
> If this has no sense, I suggest to rename them to something like "libruststd" or "librustextra" to avoid naming conflict with system libraries. We can also move to a subdirectory of /usr/lib, like /usr/lib/rust.
> 
> What do you think about this?
> -----
> Gaetan
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> 
> 
> -- 
> -----
> Gaetan
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/dce68c65/attachment-0001.html>

From oren at ben-kiki.org  Thu Nov 14 10:53:09 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Thu, 14 Nov 2013 20:53:09 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
Message-ID: <CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>

I added https://github.com/mozilla/rust/issues/10491 which links to
https://github.com/mozilla/rust/issues/9728 to propose that single
inheritance can co-exist and be compatible with anonymous fields, achieving
the best of both worlds.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/bfd3abd6/attachment.html>

From rusty.gates at icloud.com  Thu Nov 14 11:05:40 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 14 Nov 2013 21:05:40 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <20131114165743.GC6546@Mr-Bennet>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<20131114165743.GC6546@Mr-Bennet>
Message-ID: <282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>

On 2013-11-14, at 18:57, Niko Matsakis <niko at alum.mit.edu> wrote:

> Basically, a binary operator like `l + r` is translated to something
> similar to the following (which assumes universal function notation,
> not yet implemented):
> 
>   Add::add(&l, &r)
> 
> In other words, no autoderef or other transformation takes place.  We
> just look for a matching trait. Instead we just pass the values in by
> reference. The reason for passing by reference is so that you can
> compare linear types more naturally (i.e., `~[1, 2, 3]`).


I'm sorry, I don't understand that last point. Can you explain why it makes those comparisons more natural.

-Tommi


From gaetan at xeberon.net  Thu Nov 14 11:18:26 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 14 Nov 2013 20:18:26 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CA++BO6S9V4EQPBBiL4qBDWfhqg0FS99BmcBxgbARYvzNO0PWbQ@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
	<CAEvRbeqNf+ZnF-N-JWmiE5axmTMjG2fmaYE_RHjdBuiJyezR4g@mail.gmail.com>
	<CANK7tAEmE6n335Fuyc=DJbQSdMZY2mqAzJht8vv1ej7eub=f0w@mail.gmail.com>
	<CAAvrL-mjBbVQSR3pR3BeACqPKeKvkEnDn+T1wiyORkBkWmFmWw@mail.gmail.com>
	<CANK7tAFM25WmYGJV+Ez1aA=zr_EBnxshwsf55Wnh5w=LGKxTkQ@mail.gmail.com>
	<CA++BO6RvdopV_qzpQEo0A57=pP=OuftGE2U8N7FtNmLo0XO72g@mail.gmail.com>
	<CANK7tAF_PgXOqk1BFVY-J3itQiQv2ji_4qAMbLGHqUveuD1w9w@mail.gmail.com>
	<CA++BO6S9V4EQPBBiL4qBDWfhqg0FS99BmcBxgbARYvzNO0PWbQ@mail.gmail.com>
Message-ID: <CANK7tAEh30=yB7__2pCAVUQPr+icAHpuxRysX1s9st_G+7-+eA@mail.gmail.com>

do you have suggestion ?

sphinx support for rust? It would require to switch to restructuredtext
syntax

-----
Gaetan



2013/11/14 Corey Richardson <corey at octayn.net>

> We *do* do automatic generation. It uses the markdown in `doc`.
> tutorial.md, and rust.md is the manual.
>
> On Thu, Nov 14, 2013 at 12:51 PM, Gaetan <gaetan at xeberon.net> wrote:
> > good :)
> >
> > so, what is missing to have an automatic generation of html page from a
> > github page?
> >
> > -----
> > Gaetan
> >
> >
> >
> > 2013/11/14 Corey Richardson <corey at octayn.net>
> >>
> >> Travis could, but then anyone could (since the travis.yml is public
> >> and it'd need credentials to the repo). We have a buildbot,
> >> buildbot.rust-lang.org
> >>
> >> On Thu, Nov 14, 2013 at 12:39 PM, Gaetan <gaetan at xeberon.net> wrote:
> >> > do you have a buildbot or jenkins for the rust ?
> >> > I don't think travis could push html pages to a remote repository, do
> >> > it?
> >> >
> >> > -----
> >> > Gaetan
> >> >
> >> >
> >> >
> >> > 2013/11/14 Benjamin Striegel <ben.striegel at gmail.com>
> >> >>
> >> >> I would welcome such an effort, and suggest that it live as its own
> >> >> project, outside of the Rust repo. We really aren't set up currently
> to
> >> >> handle rapid and frequent documentation changes. Once it gets to a
> >> >> reasonable level of maturity we could then give it a mention from the
> >> >> main
> >> >> tutorial, and then once it's ready we could replace the current
> >> >> tutorial
> >> >> entirely.
> >> >>
> >> >>
> >> >> On Thu, Nov 14, 2013 at 11:58 AM, Gaetan <gaetan at xeberon.net> wrote:
> >> >>>
> >> >>> I would love helping on this matter, I'm use to setting up automatic
> >> >>> documentation generation (rst, sphinx, doxygen,...).
> >> >>>
> >> >>> -----
> >> >>> Gaetan
> >> >>>
> >> >>>
> >> >>>
> >> >>> 2013/11/14 Philip Herron <redbrain at gcc.gnu.org>
> >> >>>>
> >> >>>> I would defineltly like to see a clone of the python tutorial
> because
> >> >>>> it
> >> >>>> really does it so well going inch by inch building up what way
> things
> >> >>>> work i
> >> >>>> am not a web developer but would love to write content i wonder is
> it
> >> >>>> possible to start a github project for this using sphinx i think it
> >> >>>> uses
> >> >>>> isn't it?
> >> >>>>
> >> >>>>
> >> >>>> On 14 November 2013 15:38, Corey Richardson <corey at octayn.net>
> wrote:
> >> >>>>>
> >> >>>>> On Thu, Nov 14, 2013 at 10:03 AM, Daniel Glazman
> >> >>>>> <d.glazman at partner.samsung.com> wrote:
> >> >>>>> > The Tutorial is the entry point for all people willing to
> >> >>>>> > investigate
> >> >>>>> > Rust and/or contribute to Servo. I think that document is super
> >> >>>>> > precious, super-important. Unfortunately, I don't think it is
> >> >>>>> > really
> >> >>>>> > a
> >> >>>>> > tutorial but only a lighter manual. Examples are here even more
> >> >>>>> > important than in the case of the Manual above. A good Tutorial
> is
> >> >>>>> > often built around one single programming task that becomes more
> >> >>>>> > and
> >> >>>>> > more complex as more features of the language are read and
> >> >>>>> > known. Furthermore, the Tutorial has clearly adopted the
> language
> >> >>>>> > complexity of the reference manual, something that I think
> should
> >> >>>>> > be
> >> >>>>> > in general avoided. I also think all examples should be
> buildable
> >> >>>>> > and produce a readable result on the console even if that result
> >> >>>>> > is a
> >> >>>>> > build or execution error. That would drastically help the
> reader.
> >> >>>>> >
> >> >>>>> > All in all, I think the Tutorial needs some love and probably a
> >> >>>>> > technical writer who is not working on the guts of Rust, someone
> >> >>>>> > who
> >> >>>>> > could vulgarize the notions of the Manual into an easy-to-read,
> >> >>>>> > simple-to-experiment, step-by-step tutorial and avoiding in
> >> >>>>> > general
> >> >>>>> > vocabulary inherited from programming language science.
> >> >>>>> >
> >> >>>>>
> >> >>>>> I agree, partially. I think "Rust for Rubyists" fills this role
> >> >>>>> quite
> >> >>>>> well for now. Generally I  think the language tutorial should not
> >> >>>>> try
> >> >>>>> to hide complexity or paper over things, at the very least so it
> can
> >> >>>>> be complete and correct. I think the Python tutorial is a good
> >> >>>>> benchmark. We might even be able to rip off the Python tutorial's
> >> >>>>> structure wholesale.
> >> >>>>>
> >> >>>>> The "on-boarding" process is still very rough. Maybe some sort of
> >> >>>>> live-comment system would work well for finding pain points, where
> >> >>>>> one
> >> >>>>> can add comments/feedback while reading the tutorial.
> >> >>>>> _______________________________________________
> >> >>>>> Rust-dev mailing list
> >> >>>>> Rust-dev at mozilla.org
> >> >>>>> https://mail.mozilla.org/listinfo/rust-dev
> >> >>>>
> >> >>>>
> >> >>>>
> >> >>>> _______________________________________________
> >> >>>> Rust-dev mailing list
> >> >>>> Rust-dev at mozilla.org
> >> >>>> https://mail.mozilla.org/listinfo/rust-dev
> >> >>>>
> >> >>>
> >> >>>
> >> >>> _______________________________________________
> >> >>> Rust-dev mailing list
> >> >>> Rust-dev at mozilla.org
> >> >>> https://mail.mozilla.org/listinfo/rust-dev
> >> >>>
> >> >>
> >> >>
> >> >> _______________________________________________
> >> >> Rust-dev mailing list
> >> >> Rust-dev at mozilla.org
> >> >> https://mail.mozilla.org/listinfo/rust-dev
> >> >>
> >> >
> >> >
> >> > _______________________________________________
> >> > Rust-dev mailing list
> >> > Rust-dev at mozilla.org
> >> > https://mail.mozilla.org/listinfo/rust-dev
> >> >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/cf41899d/attachment.html>

From denis.spir at gmail.com  Thu Nov 14 11:24:46 2013
From: denis.spir at gmail.com (spir)
Date: Thu, 14 Nov 2013 20:24:46 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <5284E648.1000301@partner.samsung.com>
References: <5284E648.1000301@partner.samsung.com>
Message-ID: <5285237E.2030505@gmail.com>

I completely share your views, Daniel.

[Would have expressed them myself if I did not know (from experience) that 
constructive critics by me (in english) usually are mistaken or misunderstood: 
people just deny, argue, or reply violently. But you do a good job, here, in my 
opinion.]

Denis

On 11/14/2013 04:03 PM, Daniel Glazman wrote:
> Hello rust-dev,
>
> I would like to make a comment I feel is important about both the Rust
> tutorial and manual. Please don't misunderstand me, no flame here, I
> am sending this message to help. I think good docs are extremely
> important to increase the size of a community, and in particular make
> more people contribute to Servo (the reason why I'm here).
>
> If the Reference Manual for Rust tries to be complete and does not try
> to avoid language complexity, it can be from time to time hard to read
> because of one thing: examples are not well or often enough explained
> and are often too complex given the section they belong too. It's for
> instance difficult for the reader to understand an example of section
> n that uses notions explained only in section n+4.
>
> The Tutorial is the entry point for all people willing to investigate
> Rust and/or contribute to Servo. I think that document is super
> precious, super-important. Unfortunately, I don't think it is really a
> tutorial but only a lighter manual. Examples are here even more
> important than in the case of the Manual above. A good Tutorial is
> often built around one single programming task that becomes more and
> more complex as more features of the language are read and
> known. Furthermore, the Tutorial has clearly adopted the language
> complexity of the reference manual, something that I think should be
> in general avoided. I also think all examples should be buildable
> and produce a readable result on the console even if that result is a
> build or execution error. That would drastically help the reader.
>
> All in all, I think the Tutorial needs some love and probably a
> technical writer who is not working on the guts of Rust, someone who
> could vulgarize the notions of the Manual into an easy-to-read,
> simple-to-experiment, step-by-step tutorial and avoiding in general
> vocabulary inherited from programming language science.
>
> Best regards,
>
> </Daniel>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From denis.spir at gmail.com  Thu Nov 14 11:32:55 2013
From: denis.spir at gmail.com (spir)
Date: Thu, 14 Nov 2013 20:32:55 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
References: <5284E648.1000301@partner.samsung.com>
	<CA++BO6Rk41vs-GTLW8wbugE7PbD3_EGXzMdj9nhoqsKyL24iMg@mail.gmail.com>
Message-ID: <52852567.6010805@gmail.com>

On 11/14/2013 04:38 PM, Corey Richardson wrote:
> I think the Python tutorial is a good
> benchmark. We might even be able to rip off the Python tutorial's
> structure wholesale.

I disagree. Python's tutorial is for me good enough for for C/Unix programmers. 
However, most programming language tutorials are worse ;-). Some tutorial docs 
around Lua are interesting, imo. D's documentation is rather good (imo gain), I 
could do with it despite not beeing a c++ coder.

Hackers usually are very bad on the pedagogical side, i guess (I include myself, 
despite beeing trained as a technical trainer). We just cannot put ourselves in 
others' position, can only exchange with people already sharing our views. For 
whatever reason (?).

Denis

From denis.spir at gmail.com  Thu Nov 14 11:38:46 2013
From: denis.spir at gmail.com (spir)
Date: Thu, 14 Nov 2013 20:38:46 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <5284E648.1000301@partner.samsung.com>
References: <5284E648.1000301@partner.samsung.com>
Message-ID: <528526C6.6040301@gmail.com>

Could there be a kind of rust-tutorial-in-progress wiki page? (with required 
subscription to edit). Seems to me the easiest path to cooperative edition. 
Then, just have a single person responsible for regularly pushing the 'in 
progress' version as the 'offical' one, whenever its state is ok.

Denis


From d.glazman at partner.samsung.com  Thu Nov 14 13:08:47 2013
From: d.glazman at partner.samsung.com (Daniel Glazman)
Date: Thu, 14 Nov 2013 21:08:47 +0000
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAEh30=yB7__2pCAVUQPr+icAHpuxRysX1s9st_G+7-+eA@mail.gmail.com>
Message-ID: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>

Honestly, I am not sure "tutorial quality" and "automatic generation" live
well together. We hire tech evangelists for their ability to present well
information and make messages percolate better, and similarly good doc
requires good tech writers who only do that.

As I said earlier, a tutorial is crucial material to attract people and I
think writing talent, excellent presentation and correct readability are
need for such a tutorial. When I say "attract people" or "community", I am
of course thinking of reaching critical masses for Rust-based projects,
including Servo, and that requires making sure documentation material are
good enough to self-generate a pool of potential hires.

</Daniel>


From dbau.pp at gmail.com  Thu Nov 14 13:51:32 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 15 Nov 2013 08:51:32 +1100
Subject: [rust-dev] Rust docs
In-Reply-To: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
Message-ID: <528545E4.1060907@gmail.com>

On 15/11/13 08:08, Daniel Glazman wrote:
> Honestly, I am not sure "tutorial quality" and "automatic generation" live
> well together. We hire tech evangelists for their ability to present well
> information and make messages percolate better, and similarly good doc
> requires good tech writers who only do that.
>
> As I said earlier, a tutorial is crucial material to attract people and I
> think writing talent, excellent presentation and correct readability are
> need for such a tutorial. When I say "attract people" or "community", I am
> of course thinking of reaching critical masses for Rust-based projects,
> including Servo, and that requires making sure documentation material are
> good enough to self-generate a pool of potential hires.
>
> </Daniel>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Just for reference, the tutorial being suboptimal is a "known bug": 
https://github.com/mozilla/rust/issues/9874


Huon

From danielmicay at gmail.com  Thu Nov 14 14:01:57 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 17:01:57 -0500
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CADd11yVmGaaETMJx7A3NQq1YyX--eSC0tSv09es6s8Oyo8qcyQ@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<l61nh5$d81$1@ger.gmane.org>
	<CA+DvKQL+nKqxaY_xN+QoKM7-=LNNV4o-09GiY+=S5i3jpjh9uQ@mail.gmail.com>
	<CADd11yVmGaaETMJx7A3NQq1YyX--eSC0tSv09es6s8Oyo8qcyQ@mail.gmail.com>
Message-ID: <CA+DvKQLhFSE_uwmApo0j7jzJQxCcgGyBFAjmGy0goMr0U5rV5g@mail.gmail.com>

On Thu, Nov 14, 2013 at 5:27 AM, Igor Bukanov <igor at mir2.org> wrote:
> On 14 November 2013 06:42, Daniel Micay <danielmicay at gmail.com> wrote:
>> There's a link to the Microsoft documentation on the
>> implementation (replacing Windows fibers) we could be using right now.
>> It's not entirely necessary to have it on Linux because threads scale
>> well, but it would be nice.
>
> It is exactly Microsoft that added async keywords to C#. So they know
> that UMS does not cover all their needs. Plus various Linux servers
> with long-term support (32 bit RedHat 5 is alive and kicking...) make
> sure that the need for scalable IO without UMS will exist for a long
> time even if UMS will be available with the latest kernels. It also
> interesting that both MS documentation and that Google video talk
> emphases on compatibility with existing applications and tools and I
> doubt that one can both compatibility and optimal performance.

Correct, you won't get optimal performance with 1 task per
request/client across every platform. For non-socket I/O, it will be
as close as you can get to optimal on Linux except in terms of the
huge virtual memory consumption.

Due to the differences between platforms, you need a different design
to get optimal performance on each (ready-based vs. completion-based,
the extent of non-blocking/async support, threading implementation
quality, etc.).

The performance with 1:1 threading and user-mode scheduling will match
M:N threading but it will also be able to simply yield on blocking
calls, instead of faking a blocking API for calls without a fast
non-blocking alternative.

You will get poor performance on Linux with an async/await scheme for
anything but sockets compared to the 1:1 user-mode scheduling, and
even then it's not a great match for the underlying ready-based API.

From info at bnoordhuis.nl  Thu Nov 14 14:26:20 2013
From: info at bnoordhuis.nl (Ben Noordhuis)
Date: Thu, 14 Nov 2013 23:26:20 +0100
Subject: [rust-dev] The future of M:N threading
In-Reply-To: <5283F339.6040201@mozilla.com>
References: <CA+DvKQ+qLDhG3yX0ehJ-Q9CP4LaB0L4rUCjsqZa78XGmvVOOYQ@mail.gmail.com>
	<CAHQurc_ST0jor5N2qQgM=Na-e5P-ZDg3c_32XZ5snUOudtmZ5Q@mail.gmail.com>
	<5283F339.6040201@mozilla.com>
Message-ID: <CAHQurc_5ZuO6T7U7zVzXuJ0VMsFnniMwGStaab9iuw3ioeBWKQ@mail.gmail.com>

On Wed, Nov 13, 2013 at 10:46 PM, David Rajchenbach-Teller
<dteller at mozilla.com> wrote:
> On 11/13/13 9:08 PM, Ben Noordhuis wrote:
>> Libuv maintainer here.  Libuv's current approach to dealing with
>> blocking I/O is fairly crude: it offloads everything to a rather
>> unsophisticated thread pool.  There is plenty of room for improvement.
>>
>> So far relatively little effort has gone into optimizing file I/O
>> because it's not very critical for node.js.  I've been looking for an
>> excuse to spend more time on it so please file issues or post
>> suggestions.  If you have test cases or benchmarks where libuv is
>> significantly lagging, please point me to them and I'll see what I can
>> do.
>
> If, by any chance, I find time, I would be interested in giving a hand.
> (I'm the main dev of Mozilla's OS.File)

That would be great.  We hang out in #libuv on freenode.org, drop by
for a chat.  There is also a mailing list if you prefer that.

> [...]
>>> On modern systems with flash memory, including mobile, there is a *consistent*
>>> and relatively small worst-case latency for accessing data on the disk so
>>> blocking is essentially a non-issue.
>
> Well, for some systems, that's possible, but in the wild, that's not
> realistic. Firefox Telemetry shows unpredictable worst-case latencies
> that can be very long (I am talking multi-seconds worst-case, and 800 ms
> rather common cases).
>
>> I'm not sure if I can agree with that.  One of the issues with
>> blocking I/O is that the calling thread gets rescheduled when the
>> operation cannot be completed immediately.  Depending on workload and
>> system scheduler, it may get penalized when blocking often.
>
> Is that an issue? I tend to assume that a thread that does I/O should
> expect being rescheduled often.

Why that assumption?  (No snark, I'm genuinely curious.)

I reason from a different perspective: the scheduler wants me to use
up that time slice it allotted to me and will only suspend me if at
some point there is no going forward.

From ongardie at gmail.com  Thu Nov 14 16:03:28 2013
From: ongardie at gmail.com (Diego Ongaro)
Date: Thu, 14 Nov 2013 16:03:28 -0800
Subject: [rust-dev] select on std::comm::Port and different types
Message-ID: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>

Hi all,

My program starts a bunch of tasks, then I want the main task to both
receive ctrl-c signals and receive results from the children. The
signal will come from a std::rt::io::signal::Listener's port, which is
an std::comm::Port<Signum>. The child results will come from a
std::comm::Port<~[uint]>.

My first problem is that std::comm::Port doesn't implement
std::select::Select. It looks like std::rt::comm::Port does, and
std::comm::Port is just a small wrapper around that, but
std::comm::Port makes its internal std::rt::comm::Port private. Is
there any way to select on a std::comm::Port? (And what's the
difference between a std::rt::comm::Port and a std::comm::Port?)

My second problem is that std::select::select() doesn't seem to
support selecting from ports with different types. Naively, I tried
select([p1, p2]), but that expects p1 and p2 to have the same type:
error: mismatched types: expected
`std::rt::comm::Port<std::rt::io::signal::Signum>` but found
`std::rt::comm::Port<~[uint]>` (expected enum
std::rt::io::signal::Signum but found vector)
It'll need dynamic dispatch, so I tried: select([p1 as &Select, p2 as
&Select]). However, this doesn't work since &Select doesn't implement
Select:
error: failed to find an implementation of trait std::select::Select
for &std::select::Select<no-bounds>

There's some commented out code that may be related in select.rs,
though it's hard for me to know where this stands:
/* FIXME(#5121, #7914) This all should be legal, but rust is not
clever enough yet.

impl <'self> Select for &'self mut Select {
    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }
    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {
        self.block_on(sched, task)
    }
    fn unblock_from(&mut self) -> bool { self.unblock_from() }
}
...

How can I select on two ports of different types?

Thanks,
Diego

From rusty.gates at icloud.com  Thu Nov 14 16:09:51 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 02:09:51 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
Message-ID: <7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>

Why couldn't we implement multiple inheritance like this:
Traits provide the functionality, and a struct provides the data for those traits to implement their functionality.

It would look like this:

trait Inflate {
    fn get_radius<'s>(&'s mut self) -> &'s mut int;

    fn inflate_by(&mut self, amount: int) {
        *self.get_radius() += amount;
    }
    // ... rest of the implementation ...
}

trait Flatten {
    fn get_radius<'s>(&'s mut self) -> &'s mut int;

    fn release_all_air(&mut self) {
        *self.get_radius() = 0;
    }
    // ... rest of the implementation ...
}

struct Balloon {
    radius: int
}

impl Inflate for Balloon {
    fn get_radius<'s>(&'s mut self) -> &'s mut int {
        &mut self.radius
    }
}

impl Flatten for Balloon {
    fn get_radius<'s>(&'s mut self) -> &'s mut int {
        &mut self.radius
    }
}

fn main() {
    let mut b = Balloon { radius: 123 };
    b.inflate_by(10);
    b.release_all_air();
}

And we could provide some nicer syntax for doing that, something like this:

trait Inflate {
    ball_radius: mut int,

    fn inflate_by(&mut self, amount: int) {
        self.ball_radius += amount;
    }
    // ... rest of the implementation ...
}

trait Flatten {
    balloon_size: mut int,

    fn release_all_air(&mut self) {
        self.balloon_size = 0;
    }
    // ... rest of the implementation ...
}

struct Balloon {
    radius: int
}

impl Inflate for Balloon {
    ball_radius => self.radius
}

impl Flatten for Balloon {
    balloon_size => self.radius
}

-Tommi

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/21d77c48/attachment-0001.html>

From ncm at cantrip.org  Thu Nov 14 16:31:35 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Thu, 14 Nov 2013 16:31:35 -0800
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
Message-ID: <52856B67.5070200@cantrip.org>

On 11/11/2013 03:52 PM, Gaetan wrote:
> Can we have Two rust?
>
> The first one would be easy to learn, easy to read, and do most of ones
> would expect: on demand garbage collector, traits, Owned pointers,...
 >
> The second one would include all advanced feature we actually don t
> need everyday

This is a special case of the general design principle: push policy
choices up, implementation details down.

There's no need to choose between M:N vs. 1:1 threading, or contiguous
vs. segmented stacks, at the language design level.  It just takes
different kinds of spawn(). The default chosen is whatever works most
transparently.  Similarly, a thread with a tiny or segmented stack is
not what we usually want, but when we (as users) determine we can live
with its limitations and costs -- including expensive call/return
across segment boundaries, and special ffi protocol -- there's no
fundamental reason not to support it.

There are practical reasons, though.  Each choice offered adds to the
complexity of the implementation, and multiplies the testing needed.
We don't want it to be very expensive to port the rust runtime to a
new platform, so these special modes should be limited in number, and
optional.  Ideally a program could try to use one and, when it fails,
fall back to the default mode. There is no need to make this falling-
back invisible, but there are good reasons not to.

Making the choice of default mode depend on the platform (1:1 here, M:N
there) might force complexity on users not necessarily equipped to cope
with it, so it is best to make the defaults the same in all
environments, wherever practical.

(Graydon et al. understand all this, but it might not be obvious to all
of the rapidly growing readership here.)

Nathan Myers
ncm at cantrip.org

From rusty.gates at icloud.com  Thu Nov 14 16:40:50 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 02:40:50 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
Message-ID: <966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>

On 2013-11-15, at 2:09, Tommi <rusty.gates at icloud.com> wrote:

> trait Inflate {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
> 
>     fn inflate_by(&mut self, amount: int) {
>         *self.get_radius() += amount;
>     }
> }
> 
> trait Flatten {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
> 
>     fn release_all_air(&mut self) {
>         *self.get_radius() = 0;
>     }
> }
> 
> struct Balloon {
>     radius: int
> }
> 
> impl Inflate for Balloon {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>         &mut self.radius
>     }
> }
> 
> impl Flatten for Balloon {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>         &mut self.radius
>     }
> }


Am I correct in my assumption, that the above Rust code would translate effectively the same kind of thing as the following C++ code?

template <typename T>
struct Inflate {
    void inflate_by(int amount)
    {
        static_cast<T*>(this)->ball_radius() += amount;
    }
};

template <typename T>
struct Flatten {
    void release_all_air()
    {
        static_cast<T*>(this)->balloon_size() = 0;
    }
};

struct Balloon : Inflate<Balloon>, Flatten<Balloon> {
    int radius;
    
    int& ball_radius()  { return radius; }
    int& balloon_size() { return radius; }
};

-Tommi

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/08e96392/attachment.html>

From danielmicay at gmail.com  Thu Nov 14 16:51:19 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 19:51:19 -0500
Subject: [rust-dev] Implementation complexity
In-Reply-To: <52856B67.5070200@cantrip.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
Message-ID: <CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>

On Thu, Nov 14, 2013 at 7:31 PM, Nathan Myers <ncm at cantrip.org> wrote:
> On 11/11/2013 03:52 PM, Gaetan wrote:
>>
>> Can we have Two rust?
>>
>> The first one would be easy to learn, easy to read, and do most of ones
>> would expect: on demand garbage collector, traits, Owned pointers,...
>
>>
>>
>> The second one would include all advanced feature we actually don t
>> need everyday
>
>
> This is a special case of the general design principle: push policy
> choices up, implementation details down.
>
> There's no need to choose between M:N vs. 1:1 threading, or contiguous
> vs. segmented stacks, at the language design level.  It just takes
> different kinds of spawn(). The default chosen is whatever works most
> transparently.  Similarly, a thread with a tiny or segmented stack is
> not what we usually want, but when we (as users) determine we can live
> with its limitations and costs -- including expensive call/return
> across segment boundaries, and special ffi protocol -- there's no
> fundamental reason not to support it.

In many cases, there is a need to choose between supporting one or the
other, or having sub-par support for both. If segmented stacks are
supported, there will be preludes in nearly every single function to check the
available stack space and there is the need to carefully annotate all
the foreign function calls.

Go always uses segmented stacks, and therefore it reimplements the
support offered by the C standard library to avoid stack switches. It
even uses a special calling convention to make context switches cheap
(on a modern Intel CPU only 3 registers to swap, instead of 16 general
purpose ones + float state + 32 AVX registers + segment registers and
more).

The same is true for 1:1 vs. M:N threading. If a task doesn't map 1:1
to a thread ID and thread-local data, support for C libraries using
thread-local data will always be stuck with an inferior API to C/C++.
There's also the inability to directly use static thread-local data
which is very fast and easy to use.

> There are practical reasons, though.  Each choice offered adds to the
> complexity of the implementation, and multiplies the testing needed.
> We don't want it to be very expensive to port the rust runtime to a
> new platform, so these special modes should be limited in number, and
> optional.  Ideally a program could try to use one and, when it fails,
> fall back to the default mode. There is no need to make this falling-
> back invisible, but there are good reasons not to.

An example of this is that Rust's standard library currently assumes
every CPU has the baseline set of registers of the architecture, and
doesn't swap the others. For an example of the consequences, Rust
doesn't support using AVX on x86_64 and or SSE/AVX on x86. It would be
incredibly complex to support every variation of various architectures
via runtime selection of the context switching code.

The reason for Rust not simply supporting (almost) every architecture
that LLVM supports out-of-the-box is M:N threading.

From pcwalton at mozilla.com  Thu Nov 14 16:53:57 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 15 Nov 2013 09:53:57 +0900
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>	<52856B67.5070200@cantrip.org>
	<CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
Message-ID: <528570A5.8000606@mozilla.com>

On 11/15/13 9:51 AM, Daniel Micay wrote:
> The same is true for 1:1 vs. M:N threading. If a task doesn't map 1:1
> to a thread ID and thread-local data, support for C libraries using
> thread-local data will always be stuck with an inferior API to C/C++.

Unless you pin the task, no?

> There's also the inability to directly use static thread-local data
> which is very fast and easy to use.

I think we could just implement static task-local data using some sort 
of life-before-main under the hood.

Patrick


From danielmicay at gmail.com  Thu Nov 14 17:00:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 20:00:03 -0500
Subject: [rust-dev] Implementation complexity
In-Reply-To: <528570A5.8000606@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
	<CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
	<528570A5.8000606@mozilla.com>
Message-ID: <CA+DvKQKGY8nFwgOSa4DNC3Nfat=sXsXOciF47yaMCMNyMnK4nw@mail.gmail.com>

On Thu, Nov 14, 2013 at 7:53 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 11/15/13 9:51 AM, Daniel Micay wrote:
>>
>> The same is true for 1:1 vs. M:N threading. If a task doesn't map 1:1
>> to a thread ID and thread-local data, support for C libraries using
>> thread-local data will always be stuck with an inferior API to C/C++.
>
>
> Unless you pin the task, no?

If you pin the task and other tasks aren't allowed to use the thread,
it would work. The library would have to do this in all the entry
points to provide safety and there would have to be no way of
unpinning a task in safe code or at least a separate mandatory pinning
concept.

>> There's also the inability to directly use static thread-local data
>> which is very fast and easy to use.
>
> I think we could just implement static task-local data using some sort of
> life-before-main under the hood.

The issue is that the thread-local data is used by outputting accesses
through an x86 segment register (and similarly on other architectures)
so 1:1 vs. M:N would become a compile-time choice.

From pcwalton at mozilla.com  Thu Nov 14 17:02:47 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 15 Nov 2013 10:02:47 +0900
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>	<52856B67.5070200@cantrip.org>
	<CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
Message-ID: <528572B7.8070903@mozilla.com>

On 11/15/13 9:51 AM, Daniel Micay wrote:
> The reason for Rust not simply supporting (almost) every architecture
> that LLVM supports out-of-the-box is M:N threading.

I take issue with this. The *language* supports almost every 
architecture that LLVM supports. The *runtime* is just part of the 
standard library, and the standard library will always have porting work 
needed to support different platforms well.

Patrick


From pcwalton at mozilla.com  Thu Nov 14 17:04:40 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 15 Nov 2013 10:04:40 +0900
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CA+DvKQKGY8nFwgOSa4DNC3Nfat=sXsXOciF47yaMCMNyMnK4nw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
	<CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
	<528570A5.8000606@mozilla.com>
	<CA+DvKQKGY8nFwgOSa4DNC3Nfat=sXsXOciF47yaMCMNyMnK4nw@mail.gmail.com>
Message-ID: <52857328.6030007@mozilla.com>

On 11/15/13 10:00 AM, Daniel Micay wrote:
> If you pin the task and other tasks aren't allowed to use the thread,
> it would work. The library would have to do this in all the entry
> points to provide safety and there would have to be no way of
> unpinning a task in safe code or at least a separate mandatory pinning
> concept.

Mandatory pinning for safety is needed anyway, for example for OpenGL.

> The issue is that the thread-local data is used by outputting accesses
> through an x86 segment register (and similarly on other architectures)
> so 1:1 vs. M:N would become a compile-time choice.

I'm fine with that.

Patrick


From banderson at mozilla.com  Thu Nov 14 17:06:36 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 14 Nov 2013 17:06:36 -0800
Subject: [rust-dev] Rust docs
In-Reply-To: <5284E648.1000301@partner.samsung.com>
References: <5284E648.1000301@partner.samsung.com>
Message-ID: <5285739C.6060907@mozilla.com>

On 11/14/2013 07:03 AM, Daniel Glazman wrote:
> Hello rust-dev,
>
> All in all, I think the Tutorial needs some love and probably a
> technical writer who is not working on the guts of Rust, someone who
> could vulgarize the notions of the Manual into an easy-to-read,
> simple-to-experiment, step-by-step tutorial and avoiding in general
> vocabulary inherited from programming language science.

I completely agree, and rewriting the tutorial specifically is the 
subject of #9874. We want to put a lot more effort into documentation 
for Rust 1.0 and are in fact actively looking for an amazing technical 
writer for this purpose. If anybody with a background in technical 
writing is passionate about this topic I'd love to hear from you privately.

From danielmicay at gmail.com  Thu Nov 14 17:08:12 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 20:08:12 -0500
Subject: [rust-dev] Implementation complexity
In-Reply-To: <528572B7.8070903@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
	<CA+DvKQ+3N_x=X4CHJiQg0vf3kReC0mES5AEUoHUDTFzUf3367Q@mail.gmail.com>
	<528572B7.8070903@mozilla.com>
Message-ID: <CA+DvKQKprgstNF4nK0eM=7DOb-yPqEvQRXAhoJ_WqSNYUNb_Zw@mail.gmail.com>

On Thu, Nov 14, 2013 at 8:02 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 11/15/13 9:51 AM, Daniel Micay wrote:
>>
>> The reason for Rust not simply supporting (almost) every architecture
>> that LLVM supports out-of-the-box is M:N threading.
>
>
> I take issue with this. The *language* supports almost every architecture
> that LLVM supports. The *runtime* is just part of the standard library, and
> the standard library will always have porting work needed to support
> different platforms well.
>
> Patrick

That's true, but for most people the standard library is part of what
Rust is. I don't think there's much porting work to do for most
architectures beyond updating the context switch assembly code.

It's true that due to our hard-wired definitions of C types there is a
lot in `std::libc` to update, but we're going to need to switch to
auto-generating this to support alternative C libraries already.

From banderson at mozilla.com  Thu Nov 14 17:19:45 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Thu, 14 Nov 2013 17:19:45 -0800
Subject: [rust-dev] select on std::comm::Port and different types
In-Reply-To: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>
References: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>
Message-ID: <528576B1.3050909@mozilla.com>

On 11/14/2013 04:03 PM, Diego Ongaro wrote:
> Hi all,
>
> My program starts a bunch of tasks, then I want the main task to both
> receive ctrl-c signals and receive results from the children. The
> signal will come from a std::rt::io::signal::Listener's port, which is
> an std::comm::Port<Signum>. The child results will come from a
> std::comm::Port<~[uint]>.
>
> My first problem is that std::comm::Port doesn't implement
> std::select::Select. It looks like std::rt::comm::Port does, and
> std::comm::Port is just a small wrapper around that, but
> std::comm::Port makes its internal std::rt::comm::Port private. Is
> there any way to select on a std::comm::Port? (And what's the
> difference between a std::rt::comm::Port and a std::comm::Port?)

There currently isn't a way - this feature isn't fully baked yet, but it 
should not take a whole lot of effort to get it working. There is no 
functional difference between  std::comm and std::rt::comm; 
std::rt::comm should be moved wholesale to std::comm and the current 
std::comm deleted, but it hasn't been done yet.

>
> My second problem is that std::select::select() doesn't seem to
> support selecting from ports with different types. Naively, I tried
> select([p1, p2]), but that expects p1 and p2 to have the same type:
> error: mismatched types: expected
> `std::rt::comm::Port<std::rt::io::signal::Signum>` but found
> `std::rt::comm::Port<~[uint]>` (expected enum
> std::rt::io::signal::Signum but found vector)
> It'll need dynamic dispatch, so I tried: select([p1 as &Select, p2 as
> &Select]). However, this doesn't work since &Select doesn't implement
> Select:
> error: failed to find an implementation of trait std::select::Select
> for &std::select::Select<no-bounds>
>
> There's some commented out code that may be related in select.rs,
> though it's hard for me to know where this stands:
> /* FIXME(#5121, #7914) This all should be legal, but rust is not
> clever enough yet.
>
> impl <'self> Select for &'self mut Select {
>      fn optimistic_check(&mut self) -> bool { self.optimistic_check() }
>      fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {
>          self.block_on(sched, task)
>      }
>      fn unblock_from(&mut self) -> bool { self.unblock_from() }
> }
> ...
>
> How can I select on two ports of different types?

My understanding is that this code needs to be enabled to make select on 
heterogenous types work correctly. I do not know the details of this 
code but it appears that Niko has not landed a fix for #5121 yet. 
Contributions here are very welcome.


From rusty.gates at icloud.com  Thu Nov 14 17:23:07 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 03:23:07 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
Message-ID: <9C884027-E18B-4EF0-87A7-5100FBB2C507@icloud.com>


On 2013-11-15, at 2:40, Tommi <rusty.gates at icloud.com> wrote:

> On 2013-11-15, at 2:09, Tommi <rusty.gates at icloud.com> wrote:
> 
>> trait Inflate {
>>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>> 
>>     fn inflate_by(&mut self, amount: int) {
>>         *self.get_radius() += amount;
>>     }
>> }
>> 
>> trait Flatten {
>>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>> 
>>     fn release_all_air(&mut self) {
>>         *self.get_radius() = 0;
>>     }
>> }
>> 
>> struct Balloon {
>>     radius: int
>> }
>> 
>> impl Inflate for Balloon {
>>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>         &mut self.radius
>>     }
>> }
>> 
>> impl Flatten for Balloon {
>>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>         &mut self.radius
>>     }
>> }
> 
> 
> Am I correct in my assumption, that the above Rust code would translate effectively the same kind of thing as the following C++ code?
> 
> template <typename T>
> struct Inflate {
>     void inflate_by(int amount)
>     {
>         static_cast<T*>(this)->ball_radius() += amount;
>     }
> };
> 
> template <typename T>
> struct Flatten {
>     void release_all_air()
>     {
>         static_cast<T*>(this)->balloon_size() = 0;
>     }
> };
> 
> struct Balloon : Inflate<Balloon>, Flatten<Balloon> {
>     int radius;
>     
>     int& ball_radius()  { return radius; }
>     int& balloon_size() { return radius; }
> };

Sorry, second attempt... would the above Rust code translate to something like this C++ code?

struct Inflate {
    virtual void inflate_by(int amount) = 0;
};

template <typename T>
struct InflateTemp : Inflate {
    void inflate_by(int amount) override
    {
        static_cast<T*>(this)->ball_radius() += amount;
    }
};

struct Flatten {
    virtual void release_all_air() = 0;
};

template <typename T>
struct FlattenTemp : Flatten {
    void release_all_air() override
    {
        static_cast<T*>(this)->balloon_size() = 0;
    }
};

struct Balloon : InflateTemp<Balloon>, FlattenTemp<Balloon> {
    int radius;
    
    int& ball_radius()  { return radius; }
    int& balloon_size() { return radius; }
};

-Tommi

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/1ddc2985/attachment-0001.html>

From rusty.gates at icloud.com  Thu Nov 14 18:25:06 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 04:25:06 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <9C884027-E18B-4EF0-87A7-5100FBB2C507@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<9C884027-E18B-4EF0-87A7-5100FBB2C507@icloud.com>
Message-ID: <51125EAB-9254-4534-A82A-7168556B4259@icloud.com>

On 2013-11-15, at 3:23, Tommi <rusty.gates at icloud.com> wrote:

> On 2013-11-15, at 2:40, Tommi <rusty.gates at icloud.com> wrote:
> 
>> On 2013-11-15, at 2:09, Tommi <rusty.gates at icloud.com> wrote:
>> 
>>> trait Inflate {
>>>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>> 
>>>     fn inflate_by(&mut self, amount: int) {
>>>         *self.get_radius() += amount;
>>>     }
>>> }
>>> 
>>> trait Flatten {
>>>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>> 
>>>     fn release_all_air(&mut self) {
>>>         *self.get_radius() = 0;
>>>     }
>>> }
>>> 
>>> struct Balloon {
>>>     radius: int
>>> }
>>> 
>>> impl Inflate for Balloon {
>>>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>>         &mut self.radius
>>>     }
>>> }
>>> 
>>> impl Flatten for Balloon {
>>>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>>         &mut self.radius
>>>     }
>>> }
>> 
>> 
>> Am I correct in my assumption, that the above Rust code would translate effectively the same kind of thing as the following C++ code?
>> 
>> template <typename T>
>> struct Inflate {
>>     void inflate_by(int amount)
>>     {
>>         static_cast<T*>(this)->ball_radius() += amount;
>>     }
>> };
>> 
>> template <typename T>
>> struct Flatten {
>>     void release_all_air()
>>     {
>>         static_cast<T*>(this)->balloon_size() = 0;
>>     }
>> };
>> 
>> struct Balloon : Inflate<Balloon>, Flatten<Balloon> {
>>     int radius;
>>     
>>     int& ball_radius()  { return radius; }
>>     int& balloon_size() { return radius; }
>> };
> 
> Sorry, second attempt... would the above Rust code translate to something like this C++ code?
> 
> struct Inflate {
>     virtual void inflate_by(int amount) = 0;
> };
> 
> template <typename T>
> struct InflateTemp : Inflate {
>     void inflate_by(int amount) override
>     {
>         static_cast<T*>(this)->ball_radius() += amount;
>     }
> };
> 
> struct Flatten {
>     virtual void release_all_air() = 0;
> };
> 
> template <typename T>
> struct FlattenTemp : Flatten {
>     void release_all_air() override
>     {
>         static_cast<T*>(this)->balloon_size() = 0;
>     }
> };
> 
> struct Balloon : InflateTemp<Balloon>, FlattenTemp<Balloon> {
>     int radius;
>     
>     int& ball_radius()  { return radius; }
>     int& balloon_size() { return radius; }
> };

Third time's the charm. One more detail was still missing:

struct Inflate {
    virtual void inflate_by(int amount) = 0;
};

template <typename T>
struct InflateTemp : Inflate {
    void inflate_by(int amount) override
    {
        static_cast<T*>(this)->ball_radius() += amount;
    }
};

struct Flatten {
    virtual void release_all_air() = 0;
};

template <typename T>
struct FlattenTemp : Flatten {
    void release_all_air() override
    {
        static_cast<T*>(this)->balloon_size() = 0;
    }
};

struct Balloon : InflateTemp<Balloon>, FlattenTemp<Balloon> {
    int radius;
    
    void inflate_by(int amount) final override
    {
        return InflateTemp<Balloon>::inflate_by(amount);
    }
    
    void release_all_air() final override
    {
        return FlattenTemp<Balloon>::release_all_air();
    }
    
    int& ball_radius()  { return radius; }
    int& balloon_size() { return radius; }
};

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/79c6611b/attachment-0001.html>

From pnathan at vandals.uidaho.edu  Thu Nov 14 20:40:01 2013
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Thu, 14 Nov 2013 20:40:01 -0800
Subject: [rust-dev] Implementation complexity
In-Reply-To: <52856B67.5070200@cantrip.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
Message-ID: <5285A5A1.8060803@vandals.uidaho.edu>

On 11/14/13 4:31 PM, Nathan Myers wrote:
> On 11/11/2013 03:52 PM, Gaetan wrote:
>> Can we have Two rust?
>>
>> The first one would be easy to learn, easy to read, and do most of ones
>> would expect: on demand garbage collector, traits, Owned pointers,...
>>
>> The second one would include all advanced feature we actually don t
>> need everyday
> 
> This is a special case of the general design principle: push policy
> choices up, implementation details down.
> 
> There's no need to choose between M:N vs. 1:1 threading, or contiguous
> vs. segmented stacks, at the language design level.  It just takes
> different kinds of spawn(). The default chosen is whatever works most
> transparently.  Similarly, a thread with a tiny or segmented stack is
> not what we usually want, but when we (as users) determine we can live
> with its limitations and costs -- including expensive call/return
> across segment boundaries, and special ffi protocol -- there's no
> fundamental reason not to support it.
> 
> There are practical reasons, though.  Each choice offered adds to the
> complexity of the implementation, and multiplies the testing needed.
> We don't want it to be very expensive to port the rust runtime to a
> new platform, so these special modes should be limited in number, and
> optional.  Ideally a program could try to use one and, when it fails,
> fall back to the default mode. There is no need to make this falling-
> back invisible, but there are good reasons not to.
> 
> Making the choice of default mode depend on the platform (1:1 here, M:N
> there) might force complexity on users not necessarily equipped to cope
> with it, so it is best to make the defaults the same in all
> environments, wherever practical.
> 
> (Graydon et al. understand all this, but it might not be obvious to all
> of the rapidly growing readership here.)
> 
> Nathan Myers
> ncm at cantrip.org
> _______________________________________________

At the risk of increasing the current noise on the list, I want to make
a few points about the current arguments, based on my education &
experience in the embedded & critical infrastructure space.

Understand, I don't want to call anyone out; I'm not a threading expert,
and I'm not a core developer or committer, but I have watched Rust & the
mailing list and I have plans to use it in the future.  I want these
thoughts to be heard, weighed, and incorporated in the decision making
process.

* Linux is not the only platform that matters. I would actually argue
that other operating systems, in particular the embedded & RTOS space,
are the OS platforms that need to be held up as platforms to be careful
to map against. Names of such operating systems include QNX, VxWorks,
ThreadX, L4, etc. These systems are designed very carefully to be fault
tolerant, deterministic and reliable; failure in design is often
literally "not an option" with the software systems that build on them.
These are design goals that Rust, in part,  shares. Being able to
carefully manage memory, tasks, etc, and have strong type safety is
something I believe that will be very attractive to the safety critical
space (obviously after Rust proves itself).

* Not only is Linux not the only platform, assuming that *LLVM* is the
only platform is a bad idea as well. Designing for only LLVM's
capabilities ignores the possibility of a Rust compiler targeting (say)
Atmel chips. Making sufficient assumptions about a run-time model that
prevents retargeting (of course, retargeting by a funded group of
full-time engineers is what I mean, not hackable in a weekend by, say
me, a n00b) to a different non-LLVM-supported chip will also be a major
problem.

* One of the BIG problems with D uptake is the split library problem
referred to before. They could not get a comfortable standard library
for a long time, despite some extremely bright and decently famous
engineers working on D. My understanding is that it's mostly been solved
now (after what, 10 years?).  That'd be a disaster for Rust if things
split badly at the interface level.


My perspective is that the future of Rust's place is in systems that
need reliability by achieving the following characteristics: low
defects, controllable memory usage, and controllable time usage. In
short, replacing C in ten - twenty years time. I am also taking the
*corporate* perspective, which is partially driven by risk mitigation
and caution; seeing core contributors arguing about runtime
implementation *without* talking about systems much beyond Linux/LLVM is
concerning.


In summary, please remember the embedded & "hidden" world of computing
in your discussions.

-- 
Best Regards,
Paul Nathan

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/c65016d4/attachment.sig>

From pcwalton at mozilla.com  Thu Nov 14 20:52:19 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 15 Nov 2013 13:52:19 +0900
Subject: [rust-dev] Implementation complexity
In-Reply-To: <5285A5A1.8060803@vandals.uidaho.edu>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>	<52856B67.5070200@cantrip.org>
	<5285A5A1.8060803@vandals.uidaho.edu>
Message-ID: <5285A883.6090008@mozilla.com>

On 11/15/13 1:40 PM, Paul Nathan wrote:
> * Linux is not the only platform that matters. I would actually argue
> that other operating systems, in particular the embedded & RTOS space,
> are the OS platforms that need to be held up as platforms to be careful
> to map against. Names of such operating systems include QNX, VxWorks,
> ThreadX, L4, etc. These systems are designed very carefully to be fault
> tolerant, deterministic and reliable; failure in design is often
> literally "not an option" with the software systems that build on them.
> These are design goals that Rust, in part,  shares. Being able to
> carefully manage memory, tasks, etc, and have strong type safety is
> something I believe that will be very attractive to the safety critical
> space (obviously after Rust proves itself).

I agree. Note that the pthreads API was, as far as I'm aware, explicitly 
designed to be implementable by both M:N and 1:1 scheduling modes. And, 
indeed, there have been shipping implementations of pthreads on both M:N 
and 1:1 threading models. So we're essentially just following in POSIX's 
footsteps here.

> * Not only is Linux not the only platform, assuming that *LLVM* is the
> only platform is a bad idea as well. Designing for only LLVM's
> capabilities ignores the possibility of a Rust compiler targeting (say)
> Atmel chips. Making sufficient assumptions about a run-time model that
> prevents retargeting (of course, retargeting by a funded group of
> full-time engineers is what I mean, not hackable in a weekend by, say
> me, a n00b) to a different non-LLVM-supported chip will also be a major
> problem.

Agreed.

> * One of the BIG problems with D uptake is the split library problem
> referred to before. They could not get a comfortable standard library
> for a long time, despite some extremely bright and decently famous
> engineers working on D. My understanding is that it's mostly been solved
> now (after what, 10 years?).  That'd be a disaster for Rust if things
> split badly at the interface level.

I agree, and I would like to prevent divergence. Divergence of 
*implementation* is OK and probably inevitable if Rust succeeds; 
divergence of API for no reason can harm the ecosystem.

Patrick


From danielmicay at gmail.com  Thu Nov 14 20:54:50 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 14 Nov 2013 23:54:50 -0500
Subject: [rust-dev] Implementation complexity
In-Reply-To: <5285A5A1.8060803@vandals.uidaho.edu>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org> <5285A5A1.8060803@vandals.uidaho.edu>
Message-ID: <CA+DvKQLkRnD8Mbnk9OOhevxYvjxL0YiBGMr-FhJ6VnKyej0k_w@mail.gmail.com>

On Thu, Nov 14, 2013 at 11:40 PM, Paul Nathan
<pnathan at vandals.uidaho.edu> wrote:
>
> * Linux is not the only platform that matters. I would actually argue
> that other operating systems, in particular the embedded & RTOS space,
> are the OS platforms that need to be held up as platforms to be careful
> to map against. Names of such operating systems include QNX, VxWorks,
> ThreadX, L4, etc. These systems are designed very carefully to be fault
> tolerant, deterministic and reliable; failure in design is often
> literally "not an option" with the software systems that build on them.
> These are design goals that Rust, in part,  shares. Being able to
> carefully manage memory, tasks, etc, and have strong type safety is
> something I believe that will be very attractive to the safety critical
> space (obviously after Rust proves itself).

Is being able to handle dynamic resource exhaustion failures
important, or are the resources (memory, threads, file descriptors)
usually allocated up-front?

> * Not only is Linux not the only platform, assuming that *LLVM* is the
> only platform is a bad idea as well. Designing for only LLVM's
> capabilities ignores the possibility of a Rust compiler targeting (say)
> Atmel chips. Making sufficient assumptions about a run-time model that
> prevents retargeting (of course, retargeting by a funded group of
> full-time engineers is what I mean, not hackable in a weekend by, say
> me, a n00b) to a different non-LLVM-supported chip will also be a major
> problem.

Adding a backend to LLVM will be much easier than porting Rust to
another compiler and maintaining it.

> * One of the BIG problems with D uptake is the split library problem
> referred to before. They could not get a comfortable standard library
> for a long time, despite some extremely bright and decently famous
> engineers working on D. My understanding is that it's mostly been solved
> now (after what, 10 years?).  That'd be a disaster for Rust if things
> split badly at the interface level.

An alternative library is a far better situation than not having good
real-time/embedded/freestanding support. I'll have a rejected pull
request or RFC to point at for any divergence taken by rust-core, and
it won't make any pointless bikeshed changes like renaming an API.

From pcwalton at mozilla.com  Thu Nov 14 21:44:06 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 15 Nov 2013 14:44:06 +0900
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CA+DvKQLkRnD8Mbnk9OOhevxYvjxL0YiBGMr-FhJ6VnKyej0k_w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>	<52856B67.5070200@cantrip.org>
	<5285A5A1.8060803@vandals.uidaho.edu>
	<CA+DvKQLkRnD8Mbnk9OOhevxYvjxL0YiBGMr-FhJ6VnKyej0k_w@mail.gmail.com>
Message-ID: <5285B4A6.4050606@mozilla.com>

On 11/15/13 1:54 PM, Daniel Micay wrote:
> An alternative library is a far better situation than not having good
> real-time/embedded/freestanding support. I'll have a rejected pull
> request or RFC to point at for any divergence taken by rust-core, and
> it won't make any pointless bikeshed changes like renaming an API.

Glad to see that, and thanks.

Patrick


From pnathan at vandals.uidaho.edu  Thu Nov 14 21:47:01 2013
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Thu, 14 Nov 2013 21:47:01 -0800
Subject: [rust-dev] Implementation complexity
In-Reply-To: <CA+DvKQLkRnD8Mbnk9OOhevxYvjxL0YiBGMr-FhJ6VnKyej0k_w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<528153D1.1030003@mozilla.com>
	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>
	<52856B67.5070200@cantrip.org>
	<5285A5A1.8060803@vandals.uidaho.edu>
	<CA+DvKQLkRnD8Mbnk9OOhevxYvjxL0YiBGMr-FhJ6VnKyej0k_w@mail.gmail.com>
Message-ID: <5285B555.8080304@vandals.uidaho.edu>

On 11/14/13 8:54 PM, Daniel Micay wrote:
> On Thu, Nov 14, 2013 at 11:40 PM, Paul Nathan
> <pnathan at vandals.uidaho.edu> wrote:
>>
>> * Linux is not the only platform that matters. I would actually argue
>> that other operating systems, in particular the embedded & RTOS space,
>> are the OS platforms that need to be held up as platforms to be careful
>> to map against. Names of such operating systems include QNX, VxWorks,
>> ThreadX, L4, etc. These systems are designed very carefully to be fault
>> tolerant, deterministic and reliable; failure in design is often
>> literally "not an option" with the software systems that build on them.
>> These are design goals that Rust, in part,  shares. Being able to
>> carefully manage memory, tasks, etc, and have strong type safety is
>> something I believe that will be very attractive to the safety critical
>> space (obviously after Rust proves itself).
> 
> Is being able to handle dynamic resource exhaustion failures
> important, or are the resources (memory, threads, file descriptors)
> usually allocated up-front?

Depends upon the size of the system. For a hard real-time task or device
(e.g., aircraft, car response, medical system), it is better to allocate
up-front, as that simplifies your analysis of interrupts and timing.
However, components may have soft real-time requirements or no real-time
requirements; these are more likely to have dynamic allocation. I have
seen a real-time Linux system where a thread was designated real-time
and other threads were catch-as-catch can. In such a system, it is
likely that as hardware designs progress, the hard RT
thread/task/process will be pinned to a core/cpu and the rest will sit
on another core/cpu in order to guarantee that there is no contention
for the RT thread.  Keep in mind that in hard real-time applications,
MMUs have been disabled in past designs (this is for guaranteeing time
of execution) and will probably continue to be disabled for certain CPUs.

> 
>> * Not only is Linux not the only platform, assuming that *LLVM* is the
>> only platform is a bad idea as well. Designing for only LLVM's
>> capabilities ignores the possibility of a Rust compiler targeting (say)
>> Atmel chips. Making sufficient assumptions about a run-time model that
>> prevents retargeting (of course, retargeting by a funded group of
>> full-time engineers is what I mean, not hackable in a weekend by, say
>> me, a n00b) to a different non-LLVM-supported chip will also be a major
>> problem.
> 
> Adding a backend to LLVM will be much easier than porting Rust to
> another compiler and maintaining it.

If Rust attains ANSI/IEC/ISO standard and becomes used on the
multi-decade scale, I would expect multiple implementations of Rust with
separate codebases.

> 
>> * One of the BIG problems with D uptake is the split library problem
>> referred to before. They could not get a comfortable standard library
>> for a long time, despite some extremely bright and decently famous
>> engineers working on D. My understanding is that it's mostly been solved
>> now (after what, 10 years?).  That'd be a disaster for Rust if things
>> split badly at the interface level.
> 
> An alternative library is a far better situation than not having good
> real-time/embedded/freestanding support. I'll have a rejected pull
> request or RFC to point at for any divergence taken by rust-core, and
> it won't make any pointless bikeshed changes like renaming an API.
> .

Multiplicity of implementation is fine (glibc, eglibc); divergence of
policy & interface is not. If a reimplemented standard library shows up
designed to not GC & can be plugged into QNX threads but conforms to the
standard API, glorious.   I think the trait system should support this
well. :-)


-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131114/9843caf3/attachment-0001.sig>

From ml at isaac.cedarswampstudios.org  Thu Nov 14 23:46:47 2013
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Fri, 15 Nov 2013 02:46:47 -0500
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <51125EAB-9254-4534-A82A-7168556B4259@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<52830794.3070504@mozilla.com>	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>	<9C884027-E18B-4EF0-87A7-5100FBB2C507@icloud.com>
	<51125EAB-9254-4534-A82A-7168556B4259@icloud.com>
Message-ID: <5285D167.5070605@isaac.cedarswampstudios.org>

On 11/14/2013 09:25 PM, Tommi wrote:
>>>
>>>> trait Inflate {
>>>>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>>>
>>>>     fn inflate_by(&mut self, amount: int) {
>>>>         *self.get_radius() += amount;
>>>>     }
>>>> }
>>>> [...]

> Third time's the charm. One more detail was still missing:
>
> struct Inflate {
> virtual void inflate_by(int amount) = 0;
> };
> [...]

Thing is, if all you have is an Inflate*, you're going to have to make a 
virtual function call to access that member.  The goal is to have member 
access that works across several similar concrete types, without the 
speed cost of accessing a vtable.

(You could do it with a struct containing shared information plus a 
discriminated union (Rust enum) of all types that would have implemented 
the trait, but I imagine that has other downsides.)

-Isaac


From oren at ben-kiki.org  Thu Nov 14 23:47:12 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 15 Nov 2013 09:47:12 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
Message-ID: <CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>

In your code, when providing a default implementation for `inflate_by`, you
are invoking the trait (hence "virtual") method `get_radius`. If the
compiler compiles `inflate_by` when seeing just the `Inflate` source code,
then this must be translated to an indirect call through the vtable.

The point of anonymous members (and, to a greater extent, of the single
inheritance) is to ensure that access to data members is just that, without
any function calls.

To achieve that with the approach you described, the compiler will need to
re-compile `inflate_by` for each and every struct that implements it; only
then it would be able to inline `get_radius`.

Is this what the Rust compiler does today? I have no specific knowledge of
the answer, but the simplest thing for the compiler would be to
keep `get_radius` as a virtual function call.

Doing otherwise would require quite a bit of machinery (e.g., what
if `Inflate` is defined in another crate, and all we have is its
fully-compiled shared object file? There would need to be some "extra
stuff" available to the compiler to do this re-compilation, as the source
is not available at that point).

Therefore I suspect that this approach would suffer from significant
performance issues.


On 2013-11-15, at 2:09, Tommi <rusty.gates at icloud.com> wrote:
>
> trait Inflate {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>
>     fn inflate_by(&mut self, amount: int) {
>         *self.get_radius() += amount;
>     }
> }
>
> trait Flatten {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int;
>
>     fn release_all_air(&mut self) {
>         *self.get_radius() = 0;
>     }
> }
>
> struct Balloon {
>     radius: int
> }
>
> impl Inflate for Balloon {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>         &mut self.radius
>     }
> }
>
> impl Flatten for Balloon {
>     fn get_radius<'s>(&'s mut self) -> &'s mut int {
>         &mut self.radius
>     }
> }
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/c4694983/attachment.html>

From alex at crichton.co  Fri Nov 15 00:09:28 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 15 Nov 2013 00:09:28 -0800
Subject: [rust-dev] Rethinking Linking in Rust
Message-ID: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>

I've been thinking about static linking recently, along with a little bit of
linking in general, and I wanted to see what others thought.

# The Goal

Primarily, I believe that if desired, rustc should be able to generate an
executable or dynamic library with no dependence on any rust libraries. This
includes things like librustrt and libextra. Rust shouldn't be striving to lift
dependence on system libraries, that'll come at later times if need be.

Additionally, rustc should be able to generate libfoo.a where libfoo.a has no
dependence on any rust libraries. This library can then be statically linked to
another application.

# Intermediate static libraries

I personally know of no way to create a static library from a dynamic one, so to
achieve this we would need to distribute libstd and libextra in some form that
is not a shared library. This problem not only applies to libstd, but also to
any rust library which wants to be statically linked.

The first natural conclusion for for an intermediate format would be a .a file
itself. Why not distribute libstd.a along with libstd.so. After all, a .a is
only an archive which in our case would contain one .o file. In thinking about
this though, I don't think that this is the best format. The main idea of
providing intermediate .a files is to allow linkage to them via the normal
system linker. To be usable, this would mean that all .a files rust generates
would have to have their own statically linked version of libstd or otherwise
everyone will have to find where libstd is guess the name and hash attached to
it. This is infeasible for arbitrary libraries which could have arbitrarily many
dependencies.

# Native Libraries

One part of linking which rust cannot forget is native libraries. Right now,
native libraries are always linked against when compiling a local crate, but no
native library dependencies are propagated among crates.

Due to the nature of a static library and what I assume is the file format
itself, a static rust library cannot link to its dependent dynamic libraries. We
can, however, resolve all native static dependencies at compile time.

# A Scheme for Linking

With the above knowledge, I would propose the following linkage model for rust.

There are four types of files that the rust compiler will generate:

1. An executable
2. A dynamic library (.so, .dylib, .dll)
3. A "rust" static library (.rlib)
4. A regular static library (.a, .lib)

The "rust language" would ship with dynamic library files as well as .rlib
files. There would be no .a files in the distribution.

A rust static library would be a format defined by rust that is not available
for or intended for external use. It is meant to be beneficial to the rust
compiler and that's it. It just so happens that their first incarnation would be
created similarly to `cp foo.o foo.rlib`.

In addition to these changes, the linkage attributes would change to be as
follows:

* #[link_args] becomes gated behind a feature flag. I believe that this is still
  a very useful ability to pass arbitrary flags to the linker, but this is *not*
  a sanctioned way of doing so at all because of how platform specific it is

* #[link(...)] becomes the new method of specifying linkage semantics on extern
  blocks, and it may be used similarly to link_args today

  * #[link(name = "foo")] specifies that this crate links to native library
    `foo`
  * #[link(once)] implies that the native library is a static library, hence it
    *must* be linked against in the current compilation, regardless of the
    output format

  Omission of `link(once)` assumes that the library is available at all
  destinations, and it may not be linked against in the current compilation
  unit.

## The Linkage Step

To see how this affects how artifacts are created, I'd like to go into detail
about how each of the four output artifacts all interact with one another by
describing the linkage phase of each output. For each of these, remember that
the compiler's output is one .o file for each crate. Also remember that all rust
libraries will always link to all upstream rust libraries.

### Linking Executables and Dynamic Libraries

These two cases are very similar because they are creating the actual "result
artifact" in terms of a file which will have no more linkage performed on it.
The following components must be linked in to produce the artifact:

* The local .o file
* All local native dependencies
* All upstream rust libraries (dynamic and static)
* All non-once (dynamic) native libraries of upstream static crates. More on
  this later

The result artifact needs to be a fully resolved destination artifact. The point
of this is to have a dynamic dependency on all upstream dynamic libraries, and
all upstream static libraries will have been sucked in to create the target.

### Creating rust static libraries (.rlib files)

As mentioned above, these files are similar to the compiler's .o output. The
only other component which can be considered for inclusion in this .o file is
all native static library dependencies. These are encoded as #[link(once)] in
linkage attributes. The reason for doing this is that it's likely to be common
to have a local static library which is not available in distribution, but is
always available for the build process. Examples for the compiler include
libsundown, libuv, libuv_support, and maybe librustrt.

The .rlib file will be created by using ld's -r flag. This output will then have
all native static dependencies resolved, but remember that no rust dependencies
were part of this linkage process. Whenever this .rlib file is used, all of its
dependencies are encoded in the metadata and they're all sucked in at the end as
well.

The goal of not pulling in all rust dependencies is to avoid finding a static
copy of libstd in all .rlib files everywhere.

### Creating a system static library (.a or .lib)

The whole point of being able to do this is so that a rust component can be
statically linked into another application. The idea behind this mode of
compilation is to be just as much of a destination artifact as an executable or
dynamic library. The rust compiler will never attempt to link against
rust-generated .a files (it has .rlib files to look for). The .a files are
purely meant for external usage.

Again though, due to the nature of the .a format, we cannot be as comprehensive
in our dependency resolution as we were in the above cases. The first thing to
consider is all inputs to this file:

* The compiler's output .o file
* All local native static libraries
* All upstream rust .rlib files

Note how there is no mention of upstream dynamic library dependencies. Sadly, I
know of encoding those dependencies in this .a output format. I would propose
the compiler printing a warning when this is performed such that when undefined
references are found you at least have a suggestion of what dynamic libraries
you need to link against.

## Static vs Dynamic

This scheme outlines the ability to manage static and dynamic native libraries,
but it would mean that we're going to start introducing static and dynamic rust
libraries in the same location. I would propose that the compiler automatically
favors static linkage over dynamic linkage due to various rust ABI issues. This
default could be switched in the future, but it simply means that if the
compiler finds a .so and a .rlib, it will suck in the .rlib before sucking in
the .so.

## Compiler UI

If we have a scheme like this, we certainly need a method of managing it from
the command line. I would propose dropping all linkage related flags we have
today, and starting over with the following:

* --rlib, --dylib, --staticlib. These three options are stackable, and control
  the output format of the compiler. If nothing is specified, then an executable
  is assumed. The reason that these are stackable is becuase it is possible
  to create multiple artifacts from one compilation instead of having to
  recompile

* -Z print-link-args. This is the same as it is today

# Conclusion

I originally thought that this would be a proposal for adding static linking,
but this has kinda become more of a makeover of rust's current linkage model. I
believe that this scheme will solve the "static library" problem as well as
still accomodating the dynamic library approach that we have today. I wanted to
get this all down in writing, and I feel like this is certainly concrete enough
to act upon, but before doing so this should definitely be discussed.

What are others' thoughts on this? Is this too complex of a system? Is there a
glaring omission of use cases?

Hopefully soon we can generate a rust library with no dynamic rust dependencies!

---

As a side node, after writing all this up, I remembered LTO as an
option for generating libraries. I don't think I know enough about LTO
to be able to say whether it would fit in this system or not, but my
basic understanding is that an LTO library is just "IR in a box". We
could add a --lto output option which has pretty much the same
semantics as the --rlib option, but with a different format. Again
though, I haven't thought how native libraries would fit into that
scenario, but I believe that we could fairly easily accommodate LTO in
a system like this.

From rusty.gates at icloud.com  Fri Nov 15 01:42:35 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 11:42:35 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5285D167.5070605@isaac.cedarswampstudios.org>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<9C884027-E18B-4EF0-87A7-5100FBB2C507@icloud.com>
	<51125EAB-9254-4534-A82A-7168556B4259@icloud.com>
	<5285D167.5070605@isaac.cedarswampstudios.org>
Message-ID: <CBA62C77-8671-4C7B-A430-DB68CAAC5C17@icloud.com>


On 2013-11-15, at 9:46, Isaac Dupree <ml at isaac.cedarswampstudios.org> wrote:

> On 11/14/2013 09:25 PM, Tommi wrote:
>>>> 
>>>>> trait Inflate {
>>>>>    fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>>>> 
>>>>>    fn inflate_by(&mut self, amount: int) {
>>>>>        *self.get_radius() += amount;
>>>>>    }
>>>>> }
>>>>> [...]
> 
>> Third time's the charm. One more detail was still missing:
>> 
>> struct Inflate {
>> virtual void inflate_by(int amount) = 0;
>> };
>> [...]
> 
> Thing is, if all you have is an Inflate*, you're going to have to make a virtual function call to access that member.

But that's not any different from Rust. If all you have is @Inflate, then any method call through that is a virtual function call.


> The goal is to have member access that works across several similar concrete types, without the speed cost of accessing a vtable.

In my C++ example, if you have an object of the concrete type Balloon, then I don't think there's any vtable involved in a call to balloon->inflate_by(x).

From dbau.pp at gmail.com  Fri Nov 15 01:47:13 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 15 Nov 2013 20:47:13 +1100
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>	<52830794.3070504@mozilla.com>	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
Message-ID: <5285EDA1.6060801@gmail.com>

On 15/11/13 18:47, Oren Ben-Kiki wrote:
> In your code, when providing a default implementation for 
> `inflate_by`, you are invoking the trait (hence "virtual") 
> method `get_radius`. If the compiler compiles `inflate_by` when seeing 
> just the `Inflate` source code, then this must be translated to an 
> indirect call through the vtable.
>
> The point of anonymous members (and, to a greater extent, of the 
> single inheritance) is to ensure that access to data members is just 
> that, without any function calls.
>
> To achieve that with the approach you described, the compiler will 
> need to re-compile `inflate_by` for each and every struct that 
> implements it; only then it would be able to inline `get_radius`.
>
> Is this what the Rust compiler does today? I have no specific 
> knowledge of the answer, but the simplest thing for the compiler would 
> be to keep `get_radius` as a virtual function call.


As I understand it, default methods are specialised/monomorphised for 
each type for which the trait is implemented. The only time a virtual 
call ever happens is when one explicitly has a trait object.


Huon

>
> Doing otherwise would require quite a bit of machinery (e.g., what 
> if `Inflate` is defined in another crate, and all we have is its 
> fully-compiled shared object file? There would need to be some "extra 
> stuff" available to the compiler to do this re-compilation, as the 
> source is not available at that point).
>
> Therefore I suspect that this approach would suffer from significant 
> performance issues.
>
>
>     On 2013-11-15, at 2:09, Tommi <rusty.gates at icloud.com
>     <mailto:rusty.gates at icloud.com>> wrote:
>
>>     trait Inflate {
>>         fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>
>>         fn inflate_by(&mut self, amount: int) {
>>     *self.get_radius() += amount;
>>         }
>>     }
>>
>>     trait Flatten {
>>         fn get_radius<'s>(&'s mut self) -> &'s mut int;
>>
>>         fn release_all_air(&mut self) {
>>     *self.get_radius() = 0;
>>         }
>>     }
>>
>>     struct Balloon {
>>         radius: int
>>     }
>>
>>     impl Inflate for Balloon {
>>         fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>             &mut self.radius
>>         }
>>     }
>>
>>     impl Flatten for Balloon {
>>         fn get_radius<'s>(&'s mut self) -> &'s mut int {
>>             &mut self.radius
>>         }
>>     }
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/dc58671c/attachment.html>

From rusty.gates at icloud.com  Fri Nov 15 01:55:34 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 11:55:34 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
Message-ID: <C4047954-1868-48C5-8C6A-35D2375B4ED6@icloud.com>

On 2013-11-15, at 9:47, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> In your code, when providing a default implementation for `inflate_by`, you are invoking the trait (hence "virtual") method `get_radius`. If the compiler compiles `inflate_by` when seeing just the `Inflate` source code, then this must be translated to an indirect call through the vtable.
> 
> The point of anonymous members (and, to a greater extent, of the single inheritance) is to ensure that access to data members is just that, without any function calls.
> 
> To achieve that with the approach you described, the compiler will need to re-compile `inflate_by` for each and every struct that implements it; only then it would be able to inline `get_radius`.
> 
> Is this what the Rust compiler does today? I have no specific knowledge of the answer, but the simplest thing for the compiler would be to keep `get_radius` as a virtual function call.
> 
> Doing otherwise would require quite a bit of machinery (e.g., what if `Inflate` is defined in another crate, and all we have is its fully-compiled shared object file? There would need to be some "extra stuff" available to the compiler to do this re-compilation, as the source is not available at that point).
> 
> Therefore I suspect that this approach would suffer from significant performance issues.

Okay, that makes sense. I wonder if LLVM's de-virtualization capabilities would be of any help in all this.

From igor at mir2.org  Fri Nov 15 02:40:33 2013
From: igor at mir2.org (Igor Bukanov)
Date: Fri, 15 Nov 2013 11:40:33 +0100
Subject: [rust-dev] C# async for Rust
In-Reply-To: <CA+DvKQLhFSE_uwmApo0j7jzJQxCcgGyBFAjmGy0goMr0U5rV5g@mail.gmail.com>
References: <BAY170-W52ADC6D59E60DEE636A047F8F90@phx.gbl>
	<CA+DvKQ+fHKtg09j-Dgo1mKdwS9CjzdZ+dgq8CNz3tfgxxW0H2A@mail.gmail.com>
	<l61nh5$d81$1@ger.gmane.org>
	<CA+DvKQL+nKqxaY_xN+QoKM7-=LNNV4o-09GiY+=S5i3jpjh9uQ@mail.gmail.com>
	<CADd11yVmGaaETMJx7A3NQq1YyX--eSC0tSv09es6s8Oyo8qcyQ@mail.gmail.com>
	<CA+DvKQLhFSE_uwmApo0j7jzJQxCcgGyBFAjmGy0goMr0U5rV5g@mail.gmail.com>
Message-ID: <CADd11yVr+kTjyoWydNu7AqzpN2-W8NpNfey5i58mvc1H+Lz50w@mail.gmail.com>

On 14 November 2013 23:01, Daniel Micay <danielmicay at gmail.com> wrote:
> Correct, you won't get optimal performance with 1 task per
> request/client across every platform. For non-socket I/O, it will be
> as close as you can get to optimal on Linux except in terms of the
> huge virtual memory consumption.

But one *rarely* gets an optimal performance with 1 one native task
per request. As you pointed out, on Linux this is only suitable if the
request is doing a lot of file IO with little computations. On Windows
my impression is that UMS is really a tool that one should use if
writing anything related to IO in asynchronous style is not possible
due to compatibility requirements or when one need to deal with
potentially long-running computations. As threads are expensive,
performing applications there should use non-blocking API, not rely on
UMS. Hence the introduction of the async keyword to facilitate that
style of programming.

> The performance with 1:1 threading and user-mode scheduling will match
> M:N threading

That Google talk about UMS on Linux acknowledged UMS will still not
match performance of epoll-like API as while UMS eliminates scheduling
cost, it does not eliminate context switching cost. Now, M:N threading
on Linux also does not eliminate context-switching cost, but it can be
made much smaller as with it context switches can be compiler-assisted
and can take advantage of a particular language runtime.

> You will get poor performance on Linux with an async/await scheme for
> anything but sockets compared to the 1:1 user-mode scheduling, and
> even then it's not a great match for the underlying ready-based API.

ASFAICS async-style continuation code transformation precisely "a
great match for the underlying ready-based API". Which brings back the
initial question - should Rust offer that since it is known that on
Windows it will offer optimal performance for most if not all IO and
since on Linux this is optimal for socket IO.

From niko at alum.mit.edu  Fri Nov 15 02:45:49 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 15 Nov 2013 05:45:49 -0500
Subject: [rust-dev] About owned pointer
In-Reply-To: <8817533.0HqEL1HLOK@tph-l10036>
References: <CANK7tAH7qnc6WauWPihjRwDZ6vMdJCBCZFNHAy2BB9YvNNOXEQ@mail.gmail.com>
	<CAH8Jz7hQCAT6MpeCfBZANuWbtecKXeSWbEvQmL3wdUjLZFTimQ@mail.gmail.com>
	<20131108113323.GC23082@Mr-Bennet> <8817533.0HqEL1HLOK@tph-l10036>
Message-ID: <20131115104549.GA24821@Mr-Bennet>

On Fri, Nov 08, 2013 at 04:47:24PM +0100, Diggory Hardy wrote:
> What's wrong with sticking with convention here? E.g. C++'s `string` and 
> `vector<T>` are objects containing two or three pointers. D's arrays and 
> `string` act the same way. Even C's dynamic arrays (`int x[]`) can be thought 
> of the same way (if one avoids thinking of them as pointers).

This question got me thinking. I wrote up a blog post exploring it:

http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/

The takeaway for me right now is sort of "Yes, we could do it that
way. It makes some things simpler but a number of other features
harder, some of which we really have to figure out how to resolve."



regards,

Niko

From niko at alum.mit.edu  Fri Nov 15 03:01:14 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 15 Nov 2013 06:01:14 -0500
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
Message-ID: <20131115110114.GC24821@Mr-Bennet>

A few quick questions and comments:

On Fri, Nov 15, 2013 at 12:09:28AM -0800, Alex Crichton wrote:
> I've been thinking about static linking recently, along with a little bit of
> linking in general, and I wanted to see what others thought.
> 
> # The Goal
> 
> Primarily, I believe that if desired, rustc should be able to generate an
> executable or dynamic library with no dependence on any rust libraries. This
> includes things like librustrt and libextra. Rust shouldn't be striving to lift
> dependence on system libraries, that'll come at later times if need be.

It seems like you *are* striving to lift dependencies on non-rust
libraries, though. For example, you mention having libuv be statically
imported into a .rlib file etc. Or did I misunderstand?

> As mentioned above, these files are similar to the compiler's .o output. The
> only other component which can be considered for inclusion in this .o file is
> all native static library dependencies. These are encoded as #[link(once)] in
> linkage attributes. The reason for doing this is that it's likely to be common
> to have a local static library which is not available in distribution, but is
> always available for the build process. Examples for the compiler include
> libsundown, libuv, libuv_support, and maybe librustrt.

Does this imply that all Rust programs will be executed with whatever
specific version of libsundown and libuv was produced as part of the
Rust compiler build process? (I'm not implying this is a bad thing,
necessarily, just trying to understand)

> I would propose that the compiler automatically favors static
> linkage over dynamic linkage due to various rust ABI issues.

Could you elaborate? What issues are you thinking of?

> This default could be switched in the future, but it simply means
> that if the compiler finds a .so and a .rlib, it will suck in the
> .rlib before sucking in the .so.

What does "suck in" here mean? I don't think this is as simple as what
file the compiler opens, but rather it means that by default you'd get
static linking and hence wouldn't require the .so to be distributed
but also couldn't support independent library version upgrades, right?

> What are others' thoughts on this? Is this too complex of a system? Is there a
> glaring omission of use cases?

I think it generally makes sense and doesn't seem overly complicated,
though I'm not sure if there are missing use cases or not.

> As a side node, after writing all this up, I remembered LTO as an
> option for generating libraries. I don't think I know enough about LTO
> to be able to say whether it would fit in this system or not, but my
> basic understanding is that an LTO library is just "IR in a box". We
> could add a --lto output option which has pretty much the same
> semantics as the --rlib option, but with a different format. Again
> though, I haven't thought how native libraries would fit into that
> scenario, but I believe that we could fairly easily accommodate LTO in
> a system like this.

Unless I'm missing something, it seems like what we would want to do
is to have the .rlib file contain LLVM IR, at least for the Rust code
that was compiled / statically linked against. If we can, I think we
should just make LTO happen by default whenver you statically link,
rather than having it be a separate option, but it is fine if that
doesn't work yet in the first version (e.g., because .rlib is just a
.o file). Still I agree that your scheme accommodates it just fine.


Niko

From danielmicay at gmail.com  Fri Nov 15 03:34:19 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 06:34:19 -0500
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <C4047954-1868-48C5-8C6A-35D2375B4ED6@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<52814F8F.3020609@mozilla.com>
	<CADJiDhus3awmSDW1cUGqfbfYbF6fqHYrBCu2=OuqX4YKKQg0qw@mail.gmail.com>
	<5281DC30.8040402@mozilla.com>
	<81B5FB1E-F1B2-4AF7-A12B-302C436887B5@sb.org>
	<52829BF8.3000200@mozilla.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<C4047954-1868-48C5-8C6A-35D2375B4ED6@icloud.com>
Message-ID: <CA+DvKQ+JT9na+q3JGaVe43pd3UQ09Qm8Wr7=K-H_8X+_7x836w@mail.gmail.com>

On Fri, Nov 15, 2013 at 4:55 AM, Tommi <rusty.gates at icloud.com> wrote:
>
> Okay, that makes sense. I wonder if LLVM's de-virtualization capabilities would be of any help in all this.

It's not a great thing to depend on, because it doesn't work in
anything but a very simple case. As soon as there's a store to any
pointer with an address determined at runtime, it won't work.

There are ways to communicate more information in the frontend (alias
analysis, llvm.invariant), but we don't do them and I don't know how
much it will help.

From jfager at gmail.com  Fri Nov 15 03:45:14 2013
From: jfager at gmail.com (Jason Fager)
Date: Fri, 15 Nov 2013 06:45:14 -0500
Subject: [rust-dev] select on std::comm::Port and different types
In-Reply-To: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>
References: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>
Message-ID: <CAFEbTaXWVWwbiKwW8V=6sr9OE6wsiE=mnQFf3LzhengW8fGPeQ@mail.gmail.com>

I solved these problems somewhat clunkily using an enum:

https://github.com/jfager/d3cap/blob/master/multicast.rs

It's not pretty but it gets the job done until the various issues around
this get worked out.



On Thursday, November 14, 2013, Diego Ongaro wrote:

> Hi all,
>
> My program starts a bunch of tasks, then I want the main task to both
> receive ctrl-c signals and receive results from the children. The
> signal will come from a std::rt::io::signal::Listener's port, which is
> an std::comm::Port<Signum>. The child results will come from a
> std::comm::Port<~[uint]>.
>
> My first problem is that std::comm::Port doesn't implement
> std::select::Select. It looks like std::rt::comm::Port does, and
> std::comm::Port is just a small wrapper around that, but
> std::comm::Port makes its internal std::rt::comm::Port private. Is
> there any way to select on a std::comm::Port? (And what's the
> difference between a std::rt::comm::Port and a std::comm::Port?)
>
> My second problem is that std::select::select() doesn't seem to
> support selecting from ports with different types. Naively, I tried
> select([p1, p2]), but that expects p1 and p2 to have the same type:
> error: mismatched types: expected
> `std::rt::comm::Port<std::rt::io::signal::Signum>` but found
> `std::rt::comm::Port<~[uint]>` (expected enum
> std::rt::io::signal::Signum but found vector)
> It'll need dynamic dispatch, so I tried: select([p1 as &Select, p2 as
> &Select]). However, this doesn't work since &Select doesn't implement
> Select:
> error: failed to find an implementation of trait std::select::Select
> for &std::select::Select<no-bounds>
>
> There's some commented out code that may be related in select.rs,
> though it's hard for me to know where this stands:
> /* FIXME(#5121, #7914) This all should be legal, but rust is not
> clever enough yet.
>
> impl <'self> Select for &'self mut Select {
>     fn optimistic_check(&mut self) -> bool { self.optimistic_check() }
>     fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) ->
> bool {
>         self.block_on(sched, task)
>     }
>     fn unblock_from(&mut self) -> bool { self.unblock_from() }
> }
> ...
>
> How can I select on two ports of different types?
>
> Thanks,
> Diego
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org <javascript:;>
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/47d0781a/attachment.html>

From oren at ben-kiki.org  Fri Nov 15 03:54:18 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 15 Nov 2013 13:54:18 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5285EDA1.6060801@gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
Message-ID: <CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>

On Fri, Nov 15, 2013 at 11:47 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  As I understand it, default methods are specialised/monomorphised for
> each type for which the trait is implemented. The only time a virtual call
> ever happens is when one explicitly has a trait object.
>

That would be awesome, if it were true; it is quite a trick to pull that
off when the default methods are implemented in a different crate. Can
someone provide an authoritative answer on this?

Also, C++ faces the problem of providing a single copy of monomorphised
functions (for templates). This is done during the link phase and AFAIK is
one of the causes of C++ links taking a painfully long time. Will Rust
suffer from the same problem?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/2d4576e9/attachment.html>

From denis.spir at gmail.com  Fri Nov 15 04:27:47 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 15 Nov 2013 13:27:47 +0100
Subject: [rust-dev] typed loop variables & int num types
Message-ID: <52861343.30305@gmail.com>

These are 2 points of secondary importance (or even less).

What about the following pattern:
     for x:Type in expr {
         // proceed with x
     }
as equivalent to:
     for y in expr {
         let x = y as Type;
         // proceed with x
     }
both for iterator loops and range loops?
Actually, my need is to have uint's or u8's in range loops, while the default is 
int.

I'm also unhappy with "let n = 1;" yielding by default an int instead of an 
uint. I would suggest that if an int value is unsigned, the default type is 
uint. A signed int is, semantically, a difference, thus always signed: to get a 
default signed int, just write "let n = +1;". Seems both logical and 
self-documenting, imo.

Again, quite unimportant and definitely not of high priority. Just sending this 
for the record.

Denis

From danielmicay at gmail.com  Fri Nov 15 04:30:10 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 07:30:10 -0500
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
Message-ID: <CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>

On Fri, Nov 15, 2013 at 6:54 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
> That would be awesome, if it were true; it is quite a trick to pull that off
> when the default methods are implemented in a different crate. Can someone
> provide an authoritative answer on this?
>
> Also, C++ faces the problem of providing a single copy of monomorphised
> functions (for templates). This is done during the link phase and AFAIK is
> one of the causes of C++ links taking a painfully long time. Will Rust
> suffer from the same problem?

Rust serializes any generic or inline functions to an AST stored in
the crate metadata and will re-compile them as-needed per-crate.

In both Rust and C++, you end up with one copy of these at runtime for
each dynamically linked shared object. With C++ templates, the linker
or link-time optimization discards duplicate instantiations across
compilation units.

Rust doesn't have compilation units smaller than a crate so there is
no equivalent functionality. If you use crates as compilation units to
make compiles incremental/parallel, the situation is much worse than
C++ as you'll have many duplicates and they won't even go away with
link-time optimization until `mergefunc` works.

There's almost no point in doing anything but a massive crate at this point...

From danielmicay at gmail.com  Fri Nov 15 04:34:44 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 07:34:44 -0500
Subject: [rust-dev] typed loop variables & int num types
In-Reply-To: <52861343.30305@gmail.com>
References: <52861343.30305@gmail.com>
Message-ID: <CA+DvKQK2wyKRcyyA9GwC-6S6ty_s=zN2s4hwfKn-o9VA3HpEOw@mail.gmail.com>

On Fri, Nov 15, 2013 at 7:27 AM, spir <denis.spir at gmail.com> wrote:
> These are 2 points of secondary importance (or even less).
>
> What about the following pattern:
>     for x:Type in expr {
>         // proceed with x
>     }
> as equivalent to:
>     for y in expr {
>         let x = y as Type;
>         // proceed with x
>     }
> both for iterator loops and range loops?
> Actually, my need is to have uint's or u8's in range loops, while the
> default is int.

The `range` function will return an iterator based on the type passed
to it. If you use `0u8` instead of `0` it will provide an
`Iterator<u8>` implementation.

I don't think we should play around with `for` loops anymore until
they're reimplemented inside the compiler instead of as a parser hack.
A type annotation can be added in a backwards compatible way though.

> I'm also unhappy with "let n = 1;" yielding by default an int instead of an
> uint. I would suggest that if an int value is unsigned, the default type is
> uint. A signed int is, semantically, a difference, thus always signed: to
> get a default signed int, just write "let n = +1;". Seems both logical and
> self-documenting, imo.

I don't think either is a good default. Fixed-size integers do not
belong in most application-level logic.

https://github.com/mozilla/rust/issues/6023

From dbau.pp at gmail.com  Fri Nov 15 04:38:01 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 15 Nov 2013 23:38:01 +1100
Subject: [rust-dev] typed loop variables & int num types
In-Reply-To: <52861343.30305@gmail.com>
References: <52861343.30305@gmail.com>
Message-ID: <528615A9.1070501@gmail.com>

On 15/11/13 23:27, spir wrote:
> These are 2 points of secondary importance (or even less).
>
> What about the following pattern:
>     for x:Type in expr {
>         // proceed with x
>     }
> as equivalent to:
>     for y in expr {
>         let x = y as Type;
>         // proceed with x
>     }
> both for iterator loops and range loops?
> Actually, my need is to have uint's or u8's in range loops, while the 
> default is int.
>
> I'm also unhappy with "let n = 1;" yielding by default an int instead 
> of an uint. I would suggest that if an int value is unsigned, the 
> default type is uint. A signed int is, semantically, a difference, 
> thus always signed: to get a default signed int, just write "let n = 
> +1;". Seems both logical and self-documenting, imo.
>
> Again, quite unimportant and definitely not of high priority. Just 
> sending this for the record.
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

I'd like being able to write `pattern: Type` and `expression: Type` in 
arbitrary contexts, forcing the LHS to have that type, so `let (a: u8, 
b: f64) = foo(1: int);` would be valid (this would cover for-loops, 
since they are pattern contexts); I know it's been mentioned before, but 
I couldn't find any issues already, so I filed it as #10502.

In any case, you can write `range(0u8, 10)` or `range(0u, 10)` to 
override the inference and get a u8 or uint range, respectively.

BTW, Removing the int default has actually already been suggested in #6023.

6023: https://github.com/mozilla/rust/issues/6023
10502: https://github.com/mozilla/rust/issues/10502


Huon

From denis.spir at gmail.com  Fri Nov 15 04:46:22 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 15 Nov 2013 13:46:22 +0100
Subject: [rust-dev] tutorial (bis)
Message-ID: <5286179E.4070000@gmail.com>

I'm exploring the tutorial "Rust for Rubyists" at 
[http://www.rustforrubyists.com/book/book.html], which in fact is not (only) for 
rubyists, as stated in the introduction. Looks pretty good to me (just my 
opinion), should definitely be pointed to from the Rust Docs page at 
[https://github.com/mozilla/rust/wiki/Docs], and in good place. As a tutorial, 
it is in my view far better than the "official" one, and is up-to-date (Rust 
0.8), so maybe even just replace it; with a warning note.

The "official" tutorial is not a bad doc in itself (I guess) but is definitely 
not a _tutorial_: in fact, it requires quite a knowledge of Rust, its 
fundamental concepts and jargon. "Rust for Rubyists" certainly has room for 
improvement, but it _is_ for sure a tutorial. I would definitely suggest to 
start writing a new official tutorial by using "Rust for Rubyists" as raw 
material. A first pass may be to make it slightly more general, just requiring 
prior programming experience; Rust definitely is not a language for programming 
novices, anyway.

Denis


From oren at ben-kiki.org  Fri Nov 15 04:48:30 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 15 Nov 2013 14:48:30 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
Message-ID: <CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>

Thanks for the explanation! So virtual function calls are kept to the
absolute theoretical minimum, that's very good to know.

In my case I have one crate for some "infrastructure" and another crate for
the "application" using it (there would be several of these). I guess
having two copies isn't that bad.


On Fri, Nov 15, 2013 at 2:30 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Fri, Nov 15, 2013 at 6:54 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> >
> > That would be awesome, if it were true; it is quite a trick to pull that
> off
> > when the default methods are implemented in a different crate. Can
> someone
> > provide an authoritative answer on this?
> >
> > Also, C++ faces the problem of providing a single copy of monomorphised
> > functions (for templates). This is done during the link phase and AFAIK
> is
> > one of the causes of C++ links taking a painfully long time. Will Rust
> > suffer from the same problem?
>
> Rust serializes any generic or inline functions to an AST stored in
> the crate metadata and will re-compile them as-needed per-crate.
>
> In both Rust and C++, you end up with one copy of these at runtime for
> each dynamically linked shared object. With C++ templates, the linker
> or link-time optimization discards duplicate instantiations across
> compilation units.
>
> Rust doesn't have compilation units smaller than a crate so there is
> no equivalent functionality. If you use crates as compilation units to
> make compiles incremental/parallel, the situation is much worse than
> C++ as you'll have many duplicates and they won't even go away with
> link-time optimization until `mergefunc` works.
>
> There's almost no point in doing anything but a massive crate at this
> point...
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/6d12ad8d/attachment.html>

From lists at dhardy.name  Fri Nov 15 05:35:58 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Fri, 15 Nov 2013 14:35:58 +0100
Subject: [rust-dev] Treating Vectors Like Any Other Container
Message-ID: <4983399.rsLiA4KqvF@tph-l10036>

In reply to Nicholas Matsakis's post:
http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/

That's a really nice write-up Nicholas. I wanted to chip in because I had a 
think about some similar issues in the past, but your review is far more 
thorough and knowledgeable than I could have managed.

Regarding Gc<[uint]> (or @[T]), this seems fairly useless to me, given that 
@mut[T] would not be memory safe (unless it is @mut ~[T] or reallocating the 
buffer is not allowed), thus the only way of constructing @[T] would be to 
coerce a ~[T] or a literal.

For me, the biggest plus of your proposal is uniformity: e.g. someone could 
implement something like C++'s std::bitset and have it look syntactically 
equivalent to Vector<T> (although given that std::bitset is not very useful 
and Boost's "Pointer Containers" are redundant in both C++11 and Rust, I'm 
struggling to find an example where this is actually needed). Given the three 
big drawbacks (implementation effort, syntax and pattern matching) it may not 
be worth it.

Using a builder trait to construct user-defined objects from literals is a nice 
approach (I believe it could also be useful in type-safe printf-like 
formatters and embedded DSLs for things like constructing HTML or parser 
rules), but some things like method lookup won't always be possible:

let v : Vector<int> = [1,2,3].append_one( 4 )
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/a79f0bfc/attachment.sig>

From oren at ben-kiki.org  Fri Nov 15 05:39:12 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 15 Nov 2013 15:39:12 +0200
Subject: [rust-dev] Treating Vectors Like Any Other Container
In-Reply-To: <4983399.rsLiA4KqvF@tph-l10036>
References: <4983399.rsLiA4KqvF@tph-l10036>
Message-ID: <CADJiDhvhnerTxDa5DK8KTN3isixQ961QHBHAjPPjxtcJLsivpw@mail.gmail.com>

If the traits were polymorphic in the index type (instead of always
expecting an integer), then one could use them to make hash tables use
vector syntax (e.g., `hash["foo"] = 1`)... Ruby does that, for example. So
something like bitset (with integer indices) isn't the only example.

Not sure whether we want to go that way, though...


On Fri, Nov 15, 2013 at 3:35 PM, Diggory Hardy <lists at dhardy.name> wrote:

> In reply to Nicholas Matsakis's post:
>
> http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/
>
> That's a really nice write-up Nicholas. I wanted to chip in because I had a
> think about some similar issues in the past, but your review is far more
> thorough and knowledgeable than I could have managed.
>
> Regarding Gc<[uint]> (or @[T]), this seems fairly useless to me, given that
> @mut[T] would not be memory safe (unless it is @mut ~[T] or reallocating
> the
> buffer is not allowed), thus the only way of constructing @[T] would be to
> coerce a ~[T] or a literal.
>
> For me, the biggest plus of your proposal is uniformity: e.g. someone could
> implement something like C++'s std::bitset and have it look syntactically
> equivalent to Vector<T> (although given that std::bitset is not very useful
> and Boost's "Pointer Containers" are redundant in both C++11 and Rust, I'm
> struggling to find an example where this is actually needed). Given the
> three
> big drawbacks (implementation effort, syntax and pattern matching) it may
> not
> be worth it.
>
> Using a builder trait to construct user-defined objects from literals is a
> nice
> approach (I believe it could also be useful in type-safe printf-like
> formatters and embedded DSLs for things like constructing HTML or parser
> rules), but some things like method lookup won't always be possible:
>
> let v : Vector<int> = [1,2,3].append_one( 4 )
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/0adcc8b4/attachment.html>

From danielmicay at gmail.com  Fri Nov 15 05:43:46 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 08:43:46 -0500
Subject: [rust-dev] Treating Vectors Like Any Other Container
In-Reply-To: <4983399.rsLiA4KqvF@tph-l10036>
References: <4983399.rsLiA4KqvF@tph-l10036>
Message-ID: <CA+DvKQL0SeGYD7nXOk5EPi57DpZ9ogQpz9ts9Hj_9m_MewYrWQ@mail.gmail.com>

On Fri, Nov 15, 2013 at 8:35 AM, Diggory Hardy <lists at dhardy.name> wrote:
>
> For me, the biggest plus of your proposal is uniformity: e.g. someone could
> implement something like C++'s std::bitset and have it look syntactically
> equivalent to Vector<T> (although given that std::bitset is not very useful
> and Boost's "Pointer Containers" are redundant in both C++11 and Rust, I'm
> struggling to find an example where this is actually needed). Given the three
> big drawbacks (implementation effort, syntax and pattern matching) it may not
> be worth it.

There's still a need for smart pointers not defined in the library.
Rust doesn't provide a built-in reference-counted pointer (variants of
which can include atomic reference counting and weak pointer support)
or a unique pointer with an allocator parameter. Wrapping foreign
libraries often requires defining new smart pointer types too.

There are a nearly limitless number of containers that generic
literals would be useful for, including alternative vector
implementations like small vectors and ropes.

From dbau.pp at gmail.com  Fri Nov 15 05:44:52 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 16 Nov 2013 00:44:52 +1100
Subject: [rust-dev] Treating Vectors Like Any Other Container
In-Reply-To: <CADJiDhvhnerTxDa5DK8KTN3isixQ961QHBHAjPPjxtcJLsivpw@mail.gmail.com>
References: <4983399.rsLiA4KqvF@tph-l10036>
	<CADJiDhvhnerTxDa5DK8KTN3isixQ961QHBHAjPPjxtcJLsivpw@mail.gmail.com>
Message-ID: <52862554.6000505@gmail.com>

On 16/11/13 00:39, Oren Ben-Kiki wrote:
> If the traits were polymorphic in the index type (instead of always 
> expecting an integer), then one could use them to make hash tables use 
> vector syntax (e.g., `hash["foo"] = 1`)... Ruby does that, for 
> example. So something like bitset (with integer indices) isn't the 
> only example.
>
> Not sure whether we want to go that way, though...
>
Note that the traits in the blog posts are parameterised by the index type:

     trait Index<I, E> { fn index<'a>(&'a self, index: I) -> &'a E; }

Etc.


|Huon|

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/908703c1/attachment.html>

From oren at ben-kiki.org  Fri Nov 15 05:52:02 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Fri, 15 Nov 2013 15:52:02 +0200
Subject: [rust-dev] Treating Vectors Like Any Other Container
In-Reply-To: <52862554.6000505@gmail.com>
References: <4983399.rsLiA4KqvF@tph-l10036>
	<CADJiDhvhnerTxDa5DK8KTN3isixQ961QHBHAjPPjxtcJLsivpw@mail.gmail.com>
	<52862554.6000505@gmail.com>
Message-ID: <CADJiDhs8uQnq5Oxj6vVhUT38bjTKphemHNpQ4JTxnjSNKoEWFQ@mail.gmail.com>

Slice traits weren't: though, does `tree.mut_slice_between("foo", "bar")`
even make sense?


On Fri, Nov 15, 2013 at 3:44 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  On 16/11/13 00:39, Oren Ben-Kiki wrote:
>
> If the traits were polymorphic in the index type (instead of always
> expecting an integer), then one could use them to make hash tables use
> vector syntax (e.g., `hash["foo"] = 1`)... Ruby does that, for example. So
> something like bitset (with integer indices) isn't the only example.
>
>  Not sure whether we want to go that way, though...
>
>  Note that the traits in the blog posts are parameterised by the index
> type:
>
>     trait Index<I, E> { fn index<'a>(&'a self, index: I) -> &'a E; }
>
> Etc.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/a2f9630d/attachment.html>

From danielmicay at gmail.com  Fri Nov 15 05:54:36 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 08:54:36 -0500
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <5286179E.4070000@gmail.com>
References: <5286179E.4070000@gmail.com>
Message-ID: <CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>

On Fri, Nov 15, 2013 at 7:46 AM, spir <denis.spir at gmail.com> wrote:
> I'm exploring the tutorial "Rust for Rubyists" at
> [http://www.rustforrubyists.com/book/book.html], which in fact is not (only)
> for rubyists, as stated in the introduction. Looks pretty good to me (just
> my opinion), should definitely be pointed to from the Rust Docs page at
> [https://github.com/mozilla/rust/wiki/Docs], and in good place. As a
> tutorial, it is in my view far better than the "official" one, and is
> up-to-date (Rust 0.8), so maybe even just replace it; with a warning note.
>
> The "official" tutorial is not a bad doc in itself (I guess) but is
> definitely not a _tutorial_: in fact, it requires quite a knowledge of Rust,
> its fundamental concepts and jargon. "Rust for Rubyists" certainly has room
> for improvement, but it _is_ for sure a tutorial. I would definitely suggest
> to start writing a new official tutorial by using "Rust for Rubyists" as raw
> material. A first pass may be to make it slightly more general, just
> requiring prior programming experience; Rust definitely is not a language
> for programming novices, anyway.
>
> Denis

The tutorial is currently quite flawed and has ended up being a list
of language features with overviews and low quality examples. Parts of
it are approaching the right level of information, but it's not
written in the style expected of a tutorial.

I think it's very important to cover the core language features like
boxes and references at a high level. The unique and least
approachable features need great introductory coverage. I recently
replaced the old sections on owned boxes, vectors and strings, so any
concrete feedback on those would be helpful.

From lists at dhardy.name  Fri Nov 15 06:03:01 2013
From: lists at dhardy.name (Diggory Hardy)
Date: Fri, 15 Nov 2013 15:03:01 +0100
Subject: [rust-dev] Treating Vectors Like Any Other Container
In-Reply-To: <CADJiDhs8uQnq5Oxj6vVhUT38bjTKphemHNpQ4JTxnjSNKoEWFQ@mail.gmail.com>
References: <4983399.rsLiA4KqvF@tph-l10036> <52862554.6000505@gmail.com>
	<CADJiDhs8uQnq5Oxj6vVhUT38bjTKphemHNpQ4JTxnjSNKoEWFQ@mail.gmail.com>
Message-ID: <4777324.N5zKIqm4uX@tph-l10036>

If tree is ordered, e.g. lexically, it might. I've certainly found 
std::map<...>::lower_bound useful in the past:

http://en.cppreference.com/w/cpp/container/map/lower_bound

On Friday 15 November 2013 15:52:02 Oren Ben-Kiki wrote:
> Slice traits weren't: though, does `tree.mut_slice_between("foo", "bar")`
> even make sense?
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: This is a digitally signed message part.
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/79b35d17/attachment.sig>

From gaetan at xeberon.net  Fri Nov 15 06:24:59 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 15 Nov 2013 15:24:59 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
Message-ID: <CANK7tAEUny9=Q7fxO2hEF9oj141Qjd=wUAW=Qs1Wed5L1DykWg@mail.gmail.com>

I would love a documentation "Rust for Pythonist" or "Rust for C++'iste".

I don't like the Wiki page. I think the official documentation homepage
should be a nice, beautiful
http://doc.rust-lang.org/<http://static.rust-lang.org/>.
Period.
It should link all "official" documentation in a logical way.
Maybe it should provide a link to the wiki page with only "incubating"
documentation.

I think it should be derived from rst/markdown files in conf, closely
linked to the current version of rust lang. Maybe divided in several
modules (the summary for rust 0.8 derives from files in the rust 0.8
branch, for master files are on master, branch...).

-----
Gaetan



2013/11/15 Daniel Micay <danielmicay at gmail.com>

> On Fri, Nov 15, 2013 at 7:46 AM, spir <denis.spir at gmail.com> wrote:
> > I'm exploring the tutorial "Rust for Rubyists" at
> > [http://www.rustforrubyists.com/book/book.html], which in fact is not
> (only)
> > for rubyists, as stated in the introduction. Looks pretty good to me
> (just
> > my opinion), should definitely be pointed to from the Rust Docs page at
> > [https://github.com/mozilla/rust/wiki/Docs], and in good place. As a
> > tutorial, it is in my view far better than the "official" one, and is
> > up-to-date (Rust 0.8), so maybe even just replace it; with a warning
> note.
> >
> > The "official" tutorial is not a bad doc in itself (I guess) but is
> > definitely not a _tutorial_: in fact, it requires quite a knowledge of
> Rust,
> > its fundamental concepts and jargon. "Rust for Rubyists" certainly has
> room
> > for improvement, but it _is_ for sure a tutorial. I would definitely
> suggest
> > to start writing a new official tutorial by using "Rust for Rubyists" as
> raw
> > material. A first pass may be to make it slightly more general, just
> > requiring prior programming experience; Rust definitely is not a language
> > for programming novices, anyway.
> >
> > Denis
>
> The tutorial is currently quite flawed and has ended up being a list
> of language features with overviews and low quality examples. Parts of
> it are approaching the right level of information, but it's not
> written in the style expected of a tutorial.
>
> I think it's very important to cover the core language features like
> boxes and references at a high level. The unique and least
> approachable features need great introductory coverage. I recently
> replaced the old sections on owned boxes, vectors and strings, so any
> concrete feedback on those would be helpful.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/991c8f3d/attachment.html>

From gaetan at xeberon.net  Fri Nov 15 06:33:40 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 15 Nov 2013 15:33:40 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
Message-ID: <CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>

after reading this doc, I would love to have:
- have a link at the bottom page to the github project
- submit one or several pullrequest
- doc is magically updated.

I'm investigating on this matter to ease documentation. That's is quite
interesting, because in my everyday job (I'm a python developer for a
buildbot derived project) I'm in a "write tools to ease code documentation
and user manual maintainance" mood :)

Gaetan

-----
Gaetan



2013/11/15 Daniel Micay <danielmicay at gmail.com>

> On Fri, Nov 15, 2013 at 7:46 AM, spir <denis.spir at gmail.com> wrote:
> > I'm exploring the tutorial "Rust for Rubyists" at
> > [http://www.rustforrubyists.com/book/book.html], which in fact is not
> (only)
> > for rubyists, as stated in the introduction. Looks pretty good to me
> (just
> > my opinion), should definitely be pointed to from the Rust Docs page at
> > [https://github.com/mozilla/rust/wiki/Docs], and in good place. As a
> > tutorial, it is in my view far better than the "official" one, and is
> > up-to-date (Rust 0.8), so maybe even just replace it; with a warning
> note.
> >
> > The "official" tutorial is not a bad doc in itself (I guess) but is
> > definitely not a _tutorial_: in fact, it requires quite a knowledge of
> Rust,
> > its fundamental concepts and jargon. "Rust for Rubyists" certainly has
> room
> > for improvement, but it _is_ for sure a tutorial. I would definitely
> suggest
> > to start writing a new official tutorial by using "Rust for Rubyists" as
> raw
> > material. A first pass may be to make it slightly more general, just
> > requiring prior programming experience; Rust definitely is not a language
> > for programming novices, anyway.
> >
> > Denis
>
> The tutorial is currently quite flawed and has ended up being a list
> of language features with overviews and low quality examples. Parts of
> it are approaching the right level of information, but it's not
> written in the style expected of a tutorial.
>
> I think it's very important to cover the core language features like
> boxes and references at a high level. The unique and least
> approachable features need great introductory coverage. I recently
> replaced the old sections on owned boxes, vectors and strings, so any
> concrete feedback on those would be helpful.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/632df687/attachment-0001.html>

From danielmicay at gmail.com  Fri Nov 15 06:39:25 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 09:39:25 -0500
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
Message-ID: <CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>

On Fri, Nov 15, 2013 at 9:33 AM, Gaetan <gaetan at xeberon.net> wrote:
> after reading this doc, I would love to have:
> - have a link at the bottom page to the github project
> - submit one or several pullrequest
> - doc is magically updated.
>
> I'm investigating on this matter to ease documentation. That's is quite
> interesting, because in my everyday job (I'm a python developer for a
> buildbot derived project) I'm in a "write tools to ease code documentation
> and user manual maintainance" mood :)

It gets updated by the doc builder when a pull request is merged. A
pull request will run through the auto builders before being merged,
including extracting and testing the samples in the tutorial.

http://buildbot.rust-lang.org/
http://buildbot.rust-lang.org/bors/bors.html

From marijnh at gmail.com  Fri Nov 15 06:55:56 2013
From: marijnh at gmail.com (Marijn Haverbeke)
Date: Fri, 15 Nov 2013 15:55:56 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
Message-ID: <CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>

As the author of the original tutorial I'm interested in what people
hate so much about it. It appears to have slightly bit-rotted, in that
the language moved on and people haphazardly updated stuff here and
there, but the bulk of it still looks coherent. Can I get some
concrete pointers?

On Fri, Nov 15, 2013 at 3:39 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Fri, Nov 15, 2013 at 9:33 AM, Gaetan <gaetan at xeberon.net> wrote:
>> after reading this doc, I would love to have:
>> - have a link at the bottom page to the github project
>> - submit one or several pullrequest
>> - doc is magically updated.
>>
>> I'm investigating on this matter to ease documentation. That's is quite
>> interesting, because in my everyday job (I'm a python developer for a
>> buildbot derived project) I'm in a "write tools to ease code documentation
>> and user manual maintainance" mood :)
>
> It gets updated by the doc builder when a pull request is merged. A
> pull request will run through the auto builders before being merged,
> including extracting and testing the samples in the tutorial.
>
> http://buildbot.rust-lang.org/
> http://buildbot.rust-lang.org/bors/bors.html
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From danielmicay at gmail.com  Fri Nov 15 06:59:56 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 09:59:56 -0500
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
Message-ID: <CA+DvKQ+fdD+OpPu4B1TvvHqvjLGMLNFDSpn+CL-1X1b8gh5tpQ@mail.gmail.com>

On Fri, Nov 15, 2013 at 9:55 AM, Marijn Haverbeke <marijnh at gmail.com> wrote:
> As the author of the original tutorial I'm interested in what people
> hate so much about it. It appears to have slightly bit-rotted, in that
> the language moved on and people haphazardly updated stuff here and
> there, but the bulk of it still looks coherent. Can I get some
> concrete pointers?

It's gets across most of the information, but it doesn't have a very
compelling flow of examples. It teaches how to use language features
rather than walking through building something with those features.

For example, the sections on owned boxes and borrowed pointers could
be done by walking through the implementation of a singly-linked list.
It's incredibly hard to actually do this without using too many
features before they've been introduced.

From illissius at gmail.com  Fri Nov 15 08:05:28 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Fri, 15 Nov 2013 17:05:28 +0100
Subject: [rust-dev] Type system thoughts
Message-ID: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>

Hello list,

I have some ideas about typey things and I'm going to write them down. It
will be long.




It would be nice if `Trait1 + Trait2` were itself a trait, legal in the
same positions as any trait. This is already partly true: in trait bounds
on type parameters and super-traits of traits. Where it's not true is trait
objects, e.g. `~(ToStr + Send)`. Having this could remove the need for the
current `~Trait:OtherTraits` special syntax.

I wonder whether lifetimes could also be interpreted as traits, with the
meaning: "[object of type implementing lifetime-trait] does not outlive
[the given lifetime]". This is an honest wondering: I'm not sure if it
makes sense. If it does make sense, it would fit in perfectly with the fact
that 'static is already a trait. Together with the above, it might also
allow a solution for capturing borrowed data in a trait object: you could
write `~(Trait + 'a)`.




The next few are going to be about higher- (or just different-) kinded
generics. To avoid confusion, I'm going to use "built-in trait" to mean
things like `Freeze` and `Send`, and "kind" to mean what it does everywhere
else in the non-Rustic world.

I think the best available syntax for annotating the kinds of types would
be to borrow the same or similar syntax as used to declare them, with
either `type` or `struct` being the kind of "normal" non-generic types (the
only kind of type that current Rust lets you abstract over). [I prefer
`type`, because both structs and enums inhabit the same kind.] This is kind
of like how C++ does it. For example, the kind of `Result` would be
`type<type, type>`. Our `type` corresponds to C++'s `typename` and
Haskell's `*`, and `type<type, type>` to C++'s `template<typename,
typename> class` and Haskell's `* -> * -> *`. So, for example, you could
write the fully kind-annotated signature of an identity function restricted
to Result-shaped types (yeah, actually doing this would be pointless!) as:

    fn dumb_id<type<type, type> R, type A, type B>(x: R<A, B>) -> R<A, B>;

To explicitly annotate the kind of the Self-type of a trait, we could
borrow the `for` syntax used in `impl`s. Here's the fully kind-annotated
version of the `Functor` trait familiar from Haskell:

    trait Functor for type<type> Self {
        fn fmap<type A, type B>(a: &Self<A>, f: |&A| -> B) -> Self<B>;
    }

(Obviously, explicitly annotating every kind would be tiresome, and `Self`
is a little redundant when nothing else could go there. I could imagine
`trait Functor for type<type>`, `trait Functor for Self`, and/or `trait
Functor` all being legal formulations of the above. I'll get back to this
later.)

One question with regards to higher-kinded traits is what to do about
methods and `self`. What syntax to use? Does it even make sense? For
syntax, I see two possibilities (snipping from the `fmap` signature):
 - `self: &Self<A>`
 - `&self<A>`
I don't have a preference, but I'll be using the latter for now. And it
*does* make sense. Every trait over a `Self` with parameters of given kinds
gives rise to trait objects with parameters of the same kinds. Basically,
it's always the outermost type constructor that gets erased. In the trivial
case, the `Self` of `ToStr` does not have any parameters, and neither does
`~ToStr`. To see a less trivial case, let's write a variant of Haskell's
`Foldable`:

    trait Foldable for type<type> Self {
        fn fold<T>(&self<T>, init: &T, folder: |&T, &T| -> T) -> T;
    }

Then `&Foldable<int>` is a trait object hiding any foldable container of
ints (for example `~[int]`). There should probably be a way to distinguish
the arguments of the trait from the arguments of Self: so perhaps that
should be something like `&Foldable<for int>` instead (but that doesn't
cleanly extend to more than one argument). An example of its use:

    fn sum(vals: &Foldable<for int>) -> int {
        vals.fold(&0, |a, b| a + b)
    }
    let n = sum(&[1, 2, 3] as &Foldable<for int>);

So far we've seen two sorts of kinds: the base kind `type`, and generic
kinds `type<...>`. Another very important one is lifetimes. And I can
imagine two more beyond these:

Like C++, types could be parameterized over constants. Again, the syntax
could mirror their declarations. For example, a function to construct a
fixed-length array:

    fn make_n<static N: int>(n: int) -> ~[int, ..N] { [n, ..N] }

Interesting questions here include what types to allow, how or whether to
handle literals of various types as type arguments, and the constant
expression sublanguage.

The other is the potential to abstract over traits. GHC does this with the
`ConstraintKinds` extension. (According to people who have implemented
Haskell compilers, it's actually easier to implement it than not to![1]
Which is pretty crazy.) In that case, just to stick to trivial, useless
examples, and continue with parameter-syntax-follows-declaration, you could
write a generic alias for `Trait1 + Trait2` as:

    trait And<trait A, trait B>: A + B { }
    impl<trait A, trait B, type T: A + B> And<A, B> for T { }

[1]:
http://www.reddit.com/r/haskell/comments/10w3cx/ideas_for_a_library_that_uses_constraintkinds_to/c6h6di4

(I don't want to dive any more deeply into the motivations for and
complications of this feature here; I only wanted to mention the
possibility and demo the syntax.)

There's two further issues that higher-kinded generics raise. The first is
that in order for traits like `Functor` to be truly useful, you really want
currying and partial application at the type level. Otherwise, while you
can `impl Functor for` arrays and `Option`, you can't impl it for `Result`
and `HashMap`, which is a significant loss. Thankfully, there are no
difficulties regarding evaluation order at the type level, which is one of
the reasons that partial application syntax was removed at the value level.
I could imagine the syntax being something like this:

    impl<K> Functor for HashMap<K, ..> { fn fmap etc. }

in which case `HashMap` is partially applied to `K`, and the remaining
parameters (only one in this case) are left hanging - and so the result is
of the `type<type>` kind that `Functor` expects (rather than the
`type<type, type>` kind of plain `HashMap`). What the above means is that
if you have a `HashMap`, you can make a new `HashMap` with the same keys
but different values of a potentially different type.

I expect that kind annotations would be legal anywhere a type parameter is
declared. The second issue is: in which cases would they be optional, in
which cases required, and what happens if you omit one? I see several
possibilities:

  - If you omit a kind, it defaults to `type`. Any other kind must be
explicitly annotated. This is the simplest and dumbest option, and is
completely backwards compatible.

  - If you omit a kind, it is inferred. If it can't be inferred, an error
is raised. This is not quite backwards compatible.

  - If you omit a kind, it is inferred. If it can't be inferred, it
defaults to `type`. This is again backwards compatible with current Rust.

  - If you omit a kind, it is inferred. If it is unconstrained, the
declaration is kind-polymorphic, meaning it works with any kind. I think
this is backwards compatible, but I'm not 100% sure. GHC has this with
`PolyKinds`. The absence of it is frequently annoying in C++ when writing
template-heavy code: you have to manually duplicate things for `typename`,
`template<...> class`, various non-type template parameters, and all the
combinations of these that you want, and it's impossible to get full
coverage with a finite number of declarations: you have to choose the ones
you want to support. Proposals to address this issue have been submitted to
the C++ standards committee. Similarly, in Haskell's case, they were forced
to have `Typeable1` ... `Typeable7` classes (the equivalent of our `Any`
trait) for kinds of a few selected arities, which will be collapsed into a
single `Typeable` in the next GHC, both reducing duplication and attaining
full coverage of every type of every kind.




Higher-kinded types are connected to dynamically sized types. In
particular, I think sized and unsized types should be *separate kinds*,
instead of using a built-in trait to distinguish them. Multiple
considerations support this:

 - They are qualitatively different. Built-in traits are required only for
safety. You could imagine leaving one off, and it would still make sense,
it just wouldn't be safe. On the other hand, an unsized type in the wrong
place is close to nonsensical. Defining what kinds of types make sense in
what places is exactly what kinds are for. `[[int]]` doesn't make sense in
a similar way to how `let foo: HashMap`, `[Option]`, and `fn foo<T: int>`
don't make sense. In fact, this is precisely what GHC does: it has separate
kinds for boxed types (`*`), unboxed types (`#`), and trait bounds which in
Haskell are called constraints (`Constraint`).

 - If `Sized` is a built-in trait, it re-raises questions about whether
trait bounds should be allowed on struct type parameters. If the
distinction is made at the kind level, this kind of problem goes away: type
parameters already have kinds.

 - A `Sized` trait significantly increases the annotation burden. If the
distinction is made with kinds, on the other hand, they could be inferred
with the same kind inference algorithm used for all other kinds (supposing
support for different kinds and kind inference exists).

That still leaves the question of what the kind hierarchy should
specifically be. A first attempt might look something like this:

    type { sized, unsized { array, trait } }

where kinds inside braces are subkinds of those outside. (Even GHC has
subkinds, so I hope subkinding is not a big problem.) I *think* that mostly
makes sense: the type parameter of an array would have `sized` kind; the
type parameter of a pointer type would have the most general `type` kind,
but its representation would be different for `sized` and `unsized`; and in
trait-bound positions things of `trait` kind would be accepted, but not
arrays. I haven't put much thought into the actual names and syntax for all
of these. (In particular, I don't think there's an actual use case for
specifying `unsized` or `array` kinds: they're just what you get if you
take the complement of `sized` and `trait`, respectively, relative to their
superkind.)

This gets more interesting if we also have struct inheritance, and structs
can be used as traits (with the meaning is-a-substruct-of). I haven't
thought about that possibility very much yet.




The next few are about generics and dictionaries (vtables). I'm at a
somewhat earlier stage in my thinking about this than about the other
things.

Current Rust has two things it can do with generics, traits and their
dictionaries:

 - In the case of generic functions, traits are completely monomorphized
away: the implementations to call are all selected at compile time;

 - Rust also has syntactic sugar for a form of existential types in the
form of trait objects, in which case a pointer to the trait's dictionary is
packaged along with a pointer to the object, and the implementation to call
is determined at runtime.

I think there are a few other directions that could be explored. In recent
blog posts[2][3] Niko Matsakis mentioned the possibility for closures which
are generic over a lifetime (not top-level functions, but closures!) --
meaning that the lifetime(s) the closure will be invoked with are not known
until runtime. This works because the representation of the closure does
not depend on the lifetime: that information is completely erased during
compilation. The basic idea in all of the following is that lifetimes
aren't the only thing which don't affect representation: neither do the
type arguments to pointer-like types! [Let's pretend for now that only
sized types exist.] This opens the possibility of generic closures
parameterized over *types*, provided those types are only used as arguments
to pointer-like types. This corresponds to pointers to function templates
in C++ (which are notable for being occasionally desired but impossible),
and to higher-rank types in Haskell. For example, a generic closure
representing the identity function restricted to owned pointers would have
the type:

    for<T> |x: ~T| -> ~T

Here I'm using our ever-versatile `for` keyword to introduce the type
parameter list, which I think reads better than the plain `<T> |x: ~T|`
style from Niko's blog posts (and tracks Haskell's use of `forall` for the
same purpose). So far so good: a closure of the above type will indeed have
the same representation no matter what type it's used with. But there's a
wrinkle: what if there are trait bounds on the type parameter? Then the
closure will have to call different trait methods depending on which type
is used, seeming to require different representations for each. There's a
way out: pass a pointer to the trait dictionary (vtable) as a hidden
argument to the closure, and make calls to trait methods (and associated
functions) through that pointer. This is analogous to how pointers have a
hidden pointer-to-vtable field when they are pointing to trait objects.
(Incidentally, the fact that pointers have the same representation
regardless of the type they are pointing to is also what allows
pointers-to-trait-objects to work at all.) In both cases, this happens to
be the same thing that GHC does. There are few more interesting questions
and wrinkles this raises:

 - Looking at the above generic closure, what if it did not return its
argument, but let it go out of scope? Then it would have to invoke the
destructor for the given type - which again varies depending on which type
it is! This points back to the fact `Drop` really is an honest-to-god
trait, and it's not just a superficial syntactic resemblence. The reason
`Drop` is so weird is that, in effect, there's an implicit `impl` of it for
every type (when there isn't an explicit one), which does nothing, and it's
present as an implicit trait bound on every type argument. (You could
imagine it working like any other trait, and requiring an explicit `Drop`
bound in any generic function where an object of that type is destroyed
(transitively), but that would be super-annoying which is presumably why we
don't do it.) In any case, to make this example work, we would have to pass
a pointer to the `Drop` dictionary for the type as a hidden argument to the
closure, the same as with other traits. (This is similar to the issues with
owned pointers and struct inheritance from another of Niko's blog posts[4],
though I'm not sure what it teaches us.)

[2]:
http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/
[3]:
http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/
[4]:
http://smallcultfollowing.com/babysteps/blog/2013/10/24/single-inheritance/

 - There's the question of how to actually codify which generic function
types are legal and which ones aren't. For example, `for<T> |x: T| -> T`
and anything else which uses a generic argument unboxed should not be
legal. This feels like another thing that the kind system should handle,
but I'm less sure about exactly how. At first, there's a seductive
possibility: what if all types introduced in a `for<>` were considered
unsized? In a sense this is literally true: because the type is not known
until runtime, neither is its size, and unsized types can only be
manipulated through pointers, which is what we want. I'm not sure if it
completely works out, though. For one thing, unlike "normal"
pointers-to-unsized types, here pointers to these "pseudo-unsized" types
are still only a single word, they don't have hidden pointer-to-dictionary
fields (which are passed as hidden arguments to the closure, instead).
Perhaps if the sizedness of a type were treated separately from whether it
carries a dictionary, this could be made to work out (for example, `Send`
and `Freeze` don't have dictionaries either), but it's not clear how that
might be done. The other issue is that this seems too restrictive for the
return types of functions. Rust writes out the return value of a function
through a hidden pointer that is passed in to the function, so it seems
like it should be possible to have closures which return a generic value
"unboxed": while the closure does not know what type it is, the caller
does, so the caller can pass in a pointer to an appropriately-sized piece
of memory, and it would seem to all work out. For example, a type like
`for<T: Clone> |x: &T| -> T` would then be legal. And because values are
implicitly returned through pointers, there's no penalty to returning
values "unboxed", and so most Rust function do that, even if they take
their arguments by pointer: it would be a shame to exclude them all.

 - Earlier I said "let's pretend for now that only sized types exist". It's
obvious why: the size of pointers can change depending on the *kind* of the
type they point to, which would invalidate the property we've been relying
on. In can imagine two remedies. One is in fact to simply restrict the type
parameters of generic closures to sized kinds. The other is to permit
different kinds of the programmer's choice, as long as they are used
consistently and not mixed. For example, `for<sized T> |x: ~T| -> ~T` and
`for<trait T> |x: ~T| -> ~T` would both be legal under this scheme, and
incompatible.

Let's look at a few more fun things you could do using similar tricks as we
used for generic closures. One is another classic example of something you
can't do in C++: virtual function templates. In Rust terms, this
corresponds to calling a generic method through a trait object pointer.
It's clear why C++ disallows this: function templates work by generating a
separate actual function for each instantiation of the template
(monomorphization), and virtual functions work by calling the function
through a pointer, and you definitely can't have a single pointer to an
arbitrary number of different functions template instantiations. Rust could
do mostly the same thing here as with generic closures: if the generic
arguments of the method are only manipulated through pointers, then
generate an additional "generic" instantion of the method where trait
dictionaries are passed as hidden arguments, and when calling the method
through a trait object, use this instantiation of it and pass in the
dictionaries. After that, the same considerations apply as for generic
closures, from above.

Another possibility is explicit existential types inside of structs. That
might look like this:

    struct LeftFold<In, Out, 'a> {
        type Seed,
        initial: &'a Seed,
        folder: |&Seed, &In|:'a -> Seed,
        result: |&Seed|:'a -> Out
    }

(This is borrowed from the blog post "Beautiful Folding" by "Quiz"[5].)
This represents a type which encapsulates and hides both the folding
function and accumulator of a left fold. You pass in values of type `In`,
it does the folding work behind the scenes, and you get out a value of type
`Out`. (See the blog post for more details). Again, the same restrictions
apply here to the use of the `Seed` type as to generic arguments of generic
closures and methods. (If you were to use it unboxed, the struct could not
be represented.) Another thing we could do with this, along with the
`trait` kind from earlier, is write out the representation of a trait
object pointer explicitly:

    trait BorrowedObject<'a, trait Trait> {
        type T: Trait,
        object: &'a T
    }

Here, the pointer-to-Trait-dictionary will be stored as a hidden field at
the end of the struct. This results in the same representation as for the
trait object pointers that are built-in to the language. (The `object`
field itself is only one word wide, the same as pointers to generic
arguments of generic closures.)

[5]: http://squing.blogspot.hu/2008/11/beautiful-folding.html

Finally, one more thing that could be supported in this way is polymorphic
recursion. The problem with polymorphic recursion in monomorphizing
languages is that it requires an infinite number of "template
instantiations" as the recursion descends, but if the representation of the
functions is the same no matter what type arguments they are used with,
then the problem goes away. Again, the same restrictions would apply as for
all of the previous examples.




The last few are about closures. I really like the observation originally
made by strcat (Daniel Micay) that closures are basically just trait
objects[6]. In effect, our current (recently introduced) closure type
corresponds to this (using much imaginary syntax):

    trait FnMut<Args..., Ret> {
        fn call(&mut self, Args...) -> Ret;
    }

    type |Args...|:'a -> Ret = &'a mut FnMut<Args..., Ret>;

Looking at it this way, it makes sense why these closures are move-only:
they mutate their environment, hence `&mut self`, which requires the
pointer to the trait object to also be `&mut`, which is move-only. (An
aside: wouldn't `&mut 'a T` perhaps be nicer than `&'a mut T`?) Our
recently introduced `proc` type corresponds to this:

    trait FnOnce<Args..., Ret> {
        fn call(self, Args...) -> Ret;
    }

    type proc(Args...) -> Ret = ~FnOnce<Args..., Ret>;

Finally, there's a third important possibility (the old `&fn`) which
neither of the above capture:

    trait Fn<Args..., Ret> {
        fn call(&self, Args...) -> Ret;
    }

    type &'a fn(Args...) -> Ret = &'a Fn<Args..., Ret>;

This corresponds to closures with an immutable environment, which can
therefore be freely copied. In addition, if you mix and match the traits
and pointer types, `~FnMut<Args..., Ret>` is also a useful point in the
space, allowing mutation of the owned environment; and so is `@Fn<Args...,
Ret>`, which is basically the type of closures in Haskell (if you don't
consider laziness), allowing arbitrary sharing of immutable environments
between closures.

[6]: https://github.com/mozilla/rust/issues/8622

The reason all of this is so cool is that it unifies the C++ practice of
using unboxed closures via an overloaded `operator ()` with the standard in
functional languages of having a single first-class function (boxed
closure) type. Like all other templates-plus-overloading in C++,
overloading the function call operator corresponds in Rust to using a
trait. Then if you add trait objects, boxed closures - the equivalent of
C++'s `std::function` - fall out for free! (With memory management of the
closure chosen by the client, unlike `std::function`.) Like C++, you could
`impl` these Fn traits for your own types, and like functional languages,
you have the liberty of using a single unified function type (boxed
closures). (Or, well, three, thanks to Rust's distinction between by-ref,
by-mut-ref, and by-val: but they're effectively subtypes of each other, in
the reverse order.)

The problem is that doing all of this by hand in Rust with user-defined
traits is super-awkward. There's no built-in support for variadic
arguments, so you have to simulate it with tuples, or define separate
`Fn0`, `Fn1`, .. `FnN` traits; you don't have literals, so you have to
write the closure `struct` by hand and `impl` the trait for it (just like
C++ before lambdas); you can't make stack closures with the stack frame
itself as the environment; and you don't get to use the function call
operator, but have to call the `call()` method. It would be nice if Rust
solved these by in fact overloading the function call operator on traits
such as these; had some kind of built-in syntax for the traits, to solve
the variadic and plain ugliness problems (my old idea was built-in
special-syntax `trait fn(T...) -> U`, `trait fn mut(T...) -> U`, and `trait
fn once(T...) -> U` at each arity, like tuples); and had closure literals
desugar to anonymous structs `impl`ing the appropriate trait (similarly to
C++ lambdas). Perhaps the current closure types could then also desugar to
the afore-mentioned things.




If you got this far: thanks for reading! (My condolences.) I hope any of
this proves to be useful in any way. I'd be happy to elaborate on anything
if anyone wants me to elaborate on it.

-G?bor


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/622f94b4/attachment-0001.html>

From willingc at willingconsulting.com  Fri Nov 15 08:08:15 2013
From: willingc at willingconsulting.com (Carol Willing)
Date: Fri, 15 Nov 2013 08:08:15 -0800
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
Message-ID: <528646EF.4080700@willingconsulting.com>

On 11/15/13 6:55 AM, Marijn Haverbeke wrote:
> As the author of the original tutorial I'm interested in what people
> hate so much about it. It appears to have slightly bit-rotted, in that
> the language moved on and people haphazardly updated stuff here and
> there, but the bulk of it still looks coherent. Can I get some
> concrete pointers?
>
Marijn,

I have been using The Rust Language Tutorial for the past few weeks. I 
have found it to be a very good overview of the language and its 
essentials. Personally, I like the little code snippets that illustrate 
examples of a particular language feature or aspect. Overall, it's an 
very organized and helpful overview of the language.

Section 19 of the Rust Language tutorial does humbly point out that 
there are additional tutorials and areas for delving deeper into the 
language. As individuals, each of us has a unique learning style when 
approaching a new language. There is no "one size fits all" when it 
comes to documentation. As the language evolves and community continues 
to grow, I imagine more tutorials focused on specific areas about using 
Rust.

Thanks for creating the original tutorial on the Rust Language.

Carol


-- 
Carol Willing
Developer
Willing Consulting


From denis.spir at gmail.com  Fri Nov 15 08:55:53 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 15 Nov 2013 17:55:53 +0100
Subject: [rust-dev] typed loop variables & int num types
In-Reply-To: <52861343.30305@gmail.com>
References: <52861343.30305@gmail.com>
Message-ID: <52865219.4050300@gmail.com>

On 11/15/2013 01:27 PM, spir wrote:
> [...]

Thank you Huon & Daniel, your replies answer my needs. I supported the issue 
about removal of signed `int` as default (BAD! ;-).

Actually like `for i in range(1u, 9u)` as an alternative for `for i:uint in 
range(1 ,9)`, but there also, there should be not int as default.

Denis

From denis.spir at gmail.com  Fri Nov 15 09:18:49 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 15 Nov 2013 18:18:49 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
Message-ID: <52865779.9060803@gmail.com>

On 11/15/2013 03:55 PM, Marijn Haverbeke wrote:
> As the author of the original tutorial I'm interested in what people
> hate so much about it. It appears to have slightly bit-rotted, in that
> the language moved on and people haphazardly updated stuff here and
> there, but the bulk of it still looks coherent. Can I get some
> concrete pointers?

Very personal point of view: As I said elsewhere, I definitely don't find it bad 
as a document in itself. Rather, it is not a tutorial at all, in my view; quite 
the opposite. I would consider it as a "spec summary", a useful reminder for 
someone having learned and used Rust once, then let it down for while and coming 
back to it. I'd read this doc to refresh my mind.
That it also is outdated is a distinct issue (a more easily fixable one).

Side-note: I read the (big) french article on Rust 0.8 [2] and found it rather 
good as well. With this, Marijn's doc, and "Rust for Rubyist", we already have 
quite an amount of raw materiel to make a tutorial.
The big, big remaining issue is the QoPaMM (Question of Pointers & Memory 
Management ;-). I have not yet found any presentation satisfying *for me* (I 
insist: personal point of view). The problem is: how to make sense out of the 
mess? What does all that *mean*? Or: semantics, please! [1] The reason to choose 
this or that kind of pointer, or this or that kind od MM should be semantic: 
that they correspond to different kinds of elements in the app('s) model [3]. I 
have yet to find such a correspondance; until then, I find myself unable to 
write anything about that. Since now, I choose pointer kinds in a totally adhoc 
manner (except for & as func input, the only situation where it makes sense for me).

Denis

[1] 'semantic' means 'about meaning', not 'about what the machine does' ;-)
[2]  [http://linuxfr.org/news/presentation-de-rust-0-8], pointed to at the 
bottom of the 'Blogs' section of the Rust Docs web page 
[https://github.com/mozilla/rust/wiki/Docs]
[3] Questions of efficiency or such possibly coming in a later phase of 
development or thinking.

From alex at crichton.co  Fri Nov 15 09:28:49 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 15 Nov 2013 09:28:49 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <20131115110114.GC24821@Mr-Bennet>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
Message-ID: <CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>

>> Primarily, I believe that if desired, rustc should be able to generate an
>> executable or dynamic library with no dependence on any rust libraries. This
>> includes things like librustrt and libextra. Rust shouldn't be striving to lift
>> dependence on system libraries, that'll come at later times if need be.
>
> It seems like you *are* striving to lift dependencies on non-rust
> libraries, though. For example, you mention having libuv be statically
> imported into a .rlib file etc. Or did I misunderstand?

Hm, I suppose I should re-phrase. Rust's linkage model should not
attempt to lift dependence on global native libraries. These global
libraries (like libm and librt on linux) should be assumed to be
everywhere. Our result artifacts must always be linked against them
(if their functionality is used). On the other hand, any build
artifacts that are a result of a local build process should not be
considered downstream dependencies as well. To this end, I mainly
point out that rust should roll in local native static libraries, and
just live with global native dynamic libraries.

> Does this imply that all Rust programs will be executed with whatever
> specific version of libsundown and libuv was produced as part of the
> Rust compiler build process? (I'm not implying this is a bad thing,
> necessarily, just trying to understand)

Correct. We as distributors of the rust compile could choose to make
libsundown a dynamic library which is then distributed and
upgradeable. We may also choose to link it statically to show that it
cannot be in-place upgraded.

>> I would propose that the compiler automatically favors static
>> linkage over dynamic linkage due to various rust ABI issues.
>
> Could you elaborate? What issues are you thinking of?

I should rephrase. I'm not an ABI expert, and my concerns actually
aren't really that related to ABI (although I know that many others do
have concerns about this). My primary concern is the current fragility
of a symbol in rust. If I add a doc-comment in libstd, I will likely
change many symbols in the output dynamic library. This is another
problem entirely, but it has repercussions for this right now. In
favoring dynamic libraries, rust is stating that it is available for
an in-place upgrade. The rust compiler is currently sufficiently far
from this goal that I do not believe that we should be favoring
dynamic linking.

By favoring static linking instead, we are lifting ourselves from this
burden. When we upgrade the rust compiler a year from now (2.0, woo!),
all previous rust executables will continue to run just fine (assuming
they weren't linked dynamically). Additionally, any application which
has a linked version of rust will continue to work.

Does that make sense? This is a fairly major decision, and I want to
make sure that everyone's on board with it.

> Unless I'm missing something, it seems like what we would want to do
> is to have the .rlib file contain LLVM IR, at least for the Rust code
> that was compiled / statically linked against. If we can, I think we
> should just make LTO happen by default whenver you statically link,
> rather than having it be a separate option

Interesting idea! Sounds like this definitely along the right lines,
and so long as we don't advertise our .rlib format it sounds like we
can silently do this at any time in the future.

From rusty.gates at icloud.com  Fri Nov 15 09:29:26 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 15 Nov 2013 19:29:26 +0200
Subject: [rust-dev] Adding support for the non-virtual interface idiom
Message-ID: <9DC6B637-409C-4712-ABC0-5548CC43E8A6@icloud.com>

[I posted this yesterday, but since it didn't show up, I'm re-posting it. Sorry if it's a double post]

I'd like to be able to use the non-virtual interface (NVI) idiom:
http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface

The following two new features are needed to accomplish this:
1) To set trait-methods private (accessible only to other methods of that trait)
2) To set default (provided) trait-methods non-overridable

It could work something like this (deltas are the 'final' keyword and the 'priv' trait-methods):

pub trait Tr {
    final fn foo_and_back_again(&mut self) {
        self.foo();
        self.de_foo();
    }
    priv fn foo(&mut self);
    priv fn de_foo(&mut self);
}

pub struct St {
    n: int
}

impl Tr for St {
    fn foo_and_back_again(&mut self) {} // error: can't override a final method

    priv fn foo(&mut self) {
        self.n += 10;
    }

    priv fn de_foo(&mut self) {
        self.n -= 10;
    }
}

fn main() {
    let mut st = St { n: 11 };
    st.foo_and_back_again(); // OK
    st.foo();    // error: foo is private to Tr
    st.de_foo(); // error: de_foo is private to Tr
}

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/4488c663/attachment.html>

From danielmicay at gmail.com  Fri Nov 15 09:36:53 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 12:36:53 -0500
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <52865779.9060803@gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
	<52865779.9060803@gmail.com>
Message-ID: <CA+DvKQKVroKNZ2XOOMzoBWDc4JdCkCkcX4xxkhfneY6P_pvLmA@mail.gmail.com>

On Fri, Nov 15, 2013 at 12:18 PM, spir <denis.spir at gmail.com> wrote:
> On 11/15/2013 03:55 PM, Marijn Haverbeke wrote:
>>
>> As the author of the original tutorial I'm interested in what people
>> hate so much about it. It appears to have slightly bit-rotted, in that
>> the language moved on and people haphazardly updated stuff here and
>> there, but the bulk of it still looks coherent. Can I get some
>> concrete pointers?
>
>
> Very personal point of view: As I said elsewhere, I definitely don't find it
> bad as a document in itself. Rather, it is not a tutorial at all, in my
> view; quite the opposite. I would consider it as a "spec summary", a useful
> reminder for someone having learned and used Rust once, then let it down for
> while and coming back to it. I'd read this doc to refresh my mind.
> That it also is outdated is a distinct issue (a more easily fixable one).
>
> Side-note: I read the (big) french article on Rust 0.8 [2] and found it
> rather good as well. With this, Marijn's doc, and "Rust for Rubyist", we
> already have quite an amount of raw materiel to make a tutorial.
> The big, big remaining issue is the QoPaMM (Question of Pointers & Memory
> Management ;-). I have not yet found any presentation satisfying *for me* (I
> insist: personal point of view). The problem is: how to make sense out of
> the mess? What does all that *mean*? Or: semantics, please! [1] The reason
> to choose this or that kind of pointer, or this or that kind od MM should be
> semantic: that they correspond to different kinds of elements in the app('s)
> model [3]. I have yet to find such a correspondance; until then, I find
> myself unable to write anything about that. Since now, I choose pointer
> kinds in a totally adhoc manner (except for & as func input, the only
> situation where it makes sense for me).
>
> Denis
>
> [1] 'semantic' means 'about meaning', not 'about what the machine does' ;-)
> [2]  [http://linuxfr.org/news/presentation-de-rust-0-8], pointed to at the
> bottom of the 'Blogs' section of the Rust Docs web page
> [https://github.com/mozilla/rust/wiki/Docs]
> [3] Questions of efficiency or such possibly coming in a later phase of
> development or thinking.

A lot of what a Rust tutorial has to do is introduce move semantics,
value types, references and boxes to an audience who have perhaps
never heard of them. Understanding Rust requires an understanding of
these ownership concepts, so the tutorial needs to help build a solid
grasp of it.

If you have concrete feedback on where you're having trouble with this
section, it's welcome:
http://static.rust-lang.org/doc/master/tutorial.html#boxes

I only see it as flawed in the middle where it tries to mention trait
objects and struggles with a reasonable way to do it as they are
introduced later.

The current section on borrowed pointers (should be called references)
isn't very approachable, and reference-counted/managed pointers likely
belong in a separate tutorial explaining alternatives to the standard
ownership model.

From danielmicay at gmail.com  Fri Nov 15 09:42:46 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 12:42:46 -0500
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
	<CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
Message-ID: <CA+DvKQK6+OosMOMToknxBTFqFwFiKTujqaXL99Hr=SvxMRSd9A@mail.gmail.com>

On Fri, Nov 15, 2013 at 12:28 PM, Alex Crichton <alex at crichton.co> wrote:
>>> Primarily, I believe that if desired, rustc should be able to generate an
>>> executable or dynamic library with no dependence on any rust libraries. This
>>> includes things like librustrt and libextra. Rust shouldn't be striving to lift
>>> dependence on system libraries, that'll come at later times if need be.
>>
>> It seems like you *are* striving to lift dependencies on non-rust
>> libraries, though. For example, you mention having libuv be statically
>> imported into a .rlib file etc. Or did I misunderstand?
>
> Hm, I suppose I should re-phrase. Rust's linkage model should not
> attempt to lift dependence on global native libraries. These global
> libraries (like libm and librt on linux) should be assumed to be
> everywhere. Our result artifacts must always be linked against them
> (if their functionality is used). On the other hand, any build
> artifacts that are a result of a local build process should not be
> considered downstream dependencies as well. To this end, I mainly
> point out that rust should roll in local native static libraries, and
> just live with global native dynamic libraries.

This can't be assumed if we want to support freestanding use. Removing
the need for rust-core means support for environments without features
like floating point and amenities provided by a kernel to user-land
processes. Perhaps I'm misunderstanding what you mean here.

From d.glazman at partner.samsung.com  Fri Nov 15 09:53:43 2013
From: d.glazman at partner.samsung.com (Daniel Glazman)
Date: Fri, 15 Nov 2013 18:53:43 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CA+DvKQ+fdD+OpPu4B1TvvHqvjLGMLNFDSpn+CL-1X1b8gh5tpQ@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
	<CA+DvKQ+fdD+OpPu4B1TvvHqvjLGMLNFDSpn+CL-1X1b8gh5tpQ@mail.gmail.com>
Message-ID: <52865FA7.50702@partner.samsung.com>

On 15/11/13 15:59, Daniel Micay wrote:

> It's gets across most of the information, but it doesn't have a very
> compelling flow of examples. It teaches how to use language features
> rather than walking through building something with those features.
> 
> For example, the sections on owned boxes and borrowed pointers could
> be done by walking through the implementation of a singly-linked list.
> It's incredibly hard to actually do this without using too many
> features before they've been introduced.

Exactly my point.

Marijn (hey Marijn!!!), nobody "hates" your tutorial. It's an excellent
document, but made for programming language specialists with an already
quite advanced level. My comment was an optimization comment only:
tweaking a bit the way examples are chosen and designed, and explaining
better some complex vocabularies, it will attract more people to Rust
and will help smoothing the learning curve. That's all.

</Daniel>


From alex at crichton.co  Fri Nov 15 10:12:01 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 15 Nov 2013 10:12:01 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CA+DvKQK6+OosMOMToknxBTFqFwFiKTujqaXL99Hr=SvxMRSd9A@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
	<CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
	<CA+DvKQK6+OosMOMToknxBTFqFwFiKTujqaXL99Hr=SvxMRSd9A@mail.gmail.com>
Message-ID: <CAFnh-mcNr4TjKXbC6Z1zm2fxPFys75b6mzf53R6yQqn-QRFKLA@mail.gmail.com>

>> Hm, I suppose I should re-phrase. Rust's linkage model should not
>> attempt to lift dependence on global native libraries. These global
>> libraries (like libm and librt on linux) should be assumed to be
>> everywhere. Our result artifacts must always be linked against them
>> (if their functionality is used). On the other hand, any build
>> artifacts that are a result of a local build process should not be
>> considered downstream dependencies as well. To this end, I mainly
>> point out that rust should roll in local native static libraries, and
>> just live with global native dynamic libraries.
>
> This can't be assumed if we want to support freestanding use. Removing
> the need for rust-core means support for environments without features
> like floating point and amenities provided by a kernel to user-land
> processes. Perhaps I'm misunderstanding what you mean here.

In saying this is what I think that rust should do, I should also
mention that I know of no other method of doing this. If rustc creates
a static library, then it may have no dynamic dependencies encoded
anywhere. Global dependencies are not a problem which can be solved by
static linking or not, they are a problem of the standard library
itself. Here's a little example.

On linux, the libm library is a global system dynamic library (if I'm
wrong, just assume it is). Rust's stdlib has a requirement on this
library, acos. This is defined on floating point values (the acos)
function, and this will eventually call the corresponding libm
function. In this scenario, it is impossible to distribute a libstd
which does *not* have a dependence on libm if you use the acos
function (or at least it's impossible within the limits of my
knowledge).

Now that being said, all is not lost. First off, if we have a static
libstd.rlib, then I believe that this would "just work". In my scheme,
let's say you want to create a static library with no dependence on
any global dynamic libraries. This means that you will statically link
to libstd.rlib, creating libfoo.a. In doing so, the compiler will warn
you about the dynamic library dependencies of libstd, in this case
that includes libm. The compiler will *not* bring in any of them as
dependencies (because it can't). When you link libfoo.a into your
application, you will get an undefined reference error if you used the
acos function, or you will get no error at all if you did not use the
acos function. If you receive an error, you learn that the dynamic
dependencies which were not linked are probably needed for those
symbols.

All in all, a major goal of this redesign is to support freestanding
usage of rust. Rust's linkage model should not prevent you from using
rust in virtually any location. This redesign is not a "silver bullet"
in making freestanding rust work, there is more changes which need to
happen elsewhere. Rust currently has a number of dynamic library
dependencies on various platforms, and we need to figure out how to
drop them in some situations. For example, perhaps the introduction of
the libm dependency should only be done if you compile the num::f64
module, and perhaps this module shouldn't be compiled in the --cfg
freestanding version of libstd.

Does that make sense? I want to make sure that *linkage* does not
block freestanding rust. If all of this were implemented tonight, I
don't believe that rust would be "completely ready" for freestanding
use, but it would be a whole lot closer.

From gaetan at xeberon.net  Fri Nov 15 10:37:20 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 15 Nov 2013 19:37:20 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <52865FA7.50702@partner.samsung.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
	<CA+DvKQ+fdD+OpPu4B1TvvHqvjLGMLNFDSpn+CL-1X1b8gh5tpQ@mail.gmail.com>
	<52865FA7.50702@partner.samsung.com>
Message-ID: <CANK7tAEprp_5qd2ok-f-pUMxWTg5dM=s-JGgk2_ZhMNeqYdMzw@mail.gmail.com>

I agree on the semantic point.

The job of technical writer is quite a talent to have, not anyone can
easily vulgarize concept and present them in a logical way. This is
pedagogy and quite hard to set up in a developer's brain.

However, on tutorial I think there is a flaw: most of the a time, just the
source code itsn't enough. If you want to test and play with it, you need
some other files (makefiles, crates declarations, ...) to have it running.
While it's good to have the code sample right on the screen, if I want to
take it and paste it to test its behavior, i have to deploy a large among
of work, to find similar compile samples and replace the files.

I would recommend to have some kind of "package" with makefile and source
code easily accessible, described early in the tutorial. Not completly
described, but it basically say: "don't try (yet) to understand what all
these Makefile and lib.rs and other stuff do, just edit the "sample.rs file
and type "make".
I would love to have this package automatized and freely available on each
source code trace in the tutorial.

-----
Gaetan



2013/11/15 Daniel Glazman <d.glazman at partner.samsung.com>

> On 15/11/13 15:59, Daniel Micay wrote:
>
> > It's gets across most of the information, but it doesn't have a very
> > compelling flow of examples. It teaches how to use language features
> > rather than walking through building something with those features.
> >
> > For example, the sections on owned boxes and borrowed pointers could
> > be done by walking through the implementation of a singly-linked list.
> > It's incredibly hard to actually do this without using too many
> > features before they've been introduced.
>
> Exactly my point.
>
> Marijn (hey Marijn!!!), nobody "hates" your tutorial. It's an excellent
> document, but made for programming language specialists with an already
> quite advanced level. My comment was an optimization comment only:
> tweaking a bit the way examples are chosen and designed, and explaining
> better some complex vocabularies, it will attract more people to Rust
> and will help smoothing the learning curve. That's all.
>
> </Daniel>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/ff3c275b/attachment.html>

From danielmicay at gmail.com  Fri Nov 15 10:39:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 15 Nov 2013 13:39:03 -0500
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CANK7tAEprp_5qd2ok-f-pUMxWTg5dM=s-JGgk2_ZhMNeqYdMzw@mail.gmail.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEWD6swroYKrKJvvuONosshUw-SneepRaR7mwMEqETNXA@mail.gmail.com>
	<CA+DvKQJexqQ5tCU3L6h2trbW1JSoq+1OKvS_Y2Hkuyuj3U4hOg@mail.gmail.com>
	<CAJnHWXutivgjpA61LUG13dE4u1DjpHQaxz_tri5M1j2U1gfRCQ@mail.gmail.com>
	<CA+DvKQ+fdD+OpPu4B1TvvHqvjLGMLNFDSpn+CL-1X1b8gh5tpQ@mail.gmail.com>
	<52865FA7.50702@partner.samsung.com>
	<CANK7tAEprp_5qd2ok-f-pUMxWTg5dM=s-JGgk2_ZhMNeqYdMzw@mail.gmail.com>
Message-ID: <CA+DvKQK5h7oBXF1ye6xbC=224DFCZBdQmx1zb07P-tJcjRdpig@mail.gmail.com>

On Fri, Nov 15, 2013 at 1:37 PM, Gaetan <gaetan at xeberon.net> wrote:
> I agree on the semantic point.
>
> The job of technical writer is quite a talent to have, not anyone can easily
> vulgarize concept and present them in a logical way. This is pedagogy and
> quite hard to set up in a developer's brain.
>
> However, on tutorial I think there is a flaw: most of the a time, just the
> source code itsn't enough. If you want to test and play with it, you need
> some other files (makefiles, crates declarations, ...) to have it running.
> While it's good to have the code sample right on the screen, if I want to
> take it and paste it to test its behavior, i have to deploy a large among of
> work, to find similar compile samples and replace the files.
>
> I would recommend to have some kind of "package" with makefile and source
> code easily accessible, described early in the tutorial. Not completly
> described, but it basically say: "don't try (yet) to understand what all
> these Makefile and lib.rs and other stuff do, just edit the "sample.rs file
> and type "make".
> I would love to have this package automatized and freely available on each
> source code trace in the tutorial.
>
> -----
> Gaetan

All of the code samples in the tutorial could be executable/editable
in the browser just like the functionality `rusti` provides in the IRC
channel.

From niko at alum.mit.edu  Fri Nov 15 10:52:16 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 15 Nov 2013 13:52:16 -0500
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
	<CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
Message-ID: <20131115185216.GB28551@Mr-Bennet>

On Fri, Nov 15, 2013 at 09:28:49AM -0800, Alex Crichton wrote:
> To this end, I mainly
> point out that rust should roll in local native static libraries, and
> just live with global native dynamic libraries.

How does rustc know the difference? Because the "local native" libraries
are tagged as #[link(once)]? (nit: maybe link(static) would be clearer?)

> I should rephrase. I'm not an ABI expert, and my concerns actually
> aren't really that related to ABI (although I know that many others do
> have concerns about this). My primary concern is the current fragility
> of a symbol in rust. If I add a doc-comment in libstd, I will likely
> change many symbols in the output dynamic library. This is another
> problem entirely, but it has repercussions for this right now. In
> favoring dynamic libraries, rust is stating that it is available for
> an in-place upgrade. The rust compiler is currently sufficiently far
> from this goal that I do not believe that we should be favoring
> dynamic linking.

Is this just a matter of changing what is hashed when we construct the
symbol name (or dropping the symbol hashes entirely)? That doesn't
seem very far. Are there are a lot of other things standing in the
way that immediately come to mind? Can we try and document what those
issues are?

Things that I can think of off the top of my head:

- Static constants: what things are compiled in to foreign crates?

- Enum discriminants: do we want to provide a (slow) way for crates to
  match against enum variants without inlining the discriminat value
  associated with each variant?

- Inline and generic functions: currently, we export the bodies of fns
  that are marked #[inline] or which are public and generic. Clearly
  if one is concerned about binary compatibility, these functions are
  the most subtle ones to reason about, since a downstream consumer
  will continue to use the old version *even if* they link against
  your new library.

  It might make sense to have a rule that, in a dynamic linking
  scenario, no function body is exported that is not explicitly
  annotated for export. This implies that we have a way to
  "pre-instantiate" generic functions (like C++ does) and probably
  that we have an annotation that means "export this IR so it can be
  instantiated" but which does not provide an LLVM inline hint, since
  that might not be appropriate.

> Does that make sense? This is a fairly major decision, and I want to
> make sure that everyone's on board with it.

Regardless of whether or not we are able to present a clear ABI
compatibility story (and I agree we do not right now), it's always
going to be a fairly complicated set of requirements that library
authors will have to reason about. We can make rules that guarantee
binary compatibility, but that does not imply semantic compatibility.
The sense of a boolean parameter might change, for example, or the set
of flags might change. Therefore, I can see an argument that says one
ought to "opt in" to dynamic linking.

OTOH, it's more the producer that has to be careful about using
semantic versioning and so on, not so much the consumer, so I'm not
sure whether that argument really makes sense.



Niko

From niko at alum.mit.edu  Fri Nov 15 10:58:14 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Fri, 15 Nov 2013 13:58:14 -0500
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<20131114165743.GC6546@Mr-Bennet>
	<282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>
Message-ID: <20131115185814.GC28551@Mr-Bennet>

On Thu, Nov 14, 2013 at 09:05:40PM +0200, Tommi wrote:
> > In other words, no autoderef or other transformation takes place.  We
> > just look for a matching trait. Instead we just pass the values in by
> > reference. The reason for passing by reference is so that you can
> > compare linear types more naturally (i.e., `~[1, 2, 3]`).
> 
> 
> I'm sorry, I don't understand that last point. Can you explain why
> it makes those comparisons more natural.

Because if you do not pass such types by reference, then they would be consumed
as part of the comparison. Let me just write out some functions to explain
what I mean.

Imagine I had a comparison function for vectors:

    fn cmp<T>(x: ~[T], y: ~[T]) -> bool {
        x.len() == y.len() && x.iter().zip(y.iter()).all(|a, b| a == b)
    }

Now, when I call this function, it is going to take ownership of its
arguments:

    let x = ~[1, 2, 3];
    let y = ~[4, 5, 6];
    if cmp(x, y) {
       use(x); // error
    }

This is obviously silly. So the solution is to pass those types by
reference:

    fn cmp<T>(x: &~[T], y: &~[T]) -> bool {
        x.len() == y.len() && x.iter().zip(y.iter()).all(|a, b| a == b)
    }
    ...

    let x = ~[1, 2, 3];
    let y = ~[4, 5, 6];
    if cmp(&x, &y) {
       use(x); // error
    }

This is precisely what the binary operators are designed to do. In
general, the overloadable binary operators are mathematical functions
of their arguments that are not expected to modify their arguments:
`==`, `+`, `-`, and so on, so it doesn't make sense for them to take
ownership of the data they operate on.


Niko


From alex at crichton.co  Fri Nov 15 10:58:57 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 15 Nov 2013 10:58:57 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <20131115185216.GB28551@Mr-Bennet>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
	<CAFnh-mdfKfHA=nZ3MMRLGLB_86JDS3j=u5s=MZ2CGCBeHnaTGQ@mail.gmail.com>
	<20131115185216.GB28551@Mr-Bennet>
Message-ID: <CAFnh-mcJUtgRE-s36NLz8Dzu8ZPe210PcM1qioEi=7GN--hpxQ@mail.gmail.com>

>> To this end, I mainly
>> point out that rust should roll in local native static libraries, and
>> just live with global native dynamic libraries.
>
> How does rustc know the difference? Because the "local native" libraries
> are tagged as #[link(once)]? (nit: maybe link(static) would be clearer?)

You're correct, this is the reason that I added the #[link(once)]. I
don't want rustc to start guessing about LD_LIBRARY_PATH and weird
business like that, so I'd rather that the author just be explicitly
about the native library.

I also agree that #[link(static)] is clearer.

> Is this just a matter of changing what is hashed when we construct the
> symbol name (or dropping the symbol hashes entirely)? That doesn't
> seem very far. Are there are a lot of other things standing in the
> way that immediately come to mind? Can we try and document what those
> issues are?

This is correct. This is tangentially related to
https://github.com/mozilla/rust/issues/10207 along with
https://github.com/mozilla/rust/issues/10208. I have many thoughts on
this, although they don't quite relate to static linking, so I'll try
to write them up later. The main idea is that the SVH from 10207 is in
all symbol names, and the SVH is a hash of "all reachable things"
which includes many things you may not initially consider (many of
which you pointed out).

From vadimcn at gmail.com  Fri Nov 15 12:00:34 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 15 Nov 2013 12:00:34 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
Message-ID: <CADecdiK_=0S4q+ZetC5=5Jde4q5-jj5G2Gev5BMku7wDpfrF=A@mail.gmail.com>

So in the case of --staticlib, if my Rust library, libmycomp.a, depended on
non-Rust local native library, libfoo.a, would Rust then bundle all modules
from libfoo into libmycomp?   Or would it only do so for Rust libraries,
e.g. libstd.a?


On Fri, Nov 15, 2013 at 12:09 AM, Alex Crichton <alex at crichton.co> wrote:

> I've been thinking about static linking recently, along with a little bit
> of
> linking in general, and I wanted to see what others thought.
>
> # The Goal
>
> Primarily, I believe that if desired, rustc should be able to generate an
> executable or dynamic library with no dependence on any rust libraries.
> This
> includes things like librustrt and libextra. Rust shouldn't be striving to
> lift
> dependence on system libraries, that'll come at later times if need be.
>
> Additionally, rustc should be able to generate libfoo.a where libfoo.a has
> no
> dependence on any rust libraries. This library can then be statically
> linked to
> another application.
>
> # Intermediate static libraries
>
> I personally know of no way to create a static library from a dynamic one,
> so to
> achieve this we would need to distribute libstd and libextra in some form
> that
> is not a shared library. This problem not only applies to libstd, but also
> to
> any rust library which wants to be statically linked.
>
> The first natural conclusion for for an intermediate format would be a .a
> file
> itself. Why not distribute libstd.a along with libstd.so. After all, a .a
> is
> only an archive which in our case would contain one .o file. In thinking
> about
> this though, I don't think that this is the best format. The main idea of
> providing intermediate .a files is to allow linkage to them via the normal
> system linker. To be usable, this would mean that all .a files rust
> generates
> would have to have their own statically linked version of libstd or
> otherwise
> everyone will have to find where libstd is guess the name and hash
> attached to
> it. This is infeasible for arbitrary libraries which could have
> arbitrarily many
> dependencies.
>
> # Native Libraries
>
> One part of linking which rust cannot forget is native libraries. Right
> now,
> native libraries are always linked against when compiling a local crate,
> but no
> native library dependencies are propagated among crates.
>
> Due to the nature of a static library and what I assume is the file format
> itself, a static rust library cannot link to its dependent dynamic
> libraries. We
> can, however, resolve all native static dependencies at compile time.
>
> # A Scheme for Linking
>
> With the above knowledge, I would propose the following linkage model for
> rust.
>
> There are four types of files that the rust compiler will generate:
>
> 1. An executable
> 2. A dynamic library (.so, .dylib, .dll)
> 3. A "rust" static library (.rlib)
> 4. A regular static library (.a, .lib)
>
> The "rust language" would ship with dynamic library files as well as .rlib
> files. There would be no .a files in the distribution.
>
> A rust static library would be a format defined by rust that is not
> available
> for or intended for external use. It is meant to be beneficial to the rust
> compiler and that's it. It just so happens that their first incarnation
> would be
> created similarly to `cp foo.o foo.rlib`.
>
> In addition to these changes, the linkage attributes would change to be as
> follows:
>
> * #[link_args] becomes gated behind a feature flag. I believe that this is
> still
>   a very useful ability to pass arbitrary flags to the linker, but this is
> *not*
>   a sanctioned way of doing so at all because of how platform specific it
> is
>
> * #[link(...)] becomes the new method of specifying linkage semantics on
> extern
>   blocks, and it may be used similarly to link_args today
>
>   * #[link(name = "foo")] specifies that this crate links to native library
>     `foo`
>   * #[link(once)] implies that the native library is a static library,
> hence it
>     *must* be linked against in the current compilation, regardless of the
>     output format
>
>   Omission of `link(once)` assumes that the library is available at all
>   destinations, and it may not be linked against in the current compilation
>   unit.
>
> ## The Linkage Step
>
> To see how this affects how artifacts are created, I'd like to go into
> detail
> about how each of the four output artifacts all interact with one another
> by
> describing the linkage phase of each output. For each of these, remember
> that
> the compiler's output is one .o file for each crate. Also remember that
> all rust
> libraries will always link to all upstream rust libraries.
>
> ### Linking Executables and Dynamic Libraries
>
> These two cases are very similar because they are creating the actual
> "result
> artifact" in terms of a file which will have no more linkage performed on
> it.
> The following components must be linked in to produce the artifact:
>
> * The local .o file
> * All local native dependencies
> * All upstream rust libraries (dynamic and static)
> * All non-once (dynamic) native libraries of upstream static crates. More
> on
>   this later
>
> The result artifact needs to be a fully resolved destination artifact. The
> point
> of this is to have a dynamic dependency on all upstream dynamic libraries,
> and
> all upstream static libraries will have been sucked in to create the
> target.
>
> ### Creating rust static libraries (.rlib files)
>
> As mentioned above, these files are similar to the compiler's .o output.
> The
> only other component which can be considered for inclusion in this .o file
> is
> all native static library dependencies. These are encoded as #[link(once)]
> in
> linkage attributes. The reason for doing this is that it's likely to be
> common
> to have a local static library which is not available in distribution, but
> is
> always available for the build process. Examples for the compiler include
> libsundown, libuv, libuv_support, and maybe librustrt.
>
> The .rlib file will be created by using ld's -r flag. This output will
> then have
> all native static dependencies resolved, but remember that no rust
> dependencies
> were part of this linkage process. Whenever this .rlib file is used, all
> of its
> dependencies are encoded in the metadata and they're all sucked in at the
> end as
> well.
>
> The goal of not pulling in all rust dependencies is to avoid finding a
> static
> copy of libstd in all .rlib files everywhere.
>
> ### Creating a system static library (.a or .lib)
>
> The whole point of being able to do this is so that a rust component can be
> statically linked into another application. The idea behind this mode of
> compilation is to be just as much of a destination artifact as an
> executable or
> dynamic library. The rust compiler will never attempt to link against
> rust-generated .a files (it has .rlib files to look for). The .a files are
> purely meant for external usage.
>
> Again though, due to the nature of the .a format, we cannot be as
> comprehensive
> in our dependency resolution as we were in the above cases. The first
> thing to
> consider is all inputs to this file:
>
> * The compiler's output .o file
> * All local native static libraries
> * All upstream rust .rlib files
>
> Note how there is no mention of upstream dynamic library dependencies.
> Sadly, I
> know of encoding those dependencies in this .a output format. I would
> propose
> the compiler printing a warning when this is performed such that when
> undefined
> references are found you at least have a suggestion of what dynamic
> libraries
> you need to link against.
>
> ## Static vs Dynamic
>
> This scheme outlines the ability to manage static and dynamic native
> libraries,
> but it would mean that we're going to start introducing static and dynamic
> rust
> libraries in the same location. I would propose that the compiler
> automatically
> favors static linkage over dynamic linkage due to various rust ABI issues.
> This
> default could be switched in the future, but it simply means that if the
> compiler finds a .so and a .rlib, it will suck in the .rlib before sucking
> in
> the .so.
>
> ## Compiler UI
>
> If we have a scheme like this, we certainly need a method of managing it
> from
> the command line. I would propose dropping all linkage related flags we
> have
> today, and starting over with the following:
>
> * --rlib, --dylib, --staticlib. These three options are stackable, and
> control
>   the output format of the compiler. If nothing is specified, then an
> executable
>   is assumed. The reason that these are stackable is becuase it is possible
>   to create multiple artifacts from one compilation instead of having to
>   recompile
>
> * -Z print-link-args. This is the same as it is today
>
> # Conclusion
>
> I originally thought that this would be a proposal for adding static
> linking,
> but this has kinda become more of a makeover of rust's current linkage
> model. I
> believe that this scheme will solve the "static library" problem as well as
> still accomodating the dynamic library approach that we have today. I
> wanted to
> get this all down in writing, and I feel like this is certainly concrete
> enough
> to act upon, but before doing so this should definitely be discussed.
>
> What are others' thoughts on this? Is this too complex of a system? Is
> there a
> glaring omission of use cases?
>
> Hopefully soon we can generate a rust library with no dynamic rust
> dependencies!
>
> ---
>
> As a side node, after writing all this up, I remembered LTO as an
> option for generating libraries. I don't think I know enough about LTO
> to be able to say whether it would fit in this system or not, but my
> basic understanding is that an LTO library is just "IR in a box". We
> could add a --lto output option which has pretty much the same
> semantics as the --rlib option, but with a different format. Again
> though, I haven't thought how native libraries would fit into that
> scenario, but I believe that we could fairly easily accommodate LTO in
> a system like this.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/2d50ba16/attachment.html>

From alex at crichton.co  Fri Nov 15 12:12:14 2013
From: alex at crichton.co (Alex Crichton)
Date: Fri, 15 Nov 2013 12:12:14 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CADecdiK_=0S4q+ZetC5=5Jde4q5-jj5G2Gev5BMku7wDpfrF=A@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<CADecdiK_=0S4q+ZetC5=5Jde4q5-jj5G2Gev5BMku7wDpfrF=A@mail.gmail.com>
Message-ID: <CAFnh-mcrAjiwpN3t_rMWKRWQj1wwdkgxePvM4YBvhzpvnTTnAw@mail.gmail.com>

You would be required to specify that the native library would be static via

#[link(name = "foo", static)]
extern { ... }

And then rustc would bundle libfoo.a with libmycomp.a. libmycomp.a
would also include any upstream rust dependencies (libstd.a,
libextra.a, etc.)

On Fri, Nov 15, 2013 at 12:00 PM, Vadim <vadimcn at gmail.com> wrote:
> So in the case of --staticlib, if my Rust library, libmycomp.a, depended on
> non-Rust local native library, libfoo.a, would Rust then bundle all modules
> from libfoo into libmycomp?   Or would it only do so for Rust libraries,
> e.g. libstd.a?
>
>
> On Fri, Nov 15, 2013 at 12:09 AM, Alex Crichton <alex at crichton.co> wrote:
>>
>> I've been thinking about static linking recently, along with a little bit
>> of
>> linking in general, and I wanted to see what others thought.
>>
>> # The Goal
>>
>> Primarily, I believe that if desired, rustc should be able to generate an
>> executable or dynamic library with no dependence on any rust libraries.
>> This
>> includes things like librustrt and libextra. Rust shouldn't be striving to
>> lift
>> dependence on system libraries, that'll come at later times if need be.
>>
>> Additionally, rustc should be able to generate libfoo.a where libfoo.a has
>> no
>> dependence on any rust libraries. This library can then be statically
>> linked to
>> another application.
>>
>> # Intermediate static libraries
>>
>> I personally know of no way to create a static library from a dynamic one,
>> so to
>> achieve this we would need to distribute libstd and libextra in some form
>> that
>> is not a shared library. This problem not only applies to libstd, but also
>> to
>> any rust library which wants to be statically linked.
>>
>> The first natural conclusion for for an intermediate format would be a .a
>> file
>> itself. Why not distribute libstd.a along with libstd.so. After all, a .a
>> is
>> only an archive which in our case would contain one .o file. In thinking
>> about
>> this though, I don't think that this is the best format. The main idea of
>> providing intermediate .a files is to allow linkage to them via the normal
>> system linker. To be usable, this would mean that all .a files rust
>> generates
>> would have to have their own statically linked version of libstd or
>> otherwise
>> everyone will have to find where libstd is guess the name and hash
>> attached to
>> it. This is infeasible for arbitrary libraries which could have
>> arbitrarily many
>> dependencies.
>>
>> # Native Libraries
>>
>> One part of linking which rust cannot forget is native libraries. Right
>> now,
>> native libraries are always linked against when compiling a local crate,
>> but no
>> native library dependencies are propagated among crates.
>>
>> Due to the nature of a static library and what I assume is the file format
>> itself, a static rust library cannot link to its dependent dynamic
>> libraries. We
>> can, however, resolve all native static dependencies at compile time.
>>
>> # A Scheme for Linking
>>
>> With the above knowledge, I would propose the following linkage model for
>> rust.
>>
>> There are four types of files that the rust compiler will generate:
>>
>> 1. An executable
>> 2. A dynamic library (.so, .dylib, .dll)
>> 3. A "rust" static library (.rlib)
>> 4. A regular static library (.a, .lib)
>>
>> The "rust language" would ship with dynamic library files as well as .rlib
>> files. There would be no .a files in the distribution.
>>
>> A rust static library would be a format defined by rust that is not
>> available
>> for or intended for external use. It is meant to be beneficial to the rust
>> compiler and that's it. It just so happens that their first incarnation
>> would be
>> created similarly to `cp foo.o foo.rlib`.
>>
>> In addition to these changes, the linkage attributes would change to be as
>> follows:
>>
>> * #[link_args] becomes gated behind a feature flag. I believe that this is
>> still
>>   a very useful ability to pass arbitrary flags to the linker, but this is
>> *not*
>>   a sanctioned way of doing so at all because of how platform specific it
>> is
>>
>> * #[link(...)] becomes the new method of specifying linkage semantics on
>> extern
>>   blocks, and it may be used similarly to link_args today
>>
>>   * #[link(name = "foo")] specifies that this crate links to native
>> library
>>     `foo`
>>   * #[link(once)] implies that the native library is a static library,
>> hence it
>>     *must* be linked against in the current compilation, regardless of the
>>     output format
>>
>>   Omission of `link(once)` assumes that the library is available at all
>>   destinations, and it may not be linked against in the current
>> compilation
>>   unit.
>>
>> ## The Linkage Step
>>
>> To see how this affects how artifacts are created, I'd like to go into
>> detail
>> about how each of the four output artifacts all interact with one another
>> by
>> describing the linkage phase of each output. For each of these, remember
>> that
>> the compiler's output is one .o file for each crate. Also remember that
>> all rust
>> libraries will always link to all upstream rust libraries.
>>
>> ### Linking Executables and Dynamic Libraries
>>
>> These two cases are very similar because they are creating the actual
>> "result
>> artifact" in terms of a file which will have no more linkage performed on
>> it.
>> The following components must be linked in to produce the artifact:
>>
>> * The local .o file
>> * All local native dependencies
>> * All upstream rust libraries (dynamic and static)
>> * All non-once (dynamic) native libraries of upstream static crates. More
>> on
>>   this later
>>
>> The result artifact needs to be a fully resolved destination artifact. The
>> point
>> of this is to have a dynamic dependency on all upstream dynamic libraries,
>> and
>> all upstream static libraries will have been sucked in to create the
>> target.
>>
>> ### Creating rust static libraries (.rlib files)
>>
>> As mentioned above, these files are similar to the compiler's .o output.
>> The
>> only other component which can be considered for inclusion in this .o file
>> is
>> all native static library dependencies. These are encoded as #[link(once)]
>> in
>> linkage attributes. The reason for doing this is that it's likely to be
>> common
>> to have a local static library which is not available in distribution, but
>> is
>> always available for the build process. Examples for the compiler include
>> libsundown, libuv, libuv_support, and maybe librustrt.
>>
>> The .rlib file will be created by using ld's -r flag. This output will
>> then have
>> all native static dependencies resolved, but remember that no rust
>> dependencies
>> were part of this linkage process. Whenever this .rlib file is used, all
>> of its
>> dependencies are encoded in the metadata and they're all sucked in at the
>> end as
>> well.
>>
>> The goal of not pulling in all rust dependencies is to avoid finding a
>> static
>> copy of libstd in all .rlib files everywhere.
>>
>> ### Creating a system static library (.a or .lib)
>>
>> The whole point of being able to do this is so that a rust component can
>> be
>> statically linked into another application. The idea behind this mode of
>> compilation is to be just as much of a destination artifact as an
>> executable or
>> dynamic library. The rust compiler will never attempt to link against
>> rust-generated .a files (it has .rlib files to look for). The .a files are
>> purely meant for external usage.
>>
>> Again though, due to the nature of the .a format, we cannot be as
>> comprehensive
>> in our dependency resolution as we were in the above cases. The first
>> thing to
>> consider is all inputs to this file:
>>
>> * The compiler's output .o file
>> * All local native static libraries
>> * All upstream rust .rlib files
>>
>> Note how there is no mention of upstream dynamic library dependencies.
>> Sadly, I
>> know of encoding those dependencies in this .a output format. I would
>> propose
>> the compiler printing a warning when this is performed such that when
>> undefined
>> references are found you at least have a suggestion of what dynamic
>> libraries
>> you need to link against.
>>
>> ## Static vs Dynamic
>>
>> This scheme outlines the ability to manage static and dynamic native
>> libraries,
>> but it would mean that we're going to start introducing static and dynamic
>> rust
>> libraries in the same location. I would propose that the compiler
>> automatically
>> favors static linkage over dynamic linkage due to various rust ABI issues.
>> This
>> default could be switched in the future, but it simply means that if the
>> compiler finds a .so and a .rlib, it will suck in the .rlib before sucking
>> in
>> the .so.
>>
>> ## Compiler UI
>>
>> If we have a scheme like this, we certainly need a method of managing it
>> from
>> the command line. I would propose dropping all linkage related flags we
>> have
>> today, and starting over with the following:
>>
>> * --rlib, --dylib, --staticlib. These three options are stackable, and
>> control
>>   the output format of the compiler. If nothing is specified, then an
>> executable
>>   is assumed. The reason that these are stackable is becuase it is
>> possible
>>   to create multiple artifacts from one compilation instead of having to
>>   recompile
>>
>> * -Z print-link-args. This is the same as it is today
>>
>> # Conclusion
>>
>> I originally thought that this would be a proposal for adding static
>> linking,
>> but this has kinda become more of a makeover of rust's current linkage
>> model. I
>> believe that this scheme will solve the "static library" problem as well
>> as
>> still accomodating the dynamic library approach that we have today. I
>> wanted to
>> get this all down in writing, and I feel like this is certainly concrete
>> enough
>> to act upon, but before doing so this should definitely be discussed.
>>
>> What are others' thoughts on this? Is this too complex of a system? Is
>> there a
>> glaring omission of use cases?
>>
>> Hopefully soon we can generate a rust library with no dynamic rust
>> dependencies!
>>
>> ---
>>
>> As a side node, after writing all this up, I remembered LTO as an
>> option for generating libraries. I don't think I know enough about LTO
>> to be able to say whether it would fit in this system or not, but my
>> basic understanding is that an LTO library is just "IR in a box". We
>> could add a --lto output option which has pretty much the same
>> semantics as the --rlib option, but with a different format. Again
>> though, I haven't thought how native libraries would fit into that
>> scenario, but I believe that we could fairly easily accommodate LTO in
>> a system like this.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>

From denis.spir at gmail.com  Fri Nov 15 12:21:44 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 15 Nov 2013 21:21:44 +0100
Subject: [rust-dev] Implementation complexity
In-Reply-To: <5285A883.6090008@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<528153D1.1030003@mozilla.com>	<CANK7tAGjAUG_tW=KO_tXdPOTbNHJrj5sQaYki1ObF-Q4MH1Lng@mail.gmail.com>	<52856B67.5070200@cantrip.org>	<5285A5A1.8060803@vandals.uidaho.edu>
	<5285A883.6090008@mozilla.com>
Message-ID: <52868258.4020406@gmail.com>

On 11/15/2013 05:52 AM, Patrick Walton wrote:
>> * One of the BIG problems with D uptake is the split library problem
>> referred to before. They could not get a comfortable standard library
>> for a long time, despite some extremely bright and decently famous
>> engineers working on D. My understanding is that it's mostly been solved
>> now (after what, 10 years?).  That'd be a disaster for Rust if things
>> split badly at the interface level.
>
> I agree, and I would like to prevent divergence. Divergence of *implementation*
> is OK and probably inevitable if Rust succeeds; divergence of API for no reason
> can harm the ecosystem.

If I may say a word on this (I have also been a D user), all this may well also 
be a human problem. People feel badly whenever decisions on points important for 
them are taken in opaque, rush, or uncooperative manners. D's first "official" 
stdlib was somewhat like that, and felt more or less undesigned (or 
unsufficiently); while the core language was already quite good, pleasant, 
strongly usable.

I'd rather wait one or even two or three years more than expected for Rust 1.0 
and get a design that most joyfully support or at least agree with... After all, 
we are waiting for a good static, systems programming language for, what, 40 
years? (Please, don't rush for 1.0, take the time needed.)

Denis

From rusty.gates at icloud.com  Fri Nov 15 15:37:27 2013
From: rusty.gates at icloud.com (Tommi Tissari)
Date: Sat, 16 Nov 2013 01:37:27 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <20131115185814.GC28551@Mr-Bennet>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<20131114165743.GC6546@Mr-Bennet>
	<282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>
	<20131115185814.GC28551@Mr-Bennet>
Message-ID: <F7406DFB-0460-4572-8244-C51114DE8C0F@icloud.com>


> On 15 Nov 2013, at 20:58, Niko Matsakis <niko at alum.mit.edu> wrote:
> 
> On Thu, Nov 14, 2013 at 09:05:40PM +0200, Tommi wrote:
>>> In other words, no autoderef or other transformation takes place.  We
>>> just look for a matching trait. Instead we just pass the values in by
>>> reference. The reason for passing by reference is so that you can
>>> compare linear types more naturally (i.e., `~[1, 2, 3]`).
>> 
>> 
>> I'm sorry, I don't understand that last point. Can you explain why
>> it makes those comparisons more natural.
> 
> Because if you do not pass such types by reference, then they would be consumed
> as part of the comparison. Let me just write out some functions to explain
> what I mean.
> 
> Imagine I had a comparison function for vectors:
> 
>    fn cmp<T>(x: ~[T], y: ~[T]) -> bool {
>        x.len() == y.len() && x.iter().zip(y.iter()).all(|a, b| a == b)
>    }
> 
> Now, when I call this function, it is going to take ownership of its
> arguments:
> 
>    let x = ~[1, 2, 3];
>    let y = ~[4, 5, 6];
>    if cmp(x, y) {
>       use(x); // error
>    }
> 
> This is obviously silly. So the solution is to pass those types by
> reference:
> 
>    fn cmp<T>(x: &~[T], y: &~[T]) -> bool {
>        x.len() == y.len() && x.iter().zip(y.iter()).all(|a, b| a == b)
>    }
>    ...
> 
>    let x = ~[1, 2, 3];
>    let y = ~[4, 5, 6];
>    if cmp(&x, &y) {
>       use(x); // error
>    }
> 
> This is precisely what the binary operators are designed to do. In
> general, the overloadable binary operators are mathematical functions
> of their arguments that are not expected to modify their arguments:
> `==`, `+`, `-`, and so on, so it doesn't make sense for them to take
> ownership of the data they operate on.
> 
> 
> Niko

But shouldn't the signature be:
fn cmp<T>(x: &[T], y: &[T]) -> bool

From dbau.pp at gmail.com  Fri Nov 15 16:07:26 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 16 Nov 2013 11:07:26 +1100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
Message-ID: <5286B73E.20509@gmail.com>

On 16/11/13 03:05, G?bor Lehel wrote:
> Hello list,
>
> I have some ideas about typey things and I'm going to write them down. 
> It will be long.
>
>

No kidding.

>
>
> It would be nice if `Trait1 + Trait2` were itself a trait, legal in 
> the same positions as any trait. This is already partly true: in trait 
> bounds on type parameters and super-traits of traits. Where it's not 
> true is trait objects, e.g. `~(ToStr + Send)`. Having this could 
> remove the need for the current `~Trait:OtherTraits` special syntax.
>
> I wonder whether lifetimes could also be interpreted as traits, with 
> the meaning: "[object of type implementing lifetime-trait] does not 
> outlive [the given lifetime]". This is an honest wondering: I'm not 
> sure if it makes sense. If it does make sense, it would fit in 
> perfectly with the fact that 'static is already a trait. Together with 
> the above, it might also allow a solution for capturing borrowed data 
> in a trait object: you could write `~(Trait + 'a)`.
>

How does this interact with vtables?

Note we can already get something similar with

    trait Combine1And2: Trait1 + Trait2 {}
    impl<T: Trait1 + Trait2> Combine1And2 for T {}

    // use ~Combine1And2

which makes it clear how the vtables work, since Combine1And2 has its 
own vtable explicitly constructed from the two traits. (I guess ~(Trait1 
+ Trait2) would be most useful if one could cast down to ~Trait1 and 
~Trait2.)

>
>
>
> The next few are going to be about higher- (or just different-) kinded 
> generics. To avoid confusion, I'm going to use "built-in trait" to 
> mean things like `Freeze` and `Send`, and "kind" to mean what it does 
> everywhere else in the non-Rustic world.
>
> I think the best available syntax for annotating the kinds of types 
> would be to borrow the same or similar syntax as used to declare them, 
> with either `type` or `struct` being the kind of "normal" non-generic 
> types (the only kind of type that current Rust lets you abstract 
> over). [I prefer `type`, because both structs and enums inhabit the 
> same kind.] This is kind of like how C++ does it. For example, the 
> kind of `Result` would be `type<type, type>`. Our `type` corresponds 
> to C++'s `typename` and Haskell's `*`, and `type<type, type>` to C++'s 
> `template<typename, typename> class` and Haskell's `* -> * -> *`. So, 
> for example, you could write the fully kind-annotated signature of an 
> identity function restricted to Result-shaped types (yeah, actually 
> doing this would be pointless!) as:
>
>     fn dumb_id<type<type, type> R, type A, type B>(x: R<A, B>) -> R<A, B>;
>
> To explicitly annotate the kind of the Self-type of a trait, we could 
> borrow the `for` syntax used in `impl`s. Here's the fully 
> kind-annotated version of the `Functor` trait familiar from Haskell:
>
>     trait Functor for type<type> Self {
>         fn fmap<type A, type B>(a: &Self<A>, f: |&A| -> B) -> Self<B>;
>     }
>
> (Obviously, explicitly annotating every kind would be tiresome, and 
> `Self` is a little redundant when nothing else could go there. I could 
> imagine `trait Functor for type<type>`, `trait Functor for Self`, 
> and/or `trait Functor` all being legal formulations of the above. I'll 
> get back to this later.)
>
>

Could this be:

    fn dumb_id<R<type, type>, A, B>(x: R<A, B>) -> R<A, B>;

and

    trait Functor<type> {
        fn fmap<A, B>(a: &Self<A>, f: |&A| -> B) -> Self<B>;
    }

Then something like  A<type<type>, type> would correspond to A :: (* -> 
*) -> * -> *. Speaking of which, could we just use *, `R<*, *>`, 
`R<*<*>, *>`, `trait Functor<*>`? Although that looks a little cryptic 
in the nested case.


Huon

From vadimcn at gmail.com  Fri Nov 15 16:24:49 2013
From: vadimcn at gmail.com (Vadim)
Date: Fri, 15 Nov 2013 16:24:49 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mcrAjiwpN3t_rMWKRWQj1wwdkgxePvM4YBvhzpvnTTnAw@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<CADecdiK_=0S4q+ZetC5=5Jde4q5-jj5G2Gev5BMku7wDpfrF=A@mail.gmail.com>
	<CAFnh-mcrAjiwpN3t_rMWKRWQj1wwdkgxePvM4YBvhzpvnTTnAw@mail.gmail.com>
Message-ID: <CADecdiKfaVcw_rfsq-wR9B-kHVzJzgd4OUmRjcVc124gru-=PA@mail.gmail.com>

What if the final executable also wants to link against a slightly newer
version of libfoo.a?   I'm not even sure what ld would do then.   Complains
about duplicate symbols?  Picks one at random?

I think I'd rather have Rust object file along with a list of libraries
that will be needed for final linking.  This could be a companion text file
or maybe a command line option to rustc, which dumps this info from
metadata.
And if I really do want a monolithic library file, I can always create one
with ar, can't I?

Vadim

On Fri, Nov 15, 2013 at 12:12 PM, Alex Crichton <alex at crichton.co> wrote:

> You would be required to specify that the native library would be static
> via
>
> #[link(name = "foo", static)]
> extern { ... }
>
> And then rustc would bundle libfoo.a with libmycomp.a. libmycomp.a
> would also include any upstream rust dependencies (libstd.a,
> libextra.a, etc.)
>
> On Fri, Nov 15, 2013 at 12:00 PM, Vadim <vadimcn at gmail.com> wrote:
> > So in the case of --staticlib, if my Rust library, libmycomp.a, depended
> on
> > non-Rust local native library, libfoo.a, would Rust then bundle all
> modules
> > from libfoo into libmycomp?   Or would it only do so for Rust libraries,
> > e.g. libstd.a?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/49b845d1/attachment.html>

From ongardie at gmail.com  Fri Nov 15 17:03:30 2013
From: ongardie at gmail.com (Diego Ongaro)
Date: Fri, 15 Nov 2013 17:03:30 -0800
Subject: [rust-dev] select on std::comm::Port and different types
In-Reply-To: <528576B1.3050909@mozilla.com>
References: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>
	<528576B1.3050909@mozilla.com>
Message-ID: <CABUcDvO1j0j8C8dQyhxWUu5i=N4Z4GaoBZv6CzvpV1W4_HLbEA@mail.gmail.com>

On Thu, Nov 14, 2013 at 5:19 PM, Brian Anderson <banderson at mozilla.com> wrote:
> On 11/14/2013 04:03 PM, Diego Ongaro wrote:
>>
>> My program starts a bunch of tasks, then I want the main task to both
>> receive ctrl-c signals and receive results from the children. The
>> signal will come from a std::rt::io::signal::Listener's port, which is
>> an std::comm::Port<Signum>. The child results will come from a
>> std::comm::Port<~[uint]>.
>>
>> My first problem is that std::comm::Port doesn't implement
>> std::select::Select. It looks like std::rt::comm::Port does, and
>> std::comm::Port is just a small wrapper around that, but
>> std::comm::Port makes its internal std::rt::comm::Port private. Is
>> there any way to select on a std::comm::Port? (And what's the
>> difference between a std::rt::comm::Port and a std::comm::Port?)
>
>
> There currently isn't a way - this feature isn't fully baked yet, but it
> should not take a whole lot of effort to get it working. There is no
> functional difference between  std::comm and std::rt::comm; std::rt::comm
> should be moved wholesale to std::comm and the current std::comm deleted,
> but it hasn't been done yet.

Ok. In the meantime until std::comm gets blown away, can we comment
out the "priv" keyword in it?  I've attached a patch that does this.
This patch would be enough to allow me and others to work around this
issue for now (see below).


>> My second problem is that std::select::select() doesn't seem to
>> support selecting from ports with different types. Naively, I tried
>> select([p1, p2]), but that expects p1 and p2 to have the same type:
>> error: mismatched types: expected
>> `std::rt::comm::Port<std::rt::io::signal::Signum>` but found
>> `std::rt::comm::Port<~[uint]>` (expected enum
>> std::rt::io::signal::Signum but found vector)
>> It'll need dynamic dispatch, so I tried: select([p1 as &Select, p2 as
>> &Select]). However, this doesn't work since &Select doesn't implement
>> Select:
>> error: failed to find an implementation of trait std::select::Select
>> for &std::select::Select<no-bounds>
>>
>> There's some commented out code that may be related in select.rs,
>> though it's hard for me to know where this stands:
>> /* FIXME(#5121, #7914) This all should be legal, but rust is not
>> clever enough yet.
>>
>> impl <'self> Select for &'self mut Select {
>>      fn optimistic_check(&mut self) -> bool { self.optimistic_check() }
>>      fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) ->
>> bool {
>>          self.block_on(sched, task)
>>      }
>>      fn unblock_from(&mut self) -> bool { self.unblock_from() }
>> }
>> ...
>>
>> How can I select on two ports of different types?
>
>
> My understanding is that this code needs to be enabled to make select on
> heterogenous types work correctly. I do not know the details of this code
> but it appears that Niko has not landed a fix for #5121 yet. Contributions
> here are very welcome.

I think this is beyond my understanding of Rust internals for now
(though hey, just started with Rust this week, who knows). I didn't
spend much time on it, but I wasn't able to get this code to work by
just removing the comments. Instead, I have a workaround that does the
job for me once the attached patch is applied. It creates a wrapper
struct called SelectBox which implements Select by forwarding all
methods of SelectInner to an &'self mut Select field. Then I created a
macro to make the syntax tolerable. That's all available at
https://gist.github.com/ongardie/7494388 along with an example.

Best,
Diego
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Disable-priv-in-std-comm-Port-etc.patch
Type: text/x-patch
Size: 1954 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131115/4bbfc759/attachment-0001.bin>

From rusty.gates at icloud.com  Fri Nov 15 19:48:00 2013
From: rusty.gates at icloud.com (Tommi)
Date: Sat, 16 Nov 2013 05:48:00 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
Message-ID: <0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>

So... did anyone think that my idea (of doing multiple-inheritance by separating the responsibilities of providing functionality and providing data between the trait and the type which implements the trait) would warrant an enhancement request at github? Or how do these things tend to work around here? (I've done plenty of bug/enhancement reporting for D, but I know that language fairly well whereas I've just barely read the Rust tutorial/manual).


On 2013-11-15, at 14:48, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> Thanks for the explanation! So virtual function calls are kept to the absolute theoretical minimum, that's very good to know.
> 
> In my case I have one crate for some "infrastructure" and another crate for the "application" using it (there would be several of these). I guess having two copies isn't that bad.
> 
> 
> On Fri, Nov 15, 2013 at 2:30 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> On Fri, Nov 15, 2013 at 6:54 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
> >
> > That would be awesome, if it were true; it is quite a trick to pull that off
> > when the default methods are implemented in a different crate. Can someone
> > provide an authoritative answer on this?
> >
> > Also, C++ faces the problem of providing a single copy of monomorphised
> > functions (for templates). This is done during the link phase and AFAIK is
> > one of the causes of C++ links taking a painfully long time. Will Rust
> > suffer from the same problem?
> 
> Rust serializes any generic or inline functions to an AST stored in
> the crate metadata and will re-compile them as-needed per-crate.
> 
> In both Rust and C++, you end up with one copy of these at runtime for
> each dynamically linked shared object. With C++ templates, the linker
> or link-time optimization discards duplicate instantiations across
> compilation units.
> 
> Rust doesn't have compilation units smaller than a crate so there is
> no equivalent functionality. If you use crates as compilation units to
> make compiles incremental/parallel, the situation is much worse than
> C++ as you'll have many duplicates and they won't even go away with
> link-time optimization until `mergefunc` works.
> 
> There's almost no point in doing anything but a massive crate at this point...
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/f3eef13e/attachment.html>

From ml at isaac.cedarswampstudios.org  Fri Nov 15 20:26:21 2013
From: ml at isaac.cedarswampstudios.org (Isaac Dupree)
Date: Fri, 15 Nov 2013 23:26:21 -0500
Subject: [rust-dev] Type system thoughts
In-Reply-To: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
Message-ID: <5286F3ED.1040607@isaac.cedarswampstudios.org>

On 11/15/2013 11:05 AM, G?bor Lehel wrote:
> Like C++, types could be parameterized over constants. Again, the syntax
> could mirror their declarations. For example, a function to construct a
> fixed-length array:
>
>      fn make_n<static N: int>(n: int) -> ~[int, ..N] { [n, ..N] }
>
> Interesting questions here include what types to allow, how or whether
> to handle literals of various types as type arguments, and the constant
> expression sublanguage.

Personally I'd appreciate a type system that's able to express SI units, 
which C++ and Haskell are powerful enough to do[1].  For example, if 
using the right library,
     let velocity = distance / time;
would be a compile error if the dimensions do not match up properly.  I 
added such a system to a C++ physics simulation and it caught some of 
our mistakes.

*scurries off to learn Rust properly*
-Isaac

[1] C++: Boost.Units; Haskell: 
http://www.haskell.org/haskellwiki/Physical_units

From oren at ben-kiki.org  Fri Nov 15 22:18:04 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 16 Nov 2013 08:18:04 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
	<0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
Message-ID: <CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>

I'm not certain whether it is better than anonymous members; one has to
list all the data members one by one, and there's "more" magic syntax. But
it is up to the "powers-that-be".


On Sat, Nov 16, 2013 at 5:48 AM, Tommi <rusty.gates at icloud.com> wrote:

> So... did anyone think that my idea (of doing multiple-inheritance by
> separating the responsibilities of providing functionality and providing
> data between the trait and the type which implements the trait) would
> warrant an enhancement request at github? Or how do these things tend to
> work around here? (I've done plenty of bug/enhancement reporting for D, but
> I know that language fairly well whereas I've just barely read the Rust
> tutorial/manual).
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/2b1ae9b8/attachment.html>

From rusty.gates at icloud.com  Fri Nov 15 22:39:33 2013
From: rusty.gates at icloud.com (Tommi)
Date: Sat, 16 Nov 2013 08:39:33 +0200
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
	<0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
	<CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>
Message-ID: <FCC11C53-0EF7-4E36-BB69-C52E22077BE4@icloud.com>

I was just thinking that some random post on a mailing list could easily get lost in time like tears in rain, but a github enhancement request is bound to get noticed at some point. Thus if the suggestion is not total nonsense, it warrants an enhancement request. I just don't want to be spamming the github issue list.

On 2013-11-16, at 8:18, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I'm not certain whether it is better than anonymous members; one has to list all the data members one by one, and there's "more" magic syntax. But it is up to the "powers-that-be".
> 
> 
> On Sat, Nov 16, 2013 at 5:48 AM, Tommi <rusty.gates at icloud.com> wrote:
> So... did anyone think that my idea (of doing multiple-inheritance by separating the responsibilities of providing functionality and providing data between the trait and the type which implements the trait) would warrant an enhancement request at github? Or how do these things tend to work around here? (I've done plenty of bug/enhancement reporting for D, but I know that language fairly well whereas I've just barely read the Rust tutorial/manual).

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/542f00f3/attachment.html>

From bjzaba at yahoo.com.au  Fri Nov 15 22:55:44 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 16 Nov 2013 17:55:44 +1100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <5286F3ED.1040607@isaac.cedarswampstudios.org>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
	<5286F3ED.1040607@isaac.cedarswampstudios.org>
Message-ID: <1AFE145B-94FC-45EE-A1E1-EDBACC59FC13@yahoo.com.au>

> Personally I'd appreciate a type system that's able to express SI units, which C++ and Haskell are powerful enough to do[1].

I agree. This is of huge importance when it comes to providing compile time safety guarantees. And if the language is powerful enough to express SI units, then it also demonstrates that it might be powerful enough to allow users to grow the language in other directions not anticipated by the language designers.

~Brendan

On 16 Nov 2013, at 3:26 pm, Isaac Dupree <ml at isaac.cedarswampstudios.org> wrote:

> On 11/15/2013 11:05 AM, G?bor Lehel wrote:
>> Like C++, types could be parameterized over constants. Again, the syntax
>> could mirror their declarations. For example, a function to construct a
>> fixed-length array:
>> 
>>     fn make_n<static N: int>(n: int) -> ~[int, ..N] { [n, ..N] }
>> 
>> Interesting questions here include what types to allow, how or whether
>> to handle literals of various types as type arguments, and the constant
>> expression sublanguage.
> 
> Personally I'd appreciate a type system that's able to express SI units, which C++ and Haskell are powerful enough to do[1].  For example, if using the right library,
>    let velocity = distance / time;
> would be a compile error if the dimensions do not match up properly.  I added such a system to a C++ physics simulation and it caught some of our mistakes.
> 
> *scurries off to learn Rust properly*
> -Isaac
> 
> [1] C++: Boost.Units; Haskell: http://www.haskell.org/haskellwiki/Physical_units
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From rusty.gates at icloud.com  Sat Nov 16 01:08:01 2013
From: rusty.gates at icloud.com (Tommi)
Date: Sat, 16 Nov 2013 11:08:01 +0200
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <F7406DFB-0460-4572-8244-C51114DE8C0F@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<20131114165743.GC6546@Mr-Bennet>
	<282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>
	<20131115185814.GC28551@Mr-Bennet>
	<F7406DFB-0460-4572-8244-C51114DE8C0F@icloud.com>
Message-ID: <58ADA2D6-449B-4560-829B-E6804CABFB9C@icloud.com>

On 2013-11-16, at 1:37, Tommi Tissari <rusty.gates at icloud.com> wrote:

> But shouldn't the signature be:
> fn cmp<T>(x: &[T], y: &[T]) -> bool

Oh, wait I think I know what the answer to that question is going to be. The comparison trait requires the signature to be (&self, &Self) and since the pointer sigils seems to be part of the type in this language, the type Self is ~[T] and the signature has to be (&~[T], &~[T]).

From illissius at gmail.com  Sat Nov 16 03:30:12 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 16 Nov 2013 12:30:12 +0100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <5286B73E.20509@gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
	<5286B73E.20509@gmail.com>
Message-ID: <CAPNUp0_2bqcHRUkQvKf_tWFdkaNPhm-CepQpwcTvo12Fa-Y7-g@mail.gmail.com>

On Sat, Nov 16, 2013 at 1:07 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 16/11/13 03:05, G?bor Lehel wrote:
>
>> It would be nice if `Trait1 + Trait2` were itself a trait, legal in the
>> same positions as any trait. This is already partly true: in trait bounds
>> on type parameters and super-traits of traits. Where it's not true is trait
>> objects, e.g. `~(ToStr + Send)`. Having this could remove the need for the
>> current `~Trait:OtherTraits` special syntax.
>>
>> I wonder whether lifetimes could also be interpreted as traits, with the
>> meaning: "[object of type implementing lifetime-trait] does not outlive
>> [the given lifetime]". This is an honest wondering: I'm not sure if it
>> makes sense. If it does make sense, it would fit in perfectly with the fact
>> that 'static is already a trait. Together with the above, it might also
>> allow a solution for capturing borrowed data in a trait object: you could
>> write `~(Trait + 'a)`.
>>
>>
> How does this interact with vtables?
>

Good question. Here's how I think it might work: `+` would be effectively,
or actually, a type constructor. (Might be easier to think about if you
imagine desugaring to syntax like `Both<A, B>` instead of `A + B`). As
elsewhere, a type would be uniquely determined by the combination of its
type constructor and its type arguments, so `Foo + Bar` in two separate
places in the program would be the same type, with the same vtable.

Another question is whether `Bar + Foo` would also be the same type.
Looking at what GHC does, it seems `(Show Int, Read Int) ~ (Read Int, Show
Int)` does *not* hold, so they are different types, but when it comes to
constraint-solving time, if you know one you can deduce the other, so
unless you are specifically testing for type equality of constraints then
they're equivalent in practice, which seems reasonable.


>
> Note we can already get something similar with
>
>    trait Combine1And2: Trait1 + Trait2 {}
>    impl<T: Trait1 + Trait2> Combine1And2 for T {}
>
>    // use ~Combine1And2
>
> which makes it clear how the vtables work, since Combine1And2 has its own
> vtable explicitly constructed from the two traits.


Yeah I know. It feels a bit like using defunctionalization by hand to
simulate HOFs though. Much nicer if things are first class and there are
simple rules, like: "if T1 and T2 are traits, then T1 + T2 is a trait".
Might even simplify some things in the implementation, e.g. traits would
now only have *one* supertrait, there would now only be *one* trait bound
on each type variable, though I'm not too familiar with it.


> (I guess ~(Trait1 + Trait2) would be most useful if one could cast down to
> ~Trait1 and ~Trait2.)
>
>
>
>>
>>
>> The next few are going to be about higher- (or just different-) kinded
>> generics. To avoid confusion, I'm going to use "built-in trait" to mean
>> things like `Freeze` and `Send`, and "kind" to mean what it does everywhere
>> else in the non-Rustic world.
>>
>> I think the best available syntax for annotating the kinds of types would
>> be to borrow the same or similar syntax as used to declare them, with
>> either `type` or `struct` being the kind of "normal" non-generic types (the
>> only kind of type that current Rust lets you abstract over). [I prefer
>> `type`, because both structs and enums inhabit the same kind.] This is kind
>> of like how C++ does it. For example, the kind of `Result` would be
>> `type<type, type>`. Our `type` corresponds to C++'s `typename` and
>> Haskell's `*`, and `type<type, type>` to C++'s `template<typename,
>> typename> class` and Haskell's `* -> * -> *`. So, for example, you could
>> write the fully kind-annotated signature of an identity function restricted
>> to Result-shaped types (yeah, actually doing this would be pointless!) as:
>>
>>     fn dumb_id<type<type, type> R, type A, type B>(x: R<A, B>) -> R<A, B>;
>>
>> To explicitly annotate the kind of the Self-type of a trait, we could
>> borrow the `for` syntax used in `impl`s. Here's the fully kind-annotated
>> version of the `Functor` trait familiar from Haskell:
>>
>>     trait Functor for type<type> Self {
>>         fn fmap<type A, type B>(a: &Self<A>, f: |&A| -> B) -> Self<B>;
>>     }
>>
>> (Obviously, explicitly annotating every kind would be tiresome, and
>> `Self` is a little redundant when nothing else could go there. I could
>> imagine `trait Functor for type<type>`, `trait Functor for Self`, and/or
>> `trait Functor` all being legal formulations of the above. I'll get back to
>> this later.)
>>
>>
>>
> Could this be:
>
>    fn dumb_id<R<type, type>, A, B>(x: R<A, B>) -> R<A, B>;
>

That seems reasonable. Writing it out even more fully, I expect this would
actually be `type R<type, type>`, but the "return kind" could probably be
inferred/defaulted independently (and here I was going to say that at first
it could only ever be `type` anyways, but instead see below). The advantage
of writing it this way is that it tracks the declaration syntax even more
closely, and perhaps reads a little better. The drawback is that it's not
so obvious any more that you could leave off the kind-information to have
it be inferred, because it's no longer separate from the name of the type
variable; it's also farther away from the C++ way of writing it (though
that's probably not a huge loss). I'm also not sure if it still reads
better after you add a trait bound, e.g. `fn foo<F<type>: Functor>(...)`
versus `fn foo<type<type> F: Functor>(...)`.

What I was wondering in the parentheses above is whether you could have
something `type<type> MT<type<type>>`. In other words whether "templates
can return templates", which you can't do in C++ but can in Haskell. This
is closely tied to the question about currying and partial application at
the type level. If we do have that, then the above is completely equivalent
to `type MT<type<type>, type>` (just like `(* -> *) -> * -> *` and `(* ->
*) -> (* -> *)` are the same thing in Haskell), though it might be nicer to
write it one way or the other in different cases. If we don't have
automatic currying, then this might be a way to do it manually.



>
> and


>    trait Functor<type> {
>        fn fmap<A, B>(a: &Self<A>, f: |&A| -> B) -> Self<B>;
>    }
>

Not quite. This would be equivalent to `class Functor a self` (a MPTC)
rather than `class Functor (f :: * -> *)`, which is what we want.
Distinguishing the parameters of `Self` from the parameters of the trait is
why I borrowed the `impl ... for ...` syntax from impls, which I think is
nice and symmetric.



>
> Then something like  A<type<type>, type> would correspond to A :: (* -> *)
> -> * -> *. Speaking of which, could we just use *, `R<*, *>`, `R<*<*>, *>`,
> `trait Functor<*>`? Although that looks a little cryptic in the nested case.
>

I don't like `*` as the name for this in Haskell either. Various
dependently typed languages call it `Set`, which is closer, but if I were
lord I would name it `Type`. So `type` is pretty much perfect here, IMHO.


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/d3b9b16c/attachment.html>

From denis.spir at gmail.com  Sat Nov 16 08:59:05 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 16 Nov 2013 17:59:05 +0100
Subject: [rust-dev] freeing of locals
Message-ID: <5287A459.3090003@gmail.com>

Hello,

say a function defines 4 pointed elements of data. Depending on logical 
conditions, one of them escapes the func to be assigned to some world variable 
(static or on heap), while another is returned. How does Rust determine which of 
those data are to be freed? Seems this can only be done dynamically, at runtime, 
or do I miss a relevant point? Is there a cheap algo to do this?
(Also, those elements of data can be arbitrarily complex, and hold other pointed 
data which themselves may be placed there conditionally.)

Thank you,
denis


From pnathan at vandals.uidaho.edu  Sat Nov 16 09:08:18 2013
From: pnathan at vandals.uidaho.edu (Paul Nathan)
Date: Sat, 16 Nov 2013 09:08:18 -0800
Subject: [rust-dev] freeing of locals
In-Reply-To: <5287A459.3090003@gmail.com>
References: <5287A459.3090003@gmail.com>
Message-ID: <5287A682.1080909@vandals.uidaho.edu>

On 11/16/13 8:59 AM, spir wrote:
> Hello,
> 
> say a function defines 4 pointed elements of data. Depending on logical
> conditions, one of them escapes the func to be assigned to some world
> variable (static or on heap), while another is returned. How does Rust
> determine which of those data are to be freed? Seems this can only be
> done dynamically, at runtime, or do I miss a relevant point? Is there a
> cheap algo to do this?
> (Also, those elements of data can be arbitrarily complex, and hold other
> pointed data which themselves may be placed there conditionally.)
> 
> Thank you,
> denis
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> .
> 

Denis,

Can you provide a code example? I'm not sure I entirely follow your
meaning.

-- 
Regards,
Paul

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 946 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/811c38b9/attachment-0001.sig>

From qwertie256 at gmail.com  Sat Nov 16 10:00:30 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Sat, 16 Nov 2013 11:00:30 -0700
Subject: [rust-dev] Type system thoughts
Message-ID: <CAHuo6ZCcSjjOVcidfg8+dthSUFy+2tX5z15jDP-83OstayiY3g@mail.gmail.com>

>> Personally I'd appreciate a type system that's able to express SI units,
which C++ and Haskell are powerful enough to do[1].
>
>I agree. This is of huge importance when it comes to providing compile
time safety guarantees. And if the language is powerful enough to express
SI units, then it also demonstrates that it might be powerful enough to
allow users to grow the language in other directions not anticipated by the
language designers.

While I'm no type system expert, I implemented a unit inference system for
boo (though boo's developers weren't interested and did not use it). So I
thought I'd just share some thoughts about how I view types and unit
checking (as someone whose university education included absolutely no type
theory).

I've started to view types as three partly or wholly independent elements:

1. Physical structure. Under this view, two structs with members "x: int,
y: int" can be considered the same structure, and while direct assignment
between them may not be allowed, the compiler can safely treat them as the
same type IF the language allows it to.
2. Name and attributes. This encompasses things like names and modules
where structures live (e.g. a "Point" structure defined in two different
namespaces), const/non-const in C++, mutable-immutable in D, and units
(km/L, bytes/sec). Unlike a typing error in (1), a typing error or cast
that changes these attributes does not compromise the memory safety of the
language.
3. Operations. Often a type has multiple interfaces, e.g. in Java, an
object can be accessed through several different interfaces without
changing its type. I've been designing a language where this is extended to
allow arbitrary user-defined "views" on a type (a concept which might be
very useful in my Loyc project, whose goal is to allow cross-language
programming; often there are some types in two different languages that are
very similar and just need someone to define a mapping between them.)

I wonder if anyone has formalized a view like this before.

Anyway, viewing (2) as a plurality of attributes, independent from (1),
might allow one to develop a type system where user-defined "attribute"
typing is straightforwardly possible. A simple version of this would be to
allow users to install a plug-in shared library that the compiler uses for
additional analysis following standard typing. Then unit inference could be
installed as one such library. These libraries would not necessarily be
allowed to change the behavior of the program; it would be useful enough
just to allow them to perform analysis, but it would be more useful if they
could alter behavior too (e.g. the unit-checking module could automatically
coerce "km" to "mi" or "m" or "yd", adding a scaling factor; or in a
language with overloading, functions could be overloaded based on unit
types.)

Note that typing failure in (2) need not prevent the code from being
compiled (in general I like a language that doesn't force me to fix every
little problem before running the code.)

A general facility for annotating code is necessary to allow extra typing
without changing the language grammar (e.g. in my languages LES and EC# my
expression grammar allows attributes in [SquareBracks] at the beginning of
any expression or subexpression in parentheses, plus I support some
user-defined operators.)

One thing I want to say about unit checking, it's much more useful to
provide unit inference rather than unit checking, because users don't want
to write annotations all over the place. A function like

fn abs(x: int) -> int { if x < 0 { -x } else { x } }

should need no annotation for the unit inferer to understand that 'x' has
polymorphic units, and in

fn length(&self) { sqrt(self.x * self.x, self.y * self.y) }

'x' and 'y' can be constrained automatically to have the same units. (there
are a bunch of subtle details of course, but since I wrote the inference
engine about 7 years ago, I forgot many of them...)

-- 
- David
http://loyc-etc.blogspot.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/d5e92386/attachment.html>

From ben at 0x539.de  Sat Nov 16 10:03:22 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Sat, 16 Nov 2013 19:03:22 +0100
Subject: [rust-dev] freeing of locals
In-Reply-To: <5287A459.3090003@gmail.com>
References: <5287A459.3090003@gmail.com>
Message-ID: <1384625002.3069.10.camel@vigil>

Hi,

as I understand it, currently, rust zeros variables after cleanup or
when moved from (and adds a "drop flag" field to structs with cleanup
logic to be zeroed), and so dynamically, at runtime, tracks which
variables need to be freed/have destructors called.

This might change somewhat: https://github.com/mozilla/rust/issues/5016

-benh

On Sat, 2013-11-16 at 17:59 +0100, spir wrote:
> Hello,
> 
> say a function defines 4 pointed elements of data. Depending on logical 
> conditions, one of them escapes the func to be assigned to some world variable 
> (static or on heap), while another is returned. How does Rust determine which of 
> those data are to be freed? Seems this can only be done dynamically, at runtime, 
> or do I miss a relevant point? Is there a cheap algo to do this?
> (Also, those elements of data can be arbitrarily complex, and hold other pointed 
> data which themselves may be placed there conditionally.)
> 
> Thank you,
> denis
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



From someone at mearie.org  Sat Nov 16 10:11:43 2013
From: someone at mearie.org (Kang Seonghoon)
Date: Sun, 17 Nov 2013 03:11:43 +0900
Subject: [rust-dev] freeing of locals
In-Reply-To: <5287A459.3090003@gmail.com>
References: <5287A459.3090003@gmail.com>
Message-ID: <CAL04ga=V4c6nnyTGwXwWas1d-7pQCRQTMXH4EqrLVjgVkuzwYQ@mail.gmail.com>

I'm not sure I understand your question, but if I guessed correctly:
Are you want to write something like this?

~~~~
fn conditionally_return(cond: bool, p: ~str, q: ~[u8]) -> Either<~str,~[u8]> {
    if cond { Left(p) } else { Right(q) }
}
~~~~

If you have four cases, then you must make an enum with four variants
(a bit cumbersome). As you expected, the compiler *cannot* infer that
some of arguments will have to be freed according to the internal
state, but you can manually list the possible cases to let the
compiler aware of them.

2013/11/17 spir <denis.spir at gmail.com>:
> Hello,
>
> say a function defines 4 pointed elements of data. Depending on logical
> conditions, one of them escapes the func to be assigned to some world
> variable (static or on heap), while another is returned. How does Rust
> determine which of those data are to be freed? Seems this can only be done
> dynamically, at runtime, or do I miss a relevant point? Is there a cheap
> algo to do this?
> (Also, those elements of data can be arbitrarily complex, and hold other
> pointed data which themselves may be placed there conditionally.)
>
> Thank you,
> denis
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
-- Kang Seonghoon | Software Engineer, iPlateia Inc. | http://mearie.org/
-- Opinions expressed in this email do not necessarily represent the
views of my employer.
--

From niko at alum.mit.edu  Sat Nov 16 10:29:40 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 16 Nov 2013 13:29:40 -0500
Subject: [rust-dev] Built-in types should accept a pointer rhs-argument
 to binary operators
In-Reply-To: <58ADA2D6-449B-4560-829B-E6804CABFB9C@icloud.com>
References: <D3421044-D62C-4DD2-AEE8-F6EDDA5C2288@icloud.com>
	<20131114165743.GC6546@Mr-Bennet>
	<282AF5F5-3352-4F88-BCF9-FBF26DBA3B01@icloud.com>
	<20131115185814.GC28551@Mr-Bennet>
	<F7406DFB-0460-4572-8244-C51114DE8C0F@icloud.com>
	<58ADA2D6-449B-4560-829B-E6804CABFB9C@icloud.com>
Message-ID: <20131116182940.GC11552@Mr-Bennet>

On Sat, Nov 16, 2013 at 11:08:01AM +0200, Tommi wrote:
> On 2013-11-16, at 1:37, Tommi Tissari <rusty.gates at icloud.com> wrote:
> 
> > But shouldn't the signature be:
> > fn cmp<T>(x: &[T], y: &[T]) -> bool
> 
> Oh, wait I think I know what the answer to that question is going to be. The comparison trait requires the signature to be (&self, &Self) and since the pointer sigils seems to be part of the type in this language, the type Self is ~[T] and the signature has to be (&~[T], &~[T]).

Yes, that is the point. The type *being compared* is `~[T]`, and the
comparison trait is generic and just prepends a `&` to whatever type
is being compared.


Niko

From illissius at gmail.com  Sat Nov 16 11:22:17 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 16 Nov 2013 20:22:17 +0100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <CAPNUp0_2bqcHRUkQvKf_tWFdkaNPhm-CepQpwcTvo12Fa-Y7-g@mail.gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
	<5286B73E.20509@gmail.com>
	<CAPNUp0_2bqcHRUkQvKf_tWFdkaNPhm-CepQpwcTvo12Fa-Y7-g@mail.gmail.com>
Message-ID: <CAPNUp096cN=W7OcpFUH44Fe52cDnS7Yf8Ygc9A47oZUN-SrZpw@mail.gmail.com>

On Sat, Nov 16, 2013 at 12:30 PM, G?bor Lehel <illissius at gmail.com> wrote:

> What I was wondering in the parentheses above is whether you could have
> something `type<type> MT<type<type>>`. In other words whether "templates
> can return templates", which you can't do in C++ but can in Haskell. This
> is closely tied to the question about currying and partial application at
> the type level. If we do have that, then the above is completely equivalent
> to `type MT<type<type>, type>` (just like `(* -> *) -> * -> *` and `(* ->
> *) -> (* -> *)` are the same thing in Haskell), though it might be nicer to
> write it one way or the other in different cases.
>

I just noticed that if this is true, then it actually unifies your proposal
for syntax with my earlier one. What happens is that `type F<type>` is a
type-level unary function, and `type<type> F` is a nullary function
returning a unary function, and we can consider these to be equivalent.
This is like how, thanks to the absence of side effects and such, Haskell
gets to elide the difference between nullary functions and plain values.
Rust's type level shares these kind of properties with Haskell's value
level, so this is kinda appealing. On the other hand, maybe the added
flexibility doesn't actually gain us anything except a taller learning
curve. But in either case, it's really cool to realize that our two
proposals are not just ad hoc stylistic choices, but in fact both have
sensible theoretical interpretations in the same system with a
correspondence between them.

To recap the options:

 1. Everything must be on the left:

    type<type<type>, type> MT

 2. All parameters must be on the right, and only the final return kind on
the left:

    type MT<type<type>, type>

 3. Both are legal and equivalent, along with forms in between the two
extremes:

    type<type> MT<type<type>>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/dea6d7bf/attachment-0001.html>

From hatahet at gmail.com  Sat Nov 16 12:05:50 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 16 Nov 2013 12:05:50 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <FCC11C53-0EF7-4E36-BB69-C52E22077BE4@icloud.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<E41B1D1E-3A9C-429F-9B84-AF0F7DCBCDDD@sb.org>
	<52830794.3070504@mozilla.com>
	<129CF8DC-08FB-43B8-8A8B-985C254A5AEA@sb.org>
	<9859FE7A-3F11-4317-9491-6EEB4F4157AF@sb.org>
	<CANbMr6GjQzCr6ZN6aCmuT=4+K0T6T0WO00Hp-tynaemE+Us2Rw@mail.gmail.com>
	<CADJiDhsQR1nLJftTOHUzYWz=kf9yYSG=T=9KPHOMs=UG5roRnA@mail.gmail.com>
	<CANbMr6GQg+Rjo9kpeVMqPjvaNqm2Xk+MYh9u3jA5CVQAFxG6YA@mail.gmail.com>
	<CADJiDhstzRRt=KQecqH-ttkPVKqxG-iJUi2ZcmgTQ8_WRw8MnA@mail.gmail.com>
	<CANbMr6HXfcdG-Wjpqh_CPjAEPkNqub=XFbVZDHvjzkNiOpb-RA@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
	<0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
	<CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>
	<FCC11C53-0EF7-4E36-BB69-C52E22077BE4@icloud.com>
Message-ID: <CAN1rdExuuf21S-8tLfMVj7PaxP4wRoZp-W9=dfJjmvFYO+_PEQ@mail.gmail.com>

If structural inheritance were to be implemented, would we have the slicing
problem in Rust, as it happens in C++?

[1] http://en.wikipedia.org/wiki/Object_slicing
[2]
http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c/


--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/e0a84cbc/attachment.html>

From pwalton at mozilla.com  Sat Nov 16 12:15:50 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 16 Nov 2013 12:15:50 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <CAN1rdExuuf21S-8tLfMVj7PaxP4wRoZp-W9=dfJjmvFYO+_PEQ@mail.gmail.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
	<0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
	<CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>
	<FCC11C53-0EF7-4E36-BB69-C52E22077BE4@icloud.com>
	<CAN1rdExuuf21S-8tLfMVj7PaxP4wRoZp-W9=dfJjmvFYO+_PEQ@mail.gmail.com>
Message-ID: <5dd78749-4d08-4bb6-84eb-a4687be39934@email.android.com>

Nope. It's carefully designed so that pointer types only form the subtyping relationship, eliminating this problem.

BTW, I was thinking maybe we should just rename this feature to "structural constraints" to avoid the "ewww, OO" reactions.

Ziad Hatahet <hatahet at gmail.com> wrote:
>If structural inheritance were to be implemented, would we have the
>slicing
>problem in Rust, as it happens in C++?
>
>[1] http://en.wikipedia.org/wiki/Object_slicing
>[2]
>http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c/
>
>
>--
>Ziad

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/5e99fa0e/attachment.html>

From danielmicay at gmail.com  Sat Nov 16 14:53:34 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 16 Nov 2013 17:53:34 -0500
Subject: [rust-dev] freeing of locals
In-Reply-To: <5287A459.3090003@gmail.com>
References: <5287A459.3090003@gmail.com>
Message-ID: <CA+DvKQLMbLCoHY5gqu8DTahxCgy-BxabS9N18fVqUCqU8PEhuw@mail.gmail.com>

On Sat, Nov 16, 2013 at 11:59 AM, spir <denis.spir at gmail.com> wrote:
> Hello,
>
> say a function defines 4 pointed elements of data. Depending on logical
> conditions, one of them escapes the func to be assigned to some world
> variable (static or on heap), while another is returned. How does Rust
> determine which of those data are to be freed? Seems this can only be done
> dynamically, at runtime, or do I miss a relevant point? Is there a cheap
> algo to do this?
> (Also, those elements of data can be arbitrarily complex, and hold other
> pointed data which themselves may be placed there conditionally.)
>
> Thank you,
> denis

The destructor is called when a variable goes out of scope. If the
variable is moved from, the destructor isn't called. Borrowed pointers
are just pointers at runtime without any dynamic checks, because the
lifetimes are verified as part of type checking. There's never
something like implicit extension of the lifetime of a variable beyond
a scope.

Shared ownership can be built on top of the ownership system like the
`std::rc::Rc` type does, where the destructor only decreases a
reference count rather than freeing an allocation. Moving around a
reference counted pointer does *not* cause reference counts though.

From hatahet at gmail.com  Sat Nov 16 15:56:33 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 16 Nov 2013 15:56:33 -0800
Subject: [rust-dev] "Implementation Inheritance" / mixins
In-Reply-To: <5dd78749-4d08-4bb6-84eb-a4687be39934@email.android.com>
References: <CADJiDhvU7D7vtCT7iR1kDhRxKUCM4q58pnoq+o_Gfi4zJidAMQ@mail.gmail.com>
	<CADJiDht4BSxt9LB=kMZhniq2XPKHn8G_sLE+A=+zcfqr-dwTqw@mail.gmail.com>
	<CANbMr6FHtMVFKT5p1v2UqAEP-1NtQhZdp54KN68++WFOvfm_yA@mail.gmail.com>
	<CADJiDhvVX2KiFfMw2X2SNN6Qo5ZYCCtXxDv103mFY2cQ=ER+2Q@mail.gmail.com>
	<7ACEFB11-2DF2-4483-A76A-C7C92936509D@icloud.com>
	<966ED865-5D35-4FD7-A0E7-78CC546004D4@icloud.com>
	<CADJiDht7rHQveYdxxnzXpZ366W5m5CifgXEzm3HxK7nPqvE_gQ@mail.gmail.com>
	<5285EDA1.6060801@gmail.com>
	<CADJiDhvPEr2Lso6kTrz3LbTyYnUU8MEoEwM5rq6sBM7nEOMhTA@mail.gmail.com>
	<CA+DvKQKRyZymJAcJ1xxnV4cN7Gok5CDaZTbzwNdX-0qwUqCCZw@mail.gmail.com>
	<CADJiDht0-8Mii+SeuH9AwfVMPizvXOYnJExX8hozhYNbpNr_Uw@mail.gmail.com>
	<0B4CB9CE-22CD-44A3-A011-A120994E3A2F@icloud.com>
	<CADJiDhvWHPQPwdBkOCfEEJwZhXxcP_mCgV6AJukYnOf80=ufVg@mail.gmail.com>
	<FCC11C53-0EF7-4E36-BB69-C52E22077BE4@icloud.com>
	<CAN1rdExuuf21S-8tLfMVj7PaxP4wRoZp-W9=dfJjmvFYO+_PEQ@mail.gmail.com>
	<5dd78749-4d08-4bb6-84eb-a4687be39934@email.android.com>
Message-ID: <CAN1rdEybT9sddzNqXrq=NzgiStsKSujo5ck23oLhrN6iATsd+Q@mail.gmail.com>

Very cool. I agree that naming will have an effect on psychology. A similar
case is the type of reactions the word "template" may evoke, when it
reminds people of the way C++ does them.

--
Ziad


On Sat, Nov 16, 2013 at 12:15 PM, Patrick Walton <pwalton at mozilla.com>wrote:

> Nope. It's carefully designed so that pointer types only form the
> subtyping relationship, eliminating this problem.
>
> BTW, I was thinking maybe we should just rename this feature to
> "structural constraints" to avoid the "ewww, OO" reactions.
>
>
> Ziad Hatahet <hatahet at gmail.com> wrote:
>>
>> If structural inheritance were to be implemented, would we have the
>> slicing problem in Rust, as it happens in C++?
>>
>> [1] http://en.wikipedia.org/wiki/Object_slicing
>> [2]
>> http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c/
>>
>>
>> --
>> Ziad
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131116/13d65666/attachment.html>

From niko at alum.mit.edu  Sat Nov 16 17:08:15 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Sat, 16 Nov 2013 20:08:15 -0500
Subject: [rust-dev] Type system thoughts
In-Reply-To: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
Message-ID: <20131117010815.GF11552@Mr-Bennet>

On Fri, Nov 15, 2013 at 05:05:28PM +0100, G?bor Lehel wrote:
> I have some ideas about typey things and I'm going to write them down. It
> will be long.

I haven't read this all yet, I just want to respond to the first few
paragraphs. :)

> It would be nice if `Trait1 + Trait2` were itself a trait, legal in the
> same positions as any trait. This is already partly true: in trait bounds
> on type parameters and super-traits of traits. Where it's not true is trait
> objects, e.g. `~(ToStr + Send)`. Having this could remove the need for the
> current `~Trait:OtherTraits` special syntax.

It's plausible to imagine, though I wouldn't phrase it that "Trait1+Trait2"
is a trait, but rather a form of generalized object types. Today object
types have the form `~Trait` and these generalized object types would
have the form `~(Trait1+...+TraitN)`. Probably their size would be
N+1 words to account for the extra vtables, which would make it trival
to support the (natual) subtyping relation of the form

    ~(Trait1+Trait2) <: ~Trait1
    ~(Trait1+Trait2) <: ~Trait2

You can sort of do something similar today with

    trait Trait3 : Trait1 + Trait 2 { }
    impl<T:Trait1+Trait2> Trait3 for T { }

Note that the current syntax `~Trait:Bounds` is intentionally limited
in that the traits that can appear in `Bounds` do not offer methods
but rather give information about the kind of data that the object
receiver consists of.

> I wonder whether lifetimes could also be interpreted as traits, with the
> meaning: "[object of type implementing lifetime-trait] does not outlive
> [the given lifetime]". This is an honest wondering: I'm not sure if it
> makes sense. If it does make sense, it would fit in perfectly with the fact
> that 'static is already a trait. Together with the above, it might also
> allow a solution for capturing borrowed data in a trait object: you could
> write `~(Trait + 'a)`.

I don't think of `'static` as a trait, though it is currently
implemented that way for historical reasons that will hopefully soon
be eased. Rather, type parameters can have a *lifetime bound*, which
indicates the minimum lifetime that they can exist for. `'static` is
just a special case of this.  This might be (for all intents and
purposes) what you meant. In particular, one should be able to do
`~Trait:'a`, which is interpreted as:

    a pointer to some type T which implements the trait `Trait`
    and which contains data valid for at least the lifetime 'a


Niko

From dwrenshaw at gmail.com  Sun Nov 17 11:30:48 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Sun, 17 Nov 2013 14:30:48 -0500
Subject: [rust-dev] capnproto-rust: performance and safety compared to C++
Message-ID: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>

Hi everyone.

I wrote up some of my latest experiences implementing Cap'n Proto encoding
for Rust.

A performance comparison to C++, or "capnproto-rust is pretty fast":
http://dwrensha.github.io/capnproto-rust/2013/11/16/benchmark.html

A discussion of safety, or "why I'm so keen to see support for static trait
methods with lifetime parameters":
http://dwrensha.github.io/capnproto-rust/2013/11/17/lifetimes.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131117/9ac590a8/attachment-0001.html>

From dbau.pp at gmail.com  Sun Nov 17 13:49:03 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Mon, 18 Nov 2013 08:49:03 +1100
Subject: [rust-dev] capnproto-rust: performance and safety compared to
 C++
In-Reply-To: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
References: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
Message-ID: <528939CF.5070007@gmail.com>

On 18/11/13 06:30, David Renshaw wrote:
> Hi everyone.
>
> I wrote up some of my latest experiences implementing Cap'n Proto 
> encoding for Rust.
>
> A performance comparison to C++, or "capnproto-rust is pretty fast":
> http://dwrensha.github.io/capnproto-rust/2013/11/16/benchmark.html
>
> A discussion of safety, or "why I'm so keen to see support for static 
> trait methods with lifetime parameters":
> http://dwrensha.github.io/capnproto-rust/2013/11/17/lifetimes.html
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

This is cool!

I see that you mention slowness in IO and some extra string copies; are 
there any other low-hanging fruit that you know of? Or is it all down to 
micro-optimisation now?


Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/34d876af/attachment.html>

From pcwalton at mozilla.com  Sun Nov 17 13:56:39 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sun, 17 Nov 2013 13:56:39 -0800
Subject: [rust-dev] capnproto-rust: performance and safety compared to
 C++
In-Reply-To: <528939CF.5070007@gmail.com>
References: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
	<528939CF.5070007@gmail.com>
Message-ID: <52893B97.2010405@mozilla.com>

On 11/17/13 1:49 PM, Huon Wilson wrote:
> I see that you mention slowness in IO and some extra string copies; are
> there any other low-hanging fruit that you know of? Or is it all down to
> micro-optimisation now?

It would be interesting to profile the I/O and see what's causing the 
slowness.

Patrick


From dwrenshaw at gmail.com  Sun Nov 17 14:25:23 2013
From: dwrenshaw at gmail.com (David Renshaw)
Date: Sun, 17 Nov 2013 17:25:23 -0500
Subject: [rust-dev] capnproto-rust: performance and safety compared to
	C++
In-Reply-To: <528939CF.5070007@gmail.com>
References: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
	<528939CF.5070007@gmail.com>
Message-ID: <CABR6rW9HxDdkzSgHFEWa-rhdmmcAs_rPtmNmoW_LTQKCtiZ9Pw@mail.gmail.com>

The asReader() methods are also doing more work than necessary. To address
that, I think I'll first need to get the lifetime parameter situation
sorted out.


On Sun, Nov 17, 2013 at 4:49 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  On 18/11/13 06:30, David Renshaw wrote:
>
>  Hi everyone.
>
>  I wrote up some of my latest experiences implementing Cap'n Proto
> encoding for Rust.
>
> A performance comparison to C++, or "capnproto-rust is pretty fast":
> http://dwrensha.github.io/capnproto-rust/2013/11/16/benchmark.html
>
>  A discussion of safety, or "why I'm so keen to see support for static
> trait methods with lifetime parameters":
>  http://dwrensha.github.io/capnproto-rust/2013/11/17/lifetimes.html
>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
> This is cool!
>
> I see that you mention slowness in IO and some extra string copies; are
> there any other low-hanging fruit that you know of? Or is it all down to
> micro-optimisation now?
>
>
> Huon
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131117/decb3c66/attachment.html>

From pwalton at mozilla.com  Sun Nov 17 14:35:52 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sun, 17 Nov 2013 14:35:52 -0800
Subject: [rust-dev] capnproto-rust: performance and safety compared
	to	C++
In-Reply-To: <CABR6rW9HxDdkzSgHFEWa-rhdmmcAs_rPtmNmoW_LTQKCtiZ9Pw@mail.gmail.com>
References: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
	<528939CF.5070007@gmail.com>
	<CABR6rW9HxDdkzSgHFEWa-rhdmmcAs_rPtmNmoW_LTQKCtiZ9Pw@mail.gmail.com>
Message-ID: <a753abd3-ae92-4cb4-b5c9-88b915f6974c@email.android.com>

I wonder if you aren't buffering the writes or whether the buffer isn't functioning optimally. That would be consistent with a large performance degradation on complex structures, because there will be many small write syscalls. Running dtruss or strace to observe syscalls may be helpful.

Patrick

Patrick

David Renshaw <dwrenshaw at gmail.com> wrote:
>The asReader() methods are also doing more work than necessary. To
>address
>that, I think I'll first need to get the lifetime parameter situation
>sorted out.
>
>
>On Sun, Nov 17, 2013 at 4:49 PM, Huon Wilson <dbau.pp at gmail.com> wrote:
>
>>  On 18/11/13 06:30, David Renshaw wrote:
>>
>>  Hi everyone.
>>
>>  I wrote up some of my latest experiences implementing Cap'n Proto
>> encoding for Rust.
>>
>> A performance comparison to C++, or "capnproto-rust is pretty fast":
>> http://dwrensha.github.io/capnproto-rust/2013/11/16/benchmark.html
>>
>>  A discussion of safety, or "why I'm so keen to see support for
>static
>> trait methods with lifetime parameters":
>>  http://dwrensha.github.io/capnproto-rust/2013/11/17/lifetimes.html
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing
>listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>>
>>
>> This is cool!
>>
>> I see that you mention slowness in IO and some extra string copies;
>are
>> there any other low-hanging fruit that you know of? Or is it all down
>to
>> micro-optimisation now?
>>
>>
>> Huon
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131117/e292f4e8/attachment.html>

From niko at alum.mit.edu  Mon Nov 18 07:50:57 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 18 Nov 2013 10:50:57 -0500
Subject: [rust-dev] freeing of locals
In-Reply-To: <1384625002.3069.10.camel@vigil>
References: <5287A459.3090003@gmail.com>
 <1384625002.3069.10.camel@vigil>
Message-ID: <20131118155057.GH3622@Mr-Bennet>

I am planning to submit a PR changing this so that we have no need of
zeroing memory out. This does mean that some programs which today are
legal will become illegal, because the compiler must know
unambiguously at each point what is to be freed: in other words, if
one path of an if/else consumes a variable, the other path must too
(at least if those paths rejoin). This patch isn't really underway yet
(though I've been working on some of the necessary prerequisites) and
I plan to writeup a more formal description once I get started hacking
on it. If nothing else, I hope to modify the moves analysis soon to
impose the necessary requirements so that code will be backwards
compatible, even if we continue to use zeroing at runtime for a while.


Niko

On Sat, Nov 16, 2013 at 07:03:22PM +0100, Benjamin Herr wrote:
> Hi,
> 
> as I understand it, currently, rust zeros variables after cleanup or
> when moved from (and adds a "drop flag" field to structs with cleanup
> logic to be zeroed), and so dynamically, at runtime, tracks which
> variables need to be freed/have destructors called.
> 
> This might change somewhat: https://github.com/mozilla/rust/issues/5016
> 
> -benh
> 
> On Sat, 2013-11-16 at 17:59 +0100, spir wrote:
> > Hello,
> > 
> > say a function defines 4 pointed elements of data. Depending on logical 
> > conditions, one of them escapes the func to be assigned to some world variable 
> > (static or on heap), while another is returned. How does Rust determine which of 
> > those data are to be freed? Seems this can only be done dynamically, at runtime, 
> > or do I miss a relevant point? Is there a cheap algo to do this?
> > (Also, those elements of data can be arbitrarily complex, and hold other pointed 
> > data which themselves may be placed there conditionally.)
> > 
> > Thank you,
> > denis
> > 
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> 
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From banderson at mozilla.com  Mon Nov 18 12:05:54 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 12:05:54 -0800
Subject: [rust-dev] Rust docs
In-Reply-To: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
Message-ID: <528A7322.3010602@mozilla.com>

On 11/14/2013 01:08 PM, Daniel Glazman wrote:
> Honestly, I am not sure "tutorial quality" and "automatic generation" live
> well together. We hire tech evangelists for their ability to present well
> information and make messages percolate better, and similarly good doc
> requires good tech writers who only do that.
>
> As I said earlier, a tutorial is crucial material to attract people and I
> think writing talent, excellent presentation and correct readability are
> need for such a tutorial. When I say "attract people" or "community", I am
> of course thinking of reaching critical masses for Rust-based projects,
> including Servo, and that requires making sure documentation material are
> good enough to self-generate a pool of potential hires.
>

I tend to agree with this, think that a collaborative approach is 
unlikely to produce a consistent and high quality tutorial. I don't want 
to discourage anybody but my current opinion is that we should hire an 
experienced technical writer to do this piece especially, with input 
from the wider community. Where I think collaboration is more likely to 
produce something nice is in a 'cookbook' style document, of which 
several people have already worked on seperately. Also of course API 
docs and the reference manual are places where individuals can plug in 
their own sections without impacting the overall narrative flow.

From banderson at mozilla.com  Mon Nov 18 12:10:02 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 12:10:02 -0800
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <CANK7tAEUny9=Q7fxO2hEF9oj141Qjd=wUAW=Qs1Wed5L1DykWg@mail.gmail.com>
References: <5286179E.4070000@gmail.com>	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEUny9=Q7fxO2hEF9oj141Qjd=wUAW=Qs1Wed5L1DykWg@mail.gmail.com>
Message-ID: <528A741A.2080906@mozilla.com>

On 11/15/2013 06:24 AM, Gaetan wrote:
> I would love a documentation "Rust for Pythonist" or "Rust for C++'iste".
>
> I don't like the Wiki page. I think the official documentation 
> homepage should be a nice, beautiful http://doc.rust-lang.org/ 
> <http://static.rust-lang.org/>. Period.
> It should link all "official" documentation in a logical way.
> Maybe it should provide a link to the wiki page with only "incubating" 
> documentation.
>
> I think it should be derived from rst/markdown files in conf, closely 
> linked to the current version of rust lang. Maybe divided in several 
> modules (the summary for rust 0.8 derives from files in the rust 0.8 
> branch, for master files are on master, branch...).

I would take a patch that does this.

>
> -----
> Gaetan
>
>
>
> 2013/11/15 Daniel Micay <danielmicay at gmail.com 
> <mailto:danielmicay at gmail.com>>
>
>     On Fri, Nov 15, 2013 at 7:46 AM, spir <denis.spir at gmail.com
>     <mailto:denis.spir at gmail.com>> wrote:
>     > I'm exploring the tutorial "Rust for Rubyists" at
>     > [http://www.rustforrubyists.com/book/book.html], which in fact
>     is not (only)
>     > for rubyists, as stated in the introduction. Looks pretty good
>     to me (just
>     > my opinion), should definitely be pointed to from the Rust Docs
>     page at
>     > [https://github.com/mozilla/rust/wiki/Docs], and in good place. As a
>     > tutorial, it is in my view far better than the "official" one,
>     and is
>     > up-to-date (Rust 0.8), so maybe even just replace it; with a
>     warning note.
>     >
>     > The "official" tutorial is not a bad doc in itself (I guess) but is
>     > definitely not a _tutorial_: in fact, it requires quite a
>     knowledge of Rust,
>     > its fundamental concepts and jargon. "Rust for Rubyists"
>     certainly has room
>     > for improvement, but it _is_ for sure a tutorial. I would
>     definitely suggest
>     > to start writing a new official tutorial by using "Rust for
>     Rubyists" as raw
>     > material. A first pass may be to make it slightly more general, just
>     > requiring prior programming experience; Rust definitely is not a
>     language
>     > for programming novices, anyway.
>     >
>     > Denis
>
>     The tutorial is currently quite flawed and has ended up being a list
>     of language features with overviews and low quality examples. Parts of
>     it are approaching the right level of information, but it's not
>     written in the style expected of a tutorial.
>
>     I think it's very important to cover the core language features like
>     boxes and references at a high level. The unique and least
>     approachable features need great introductory coverage. I recently
>     replaced the old sections on owned boxes, vectors and strings, so any
>     concrete feedback on those would be helpful.
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/8333298f/attachment.html>

From gaetan at xeberon.net  Mon Nov 18 13:23:31 2013
From: gaetan at xeberon.net (Gaetan)
Date: Mon, 18 Nov 2013 22:23:31 +0100
Subject: [rust-dev] tutorial (bis)
In-Reply-To: <528A741A.2080906@mozilla.com>
References: <5286179E.4070000@gmail.com>
	<CA+DvKQJJuiDNfv7r-TX_1aLcBGQxZ-=oH3=os-qytqGJh_dxiQ@mail.gmail.com>
	<CANK7tAEUny9=Q7fxO2hEF9oj141Qjd=wUAW=Qs1Wed5L1DykWg@mail.gmail.com>
	<528A741A.2080906@mozilla.com>
Message-ID: <CANK7tAGhV-JORgTYxtHK4M4sYQWYmpOhYaTD3Ods76pFQtin-w@mail.gmail.com>

I ve started the github project now i just need to learn rust...

https://github.com/Stibbons/rust-for-pythonists
 Le 18 nov. 2013 21:10, "Brian Anderson" <banderson at mozilla.com> a ?crit :

>  On 11/15/2013 06:24 AM, Gaetan wrote:
>
> I would love a documentation "Rust for Pythonist" or "Rust for C++'iste".
>
>  I don't like the Wiki page. I think the official documentation homepage
> should be a nice, beautiful http://doc.rust-lang.org/<http://static.rust-lang.org/>.
> Period.
> It should link all "official" documentation in a logical way.
> Maybe it should provide a link to the wiki page with only "incubating"
> documentation.
>
>  I think it should be derived from rst/markdown files in conf, closely
> linked to the current version of rust lang. Maybe divided in several
> modules (the summary for rust 0.8 derives from files in the rust 0.8
> branch, for master files are on master, branch...).
>
>
> I would take a patch that does this.
>
>
> -----
> Gaetan
>
>
>
> 2013/11/15 Daniel Micay <danielmicay at gmail.com>
>
>> On Fri, Nov 15, 2013 at 7:46 AM, spir <denis.spir at gmail.com> wrote:
>> > I'm exploring the tutorial "Rust for Rubyists" at
>> > [http://www.rustforrubyists.com/book/book.html], which in fact is not
>> (only)
>> > for rubyists, as stated in the introduction. Looks pretty good to me
>> (just
>> > my opinion), should definitely be pointed to from the Rust Docs page at
>> > [https://github.com/mozilla/rust/wiki/Docs], and in good place. As a
>> > tutorial, it is in my view far better than the "official" one, and is
>> > up-to-date (Rust 0.8), so maybe even just replace it; with a warning
>> note.
>> >
>> > The "official" tutorial is not a bad doc in itself (I guess) but is
>> > definitely not a _tutorial_: in fact, it requires quite a knowledge of
>> Rust,
>> > its fundamental concepts and jargon. "Rust for Rubyists" certainly has
>> room
>> > for improvement, but it _is_ for sure a tutorial. I would definitely
>> suggest
>> > to start writing a new official tutorial by using "Rust for Rubyists"
>> as raw
>> > material. A first pass may be to make it slightly more general, just
>> > requiring prior programming experience; Rust definitely is not a
>> language
>> > for programming novices, anyway.
>> >
>> > Denis
>>
>>  The tutorial is currently quite flawed and has ended up being a list
>> of language features with overviews and low quality examples. Parts of
>> it are approaching the right level of information, but it's not
>> written in the style expected of a tutorial.
>>
>> I think it's very important to cover the core language features like
>> boxes and references at a high level. The unique and least
>> approachable features need great introductory coverage. I recently
>> replaced the old sections on owned boxes, vectors and strings, so any
>> concrete feedback on those would be helpful.
>>  _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/33103445/attachment.html>

From derekchiang93 at gmail.com  Sun Nov 17 23:02:11 2013
From: derekchiang93 at gmail.com (Derek Chiang)
Date: Mon, 18 Nov 2013 02:02:11 -0500
Subject: [rust-dev] Why does string formatting in Rust have to be different
	from other languages?
Message-ID: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>

Hi all,

I'm a newcomer to Rust.  One of the things that I find confusing is the use
of {} in formatted strings.  In all other languages I've ever used, it's
always %.  So instead of writing "%d", you write "{:d}" in Rust.  Why is
this so?  What benefits do we get?

Thanks,
Derek
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/3f76d0f7/attachment-0001.html>

From pcwalton at mozilla.com  Tue Nov 12 13:31:49 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 13 Nov 2013 06:31:49 +0900
Subject: [rust-dev] Fwd:  Please simplify the syntax for Great Justice
In-Reply-To: <21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
Message-ID: <52829E45.4030405@mozilla.com>

On 11/13/13 2:37 AM, Greg wrote:
> 1. ~[Option<Bucket<K,V>>]
>
> 2.  fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) ->
> LinearMap<K,V>
>
> 3.  fn contains_key(&self, k: &K)
>
> My approach would be to try and get rid of templates through better
> type inference in the compiler.

We need the ability to define custom generic containers, which are 
essential for high-performance code. The Go/JS-like approach of building 
a few blessed containers into the language doesn't work when you need 
fine-grained control over data representations, which we need to build a 
competitive browser engine among other considerations.

> I'd introduce the common brace
> literal syntax for maps that can be found in JS and elsewhere, and
> perhaps additional literal syntax (ala ObjC + Clojure).

We use the brace literal syntax for objects already, so we need 
something different. I do think that having a map literal syntax would 
be nice, but that can probably be done via the macro system for now.

> I'd also look at the symbols '~', '@', and '&', and see what could be
> done to remove or simplify those.

The current thinking is to remove `@` and possibly change `~`. `&` will 
likely not change because of familiarity from C++.

> I'd look to see whether ARC could be used instead of garbage
> collection, and whether that would have an impact on syntax or not.

We do support reference counting. The fact that we offer GC is a choice 
that gives control to the programmer.

A broader point, though, is that syntax seems to me to be a very 
unimportant concern when making decisions that impact performance and 
control. Users of high-performance software, who vastly outnumber the 
developers and who never see the source code, aren't going to accept 
tradeoffs made to source-level aesthetics that simultaneously have the 
effect of making their software slow.

> There's also the question of whether symbols (ala
> Lisp/Scheme/Clojure) could be useful in simplifying the language and
> making it more versatile.

Can you elaborate?

Patrick

From danielmicay at gmail.com  Mon Nov 18 14:12:43 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Mon, 18 Nov 2013 17:12:43 -0500
Subject: [rust-dev] Why does string formatting in Rust have to be
 different from other languages?
In-Reply-To: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
References: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
Message-ID: <CA+DvKQ+R5S=tX8KqMD+NrvXsLnprPVzcG49+eZBeVOH3jNSiqA@mail.gmail.com>

On Mon, Nov 18, 2013 at 2:02 AM, Derek Chiang <derekchiang93 at gmail.com> wrote:
> Hi all,
>
> I'm a newcomer to Rust.  One of the things that I find confusing is the use
> of {} in formatted strings.  In all other languages I've ever used, it's
> always %.  So instead of writing "%d", you write "{:d}" in Rust.  Why is
> this so?  What benefits do we get?
>
> Thanks,
> Derek

It's the syntax used by C# and modern Python:

http://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx
http://docs.python.org/2/library/string.html#format-string-syntax

From acrichton at mozilla.com  Mon Nov 18 14:19:43 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Mon, 18 Nov 2013 14:19:43 -0800
Subject: [rust-dev] Why does string formatting in Rust have to be
	different from other languages?
In-Reply-To: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
References: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
Message-ID: <AD48F4D9-6698-4BEB-968D-12CBA1E0011C@mozilla.com>

Rust?s old fmt! syntax also used % instead of {}. The reason for the switch was to primarily support compatibility with an internationalization-style scheme of string formatting. The main benefit of {} of % is that you can nest {} inside of another format, whereas with % you?re limited to just one format. That being said, this effort has not gone underway just yet.

As Daniel also pointed out, the syntax was drawn from other languages instead of inventing one fresh, so it should be familiar to at least some programmers. If you?re curious about how the format syntax works, there?s documentation which can be found at http://static.rust-lang.org/doc/master/std/fmt/index.html.

Hope that clears up any confusion!

On Nov 17, 2013, at 11:02 PM, Derek Chiang <derekchiang93 at gmail.com> wrote:

> Hi all,
> 
> I'm a newcomer to Rust.  One of the things that I find confusing is the use of {} in formatted strings.  In all other languages I've ever used, it's always %.  So instead of writing "%d", you write "{:d}" in Rust.  Why is this so?  What benefits do we get?
> 
> Thanks,
> Derek
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/256a9481/attachment.html>

From dbau.pp at gmail.com  Mon Nov 18 14:22:34 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 19 Nov 2013 09:22:34 +1100
Subject: [rust-dev] Why does string formatting in Rust have to be
 different from other languages?
In-Reply-To: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
References: <CADqrBrAFuLvSKrqJEt-Ns2J74vUkC0Ep7_Shx0O36sr9RuO4bw@mail.gmail.com>
Message-ID: <528A932A.5020901@gmail.com>

On 18/11/13 18:02, Derek Chiang wrote:
> Hi all,
>
> I'm a newcomer to Rust.  One of the things that I find confusing is 
> the use of {} in formatted strings.  In all other languages I've ever 
> used, it's always %.  So instead of writing "%d", you write "{:d}" in 
> Rust.  Why is this so?  What benefits do we get?
>
> Thanks,
> Derek
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

In addition to what Daniel said, being statically typed mean you can 
normally just write `{}` and let the std::fmt::Default implementation 
handle everything (for the primitive types it's the same as the {:d}, 
{:f}, {:s} etc).


Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/aa1708a0/attachment.html>

From banderson at mozilla.com  Mon Nov 18 15:18:20 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 15:18:20 -0800
Subject: [rust-dev] capnproto-rust: performance and safety compared to
 C++
In-Reply-To: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
References: <CABR6rW_nGWd6FLtdhre3uy=TXnKA3SBp7tFMzo45fwpiWXyHOQ@mail.gmail.com>
Message-ID: <528AA03C.7010305@mozilla.com>

On 11/17/2013 11:30 AM, David Renshaw wrote:
> Hi everyone.
>
> I wrote up some of my latest experiences implementing Cap'n Proto 
> encoding for Rust.
>
> A performance comparison to C++, or "capnproto-rust is pretty fast":
> http://dwrensha.github.io/capnproto-rust/2013/11/16/benchmark.html
>
> A discussion of safety, or "why I'm so keen to see support for static 
> trait methods with lifetime parameters":
> http://dwrensha.github.io/capnproto-rust/2013/11/17/lifetimes.html
>
>

Those are very promising results! Thanks for the writeup.

From gokcehankara at gmail.com  Mon Nov 18 15:25:43 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 19 Nov 2013 01:25:43 +0200
Subject: [rust-dev] autocomplete engine for rust
Message-ID: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>

Hello folks,

I have been thinking of working on an editor agnostic code helper library
with an autocomplete engine for rust (since there isn't anything yet?) as a
hobby project to get to know the internals of the compiler. Examples of
similar projects in different languages include;

- [youcompleteme](https://github.com/Valloric/YouCompleteMe)
(C/C++/Objective-C/Objective-C++) (this one is specific to vim and a more
general solution to autocompletion in vim but it includes a clang based
completion engine for c family languages)
- [merlin](https://github.com/def-lkb/merlin) (ocaml) (haven't actually
used this but since we have many ocaml people I'm guessing some people
might have)
- [gocode](https://github.com/nsf/gocode) (go)
- [jedi](https://github.com/davidhalter/jedi) (python)

I have already started playing with the code but couldn't make much
progress. What I had in mind was;

1) Implement a type under cursor functionality
2) Implement autocompletion functionality (i.e by looking up the methods
and members of the type under cursor)
3) Wrap the whole thing with a server-client architecture (only if
performance suffers too much otherwise)
4) Work on the bindings for my editor of choice as the showcase and ask the
community for others

Unfortunately I'm still at step 1. I have managed to parse a file until
typecheck using `phase_3_run_analysis_passes` which gave me a
`CrateAnalysis` including presumably the type context in `ty::ctxt`. From
there I have only checked two things so far, (1) `items: ast_map::map`
which is basically a map from `NodeId` to the enum `ast_node` and (2)
`node_types: node_type_table` which is similarly a map from `uint` to `t`.

`t` seems to represent types which is what I was looking for although I
couldn't find anything related to type names so far. I have found a few
id's instead that I have yet to comprehend which then made me think that it
might be the case that types themselves might be stored only with an id
instead of a name. If this is the case, it may still be possible to work on
autocomplete functionality by skipping type under cursor functionality. Any
insight?

Some more general questions are;

- How feasible is this project with the current state of the compiler?
- How difficult would it be for a newbie (to both rustc and compilers)?
- Shall I open an issue for this?

Thanks,
Gokcehan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/be461154/attachment.html>

From banderson at mozilla.com  Mon Nov 18 15:56:31 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 15:56:31 -0800
Subject: [rust-dev] select on std::comm::Port and different types
In-Reply-To: <CABUcDvO1j0j8C8dQyhxWUu5i=N4Z4GaoBZv6CzvpV1W4_HLbEA@mail.gmail.com>
References: <CABUcDvMraE=AZ7ny4-y0anb_Ys+MB9kFUxw8UTekiP7-ZeamKQ@mail.gmail.com>	<528576B1.3050909@mozilla.com>
	<CABUcDvO1j0j8C8dQyhxWUu5i=N4Z4GaoBZv6CzvpV1W4_HLbEA@mail.gmail.com>
Message-ID: <528AA92F.1050705@mozilla.com>

On 11/15/2013 05:03 PM, Diego Ongaro wrote:
> On Thu, Nov 14, 2013 at 5:19 PM, Brian Anderson <banderson at mozilla.com> wrote:
>> On 11/14/2013 04:03 PM, Diego Ongaro wrote:
>>> My program starts a bunch of tasks, then I want the main task to both
>>> receive ctrl-c signals and receive results from the children. The
>>> signal will come from a std::rt::io::signal::Listener's port, which is
>>> an std::comm::Port<Signum>. The child results will come from a
>>> std::comm::Port<~[uint]>.
>>>
>>> My first problem is that std::comm::Port doesn't implement
>>> std::select::Select. It looks like std::rt::comm::Port does, and
>>> std::comm::Port is just a small wrapper around that, but
>>> std::comm::Port makes its internal std::rt::comm::Port private. Is
>>> there any way to select on a std::comm::Port? (And what's the
>>> difference between a std::rt::comm::Port and a std::comm::Port?)
>>
>> There currently isn't a way - this feature isn't fully baked yet, but it
>> should not take a whole lot of effort to get it working. There is no
>> functional difference between  std::comm and std::rt::comm; std::rt::comm
>> should be moved wholesale to std::comm and the current std::comm deleted,
>> but it hasn't been done yet.
> Ok. In the meantime until std::comm gets blown away, can we comment
> out the "priv" keyword in it?  I've attached a patch that does this.
> This patch would be enough to allow me and others to work around this
> issue for now (see below).

Yes. Can you open a pull request?

>
>
>>> My second problem is that std::select::select() doesn't seem to
>>> support selecting from ports with different types. Naively, I tried
>>> select([p1, p2]), but that expects p1 and p2 to have the same type:
>>> error: mismatched types: expected
>>> `std::rt::comm::Port<std::rt::io::signal::Signum>` but found
>>> `std::rt::comm::Port<~[uint]>` (expected enum
>>> std::rt::io::signal::Signum but found vector)
>>> It'll need dynamic dispatch, so I tried: select([p1 as &Select, p2 as
>>> &Select]). However, this doesn't work since &Select doesn't implement
>>> Select:
>>> error: failed to find an implementation of trait std::select::Select
>>> for &std::select::Select<no-bounds>
>>>
>>> There's some commented out code that may be related in select.rs,
>>> though it's hard for me to know where this stands:
>>> /* FIXME(#5121, #7914) This all should be legal, but rust is not
>>> clever enough yet.
>>>
>>> impl <'self> Select for &'self mut Select {
>>>       fn optimistic_check(&mut self) -> bool { self.optimistic_check() }
>>>       fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) ->
>>> bool {
>>>           self.block_on(sched, task)
>>>       }
>>>       fn unblock_from(&mut self) -> bool { self.unblock_from() }
>>> }
>>> ...
>>>
>>> How can I select on two ports of different types?
>>
>> My understanding is that this code needs to be enabled to make select on
>> heterogenous types work correctly. I do not know the details of this code
>> but it appears that Niko has not landed a fix for #5121 yet. Contributions
>> here are very welcome.
> I think this is beyond my understanding of Rust internals for now
> (though hey, just started with Rust this week, who knows). I didn't
> spend much time on it, but I wasn't able to get this code to work by
> just removing the comments. Instead, I have a workaround that does the
> job for me once the attached patch is applied. It creates a wrapper
> struct called SelectBox which implements Select by forwarding all
> methods of SelectInner to an &'self mut Select field. Then I created a
> macro to make the syntax tolerable. That's all available at
> https://gist.github.com/ongardie/7494388 along with an example.
>
> Best,
> Diego


From hatahet at gmail.com  Mon Nov 18 16:23:13 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Mon, 18 Nov 2013 16:23:13 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <52829E45.4030405@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
Message-ID: <CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>

> ...and possibly change `~`.

To what?

--
Ziad


On Tue, Nov 12, 2013 at 1:31 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/13/13 2:37 AM, Greg wrote:
>
>> 1. ~[Option<Bucket<K,V>>]
>>
>> 2.  fn linear_map_with_capacity<K:Eq + Hash,V>(capacity: uint) ->
>> LinearMap<K,V>
>>
>> 3.  fn contains_key(&self, k: &K)
>>
>> My approach would be to try and get rid of templates through better
>> type inference in the compiler.
>>
>
> We need the ability to define custom generic containers, which are
> essential for high-performance code. The Go/JS-like approach of building a
> few blessed containers into the language doesn't work when you need
> fine-grained control over data representations, which we need to build a
> competitive browser engine among other considerations.
>
>
>  I'd introduce the common brace
>> literal syntax for maps that can be found in JS and elsewhere, and
>> perhaps additional literal syntax (ala ObjC + Clojure).
>>
>
> We use the brace literal syntax for objects already, so we need something
> different. I do think that having a map literal syntax would be nice, but
> that can probably be done via the macro system for now.
>
>
>  I'd also look at the symbols '~', '@', and '&', and see what could be
>> done to remove or simplify those.
>>
>
> The current thinking is to remove `@` and possibly change `~`. `&` will
> likely not change because of familiarity from C++.
>
>
>  I'd look to see whether ARC could be used instead of garbage
>> collection, and whether that would have an impact on syntax or not.
>>
>
> We do support reference counting. The fact that we offer GC is a choice
> that gives control to the programmer.
>
> A broader point, though, is that syntax seems to me to be a very
> unimportant concern when making decisions that impact performance and
> control. Users of high-performance software, who vastly outnumber the
> developers and who never see the source code, aren't going to accept
> tradeoffs made to source-level aesthetics that simultaneously have the
> effect of making their software slow.
>
>
>  There's also the question of whether symbols (ala
>> Lisp/Scheme/Clojure) could be useful in simplifying the language and
>> making it more versatile.
>>
>
> Can you elaborate?
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/5d697266/attachment.html>

From pcwalton at mozilla.com  Mon Nov 18 16:27:04 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 18 Nov 2013 16:27:04 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
Message-ID: <528AB058.2010706@mozilla.com>

On 11/18/13 4:23 PM, Ziad Hatahet wrote:
>> ...and possibly change `~`.
>
> To what?

`*`

Patrick


From banderson at mozilla.com  Mon Nov 18 17:13:17 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 17:13:17 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
Message-ID: <528ABB2D.6030802@mozilla.com>

On 11/15/2013 12:09 AM, Alex Crichton wrote:
> I've been thinking about static linking recently, along with a little bit of
> linking in general, and I wanted to see what others thought.
>
> # The Goal
>
> Primarily, I believe that if desired, rustc should be able to generate an
> executable or dynamic library with no dependence on any rust libraries. This
> includes things like librustrt and libextra. Rust shouldn't be striving to lift
> dependence on system libraries, that'll come at later times if need be.
>
> Additionally, rustc should be able to generate libfoo.a where libfoo.a has no
> dependence on any rust libraries. This library can then be statically linked to
> another application.
>
> # Intermediate static libraries
>
> I personally know of no way to create a static library from a dynamic one, so to
> achieve this we would need to distribute libstd and libextra in some form that
> is not a shared library. This problem not only applies to libstd, but also to
> any rust library which wants to be statically linked.
>
> The first natural conclusion for for an intermediate format would be a .a file
> itself. Why not distribute libstd.a along with libstd.so. After all, a .a is
> only an archive which in our case would contain one .o file. In thinking about
> this though, I don't think that this is the best format. The main idea of
> providing intermediate .a files is to allow linkage to them via the normal
> system linker. To be usable, this would mean that all .a files rust generates
> would have to have their own statically linked version of libstd or otherwise
> everyone will have to find where libstd is guess the name and hash attached to
> it. This is infeasible for arbitrary libraries which could have arbitrarily many
> dependencies.
>
> # Native Libraries
>
> One part of linking which rust cannot forget is native libraries. Right now,
> native libraries are always linked against when compiling a local crate, but no
> native library dependencies are propagated among crates.
>
> Due to the nature of a static library and what I assume is the file format
> itself, a static rust library cannot link to its dependent dynamic libraries. We
> can, however, resolve all native static dependencies at compile time.
>
> # A Scheme for Linking
>
> With the above knowledge, I would propose the following linkage model for rust.
>
> There are four types of files that the rust compiler will generate:
>
> 1. An executable
> 2. A dynamic library (.so, .dylib, .dll)
> 3. A "rust" static library (.rlib)
> 4. A regular static library (.a, .lib)
>
> The "rust language" would ship with dynamic library files as well as .rlib
> files. There would be no .a files in the distribution.
>
> A rust static library would be a format defined by rust that is not available
> for or intended for external use. It is meant to be beneficial to the rust
> compiler and that's it. It just so happens that their first incarnation would be
> created similarly to `cp foo.o foo.rlib`.
>
> In addition to these changes, the linkage attributes would change to be as
> follows:
>
> * #[link_args] becomes gated behind a feature flag. I believe that this is still
>    a very useful ability to pass arbitrary flags to the linker, but this is *not*
>    a sanctioned way of doing so at all because of how platform specific it is
>
> * #[link(...)] becomes the new method of specifying linkage semantics on extern
>    blocks, and it may be used similarly to link_args today

I'd kind of like for this to be available at the crate level too since 
most libraries don't use OS X two-level namespaces and it's more 
convient to me to just put all the linkage at the top of the crate. Of 
course this conflicts with the `link` attribute of crates, which I think 
is poorly named anyway.

>
>    * #[link(name = "foo")] specifies that this crate links to native library
>      `foo`
>    * #[link(once)] implies that the native library is a static library, hence it
>      *must* be linked against in the current compilation, regardless of the
>      output format
>
>    Omission of `link(once)` assumes that the library is available at all
>    destinations, and it may not be linked against in the current compilation
>    unit.

I don't really understand what 'once' implies in `link(once)` and how it 
relates to statics. If a static library *must* be linked, then dynamic 
libraries may not be linked? Why is that? If 'once' implies 'static', 
can we just say 'link(static)'? I assume some argument propagation is 
going to come into play here ...

Will also need to accomodate some other common features like, e.g. 
`link(framework = "foo")` or something for OS X frameworks.

>
> ## The Linkage Step
>
> To see how this affects how artifacts are created, I'd like to go into detail
> about how each of the four output artifacts all interact with one another by
> describing the linkage phase of each output. For each of these, remember that
> the compiler's output is one .o file for each crate. Also remember that all rust
> libraries will always link to all upstream rust libraries.
>
> ### Linking Executables and Dynamic Libraries
>
> These two cases are very similar because they are creating the actual "result
> artifact" in terms of a file which will have no more linkage performed on it.
> The following components must be linked in to produce the artifact:
>
> * The local .o file
> * All local native dependencies
> * All upstream rust libraries (dynamic and static)
> * All non-once (dynamic) native libraries of upstream static crates. More on
>    this later
>
> The result artifact needs to be a fully resolved destination artifact. The point
> of this is to have a dynamic dependency on all upstream dynamic libraries, and
> all upstream static libraries will have been sucked in to create the target.
>
> ### Creating rust static libraries (.rlib files)
>
> As mentioned above, these files are similar to the compiler's .o output. The
> only other component which can be considered for inclusion in this .o file is
> all native static library dependencies. These are encoded as #[link(once)] in
> linkage attributes. The reason for doing this is that it's likely to be common
> to have a local static library which is not available in distribution, but is
> always available for the build process. Examples for the compiler include
> libsundown, libuv, libuv_support, and maybe librustrt.

.rlib files also need the crate metadata.

>
> The .rlib file will be created by using ld's -r flag. This output will then have
> all native static dependencies resolved, but remember that no rust dependencies
> were part of this linkage process. Whenever this .rlib file is used, all of its
> dependencies are encoded in the metadata and they're all sucked in at the end as
> well.

What happens when two upstream crates link to the same native static 
library? In the final link step they are both going to be linked in, and 
I presume there's some kind of conflict?

>
> The goal of not pulling in all rust dependencies is to avoid finding a static
> copy of libstd in all .rlib files everywhere.
>
> ### Creating a system static library (.a or .lib)
>
> The whole point of being able to do this is so that a rust component can be
> statically linked into another application. The idea behind this mode of
> compilation is to be just as much of a destination artifact as an executable or
> dynamic library. The rust compiler will never attempt to link against
> rust-generated .a files (it has .rlib files to look for). The .a files are
> purely meant for external usage.
>
> Again though, due to the nature of the .a format, we cannot be as comprehensive
> in our dependency resolution as we were in the above cases. The first thing to
> consider is all inputs to this file:
>
> * The compiler's output .o file
> * All local native static libraries
> * All upstream rust .rlib files
>
> Note how there is no mention of upstream dynamic library dependencies. Sadly, I
> know of encoding those dependencies in this .a output format. I would propose
> the compiler printing a warning when this is performed such that when undefined
> references are found you at least have a suggestion of what dynamic libraries
> you need to link against.
>
> ## Static vs Dynamic
>
> This scheme outlines the ability to manage static and dynamic native libraries,
> but it would mean that we're going to start introducing static and dynamic rust
> libraries in the same location. I would propose that the compiler automatically
> favors static linkage over dynamic linkage due to various rust ABI issues. This
> default could be switched in the future, but it simply means that if the
> compiler finds a .so and a .rlib, it will suck in the .rlib before sucking in
> the .so.
>
> ## Compiler UI
>
> If we have a scheme like this, we certainly need a method of managing it from
> the command line. I would propose dropping all linkage related flags we have
> today, and starting over with the following:
>
> * --rlib, --dylib, --staticlib. These three options are stackable, and control
>    the output format of the compiler. If nothing is specified, then an executable
>    is assumed. The reason that these are stackable is becuase it is possible
>    to create multiple artifacts from one compilation instead of having to
>    recompile
>
> * -Z print-link-args. This is the same as it is today

How does one opt into linking to dynamic libraries? Without some further 
mechanism everybody will be linking to the static libstd.

>
> # Conclusion
>
> I originally thought that this would be a proposal for adding static linking,
> but this has kinda become more of a makeover of rust's current linkage model. I
> believe that this scheme will solve the "static library" problem as well as
> still accomodating the dynamic library approach that we have today. I wanted to
> get this all down in writing, and I feel like this is certainly concrete enough
> to act upon, but before doing so this should definitely be discussed.
>
> What are others' thoughts on this? Is this too complex of a system? Is there a
> glaring omission of use cases?

It sounds promising to me.

>
> Hopefully soon we can generate a rust library with no dynamic rust dependencies!
>
> ---
>
> As a side node, after writing all this up, I remembered LTO as an
> option for generating libraries. I don't think I know enough about LTO
> to be able to say whether it would fit in this system or not, but my
> basic understanding is that an LTO library is just "IR in a box". We
> could add a --lto output option which has pretty much the same
> semantics as the --rlib option, but with a different format. Again
> though, I haven't thought how native libraries would fit into that
> scenario, but I believe that we could fairly easily accommodate LTO in
> a system like this.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From banderson at mozilla.com  Mon Nov 18 17:17:20 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 17:17:20 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <20131115110114.GC24821@Mr-Bennet>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
Message-ID: <528ABC20.2020904@mozilla.com>

On 11/15/2013 03:01 AM, Niko Matsakis wrote:
> A few quick questions and comments:
>
> On Fri, Nov 15, 2013 at 12:09:28AM -0800, Alex Crichton wrote:
>> As a side node, after writing all this up, I remembered LTO as an
>> option for generating libraries. I don't think I know enough about LTO
>> to be able to say whether it would fit in this system or not, but my
>> basic understanding is that an LTO library is just "IR in a box". We
>> could add a --lto output option which has pretty much the same
>> semantics as the --rlib option, but with a different format. Again
>> though, I haven't thought how native libraries would fit into that
>> scenario, but I believe that we could fairly easily accommodate LTO in
>> a system like this.
> Unless I'm missing something, it seems like what we would want to do
> is to have the .rlib file contain LLVM IR, at least for the Rust code
> that was compiled / statically linked against. If we can, I think we
> should just make LTO happen by default whenver you statically link,
> rather than having it be a separate option, but it is fine if that
> doesn't work yet in the first version (e.g., because .rlib is just a
> .o file). Still I agree that your scheme accommodates it just fine.
>

I'm not sure I agree that LTO should be the default - for large 
applications it's going to be brutal on LLVM and I imagine we'll quickly 
hit scenarios where we run out of RAM. For something like a production 
Servo I imagine we would go to whatever lengths necessary to LTO 
everything, but it would be cheaper and faster to do normal static 
linking. Some empirical evidence about how far we can push LLVM's LTO 
would be helpful though.

From banderson at mozilla.com  Mon Nov 18 17:19:21 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Mon, 18 Nov 2013 17:19:21 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <20131115110114.GC24821@Mr-Bennet>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<20131115110114.GC24821@Mr-Bennet>
Message-ID: <528ABC99.3040407@mozilla.com>

On 11/15/2013 03:01 AM, Niko Matsakis wrote:
> A few quick questions and comments:
>
> On Fri, Nov 15, 2013 at 12:09:28AM -0800, Alex Crichton wrote:
>> I've been thinking about static linking recently, along with a little bit of
>> linking in general, and I wanted to see what others thought.
>>
>> # The Goal
>>
>> Primarily, I believe that if desired, rustc should be able to generate an
>> executable or dynamic library with no dependence on any rust libraries. This
>> includes things like librustrt and libextra. Rust shouldn't be striving to lift
>> dependence on system libraries, that'll come at later times if need be.
> It seems like you *are* striving to lift dependencies on non-rust
> libraries, though. For example, you mention having libuv be statically
> imported into a .rlib file etc. Or did I misunderstand?

I took this to mean that we would just be packaging up the static 
libraries to save them for the final link step (since the rlib is just a 
.o file, not pre-linked to it's static lib dependencies). The effect of 
this though may be that all downstream crates implicitly have access to 
all the static library's symbols.

From ben.striegel at gmail.com  Mon Nov 18 17:33:13 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Mon, 18 Nov 2013 20:33:13 -0500
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <528AB058.2010706@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
Message-ID: <CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>

>> To what?

> `*`

...But only if you change the deref operator to something else.
Bikeshedding thread! :P


On Mon, Nov 18, 2013 at 7:27 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/18/13 4:23 PM, Ziad Hatahet wrote:
>
>> ...and possibly change `~`.
>>>
>>
>> To what?
>>
>
> `*`
>
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/fea505c5/attachment.html>

From pcwalton at mozilla.com  Mon Nov 18 17:34:03 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 18 Nov 2013 17:34:03 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>	<52829E45.4030405@mozilla.com>	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
Message-ID: <528AC00B.1000909@mozilla.com>

On 11/18/13 5:33 PM, Benjamin Striegel wrote:
>  >> To what?
>
>  > `*`
>
> ...But only if you change the deref operator to something else.
> Bikeshedding thread! :P

No, allocation would be with `new`.

Patrick


From ncm at cantrip.org  Mon Nov 18 17:36:57 2013
From: ncm at cantrip.org (Nathan Myers)
Date: Mon, 18 Nov 2013 17:36:57 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <528AB058.2010706@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
Message-ID: <528AC0B9.5050801@cantrip.org>

On 11/18/2013 04:27 PM, Patrick Walton wrote:
> On 11/18/13 4:23 PM, Ziad Hatahet wrote:
>>> ...and possibly change `~`.
>>
>> To what?
>
> `*`

Also, s/fn/fun/g

We must not underestimate the importance of being perceived as a
fun language.

"C++ is a general purpose programming language designed to make 
programming more enjoyable for the serious programmer."
  - Bjarne Stroustrup

"Rust is a general purpose language designed to make programming
more fun for the serious programmer."
  - nobody, yet.

Seriously,
Nathan Myers

From acrichton at mozilla.com  Mon Nov 18 18:22:40 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Mon, 18 Nov 2013 18:22:40 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <528ABB2D.6030802@mozilla.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<528ABB2D.6030802@mozilla.com>
Message-ID: <4111F0A2-153B-4131-B450-753768F6DE46@mozilla.com>


>> * #[link(...)] becomes the new method of specifying linkage semantics on extern
>>   blocks, and it may be used similarly to link_args today
> 
> I'd kind of like for this to be available at the crate level too since most libraries don't use OS X two-level namespaces and it's more convient to me to just put all the linkage at the top of the crate. Of course this conflicts with the `link` attribute of crates, which I think is poorly named anyway.

What purpose did you have in mind for the #[link] attribute at the top of the crate? Is the crate saying how it should be linked to other crates?

> I don't really understand what 'once' implies in `link(once)` and how it relates to statics. If a static library *must* be linked, then dynamic libraries may not be linked? Why is that? If 'once' implies 'static', can we just say 'link(static)'? I assume some argument propagation is going to come into play here ...
> 
> Will also need to accomodate some other common features like, e.g. `link(framework = "foo")` or something for OS X frameworks.

What this ended up turning out as is #[link(name = ?foo?, kind = ?static?)]. I think that a ?framework? kind would fit quite well for this use case.

> .rlib files also need the crate metadata.

I agree

> What happens when two upstream crates link to the same native static library? In the final link step they are both going to be linked in, and I presume there's some kind of conflict?

Right now they?re both linked in. I didn?t envision this as a use case for rustc to complain about, but it would be simple enough to iterate over all upstream crates and see if the same static library were linked twice. My implementation requires metadata about the linkage regardless.

> How does one opt into linking to dynamic libraries? Without some further mechanism everybody will be linking to the static libstd.

I?ve reserved another -Z flag for ?-Z prefer-dynamic'

> I took this to mean that we would just be packaging up the static libraries to save them for the final link step (since the rlib is just a .o file, not pre-linked to it's static lib dependencies). The effect of this though may be that all downstream crates implicitly have access to all the static library's symbols.

This actually what currently happens. The resulting rlib file already contains all of the static native libraries bundled inside of it. This is achieved via ld?s -r option. It is true that all of the symbols leak through, however, and this is unfortunate. I?d like to explore methods of preventing this, but I only know of one way currently. We?d create a list of all symbols in the rust library (an actual file on the filesystem), and then pass that to the linker saying ?here are all the exported symbols, discard everything else.?



From hatahet at gmail.com  Mon Nov 18 19:05:18 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Mon, 18 Nov 2013 19:05:18 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <528AC00B.1000909@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
Message-ID: <CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>

On Mon, Nov 18, 2013 at 5:34 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> No, allocation would be with `new`.
>


Would that have to proceed each allocation? For instance, would

let v = ~[~"one", ~"two", ~"three"];

turn into

let v = new Vector(new "one", new "two", new "three");

?

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/26726f1a/attachment.html>

From pwalton at mozilla.com  Mon Nov 18 19:06:41 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 18 Nov 2013 19:06:41 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
Message-ID: <86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>

Yes.

Patrick

Ziad Hatahet <hatahet at gmail.com> wrote:
>On Mon, Nov 18, 2013 at 5:34 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> No, allocation would be with `new`.
>>
>
>
>Would that have to proceed each allocation? For instance, would
>
>let v = ~[~"one", ~"two", ~"three"];
>
>turn into
>
>let v = new Vector(new "one", new "two", new "three");
>
>?
>
>--
>Ziad

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/2f79a6aa/attachment.html>

From pwalton at mozilla.com  Mon Nov 18 19:09:35 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Mon, 18 Nov 2013 19:09:35 -0800
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
Message-ID: <14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>

Keep in mind that, IMHO, the brevity of ~"" is a large reason why people overallocate and make Rust programs slower than they need to be (e.g. your example).

Patrick

Patrick Walton <pwalton at mozilla.com> wrote:
>Yes.
>
>Patrick
>
>Ziad Hatahet <hatahet at gmail.com> wrote:
>>On Mon, Nov 18, 2013 at 5:34 PM, Patrick Walton
>><pcwalton at mozilla.com>wrote:
>>
>>> No, allocation would be with `new`.
>>>
>>
>>
>>Would that have to proceed each allocation? For instance, would
>>
>>let v = ~[~"one", ~"two", ~"three"];
>>
>>turn into
>>
>>let v = new Vector(new "one", new "two", new "three");
>>
>>?
>>
>>--
>>Ziad
>
>-- 
>Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/6696ce05/attachment-0001.html>

From kevin at sb.org  Mon Nov 18 19:41:54 2013
From: kevin at sb.org (Kevin Ballard)
Date: Mon, 18 Nov 2013 19:41:54 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
Message-ID: <78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>

Is that really why, or are you just  guessing? I'm assuming the real reason is that people are used to languages where heap allocation is common and stack allocation rare or nonexistant, and don't understand why boxing everything is a bad idea. In other words, it's a problem that a proper tutorial should be able to help with. I don't think changing syntax is going to make much of a difference.

-Kevin

On Nov 18, 2013, at 7:09 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> Keep in mind that, IMHO, the brevity of ~"" is a large reason why people overallocate and make Rust programs slower than they need to be (e.g. your example).
> 
> Patrick
> 
> Patrick Walton <pwalton at mozilla.com> wrote:
> Yes.
> 
> Patrick
> 
> Ziad Hatahet <hatahet at gmail.com> wrote:
> On Mon, Nov 18, 2013 at 5:34 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> No, allocation would be with `new`.
> 
> 
> Would that have to proceed each allocation? For instance, would
> 
> let v = ~[~"one", ~"two", ~"three"];
> 
> turn into
> 
> let v = new Vector(new "one", new "two", new "three");
> 
> ?
> 
> --
> Ziad
> 
> 
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/385451a7/attachment.html>

From zack at z0w0.me  Mon Nov 18 20:01:54 2013
From: zack at z0w0.me (Zack Corr)
Date: Tue, 19 Nov 2013 14:01:54 +1000
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <528ABB2D.6030802@mozilla.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<528ABB2D.6030802@mozilla.com>
Message-ID: <CAJjz6c0j2wDLpKt4n-7seCHnKTwMnjU1osMgeXg7irAG-=ok2g@mail.gmail.com>

On Tue, Nov 19, 2013 at 11:13 AM, Brian Anderson <banderson at mozilla.com>wrote:

> Of course this conflicts with the `link` attribute of crates, which I
> think is poorly named anyway.
>

Perhaps #[link] in its current usage should be renamed to #[crate]? I think
that would make more sense.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/26678da5/attachment.html>

From bklooste at gmail.com  Mon Nov 18 20:04:37 2013
From: bklooste at gmail.com (Ben Kloosterman)
Date: Tue, 19 Nov 2013 12:04:37 +0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
Message-ID: <CAJT18iZD5zeTH-ixJS+uX3efXFe3J8fwP3oG5bN_ZxKHO26dVA@mail.gmail.com>

He said IMHO ..

An explicit "new" is a huge indicator of what is going on ... most people
are familiar enough with stack allocation early adopters are not 9-5
developers..

Ben


On Tue, Nov 19, 2013 at 11:41 AM, Kevin Ballard <kevin at sb.org> wrote:

> Is that really why, or are you just  guessing? I'm assuming the real
> reason is that people are used to languages where heap allocation is common
> and stack allocation rare or nonexistant, and don't understand why boxing
> everything is a bad idea. In other words, it's a problem that a proper
> tutorial should be able to help with. I don't think changing syntax is
> going to make much of a difference.
>
> -Kevin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/4a0ade0e/attachment.html>

From pcwalton at mozilla.com  Mon Nov 18 20:17:41 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Mon, 18 Nov 2013 20:17:41 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
Message-ID: <528AE665.3010000@mozilla.com>

On 11/18/13 7:41 PM, Kevin Ballard wrote:
> Is that really why, or are you just  guessing? I'm assuming the real
> reason is that people are used to languages where heap allocation is
> common and stack allocation rare or nonexistant, and don't understand
> why boxing everything is a bad idea. In other words, it's a problem that
> a proper tutorial should be able to help with. I don't think changing
> syntax is going to make much of a difference.

I've observed a lot of beginning Rust programmers treat the language as 
"add sigils until it works". (I have specific examples but don't want to 
name people here; however, feel free to contact me privately if you're 
curious.) They end up with slow programs and frustrated with Rust, 
wondering why they had to fight the compiler if they seemingly didn't 
gain any performance from it.

I think a fair amount of it is that the sigils don't visually convey 
enough information to the programmer; they feel like something that you 
just have to add to make the compiler happy. A sigil in Rust's 
expression grammar as it stands represents an *action*, not a 
*qualifier* as it does in most other languages (e.g. `$foo` in PHP). 
Moreover, the `~` expression maps to one of the most expensive machine 
operations in the entire language semantics! It's thus important in my 
view to emphasize to newcomers that `~` *means* something; it is not 
just a qualifier you have to add to make the compiler happy. Indeed, if 
you are adding it just to make the compiler accept your code, there's 
something wrong--either the API you're using is inefficient or you're 
confused about the semantics!

Patrick


From thadguidry at gmail.com  Mon Nov 18 21:03:29 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Mon, 18 Nov 2013 23:03:29 -0600
Subject: [rust-dev] Rust docs
In-Reply-To: <528A7322.3010602@mozilla.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
Message-ID: <CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>

>
>
> I tend to agree with this, think that a collaborative approach is unlikely
> to produce a consistent and high quality tutorial. I don't want to
> discourage anybody but my current opinion is that we should hire an
> experienced technical writer to do this piece especially, with input from
> the wider community. Where I think collaboration is more likely to produce
> something nice is in a 'cookbook' style document, of which several people
> have already worked on seperately. Also of course API docs and the
> reference manual are places where individuals can plug in their own
> sections without impacting the overall narrative flow.
>
>
So I spent this evening going through the tutorial (.08).  As an outsider
to Rust, I can tell you it does not fit any model of a tutorial, but
instead is an elongated language reference broken down into feature
sections.  Which is highly useful in its design, and does say "This
tutorial assumes that the reader is already familiar with one or more
languages in the C family. Understanding of pointers and general memory
management techniques will help."  BUT...

It was not until section 17, that I finally met with a simple program that
could compile.  That was 2 1/2 hours later before I was able to DO
SOMETHING.

I would encourage the Mozilla team to hire a technical writer as Brian
suggests, that would turn the tutorial upside down...

Start with something fun and entertaining in under 10 or 20 lines of Rust,
that would amuse and provide "hackability" to tweak and play with values,
mutability, and seeing the stack pop itself (half the developers in the
world, do not know or have to worry about "a stack"..but of course "should"
in any decent systems language :-) ), and then introduce garbage
collecting, etc.   Introduce compile-able examples from the start, and
continue with working examples that actually produce errors and let the
user come to grips with the syntax & compiler error output, while coaching
them through fixing the errors, and learning the do's and don'ts of Rust's
current best practices.  That would be a mighty fine tutorial and the
makings of a book for Rust itself.

2 cents and a haircut and I wish the team tremendous success on finding a
talented writer,

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131118/4747de0d/attachment-0001.html>

From gaetan at xeberon.net  Tue Nov 19 01:04:12 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:04:12 +0100
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
Message-ID: <CANK7tAExP7rC3rnf7yWLDFHpvTpFdTnFL9TN3i=T8Of2M4CZ_A@mail.gmail.com>

Hello

I'm willing to help on this task, I think having a good completion library
can help a lot smoothing the learning curve of a new language. I learned
python in a few days with aptana, and I remember a few years ago how it was
easy to write C++ with visual studio. Having an IDE integration is almost
as important as having good tutorials.

I'm also a newbe in Rust and I imagine you want to write in rust itself. I
can help on the integration with sublime.

-----
Gaetan



2013/11/19 Gokcehan Kara <gokcehankara at gmail.com>

> Hello folks,
>
> I have been thinking of working on an editor agnostic code helper library
> with an autocomplete engine for rust (since there isn't anything yet?) as a
> hobby project to get to know the internals of the compiler. Examples of
> similar projects in different languages include;
>
> - [youcompleteme](https://github.com/Valloric/YouCompleteMe)
> (C/C++/Objective-C/Objective-C++) (this one is specific to vim and a more
> general solution to autocompletion in vim but it includes a clang based
> completion engine for c family languages)
> - [merlin](https://github.com/def-lkb/merlin) (ocaml) (haven't actually
> used this but since we have many ocaml people I'm guessing some people
> might have)
> - [gocode](https://github.com/nsf/gocode) (go)
> - [jedi](https://github.com/davidhalter/jedi) (python)
>
> I have already started playing with the code but couldn't make much
> progress. What I had in mind was;
>
> 1) Implement a type under cursor functionality
> 2) Implement autocompletion functionality (i.e by looking up the methods
> and members of the type under cursor)
> 3) Wrap the whole thing with a server-client architecture (only if
> performance suffers too much otherwise)
> 4) Work on the bindings for my editor of choice as the showcase and ask
> the community for others
>
> Unfortunately I'm still at step 1. I have managed to parse a file until
> typecheck using `phase_3_run_analysis_passes` which gave me a
> `CrateAnalysis` including presumably the type context in `ty::ctxt`. From
> there I have only checked two things so far, (1) `items: ast_map::map`
> which is basically a map from `NodeId` to the enum `ast_node` and (2)
> `node_types: node_type_table` which is similarly a map from `uint` to `t`.
>
> `t` seems to represent types which is what I was looking for although I
> couldn't find anything related to type names so far. I have found a few
> id's instead that I have yet to comprehend which then made me think that it
> might be the case that types themselves might be stored only with an id
> instead of a name. If this is the case, it may still be possible to work on
> autocomplete functionality by skipping type under cursor functionality. Any
> insight?
>
> Some more general questions are;
>
> - How feasible is this project with the current state of the compiler?
> - How difficult would it be for a newbie (to both rustc and compilers)?
> - Shall I open an issue for this?
>
> Thanks,
> Gokcehan
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/cb186b29/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 01:06:23 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:06:23 +0100
Subject: [rust-dev] list of all reserved keywords of the language
Message-ID: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>

hello

Where can I find an exhaustive list of the keywords defined by the
language? I want to add basic syntax highlighting support to the rust
language to some web editors and I don't know all of them yet.

Thanks.

-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/b21f44d5/attachment.html>

From j.boggiano at seld.be  Tue Nov 19 01:12:23 2013
From: j.boggiano at seld.be (Jordi Boggiano)
Date: Tue, 19 Nov 2013 10:12:23 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528AE665.3010000@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
Message-ID: <CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>

On Tue, Nov 19, 2013 at 5:17 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> I've observed a lot of beginning Rust programmers treat the language as "add
> sigils until it works". (I have specific examples but don't want to name
> people here; however, feel free to contact me privately if you're curious.)

I feel like I have to out myself as one of the idiot newcomers that do
this, just for the sake of the discussion. I have no systems language
background and frankly never had to consider the difference between
the heap or the stack in the past 10-some years of writing code.

I don't really think having new vs ~ would help me avoid this problem.
The issue I believe is that the language looks understandable enough
for the average joe used to higher level web languages (php, python,
ruby). That's a great thing of course, that I can just jump in and
mostly grasp what's going on, while past attempts at C++ tinkering
quickly ended in tears. It also means that you have lots of people
that come in and are capable of getting stuff to compile but won't
necessarily understand the small print. Often there is an alternative
to pooping sigils all over the code, but if you don't understand the
concepts behind it it's hard to reason about what those alternatives
could be.

I think I'm getting better with this over time, and the rust libraries
also get more usable and consistent leading to less ~ insanity, but
one thing that would have helped early on is a good warning in the
docs about this, and a good explanation of what the hell is going on
(not one geared towards C++ devs using lingo that only low level devs
are familiar with).

I realize it's no easy task, and that arguably I should probably just
read a book, but at the same time it's an amazing feat I think that
the language is so accessible while remaining at such a low level, so
if we manage to improve the onboarding process it would probably be
very beneficial. There are tons of web devs that are interested in
doing things faster/lower level - if only for fun. Maybe it's worth
having a chapter for them in the docs. I'd happily help review that
and point out unclear things :)

Cheers

-- 
Jordi Boggiano
@seldaek - http://nelm.io/jordi

From josh at joshmatthews.net  Tue Nov 19 01:12:25 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Tue, 19 Nov 2013 17:12:25 +0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
Message-ID: <CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>

http://static.rust-lang.org/doc/master/rust.html#keywords

Cheers,
Josh


On 19 November 2013 17:06, Gaetan <gaetan at xeberon.net> wrote:

> hello
>
> Where can I find an exhaustive list of the keywords defined by the
> language? I want to add basic syntax highlighting support to the rust
> language to some web editors and I don't know all of them yet.
>
> Thanks.
>
> -----
> Gaetan
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/5dd848d7/attachment.html>

From danielmicay at gmail.com  Tue Nov 19 01:17:51 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 04:17:51 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
Message-ID: <CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>

Is there any specific issue with the current tutorial section on
boxes? It mentions every case where owned boxes are useful.

http://static.rust-lang.org/doc/master/tutorial.html#boxes

I keep hearing that it should be better, but have yet to see any hints
on where it falls short. It's not going to change if no one can point
out where it confuses them.

I do want to rewrite it in a less boring style by having it be an
introduction to these concepts by implementing a linked list, but I
won't be changing the *content* (at least of Boxes).

From danielmicay at gmail.com  Tue Nov 19 01:20:46 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 04:20:46 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
Message-ID: <CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>

On Tue, Nov 19, 2013 at 4:12 AM, Josh Matthews <josh at joshmatthews.net> wrote:
> http://static.rust-lang.org/doc/master/rust.html#keywords
>
> Cheers,
> Josh

That's missing `proc`, at the very least :). Perhaps it would be best
to look at `libsyntax/parse/token.rs`. Just ignore __LogLevel (it
existing is a bug) and you likely don't want to bother highlighting
non-functional reserved ones.

From corey at octayn.net  Tue Nov 19 01:22:47 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 19 Nov 2013 04:22:47 -0500
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
Message-ID: <CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>

On Mon, Nov 18, 2013 at 6:25 PM, Gokcehan Kara <gokcehankara at gmail.com> wrote:
> 1) Implement a type under cursor functionality

rustfind (https://github.com/dobkeratops/rustfind) does this and more,
for crates that compile.

> Some more general questions are;
>
> - How feasible is this project with the current state of the compiler?
>

Not very, for the general case. If you want autocompletion as you
type, you currently need to have a fully-compilable crate. Otherwise,
parsing or typechecking or something else will fail and you won't be
able to get any results. rustc is currently very all-or-nothing.  But,
you can get useful information for completion out of an
already-compiling crate, though I'm not sure how much better it would
be than what etags already does.

> - How difficult would it be for a newbie (to both rustc and compilers)?
>

Very, since it would require reworking most of the compiler ;)

From gaetan at xeberon.net  Tue Nov 19 01:22:53 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:22:53 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
Message-ID: <CANK7tAG00hG+ou=6af+vYOpbUbPd-544zGyqUm0Gq08OQPVaxA@mail.gmail.com>

That was my point on another thread. I think it's best to have a top-bottom
approach, ie, decribe everything else BUT the language first (how crates
works, how to compile, how to test,...) and then introduce the memory
concepts, etc.

I think the technical writer is a full time job, how to present things
properly is not easy to do. He may have better way of introducing the
language. I tend to agree with the assertion that its not a level of
quality we can achieve with collaborating works, sadly.

-----
Gaetan



2013/11/19 Thad Guidry <thadguidry at gmail.com>

>
>> I tend to agree with this, think that a collaborative approach is
>> unlikely to produce a consistent and high quality tutorial. I don't want to
>> discourage anybody but my current opinion is that we should hire an
>> experienced technical writer to do this piece especially, with input from
>> the wider community. Where I think collaboration is more likely to produce
>> something nice is in a 'cookbook' style document, of which several people
>> have already worked on seperately. Also of course API docs and the
>> reference manual are places where individuals can plug in their own
>> sections without impacting the overall narrative flow.
>>
>>
> So I spent this evening going through the tutorial (.08).  As an outsider
> to Rust, I can tell you it does not fit any model of a tutorial, but
> instead is an elongated language reference broken down into feature
> sections.  Which is highly useful in its design, and does say "This
> tutorial assumes that the reader is already familiar with one or more
> languages in the C family. Understanding of pointers and general memory
> management techniques will help."  BUT...
>
> It was not until section 17, that I finally met with a simple program that
> could compile.  That was 2 1/2 hours later before I was able to DO
> SOMETHING.
>
> I would encourage the Mozilla team to hire a technical writer as Brian
> suggests, that would turn the tutorial upside down...
>
> Start with something fun and entertaining in under 10 or 20 lines of Rust,
> that would amuse and provide "hackability" to tweak and play with values,
> mutability, and seeing the stack pop itself (half the developers in the
> world, do not know or have to worry about "a stack"..but of course "should"
> in any decent systems language :-) ), and then introduce garbage
> collecting, etc.   Introduce compile-able examples from the start, and
> continue with working examples that actually produce errors and let the
> user come to grips with the syntax & compiler error output, while coaching
> them through fixing the errors, and learning the do's and don'ts of Rust's
> current best practices.  That would be a mighty fine tutorial and the
> makings of a book for Rust itself.
>
> 2 cents and a haircut and I wish the team tremendous success on finding a
> talented writer,
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/fa39f1d4/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 01:25:42 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:25:42 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
Message-ID: <CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>

I don't think there is any particular issue with the tutorial, but we need
more "recipes" on how to handle typical situations.



-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> Is there any specific issue with the current tutorial section on
> boxes? It mentions every case where owned boxes are useful.
>
> http://static.rust-lang.org/doc/master/tutorial.html#boxes
>
> I keep hearing that it should be better, but have yet to see any hints
> on where it falls short. It's not going to change if no one can point
> out where it confuses them.
>
> I do want to rewrite it in a less boring style by having it be an
> introduction to these concepts by implementing a linked list, but I
> won't be changing the *content* (at least of Boxes).
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/0901edc9/attachment.html>

From valentin.gosu at gmail.com  Tue Nov 19 01:30:35 2013
From: valentin.gosu at gmail.com (Valentin Gosu)
Date: Tue, 19 Nov 2013 11:30:35 +0200
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
Message-ID: <CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>

On 19 November 2013 11:20, Daniel Micay <danielmicay at gmail.com> wrote:

> On Tue, Nov 19, 2013 at 4:12 AM, Josh Matthews <josh at joshmatthews.net>
> wrote:
> > http://static.rust-lang.org/doc/master/rust.html#keywords
> >
> > Cheers,
> > Josh
>
> That's missing `proc`, at the very least :). Perhaps it would be best
> to look at `libsyntax/parse/token.rs`. Just ignore __LogLevel (it
> existing is a bug) and you likely don't want to bother highlighting
> non-functional reserved ones.
>

Also, it seems none of the docs have been updated for with the changing of
loop -> continue
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/56f639d8/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 01:30:46 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:30:46 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
Message-ID: <CANK7tAHBfDpee9sPhS9m3qVexz=bqQUZWAyF1F0c+hkFfC0Rcw@mail.gmail.com>

can you give a little review?
https://github.com/Stibbons/crayon-syntax-rust

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 4:12 AM, Josh Matthews <josh at joshmatthews.net>
> wrote:
> > http://static.rust-lang.org/doc/master/rust.html#keywords
> >
> > Cheers,
> > Josh
>
> That's missing `proc`, at the very least :). Perhaps it would be best
> to look at `libsyntax/parse/token.rs`. Just ignore __LogLevel (it
> existing is a bug) and you likely don't want to bother highlighting
> non-functional reserved ones.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/35e8ddf3/attachment-0001.html>

From danielmicay at gmail.com  Tue Nov 19 01:35:37 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 04:35:37 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
Message-ID: <CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>

On Tue, Nov 19, 2013 at 4:25 AM, Gaetan <gaetan at xeberon.net> wrote:
> I don't think there is any particular issue with the tutorial, but we need
> more "recipes" on how to handle typical situations.

I'm specifically talking about the `Boxes` section in the tutorial and
not the whole picture. I keep hearing that the coverage of `~` it's
confusing - so can someone elaborate?

Rewriting the coverage of boxes and references by walking through the
implementation of some data structures is something I'm willing to do,
but in my opinion that section is now quite good, other than being dry
and not presenting interesting code samples for the use cases it
describes.

From illissius at gmail.com  Tue Nov 19 01:37:13 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 19 Nov 2013 10:37:13 +0100
Subject: [rust-dev] Type system thoughts
In-Reply-To: <20131117010815.GF11552@Mr-Bennet>
References: <CAPNUp080nh-awbLmbJXZkzLpw0foD3+rMSJugtaT1MOvdAfKeA@mail.gmail.com>
	<20131117010815.GF11552@Mr-Bennet>
Message-ID: <CAPNUp08LD6iS2CH7S1qAuFiWmXN9a7X=X0zYqd3QjNXN6ZFfNQ@mail.gmail.com>

On Sun, Nov 17, 2013 at 2:08 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Fri, Nov 15, 2013 at 05:05:28PM +0100, G?bor Lehel wrote:
> > I have some ideas about typey things and I'm going to write them down. It
> > will be long.
>
> I haven't read this all yet, I just want to respond to the first few
> paragraphs. :)
>


Thanks!


> > It would be nice if `Trait1 + Trait2` were itself a trait, legal in the
> > same positions as any trait. This is already partly true: in trait bounds
> > on type parameters and super-traits of traits. Where it's not true is
> trait
> > objects, e.g. `~(ToStr + Send)`. Having this could remove the need for
> the
> > current `~Trait:OtherTraits` special syntax.
>
> It's plausible to imagine, though I wouldn't phrase it that "Trait1+Trait2"
> is a trait, but rather a form of generalized object types. Today object
> types have the form `~Trait` and these generalized object types would
> have the form `~(Trait1+...+TraitN)`. Probably their size would be
> N+1 words to account for the extra vtables, which would make it trival
> to support the (natual) subtyping relation of the form
>
>     ~(Trait1+Trait2) <: ~Trait1
>     ~(Trait1+Trait2) <: ~Trait2
>
> You can sort of do something similar today with
>
>     trait Trait3 : Trait1 + Trait 2 { }
>     impl<T:Trait1+Trait2> Trait3 for T { }
>

Interesting. Why would (or should) these two have different
representations? Couldn't we think of `+` as a type constructor, that takes
two traits as arguments and makes a trait?

In the same way that

    type MyThing = (int, f64);

    struct MyThing { a: (int, f64) }

will both have the same representation, couldn't we have `~(Trait1+Trait2)`
be represented just the same as `~Trait3` from the example above, so in a
sense `Trait3` is nothing more than a newtype of `Trait1+Trait2`?

(Couldn't/wouldn't/shouldn't `~Trait3` also be a subtype of `~Trait1` and
`~Trait2`?)

Note that my intuitions here are informed by having done much of the same
things in Haskell with `ConstraintKinds`. For instance, here is Rust's `+`,
but called `:&:`:

http://hackage.haskell.org/package/exists-0.2/docs/Control-Constraint-Combine.html

(And `Exists` in the same package is quite close to Rust's object types.)

But not everything translates directly, because for instance, Haskell
doesn't have subtyping. (Or at least, not in this way -- polymorphic types
with (sub)constraints are in effect a different form of it.)



>
> Note that the current syntax `~Trait:Bounds` is intentionally limited
> in that the traits that can appear in `Bounds` do not offer methods
> but rather give information about the kind of data that the object
> receiver consists of.
>

I know. What I'm trying to explore is whether generalizing the meaning of
`+` might not (alongside being useful generally) remove the need for this
special casing. (My wondering about lifetimes is in a similar vein.)


>
> > I wonder whether lifetimes could also be interpreted as traits, with the
> > meaning: "[object of type implementing lifetime-trait] does not outlive
> > [the given lifetime]". This is an honest wondering: I'm not sure if it
> > makes sense. If it does make sense, it would fit in perfectly with the
> fact
> > that 'static is already a trait. Together with the above, it might also
> > allow a solution for capturing borrowed data in a trait object: you could
> > write `~(Trait + 'a)`.
>
> I don't think of `'static` as a trait, though it is currently
> implemented that way for historical reasons that will hopefully soon
> be eased. Rather, type parameters can have a *lifetime bound*, which
> indicates the minimum lifetime that they can exist for. `'static` is
> just a special case of this.  This might be (for all intents and
> purposes) what you meant.


Which is a worthwhile question. :-)

I currently have two overlapping interpretations of lifetimes:

 1. The intuitive version, where lifetime parameters on borrowed pointers
and structs have the meaning "this object does not outlive the given
lifetime";

 2. By relating them to the universally quantified type variable of
Haskell's `ST` monad, which seems very close to if not precisely the same
thing: in both cases, objects whose type is tagged with a given
(lifetime/type variable) can't "escape" the given computation.

I can make sense of the "lifetime bounds" on type parameters which you
describe in terms of the first, because it makes sense intuitively, but not
the second. How does a universally quantified type variable end up behaving
in any way, shape, or form like a type class?

In particular, one should be able to do
> `~Trait:'a`, which is interpreted as:
>
>     a pointer to some type T which implements the trait `Trait`
>     and which contains data valid for at least the lifetime 'a
>

Again, in part I'm trying to explore whether the need for this `:` syntax
could be obviated. But for this half of it, in larger part I'm just trying
to understand things.


>
>
> Niko
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/db168f5d/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 01:51:54 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 10:51:54 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
Message-ID: <CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>

In the french presentation for rust 0.8 [1], the author gives the analogy
with C++ semantics
- ~ is a bit like unique_ptr
- @ is an enhanced shared_ptr<T>
- borrowed pointer works like C++ reference

and I think it was very helpful to better understand them. I don't know if
it is true or now, but this comparison helps a lot understanding the
concepts.You can present them like this, and after, add more precision, and
difference with the C++ counter parts.

A tutorial to make would be "Rust for C++ programmer" :)


[1] http://linuxfr.org/news/presentation-de-rust-0-8

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 4:25 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I don't think there is any particular issue with the tutorial, but we
> need
> > more "recipes" on how to handle typical situations.
>
> I'm specifically talking about the `Boxes` section in the tutorial and
> not the whole picture. I keep hearing that the coverage of `~` it's
> confusing - so can someone elaborate?
>
> Rewriting the coverage of boxes and references by walking through the
> implementation of some data structures is something I'm willing to do,
> but in my opinion that section is now quite good, other than being dry
> and not presenting interesting code samples for the use cases it
> describes.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/939f4fc4/attachment.html>

From dbau.pp at gmail.com  Tue Nov 19 01:57:18 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Tue, 19 Nov 2013 20:57:18 +1100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>	<52829E45.4030405@mozilla.com>	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>	<528AB058.2010706@mozilla.com>	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>	<528AC00B.1000909@mozilla.com>	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>	<528AE665.3010000@mozilla.com>	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
Message-ID: <528B35FE.90707@gmail.com>

On 19/11/13 20:51, Gaetan wrote:
> In the french presentation for rust 0.8 [1], the author gives the 
> analogy with C++ semantics
> - ~ is a bit like unique_ptr
> - @ is an enhanced shared_ptr<T>
> - borrowed pointer works like C++ reference
>
> and I think it was very helpful to better understand them. I don't 
> know if it is true or now, but this comparison helps a lot 
> understanding the concepts.You can present them like this, and after, 
> add more precision, and difference with the C++ counter parts.
>
> A tutorial to make would be "Rust for C++ programmer" :)

Something like that already exists: 
https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers


Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/9aca7011/attachment-0001.html>

From danielmicay at gmail.com  Tue Nov 19 01:57:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 04:57:58 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
Message-ID: <CA+DvKQKzhfXp=5=+mQ49VA0GJnxNM42apvst_ztvXtyE86v7Mw@mail.gmail.com>

On Tue, Nov 19, 2013 at 4:51 AM, Gaetan <gaetan at xeberon.net> wrote:
> In the french presentation for rust 0.8 [1], the author gives the analogy
> with C++ semantics
> - ~ is a bit like unique_ptr
> - @ is an enhanced shared_ptr<T>
> - borrowed pointer works like C++ reference
>
> and I think it was very helpful to better understand them. I don't know if
> it is true or now, but this comparison helps a lot understanding the
> concepts.You can present them like this, and after, add more precision, and
> difference with the C++ counter parts.
>
> A tutorial to make would be "Rust for C++ programmer" :)
>
>
> [1] http://linuxfr.org/news/presentation-de-rust-0-8
>
> -----
> Gaetan

I wrote a reference for C++ programmers on the wiki some time ago.
Rust is very easy to approach as if you have a solid grasp of C++11 so
I don't think it's an important area to work on.

A C++ programmer already has a thorough understanding of the
ownership/lifetime concepts in Rust and the trait system will be
familiar because C++ has type traits + enable_if and implicit type
"concepts" that aren't formalized in the language yet.

https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers

From illissius at gmail.com  Tue Nov 19 02:18:07 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Tue, 19 Nov 2013 11:18:07 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
Message-ID: <CAPNUp08ggBJBgP52VrXxPTb6Z+urdoDCYC3PeKewfcpavcZi_g@mail.gmail.com>

In case this helps, I recently noticed that the sigils correspond to
possessive pronouns:

    '~' => "my",
    '&' => "their",
    '@' => "our"

Of course, `@` might be going away, but `Rc<>`, `Gc<>`, and so forth all
(will) have the same intuitive content, only different representations
(among other properties). Similarly `~Foo` and plain `Foo` both mean "my",
while having differences in other areas, in which case yeah, telling you
that `Foo` is stored in-place while `~Foo` is stored on the heap doesn't
help you if you don't know what heap allocation is about. But maybe this is
something.


On Tue, Nov 19, 2013 at 10:12 AM, Jordi Boggiano <j.boggiano at seld.be> wrote:

> On Tue, Nov 19, 2013 at 5:17 AM, Patrick Walton <pcwalton at mozilla.com>
> wrote:
> > I've observed a lot of beginning Rust programmers treat the language as
> "add
> > sigils until it works". (I have specific examples but don't want to name
> > people here; however, feel free to contact me privately if you're
> curious.)
>
> I feel like I have to out myself as one of the idiot newcomers that do
> this, just for the sake of the discussion. I have no systems language
> background and frankly never had to consider the difference between
> the heap or the stack in the past 10-some years of writing code.
>
> I don't really think having new vs ~ would help me avoid this problem.
> The issue I believe is that the language looks understandable enough
> for the average joe used to higher level web languages (php, python,
> ruby). That's a great thing of course, that I can just jump in and
> mostly grasp what's going on, while past attempts at C++ tinkering
> quickly ended in tears. It also means that you have lots of people
> that come in and are capable of getting stuff to compile but won't
> necessarily understand the small print. Often there is an alternative
> to pooping sigils all over the code, but if you don't understand the
> concepts behind it it's hard to reason about what those alternatives
> could be.
>
> I think I'm getting better with this over time, and the rust libraries
> also get more usable and consistent leading to less ~ insanity, but
> one thing that would have helped early on is a good warning in the
> docs about this, and a good explanation of what the hell is going on
> (not one geared towards C++ devs using lingo that only low level devs
> are familiar with).
>
> I realize it's no easy task, and that arguably I should probably just
> read a book, but at the same time it's an amazing feat I think that
> the language is so accessible while remaining at such a low level, so
> if we manage to improve the onboarding process it would probably be
> very beneficial. There are tons of web devs that are interested in
> doing things faster/lower level - if only for fun. Maybe it's worth
> having a chapter for them in the docs. I'd happily help review that
> and point out unclear things :)
>
> Cheers
>
> --
> Jordi Boggiano
> @seldaek - http://nelm.io/jordi
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/76fa1577/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 02:56:08 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 11:56:08 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CAPNUp08ggBJBgP52VrXxPTb6Z+urdoDCYC3PeKewfcpavcZi_g@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CAPNUp08ggBJBgP52VrXxPTb6Z+urdoDCYC3PeKewfcpavcZi_g@mail.gmail.com>
Message-ID: <CANK7tAH-qiqkdnGGmNG0koDvisoS5LvtT8ZpAq5JpSBcN76RUg@mail.gmail.com>

Can I advise to have a certain constitency in the semantics?

Not having ~foo, *foo, Rc<>, Gc<>.

I would rather prefere having

  ~foo *foo &foo @foo

of

  Something<>foo, other<>foo, Rc<> foo

By the way, I like pretty much your pronoums thing, this help understanding
:)

-----
Gaetan



2013/11/19 G?bor Lehel <illissius at gmail.com>

> In case this helps, I recently noticed that the sigils correspond to
> possessive pronouns:
>
>     '~' => "my",
>     '&' => "their",
>     '@' => "our"
>
> Of course, `@` might be going away, but `Rc<>`, `Gc<>`, and so forth all
> (will) have the same intuitive content, only different representations
> (among other properties). Similarly `~Foo` and plain `Foo` both mean "my",
> while having differences in other areas, in which case yeah, telling you
> that `Foo` is stored in-place while `~Foo` is stored on the heap doesn't
> help you if you don't know what heap allocation is about. But maybe this is
> something.
>
>
> On Tue, Nov 19, 2013 at 10:12 AM, Jordi Boggiano <j.boggiano at seld.be>wrote:
>
>> On Tue, Nov 19, 2013 at 5:17 AM, Patrick Walton <pcwalton at mozilla.com>
>> wrote:
>> > I've observed a lot of beginning Rust programmers treat the language as
>> "add
>> > sigils until it works". (I have specific examples but don't want to name
>> > people here; however, feel free to contact me privately if you're
>> curious.)
>>
>> I feel like I have to out myself as one of the idiot newcomers that do
>> this, just for the sake of the discussion. I have no systems language
>> background and frankly never had to consider the difference between
>> the heap or the stack in the past 10-some years of writing code.
>>
>> I don't really think having new vs ~ would help me avoid this problem.
>> The issue I believe is that the language looks understandable enough
>> for the average joe used to higher level web languages (php, python,
>> ruby). That's a great thing of course, that I can just jump in and
>> mostly grasp what's going on, while past attempts at C++ tinkering
>> quickly ended in tears. It also means that you have lots of people
>> that come in and are capable of getting stuff to compile but won't
>> necessarily understand the small print. Often there is an alternative
>> to pooping sigils all over the code, but if you don't understand the
>> concepts behind it it's hard to reason about what those alternatives
>> could be.
>>
>> I think I'm getting better with this over time, and the rust libraries
>> also get more usable and consistent leading to less ~ insanity, but
>> one thing that would have helped early on is a good warning in the
>> docs about this, and a good explanation of what the hell is going on
>> (not one geared towards C++ devs using lingo that only low level devs
>> are familiar with).
>>
>> I realize it's no easy task, and that arguably I should probably just
>> read a book, but at the same time it's an amazing feat I think that
>> the language is so accessible while remaining at such a low level, so
>> if we manage to improve the onboarding process it would probably be
>> very beneficial. There are tons of web devs that are interested in
>> doing things faster/lower level - if only for fun. Maybe it's worth
>> having a chapter for them in the docs. I'd happily help review that
>> and point out unclear things :)
>>
>> Cheers
>>
>> --
>> Jordi Boggiano
>> @seldaek - http://nelm.io/jordi
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/d309c516/attachment-0001.html>

From denis.spir at gmail.com  Tue Nov 19 03:00:32 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 12:00:32 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
Message-ID: <528B44D0.6080401@gmail.com>

On 11/19/2013 10:30 AM, Valentin Gosu wrote:
> Also, it seems none of the docs have been updated for with the changing of
> loop -> continue

Oh, has this changed? (I've just updated my editor's list of keywords to include 
"loop".)

Denis

From danielmicay at gmail.com  Tue Nov 19 03:08:43 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 06:08:43 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAH-qiqkdnGGmNG0koDvisoS5LvtT8ZpAq5JpSBcN76RUg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CAPNUp08ggBJBgP52VrXxPTb6Z+urdoDCYC3PeKewfcpavcZi_g@mail.gmail.com>
	<CANK7tAH-qiqkdnGGmNG0koDvisoS5LvtT8ZpAq5JpSBcN76RUg@mail.gmail.com>
Message-ID: <CA+DvKQJ5kS=KcWJ1PnX-pCn0=xCzj4v_29FHQry2Jo3xZc=RFw@mail.gmail.com>

On Tue, Nov 19, 2013 at 5:56 AM, Gaetan <gaetan at xeberon.net> wrote:
> Can I advise to have a certain constitency in the semantics?
>
> Not having ~foo, *foo, Rc<>, Gc<>.
>
> I would rather prefere having
>
>   ~foo *foo &foo @foo
>
> of
>
>   Something<>foo, other<>foo, Rc<> foo
>
> By the way, I like pretty much your pronoums thing, this help understanding
> :)
>
> -----
> Gaetan

Containers and smart pointers are plain old generic data types, they
don't deserve special construction or type syntax at all in my
opinion. If there's something wrong with Rust's syntax for generics,
lets fix that.

I wouldn't mind not having `~T` in the language at all, but am not
really opposed to including it because there's no harm. Choosing to
special-case arbitrary non-trivial data structures like vectors and
reference counted boxes *is* harmful because alternatives should *not*
be second-class.

From danielmicay at gmail.com  Tue Nov 19 03:09:34 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 06:09:34 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528B44D0.6080401@gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
Message-ID: <CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>

On Tue, Nov 19, 2013 at 6:00 AM, spir <denis.spir at gmail.com> wrote:
> On 11/19/2013 10:30 AM, Valentin Gosu wrote:
>>
>> Also, it seems none of the docs have been updated for with the changing of
>> loop -> continue
>
>
> Oh, has this changed? (I've just updated my editor's list of keywords to
> include "loop".)
>
> Denis

The `loop` keyword still exists for the moment, but only for infinite
loops. I'd prefer removing it and just using `while true { ... }`.

From denis.spir at gmail.com  Tue Nov 19 03:13:22 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 12:13:22 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528AE665.3010000@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>	<52829E45.4030405@mozilla.com>	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>	<528AB058.2010706@mozilla.com>	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>	<528AC00B.1000909@mozilla.com>	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
Message-ID: <528B47D2.50807@gmail.com>

On 11/19/2013 05:17 AM, Patrick Walton wrote:
> On 11/18/13 7:41 PM, Kevin Ballard wrote:
>> Is that really why, or are you just  guessing? I'm assuming the real
>> reason is that people are used to languages where heap allocation is
>> common and stack allocation rare or nonexistant, and don't understand
>> why boxing everything is a bad idea. In other words, it's a problem that
>> a proper tutorial should be able to help with. I don't think changing
>> syntax is going to make much of a difference.
>
> I've observed a lot of beginning Rust programmers treat the language as "add
> sigils until it works". (I have specific examples but don't want to name people
> here; however, feel free to contact me privately if you're curious.) They end up
> with slow programs and frustrated with Rust, wondering why they had to fight the
> compiler if they seemingly didn't gain any performance from it.
>
> I think a fair amount of it is that the sigils don't visually convey enough
> information to the programmer; they feel like something that you just have to
> add to make the compiler happy. A sigil in Rust's expression grammar as it
> stands represents an *action*, not a *qualifier* as it does in most other
> languages (e.g. `$foo` in PHP). Moreover, the `~` expression maps to one of the
> most expensive machine operations in the entire language semantics! It's thus
> important in my view to emphasize to newcomers that `~` *means* something; it is
> not just a qualifier you have to add to make the compiler happy. Indeed, if you
> are adding it just to make the compiler accept your code, there's something
> wrong--either the API you're using is inefficient or you're confused about the
> semantics!

I share this line of reasoning. However, why not take the opporunity to find a 
proper term (or abbreviation)? "New" says nothing about the "action" or its 
cost. Semantically, every expression yields a "new" value, doesn't it?
(My take as of now would be "mem", as a shortcut for "reserve some memory on the 
heap, where the following piece of data is to be stored; but I don't find it 
great myself. "Alloc" or "store" would be pretty good, but maybe too long.)
Some may think this is just bikeshed; I don't share this view: instead, 
terminology is extremely important, it is what conveys semantics, or should; 
ditto for "key signs". And key terms & signs remain until the end of eternity ;-).

Denis

From denis.spir at gmail.com  Tue Nov 19 03:19:06 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 12:19:06 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
Message-ID: <528B492A.60002@gmail.com>

On 11/19/2013 12:09 PM, Daniel Micay wrote:
> The `loop` keyword still exists for the moment, but only for infinite
> loops. I'd prefer removing it and just using `while true { ... }`.

My view on conditionned loop is something like:

loop [while cond] {
     ...
     [continue if cond]
     ...
     [break if cond]
     ...
} [until cond]

An infinite loop is just when there is neither start, nore end condition.

Or replace "loop" with "do" (only for brevity), "continue" with "next" or "up", 
"break" with "exit" or "out" (the latter 2 for clarity).

Denis

From denis.spir at gmail.com  Tue Nov 19 03:21:41 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 12:21:41 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>	<52829E45.4030405@mozilla.com>	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>	<528AB058.2010706@mozilla.com>	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>	<528AC00B.1000909@mozilla.com>	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
Message-ID: <528B49C5.4000802@gmail.com>

On 11/19/2013 10:12 AM, Jordi Boggiano wrote:
> Often there is an alternative
> to pooping sigils all over the code, but if you don't understand the
> concepts behind it it's hard to reason about what those alternatives
> could be.

+++

This is what I'm asking for about pointer variety and memory management in Rust. 
What does this all mean? Semantics, please ;-) (I mean human semantics, no 
machine operations)

Denis

From gaetan at xeberon.net  Tue Nov 19 03:42:34 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 12:42:34 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528B492A.60002@gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B492A.60002@gmail.com>
Message-ID: <CANK7tAEoNti43CWmqyTEoyNuATZgTYk5oTamC_rvS3Lau5gXhQ@mail.gmail.com>

I d prefere letting do launch tasks and don t add confusion.

Break and continue are consistent with other langages so i would keep them.
 Le 19 nov. 2013 12:19, "spir" <denis.spir at gmail.com> a ?crit :

> On 11/19/2013 12:09 PM, Daniel Micay wrote:
>
>> The `loop` keyword still exists for the moment, but only for infinite
>> loops. I'd prefer removing it and just using `while true { ... }`.
>>
>
> My view on conditionned loop is something like:
>
> loop [while cond] {
>     ...
>     [continue if cond]
>     ...
>     [break if cond]
>     ...
> } [until cond]
>
> An infinite loop is just when there is neither start, nore end condition.
>
> Or replace "loop" with "do" (only for brevity), "continue" with "next" or
> "up", "break" with "exit" or "out" (the latter 2 for clarity).
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/4a987fe5/attachment-0001.html>

From denis.spir at gmail.com  Tue Nov 19 03:45:54 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 12:45:54 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>	<52829E45.4030405@mozilla.com>	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>	<528AB058.2010706@mozilla.com>	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>	<528AC00B.1000909@mozilla.com>	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>	<528AE665.3010000@mozilla.com>	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
Message-ID: <528B4F72.1070608@gmail.com>

On 11/19/2013 10:51 AM, Gaetan wrote:
> In the french presentation for rust 0.8 [1], the author gives the analogy
> with C++ semantics
> - ~ is a bit like unique_ptr
> - @ is an enhanced shared_ptr<T>
> - borrowed pointer works like C++ reference
>
> and I think it was very helpful to better understand them. I don't know if
> it is true or now, but this comparison helps a lot understanding the
> concepts.You can present them like this, and after, add more precision, and
> difference with the C++ counter parts.
>
> A tutorial to make would be "Rust for C++ programmer" :)
>
>
> [1] http://linuxfr.org/news/presentation-de-rust-0-8

This helped me too, even if I'm not a C++ programmer (can only read). However, 
it is still not enough to understand the meaning of each of those pointer 
varieties, imo (at least, _i_ still don't get it). What semantic kinds of 
pointed data should go to each variety? why? I would help at once improving the 
tutorial if I did understand.

@Daniel: I would answer your questions if I did understand the *logic* of Rust's 
pointers and memory management. The tutorial, in my view, should precisely help 
on this. Instead, it tells us about machine-side issues without meaning (which 
are important and we need to know, but don't help in understanding). What is the 
semantic counter-part of all this? Why does it exist?

The logic here is hidden or difficult. As a comparison, we don't need tons of 
explanations to understand the differences between a sequential collection 
(array, list) and, say, a set. The logic is nearly obvious, we easily get why 
both kinds exist. And in fact, the machine-side, implementation counterpart, 
while important, comes after, once we understand the meaning; then we get to 
know the price one has to pay for quick, direct access of given items, as 
opposed to access by index.

Denis

From danielmicay at gmail.com  Tue Nov 19 03:51:19 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 06:51:19 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528B4F72.1070608@gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
Message-ID: <CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>

On Tue, Nov 19, 2013 at 6:45 AM, spir <denis.spir at gmail.com> wrote:>
>
> This helped me too, even if I'm not a C++ programmer (can only read).
> However, it is still not enough to understand the meaning of each of those
> pointer varieties, imo (at least, _i_ still don't get it). What semantic
> kinds of pointed data should go to each variety? why? I would help at once
> improving the tutorial if I did understand.
>
> @Daniel: I would answer your questions if I did understand the *logic* of
> Rust's pointers and memory management. The tutorial, in my view, should
> precisely help on this. Instead, it tells us about machine-side issues
> without meaning (which are important and we need to know, but don't help in
> understanding). What is the semantic counter-part of all this? Why does it
> exist?
>
> The logic here is hidden or difficult. As a comparison, we don't need tons
> of explanations to understand the differences between a sequential
> collection (array, list) and, say, a set. The logic is nearly obvious, we
> easily get why both kinds exist. And in fact, the machine-side,
> implementation counterpart, while important, comes after, once we understand
> the meaning; then we get to know the price one has to pay for quick, direct
> access of given items, as opposed to access by index.
>
> Denis

So in your opinion, what's wrong with the `Boxes` section?

http://static.rust-lang.org/doc/master/tutorial.html#boxes

I happen to think it does a pretty good job of explaining why `~` is
required for recursive types, which is almost the only use case for it
from a purely semantic perspective (not worrying about performance).

From danielmicay at gmail.com  Tue Nov 19 03:53:21 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 06:53:21 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CANK7tAEoNti43CWmqyTEoyNuATZgTYk5oTamC_rvS3Lau5gXhQ@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B492A.60002@gmail.com>
	<CANK7tAEoNti43CWmqyTEoyNuATZgTYk5oTamC_rvS3Lau5gXhQ@mail.gmail.com>
Message-ID: <CA+DvKQL_1w7Jnxk9J8Uz8=11aSRv0PSKS1a4P+3MPFQVCZ7=CQ@mail.gmail.com>

On Tue, Nov 19, 2013 at 6:42 AM, Gaetan <gaetan at xeberon.net> wrote:
> I d prefere letting do launch tasks and don t add confusion.

Tasks are part of the standard library, and don't have any presence at
a language level.

From gaetan at xeberon.net  Tue Nov 19 04:02:36 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:02:36 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAHVFbsqQhh4yUUR-9VHHW9s5R9ZCE4RteOXS8i2qRg0Hw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<528B49C5.4000802@gmail.com>
	<CANK7tAHVFbsqQhh4yUUR-9VHHW9s5R9ZCE4RteOXS8i2qRg0Hw@mail.gmail.com>
Message-ID: <CANK7tAFv8RL5TwPUVeAmSAuprxzaHT5ZByM8iGTSXw+PYdMPdA@mail.gmail.com>

+1 semantics is so important

>
> Le 19 nov. 2013 12:22, "spir" <denis.spir at gmail.com> a ?crit :
>
>> On 11/19/2013 10:12 AM, Jordi Boggiano wrote:
>>>
>>> Often there is an alternative
>>> to pooping sigils all over the code, but if you don't understand the
>>> concepts behind it it's hard to reason about what those alternatives
>>> could be.
>>
>>
>> +++
>>
>> This is what I'm asking for about pointer variety and memory management
in Rust. What does this all mean? Semantics, please ;-) (I mean human
semantics, no machine operations)
>>
>> Denis
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/7ca96ada/attachment.html>

From d.glazman at partner.samsung.com  Tue Nov 19 04:27:09 2013
From: d.glazman at partner.samsung.com (Daniel Glazman)
Date: Tue, 19 Nov 2013 13:27:09 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528AE665.3010000@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
Message-ID: <528B591D.7080601@partner.samsung.com>

On 19/11/13 05:17, Patrick Walton wrote:

> I've observed a lot of beginning Rust programmers treat the language as
> "add sigils until it works". (I have specific examples but don't want to
> name people here; however, feel free to contact me privately if you're
> curious.) They end up with slow programs and frustrated with Rust,
> wondering why they had to fight the compiler if they seemingly didn't
> gain any performance from it.
> 
> I think a fair amount of it is that the sigils don't visually convey
> enough information to the programmer; they feel like something that you
> just have to add to make the compiler happy. A sigil in Rust's
> expression grammar as it stands represents an *action*, not a
> *qualifier* as it does in most other languages (e.g. `$foo` in PHP).
> Moreover, the `~` expression maps to one of the most expensive machine
> operations in the entire language semantics! It's thus important in my
> view to emphasize to newcomers that `~` *means* something; it is not
> just a qualifier you have to add to make the compiler happy. Indeed, if
> you are adding it just to make the compiler accept your code, there's
> something wrong--either the API you're using is inefficient or you're
> confused about the semantics!

I agree 10000% with what was said above.

</Daniel>

From gaetan at xeberon.net  Tue Nov 19 04:27:03 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:27:03 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
Message-ID: <CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>

"The most common use case for owned boxes is creating recursive data
structures like a binary search tree."

I don't think this is the most common use of owned boxes: string
management, ...

I don't think it a good idea to place "binary search tree" in a tutorial.
You don't do this every day :)

-----
Gaetan



2013/11/19 Gaetan <gaetan at xeberon.net>

> In the french presentation for rust 0.8 [1], the author gives the analogy
> with C++ semantics
> - ~ is a bit like unique_ptr
> - @ is an enhanced shared_ptr<T>
> - borrowed pointer works like C++ reference
>
> and I think it was very helpful to better understand them. I don't know if
> it is true or now, but this comparison helps a lot understanding the
> concepts.You can present them like this, and after, add more precision, and
> difference with the C++ counter parts.
>
> A tutorial to make would be "Rust for C++ programmer" :)
>
>
> [1] http://linuxfr.org/news/presentation-de-rust-0-8
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Daniel Micay <danielmicay at gmail.com>
>
>> On Tue, Nov 19, 2013 at 4:25 AM, Gaetan <gaetan at xeberon.net> wrote:
>> > I don't think there is any particular issue with the tutorial, but we
>> need
>> > more "recipes" on how to handle typical situations.
>>
>> I'm specifically talking about the `Boxes` section in the tutorial and
>> not the whole picture. I keep hearing that the coverage of `~` it's
>> confusing - so can someone elaborate?
>>
>> Rewriting the coverage of boxes and references by walking through the
>> implementation of some data structures is something I'm willing to do,
>> but in my opinion that section is now quite good, other than being dry
>> and not presenting interesting code samples for the use cases it
>> describes.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/e4376c37/attachment-0001.html>

From d.glazman at partner.samsung.com  Tue Nov 19 04:27:50 2013
From: d.glazman at partner.samsung.com (Daniel Glazman)
Date: Tue, 19 Nov 2013 13:27:50 +0100
Subject: [rust-dev] Fwd: Please simplify the syntax for Great Justice
In-Reply-To: <528AC0B9.5050801@cantrip.org>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com> <528AC0B9.5050801@cantrip.org>
Message-ID: <528B5946.9060101@partner.samsung.com>

On 19/11/13 02:36, Nathan Myers wrote:

> "Rust is a general purpose language designed to make programming
> more fun for the serious programmer."
>  - nobody, yet.

Honestly, I don't really care about fun. What my company needs is more
in line with:

? Rust is a powerful, clean, easy-to-learn and easy-to-read general
purpose language designed for ?programming in the large? that could
replace c++ ?

</Daniel>


From danielmicay at gmail.com  Tue Nov 19 04:29:06 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 07:29:06 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
Message-ID: <CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>

On Tue, Nov 19, 2013 at 7:27 AM, Gaetan <gaetan at xeberon.net> wrote:
> "The most common use case for owned boxes is creating recursive data
> structures like a binary search tree."
>
> I don't think this is the most common use of owned boxes: string management,
> ...
>
> I don't think it a good idea to place "binary search tree" in a tutorial.
> You don't do this every day :)
>
> -----
> Gaetan

~str isn't an ~T, in the existing type system

From denis.spir at gmail.com  Tue Nov 19 04:35:50 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 19 Nov 2013 13:35:50 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
Message-ID: <528B5B26.6080305@gmail.com>

On 11/19/2013 12:51 PM, Daniel Micay wrote:
> So in your opinion, what's wrong with the `Boxes` section?
>
> http://static.rust-lang.org/doc/master/tutorial.html#boxes
>
> I happen to think it does a pretty good job of explaining why `~` is
> required for recursive types, which is almost the only use case for it
> from a purely semantic perspective (not worrying about performance).

If this is all true, that recursive structures are the main, "almost the only 
use case" of ~ pointers, then the tutorial is in my view rather ok on this 
point. But then, why does it seem there are ~ pointers in every corner of Rust 
code? Including numerous cases in the tutorial itself.

Also, how would we explain and term this meaning? "Indirection" is not good 
enough (for we introduce indirections for other reasons, if only to have 
variable-size content). I'd say "self-similarity" is the right term here, and 
self-explaining (see wikipedia if you are not familiar with the idea). This is, 
in fact, the actual idea commonly termed "recursivity" in programming (wrongly, 
in my view, but this is yet another terminological issue). A rule about ~ 
pointers thus may be:

    Whenever one needs self-similarity, use a ~ pointer.
    This lets the language store the element through the kind
    of indirection that permits a self-similar structure.

(I'm not happy of this formulation, neither, still obscure.)

however, other comments on ~ pointers (eg comparisons with C++ unique_ptr, notes 
that it means owned or "my") introduce ideas rather different from the one you 
suggest here, don't they? Say I manually create a kind of string or "fix-size" 
array:

struct String {
     n_bytes : uint,
     bytes   : ~[u8],
}

struct Array <Item> {
     n_items : uint,
     items   : ~[Item],
}

Is it wrong here to ~ point to bytes or items? that's what I'd do, anyway... If 
it is right, maybe the actual meaning of ~ is something like "proper content". 
Whenever a structure actually contains content which is actually proper to it, 
or more generally has (pointed) data participating to its description, then 
these contents or descriptive data should pointed with ~: because they belong / 
are proper to it.

struct ComplexVisualForm {
     shape : ~ Shape,
     style : ~ Style,
}

This matches my distinction between things and data (properly speaking). Data, 
even when pointed (for technological rather than semantic reasons), still belong 
to whatever they are part of. Data are never referenced (properly speaking), it 
makes no sense. Things instead exist by themselves, are always ref'ed, never 
copied (or moved), it makes no sense. If the reasoning above about ~ pointers is 
more or less correct (i doubt it is), then we have in Rust the proper kind of 
pointer to point to data, properly speaking, meaning information about things. 
Now, to reference things from multiple points of view, we need something else, 
proper refs or links, and they cannot be ordinary pointers (especially not 
GC'ed): we need true refs, independant from the data (while pointers hold their 
addresses).

Denis


From gaetan at xeberon.net  Tue Nov 19 04:40:38 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:40:38 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
Message-ID: <CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>

I think this is precisely one of the bigest issue, from a newbee point of
view. And I agree with spir on this point. It's not that important, but you
end up placing them everywhere "to make the compiler happy".

~str should be a ~T. If it is not, it should use another semantic.

However, I don't see where you explain this subtility in the tutorial,
didn't you added it recently?

PS: I'm french, I know pretty well that all subtilities (other words for
"exception to the general rules") my natural language has their own reason,
BUT if I wanted to redesign french, I would get rid of all these rules,
exceptions, rules in the exceptions. And exceptions in the rules of
exceptions...

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 7:27 AM, Gaetan <gaetan at xeberon.net> wrote:
> > "The most common use case for owned boxes is creating recursive data
> > structures like a binary search tree."
> >
> > I don't think this is the most common use of owned boxes: string
> management,
> > ...
> >
> > I don't think it a good idea to place "binary search tree" in a tutorial.
> > You don't do this every day :)
> >
> > -----
> > Gaetan
>
> ~str isn't an ~T, in the existing type system
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/29dd2d33/attachment.html>

From danielmicay at gmail.com  Tue Nov 19 04:43:42 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 07:43:42 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528B5B26.6080305@gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
Message-ID: <CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>

On Tue, Nov 19, 2013 at 7:35 AM, spir <denis.spir at gmail.com> wrote:
>
> If this is all true, that recursive structures are the main, "almost the
> only use case" of ~ pointers, then the tutorial is in my view rather ok on
> this point. But then, why does it seem there are ~ pointers in every corner
> of Rust code? Including numerous cases in the tutorial itself.
>
> Also, how would we explain and term this meaning? "Indirection" is not good
> enough (for we introduce indirections for other reasons, if only to have
> variable-size content). I'd say "self-similarity" is the right term here,
> and self-explaining (see wikipedia if you are not familiar with the idea).
> This is, in fact, the actual idea commonly termed "recursivity" in
> programming (wrongly, in my view, but this is yet another terminological
> issue). A rule about ~ pointers thus may be:
>
>    Whenever one needs self-similarity, use a ~ pointer.
>    This lets the language store the element through the kind
>    of indirection that permits a self-similar structure.
>
> (I'm not happy of this formulation, neither, still obscure.)
>
> however, other comments on ~ pointers (eg comparisons with C++ unique_ptr,
> notes that it means owned or "my") introduce ideas rather different from the
> one you suggest here, don't they? Say I manually create a kind of string or
> "fix-size" array:
>
> struct String {
>     n_bytes : uint,
>     bytes   : ~[u8],
> }
>
> struct Array <Item> {
>     n_items : uint,
>     items   : ~[Item],
> }

The expression ~([1, 2, 3]) has a different type than the expression
~[1, 2, 3]. The former is an owned box containing a fixed size array
(~[int, ..3]) and the latter is a dynamic array (~[int]).

The ~str and ~[T] types are *not* owned boxes in the current type
system. There has been a proposal for dynamically sized types which
would make them owned boxes, but I only like it as the path forwards
for traits/closures and not vectors.

I don't think dynamic arrays/strings belong as built-in types
hard-wired into the language, especially with a confusing syntax like
this. They should be treated as other containers are.

In what I think is a sane system, dynamic arrays would be a library
`Vec<T>` type just like we have `HashMap<K, V>` and will have other
vector types like `Rope<T>` or `SmallVec<T, N>`.

> Is it wrong here to ~ point to bytes or items? that's what I'd do, anyway...
> If it is right, maybe the actual meaning of ~ is something like "proper
> content". Whenever a structure actually contains content which is actually
> proper to it, or more generally has (pointed) data participating to its
> description, then these contents or descriptive data should pointed with ~:
> because they belong / are proper to it.
>
> struct ComplexVisualForm {
>     shape : ~ Shape,
>     style : ~ Style,
> }

It doesn't make sense to use ~T over T without a reason to need a
pointer-size value. It offers nothing in terms of semantics. It uses
indirection to obtain pointer-size, and adds a destructor (a strict
loss in terms of functionality). If you're not writing a recursive
data structure or using dynamic dispatch via a trait object, you don't
need it.

> This matches my distinction between things and data (properly speaking).
> Data, even when pointed (for technological rather than semantic reasons),
> still belong to whatever they are part of. Data are never referenced
> (properly speaking), it makes no sense. Things instead exist by themselves,
> are always ref'ed, never copied (or moved), it makes no sense. If the
> reasoning above about ~ pointers is more or less correct (i doubt it is),
> then we have in Rust the proper kind of pointer to point to data, properly
> speaking, meaning information about things. Now, to reference things from
> multiple points of view, we need something else, proper refs or links, and
> they cannot be ordinary pointers (especially not GC'ed): we need true refs,
> independant from the data (while pointers hold their addresses).
>
> Denis
>

~T and T both have value semantics. Neither has by-reference
semantics, as ~T is always the unique owner of the contained value.

From danielmicay at gmail.com  Tue Nov 19 04:46:55 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 07:46:55 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
Message-ID: <CA+DvKQKT1er3wmzEt6+76Q=Z+o0P99S42Wz4imsPUFJrdRv5rg@mail.gmail.com>

On Tue, Nov 19, 2013 at 7:40 AM, Gaetan <gaetan at xeberon.net> wrote:
> I think this is precisely one of the bigest issue, from a newbee point of
> view. And I agree with spir on this point. It's not that important, but you
> end up placing them everywhere "to make the compiler happy".
>
> ~str should be a ~T. If it is not, it should use another semantic.
>
> However, I don't see where you explain this subtility in the tutorial,
> didn't you added it recently?
>
> PS: I'm french, I know pretty well that all subtilities (other words for
> "exception to the general rules") my natural language has their own reason,
> BUT if I wanted to redesign french, I would get rid of all these rules,
> exceptions, rules in the exceptions. And exceptions in the rules of
> exceptions...
>
> -----
> Gaetan

I don't want to have `~str` and `~[T]` in the language, so I'm not
really motivated to spend time trying to paper over the confusion
caused by them. I doubt most users of Rust realize that ~([1, 2, 3])
and ~[1, 2, 3] have different types, and dynamically sized types are
not going to fix this.

From gaetan at xeberon.net  Tue Nov 19 04:49:08 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:49:08 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CA+DvKQL_1w7Jnxk9J8Uz8=11aSRv0PSKS1a4P+3MPFQVCZ7=CQ@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B492A.60002@gmail.com>
	<CANK7tAEoNti43CWmqyTEoyNuATZgTYk5oTamC_rvS3Lau5gXhQ@mail.gmail.com>
	<CA+DvKQL_1w7Jnxk9J8Uz8=11aSRv0PSKS1a4P+3MPFQVCZ7=CQ@mail.gmail.com>
Message-ID: <CANK7tAEzOgzYj0d7LKPnFFppHqotPY=k=x9Qn_6taB6D5ZqV5w@mail.gmail.com>

Sorry, I rephrase: "Let "do" spawn high level functions like "each" or
"spawn" and not confuse it with "loop" or "while".

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 6:42 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I d prefere letting do launch tasks and don t add confusion.
>
> Tasks are part of the standard library, and don't have any presence at
> a language level.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/bb9f9d70/attachment.html>

From danielmicay at gmail.com  Tue Nov 19 04:50:48 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 07:50:48 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CANK7tAEzOgzYj0d7LKPnFFppHqotPY=k=x9Qn_6taB6D5ZqV5w@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B492A.60002@gmail.com>
	<CANK7tAEoNti43CWmqyTEoyNuATZgTYk5oTamC_rvS3Lau5gXhQ@mail.gmail.com>
	<CA+DvKQL_1w7Jnxk9J8Uz8=11aSRv0PSKS1a4P+3MPFQVCZ7=CQ@mail.gmail.com>
	<CANK7tAEzOgzYj0d7LKPnFFppHqotPY=k=x9Qn_6taB6D5ZqV5w@mail.gmail.com>
Message-ID: <CA+DvKQKRRRzJsYp86EX9--HK70UCFAroBN4sFdeWJ0r2bK_57w@mail.gmail.com>

On Tue, Nov 19, 2013 at 7:49 AM, Gaetan <gaetan at xeberon.net> wrote:
> Sorry, I rephrase: "Let "do" spawn high level functions like "each" or
> "spawn" and not confuse it with "loop" or "while".
>
> -----
> Gaetan

Ah, my fault for taking that out of context. I should have read the
parent email :).

From gaetan at xeberon.net  Tue Nov 19 04:52:22 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:52:22 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQKT1er3wmzEt6+76Q=Z+o0P99S42Wz4imsPUFJrdRv5rg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
	<CA+DvKQKT1er3wmzEt6+76Q=Z+o0P99S42Wz4imsPUFJrdRv5rg@mail.gmail.com>
Message-ID: <CANK7tAFt9LvL+PdS2_j-NNs-9E8yYT-_VNg9CYVeKTVjQEWijw@mail.gmail.com>

I think it is one of the first thing to explain, actually...

Playing with strings, using the method in std or extra requires to
understand it. I wanted to use (and improve) extra::url and others (like
std::path,...) and... I was simply lost with all of these ~str... and
nothing in the manual or tutorial.

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 7:40 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I think this is precisely one of the bigest issue, from a newbee point of
> > view. And I agree with spir on this point. It's not that important, but
> you
> > end up placing them everywhere "to make the compiler happy".
> >
> > ~str should be a ~T. If it is not, it should use another semantic.
> >
> > However, I don't see where you explain this subtility in the tutorial,
> > didn't you added it recently?
> >
> > PS: I'm french, I know pretty well that all subtilities (other words for
> > "exception to the general rules") my natural language has their own
> reason,
> > BUT if I wanted to redesign french, I would get rid of all these rules,
> > exceptions, rules in the exceptions. And exceptions in the rules of
> > exceptions...
> >
> > -----
> > Gaetan
>
> I don't want to have `~str` and `~[T]` in the language, so I'm not
> really motivated to spend time trying to paper over the confusion
> caused by them. I doubt most users of Rust realize that ~([1, 2, 3])
> and ~[1, 2, 3] have different types, and dynamically sized types are
> not going to fix this.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/a3e21fa0/attachment.html>

From danielmicay at gmail.com  Tue Nov 19 04:55:08 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Tue, 19 Nov 2013 07:55:08 -0500
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAFt9LvL+PdS2_j-NNs-9E8yYT-_VNg9CYVeKTVjQEWijw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
	<CA+DvKQKT1er3wmzEt6+76Q=Z+o0P99S42Wz4imsPUFJrdRv5rg@mail.gmail.com>
	<CANK7tAFt9LvL+PdS2_j-NNs-9E8yYT-_VNg9CYVeKTVjQEWijw@mail.gmail.com>
Message-ID: <CA+DvKQ+KXFnvajqw13BvyeP9iGrf=2FjZx0EpHTc_h7cEqH5yA@mail.gmail.com>

On Tue, Nov 19, 2013 at 7:52 AM, Gaetan <gaetan at xeberon.net> wrote:
> I think it is one of the first thing to explain, actually...
>
> Playing with strings, using the method in std or extra requires to
> understand it. I wanted to use (and improve) extra::url and others (like
> std::path,...) and... I was simply lost with all of these ~str... and
> nothing in the manual or tutorial.
>
> -----
> Gaetan

It is covered, I rewrote the section on it recently:

http://static.rust-lang.org/doc/master/tutorial.html#vectors-and-strings

It doesn't go out of the way to explain that they're not owned boxes,
but I don't think it should. It's a confusing language wart and should
be fixed as far as I am concerned.

From gaetan at xeberon.net  Tue Nov 19 04:58:07 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:58:07 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQ+KXFnvajqw13BvyeP9iGrf=2FjZx0EpHTc_h7cEqH5yA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
	<CA+DvKQKT1er3wmzEt6+76Q=Z+o0P99S42Wz4imsPUFJrdRv5rg@mail.gmail.com>
	<CANK7tAFt9LvL+PdS2_j-NNs-9E8yYT-_VNg9CYVeKTVjQEWijw@mail.gmail.com>
	<CA+DvKQ+KXFnvajqw13BvyeP9iGrf=2FjZx0EpHTc_h7cEqH5yA@mail.gmail.com>
Message-ID: <CANK7tAFWE7s=KMm927Dfk=CGkSi28tjd9RmvYynfxe5OA+9tyw@mail.gmail.com>

Sorry, but it's not clear.

the only occurences of "~str" are in "Declaring and implementing traits"
section...
Maybe by adding more "string specific" examples would help...

And a special section one "why ~str is not a ~T" would be so useful!

-----
Gaetan



2013/11/19 Daniel Micay <danielmicay at gmail.com>

> On Tue, Nov 19, 2013 at 7:52 AM, Gaetan <gaetan at xeberon.net> wrote:
> > I think it is one of the first thing to explain, actually...
> >
> > Playing with strings, using the method in std or extra requires to
> > understand it. I wanted to use (and improve) extra::url and others (like
> > std::path,...) and... I was simply lost with all of these ~str... and
> > nothing in the manual or tutorial.
> >
> > -----
> > Gaetan
>
> It is covered, I rewrote the section on it recently:
>
> http://static.rust-lang.org/doc/master/tutorial.html#vectors-and-strings
>
> It doesn't go out of the way to explain that they're not owned boxes,
> but I don't think it should. It's a confusing language wart and should
> be fixed as far as I am concerned.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/646708ed/attachment-0001.html>

From gaetan at xeberon.net  Tue Nov 19 04:59:50 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 13:59:50 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
Message-ID: <CANK7tAFS-ZUcSuY4Uv8g4Lkxurt9a6k4Jt-Sr5BnUf6WDkv_HA@mail.gmail.com>

However, I want to highlight it is really appreciable that you, the rust
team, are so open to our question.

Just wanted to give you this feedback, I don't want to be held like the guy
who criticize the current work, I know very much that is could be very
annoying.

Just willing to help :)

-----
Gaetan



2013/11/19 Gaetan <gaetan at xeberon.net>

> I think this is precisely one of the bigest issue, from a newbee point of
> view. And I agree with spir on this point. It's not that important, but you
> end up placing them everywhere "to make the compiler happy".
>
> ~str should be a ~T. If it is not, it should use another semantic.
>
> However, I don't see where you explain this subtility in the tutorial,
> didn't you added it recently?
>
> PS: I'm french, I know pretty well that all subtilities (other words for
> "exception to the general rules") my natural language has their own reason,
> BUT if I wanted to redesign french, I would get rid of all these rules,
> exceptions, rules in the exceptions. And exceptions in the rules of
> exceptions...
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Daniel Micay <danielmicay at gmail.com>
>
>> On Tue, Nov 19, 2013 at 7:27 AM, Gaetan <gaetan at xeberon.net> wrote:
>> > "The most common use case for owned boxes is creating recursive data
>> > structures like a binary search tree."
>> >
>> > I don't think this is the most common use of owned boxes: string
>> management,
>> > ...
>> >
>> > I don't think it a good idea to place "binary search tree" in a
>> tutorial.
>> > You don't do this every day :)
>> >
>> > -----
>> > Gaetan
>>
>> ~str isn't an ~T, in the existing type system
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/11a776d1/attachment.html>

From philippe.delrieu at free.fr  Tue Nov 19 05:26:43 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 19 Nov 2013 14:26:43 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
Message-ID: <528B6713.2070308@free.fr>

Hello,

I would like to share my experience about the Rust doc and the tutorial. 
I've just started to learn Rust and I've decided to use it on a project 
I work on. Like everybody I read the Rust tutorial. It's not a really a 
tutorial for beginner but it do a good job in presenting Rust and its 
mains concept. I found other tutorial on the web and in my opinion what 
is missing the more is sample code. The Rust lib is huge and there is no 
code. In my project I have to use Json serialization. So I wanted to use 
the json lib in extra lib and I really spend some time to make a simple 
code works. I was very near to write my own lib. json.rs is a little 
complicated for a newbie. There are some test case at the end but it 
tests the lib and not what I want to do with it. For example there is no 
serialization of an object. I search the web and I found some old 
example (not compatible with the master lib) and no object serialization.

So what I think is that it would be great is to construct a repository 
of sample code of the Rust lib that show how to use the lib. I'm ok to 
write and maintain some sample like one on json. I think it would be 
great to host all these sample in the same repository and to have the 
same organization for all sample. The second reason tu use a share 
repository is that the sample has to be made in the spirit of Rust to 
help understand it. For that the sample must be checked and modified by 
more experienced rust developer. It's easier when the code is in a 
common repository.

P?ilippe

From gaetan at xeberon.net  Tue Nov 19 05:43:26 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 14:43:26 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <528B6713.2070308@free.fr>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
	<528B6713.2070308@free.fr>
Message-ID: <CANK7tAFST+Xdnsv0T+m5g-7HceSg5iknE=wQ5PDvtB+qeYcfyg@mail.gmail.com>

I think it's better to enhance the extra::json lib itself and write proper
module documentation, with samples, use case etc.
My reference is the QT documentation. You never open and samples or even
the QT source code, everything is in the module documentation.

-----
Gaetan



2013/11/19 Philippe Delrieu <philippe.delrieu at free.fr>

> Hello,
>
> I would like to share my experience about the Rust doc and the tutorial.
> I've just started to learn Rust and I've decided to use it on a project I
> work on. Like everybody I read the Rust tutorial. It's not a really a
> tutorial for beginner but it do a good job in presenting Rust and its mains
> concept. I found other tutorial on the web and in my opinion what is
> missing the more is sample code. The Rust lib is huge and there is no code.
> In my project I have to use Json serialization. So I wanted to use the json
> lib in extra lib and I really spend some time to make a simple code works.
> I was very near to write my own lib. json.rs is a little complicated for
> a newbie. There are some test case at the end but it tests the lib and not
> what I want to do with it. For example there is no serialization of an
> object. I search the web and I found some old example (not compatible with
> the master lib) and no object serialization.
>
> So what I think is that it would be great is to construct a repository of
> sample code of the Rust lib that show how to use the lib. I'm ok to write
> and maintain some sample like one on json. I think it would be great to
> host all these sample in the same repository and to have the same
> organization for all sample. The second reason tu use a share repository is
> that the sample has to be made in the spirit of Rust to help understand it.
> For that the sample must be checked and modified by more experienced rust
> developer. It's easier when the code is in a common repository.
>
> P?ilippe
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/24ab1a12/attachment.html>

From gaetan at xeberon.net  Tue Nov 19 05:48:59 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 14:48:59 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAFST+Xdnsv0T+m5g-7HceSg5iknE=wQ5PDvtB+qeYcfyg@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
	<528B6713.2070308@free.fr>
	<CANK7tAFST+Xdnsv0T+m5g-7HceSg5iknE=wQ5PDvtB+qeYcfyg@mail.gmail.com>
Message-ID: <CANK7tAFhZFoVHQ_ZMR84naVu-zHYYZMbXEDSN=NJQ3sYBb_GVQ@mail.gmail.com>

Also, what we set up in our scrum team is "targetted" doc stories inside
each sprint.

Let's say that over the next month, the objective is to improve a set of
module doc, ie, a list of very useful std or extra lib that is not properly
documented.
For instance, the next month we target on improving json or extra::path,
and enhance them until they become golden star level. And the next month or
sprint, we focus on other modules

It's easier to focus people like this that just telling "you can take
whichever module you want and improve them". It just work better, we
discovered.

-----
Gaetan



2013/11/19 Gaetan <gaetan at xeberon.net>

> I think it's better to enhance the extra::json lib itself and write proper
> module documentation, with samples, use case etc.
> My reference is the QT documentation. You never open and samples or even
> the QT source code, everything is in the module documentation.
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Philippe Delrieu <philippe.delrieu at free.fr>
>
>> Hello,
>>
>> I would like to share my experience about the Rust doc and the tutorial.
>> I've just started to learn Rust and I've decided to use it on a project I
>> work on. Like everybody I read the Rust tutorial. It's not a really a
>> tutorial for beginner but it do a good job in presenting Rust and its mains
>> concept. I found other tutorial on the web and in my opinion what is
>> missing the more is sample code. The Rust lib is huge and there is no code.
>> In my project I have to use Json serialization. So I wanted to use the json
>> lib in extra lib and I really spend some time to make a simple code works.
>> I was very near to write my own lib. json.rs is a little complicated for
>> a newbie. There are some test case at the end but it tests the lib and not
>> what I want to do with it. For example there is no serialization of an
>> object. I search the web and I found some old example (not compatible with
>> the master lib) and no object serialization.
>>
>> So what I think is that it would be great is to construct a repository of
>> sample code of the Rust lib that show how to use the lib. I'm ok to write
>> and maintain some sample like one on json. I think it would be great to
>> host all these sample in the same repository and to have the same
>> organization for all sample. The second reason tu use a share repository is
>> that the sample has to be made in the spirit of Rust to help understand it.
>> For that the sample must be checked and modified by more experienced rust
>> developer. It's easier when the code is in a common repository.
>>
>> P?ilippe
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/535806b4/attachment-0001.html>

From gaetan at xeberon.net  Tue Nov 19 06:13:13 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 15:13:13 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <528B6E7D.8020307@free.fr>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
	<528B6713.2070308@free.fr>
	<CANK7tAFST+Xdnsv0T+m5g-7HceSg5iknE=wQ5PDvtB+qeYcfyg@mail.gmail.com>
	<CANK7tAFhZFoVHQ_ZMR84naVu-zHYYZMbXEDSN=NJQ3sYBb_GVQ@mail.gmail.com>
	<528B6E7D.8020307@free.fr>
Message-ID: <CANK7tAFJhwCuDCc_46HR7d79AsB3OtFGwaKC3h+1psQKnKDv1w@mail.gmail.com>

I am willing to help also but i find it quite hard to setup the
environnement properly. Is these a tutorial for this point?
Le 19 nov. 2013 14:58, "Philippe Delrieu" <philippe.delrieu at free.fr> a
?crit :

>  I'am ok to add sample code in json.rs.
> how can I do?
> I think I will have other sample code for other lib in a few days. I'll
> wait that the lib is open to doc enhancement or I put it as it come and how
> can it be managed.
>
> Philippe
>
> Le 19/11/2013 14:48, Gaetan a ?crit :
>
> Also, what we set up in our scrum team is "targetted" doc stories inside
> each sprint.
>
>  Let's say that over the next month, the objective is to improve a set of
> module doc, ie, a list of very useful std or extra lib that is not properly
> documented.
> For instance, the next month we target on improving json or extra::path,
> and enhance them until they become golden star level. And the next month or
> sprint, we focus on other modules
>
>  It's easier to focus people like this that just telling "you can take
> whichever module you want and improve them". It just work better, we
> discovered.
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Gaetan <gaetan at xeberon.net>
>
>> I think it's better to enhance the extra::json lib itself and write
>> proper module documentation, with samples, use case etc.
>> My reference is the QT documentation. You never open and samples or even
>> the QT source code, everything is in the module documentation.
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/11/19 Philippe Delrieu <philippe.delrieu at free.fr>
>>
>>> Hello,
>>>
>>> I would like to share my experience about the Rust doc and the tutorial.
>>> I've just started to learn Rust and I've decided to use it on a project I
>>> work on. Like everybody I read the Rust tutorial. It's not a really a
>>> tutorial for beginner but it do a good job in presenting Rust and its mains
>>> concept. I found other tutorial on the web and in my opinion what is
>>> missing the more is sample code. The Rust lib is huge and there is no code.
>>> In my project I have to use Json serialization. So I wanted to use the json
>>> lib in extra lib and I really spend some time to make a simple code works.
>>> I was very near to write my own lib. json.rs is a little complicated
>>> for a newbie. There are some test case at the end but it tests the lib and
>>> not what I want to do with it. For example there is no serialization of an
>>> object. I search the web and I found some old example (not compatible with
>>> the master lib) and no object serialization.
>>>
>>> So what I think is that it would be great is to construct a repository
>>> of sample code of the Rust lib that show how to use the lib. I'm ok to
>>> write and maintain some sample like one on json. I think it would be great
>>> to host all these sample in the same repository and to have the same
>>> organization for all sample. The second reason tu use a share repository is
>>> that the sample has to be made in the spirit of Rust to help understand it.
>>> For that the sample must be checked and modified by more experienced rust
>>> developer. It's easier when the code is in a common repository.
>>>
>>> P?ilippe
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/9df0cecd/attachment.html>

From philippe.delrieu at free.fr  Tue Nov 19 06:14:00 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 19 Nov 2013 15:14:00 +0100
Subject: [rust-dev] Rust docs
In-Reply-To: <CANK7tAFhZFoVHQ_ZMR84naVu-zHYYZMbXEDSN=NJQ3sYBb_GVQ@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
	<528B6713.2070308@free.fr>
	<CANK7tAFST+Xdnsv0T+m5g-7HceSg5iknE=wQ5PDvtB+qeYcfyg@mail.gmail.com>
	<CANK7tAFhZFoVHQ_ZMR84naVu-zHYYZMbXEDSN=NJQ3sYBb_GVQ@mail.gmail.com>
Message-ID: <528B7228.5030803@free.fr>

I'am ok to add sample code in json.rs.
how can I do?
I think I will have other sample code for other lib in a few days. I'll 
wait that the lib is open to doc enhancement or I put it as it come and 
how can it be managed.

Philippe

Le 19/11/2013 14:48, Gaetan a ?crit :
> Also, what we set up in our scrum team is "targetted" doc stories 
> inside each sprint.
>
> Let's say that over the next month, the objective is to improve a set 
> of module doc, ie, a list of very useful std or extra lib that is not 
> properly documented.
> For instance, the next month we target on improving json or 
> extra::path, and enhance them until they become golden star level. And 
> the next month or sprint, we focus on other modules
>
> It's easier to focus people like this that just telling "you can take 
> whichever module you want and improve them". It just work better, we 
> discovered.
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Gaetan <gaetan at xeberon.net <mailto:gaetan at xeberon.net>>
>
>     I think it's better to enhance the extra::json lib itself and
>     write proper module documentation, with samples, use case etc.
>     My reference is the QT documentation. You never open and samples
>     or even the QT source code, everything is in the module documentation.
>
>     -----
>     Gaetan
>
>
>
>     2013/11/19 Philippe Delrieu <philippe.delrieu at free.fr
>     <mailto:philippe.delrieu at free.fr>>
>
>         Hello,
>
>         I would like to share my experience about the Rust doc and the
>         tutorial. I've just started to learn Rust and I've decided to
>         use it on a project I work on. Like everybody I read the Rust
>         tutorial. It's not a really a tutorial for beginner but it do
>         a good job in presenting Rust and its mains concept. I found
>         other tutorial on the web and in my opinion what is missing
>         the more is sample code. The Rust lib is huge and there is no
>         code. In my project I have to use Json serialization. So I
>         wanted to use the json lib in extra lib and I really spend
>         some time to make a simple code works. I was very near to
>         write my own lib. json.rs <http://json.rs> is a little
>         complicated for a newbie. There are some test case at the end
>         but it tests the lib and not what I want to do with it. For
>         example there is no serialization of an object. I search the
>         web and I found some old example (not compatible with the
>         master lib) and no object serialization.
>
>         So what I think is that it would be great is to construct a
>         repository of sample code of the Rust lib that show how to use
>         the lib. I'm ok to write and maintain some sample like one on
>         json. I think it would be great to host all these sample in
>         the same repository and to have the same organization for all
>         sample. The second reason tu use a share repository is that
>         the sample has to be made in the spirit of Rust to help
>         understand it. For that the sample must be checked and
>         modified by more experienced rust developer. It's easier when
>         the code is in a common repository.
>
>         P?ilippe
>
>         _______________________________________________
>         Rust-dev mailing list
>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>         https://mail.mozilla.org/listinfo/rust-dev
>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/080f3941/attachment.html>

From pcwalton at mozilla.com  Tue Nov 19 07:19:15 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 19 Nov 2013 07:19:15 -0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
Message-ID: <528B8173.9060201@mozilla.com>

On 11/19/13 3:09 AM, Daniel Micay wrote:
> The `loop` keyword still exists for the moment, but only for infinite
> loops. I'd prefer removing it and just using `while true { ... }`.

The liveness analysis uses the infinite nature of `loop`, and it was 
felt that special-casing the `true` boolean like Java does is a hack.

Patrick


From nit.dgp673 at gmail.com  Mon Nov 18 22:16:59 2013
From: nit.dgp673 at gmail.com (Laxmi Narayan NIT DGP)
Date: Tue, 19 Nov 2013 11:46:59 +0530
Subject: [rust-dev] Rust docs
In-Reply-To: <CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
Message-ID: <CAKUZWq83baZkqm82kOf8-MgpnedhU-51+01f1gv-UyeQd0OykQ@mail.gmail.com>

I am a student and thinking to write tutorial for it .





*          Laxmi Narayan Patel*

*               MCA NIT Durgapur ( Final year)*

*          Mob:-    8345847473    *


On Tue, Nov 19, 2013 at 10:33 AM, Thad Guidry <thadguidry at gmail.com> wrote:

>
>> I tend to agree with this, think that a collaborative approach is
>> unlikely to produce a consistent and high quality tutorial. I don't want to
>> discourage anybody but my current opinion is that we should hire an
>> experienced technical writer to do this piece especially, with input from
>> the wider community. Where I think collaboration is more likely to produce
>> something nice is in a 'cookbook' style document, of which several people
>> have already worked on seperately. Also of course API docs and the
>> reference manual are places where individuals can plug in their own
>> sections without impacting the overall narrative flow.
>>
>>
> So I spent this evening going through the tutorial (.08).  As an outsider
> to Rust, I can tell you it does not fit any model of a tutorial, but
> instead is an elongated language reference broken down into feature
> sections.  Which is highly useful in its design, and does say "This
> tutorial assumes that the reader is already familiar with one or more
> languages in the C family. Understanding of pointers and general memory
> management techniques will help."  BUT...
>
> It was not until section 17, that I finally met with a simple program that
> could compile.  That was 2 1/2 hours later before I was able to DO
> SOMETHING.
>
> I would encourage the Mozilla team to hire a technical writer as Brian
> suggests, that would turn the tutorial upside down...
>
> Start with something fun and entertaining in under 10 or 20 lines of Rust,
> that would amuse and provide "hackability" to tweak and play with values,
> mutability, and seeing the stack pop itself (half the developers in the
> world, do not know or have to worry about "a stack"..but of course "should"
> in any decent systems language :-) ), and then introduce garbage
> collecting, etc.   Introduce compile-able examples from the start, and
> continue with working examples that actually produce errors and let the
> user come to grips with the syntax & compiler error output, while coaching
> them through fixing the errors, and learning the do's and don'ts of Rust's
> current best practices.  That would be a mighty fine tutorial and the
> makings of a book for Rust itself.
>
> 2 cents and a haircut and I wish the team tremendous success on finding a
> talented writer,
>
> --
> -Thad
> +ThadGuidry <https://www.google.com/+ThadGuidry>
> Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/c63dad09/attachment-0001.html>

From banderson at mozilla.com  Tue Nov 19 10:04:37 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 19 Nov 2013 10:04:37 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <4111F0A2-153B-4131-B450-753768F6DE46@mozilla.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>
	<528ABB2D.6030802@mozilla.com>
	<4111F0A2-153B-4131-B450-753768F6DE46@mozilla.com>
Message-ID: <528BA835.2070603@mozilla.com>

On 11/18/2013 06:22 PM, Alex Crichton wrote:
>>> * #[link(...)] becomes the new method of specifying linkage semantics on extern
>>>    blocks, and it may be used similarly to link_args today
>> I'd kind of like for this to be available at the crate level too since most libraries don't use OS X two-level namespaces and it's more convient to me to just put all the linkage at the top of the crate. Of course this conflicts with the `link` attribute of crates, which I think is poorly named anyway.
> What purpose did you have in mind for the #[link] attribute at the top of the crate? Is the crate saying how it should be linked to other crates?

It would be the same purpose as putting them on extern blocks - to tell 
the linker what other libraries to link to. It would function exactly 
the same. The only reason link attributes ever *need* to be specifically 
on an extern block is to support OS X two-level namespaces (which I 
don't know anything about and haven't actually seen).

>
>> I don't really understand what 'once' implies in `link(once)` and how it relates to statics. If a static library *must* be linked, then dynamic libraries may not be linked? Why is that? If 'once' implies 'static', can we just say 'link(static)'? I assume some argument propagation is going to come into play here ...
>>
>> Will also need to accomodate some other common features like, e.g. `link(framework = "foo")` or something for OS X frameworks.
> What this ended up turning out as is #[link(name = ?foo?, kind = ?static?)]. I think that a ?framework? kind would fit quite well for this use case.
>
>> .rlib files also need the crate metadata.
> I agree
>
>> What happens when two upstream crates link to the same native static library? In the final link step they are both going to be linked in, and I presume there's some kind of conflict?
> Right now they?re both linked in. I didn?t envision this as a use case for rustc to complain about, but it would be simple enough to iterate over all upstream crates and see if the same static library were linked twice. My implementation requires metadata about the linkage regardless.
>
>> How does one opt into linking to dynamic libraries? Without some further mechanism everybody will be linking to the static libstd.
> I?ve reserved another -Z flag for ?-Z prefer-dynamic'
>
>> I took this to mean that we would just be packaging up the static libraries to save them for the final link step (since the rlib is just a .o file, not pre-linked to it's static lib dependencies). The effect of this though may be that all downstream crates implicitly have access to all the static library's symbols.
> This actually what currently happens. The resulting rlib file already contains all of the static native libraries bundled inside of it. This is achieved via ld?s -r option. It is true that all of the symbols leak through, however, and this is unfortunate. I?d like to explore methods of preventing this, but I only know of one way currently. We?d create a list of all symbols in the rust library (an actual file on the filesystem), and then pass that to the linker saying ?here are all the exported symbols, discard everything else.?
>
>


From banderson at mozilla.com  Tue Nov 19 10:05:18 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Tue, 19 Nov 2013 10:05:18 -0800
Subject: [rust-dev] Rethinking Linking in Rust
In-Reply-To: <CAJjz6c0j2wDLpKt4n-7seCHnKTwMnjU1osMgeXg7irAG-=ok2g@mail.gmail.com>
References: <CAFnh-mcwnNE5uhe3E21+ESwn85GqzUvZQEt2BE4psHpK0_Qtaw@mail.gmail.com>	<528ABB2D.6030802@mozilla.com>
	<CAJjz6c0j2wDLpKt4n-7seCHnKTwMnjU1osMgeXg7irAG-=ok2g@mail.gmail.com>
Message-ID: <528BA85E.30105@mozilla.com>

On 11/18/2013 08:01 PM, Zack Corr wrote:
> On Tue, Nov 19, 2013 at 11:13 AM, Brian Anderson 
> <banderson at mozilla.com <mailto:banderson at mozilla.com>> wrote:
>
>     Of course this conflicts with the `link` attribute of crates,
>     which I think is poorly named anyway.
>
>
> Perhaps #[link] in its current usage should be renamed to #[crate]? I 
> think that would make more sense.

This would be my preference.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/0acaa970/attachment.html>

From kevin at sb.org  Tue Nov 19 10:53:17 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 19 Nov 2013 10:53:17 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQJ5kS=KcWJ1PnX-pCn0=xCzj4v_29FHQry2Jo3xZc=RFw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CAPNUp08ggBJBgP52VrXxPTb6Z+urdoDCYC3PeKewfcpavcZi_g@mail.gmail.com>
	<CANK7tAH-qiqkdnGGmNG0koDvisoS5LvtT8ZpAq5JpSBcN76RUg@mail.gmail.com>
	<CA+DvKQJ5kS=KcWJ1PnX-pCn0=xCzj4v_29FHQry2Jo3xZc=RFw@mail.gmail.com>
Message-ID: <82ABDF79-EB32-4187-96A6-2699C774FE3C@sb.org>

On Nov 19, 2013, at 3:08 AM, Daniel Micay <danielmicay at gmail.com> wrote:

> I wouldn't mind not having `~T` in the language at all, but am not
> really opposed to including it because there's no harm. Choosing to
> special-case arbitrary non-trivial data structures like vectors and
> reference counted boxes *is* harmful because alternatives should *not*
> be second-class.

Alternatives aren?t second-class, they just aren?t special. Vectors in particular are used so ubiquitously that having special syntax is extremely convenient.

Anecdotally, Objective-C has moved in the opposite direction to the great happiness of all Obj-C developers. NSArray* and NSDictionary* are the ubiquitous vector/hashtable implementations that everybody uses, but they didn?t have any special language support. Recently, special language support was added so I can say @[@?yes?, @?no?, @?maybe?] instead of [NSArray arrayWithObjects:@?yes?, @?no?, @?maybe?, nil] (and similar syntax for dictionaries, as well as boxed NSNumbers) and it?s made programming in Obj-C significantly nicer. There?s nothing stopping you from using other data structures, but the special syntax for these particular ubiquitous ones just makes everyone?s life easier.

So back to Rust. &[] and its variants are extremely commonly used. Removing the special syntax for this will do nothing but make it more annoying to use them. It doesn?t do anything to make alternative data structures any easier to use. The one suggestion I?d make is maybe provide hooks for the &[] syntax to be used for a different vector implementation on a per-crate basis, although this would mean that &[] would actually be something like std::vector<T> and &[] is just syntactic sugar. Which is generally fine, although it?s awfully nice to have &[T] be the actual type name in type signatures, having to use std::vector<T> in type signatures and then using [a, b, c] to construct the value in code just feels a bit less nice than what we have in Rust today (but certainly better than no syntactic sugar at all).

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/d44049ff/attachment.html>

From rexlen at gmail.com  Tue Nov 19 11:19:57 2013
From: rexlen at gmail.com (Renato Lenzi)
Date: Tue, 19 Nov 2013 20:19:57 +0100
Subject: [rust-dev] Fwd:  Rust docs
In-Reply-To: <CAKUZWq83baZkqm82kOf8-MgpnedhU-51+01f1gv-UyeQd0OykQ@mail.gmail.com>
References: <CEAAF5F9.11FE%d.glazman@partner.samsung.com>
	<528A7322.3010602@mozilla.com>
	<CAChbWaPUyyW7hNYFZXU7fZzugQCT8Fkju6+ri9PtkPx25g38Fg@mail.gmail.com>
	<CAKUZWq83baZkqm82kOf8-MgpnedhU-51+01f1gv-UyeQd0OykQ@mail.gmail.com>
Message-ID: <CAM0XVgsHuTnBUGxKfsSnnmsLJEur=9MOnq07wrz=ZqtYdh8dAg@mail.gmail.com>

Good documentation is crucial for the success of a language. Some friends
of mine simply ceased their efforts on a language due to lack of good docs
about it. There are examples: excellent languages, as Falcon, Gosu, Fantom,
probably do not have sufficient resources to produce what their value
would require ... while if you wanna learn Go you can find, web sites,
info and even books. I believe that Mozilla can find the right resources
for good docs about Rust.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/fe9ec3ca/attachment.html>

From philippe.delrieu at free.fr  Tue Nov 19 11:48:32 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 19 Nov 2013 20:48:32 +0100
Subject: [rust-dev] How to cast a @type in a @trait
Message-ID: <528BC090.5070003@free.fr>

I still struggle with the json API. I try it using encode and decode API 
and I face a problem.
I take this code in the json test case :
         let m = @mut MemWriter::new();
         f(m as @mut io::Writer);
and I have an error :
The managed box syntax will be replaced by a library type, and a garbage 
collector is not yet implemented. Consider using the `std::rc::Rc` type 
for reference counted pointers.

With this error I can't use extra::json::Encoder that expect a @mut 
io::Writer

I use the master updated on the 15/10

Any idea.

I didn't see if the json test case compile. Rust build but I don't know 
if the test are compiled by default.

Philippe



From gokcehankara at gmail.com  Tue Nov 19 11:56:44 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 19 Nov 2013 21:56:44 +0200
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
	<CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
Message-ID: <CAEWroOgVHN-LY=6gmS-FZoK06Pchx1Rr54Wr+qW5YSDvyfJpOg@mail.gmail.com>

>
> I'm willing to help on this task, I think having a good completion library
> can help a lot smoothing the learning curve of a new language. I learned
> python in a few days with aptana, and I remember a few years ago how it was
> easy to write C++ with visual studio. Having an IDE integration is almost
> as important as having good tutorials.


That's great. I agree that it would be nice for newbies and I think also
for others as most people are already quite spoiled by the capabilities of
modern IDE's these days.

I'm also a newbe in Rust and I imagine you want to write in rust itself. I
> can help on the integration with sublime.


I was hoping to write in rust because I don't want to implement/maintain a
parser and typechecker from scratch. I was very pleased to see that it's
possible to access everything in `librustc` and `libsyntax` with a simple
`extern`, not sure if this will be removed later.

rustfind (https://github.com/dobkeratops/rustfind) does this and more,
> for crates that compile.


I wasn't aware of that, looks very nice indeed. I will take a look and see
if I can contribute somehow when I have some time.

Not very, for the general case. If you want autocompletion as you
> type, you currently need to have a fully-compilable crate. Otherwise,
> parsing or typechecking or something else will fail and you won't be
> able to get any results. rustc is currently very all-or-nothing.


It's a bummer. Are there any plans to implement some error recovery to
rustc?

But, you can get useful information for completion out of an
> already-compiling crate, though I'm not sure how much better it would
> be than what etags already does.


It has been some time since I last tried tags for autocompletion but it
wasn't very accurate as far as I remember. As far as I know you also need
some editor plugin for this, something like [OmniCppComplete](
http://www.vim.org/scripts/script.php?script_id=1520) which is basically a
cpp parser implemented in vimscript.

Very, since it would require reworking most of the compiler ;)


:)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/cbf1eaa9/attachment-0001.html>

From gokcehankara at gmail.com  Tue Nov 19 11:56:45 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 19 Nov 2013 21:56:45 +0200
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
	<CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
Message-ID: <CAEWroOhAQgKrR0Nt_NShcboSBksucwzLGfAqDvck0GqE0EuifQ@mail.gmail.com>

>
> I'm willing to help on this task, I think having a good completion library
> can help a lot smoothing the learning curve of a new language. I learned
> python in a few days with aptana, and I remember a few years ago how it was
> easy to write C++ with visual studio. Having an IDE integration is almost
> as important as having good tutorials.


That's great. I agree that it would be nice for newbies and I think also
for others as most people are already quite spoiled by the capabilities of
modern IDE's these days.

I'm also a newbe in Rust and I imagine you want to write in rust itself. I
> can help on the integration with sublime.


I was hoping to write in rust because I don't want to implement/maintain a
parser and typechecker from scratch. I was very pleased to see that it's
possible to access everything in `librustc` and `libsyntax` with a simple
`extern`, not sure if this will be removed later.

rustfind (https://github.com/dobkeratops/rustfind) does this and more,
> for crates that compile.


I wasn't aware of that, looks very nice indeed. I will take a look and see
if I can contribute somehow when I have some time.

Not very, for the general case. If you want autocompletion as you
> type, you currently need to have a fully-compilable crate. Otherwise,
> parsing or typechecking or something else will fail and you won't be
> able to get any results. rustc is currently very all-or-nothing.


It's a bummer. Are there any plans to implement some error recovery to
rustc?

But, you can get useful information for completion out of an
> already-compiling crate, though I'm not sure how much better it would
> be than what etags already does.


It has been some time since I last tried tags for autocompletion but it
wasn't very accurate as far as I remember. As far as I know you also need
some editor plugin for this, something like [OmniCppComplete](
http://www.vim.org/scripts/script.php?script_id=1520) which is basically a
cpp parser implemented in vimscript.

Very, since it would require reworking most of the compiler ;)


:)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/8ce2cd1f/attachment.html>

From pcwalton at mozilla.com  Tue Nov 19 12:00:46 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 19 Nov 2013 12:00:46 -0800
Subject: [rust-dev] How to cast a @type in a @trait
In-Reply-To: <528BC090.5070003@free.fr>
References: <528BC090.5070003@free.fr>
Message-ID: <528BC36E.9070509@mozilla.com>

On 11/19/13 11:48 AM, Philippe Delrieu wrote:
> I still struggle with the json API. I try it using encode and decode API
> and I face a problem.
> I take this code in the json test case :
>          let m = @mut MemWriter::new();
>          f(m as @mut io::Writer);
> and I have an error :
> The managed box syntax will be replaced by a library type, and a garbage
> collector is not yet implemented. Consider using the `std::rc::Rc` type
> for reference counted pointers.

Add `#[feature(managed_boxes)];` to the top of your crate. The JSON and 
EBML APIs have not been kept well up to date with idioms used by the 
current version of Rust and will not work without this feature flag.

Patrick


From gaetan at xeberon.net  Tue Nov 19 12:13:02 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 19 Nov 2013 21:13:02 +0100
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CAEWroOhAQgKrR0Nt_NShcboSBksucwzLGfAqDvck0GqE0EuifQ@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
	<CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
	<CAEWroOhAQgKrR0Nt_NShcboSBksucwzLGfAqDvck0GqE0EuifQ@mail.gmail.com>
Message-ID: <CANK7tAFY9G_ksgmDL0k+DDtLXF9gAyb4DScaRbh-o19yQVUfLQ@mail.gmail.com>

I think we can write in rust and perhaps reuse part of the compiler, but we
cannot allow to support only fully compiler crates.

It may be possible to begin a draft in language such as python
(YouCompleteMe seems to be written mostly in python)

-----
Gaetan



2013/11/19 Gokcehan Kara <gokcehankara at gmail.com>

> I'm willing to help on this task, I think having a good completion library
>> can help a lot smoothing the learning curve of a new language. I learned
>> python in a few days with aptana, and I remember a few years ago how it was
>> easy to write C++ with visual studio. Having an IDE integration is almost
>> as important as having good tutorials.
>
>
> That's great. I agree that it would be nice for newbies and I think also
> for others as most people are already quite spoiled by the capabilities of
> modern IDE's these days.
>
> I'm also a newbe in Rust and I imagine you want to write in rust itself. I
>> can help on the integration with sublime.
>
>
> I was hoping to write in rust because I don't want to implement/maintain a
> parser and typechecker from scratch. I was very pleased to see that it's
> possible to access everything in `librustc` and `libsyntax` with a simple
> `extern`, not sure if this will be removed later.
>
> rustfind (https://github.com/dobkeratops/rustfind) does this and more,
>> for crates that compile.
>
>
> I wasn't aware of that, looks very nice indeed. I will take a look and see
> if I can contribute somehow when I have some time.
>
> Not very, for the general case. If you want autocompletion as you
>> type, you currently need to have a fully-compilable crate. Otherwise,
>> parsing or typechecking or something else will fail and you won't be
>> able to get any results. rustc is currently very all-or-nothing.
>
>
> It's a bummer. Are there any plans to implement some error recovery to
> rustc?
>
> But, you can get useful information for completion out of an
>> already-compiling crate, though I'm not sure how much better it would
>> be than what etags already does.
>
>
> It has been some time since I last tried tags for autocompletion but it
> wasn't very accurate as far as I remember. As far as I know you also need
> some editor plugin for this, something like [OmniCppComplete](
> http://www.vim.org/scripts/script.php?script_id=1520) which is basically
> a cpp parser implemented in vimscript.
>
> Very, since it would require reworking most of the compiler ;)
>
>
> :)
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/3ac510f3/attachment.html>

From gokcehankara at gmail.com  Tue Nov 19 13:12:01 2013
From: gokcehankara at gmail.com (Gokcehan Kara)
Date: Tue, 19 Nov 2013 23:12:01 +0200
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CANK7tAFY9G_ksgmDL0k+DDtLXF9gAyb4DScaRbh-o19yQVUfLQ@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
	<CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
	<CAEWroOhAQgKrR0Nt_NShcboSBksucwzLGfAqDvck0GqE0EuifQ@mail.gmail.com>
	<CANK7tAFY9G_ksgmDL0k+DDtLXF9gAyb4DScaRbh-o19yQVUfLQ@mail.gmail.com>
Message-ID: <CAEWroOihicLO7BA9s-CeyWEPY0-gDs-fRoDdhBXaZs=AnNZCEA@mail.gmail.com>

I will be speculating a little since I haven't actually read the source. As
far as I understand, YouCompleteMe uses python for some parts but at its
core it has a cpp component using libclang library. libclang library itself
is already something that provides code completion which is the thing
missing for rust language.

[libclang]: http://clang.llvm.org/doxygen/group__CINDEX.html


On Tue, Nov 19, 2013 at 10:13 PM, Gaetan <gaetan at xeberon.net> wrote:

> I think we can write in rust and perhaps reuse part of the compiler, but
> we cannot allow to support only fully compiler crates.
>
> It may be possible to begin a draft in language such as python
> (YouCompleteMe seems to be written mostly in python)
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Gokcehan Kara <gokcehankara at gmail.com>
>
>> I'm willing to help on this task, I think having a good completion
>>> library can help a lot smoothing the learning curve of a new language. I
>>> learned python in a few days with aptana, and I remember a few years ago
>>> how it was easy to write C++ with visual studio. Having an IDE integration
>>> is almost as important as having good tutorials.
>>
>>
>> That's great. I agree that it would be nice for newbies and I think also
>> for others as most people are already quite spoiled by the capabilities of
>> modern IDE's these days.
>>
>> I'm also a newbe in Rust and I imagine you want to write in rust itself.
>>> I can help on the integration with sublime.
>>
>>
>> I was hoping to write in rust because I don't want to implement/maintain
>> a parser and typechecker from scratch. I was very pleased to see that it's
>> possible to access everything in `librustc` and `libsyntax` with a simple
>> `extern`, not sure if this will be removed later.
>>
>> rustfind (https://github.com/dobkeratops/rustfind) does this and more,
>>> for crates that compile.
>>
>>
>> I wasn't aware of that, looks very nice indeed. I will take a look and
>> see if I can contribute somehow when I have some time.
>>
>> Not very, for the general case. If you want autocompletion as you
>>> type, you currently need to have a fully-compilable crate. Otherwise,
>>> parsing or typechecking or something else will fail and you won't be
>>> able to get any results. rustc is currently very all-or-nothing.
>>
>>
>> It's a bummer. Are there any plans to implement some error recovery to
>> rustc?
>>
>> But, you can get useful information for completion out of an
>>> already-compiling crate, though I'm not sure how much better it would
>>> be than what etags already does.
>>
>>
>> It has been some time since I last tried tags for autocompletion but it
>> wasn't very accurate as far as I remember. As far as I know you also need
>> some editor plugin for this, something like [OmniCppComplete](
>> http://www.vim.org/scripts/script.php?script_id=1520) which is basically
>> a cpp parser implemented in vimscript.
>>
>> Very, since it would require reworking most of the compiler ;)
>>
>>
>> :)
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/677c52e3/attachment.html>

From alex at crichton.co  Tue Nov 19 14:08:06 2013
From: alex at crichton.co (Alex Crichton)
Date: Tue, 19 Nov 2013 14:08:06 -0800
Subject: [rust-dev] Removing some autoref magic
Message-ID: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>

Hello rust-dev!

Everyone's had their fair share of issues with autoref and autoderef,
and it's worth considering removing certain portions of it from the
compiler. The discussion around this has been rooted in the past, but
has recently been brought up as part of
https://github.com/mozilla/rust/issues/10504.

The current proposal is to remove all autoref except for function
invocations and indexing operations. The method of creating &T from ~T
would be `let foo: &T = foo` or `&*foo`. Vectors and strings can't
currently benefit from the `&*foo` syntax, but they will hopefully be
able to do such once DST lands. In the meantime coercion via type
ascription will work and they also have `as_slice` methods.

There are a few reasons backing this proposal:

1. It's inconsistent to have magical autoref in some places, but not
in other places.
2. The camp of "less compiler magic is better" can fly their flag over
this change.
3. Code readability does not necessarily benefit from autoref on arguments:

  let a = ~Foo;
  foo(a); // reading this code looks like it moves `a`
  fn foo(_: &Foo) {} // ah, nevermind, it doesn't move `a`!

  let mut a = ~[ ... ];
  sort(a); // not only does this not move `a`, but it mutates it!

The basic idea is that reasoning about code is no longer a local
function decision, but rather you must understand all the pointer-ness
of the called signatures to understand when a move happens or not.
With no autoref, the code would look like

  let a = ~Foo;
  foo(&*a); // clearly not passing by value

  let mut a = ~[ ... ];
  sort(a.as_mut_slice()); // clearly loaning a mutable reference


That being said, this proposal is not yet set in stone. I don't think
that there are many people that are fans of `&*foo` or `&mut *foo`;
both cases look fairly ugly. So far the general agreement is that
local small ugliness is the price we pay for local readability, and
the discussions have been unable to unearth a better system.

I'm curious if others have a better idea of how to go about doing
this, or if others just think it's a terrible idea in the first place.

From alex at crichton.co  Tue Nov 19 14:32:01 2013
From: alex at crichton.co (Alex Crichton)
Date: Tue, 19 Nov 2013 14:32:01 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
Message-ID: <CAFnh-me9G4tbkWrv4bbDZRR_+cJSKnbLCPkfZiZJ+LW6Oiu56g@mail.gmail.com>

Additionally, we discussed this today at our weekly meeting, and the
minutes can be found here:
https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-19#autoderef

From kevin at sb.org  Tue Nov 19 15:10:47 2013
From: kevin at sb.org (Kevin Ballard)
Date: Tue, 19 Nov 2013 15:10:47 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
Message-ID: <08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>

In general, I?m not a fan of &*, and I like auto-borrowing (autoref sounds like it turns T into &T, not ~T into &T). I understand the arguments to get rid of it though.

BTW, you said that the current proposal still includes autoref for function invocation. That sounds to me like autoref would still apply to x in foo(x). Is there something else you mean by that?

As I see it, the two interesting cases to consider for removing it are:

1. let x = ~Foo; foo(x); // looks like it moves x when it just borrows it

2. let mut a = ~[ ? ]; sort(a); // mutates a

To me, the second case seems pretty clear that it shouldn?t auto-borrow a ~T to a &mut T, and instead require sort(&mut *a). It?s pretty ugly, but it makes it clear what?s going on. This case isn?t particularly common, which is why losing autoref isn?t very tragic.

The first case is the most common case, and it seems a shame to require &*x everywhere. I understand the argument that it looks like x is moved until you read the function signature of foo(), but I?m not convinced that?s important enough to uglify the code. Arguably, you already have to know what foo() does to understand what the code is doing.

The basic argument, as I see it, is that the type signature of foo() shouldn?t change how the calling code treats its argument. If foo() changed from `fn foo(_: &T)` to `fn foo(_: ~T)` then `x` would start being moved instead of borrowed, which could cause errors in subsequent code in the caller.

But the problem with this argument is that the type signature of foo() already changes how the calling code treats its argument, in a fashion that will surface errors in later code rather than at the call site. Notably, if the argument is not fully constrained to a specific type by the time foo(x) is called, it will further constrain the type that may not cause a problem until later. For example:

fn foo(_: uint);
fn bar(_: uint);

let x = 1;
foo(x);
bar(x);

This compiles just fine, but if foo() changes its argument to `int`, then the call to bar() will fail with a type error. More complex situations can be created using generic functions as well.

In the case of autoref, the question is whether the value will be moved, rather than the type of the value, which is a slightly different issue but I?m not convinced it?s different enough that it needs to be specially addressed.

The other problem with this is that, even with autoref removed, you can still hit the same problem of a seemingly-benign change elsewhere causing a compiler error in your code. Namely, if a struct has no destructor, and you rely on the ability to implicitly copy it (e.g. calling bar(x) where foo is fn bar(_: T)), then adding a destructor to the struct will cause your code to fail to compile, in just the same way that foo changing from `fn foo(_: &T)` to `fn foo(_: ~T)` will today.

Overall, there just doesn?t seem to me to be a compelling reason to remove the ability to auto-borrow ~T into &T. Removing the ability to auto-borrow ~T into &mut T is more sensible though.

FWIW, a lot of why I like auto-borrowing is actually due to auto-slicing of ~[T] into &[T] and ~str into &str. But I assume that when (if) DST happens, auto-slicing will just be a case of auto-borrowing. And until that happens I?d really like to avoiding having to say foo(v.as_slice()).

-Kevin

On Nov 19, 2013, at 2:08 PM, Alex Crichton <alex at crichton.co> wrote:

> Hello rust-dev!
> 
> Everyone's had their fair share of issues with autoref and autoderef,
> and it's worth considering removing certain portions of it from the
> compiler. The discussion around this has been rooted in the past, but
> has recently been brought up as part of
> https://github.com/mozilla/rust/issues/10504.
> 
> The current proposal is to remove all autoref except for function
> invocations and indexing operations. The method of creating &T from ~T
> would be `let foo: &T = foo` or `&*foo`. Vectors and strings can't
> currently benefit from the `&*foo` syntax, but they will hopefully be
> able to do such once DST lands. In the meantime coercion via type
> ascription will work and they also have `as_slice` methods.
> 
> There are a few reasons backing this proposal:
> 
> 1. It's inconsistent to have magical autoref in some places, but not
> in other places.
> 2. The camp of "less compiler magic is better" can fly their flag over
> this change.
> 3. Code readability does not necessarily benefit from autoref on arguments:
> 
>  let a = ~Foo;
>  foo(a); // reading this code looks like it moves `a`
>  fn foo(_: &Foo) {} // ah, nevermind, it doesn't move `a`!
> 
>  let mut a = ~[ ... ];
>  sort(a); // not only does this not move `a`, but it mutates it!
> 
> The basic idea is that reasoning about code is no longer a local
> function decision, but rather you must understand all the pointer-ness
> of the called signatures to understand when a move happens or not.
> With no autoref, the code would look like
> 
>  let a = ~Foo;
>  foo(&*a); // clearly not passing by value
> 
>  let mut a = ~[ ... ];
>  sort(a.as_mut_slice()); // clearly loaning a mutable reference
> 
> 
> That being said, this proposal is not yet set in stone. I don't think
> that there are many people that are fans of `&*foo` or `&mut *foo`;
> both cases look fairly ugly. So far the general agreement is that
> local small ugliness is the price we pay for local readability, and
> the discussions have been unable to unearth a better system.
> 
> I'm curious if others have a better idea of how to go about doing
> this, or if others just think it's a terrible idea in the first place.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/2af722fb/attachment.html>

From com.liigo at gmail.com  Tue Nov 19 15:26:14 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 20 Nov 2013 07:26:14 +0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
Message-ID: <CAH8Jz7hAgeLupL-dSXdnGpP7MZ5C7=ivk3sVrwTW8tZbVyA+tw@mail.gmail.com>

+1
? 2013?11?19? ??8:27?"Gaetan" <gaetan at xeberon.net>???

> "The most common use case for owned boxes is creating recursive data
> structures like a binary search tree."
>
> I don't think this is the most common use of owned boxes: string
> management, ...
>
> I don't think it a good idea to place "binary search tree" in a tutorial.
> You don't do this every day :)
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Gaetan <gaetan at xeberon.net>
>
>> In the french presentation for rust 0.8 [1], the author gives the analogy
>> with C++ semantics
>> - ~ is a bit like unique_ptr
>> - @ is an enhanced shared_ptr<T>
>> - borrowed pointer works like C++ reference
>>
>> and I think it was very helpful to better understand them. I don't know
>> if it is true or now, but this comparison helps a lot understanding the
>> concepts.You can present them like this, and after, add more precision, and
>> difference with the C++ counter parts.
>>
>> A tutorial to make would be "Rust for C++ programmer" :)
>>
>>
>> [1] http://linuxfr.org/news/presentation-de-rust-0-8
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/11/19 Daniel Micay <danielmicay at gmail.com>
>>
>>> On Tue, Nov 19, 2013 at 4:25 AM, Gaetan <gaetan at xeberon.net> wrote:
>>> > I don't think there is any particular issue with the tutorial, but we
>>> need
>>> > more "recipes" on how to handle typical situations.
>>>
>>> I'm specifically talking about the `Boxes` section in the tutorial and
>>> not the whole picture. I keep hearing that the coverage of `~` it's
>>> confusing - so can someone elaborate?
>>>
>>> Rewriting the coverage of boxes and references by walking through the
>>> implementation of some data structures is something I'm willing to do,
>>> but in my opinion that section is now quite good, other than being dry
>>> and not presenting interesting code samples for the use cases it
>>> describes.
>>>
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/854623df/attachment-0001.html>

From com.liigo at gmail.com  Tue Nov 19 15:39:30 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 20 Nov 2013 07:39:30 +0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528B5B26.6080305@gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
Message-ID: <CAH8Jz7jr1EQLiEGxJT1P2HXdAXzRgcz_ahBum9q_WJsVtQqfhw@mail.gmail.com>

? 2013?11?19? ??8:35?"spir" <denis.spir at gmail.com>???
>
> On 11/19/2013 12:51 PM, Daniel Micay wrote:
>>
>> So in your opinion, what's wrong with the `Boxes` section?
>>
>> http://static.rust-lang.org/doc/master/tutorial.html#boxes
>>
>> I happen to think it does a pretty good job of explaining why `~` is
>> required for recursive types, which is almost the only use case for it
>> from a purely semantic perspective (not worrying about performance).
>
>
> If this is all true, that recursive structures are the main, "almost the
only use case" of ~ pointers, then the tutorial is in my view rather ok on
this point. But then, why does it seem there are ~ pointers in every corner
of Rust code? Including numerous cases in the tutorial itself.
>
+1

> Also, how would we explain and term this meaning? "Indirection" is not
good enough (for we introduce indirections for other reasons, if only to
have variable-size content). I'd say "self-similarity" is the right term
here, and self-explaining (see wikipedia if you are not familiar with the
idea). This is, in fact, the actual idea commonly termed "recursivity" in
programming (wrongly, in my view, but this is yet another terminological
issue). A rule about ~ pointers thus may be:
>
>    Whenever one needs self-similarity, use a ~ pointer.
>    This lets the language store the element through the kind
>    of indirection that permits a self-similar structure.
>
> (I'm not happy of this formulation, neither, still obscure.)
>
> however, other comments on ~ pointers (eg comparisons with C++
unique_ptr, notes that it means owned or "my") introduce ideas rather
different from the one you suggest here, don't they? Say I manually create
a kind of string or "fix-size" array:
>
> struct String {
>     n_bytes : uint,
>     bytes   : ~[u8],
> }
>
> struct Array <Item> {
>     n_items : uint,
>     items   : ~[Item],
> }
>
> Is it wrong here to ~ point to bytes or items? that's what I'd do,
anyway... If it is right, maybe the actual meaning of ~ is something like
"proper content". Whenever a structure actually contains content which is
actually proper to it, or more generally has (pointed) data participating
to its description, then these contents or descriptive data should pointed
with ~: because they belong / are proper to it.
>
> struct ComplexVisualForm {
>     shape : ~ Shape,
>     style : ~ Style,
> }
>
> This matches my distinction between things and data (properly speaking).
Data, even when pointed (for technological rather than semantic reasons),
still belong to whatever they are part of. Data are never referenced
(properly speaking), it makes no sense. Things instead exist by themselves,
are always ref'ed, never copied (or moved), it makes no sense. If the
reasoning above about ~ pointers is more or less correct (i doubt it is),
then we have in Rust the proper kind of pointer to point to data, properly
speaking, meaning information about things. Now, to reference things from
multiple points of view, we need something else, proper refs or links, and
they cannot be ordinary pointers (especially not GC'ed): we need true refs,
independant from the data (while pointers hold their addresses).
>
> Denis
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/906b21ca/attachment.html>

From ben.striegel at gmail.com  Tue Nov 19 15:40:04 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Tue, 19 Nov 2013 18:40:04 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
Message-ID: <CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>

If autoref still happens on methods, does this mean that you'd be able to
get around the need to do:

    sort(&mut *foo);

...by turning it into a method?

    foo.sort();


On Tue, Nov 19, 2013 at 6:10 PM, Kevin Ballard <kevin at sb.org> wrote:

> In general, I?m not a fan of &*, and I like auto-borrowing (autoref sounds
> like it turns T into &T, not ~T into &T). I understand the arguments to get
> rid of it though.
>
> BTW, you said that the current proposal still includes autoref for
> function invocation. That sounds to me like autoref would still apply to x
> in foo(x). Is there something else you mean by that?
>
> As I see it, the two interesting cases to consider for removing it are:
>
> 1. let x = ~Foo; foo(x); // looks like it moves x when it just borrows it
>
> 2. let mut a = ~[ ? ]; sort(a); // mutates a
>
> To me, the second case seems pretty clear that it shouldn?t auto-borrow a
> ~T to a &mut T, and instead require sort(&mut *a). It?s pretty ugly, but it
> makes it clear what?s going on. This case isn?t particularly common, which
> is why losing autoref isn?t very tragic.
>
> The first case is the most common case, and it seems a shame to require
> &*x everywhere. I understand the argument that it looks like x is moved
> until you read the function signature of foo(), but I?m not convinced
> that?s important enough to uglify the code. Arguably, you already have to
> know what foo() does to understand what the code is doing.
>
> The basic argument, as I see it, is that the type signature of foo()
> shouldn?t change how the calling code treats its argument. If foo() changed
> from `fn foo(_: &T)` to `fn foo(_: ~T)` then `x` would start being moved
> instead of borrowed, which could cause errors in subsequent code in the
> caller.
>
> But the problem with this argument is that the type signature of foo()
> *already* changes how the calling code treats its argument, in a fashion
> that will surface errors in later code rather than at the call site.
> Notably, if the argument is not fully constrained to a specific type by the
> time foo(x) is called, it will further constrain the type that may not
> cause a problem until later. For example:
>
> fn foo(_: uint);
> fn bar(_: uint);
>
> let x = 1;
> foo(x);
> bar(x);
>
> This compiles just fine, but if foo() changes its argument to `int`, then
> the call to bar() will fail with a type error. More complex situations can
> be created using generic functions as well.
>
> In the case of autoref, the question is whether the value will be moved,
> rather than the type of the value, which is a slightly different issue but
> I?m not convinced it?s different enough that it needs to be specially
> addressed.
>
> The other problem with this is that, even with autoref removed, you can
> still hit the same problem of a seemingly-benign change elsewhere causing a
> compiler error in your code. Namely, if a struct has no destructor, and you
> rely on the ability to implicitly copy it (e.g. calling bar(x) where foo is
> fn bar(_: T)), then adding a destructor to the struct will cause your code
> to fail to compile, in just the same way that foo changing from `fn foo(_:
> &T)` to `fn foo(_: ~T)` will today.
>
> Overall, there just doesn?t seem to me to be a compelling reason to remove
> the ability to auto-borrow ~T into &T. Removing the ability to auto-borrow
> ~T into &mut T is more sensible though.
>
> FWIW, a lot of why I like auto-borrowing is actually due to auto-slicing
> of ~[T] into &[T] and ~str into &str. But I assume that when (if) DST
> happens, auto-slicing will just be a case of auto-borrowing. And until that
> happens I?d really like to avoiding having to say foo(v.as_slice()).
>
> -Kevin
>
> On Nov 19, 2013, at 2:08 PM, Alex Crichton <alex at crichton.co> wrote:
>
> Hello rust-dev!
>
> Everyone's had their fair share of issues with autoref and autoderef,
> and it's worth considering removing certain portions of it from the
> compiler. The discussion around this has been rooted in the past, but
> has recently been brought up as part of
> https://github.com/mozilla/rust/issues/10504.
>
> The current proposal is to remove all autoref except for function
> invocations and indexing operations. The method of creating &T from ~T
> would be `let foo: &T = foo` or `&*foo`. Vectors and strings can't
> currently benefit from the `&*foo` syntax, but they will hopefully be
> able to do such once DST lands. In the meantime coercion via type
> ascription will work and they also have `as_slice` methods.
>
> There are a few reasons backing this proposal:
>
> 1. It's inconsistent to have magical autoref in some places, but not
> in other places.
> 2. The camp of "less compiler magic is better" can fly their flag over
> this change.
> 3. Code readability does not necessarily benefit from autoref on arguments:
>
>  let a = ~Foo;
>  foo(a); // reading this code looks like it moves `a`
>  fn foo(_: &Foo) {} // ah, nevermind, it doesn't move `a`!
>
>  let mut a = ~[ ... ];
>  sort(a); // not only does this not move `a`, but it mutates it!
>
> The basic idea is that reasoning about code is no longer a local
> function decision, but rather you must understand all the pointer-ness
> of the called signatures to understand when a move happens or not.
> With no autoref, the code would look like
>
>  let a = ~Foo;
>  foo(&*a); // clearly not passing by value
>
>  let mut a = ~[ ... ];
>  sort(a.as_mut_slice()); // clearly loaning a mutable reference
>
>
> That being said, this proposal is not yet set in stone. I don't think
> that there are many people that are fans of `&*foo` or `&mut *foo`;
> both cases look fairly ugly. So far the general agreement is that
> local small ugliness is the price we pay for local readability, and
> the discussions have been unable to unearth a better system.
>
> I'm curious if others have a better idea of how to go about doing
> this, or if others just think it's a terrible idea in the first place.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/e201fcc8/attachment.html>

From com.liigo at gmail.com  Tue Nov 19 15:47:04 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 20 Nov 2013 07:47:04 +0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CADcg8==CzYuBZs-ghFU_OhL88csrouf1zhB5H-129j=-Hb6c=w@mail.gmail.com>
	<D4CB69FD-1157-4B18-AC5E-75AB22EAC8CD@kinostudios.com>
	<CA++BO6T24dQqO-+KT5H20cUZZ8zhV9J1OPc00d4OwNsmh17Xgw@mail.gmail.com>
	<D2F71749-9508-40E0-8F2F-7B5FD983521F@kinostudios.com>
	<CAKBOV9=L3_YKTvg9OOJp_Ta8H+qX5=osVQ+Rvrp14s-MOKsa_A@mail.gmail.com>
	<CAKBOV9k32pGXm79=dsraMbmGZPkzSuZhWGFfGQ6Z5G7mA_9r_A@mail.gmail.com>
	<21D511A4-ADC2-4D2E-BD65-FDF93AB8AEEB@kinostudios.com>
	<52829E45.4030405@mozilla.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<CANK7tAH5YRtzuWyhkyB8_8Q4hyC3R8sMw0QtmZrT88UOc5bmyw@mail.gmail.com>
	<CA+DvKQ+Fz=WymN6u-oWGc2EABE8-k7X22B1zPkUvphS5rqQJ3Q@mail.gmail.com>
	<CANK7tAFa2Kthn6dLxw-MRGfawAqNqnOyf7a-BekX-CnRmkEo4w@mail.gmail.com>
Message-ID: <CAH8Jz7jxZLTPnG=hR61GQ133GZWax5=QBwCf5HT1z0Q=2cMVEQ@mail.gmail.com>

? 2013?11?19? ??8:41?"Gaetan" <gaetan at xeberon.net>???
>
> I think this is precisely one of the bigest issue, from a newbee point of
view. And I agree with spir on this point. It's not that important, but you
end up placing them everywhere "to make the compiler happy".
>
> ~str should be a ~T. If it is not, it should use another semantic.
>
+1

> However, I don't see where you explain this subtility in the tutorial,
didn't you added it recently?
>
> PS: I'm french, I know pretty well that all subtilities (other words for
"exception to the general rules") my natural language has their own reason,
BUT if I wanted to redesign french, I would get rid of all these rules,
exceptions, rules in the exceptions. And exceptions in the rules of
exceptions...
>
> -----
> Gaetan
>
>
>
> 2013/11/19 Daniel Micay <danielmicay at gmail.com>
>>
>> On Tue, Nov 19, 2013 at 7:27 AM, Gaetan <gaetan at xeberon.net> wrote:
>> > "The most common use case for owned boxes is creating recursive data
>> > structures like a binary search tree."
>> >
>> > I don't think this is the most common use of owned boxes: string
management,
>> > ...
>> >
>> > I don't think it a good idea to place "binary search tree" in a
tutorial.
>> > You don't do this every day :)
>> >
>> > -----
>> > Gaetan
>>
>> ~str isn't an ~T, in the existing type system
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/107a07d4/attachment-0001.html>

From com.liigo at gmail.com  Tue Nov 19 16:00:08 2013
From: com.liigo at gmail.com (Liigo Zhuang)
Date: Wed, 20 Nov 2013 08:00:08 +0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
Message-ID: <CAH8Jz7iqM5eanjom8CMo6fpBvOWf_75Sat4_CigCiTm-AC+Trw@mail.gmail.com>

? 2013?11?19? ??8:44?"Daniel Micay" <danielmicay at gmail.com>???
>
> On Tue, Nov 19, 2013 at 7:35 AM, spir <denis.spir at gmail.com> wrote:
> >
> > If this is all true, that recursive structures are the main, "almost the
> > only use case" of ~ pointers, then the tutorial is in my view rather ok
on
> > this point. But then, why does it seem there are ~ pointers in every
corner
> > of Rust code? Including numerous cases in the tutorial itself.
> >
> > Also, how would we explain and term this meaning? "Indirection" is not
good
> > enough (for we introduce indirections for other reasons, if only to have
> > variable-size content). I'd say "self-similarity" is the right term
here,
> > and self-explaining (see wikipedia if you are not familiar with the
idea).
> > This is, in fact, the actual idea commonly termed "recursivity" in
> > programming (wrongly, in my view, but this is yet another terminological
> > issue). A rule about ~ pointers thus may be:
> >
> >    Whenever one needs self-similarity, use a ~ pointer.
> >    This lets the language store the element through the kind
> >    of indirection that permits a self-similar structure.
> >
> > (I'm not happy of this formulation, neither, still obscure.)
> >
> > however, other comments on ~ pointers (eg comparisons with C++
unique_ptr,
> > notes that it means owned or "my") introduce ideas rather different
from the
> > one you suggest here, don't they? Say I manually create a kind of
string or
> > "fix-size" array:
> >
> > struct String {
> >     n_bytes : uint,
> >     bytes   : ~[u8],
> > }
> >
> > struct Array <Item> {
> >     n_items : uint,
> >     items   : ~[Item],
> > }
>
> The expression ~([1, 2, 3]) has a different type than the expression
> ~[1, 2, 3]. The former is an owned box containing a fixed size array
> (~[int, ..3]) and the latter is a dynamic array (~[int]).
>
> The ~str and ~[T] types are *not* owned boxes in the current type
> system. There has been a proposal for dynamically sized types which
> would make them owned boxes, but I only like it as the path forwards
> for traits/closures and not vectors.
>

Are you telling us "~T is not ~T", just as "sun is not sun" and "moon is
not moon"?? If they do not have the same semantic, why use the same syntax?

> I don't think dynamic arrays/strings belong as built-in types
> hard-wired into the language, especially with a confusing syntax like
> this. They should be treated as other containers are.
>
> In what I think is a sane system, dynamic arrays would be a library
> `Vec<T>` type just like we have `HashMap<K, V>` and will have other
> vector types like `Rope<T>` or `SmallVec<T, N>`.
>
> > Is it wrong here to ~ point to bytes or items? that's what I'd do,
anyway...
> > If it is right, maybe the actual meaning of ~ is something like "proper
> > content". Whenever a structure actually contains content which is
actually
> > proper to it, or more generally has (pointed) data participating to its
> > description, then these contents or descriptive data should pointed
with ~:
> > because they belong / are proper to it.
> >
> > struct ComplexVisualForm {
> >     shape : ~ Shape,
> >     style : ~ Style,
> > }
>
> It doesn't make sense to use ~T over T without a reason to need a
> pointer-size value. It offers nothing in terms of semantics. It uses
> indirection to obtain pointer-size, and adds a destructor (a strict
> loss in terms of functionality). If you're not writing a recursive
> data structure or using dynamic dispatch via a trait object, you don't
> need it.
>
> > This matches my distinction between things and data (properly speaking).
> > Data, even when pointed (for technological rather than semantic
reasons),
> > still belong to whatever they are part of. Data are never referenced
> > (properly speaking), it makes no sense. Things instead exist by
themselves,
> > are always ref'ed, never copied (or moved), it makes no sense. If the
> > reasoning above about ~ pointers is more or less correct (i doubt it
is),
> > then we have in Rust the proper kind of pointer to point to data,
properly
> > speaking, meaning information about things. Now, to reference things
from
> > multiple points of view, we need something else, proper refs or links,
and
> > they cannot be ordinary pointers (especially not GC'ed): we need true
refs,
> > independant from the data (while pointers hold their addresses).
> >
> > Denis
> >
>
> ~T and T both have value semantics. Neither has by-reference
> semantics, as ~T is always the unique owner of the contained value.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/d854d492/attachment.html>

From vadimcn at gmail.com  Tue Nov 19 16:54:18 2013
From: vadimcn at gmail.com (Vadim)
Date: Tue, 19 Nov 2013 16:54:18 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
Message-ID: <CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>

So why did Rust adopt auto-moving instead of explicit moving?   If the
second example had to be written as foo(move a) there would be no
confusion.   The and the third example should arguably be sort(mut
a.as_mut_slice()).

Personally I would prefer if & in Rust worked similar to const T& in c++
(i.e. for most intents and purposes you can treat a reference as a value),
otherwise half of the arguments on each function call will have to be
adorned with ampersands.

Can we have it such that foo(a) would be guaranteed to not mutate or move a
and require "mut" or "move" prefix otherwise?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/4be5520c/attachment.html>

From hatahet at gmail.com  Tue Nov 19 17:07:03 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Tue, 19 Nov 2013 17:07:03 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
Message-ID: <CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>

> Personally I would prefer if & in Rust worked similar to const T& in c++

In that case, you would not be able to tell whether a function argument was
passed by value or by reference. I actually like this feature about Rust
(C# has it too with the `ref` keyword).

--
Ziad


On Tue, Nov 19, 2013 at 4:54 PM, Vadim <vadimcn at gmail.com> wrote:

> So why did Rust adopt auto-moving instead of explicit moving?   If the
> second example had to be written as foo(move a) there would be no
> confusion.   The and the third example should arguably be sort(mut
> a.as_mut_slice()).
>
> Personally I would prefer if & in Rust worked similar to const T& in c++
> (i.e. for most intents and purposes you can treat a reference as a value),
> otherwise half of the arguments on each function call will have to be
> adorned with ampersands.
>
> Can we have it such that foo(a) would be guaranteed to not mutate or move
> a and require "mut" or "move" prefix otherwise?
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/0f32c137/attachment.html>

From val at markovic.io  Tue Nov 19 17:12:52 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 19 Nov 2013 17:12:52 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<CAN1rdEyBR+4jrwcLSKuba=8qvW+XibfA3SCUjQax3TmpmB+0Gg@mail.gmail.com>
	<528AB058.2010706@mozilla.com>
	<CAAvrL-kD1cVj7zGuEkfU2Lsqxyrn-u7h7+CcXGGNhpmdowiQYA@mail.gmail.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
Message-ID: <CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>

On Tue, Nov 19, 2013 at 4:43 AM, Daniel Micay <danielmicay at gmail.com> wrote:
>
> The expression ~([1, 2, 3]) has a different type than the expression
> ~[1, 2, 3]. The former is an owned box containing a fixed size array
> (~[int, ..3]) and the latter is a dynamic array (~[int]).
>
> The ~str and ~[T] types are *not* owned boxes in the current type
> system. There has been a proposal for dynamically sized types which
> would make them owned boxes, but I only like it as the path forwards
> for traits/closures and not vectors.
>
> I don't think dynamic arrays/strings belong as built-in types
> hard-wired into the language, especially with a confusing syntax like
> this. They should be treated as other containers are.
>
> In what I think is a sane system, dynamic arrays would be a library
> `Vec<T>` type just like we have `HashMap<K, V>` and will have other
> vector types like `Rope<T>` or `SmallVec<T, N>`.


Agreed with this 100%. From a mental model perspective, you can't have ~foo
mean "foo is boxed" everywhere in the language and then go "Oh but ~str and
~[T]? Yeah those are exceptions. You're mental model is wrong".

*Everyone* is going to build this incorrect mental model of "putting ~ in
front of a thing puts that thing in a box" and it's not the user's fault,
it's Rust's fault for having this silly distinction.

~ in front of a type should mean one thing and one thing only. Otherwise
we're just making life difficult for the users for no sensible reason. I
read through all the Rust docs several times over the last few months, I
have years of experience with C++ and thought I had a rock-solid
understanding of ~T (it's just a unique_ptr<T>) and just a few days ago I
learned that ~str and ~[T] are special. And I only learned about this by
randomly browsing through rust-dev.

I felt cheated a bit TBH. It's such an obvious design mistake IMO;
everyone's going to get this wrong because it's counter-intuitive. It's
like mutable default arguments in Python 2.x (which was thankfully fixed in
3.0). [I'm not trying to bash a different language, I know that's against
the rules of the list. I'm just trying to draw a parallel with a different
language design mistake that tripped up everyone as well.]
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/1f2a7c03/attachment-0001.html>

From pcwalton at mozilla.com  Tue Nov 19 17:21:40 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 19 Nov 2013 17:21:40 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<528AC00B.1000909@mozilla.com>	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>	<528AE665.3010000@mozilla.com>	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>	<528B4F72.1070608@gmail.com>	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>	<528B5B26.6080305@gmail.com>	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
	<CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>
Message-ID: <528C0EA4.8010008@mozilla.com>

On 11/19/13 5:12 PM, Val Markovic wrote:
> I felt cheated a bit TBH. It's such an obvious design mistake IMO;
> everyone's going to get this wrong because it's counter-intuitive.

I agree that we should change this, but give us some credit: it's only 
an obvious design mistake now that we've gotten to this point. For those 
joining us now, we have gone through the following changes starting 3 
years ago:

     1. `[T]` is always reference counted. Pushing onto a vector was 
optimized to push in-place iff the reference count was 1. There is `[mut 
T]` as well. There is no overloading and also no slicing, because there 
was no region system.
     2. `[T]` is always owned and small vector optimized with 4 elements 
in place (number arrived at through measurements). There is no `[mut 
T]`. There is no slicing because there is no region system.
     3. `[T]` is always owned and not small vector optimized. There is 
no slicing.
     4. We have 4 vector types, `[T, ..N]`, `[T]/&` and `[T]/~` (today 
`[T, ..N]`, `&[T]`, `~[T]` respectively), as well as `[T]/@` which is 
reference counted. Vector literals infer to the right one. Owned and 
managed vectors can be sliced.
     5. We have 4 vector types, `[T, ..N]`, `&[T]`, `~[T]`, and `@[T]`.
     6. We have 3 vector types, `[T, ..N]`, `&[T]` and `~[T]`.

Now we're talking about:

     7. We have 1 built-in vector type: `[T, ..N]`. Slices are 
`Slice<T>` lang items. Owned and managed vectors can be built into the 
library.

The current status is the product of the slow evolution of a design that 
predated the region and slicing system, and what seems obvious now was 
not obvious in retrospect.

Patrick


From vadimcn at gmail.com  Tue Nov 19 17:35:12 2013
From: vadimcn at gmail.com (Vadim)
Date: Tue, 19 Nov 2013 17:35:12 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
Message-ID: <CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>

If the function is not going to mutate it, I don't really care if it's
by-ref or by-value.   That's why I said "const T&", not "T&".   Well,
except for the case when a function caches a reference to something which I
later mutate.   But borrow checking will prevent that.

I would also be totally fine with letting the compiler figure out how
immutable arguments are passed (based on data type size, existence of
destructors, and whatnot).  This might not be the best idea for binary
compatibility of public APIs, but I don't see why it can't be done with
crate-private functions.




On Tue, Nov 19, 2013 at 5:07 PM, Ziad Hatahet <hatahet at gmail.com> wrote:

> > Personally I would prefer if & in Rust worked similar to const T& in c++
>
> In that case, you would not be able to tell whether a function argument
> was passed by value or by reference. I actually like this feature about
> Rust (C# has it too with the `ref` keyword).
>
> --
> Ziad
>
>
> On Tue, Nov 19, 2013 at 4:54 PM, Vadim <vadimcn at gmail.com> wrote:
>
>> So why did Rust adopt auto-moving instead of explicit moving?   If the
>> second example had to be written as foo(move a) there would be no
>> confusion.   The and the third example should arguably be sort(mut
>> a.as_mut_slice()).
>>
>> Personally I would prefer if & in Rust worked similar to const T& in c++
>> (i.e. for most intents and purposes you can treat a reference as a value),
>> otherwise half of the arguments on each function call will have to be
>> adorned with ampersands.
>>
>> Can we have it such that foo(a) would be guaranteed to not mutate or move
>> a and require "mut" or "move" prefix otherwise?
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/f8355d43/attachment.html>

From bklooste at gmail.com  Tue Nov 19 17:54:40 2013
From: bklooste at gmail.com (Ben Kloosterman)
Date: Wed, 20 Nov 2013 09:54:40 +0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
	<CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
Message-ID: <CAJT18iZPfzHQE+v730=iiXVHZwvvdh1q8bnDrp-vvtav+utk3Q@mail.gmail.com>

While i like auto magic eg you could let region analysis work out the
pointer type , borrowed pointers etc  ,however you need to be very careful
. C# uses ref  but autoboxing is a major issue , you dont know when the
struct is boxed ( there are some places besides the obvious virt call ) and
then you incur boxing costs  defeating the whole point of value types .
 The vast majority of C# developers only use structs for a few corner cases
eg a type holding a few values  ( many dont use value types at all) , they
could go further but often it will get boxed somewhere and kill the
benefits so why go through the hassle.

Ben


On Wed, Nov 20, 2013 at 9:35 AM, Vadim <vadimcn at gmail.com> wrote:

> If the function is not going to mutate it, I don't really care if it's
> by-ref or by-value.   That's why I said "const T&", not "T&".   Well,
> except for the case when a function caches a reference to something which I
> later mutate.   But borrow checking will prevent that.
>
> I would also be totally fine with letting the compiler figure out how
> immutable arguments are passed (based on data type size, existence of
> destructors, and whatnot).  This might not be the best idea for binary
> compatibility of public APIs, but I don't see why it can't be done with
> crate-private functions.
>
>
>
>
> On Tue, Nov 19, 2013 at 5:07 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
>
>> > Personally I would prefer if & in Rust worked similar to const T& in c++
>>
>> In that case, you would not be able to tell whether a function argument
>> was passed by value or by reference. I actually like this feature about
>> Rust (C# has it too with the `ref` keyword).
>>
>> --
>> Ziad
>>
>>
>> On Tue, Nov 19, 2013 at 4:54 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>>> So why did Rust adopt auto-moving instead of explicit moving?   If the
>>> second example had to be written as foo(move a) there would be no
>>> confusion.   The and the third example should arguably be sort(mut
>>> a.as_mut_slice()).
>>>
>>> Personally I would prefer if & in Rust worked similar to const T& in c++
>>> (i.e. for most intents and purposes you can treat a reference as a value),
>>> otherwise half of the arguments on each function call will have to be
>>> adorned with ampersands.
>>>
>>> Can we have it such that foo(a) would be guaranteed to not mutate or
>>> move a and require "mut" or "move" prefix otherwise?
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/92429161/attachment.html>

From val at markovic.io  Tue Nov 19 19:03:57 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 19 Nov 2013 19:03:57 -0800
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <528C0EA4.8010008@mozilla.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
	<CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>
	<528C0EA4.8010008@mozilla.com>
Message-ID: <CAK9U+m2B+eCreVn13-co+Yj2kghaDthvoyz_Q4EeRSfLXt3oQw@mail.gmail.com>

On Tue, Nov 19, 2013 at 5:21 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

>
> I agree that we should change this, but give us some credit: it's only an
> obvious design mistake now that we've gotten to this point.
> [...]

The current status is the product of the slow evolution of a design that
> predated the region and slicing system, and what seems obvious now was not
> obvious in retrospect.


Fair point. I give you guys a lot of credit though, Rust is a wonderful
language in general. I also admire how willing core Rust devs are to admit
"ok that was a bad idea, let's try something else." I don't see that every
day; Rust is better for it.

Please continue being awesome.


>
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/55b19a0e/attachment.html>

From val at markovic.io  Tue Nov 19 19:33:06 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 19 Nov 2013 19:33:06 -0800
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
Message-ID: <CAK9U+m3sQDAHLocVTNVY9nAffrQhJLbBy=UHfhJytg3EXf8smQ@mail.gmail.com>

On Mon, Nov 18, 2013 at 3:25 PM, Gokcehan Kara <gokcehankara at gmail.com>wrote:

> I have been thinking of working on an editor agnostic code helper library
> with an autocomplete engine for rust (since there isn't anything yet?) as a
> hobby project to get to know the internals of the compiler. Examples of
> similar projects in different languages include;
>

This is a great idea. Rust needs to have something like libclang. In fact,
I think the Clang project was started because GCC had such poor support for
being used as a library (well, that and the GPLv3 license making it hard
for Apple to link it into Xcode). This should teach us something.


> - [youcompleteme](https://github.com/Valloric/YouCompleteMe)
> (C/C++/Objective-C/Objective-C++) (this one is specific to vim and a more
> general solution to autocompletion in vim but it includes a clang based
> completion engine for c family languages)
>

YCM is a bit more complicated than that (and I'd know since I wrote it :)).
It provides a general framework for tying together various semantic engines
and building an awesome code completion experience on top. YCM currently
uses libclang as the semantic engine for C/C++/ObjC/ObjC++, Jedi for
Python, OmniSharp for C# etc. Plugging in a new semantic engine is very
easy. YCM can use the Vim omnifunc as the semantic source so it can tie
into other plugins that provide an omnifunc, like Eclim for Java or gocode
for Go. YCM then provides its own features on top of that.

YCM *used* to be specific to Vim, but that's slowly changing. I recently
rewrote it from scratch to have a client-server architecture where almost
all of the logic is in the server; the client is a very thin shell that
merely queries the server. Some time in the future you'll see YCM clients
for other editors like SublimeText, emacs and others. I first have to pull
out the server source code into a separate repo on GitHub.

Bottom line, if you get to a point where you have a library with an API
that can provide completions for Rust code, I'd love to hook it into YCM.
There's a similar project (DCD <https://github.com/Hackerpilot/DCD>) going
for D as well; when that's more stable it will be hooked up to YCM too.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/606064fc/attachment-0001.html>

From val at markovic.io  Tue Nov 19 19:39:23 2013
From: val at markovic.io (Val Markovic)
Date: Tue, 19 Nov 2013 19:39:23 -0800
Subject: [rust-dev] autocomplete engine for rust
In-Reply-To: <CAEWroOihicLO7BA9s-CeyWEPY0-gDs-fRoDdhBXaZs=AnNZCEA@mail.gmail.com>
References: <CAEWroOj7=U6SyOUEwVPGx2SsoB=z7_7Nc3G9Nb77s2BReDyHMg@mail.gmail.com>
	<CA++BO6QqLjUEpZBw12LqM1kddtfi6krJKdDsppvKfxGEahK+3w@mail.gmail.com>
	<CAEWroOhAQgKrR0Nt_NShcboSBksucwzLGfAqDvck0GqE0EuifQ@mail.gmail.com>
	<CANK7tAFY9G_ksgmDL0k+DDtLXF9gAyb4DScaRbh-o19yQVUfLQ@mail.gmail.com>
	<CAEWroOihicLO7BA9s-CeyWEPY0-gDs-fRoDdhBXaZs=AnNZCEA@mail.gmail.com>
Message-ID: <CAK9U+m2qLt--jtnMnHsSud3KWriNrGG3r-G8GLh-iA=rYi5F8g@mail.gmail.com>

On Tue, Nov 19, 2013 at 1:12 PM, Gokcehan Kara <gokcehankara at gmail.com>wrote:

> I will be speculating a little since I haven't actually read the source.
> As far as I understand, YouCompleteMe uses python for some parts but at its
> core it has a cpp component using libclang library. libclang library itself
> is already something that provides code completion which is the thing
> missing for rust language.
>
> [libclang]: http://clang.llvm.org/doxygen/group__CINDEX.html
>

This is mostly correct. libclang is clang compiler API (the entire compiler
is in the binary and is exposed through the C API). YCM is written is
several languages: VimScript for the Vim client and Python & C++ for the
server binary. Python is the glue code between the various components and
semantic engines. Jedi is a semantic engine written in Python, OmniSharp is
written in C#. There's a C++ component that talks to libclang. There's
another C++ component that does the complex subsequence candidate string
matching and candidate ranking.


>
>
> On Tue, Nov 19, 2013 at 10:13 PM, Gaetan <gaetan at xeberon.net> wrote:
>
>> I think we can write in rust and perhaps reuse part of the compiler, but
>> we cannot allow to support only fully compiler crates.
>>
>> It may be possible to begin a draft in language such as python
>> (YouCompleteMe seems to be written mostly in python)
>>
>> -----
>> Gaetan
>>
>>
>>
>> 2013/11/19 Gokcehan Kara <gokcehankara at gmail.com>
>>
>>> I'm willing to help on this task, I think having a good completion
>>>> library can help a lot smoothing the learning curve of a new language. I
>>>> learned python in a few days with aptana, and I remember a few years ago
>>>> how it was easy to write C++ with visual studio. Having an IDE integration
>>>> is almost as important as having good tutorials.
>>>
>>>
>>> That's great. I agree that it would be nice for newbies and I think also
>>> for others as most people are already quite spoiled by the capabilities of
>>> modern IDE's these days.
>>>
>>> I'm also a newbe in Rust and I imagine you want to write in rust itself.
>>>> I can help on the integration with sublime.
>>>
>>>
>>> I was hoping to write in rust because I don't want to implement/maintain
>>> a parser and typechecker from scratch. I was very pleased to see that it's
>>> possible to access everything in `librustc` and `libsyntax` with a simple
>>> `extern`, not sure if this will be removed later.
>>>
>>> rustfind (https://github.com/dobkeratops/rustfind) does this and more,
>>>> for crates that compile.
>>>
>>>
>>> I wasn't aware of that, looks very nice indeed. I will take a look and
>>> see if I can contribute somehow when I have some time.
>>>
>>> Not very, for the general case. If you want autocompletion as you
>>>> type, you currently need to have a fully-compilable crate. Otherwise,
>>>> parsing or typechecking or something else will fail and you won't be
>>>> able to get any results. rustc is currently very all-or-nothing.
>>>
>>>
>>> It's a bummer. Are there any plans to implement some error recovery to
>>> rustc?
>>>
>>> But, you can get useful information for completion out of an
>>>> already-compiling crate, though I'm not sure how much better it would
>>>> be than what etags already does.
>>>
>>>
>>> It has been some time since I last tried tags for autocompletion but it
>>> wasn't very accurate as far as I remember. As far as I know you also need
>>> some editor plugin for this, something like [OmniCppComplete](
>>> http://www.vim.org/scripts/script.php?script_id=1520) which is
>>> basically a cpp parser implemented in vimscript.
>>>
>>> Very, since it would require reworking most of the compiler ;)
>>>
>>>
>>> :)
>>>
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131119/1831d569/attachment.html>

From rusty.gates at icloud.com  Tue Nov 19 19:43:54 2013
From: rusty.gates at icloud.com (Tommi)
Date: Wed, 20 Nov 2013 05:43:54 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
Message-ID: <F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>

On 2013-11-20, at 1:40, Benjamin Striegel <ben.striegel at gmail.com> wrote:

> If autoref still happens on methods, does this mean that you'd be able to get around the need to do:
> 
>     sort(&mut *foo);
> 
> ...by turning it into a method?
> 
>     foo.sort();

I like how your argument nudges this whole discussion a few inches to the left. Now we see that disallowing auto-borrowing from regular function arguments doesn't buy us anything unless we also disallow it from the target of method invocation syntax (dot notation). And that's obviously assuming the upcoming UFCS feature. I doubt that anyone would like to be writing (&*foo).call_method() all day long.

From pcwalton at mozilla.com  Tue Nov 19 20:24:14 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Tue, 19 Nov 2013 20:24:14 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
Message-ID: <528C396E.5070603@mozilla.com>

On 11/19/13 7:43 PM, Tommi wrote:
> I like how your argument nudges this whole discussion a few inches to
> the left. Now we see that disallowing auto-borrowing from regular
> function arguments doesn't buy us anything unless we also disallow it
> from the target of method invocation syntax (dot notation). And
> that's obviously assuming the upcoming UFCS feature. I doubt that
> anyone would
like to be writing (&*foo).call_method() all day long.

Magic in one part of the language isn't equivalent to magic everywhere 
in the language. The dot operator is already magical in several ways: it 
autoderefs for fields and searches through all traits in scope. This 
proposal would confine the magic to that operator and that operator 
alone, preventing it from leaking out into other parts of the language.

Patrick

From rusty.gates at icloud.com  Tue Nov 19 21:13:40 2013
From: rusty.gates at icloud.com (Tommi)
Date: Wed, 20 Nov 2013 07:13:40 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528C396E.5070603@mozilla.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
Message-ID: <18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>

On 2013-11-20, at 6:24, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/19/13 7:43 PM, Tommi wrote:
>> I like how your argument nudges this whole discussion a few inches to
>> the left. Now we see that disallowing auto-borrowing from regular
>> function arguments doesn't buy us anything unless we also disallow it
>> from the target of method invocation syntax (dot notation). And
>> that's obviously assuming the upcoming UFCS feature. I doubt that
>> anyone would like to be writing (&*foo).call_method() all day long.
> 
> Magic in one part of the language isn't equivalent to magic everywhere in the language. The dot operator is already magical in several ways: it autoderefs for fields and searches through all traits in scope. This proposal would confine the magic to that operator and that operator alone, preventing it from leaking out into other parts of the language.
> 
> Patrick
> 

Yeah, my claim that it "doesn't buy us anything" stemmed from a misconception that arg.foo() could move arg, given let arg: ~A; and fn foo(x: ~A) {...}. I had already forgotten that Rust UFCS was specified differently from D's. To anyone not following, in D it would be a simple re-write to foo(arg) and, in Rust, to foo(&arg).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/4c81d26b/attachment.html>

From rusty.gates at icloud.com  Tue Nov 19 21:42:37 2013
From: rusty.gates at icloud.com (Tommi)
Date: Wed, 20 Nov 2013 07:42:37 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
Message-ID: <EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>


On 2013-11-20, at 7:13, Tommi <rusty.gates at icloud.com> wrote:

> Yeah, my claim that it "doesn't buy us anything" stemmed from a misconception that arg.foo() could move arg, given let arg: ~A; and fn foo(x: ~A) {...}. I had already forgotten that Rust UFCS was specified differently from D's. To anyone not following, in D it would be a simple re-write to foo(arg) and, in Rust, to foo(&arg).

Scratch that. I seem to have different things mixed up now. I found this ticket https://github.com/mozilla/rust/issues/6974 again and it seems I should stand by my initial argument. Let me explain my argument again:

Our problem is that, given let arg: ~A;, seeing only foo(arg) in code doesn't tell us whether arg is moved or borrowed. The proposed solution is that auto-borrowing in that context would be deprecated and thus would require an explicit borrowing: foo(&*arg). Now, given that it seems that the upcoming UFCS would simply re-write arg.foo() to foo(arg), it would mean that seeing only arg.foo() in code doesn't tell us whether arg is moved or borrowed. Thus, the proposed solution would fix only half of the problem.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/6cabde34/attachment-0001.html>

From gaetan at xeberon.net  Wed Nov 20 00:02:49 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 20 Nov 2013 09:02:49 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CAK9U+m2B+eCreVn13-co+Yj2kghaDthvoyz_Q4EeRSfLXt3oQw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>
	<528AC00B.1000909@mozilla.com>
	<CAN1rdEyf4fVQQ6n+BidMUfSrELR1ueBagXOeTEa0XuWmQnEhBg@mail.gmail.com>
	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>
	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>
	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>
	<528AE665.3010000@mozilla.com>
	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>
	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>
	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>
	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>
	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>
	<528B4F72.1070608@gmail.com>
	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>
	<528B5B26.6080305@gmail.com>
	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>
	<CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>
	<528C0EA4.8010008@mozilla.com>
	<CAK9U+m2B+eCreVn13-co+Yj2kghaDthvoyz_Q4EeRSfLXt3oQw@mail.gmail.com>
Message-ID: <CANK7tAE1+ZPx3ce=NNWdCFV-2z9W8FLa2rj3duT0HSi5nVH-4g@mail.gmail.com>

Indeed, that deserve our uttermost respect!
Le 20 nov. 2013 04:04, "Val Markovic" <val at markovic.io> a ?crit :

> On Tue, Nov 19, 2013 at 5:21 PM, Patrick Walton <pcwalton at mozilla.com>wrote:
>
>>
>> I agree that we should change this, but give us some credit: it's only an
>> obvious design mistake now that we've gotten to this point.
>> [...]
>
> The current status is the product of the slow evolution of a design that
>> predated the region and slicing system, and what seems obvious now was not
>> obvious in retrospect.
>
>
> Fair point. I give you guys a lot of credit though, Rust is a wonderful
> language in general. I also admire how willing core Rust devs are to admit
> "ok that was a bad idea, let's try something else." I don't see that every
> day; Rust is better for it.
>
> Please continue being awesome.
>
>
>>
>>
>> Patrick
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/210c30ea/attachment.html>

From philippe.delrieu at free.fr  Wed Nov 20 00:17:40 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 20 Nov 2013 09:17:40 +0100
Subject: [rust-dev] How to cast a @type in a @trait
In-Reply-To: <528BC36E.9070509@mozilla.com>
References: <528BC090.5070003@free.fr> <528BC36E.9070509@mozilla.com>
Message-ID: <528C7024.70404@free.fr>

Thanks you it works in my simple test but I have this error when I add 
it in my program : error: can't find crate for `std`
I try to find why it doesn't work in my program and I found the error 
occurs when I add the extern mod zmq;.

Perhaps I have to build lib zmq with the same flag.

I have another question. Why this flag is not set by default because 
without it you can't really use serialization and io lib?

Philippe

Le 19/11/2013 21:00, Patrick Walton a ?crit :
> On 11/19/13 11:48 AM, Philippe Delrieu wrote:
>> I still struggle with the json API. I try it using encode and decode API
>> and I face a problem.
>> I take this code in the json test case :
>>          let m = @mut MemWriter::new();
>>          f(m as @mut io::Writer);
>> and I have an error :
>> The managed box syntax will be replaced by a library type, and a garbage
>> collector is not yet implemented. Consider using the `std::rc::Rc` type
>> for reference counted pointers.
>
> Add `#[feature(managed_boxes)];` to the top of your crate. The JSON 
> and EBML APIs have not been kept well up to date with idioms used by 
> the current version of Rust and will not work without this feature flag.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From vadimcn at gmail.com  Wed Nov 20 00:30:59 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 20 Nov 2013 00:30:59 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
	<CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
Message-ID: <CADecdi+yNgcSA6C3oc=g6AVNGvACbKSsjg6LBVRKFq4LpxWZ=w@mail.gmail.com>

I found this post<http://smallcultfollowing.com/babysteps/blog/2012/10/01/moves-based-on-type/>by
Niko, and it seems that at the time everyone agreed that implicit
moving
actually makes things more clear.   Why is this different now, only a year
later? :-)

Ok, but serieosly, I allow that this is different for function arguments vs
"regular" code in the function body.  So maybe the right thing to do *is *to
stop moving function parameters by default?



On Tue, Nov 19, 2013 at 5:35 PM, Vadim <vadimcn at gmail.com> wrote:

> If the function is not going to mutate it, I don't really care if it's
> by-ref or by-value.   That's why I said "const T&", not "T&".   Well,
> except for the case when a function caches a reference to something which I
> later mutate.   But borrow checking will prevent that.
>
> I would also be totally fine with letting the compiler figure out how
> immutable arguments are passed (based on data type size, existence of
> destructors, and whatnot).  This might not be the best idea for binary
> compatibility of public APIs, but I don't see why it can't be done with
> crate-private functions.
>
>
>
>
> On Tue, Nov 19, 2013 at 5:07 PM, Ziad Hatahet <hatahet at gmail.com> wrote:
>
>> > Personally I would prefer if & in Rust worked similar to const T& in c++
>>
>> In that case, you would not be able to tell whether a function argument
>> was passed by value or by reference. I actually like this feature about
>> Rust (C# has it too with the `ref` keyword).
>>
>> --
>> Ziad
>>
>>
>> On Tue, Nov 19, 2013 at 4:54 PM, Vadim <vadimcn at gmail.com> wrote:
>>
>>> So why did Rust adopt auto-moving instead of explicit moving?   If the
>>> second example had to be written as foo(move a) there would be no
>>> confusion.   The and the third example should arguably be sort(mut
>>> a.as_mut_slice()).
>>>
>>> Personally I would prefer if & in Rust worked similar to const T& in c++
>>> (i.e. for most intents and purposes you can treat a reference as a value),
>>> otherwise half of the arguments on each function call will have to be
>>> adorned with ampersands.
>>>
>>> Can we have it such that foo(a) would be guaranteed to not mutate or
>>> move a and require "mut" or "move" prefix otherwise?
>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/40a5dfb2/attachment.html>

From igor at mir2.org  Wed Nov 20 00:50:50 2013
From: igor at mir2.org (Igor Bukanov)
Date: Wed, 20 Nov 2013 09:50:50 +0100
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
Message-ID: <CADd11yVcJp+3afB=+oKZqfYLSTH+MRc0oyWdn6w1Ly037+EDFA@mail.gmail.com>

On 20 November 2013 02:07, Ziad Hatahet <hatahet at gmail.com> wrote:
>> Personally I would prefer if & in Rust worked similar to const T& in c++
>
> In that case, you would not be able to tell whether a function argument was
> passed by value or by reference. I actually like this feature about Rust (C#
> has it too with the `ref` keyword).

In the safe code there is no difference if the value is passed via a
copy or as &T. Also as I learned recently the Rust compiler already
optimizes &T parameters into T for small-sized T at --opt-level=3. So
effectively &T parameter became a notation for the most efficient
passing of arguments of type T.

From gaetan at xeberon.net  Wed Nov 20 02:03:10 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 20 Nov 2013 11:03:10 +0100
Subject: [rust-dev] A la python array access
Message-ID: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>

Hello

I'd like to know if you think it could be feasible to have a Python-like
syntax for indices in array and vector?

I find it so obvious and practical.

let i = ~[1, 2, 3, 4, 5]

i[1] returns a the second item ("2")
i[1:] returns ~[2, 3, 4, 5]
i[:-2] return ~[1, 2, 3, 4]
i[-2] returns ~[4, 5]
i[1,-1] returns ~[2, 3, 4]

Thanks !

-----
Gaetan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/da7c307e/attachment.html>

From danielmicay at gmail.com  Wed Nov 20 02:05:44 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 20 Nov 2013 05:05:44 -0500
Subject: [rust-dev] A la python array access
In-Reply-To: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
References: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
Message-ID: <CA+DvKQLssawvun426JitwOq3jqDZoyVguujvNv-ZRL_dghLSYg@mail.gmail.com>

On Wed, Nov 20, 2013 at 5:03 AM, Gaetan <gaetan at xeberon.net> wrote:
> Hello
>
> I'd like to know if you think it could be feasible to have a Python-like
> syntax for indices in array and vector?
>
> I find it so obvious and practical.
>
> let i = ~[1, 2, 3, 4, 5]
>
> i[1] returns a the second item ("2")
> i[1:] returns ~[2, 3, 4, 5]
> i[:-2] return ~[1, 2, 3, 4]
> i[-2] returns ~[4, 5]
> i[1,-1] returns ~[2, 3, 4]
>
> Thanks !
>
> -----
> Gaetan

Slicing sugar could be implemented but it definitely wouldn't allocate
new dynamic arrays.

From dbau.pp at gmail.com  Wed Nov 20 02:08:42 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Wed, 20 Nov 2013 21:08:42 +1100
Subject: [rust-dev] A la python array access
In-Reply-To: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
References: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
Message-ID: <528C8A2A.2010808@gmail.com>

On 20/11/13 21:03, Gaetan wrote:
> Hello
>
> I'd like to know if you think it could be feasible to have a 
> Python-like syntax for indices in array and vector?
>
> I find it so obvious and practical.
>
> let i = ~[1, 2, 3, 4, 5]
>
> i[1] returns a the second item ("2")
> i[1:] returns ~[2, 3, 4, 5]
> i[:-2] return ~[1, 2, 3, 4]
> i[-2] returns ~[4, 5]
> i[1,-1] returns ~[2, 3, 4]
>
> Thanks !
>
> -----
> Gaetan
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


This has been proposed in #4160, and was even mentioned in Niko's recent 
"Treating vectors like any other container" blog post[1]; although, as 
Daniel says, they would return slices (&[T]), not new allocations.

[4160]: https://github.com/mozilla/rust/issues/4160
[1]: 
http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/


Huon
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/bfc6a6a0/attachment.html>

From gaetan at xeberon.net  Wed Nov 20 02:16:42 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 20 Nov 2013 11:16:42 +0100
Subject: [rust-dev] A la python array access
In-Reply-To: <528C8A2A.2010808@gmail.com>
References: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
	<528C8A2A.2010808@gmail.com>
Message-ID: <CANK7tAGupgg8Z9xvhX8LM9ha=+tAVQS8sD-HU9=hAFS7kpVgcw@mail.gmail.com>

actually that was what I was expected, sorry I'm not very confortable with
slices yet.
It should not allocate, indeed, there is no reason. Python doesn't allocate
but the way it handle items, it doesn't really behave like rust's slices

Anyway, I fully back the [4160] change request :)

-----
Gaetan



2013/11/20 Huon Wilson <dbau.pp at gmail.com>

>  On 20/11/13 21:03, Gaetan wrote:
>
> Hello
>
>  I'd like to know if you think it could be feasible to have a Python-like
> syntax for indices in array and vector?
>
>  I find it so obvious and practical.
>
>  let i = ~[1, 2, 3, 4, 5]
>
>  i[1] returns a the second item ("2")
> i[1:] returns ~[2, 3, 4, 5]
> i[:-2] return ~[1, 2, 3, 4]
> i[-2] returns ~[4, 5]
> i[1,-1] returns ~[2, 3, 4]
>
>  Thanks !
>
>  -----
>  Gaetan
>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> This has been proposed in #4160, and was even mentioned in Niko's recent
> "Treating vectors like any other container" blog post[1]; although, as
> Daniel says, they would return slices (&[T]), not new allocations.
>
> [4160]: https://github.com/mozilla/rust/issues/4160
> [1]:
> http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/
>
>
> Huon
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/078612a9/attachment.html>

From masklinn at masklinn.net  Wed Nov 20 02:59:45 2013
From: masklinn at masklinn.net (Masklinn)
Date: Wed, 20 Nov 2013 11:59:45 +0100
Subject: [rust-dev] A la python array access
In-Reply-To: <CANK7tAGupgg8Z9xvhX8LM9ha=+tAVQS8sD-HU9=hAFS7kpVgcw@mail.gmail.com>
References: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
	<528C8A2A.2010808@gmail.com>
	<CANK7tAGupgg8Z9xvhX8LM9ha=+tAVQS8sD-HU9=hAFS7kpVgcw@mail.gmail.com>
Message-ID: <F43E93BF-8453-4663-92EF-A32AE2E08E42@masklinn.net>

On 2013-11-20, at 11:16 , Gaetan <gaetan at xeberon.net> wrote:

> actually that was what I was expected, sorry I'm not very confortable with slices yet.
> It should not allocate, indeed, there is no reason. Python doesn?t allocate but the way it handle items, it doesn?t really behave like rust's slices 

Slicing a list in Python will allocate and return a new list[0]

It does not have to, and you can easily implement a sequence type which
will return a genuine slice object (aka a triple of the parent object,
an offset and a length), but that?s not what list does.

I believe memory views[1] slicing behaves the way lower-level languages
expect. So do numpy arrays.

[0] http://hg.python.org/cpython/file/adb471b9cba1/Objects/listobject.c#l431

[1] http://docs.python.org/2/library/stdtypes.html#memoryview-type

From gaetan at xeberon.net  Wed Nov 20 03:26:13 2013
From: gaetan at xeberon.net (Gaetan)
Date: Wed, 20 Nov 2013 12:26:13 +0100
Subject: [rust-dev] A la python array access
In-Reply-To: <F43E93BF-8453-4663-92EF-A32AE2E08E42@masklinn.net>
References: <CANK7tAErB-V=uy5wuwbwgDJwB0CpqoqYk1=qcOB7+OC585fFpg@mail.gmail.com>
	<528C8A2A.2010808@gmail.com>
	<CANK7tAGupgg8Z9xvhX8LM9ha=+tAVQS8sD-HU9=hAFS7kpVgcw@mail.gmail.com>
	<F43E93BF-8453-4663-92EF-A32AE2E08E42@masklinn.net>
Message-ID: <CANK7tAETKwagwqY8yDPrvZt0SPfrCTgYs92WNCdnY6yyJFewbw@mail.gmail.com>

Hum that would prevent the step != 1 (allowed in python, but i never used
it)
Le 20 nov. 2013 11:59, "Masklinn" <masklinn at masklinn.net> a ?crit :

> On 2013-11-20, at 11:16 , Gaetan <gaetan at xeberon.net> wrote:
>
> > actually that was what I was expected, sorry I'm not very confortable
> with slices yet.
> > It should not allocate, indeed, there is no reason. Python doesn?t
> allocate but the way it handle items, it doesn?t really behave like rust's
> slices
>
> Slicing a list in Python will allocate and return a new list[0]
>
> It does not have to, and you can easily implement a sequence type which
> will return a genuine slice object (aka a triple of the parent object,
> an offset and a length), but that?s not what list does.
>
> I believe memory views[1] slicing behaves the way lower-level languages
> expect. So do numpy arrays.
>
> [0]
> http://hg.python.org/cpython/file/adb471b9cba1/Objects/listobject.c#l431
>
> [1] http://docs.python.org/2/library/stdtypes.html#memoryview-type
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/8aa35f78/attachment.html>

From niko at alum.mit.edu  Wed Nov 20 03:52:27 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 20 Nov 2013 06:52:27 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CADecdi+yNgcSA6C3oc=g6AVNGvACbKSsjg6LBVRKFq4LpxWZ=w@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
	<CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
	<CADecdi+yNgcSA6C3oc=g6AVNGvACbKSsjg6LBVRKFq4LpxWZ=w@mail.gmail.com>
Message-ID: <20131120115227.GB7252@Mr-Bennet>

On Wed, Nov 20, 2013 at 12:30:59AM -0800, Vadim wrote:
> I found this post<http://smallcultfollowing.com/babysteps/blog/2012/10/01/moves-based-on-type/>by
> Niko, and it seems that at the time everyone agreed that implicit
> moving
> actually makes things more clear.   Why is this different now, only a year
> later? :-)

I stand by the arguments I made in that post. My experience at least
has been that implicit moves have been much more pleasant to work with
than explicit ones, and the language is simpler as well.


Niko

From danielmicay at gmail.com  Wed Nov 20 04:14:37 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Wed, 20 Nov 2013 07:14:37 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <20131120115227.GB7252@Mr-Bennet>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<CADecdiKS5U0pkFNjuHjt4EcHRxRsDOm9A5Avp1SBcToj4dhvvw@mail.gmail.com>
	<CAN1rdEyZ55Y8Tp=uj5EEVZhnfdBqFh2eaOwLQZRP88FkuhYk9g@mail.gmail.com>
	<CADecdiKWQTZnyMeSM84etGDM89JEm17V-Qm=tZcByh4Y=tsWvg@mail.gmail.com>
	<CADecdi+yNgcSA6C3oc=g6AVNGvACbKSsjg6LBVRKFq4LpxWZ=w@mail.gmail.com>
	<20131120115227.GB7252@Mr-Bennet>
Message-ID: <CA+DvKQJrNjh0eEqPSU1fVMDkwCi806YvF7N-h5jdTJRBUdhjkg@mail.gmail.com>

On Wed, Nov 20, 2013 at 6:52 AM, Niko Matsakis <niko at alum.mit.edu> wrote:
>
> I stand by the arguments I made in that post. My experience at least
> has been that implicit moves have been much more pleasant to work with
> than explicit ones, and the language is simpler as well.

I agree, and I think this is one of the most compelling features of
the language. The lack of implicit heap allocations is a great example
of Rust being more suited to systems programming than C++. It's also
nice to have the guarantee that every type can be moved or swapped,
since it leads to being able to write very flexible move-only
containers.

From sh4.seo at samsung.com  Wed Nov 20 05:05:04 2013
From: sh4.seo at samsung.com (Sanghyeon Seo)
Date: Wed, 20 Nov 2013 13:05:04 +0000 (GMT)
Subject: [rust-dev] Removing some autoref magic
Message-ID: <23413236.152451384952703988.JavaMail.weblogic@epml08>

First, I am speaking for myself and not my employer.

> The current proposal is to remove all autoref except for function
> invocations and indexing operations. The method of creating &T from ~T
> would be `let foo: &T = foo` or `&*foo`. Vectors and strings can't
> currently benefit from the `&*foo` syntax, but they will hopefully be
> able to do such once DST lands. In the meantime coercion via type
> ascription will work and they also have `as_slice` methods.

I am against this proposal. As I understand, we will still keep
autoref, autoborrow, etc. in method calls. So I don't think inconsistency
argument holds. Neither does local readability argument.

For local readability, which I agree is important, we have naming
conventions naming methods taking &mut self with mut_* and
methods taking by-value self with move_*. (Methods normally take
&self.) And with better tooling, function signature should be locally
accessible to the call site.

I am not in the camp of less compiler magic. Some people
seem to argue for removal of automatic coercions even in method calls,
and I am very much against that idea. Someone's magic is other's
convenience.

As for #10504, perceived asymmetry seems to originate from
the confusion of value and reference. As for inconsistency of
automatic coercions, I propose we add automatic coercions to
return expression, and any other places as we discover other
missing places.

From philippe.delrieu at free.fr  Wed Nov 20 05:15:26 2013
From: philippe.delrieu at free.fr (philippe.delrieu at free.fr)
Date: Wed, 20 Nov 2013 14:15:26 +0100
Subject: [rust-dev] error: cannot move out of dereference of @ pointer
Message-ID: <1384953326.528cb5ee83dfb@imp.free.fr>

I'am still testing the json lib and I try to encode the json using
extra::json::Encoder. The code I use is :
    let mut encoder = extra::json::Encoder(m as @mut Writer);
    test.encode(&mut encoder);
    let st:~[u8] = m.inner();

I have the error : error: cannot move out of dereference of @ pointer

the inner is declared as follow :
    /// Because this takes `self' one could never 'undecorate' a Reader/Writer
    /// that has been boxed. Is that ok? This feature is mostly useful for
    /// extracting the buffer from MemWriter
    fn inner(self) -> T;

My second question is how to convert a ~[u8]  to a ~std ?

Philippe Delrieu


From denis.spir at gmail.com  Wed Nov 20 05:49:23 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 20 Nov 2013 14:49:23 +0100
Subject: [rust-dev] Please simplify the syntax for Great Justice
In-Reply-To: <CAK9U+m2B+eCreVn13-co+Yj2kghaDthvoyz_Q4EeRSfLXt3oQw@mail.gmail.com>
References: <7548192E-7C36-4AF2-8338-D62AC26E3A16@kinostudios.com>	<86ffd9ae-f935-4d77-b0f0-44fa10d0dc54@email.android.com>	<14e16387-8e57-44da-90f5-7fd5fd3fd857@email.android.com>	<78AB9D3F-F814-4E6B-84F1-C04D0B008792@sb.org>	<528AE665.3010000@mozilla.com>	<CA+GmM=x01SfuSGiHZktn4v8MUHmvnzCZgwvmeUvSD=0Dcm61hA@mail.gmail.com>	<CA+DvKQ+8V9oScmO7mLcB+i3dUSprQRMYD99+zmBkKWotps0v-g@mail.gmail.com>	<CANK7tAEjp3bW1w65KV+_MTHH_oAEJWpX5+A7Vb3sBWu-6a4hpg@mail.gmail.com>	<CA+DvKQLGGFaUSVeJrYTbBeUtG=iEjRkejMZ6tDVZ3+ADATY=tw@mail.gmail.com>	<CANK7tAG7---adN+Nyfj_sFZRrv77vyePZ6C9dksp434NzMcWZw@mail.gmail.com>	<528B4F72.1070608@gmail.com>	<CA+DvKQKmus4kv45sK_crSTrj9B2JXVFUPXfBzFeWMR1FML2vSQ@mail.gmail.com>	<528B5B26.6080305@gmail.com>	<CA+DvKQJ6wHpR5WqDo5kriQ9WuBjDCA0dsAqMSHpQVj+BR3KXiA@mail.gmail.com>	<CAK9U+m05EkyAuin-me5LtnCw5_dywCHgUKM0hHZzufJ116dgzg@mail.gmail.com>	<528C0EA4.8010008@mozilla.com>
	<CAK9U+m2B+eCreVn13-co+Yj2kghaDthvoyz_Q4EeRSfLXt3oQw@mail.gmail.com>
Message-ID: <528CBDE3.8080002@gmail.com>

On 11/20/2013 04:03 AM, Val Markovic wrote:
> Fair point. I give you guys a lot of credit though, Rust is a wonderful
> language in general. I also admire how willing core Rust devs are to admit
> "ok that was a bad idea, let's try something else." I don't see that every
> day; Rust is better for it.
>
> Please continue being awesome.

Agree. Thank you all very much for this effort, and for making it "public good".

Denis

From bill_myers at outlook.com  Wed Nov 20 05:51:48 2013
From: bill_myers at outlook.com (Bill Myers)
Date: Wed, 20 Nov 2013 13:51:48 +0000
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
Message-ID: <BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>

Have you considered making deref the default instead and requiring moves to use an explicit "move" keyword?

Basically, from this hypothetical syntax to current one:
- x => &x
- mut x => &mut x
- move x => x

One could even make the & implicit in parameter types in function declarations unless the "move" keyword is used, so we would have (new => old syntax):
- fn(self, ...) => fn(&self, ...)
- fn(mut self, ...) => fn(&mut self, ...)
- fn(move self, ...) => fn(self, ...)

Regarding owned pointers, one could introduce this syntax:
let *x = func_that_gives_owned_pointer()

which makes x a variable of type T referring to the contents of the owned box, and thus derefed to & when passed to a function as above without having to write "*x" in the function call.

One could then add a new "#x" or similar syntax that would get back to the owned pointer.

Not sure if all this is a good idea, just throwing it out there. I actually think keeping autoref/autoderef is probably better.

 		 	   		  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/26794368/attachment.html>

From denis.spir at gmail.com  Wed Nov 20 06:25:59 2013
From: denis.spir at gmail.com (spir)
Date: Wed, 20 Nov 2013 15:25:59 +0100
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>
Message-ID: <528CC677.7030906@gmail.com>

On 11/20/2013 02:51 PM, Bill Myers wrote:
> Have you considered making deref the default instead and requiring moves to use an explicit "move" keyword?
>
> Basically, from this hypothetical syntax to current one:
> - x => &x
> - mut x => &mut x
> - move x => x
>
> One could even make the & implicit in parameter types in function declarations unless the "move" keyword is used, so we would have (new => old syntax):
> - fn(self, ...) => fn(&self, ...)
> - fn(mut self, ...) => fn(&mut self, ...)
> - fn(move self, ...) => fn(self, ...)

I like this proposal, because afaik it matches the common use case.
Also, it would make things easier to learn, understand, and use, for people not 
used to move semantics (even less to it as default / implicit case). I do 
struggle with move; making it explicit would help (also when reading it other 
people's code).

Denis

From philippe.delrieu at free.fr  Wed Nov 20 07:56:13 2013
From: philippe.delrieu at free.fr (philippe.delrieu at free.fr)
Date: Wed, 20 Nov 2013 16:56:13 +0100
Subject: [rust-dev] How to cast a @type in a @trait
In-Reply-To: <528C7024.70404@free.fr>
References: <528BC090.5070003@free.fr> <528BC36E.9070509@mozilla.com>
	<528C7024.70404@free.fr>
Message-ID: <1384962973.528cdb9d4399f@imp.free.fr>

Selon Philippe Delrieu <philippe.delrieu at free.fr>:

> Thanks you it works in my simple test but I have this error when I add
> it in my program : error: can't find crate for `std`
> I try to find why it doesn't work in my program and I found the error
> occurs when I add the extern mod zmq;.
>
> Perhaps I have to build lib zmq with the same flag.

I found the issue. I have to recompile zmq with the last version of rustc.
Extern lib link has changed in the current master trunk and the externfn! macro
disappeared. I have to update rust-zmq to make it compile.
I can send the modified file to the zmq maintener or pull the modif.

Philippe



From pcwalton at mozilla.com  Wed Nov 20 08:27:16 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 20 Nov 2013 08:27:16 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
Message-ID: <528CE2E4.2000709@mozilla.com>

On 11/19/13 9:42 PM, Tommi wrote:
> Our problem is that, given let arg: ~A;, seeing only foo(arg) in code
> doesn't tell us whether arg is moved or borrowed. The proposed solution
> is that auto-borrowing in that context would be deprecated and thus
> would require an explicit borrowing: foo(&*arg). Now, given that it
> seems that the upcoming UFCS would simply re-write arg.foo() to
> foo(arg), it would mean that seeing only arg.foo() in code doesn't tell
> us whether arg is moved or borrowed. Thus, the proposed solution would
> fix only half of the problem.

Again, I don't see this as an argument against the proposal. The dot 
operator is always magical. Magic on one place doesn't justify magic 
everywhere.

Patrick


From pcwalton at mozilla.com  Wed Nov 20 08:28:54 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 20 Nov 2013 08:28:54 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>
Message-ID: <528CE346.4040701@mozilla.com>

On 11/20/13 5:51 AM, Bill Myers wrote:
> Have you considered making deref the default instead and requiring moves
> to use an explicit "move" keyword?

Tried it a year ago. It was incredibly noisy. I don't want to go back to 
that world.

We saw things like:

     let move x = move foo(move y);

Patrick


From pcwalton at mozilla.com  Wed Nov 20 08:29:53 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 20 Nov 2013 08:29:53 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528CC677.7030906@gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>	<BAY170-W555FB1BE3DDE326BF4A0EAF8E60@phx.gbl>
	<528CC677.7030906@gmail.com>
Message-ID: <528CE381.2060309@mozilla.com>

On 11/20/13 6:25 AM, spir wrote:
> I like this proposal, because afaik it matches the common use case.
> Also, it would make things easier to learn, understand, and use, for
> people not used to move semantics (even less to it as default / implicit
> case). I do struggle with move; making it explicit would help (also when
> reading it other people's code).

You have to know moves to use Rust. The noise didn't aid understanding a 
year ago, and I don't think it will now.

Patrick


From pcwalton at mozilla.com  Wed Nov 20 08:37:31 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 20 Nov 2013 08:37:31 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <23413236.152451384952703988.JavaMail.weblogic@epml08>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
Message-ID: <528CE54B.9090302@mozilla.com>

On 11/20/13 5:05 AM, Sanghyeon Seo wrote:
> I am against this proposal. As I understand, we will still keep
> autoref, autoborrow, etc. in method calls. So I don't think inconsistency
> argument holds. Neither does local readability argument.

It is a good point that a true emphasis on consistency between methods 
and functions would have us perform auto-deref and auto-ref on all 
argument positions. Then the LHS of `.` and arguments would truly be 
treated the same way, which dovetails with UFCS pretty nicely.

I'm pretty nervous about performing auto-ref on function arguments, 
though, *especially* `&mut` auto-ref. For some reason I expect that this:

     let mut a = ~["x"];
     a.push("hi");

may mutate `a`, while:

     let mut a = ~["y"];
     push(a, b);

will *not* mutate `a`. Do others have the same expectation?

Patrick


From corey at octayn.net  Wed Nov 20 08:52:47 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 20 Nov 2013 11:52:47 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528CE54B.9090302@mozilla.com>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
	<528CE54B.9090302@mozilla.com>
Message-ID: <CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>

On Wed, Nov 20, 2013 at 11:37 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 11/20/13 5:05 AM, Sanghyeon Seo wrote:
>>
>> I am against this proposal. As I understand, we will still keep
>> autoref, autoborrow, etc. in method calls. So I don't think inconsistency
>> argument holds. Neither does local readability argument.
>
> I'm pretty nervous about performing auto-ref on function arguments, though,
> *especially* `&mut` auto-ref. For some reason I expect that this:
>
>     let mut a = ~["x"];
>     a.push("hi");
>
> may mutate `a`, while:
>
>     let mut a = ~["y"];
>     push(a, b);
>
> will *not* mutate `a`. Do others have the same expectation?
>

I do, and I agree a lot with Niko's arguments from the meeting. I
agree that &* is a bit ugly, but I prefer the ugly syntax to the
ambiguity. I don't find Kevin's argument particularly convincing;
those changes can make your code fail to compile, but *not* to
transparently behave differently (simply by changing the types of the
args).

I'm in favor of the proposal. What we have now isn't that great and
moving to an alternative is good, even if it's not the best. We can
move to something better later.

From ben.striegel at gmail.com  Wed Nov 20 08:59:46 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 20 Nov 2013 11:59:46 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
	<528CE54B.9090302@mozilla.com>
	<CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
Message-ID: <CAAvrL-=FPouhFmw5Va1Z_293pqSfR3OYwSFiFmPwNyLOsVqV4Q@mail.gmail.com>

Obligatory link to Niko's blog post on this topic:
http://smallcultfollowing.com/babysteps/blog/2013/11/20/parameter-coercion-in-rust/

I do agree that explicitness is nice, but too much noise will harm
readability just as much as magic does.

It also doesn't help that the `&*` operator is a bit misleading: it
visually implies a deref that never actually occurs. Could lead to people
naively avoiding borrowing if they think it incurs the cost of a deref, and
just writing APIs to take owned pointers directly.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/9200ff96/attachment.html>

From niko at alum.mit.edu  Wed Nov 20 09:11:45 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 20 Nov 2013 12:11:45 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
Message-ID: <20131120171145.GF11345@Mr-Bennet>

One caveat: this e-mail made it sound as if the proposal were
universally favored at the meeting, but I at least feel conflicted,
though I may not have that clear. I started writing a response but
it got long, so I moved it to a blog post:

http://smallcultfollowing.com/babysteps/blog/2013/11/20/parameter-coercion-in-rust/

I'll just paste the text inline here, starting with the conclusion:

## What should we do?

I think we ought to experiment. It's not too hard to whip up a branch
with the two alternatives and work through the implications. I'm
currently doing the same with more stringent rules around operator
overloading, and the experience has been instructive -- I haven't yet
decided if it's acceptable or not. But that's a topic for another
post.

## Historical background

In the interest of clarity, I wanted to briefly explain some
terminology and precisely what the rules *are*. I refer to "autoref"
as the addition of an implicit `&`: so converting from `T` to `&T`, in
terms of the type. "Autoderef" is the addition of an implicit `*`:
converting from `&T`, `~T`, etc to `T`. Finally, "autoborrow" is the
addition of both a `&` and a `*`, which effectively converts from
`~T`, `&T` etc to `&T`. "Autoslice" is the conversion from `~[..]` and
`&[...]` to `&[...]` -- if we had a DST-based system, autoslice and
autoborrow would be the same thing, but in today's world they are not,
and in fact there is no explicit syntax for slicing.

Currently we apply implicit transformations in the following circumstances:

- For method calls and field accesses (the `.` operator) and indexing
  (`[]`), we will autoderef, autoref, and autoslice the
  receiver. We're pretty aggressive here, happily autoderefing through
  many layers of indirection.  This means that, in the extreme case,
  we can convert from some nested pointer type like `&&@T` to a type
  like `&T`.
  
- For parameter passing, local variable initializers with a declared
  type, and struct field initializers, we apply *coercion*. This is a
  more limited set of transformations. We could and probably should
  apply coercion in a *somewhat* wider set of contexts, notably return
  expressions.
  
Currently we are specifically referring to what the *coercion* rules
ought to be. Nobody is proposing changing the method lookup behavior.
Furthermore, nobody is proposing removing coercion altogether, just
changing the set of coercions we apply.

### Current coercion rules

The current coercion rules are as follows:

  - Autoborrow from `~T` etc to `&T` or `&mut T`.
    - Reborrowing from `&'a T` to `&'b T`, `&'a mut T` to `&'b mut T`,
      which is a special case. See discussion below.
  - Autoslice from `~[T]`, `&[T]`, `[T, ..N]` etc to `&[T]`
  - Convert from `&T` to `*T`
  - Convert from a bare fn type `fn(A) -> R` to a closure type `|A| -> R`

In addition, I believe that we *should* have the rule that we will
convert from a pointer type `&T` to an object type `&Trait` where
`T:Trait`. I have found that making widespread but non-uniform use of
object types without this rule requires a lot of explicit and verbose
casting.

### Slicing

If we had DST, then slicing and borrowing are the same thing. Without
DST, there is in fact no explicit way to "slice" a vector type like
`~[T]` or `[T, ..N]` into a slice `&[N]`. You can call the `slice()`
method, but that in fact relies on the fact that we will "autoslice" a
method receiver. For vectors like `~[N]` and so on, we could implement
`slice` methods manually, but fixed-length vectors like `[T, ..N]` are
particularly troublesome because there is no way to do such a thing.

### Reborrowing

One of the less obvious but more important coercions is what I call
*reborrowing*, though it's really a special case of autoborrow. The
idea here is that when we see a parameter of type `&'a T` or `&'a mut
T` we always "reborrow" it, effectively converting to `&'b T` or `&'b
mut T`.  While both are borrowed pointers, the reborrowed version has
a different (generally shorter) lifetime. Let me give an example where
this becomes important:

    fn update(x: &mut int) {
        *x += 1;
    }

    fn update_twice(x: &mut int) {
        update(x);
        update(x);
    }
    
In fact, thanks to auto-borrowing, the second function is implicitly
transformed to:

    fn update_twice(x: &mut int) {
        update(&mut *x);
        update(&mut *x);
    }

This is needed because `&mut` pointers are *affine*, meaning that
otherwise the first call to `update(x)` would move the pointer `x`
into the callee, leading to an error during the second call. The
reborrowing however means that we are in fact not moving `x` but
rather a temporary pointer (let's call it `y`). So long as `y` exists,
access to `x` is disabled, so this is very similar to giving `x` away.
However, lifetime inference will find that the lifetime of this
temporary pointer `y` is limited to the first call to `update` itself,
and so after the call access to `x` will be restored. The borrow
checker rules permit reborrowing under the same conditions in which a
move would be allowed, so this transformation never introduces errors.

### Interactions with inference

One interesting aspect of coercion is its interaction with inference.
For coercion rules to make sense, we need to know all the types
involved. But in some cases we are in the process of inferring the
types, and the decision of whether or not to coerce would in fact
affect the results of that inference. In such cases we currently do
not coerce. This can occasionally lead to surprising results. Here is
a relatively simple example:

    fn foo<T>(x: T, y: T) -> T { ... }
    
    fn bar(x: ~U, y: ~U) {
    
        // This would be legal, and would imply that `z` has type `~U`.
        let z = foo::<~U>(x, y);
        
        // This would be legal, because the arguments are autoborrowed,
        // and would imply that `z` has type `&U`.
        let z = foo::<&U>(x, y);
        
        // Here we are inferring value of `T`. Which version is intended?
        let z = foo(x, y);
    
    }
    
Currently, the coercion rules would favor the first intepretation. But
there is ambiguity here. And in more advanced cases, the decision of
whether or not to coerce might depend on peculiarities of our type
inference process. To be honest, though, this rarely seems to be a
problem in practice, though I'm sure it arises.

## What are the complaints about the system?

I'll give my personal take. The current coercion rules date from the
early days of the region system. I did not understand then how Rust
would ultimately be used, nor had we adopted the current mutability
rules. The rules were designed around the idea of *pointers* -- so
they convert between any pointer type to a borrowed pointer. But since
then, I've stopped thinking of `~T` as a pointer type and started
thinking of it as a value type. The choice between `T` and `~T` is
really an efficiency tradeoff; the two types behave similarly in most
respects. Except parameter coercion. Speaking personally, this unequal
treatment of `T` and `~T` is what bothers me the most -- but whether
it should be rectified by making `T` automatically coercable to `&T`
or by disallowing `~T` from being coerced to `&T` is unclear.

An argument in favor of limiting coercion is that it makes it easier
to read and follow a function independent of its callees. For example,
when you see some code like the following, you don't know whether `x`
is moved or autosliced:

    let x = ~[1, 2, 3];
    foo(x); // Does this consume `x`, or auto-slice it?

Automatic coercions also interact in an unfortunate way with inherited
mutability, in that they permit "silent" mutability:

    let mut x = ~[1, 2, 3];
    sort(x); // This mutates x in place
    
The reason that this surprises me is precisely because I've stopped
thinking of a `~[int]` array as a pointer -- in other languages, it
wouldn't surprise me that when I give a pointer to a function, it may
mutate the data that pointer points at. But because I think of a
`~[int]` as a value, I feel like `sort(x)` shouldn't be able to mutate
"the value" `x` without some explicit acknowledgement (e.g.,
`sort(&mut *x)`). (Note that when the rules were first created,
mutability was not inherited, so you would have had to declare `let x
= ~mut [1, 2, 3]`, in which case the fact that `sort` mutates `x`
feels more natural to me.)

When discussing "silent mutability", it's worth pointing out that C++
references make this sort of mutation implicit as well, so it's hardly
without precedent. I've never considered this to be a particularly
good thing, though, even if it can be convenient.

It's also worth pointing out that, whatever change we make, it's not
*actually* possible to reason about a function independently of its
callees, for a variety of reasons: there are still some coercions that
remain; method notation has a number of conveniences including autoref
(with mutation!); type inference might be affected by the parameter
types of a function; and so on. Also, if we had an IDE and not just a
simple emacs mode, of course, autorefs and so on could be indicated
using syntax highlighting. But we don't have an IDE and I wouldn't
consider that likely in the short term. Besides, I dig emacs. ;)

## What are the proposed changes?

The issue discusses two possible changes. We could either *limit*
coercion by removing autoborrowing (but keeping reborrowing), or we
could *expand* coercion by including autoref.

Limiting coercion has appeal because less magic is, all other things
being equal, good. We've been bitten by attempting to be too smart.
It often makes the system harder for new users to understand, since it
makes errors less predictable, and it means that distinct concepts
(like `T` vs `~T`) get muddled together. On the other hand, it makes
it easier to get started, and reduces overhead for advanced users.

Expanding coercion has appeal because it'd lower notational overhead.
This is particularly true around generic types like `HashMap` that make
extensive use of borrowed pointers. For example, to look up a key
in a hash map, one typically writes `map.find(&key)` today. If we
expanded coercion to include autoref, one would write `map.find(key)`,
and the borrow would be implicit.

Independently, we could *tweak* coercion by removing the ability to
autoborrow to an `&mut T` (except from another `&mut T`). This is
probably a good idea.

I am concerned that if we remove autoborrow the notational overhead
will be too large, I am also annoyed that we must keep at least the
autoslicing from fixed-length vectors to slices, since we have no
other way to achieve that. (Unless we added a [slice operator][op], as
discussed in another blog post.) *But* I am very sympathetic to the
less magic angle -- and it's the conservative path as well, since as
we can always add magic back later if it proves to be necessary.

[op]: http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/


From niko at alum.mit.edu  Wed Nov 20 09:14:08 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 20 Nov 2013 12:14:08 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528B8173.9060201@mozilla.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com>
Message-ID: <20131120171408.GG11345@Mr-Bennet>

On Tue, Nov 19, 2013 at 07:19:15AM -0800, Patrick Walton wrote:
> The liveness analysis uses the infinite nature of `loop`, and it was
> felt that special-casing the `true` boolean like Java does is a hack.

I personally like `loop`. It reads nicely. It happens quite frequently
that I have a loop that works out best if I test the condition in the
middle, rather than the front or the end, or where the condition is
something quite involved; in such situations, `loop { ... }` is
perfect, and `while true { ... }` always feels second-class. I
recognize this is silly of me, though. :)



Niko

From thadguidry at gmail.com  Wed Nov 20 09:19:35 2013
From: thadguidry at gmail.com (Thad Guidry)
Date: Wed, 20 Nov 2013 11:19:35 -0600
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
	<528CE54B.9090302@mozilla.com>
	<CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
Message-ID: <CAChbWaOz-4YakdKqMTXOZq25gZJM6FZcVBzXeJGBmTfBNO4oJA@mail.gmail.com>

>
>
> > may mutate `a`, while:
> >
> >     let mut a = ~["y"];
> >     push(a, b);
> >
> > will *not* mutate `a`. Do others have the same expectation?
> >
>

But isn't there a missing context there ?  That 'a' does not necessarily
have to be mutable globally ?  But could be constrained... only in the
defined functions, or...traits...or ?

-- 
-Thad
+ThadGuidry <https://www.google.com/+ThadGuidry>
Thad on LinkedIn <http://www.linkedin.com/in/thadguidry/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/48ac2bd6/attachment.html>

From qwertie256 at gmail.com  Wed Nov 20 10:23:57 2013
From: qwertie256 at gmail.com (David Piepgrass)
Date: Wed, 20 Nov 2013 11:23:57 -0700
Subject: [rust-dev] Removing some autoref magic
Message-ID: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>

I'm wondering something. Have the Rust developers considered the
possibility of using references instead of pointers? It seems to me
that this would eliminate a lot of the need for "autoderef". Now I'm
not well-equipped to talk about Rust (some of the rules I am totally
ignorant about, e.g. I know rust has a "ref" keyword but the tutorial
does not mention it) so let me talk about C++ instead.

C++, of course, has references, which are exactly like pointers except
they are always implicitly dereferenced:

int y = 123;
int* x1 = &y; // *x1 == y &&  x1 == &y
int& x2 = y;  //  x2 == y && &x2 == &y

In fact, with one small tweak, C++ could have entirely eliminated the
need for pointers (except array pointers), and references could have
been used for everything except arrays. The reason references cannot
replace pointers is that the pointer--the true identity of a
reference--is immutable. But that's easily fixable though, by defining
&x2 as an lvalue:

x1 = &z;
&x2 = &z; // Aha! We've changed the pointer inside the reference

If the second line were legal, then references could do everything
that pointers could do; in that case I think that, for consistency,
people would have eventually standardized on using references for
everything that doesn't require pointer arithmetic (i.e. arrays).
Instead we have this situation where some functions take (non-const)
T& and others take T*, so sometimes you have to call functions with
"&foo" and other times it's just "foo", and the presence or absence of
"&" doesn't signify anything important (for example, it doesn't tell
you whether the callee mutates "foo" or not)

It seems to me that the majority of languages have recognized that
references are easier to work with than pointers, and not just because
you can write "foo.f()" instead of "foo->f()". That is, I don't think
auto-deref (where foo.f() means (*foo).f()) is enough to eliminate the
pain of working with pointers instead of references.
Would it help to define ~T, &T and @T as reference types rather than
pointer types? I'm sure there are some obvious objections, but perhaps
the problems could be ironed out by someone with a better grasp of
Rust.
I'd also like to comment on the removal of "move". While I recognize
explicit moves everywhere might be inconvenient, I have noticed that
newbies on the list (including myself) are often confused by them.
Would a compromise be in order, in which moves are implicit except
when passing parameters to methods? I like Bill Byers' suggestion for
call-site parameters of the form "move x", "mut x" and just "x" for
implicit copy / borrow. Patrick mentioned the annoyance of writing

 let move x = move foo(move y);

but


 let x = foo(move y);

doesn't sound so onerous, and it says something important about foo()
that someone reading the code might not realize.

Everyone's had their fair share of issues with autoref and autoderef,

and it's worth considering removing certain portions of it from the

compiler. The discussion around this has been rooted in the past, but

has recently been brought up as part of

https://github.com/mozilla/rust/issues/10504.


> The current proposal is to remove all autoref except for function

invocations and indexing operations. The method of creating &T from ~T

would be `let foo: &T = foo` or `&*foo`. Vectors and strings can't

currently benefit from the `&*foo` syntax, but they will hopefully be

able to do such once DST lands. In the meantime coercion via type

ascription will work and they also have `as_slice` methods.


> There are a few reasons backing this proposal:


> 1. It's inconsistent to have magical autoref in some places, but not

in other places.

2. The camp of "less compiler magic is better" can fly their flag over

this change.

3. Code readability does not necessarily benefit from autoref on arguments:


>   let a = ~Foo;

  foo(a); // reading this code looks like it moves `a`

  fn foo(_: &Foo) {} // ah, nevermind, it doesn't move `a`!


>   let mut a = ~[ ... ];

  sort(a); // not only does this not move `a`, but it mutates it!


>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/913a0d01/attachment.html>

From steven099 at gmail.com  Wed Nov 20 10:26:55 2013
From: steven099 at gmail.com (Steven Blenkinsop)
Date: Wed, 20 Nov 2013 13:26:55 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528CE54B.9090302@mozilla.com>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
	<528CE54B.9090302@mozilla.com>
Message-ID: <CANjmGJt2Nr_XRcrAUJXDJ29HkggeUk8s2S+muO5ty-cAGUdjVg@mail.gmail.com>

If the concern is mutability rather than details of the indirection used,
then one option would be:

let mut a = ~["y"];
push(mut a, b);

It would be a bit odd to do:

let mut x = 0;
incr(mut x);

instead of:

incr(&mut x);

as long as you're keeping a strict pointer vs. value mental model, but part
of the motivation of considering this in the first place is a weakening of
this model, so I'm not sure how it ends up on balance. Sort of starts to
seem like passing modes on the caller side, though still implemented using
explicit memory layout on the callee side and autoref/autoborrow acting as
the bridge.

On Wednesday, November 20, 2013, Patrick Walton wrote:

> On 11/20/13 5:05 AM, Sanghyeon Seo wrote:
>
>> I am against this proposal. As I understand, we will still keep
>> autoref, autoborrow, etc. in method calls. So I don't think inconsistency
>> argument holds. Neither does local readability argument.
>>
>
> It is a good point that a true emphasis on consistency between methods and
> functions would have us perform auto-deref and auto-ref on all argument
> positions. Then the LHS of `.` and arguments would truly be treated the
> same way, which dovetails with UFCS pretty nicely.
>
> I'm pretty nervous about performing auto-ref on function arguments,
> though, *especially* `&mut` auto-ref. For some reason I expect that this:
>
>     let mut a = ~["x"];
>     a.push("hi");
>
> may mutate `a`, while:
>
>     let mut a = ~["y"];
>     push(a, b);
>
> will *not* mutate `a`. Do others have the same expectation?
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/2637dc0c/attachment.html>

From pcwalton at mozilla.com  Wed Nov 20 10:27:49 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Wed, 20 Nov 2013 10:27:49 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>
References: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>
Message-ID: <528CFF25.3030902@mozilla.com>

On 11/20/13 10:23 AM, David Piepgrass wrote:
>
> I'm wondering something. Have the Rust developers considered the possibility of using references instead of pointers? It seems to me that this would eliminate a lot of the need for "autoderef". Now I'm not well-equipped to talk about Rust (some of the rules I am totally ignorant about, e.g. I know rust has a "ref" keyword but the tutorial  does not mention it) so let me talk about C++ instead.
>
> C++, of course, has references, which are exactly like pointers except they are always implicitly dereferenced:
>
> int y = 123;
> int* x1 = &y; // *x1 == y &&  x1 == &y
> int& x2 = y;  //  x2 == y && &x2 == &y
>
> In fact, with one small tweak, C++ could have entirely eliminated the need for pointers (except array pointers), and references could have been used for everything except arrays. The reason references cannot replace pointers is that the pointer--the true identity of a reference--is immutable. But that's easily fixable though, by defining &x2 as an lvalue:
>
>
> x1 = &z;
> &x2 = &z; // Aha! We've changed the pointer inside the reference
>
> If the second line were legal, then references could do everything that pointers could do; in that case I think that, for consistency, people would have eventually standardized on using references for everything that doesn't require pointer arithmetic (i.e. arrays). Instead we have this situation where some functions take (non-const) T& and others take T*, so sometimes you have to call functions with "&foo" and other times it's just "foo", and the presence or absence of "&" doesn't signify anything important (for example, it doesn't tell you whether the callee mutates "foo" or not)

This is orthogonal, and I don't want to make that change. I like the 
explicitness of pointers.

> It seems to me that the majority of languages have recognized that references are easier to work with than pointers, and not just because you can write "foo.f()" instead of "foo->f()". That is, I don't think auto-deref (where foo.f() means (*foo).f()) is enough to eliminate the pain of working with pointers instead of references.

This is because in most languages all object types are reference types 
and they rely on a GC, following Lisp.

> Would it help to define ~T, &T and @T as reference types rather than pointer types? I'm sure there are some obvious objections, but perhaps the problems could be ironed out by someone with a better grasp of Rust.

Doesn't work with custom smart pointers.

> I'd also like to comment on the removal of "move". While I recognize explicit moves everywhere might be inconvenient, I have noticed that newbies on the list (including myself) are often confused by them. Would a compromise be in order, in which moves are implicit except when passing parameters to methods? I like Bill Byers' suggestion for call-site parameters of the form "move x", "mut x" and just "x" for implicit copy / borrow. Patrick mentioned the annoyance of writing
>
>   let move x = move foo(move y);
>
> but
>
>
>   let x = foo(move y);
>
> doesn't sound so onerous, and it says something important about foo() that someone reading the code might not realize.

-1. It'd be inconsistent to require it only in parameter position.

Patrick

From banderson at mozilla.com  Wed Nov 20 10:37:03 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 20 Nov 2013 10:37:03 -0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <20131120171408.GG11345@Mr-Bennet>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>	<528B44D0.6080401@gmail.com>	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>	<528B8173.9060201@mozilla.com>
	<20131120171408.GG11345@Mr-Bennet>
Message-ID: <528D014F.3040406@mozilla.com>

On 11/20/2013 09:14 AM, Niko Matsakis wrote:
> On Tue, Nov 19, 2013 at 07:19:15AM -0800, Patrick Walton wrote:
>> The liveness analysis uses the infinite nature of `loop`, and it was
>> felt that special-casing the `true` boolean like Java does is a hack.
> I personally like `loop`. It reads nicely. It happens quite frequently
> that I have a loop that works out best if I test the condition in the
> middle, rather than the front or the end, or where the condition is
> something quite involved; in such situations, `loop { ... }` is
> perfect, and `while true { ... }` always feels second-class. I
> recognize this is silly of me, though. :)
>
>

I also adore `loop` and rarely use `while`. I write code like this 
constantly:

loop {
     match port.recv() {
         case DoSomething => { }
         case Exit => break
     }
}

From banderson at mozilla.com  Wed Nov 20 10:37:39 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Wed, 20 Nov 2013 10:37:39 -0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528D014F.3040406@mozilla.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>	<528B44D0.6080401@gmail.com>	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>	<528B8173.9060201@mozilla.com>
	<20131120171408.GG11345@Mr-Bennet> <528D014F.3040406@mozilla.com>
Message-ID: <528D0173.1040706@mozilla.com>

On 11/20/2013 10:37 AM, Brian Anderson wrote:
> On 11/20/2013 09:14 AM, Niko Matsakis wrote:
>> On Tue, Nov 19, 2013 at 07:19:15AM -0800, Patrick Walton wrote:
>>> The liveness analysis uses the infinite nature of `loop`, and it was
>>> felt that special-casing the `true` boolean like Java does is a hack.
>> I personally like `loop`. It reads nicely. It happens quite frequently
>> that I have a loop that works out best if I test the condition in the
>> middle, rather than the front or the end, or where the condition is
>> something quite involved; in such situations, `loop { ... }` is
>> perfect, and `while true { ... }` always feels second-class. I
>> recognize this is silly of me, though. :)
>>
>>
>
> I also adore `loop` and rarely use `while`. I write code like this 
> constantly:
>
> loop {
>     match port.recv() {
>         case DoSomething => { }
>         case Exit => break
>     }
> }

Of course, `case` doesn't mean anything in this language...

From kevin at sb.org  Wed Nov 20 10:46:37 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 20 Nov 2013 10:46:37 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
References: <23413236.152451384952703988.JavaMail.weblogic@epml08>
	<528CE54B.9090302@mozilla.com>
	<CA++BO6Su1qRveAPXwJ6c+CbTzwxqpPzo4nbh2an2tEsA+Yr0Jg@mail.gmail.com>
Message-ID: <372AD236-75A6-4D7C-A263-53A75D9126CA@sb.org>

On Nov 20, 2013, at 8:52 AM, Corey Richardson <corey at octayn.net> wrote:

> I do, and I agree a lot with Niko's arguments from the meeting. I
> agree that &* is a bit ugly, but I prefer the ugly syntax to the
> ambiguity. I don't find Kevin's argument particularly convincing;
> those changes can make your code fail to compile, but *not* to
> transparently behave differently (simply by changing the types of the
> args).

Sure they can.

	fn foo(_: int) {}
	let mut x = 0;
	foo(x);
	x -= 1;
	println!("{}", x);

prints -1. Change the first line to

	fn foo(_: uint) {}

and now this prints 18446744073709551615 (on my 64-bit machine).

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/f84264d5/attachment.html>

From vadimcn at gmail.com  Wed Nov 20 11:31:40 2013
From: vadimcn at gmail.com (Vadim)
Date: Wed, 20 Nov 2013 11:31:40 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528CFF25.3030902@mozilla.com>
References: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>
	<528CFF25.3030902@mozilla.com>
Message-ID: <CADecdi+WYXKVRL9jELACp34-L0w0ztbXfPzotFycrDWz+Q20pw@mail.gmail.com>

On Wed, Nov 20, 2013 at 10:27 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/20/13 10:23 AM, David Piepgrass wrote:
>

 <snip>


>  It seems to me that the majority of languages have recognized that
>> references are easier to work with than pointers, and not just because you
>> can write "foo.f()" instead of "foo->f()". That is, I don't think
>> auto-deref (where foo.f() means (*foo).f()) is enough to eliminate the pain
>> of working with pointers instead of references.
>>
>
> This is because in most languages all object types are reference types and
> they rely on a GC, following Lisp.
>

But const references work out pretty well in C++, and it'd be hard to
accuse C++ of relying on GC.



> Would it help to define ~T, &T and @T as reference types rather than
>> pointer types? I'm sure there are some obvious objections, but perhaps the
>> problems could be ironed out by someone with a better grasp of Rust.
>>
>
> Doesn't work with custom smart pointers.
>

I'm sure something can be worked out for smart pointers with the help of
some kind of "AutoDeref" trait.



I'd also like to comment on the removal of "move". While I recognize
>> explicit moves everywhere might be inconvenient, I have noticed that
>> newbies on the list (including myself) are often confused by them. Would a
>> compromise be in order, in which moves are implicit except when passing
>> parameters to methods? I like Bill Byers' suggestion for call-site
>> parameters of the form "move x", "mut x" and just "x" for implicit copy /
>> borrow. Patrick mentioned the annoyance of writing
>>
>>   let move x = move foo(move y);
>>
>> but
>>
>>
>>   let x = foo(move y);
>>
>> doesn't sound so onerous, and it says something important about foo()
>> that someone reading the code might not realize.
>>
>
> -1. It'd be inconsistent to require it only in parameter position.
>

Well, it *would* be kind of consistent with Rust's policy "type inference
everywhere, except in function parameters".

Also, - look at this thread - people are concerned about ambiguous
mutability and moved-ness properties of function parameters, not about
ambiguity of the level of indirection.

I think that reference semantics for pointers combined with "foo(mut x);
foo(move y)';" would address the former while not introducing more syntax
noise required to disambiguate the latter.

Vadim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/24548644/attachment.html>

From niko at alum.mit.edu  Wed Nov 20 11:46:12 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Wed, 20 Nov 2013 14:46:12 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>
References: <CAHuo6ZAC5BoU3omDzpu03wqOgtSpcnunhSyiMh6wv3ef2-0YMg@mail.gmail.com>
Message-ID: <20131120194612.GB2428@Mr-Bennet>

On Wed, Nov 20, 2013 at 11:23:57AM -0700, David Piepgrass wrote:
> I'm wondering something. Have the Rust developers considered the
> possibility of using references instead of pointers? It seems to me
> that this would eliminate a lot of the need for "autoderef". Now I'm
> not well-equipped to talk about Rust (some of the rules I am totally
> ignorant about, e.g. I know rust has a "ref" keyword but the tutorial
> does not mention it) so let me talk about C++ instead.

I've thought about it, yes. When first designing the system, we were
aiming for C-like semantics, which expose the underlying machinery of
the computer more clearly. But I've since come to appreciate C++
references as well, though they are the poster child for creating
invisible links between caller and callee.

It's not entirely clear to me how C++ like references combine with
type inference, particularly the H-M-like variant we are using now.
In C++, there is no *operator* to create (or dereference) a reference,
instead it is driven implicitly by type coercion (the very topic under
discussion, in fact). Since C++ has such limited inference, this works
out reasonably OK, but in Rust I imagine it'd be more troublesome.

For example:

    let arr = ~[1, 2, 3];
    let v = ~[];
    v.push(arr[0]);
    v.push(arr[1]);
    v.push(arr[2]);

I could legally infer the type of `v` to be either `~[int]` or
`~[&int]` here, the meaning is very different, and there is no real
way for the user to be explicit about the difference other than
supplying some type annotations.

We're not immune to this. Our own coercions also potentially interact
with inference. They are relatively limited, though, and we tend to
have explicit operators as well, which helps. [1]



Niko

[1] See the "interactions with inference" section in my post. :)



From hatahet at gmail.com  Wed Nov 20 12:03:59 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 20 Nov 2013 12:03:59 -0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528D0173.1040706@mozilla.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com> <528D0173.1040706@mozilla.com>
Message-ID: <CAN1rdEwQrnbi48Su6mRgrYR34_Q8ie8H4o-xUOhF8sw61R1vWA@mail.gmail.com>

On Wed, Nov 20, 2013 at 10:37 AM, Brian Anderson <banderson at mozilla.com>wrote:

> Of course, `case` doesn't mean anything in this language...
>

Hmm, Scala? ;)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/546ad149/attachment.html>

From illissius at gmail.com  Wed Nov 20 12:33:15 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 20 Nov 2013 21:33:15 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <528D014F.3040406@mozilla.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
Message-ID: <CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>

On Wed, Nov 20, 2013 at 7:37 PM, Brian Anderson <banderson at mozilla.com>wrote:

> On 11/20/2013 09:14 AM, Niko Matsakis wrote:
>
>> On Tue, Nov 19, 2013 at 07:19:15AM -0800, Patrick Walton wrote:
>>
>>> The liveness analysis uses the infinite nature of `loop`, and it was
>>> felt that special-casing the `true` boolean like Java does is a hack.
>>>
>> I personally like `loop`. It reads nicely. It happens quite frequently
>> that I have a loop that works out best if I test the condition in the
>> middle, rather than the front or the end, or where the condition is
>> something quite involved; in such situations, `loop { ... }` is
>> perfect, and `while true { ... }` always feels second-class. I
>> recognize this is silly of me, though. :)
>>
>>
>>
> I also adore `loop` and rarely use `while`. I write code like this
> constantly:
>
> loop {
>     match port.recv() {
>         case DoSomething => { }
>         case Exit => break
>
>     }
> }
>

This is an even sillier idea, but then what about keeping `loop` and
dropping `while`?




>  _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/2950472c/attachment.html>

From ben.striegel at gmail.com  Wed Nov 20 12:56:23 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Wed, 20 Nov 2013 15:56:23 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
Message-ID: <CAAvrL-=SzJcXCTWxfAzvm2ySfSZLUfx7YfSzUkcvJJ4RK_5U1Q@mail.gmail.com>

> This is an even sillier idea, but then what about keeping `loop` and
dropping `while`?

I'm not sure this is possible to disambiguate in the grammar. You'd have to
be able to tell the difference between the infinite form:

    loop <block>

...and the conditional form:

    loop <expr> <block>

...while keeping in mind that <expr> can also be a <block>.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/b5ae178a/attachment.html>

From illissius at gmail.com  Wed Nov 20 13:13:31 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Wed, 20 Nov 2013 22:13:31 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CAAvrL-=SzJcXCTWxfAzvm2ySfSZLUfx7YfSzUkcvJJ4RK_5U1Q@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
	<CAAvrL-=SzJcXCTWxfAzvm2ySfSZLUfx7YfSzUkcvJJ4RK_5U1Q@mail.gmail.com>
Message-ID: <CAPNUp08PuoomYba4EY93ZwOtv1qPxvU0JcV6kV_q5y1cyea8PQ@mail.gmail.com>

Hmm? I think you think I meant that `loop` should accept a condition in
front of the loop, like `while`? In fact my idea was sillier: just replace
all instances of `while foo { bar }` with

    loop {
        if !foo { break }
        bar
    }


On Wed, Nov 20, 2013 at 9:56 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> > This is an even sillier idea, but then what about keeping `loop` and
> dropping `while`?
>
> I'm not sure this is possible to disambiguate in the grammar. You'd have
> to be able to tell the difference between the infinite form:
>
>     loop <block>
>
> ...and the conditional form:
>
>     loop <expr> <block>
>
> ...while keeping in mind that <expr> can also be a <block>.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/5db06dd7/attachment.html>

From gaetan at xeberon.net  Wed Nov 20 15:00:00 2013
From: gaetan at xeberon.net (Gaetan)
Date: Thu, 21 Nov 2013 00:00:00 +0100
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CAPNUp08PuoomYba4EY93ZwOtv1qPxvU0JcV6kV_q5y1cyea8PQ@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
	<CAAvrL-=SzJcXCTWxfAzvm2ySfSZLUfx7YfSzUkcvJJ4RK_5U1Q@mail.gmail.com>
	<CAPNUp08PuoomYba4EY93ZwOtv1qPxvU0JcV6kV_q5y1cyea8PQ@mail.gmail.com>
Message-ID: <CANK7tAH7U6+UDQ4POzY0iPOr+Z2VayX+BDKruXLTjjx0utfM1w@mail.gmail.com>

Let stick to the semantic:
- while (<this condition is true>) = execute until this condition becomes
false
- loop = make a loop until a manual break = while true.

However, i think the compiler should check that there is an exit condition
in 'loop' block. I hate reading code with "while true" without exit cond,
this is the kind of evilness that shouldnt exist in rust!

And why not preventing any 'break' condition in 'while' block? Having a
"pure" while construction can make the compiler happy (better optimisation?)
Le 20 nov. 2013 22:13, "G?bor Lehel" <illissius at gmail.com> a ?crit :

> Hmm? I think you think I meant that `loop` should accept a condition in
> front of the loop, like `while`? In fact my idea was sillier: just replace
> all instances of `while foo { bar }` with
>
>     loop {
>         if !foo { break }
>         bar
>     }
>
>
> On Wed, Nov 20, 2013 at 9:56 PM, Benjamin Striegel <ben.striegel at gmail.com
> > wrote:
>
>> > This is an even sillier idea, but then what about keeping `loop` and
>> dropping `while`?
>>
>> I'm not sure this is possible to disambiguate in the grammar. You'd have
>> to be able to tell the difference between the infinite form:
>>
>>     loop <block>
>>
>> ...and the conditional form:
>>
>>     loop <expr> <block>
>>
>> ...while keeping in mind that <expr> can also be a <block>.
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> --
> Your ship was destroyed in a monadic eruption.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131121/5a8eef89/attachment-0001.html>

From rusty.gates at icloud.com  Wed Nov 20 17:47:03 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 21 Nov 2013 03:47:03 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <528CE2E4.2000709@mozilla.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
Message-ID: <E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>

On 2013-11-20, at 18:27, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/19/13 9:42 PM, Tommi wrote:
>> Our problem is that, given let arg: ~A;, seeing only foo(arg) in code
>> doesn't tell us whether arg is moved or borrowed. The proposed solution
>> is that auto-borrowing in that context would be deprecated and thus
>> would require an explicit borrowing: foo(&*arg). Now, given that it
>> seems that the upcoming UFCS would simply re-write arg.foo() to
>> foo(arg), it would mean that seeing only arg.foo() in code doesn't tell
>> us whether arg is moved or borrowed. Thus, the proposed solution would
>> fix only half of the problem.
> 
> Again, I don't see this as an argument against the proposal. The dot operator is always magical. Magic on one place doesn't justify magic everywhere.
> 
> Patrick
> 

The goal of the proposal is to disambiguate code by forcing programmers to write foo(&*arg) instead of foo(arg). But I claim that the proposal will at least partly fail to achieve that goal because programmers will simply resort to writing arg.foo() rather than foo(&*arg), and we finish where we started.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131121/d1317454/attachment.html>

From rusty.gates at icloud.com  Wed Nov 20 17:58:40 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 21 Nov 2013 03:58:40 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
Message-ID: <9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>

While I'm trying to argue why the proposed solution is not a full solution to the proposed problem, I don't even think that the proposed problem is a problem. Here's why: if you make a call foo(arg) and never use arg after that, then you don't care if arg gets moved or borrowed. And if you try to use arg afterwards and foo did in fact move it previously, then your IDE is going to tell you about it by drawing a red squiggly line under that incorrect use of arg.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131121/ba498f97/attachment.html>

From tkuehn at cmu.edu  Wed Nov 20 17:59:41 2013
From: tkuehn at cmu.edu (Tim Kuehn)
Date: Wed, 20 Nov 2013 20:59:41 -0500
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
Message-ID: <CACVDHKmJ-7x9mM0rMKzSnpst-Nwdw6j9WB0n7NJyW4oonjHhzg@mail.gmail.com>

This strikes me as a good point. I think the incongruity this would create
between functions and methods -- along with the additional syntactic burden
-- could lead to the use of functions feeling second class in some sense.
Also, how would static methods be treated?

Cheers,
Tim


On Wed, Nov 20, 2013 at 8:47 PM, Tommi <rusty.gates at icloud.com> wrote:

> On 2013-11-20, at 18:27, Patrick Walton <pcwalton at mozilla.com> wrote:
>
> On 11/19/13 9:42 PM, Tommi wrote:
>
> Our problem is that, given let arg: ~A;, seeing only foo(arg) in code
> doesn't tell us whether arg is moved or borrowed. The proposed solution
> is that auto-borrowing in that context would be deprecated and thus
> would require an explicit borrowing: foo(&*arg). Now, given that it
> seems that the upcoming UFCS would simply re-write arg.foo() to
> foo(arg), it would mean that seeing only arg.foo() in code doesn't tell
> us whether arg is moved or borrowed. Thus, the proposed solution would
> fix only half of the problem.
>
>
> Again, I don't see this as an argument against the proposal. The dot
> operator is always magical. Magic on one place doesn't justify magic
> everywhere.
>
> Patrick
>
>
> The goal of the proposal is to disambiguate code by forcing programmers to
> write foo(&*arg) instead of foo(arg). But I claim that the proposal will
> at least partly fail to achieve that goal because programmers will simply
> resort to writing arg.foo() rather than foo(&*arg), and we finish where
> we started.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/3b843e8f/attachment.html>

From hatahet at gmail.com  Wed Nov 20 18:16:45 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 20 Nov 2013 18:16:45 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
	<9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
Message-ID: <CAN1rdEwJNOyWo4=iUPhdvhJfWcrJLRCqD3Bp+5ZgyYUfEE5SrQ@mail.gmail.com>

What about @/Gc<> types then? You could still potentially reuse them.

--
Ziad


On Wed, Nov 20, 2013 at 5:58 PM, Tommi <rusty.gates at icloud.com> wrote:

> While I'm trying to argue why the proposed solution is not a full solution
> to the proposed problem, I don't even think that the proposed problem is a
> problem. Here's why: if you make a call foo(arg) and never use arg after
> that, then you don't care if arg gets moved or borrowed. And if you try
> to use arg afterwards and foo did in fact move it previously, then your
> IDE is going to tell you about it by drawing a red squiggly line under that
> incorrect use of arg.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/b3cef5a0/attachment.html>

From hatahet at gmail.com  Wed Nov 20 18:21:50 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Wed, 20 Nov 2013 18:21:50 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
	<9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
Message-ID: <CAN1rdEzXhWFJjjWe648_9BnYuTNL3sKq3A1o8WmfYaG6NgfLKQ@mail.gmail.com>

On Wed, Nov 20, 2013 at 5:58 PM, Tommi <rusty.gates at icloud.com> wrote:

> Here's why: if you make a call foo(arg) and never use arg after that,
> then you don't care if arg gets moved or borrowed. And if you try to use
> arg afterwards and foo did in fact move it previously, then your IDE is
> going to tell you about it by drawing a red squiggly line under that
> incorrect use of arg.
>
>
This is from the point of view of the person writing the code. What about
someone reading the code? He/she would either have to go through the
remainder of the function/scope to make sure that `arg` was not being used
(if it were, then it was a borrow, otherwise, it could have been either a
borrow or a move); or they would have to look at the signature of `foo()`;
as opposed to just being able to tell right there at the call site.

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/2d0311c3/attachment-0001.html>

From kevin at sb.org  Wed Nov 20 18:30:53 2013
From: kevin at sb.org (Kevin Ballard)
Date: Wed, 20 Nov 2013 18:30:53 -0800
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAN1rdEzXhWFJjjWe648_9BnYuTNL3sKq3A1o8WmfYaG6NgfLKQ@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
	<9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
	<CAN1rdEzXhWFJjjWe648_9BnYuTNL3sKq3A1o8WmfYaG6NgfLKQ@mail.gmail.com>
Message-ID: <4D3B2514-E4C7-4FE8-896E-4CAB0E89B17E@sb.org>

On Nov 20, 2013, at 6:21 PM, Ziad Hatahet <hatahet at gmail.com> wrote:

> On Wed, Nov 20, 2013 at 5:58 PM, Tommi <rusty.gates at icloud.com> wrote:
> Here's why: if you make a call foo(arg) and never use arg after that, then you don't care if arg gets moved or borrowed. And if you try to use arg afterwards and foodid in fact move it previously, then your IDE is going to tell you about it by drawing a red squiggly line under that incorrect use of arg.
> 
> 
> This is from the point of view of the person writing the code. What about someone reading the code? He/she would either have to go through the remainder of the function/scope to make sure that `arg` was not being used (if it were, then it was a borrow, otherwise, it could have been either a borrow or a move); or they would have to look at the signature of `foo()`; as opposed to just being able to tell right there at the call site.

Why does the reader particularly care? Presumably the code compiles (otherwise I have to ask why they're reading broken code, which is broken in a way that the compiler would trivially explain), so either it's moved and the arg isn't used again, or it's borrowed. It only really matters if the reader wants to subsequently modify the code, at which point they're now the person writing the code. And we get back to Tommi's point that the compiler (or, ideally, an IDE) will tell you if you try and use a moved value.

-Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131120/f7ebbc6f/attachment.html>

From rusty.gates at icloud.com  Wed Nov 20 18:56:10 2013
From: rusty.gates at icloud.com (Tommi)
Date: Thu, 21 Nov 2013 04:56:10 +0200
Subject: [rust-dev] Removing some autoref magic
In-Reply-To: <CAN1rdEwJNOyWo4=iUPhdvhJfWcrJLRCqD3Bp+5ZgyYUfEE5SrQ@mail.gmail.com>
References: <CAFnh-meusgrQ1SL6Nf=ntK2qsGcsdrV6rmXHAMCLininUtM_6A@mail.gmail.com>
	<08121FF9-9ADD-46A3-9704-B9D1B3DEBBB1@sb.org>
	<CAAvrL-kroUXR-U0V+7_CaiyqF=ni+vozDrQTuTfgM55V=NY6cw@mail.gmail.com>
	<F0F39A18-A904-4302-BE9E-48FAEC963FF4@icloud.com>
	<528C396E.5070603@mozilla.com>
	<18694BC4-CECB-4314-9B93-EB46A168146B@icloud.com>
	<EF296003-DCFE-4A48-AF6E-0874164F027B@icloud.com>
	<528CE2E4.2000709@mozilla.com>
	<E2FC7E9E-C979-4526-8958-ABC5C19F82DE@icloud.com>
	<9D9FD874-AD70-4CB0-B0C2-BE098C064CBB@icloud.com>
	<CAN1rdEwJNOyWo4=iUPhdvhJfWcrJLRCqD3Bp+5ZgyYUfEE5SrQ@mail.gmail.com>
Message-ID: <BE042445-BEB0-4972-B554-150B32525FB6@icloud.com>

On 2013-11-21, at 4:16, Ziad Hatahet <hatahet at gmail.com> wrote:

> What about @/Gc<> types then? You could still potentially reuse them.
> 
> --
> Ziad
> 
> 
> On Wed, Nov 20, 2013 at 5:58 PM, Tommi <rusty.gates at icloud.com> wrote:
> While I'm trying to argue why the proposed solution is not a full solution to the proposed problem, I don't even think that the proposed problem is a problem. Here's why: if you make a call foo(arg) and never use arg after that, then you don't care if arg gets moved or borrowed. And if you try to use arg afterwards and foo did in fact move it previously, then your IDE is going to tell you about it by drawing a red squiggly line under that incorrect use of arg.
> 

Garbage collected variables are owned by the runtime and the programmer cannot move (change the ownership of) them.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131121/f7c8006a/attachment.html>

From danielmicay at gmail.com  Wed Nov 20 22:28:56 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 21 Nov 2013 01:28:56 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CANK7tAH7U6+UDQ4POzY0iPOr+Z2VayX+BDKruXLTjjx0utfM1w@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
	<CAAvrL-=SzJcXCTWxfAzvm2ySfSZLUfx7YfSzUkcvJJ4RK_5U1Q@mail.gmail.com>
	<CAPNUp08PuoomYba4EY93ZwOtv1qPxvU0JcV6kV_q5y1cyea8PQ@mail.gmail.com>
	<CANK7tAH7U6+UDQ4POzY0iPOr+Z2VayX+BDKruXLTjjx0utfM1w@mail.gmail.com>
Message-ID: <CA+DvKQL6h-EVeT722vsEHAeKGVyCHKtBeKcfxCqqjT3wQ-Cz5w@mail.gmail.com>

On Wed, Nov 20, 2013 at 6:00 PM, Gaetan <gaetan at xeberon.net> wrote:
>
> However, i think the compiler should check that there is an exit condition
> in 'loop' block. I hate reading code with "while true" without exit cond,
> this is the kind of evilness that shouldnt exist in rust!

A loop without a `break` condition is perfectly sane.

> And why not preventing any 'break' condition in 'while' block? Having a
> "pure" while construction can make the compiler happy (better optimisation?)

Loops are a higher level concept than how they're represented in LLVM
bitcode anyway. Whether or not you're allowed to have break conditions
inside the loop body doesn't have optimization implications.

From michael.m.spiegel at gmail.com  Thu Nov 21 11:14:18 2013
From: michael.m.spiegel at gmail.com (Michael Spiegel)
Date: Thu, 21 Nov 2013 14:14:18 -0500
Subject: [rust-dev] status of atomic operations
Message-ID: <CANwu5-r34ObuNkFKBZEAbVSn2VUfCXY3UnebErL6KD3Hzoo6ow@mail.gmail.com>

Apologies ahead of time if this question has been discussed and/or resolved
elsewhere or previously. Looking at the rust manual in the chapter on the
memory and concurrency model (from git master) I think it states that
mutable portions of the heap cannot be shared. Aside: the wording is a
little confusing. Are there execution contexts in rust that are not tasks?
>From the sentence that begins "When reading about the memory model, keep in
mind.." I couldn't determine if execution was comprised only of tasks or
whether there were things that are not tasks that share mutable state.

Anyway assuming that there are not execution contexts that share mutable
state does this mean that the atomics library should be removed?

Thanks,
--Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131121/1c8a5dee/attachment.html>

From danielmicay at gmail.com  Thu Nov 21 11:34:24 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Thu, 21 Nov 2013 14:34:24 -0500
Subject: [rust-dev] status of atomic operations
In-Reply-To: <CANwu5-r34ObuNkFKBZEAbVSn2VUfCXY3UnebErL6KD3Hzoo6ow@mail.gmail.com>
References: <CANwu5-r34ObuNkFKBZEAbVSn2VUfCXY3UnebErL6KD3Hzoo6ow@mail.gmail.com>
Message-ID: <CA+DvKQLrvoncf0OTuo9a1B=G5WQPYm4Xu4tJdHaH=w6fppN78w@mail.gmail.com>

On Thu, Nov 21, 2013 at 2:14 PM, Michael Spiegel
<michael.m.spiegel at gmail.com> wrote:
> Apologies ahead of time if this question has been discussed and/or resolved
> elsewhere or previously. Looking at the rust manual in the chapter on the
> memory and concurrency model (from git master) I think it states that
> mutable portions of the heap cannot be shared. Aside: the wording is a
> little confusing. Are there execution contexts in rust that are not tasks?
> From the sentence that begins "When reading about the memory model, keep in
> mind.." I couldn't determine if execution was comprised only of tasks or
> whether there were things that are not tasks that share mutable state.
>
> Anyway assuming that there are not execution contexts that share mutable
> state does this mean that the atomics library should be removed?
>
> Thanks,
> --Michael

The safe subset of Rust can't make direct use of atomics, but it
doesn't mean they aren't useful. They're a tool for `unsafe` code to
use for building safe abstractions. Rust's standard library, including
what you could call the runtime, is implemented in Rust.

There is safe immutable shared memory implemented with atomic
reference counting. Rust also has safe mutable shared memory via
`MutexArc` and `RWArc`, which do locking in addition to atomic
reference counting.

From pcwalton at mozilla.com  Thu Nov 21 20:53:52 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 21 Nov 2013 20:53:52 -0800
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
Message-ID: <528EE360.5070504@mozilla.com>

There are several issues in the backwards-compatible milestone related 
to Unicode identifiers:

#4928: XID_Start/XID_Continue might not be correct
#2253: Do NKFC normalization in lexer

Given the extreme lack of use of Unicode identifiers and the fact that 
we have much more pressing issues for 1.0, I propose putting support for 
identifiers that don't match /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ 
behind a feature gate.

Thoughts?

Patrick

From sh4.seo at samsung.com  Thu Nov 21 21:25:17 2013
From: sh4.seo at samsung.com (Sanghyeon Seo)
Date: Fri, 22 Nov 2013 05:25:17 +0000 (GMT)
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
Message-ID: <3547098.17571385097917550.JavaMail.weblogic@epv6ml01>

> Given the extreme lack of use of Unicode identifiers and the fact that
> we have much more pressing issues for 1.0, I propose putting support for
> identifiers that don't match /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/
> behind a feature gate.

+1. While I very much want Unicode identifiers implemented (for example,
if you are writing a code implementing requirements from Korean legal code,
it is tedious and annoying to transliterate, translate, or invent neologisms),
I agree this probably should not block 1.0.

From rusty.gates at icloud.com  Thu Nov 21 21:37:04 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 22 Nov 2013 07:37:04 +0200
Subject: [rust-dev] The need for iterators that return by value
Message-ID: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>

In the following example, I have a function which takes an input-iterator to ints. It would be a loss of generality for that function to require its iterator argument to return its elements by pointer, because generator iterators like range(x, y) or random number generators etc. generally must return their elements by value. This makes it inconvenient to pass a vector iterator for example since it returns its elements by pointer. I wouldn't like to be writing values.iter().map(|a| *a) nor accept the performance hit it entails. I'd rather write something like values.value_iter().

fn print_these<T: Iterator<int>>(mut it: T) {
    for i in it {
        println!("{}", i);
    }
}

fn main() {
    let mut values = range(0, 3);
    print_these(values);

    let mut values = [3, 4, 5];
    print_these(values.iter().map(|a| *a));
}


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131122/ec7911b8/attachment.html>

From pcwalton at mozilla.com  Thu Nov 21 21:42:37 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Thu, 21 Nov 2013 21:42:37 -0800
Subject: [rust-dev] The need for iterators that return by value
In-Reply-To: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>
References: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>
Message-ID: <528EEECD.6040307@mozilla.com>

On 11/21/13 9:37 PM, Tommi wrote:
> In the following example, I have a function which takes an
> input-iterator to ints. It would be a loss of generality for that
> function to require its iterator argument to return its elements by
> pointer, because generator iterators like range(x, y) or random number
> generators etc. generally must return their elements by value. This
> makes it inconvenient to pass a vector iterator for example since it
> returns its elements by pointer. I wouldn't like to be writing
> values.iter().map(|a| *a) nor accept the performance hit it entails.

I think it's unlikely that the performance hit there would be 
significant. Actually, the example you gave, there won't be any at all 
because it'll be devirtualized and inlined.

> I'd
> rather write something like values.value_iter().
>
> fn print_these<T: Iterator<int>>(mut it: T) {
>      for i in it {
>          println!("{}", i);
>      }
> }
>
> fn main() {
>      let mut values = range(0, 3);
>      print_these(values);
>
>      let mut values = [3, 4, 5];
>      print_these(values.iter().map(|a| *a));
> }

There is `move_iter`, but that only works for owned vectors. Perhaps 
what you want is a kind of iterator that clones its values...

Patrick


From rusty.gates at icloud.com  Thu Nov 21 22:01:57 2013
From: rusty.gates at icloud.com (Tommi)
Date: Fri, 22 Nov 2013 08:01:57 +0200
Subject: [rust-dev] The need for iterators that return by value
In-Reply-To: <528EEECD.6040307@mozilla.com>
References: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>
	<528EEECD.6040307@mozilla.com>
Message-ID: <49F9EC54-B204-4C35-8BCC-66F76D5506A1@icloud.com>


On 2013-11-22, at 7:42, Patrick Walton <pcwalton at mozilla.com> wrote:
> 
> I think it's unlikely that the performance hit there would be significant. Actually, the example you gave, there won't be any at all because it'll be devirtualized and inlined.

Oh, okay, that's good to hear.


> 
> There is `move_iter`, but that only works for owned vectors. Perhaps what you want is a kind of iterator that clones its values...
> 

I suppose what .map(|a| a.clone()) does would be a generalization of that. Although I don't know what that does exactly.

Now, off-topic: I've been trying to post the following question to this mailing list for like 4 times, but no dice. I seem to have better luck when replying to posts, so here it goes:

struct Value {
    n: int
}

impl Value {
    fn squared(mut self) -> Value {
        self.n *= self.n;
        self
    }
}

fn main() {
    let x = Value{ n: 3 };
    let y = x.squared();
    println!("{} {}", x.n, y.n); // prints 9 9
}

self isn't being passed by value to squared, since x.n gets mutated as well. This must be a bug, right?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131122/a96bc82d/attachment.html>

From philippe.delrieu at free.fr  Fri Nov 22 00:22:39 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 22 Nov 2013 09:22:39 +0100
Subject: [rust-dev] error: cannot move out of dereference of @ pointer
In-Reply-To: <1384953326.528cb5ee83dfb@imp.free.fr>
References: <1384953326.528cb5ee83dfb@imp.free.fr>
Message-ID: <528F144F.4020208@free.fr>

I found the answer of my questions:
for ~[u8] convertion in string : std::str::from_utf8();

For  m.inner() error : use m.inner_ref()

Philippe

Le 20/11/2013 14:15, philippe.delrieu at free.fr a ?crit :
> I'am still testing the json lib and I try to encode the json using
> extra::json::Encoder. The code I use is :
>      let mut encoder = extra::json::Encoder(m as @mut Writer);
>      test.encode(&mut encoder);
>      let st:~[u8] = m.inner();
>
> I have the error : error: cannot move out of dereference of @ pointer
>
> the inner is declared as follow :
>      /// Because this takes `self' one could never 'undecorate' a Reader/Writer
>      /// that has been boxed. Is that ok? This feature is mostly useful for
>      /// extracting the buffer from MemWriter
>      fn inner(self) -> T;
>
> My second question is how to convert a ~[u8]  to a ~std ?
>
> Philippe Delrieu
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>


From philippe.delrieu at free.fr  Fri Nov 22 00:33:15 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 22 Nov 2013 09:33:15 +0100
Subject: [rust-dev] Json example code
Message-ID: <528F16CB.7090108@free.fr>

I finished my test with the rust json API. I made a non trivial example 
code that summaries what I understand. I put it at the end of the mail. 
Could someone (the developer of the API for example) add it to the 
comment of the json API. I don't think I have the right. It can be good 
to add it as a test case to validate that it stay up to date.
Put any remarks about the code if I've made some mistake or if there is 
better code.

I have a general remark about the json.rs. It's copyrighted by Rust 
developer and google.

Philippe

The code :

#[link(name = "test_json", vers = "0.1", author = "Philippe Delrieu")];
#[feature(managed_boxes)];

extern mod extra;

use std::io::mem::MemWriter;

use extra::serialize::Decodable;
use extra::serialize::Encodable;
use extra::serialize::Encoder;
use extra::json::{Json, Decoder, ToJson, Object};
use extra::treemap::TreeMap;
use std::io::Decorator;

//first struct with auto generate  Decodable, Encodable
#[deriving(Decodable, Encodable, Eq)] //generate Decodable, Encodable 
impl. Eq is added for the test assert.
pub struct TestStruct1    {
     dataInt: u8,
     dataStr:~str,
     dataArray:~[u8],
}

fn Test1()    {

     //first possibility to use JSON is the serialization API. Use a 
struct that implement Decodable, Encodable.
     //the object to test
     let test : TestStruct1 = TestStruct1 {dataInt: 1, dataStr:~"toto", 
dataArray:~[2,3,4,5]}; // encoded 
~"{\"dataInt\":1,\"dataStr\":\"toto\",\"dataArray\":[2,3,4,5]}"

     //Serialize the object in a string using a writer
     let m = @mut MemWriter::new();
     let mut encoder = extra::json::Encoder(m as @mut Writer);
     test.encode(&mut encoder);
     let buf:&~[u8] = m.inner_ref(); //get the serialized values.
     let s = std::str::from_utf8(*buf);

     println!("test 1 encoded using auto generated Encodable {:?}", s);
     assert_eq!(s, 
~"{\"dataInt\":1,\"dataStr\":\"toto\",\"dataArray\":[2,3,4,5]}");

     //unserialize using the object decoder
     //convert the string to a json object.
     let jsonobject = extra::json::from_str(s);
     let mut decoder = Decoder(jsonobject.unwrap());
     let decoded1: TestStruct1 = Decodable::decode(&mut decoder); 
//create the final object
     println!("test 1 decoded using auto generated Decodable {:?}", 
decoded1);
     assert_eq!(decoded1, test);

}

//second struct with manually implemented  Decodable, Encodable
#[deriving(Eq)] //generate impl of Eq for the test assert.
pub struct TestStruct2    {
     dataInt: u8,
     dataStr:~str,
     dataArray:~[u8],
}

impl<S:Encoder> Encodable<S> for TestStruct2 {
     fn encode(&self, s: &mut S) {
           do s.emit_struct("TestStruct2", 2) |s| {  //2 correspond to 
len the number of field in the structure.
             s.emit_struct_field("dataInt", 0, |s| self.dataInt.encode(s));
             s.emit_struct_field("dataStr", 1, |s| self.dataStr.encode(s));
             //encode the dataArray array field with emit_seq
             do s.emit_struct_field("dataArray", 3) |s| {
                   do s.emit_seq(self.dataArray.len()) |s| {  //len 
number of element in the array.
                       for i in range(0u, self.dataArray.len())    {
                         s.emit_seq_elt(i, |s| self.dataArray[i].encode(s));
                       }
                 }
             }
         }
    }
}

  impl<D:extra::serialize::Decoder> extra::serialize::Decodable<D> for 
TestStruct2 {
     fn decode(d: &mut D) -> TestStruct2 {
         do d.read_struct("TestStruct2", 1) |d| {
             TestStruct2
             {
                 dataInt: d.read_struct_field("dataInt", 0, |d| 
d.read_u8()),
                 dataStr: d.read_struct_field("dataStr", 1, |d| 
d.read_str()),

                 dataArray: do d.read_struct_field("dataArray", 2) |d| {
                     let mut arr:~[u8] = ~[];
                     do d.read_seq |d, len| {
                         for i in range(0u, len) {
                             arr.push(d.read_seq_elt(i, |d| d.read_u8()));
                         }
                     }
                     arr
                 }
             }
         }

     }
}

//second possibility to decode json is to implement the ToJson trait.
impl ToJson for TestStruct2 {
     fn to_json( &self ) -> Json {
         let mut d = ~TreeMap::new();
         d.insert(~"dataInt", self.dataInt.to_json());
         d.insert(~"dataStr", self.dataStr.to_json());
         d.insert(~"dataArray", self.dataArray.to_json());
         Object(d)
     }
}

fn Test2()    {
         //second possibility : use impl of to_json() to serialize
     let test2 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto", 
dataArray:~[2,3,4,5]}; 
//{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
     let tjson : Json = test2.to_json();
     let jsonStr:~str = tjson.to_str();
     println!("Test 2 encoded using to_json {:?}", jsonStr);
     assert_eq!(jsonStr, 
~"{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}");

     //unserialize using the our own impl of decoder
     //convert the string to a json object and decode.
     let mut decoder = Decoder(extra::json::from_str(jsonStr).unwrap());
     let decoded2: TestStruct2 = Decodable::decode(&mut decoder); 
//create the final object
     println!("test 2 decoded using our Decodable{:?}", decoded2);
     assert_eq!(decoded2, test2);

}

fn Test3()    {
         //thrid use our own encoder to encode
     let test3 : TestStruct2 = TestStruct2 {dataInt: 1, dataStr:~"toto", 
dataArray:~[2,3,4,5]}; 
//{\"dataArray\":[2,3,4,5],\"dataInt\":1,\"dataStr\":\"toto\"}
     let m3 = @mut MemWriter::new();
     let mut encoder3 = extra::json::Encoder(m3 as @mut Writer);
     test3.encode(&mut encoder3);
     let buf3:&~[u8] = m3.inner_ref(); //get the serialized values.
     let s3 = std::str::from_utf8(*buf3);
     println!("test 3 encoded using our Encodable {:?}", s3);

     //decode using error management and our own decoder.
     let j:Result<extra::json::Json,extra::json::Error> = 
extra::json::from_str(s3);
     let json: extra::json::Json = match j {
          Ok(l) => l,
          Err(e) => fail!(format!("Error: {:?}", e))
     };
     let mut decoder3 = Decoder(json);
     let decoded3: TestStruct2 = Decodable::decode(&mut decoder3); 
//create the final object
     println!("test 3 decoded using our Decodable {:?}", decoded3);
     assert_eq!(decoded3, test3);
}


#[main]
fn main() {
     Test1();
     Test2();
     Test3();
}


From dbau.pp at gmail.com  Fri Nov 22 00:47:00 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Fri, 22 Nov 2013 19:47:00 +1100
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <528EE360.5070504@mozilla.com>
References: <528EE360.5070504@mozilla.com>
Message-ID: <528F1A04.2030306@gmail.com>

On 22/11/13 15:53, Patrick Walton wrote:
> There are several issues in the backwards-compatible milestone related 
> to Unicode identifiers:
>
> #4928: XID_Start/XID_Continue might not be correct
> #2253: Do NKFC normalization in lexer
>
> Given the extreme lack of use of Unicode identifiers and the fact that 
> we have much more pressing issues for 1.0, I propose putting support 
> for identifiers that don't match 
> /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ behind a feature gate.
>
> Thoughts?
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Implemented in https://github.com/mozilla/rust/pull/10605 for if/when we 
make a decision. (Feel free to reject it.)

(Another small data-point against our current unicode support: 
https://github.com/mozilla/rust/issues/8706 )


Huon

From corey at octayn.net  Fri Nov 22 01:07:08 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 22 Nov 2013 04:07:08 -0500
Subject: [rust-dev] Json example code
In-Reply-To: <528F16CB.7090108@free.fr>
References: <528F16CB.7090108@free.fr>
Message-ID: <CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>

On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> I finished my test with the rust json API. I made a non trivial example code
> that summaries what I understand. I put it at the end of the mail. Could
> someone (the developer of the API for example) add it to the comment of the
> json API. I don't think I have the right. It can be good to add it as a test
> case to validate that it stay up to date.
> Put any remarks about the code if I've made some mistake or if there is
> better code.
>

Send a pull request adding it.

From danielmicay at gmail.com  Fri Nov 22 01:22:50 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 22 Nov 2013 04:22:50 -0500
Subject: [rust-dev] The need for iterators that return by value
In-Reply-To: <528EEECD.6040307@mozilla.com>
References: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>
	<528EEECD.6040307@mozilla.com>
Message-ID: <CA+DvKQL-G6OEZXjxh5wyvWcr5Z27iyZBk9qM9u0ZWZK+SgK9qg@mail.gmail.com>

On Fri, Nov 22, 2013 at 12:42 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
> There is `move_iter`, but that only works for owned vectors. Perhaps what
> you want is a kind of iterator that clones its values...
>
> Patrick

The issue with a `Clone` iterator is that it adds an extra method to
every container, and still borrows the container anyway. I'm happy for
now with `map(|x| *x)` or `map(clone)`. In the simple case, you can
just put the dereference in the for loop (`for &x in xs.iter()`) or
one of the method calls (`xs.iter().fold(0, |a, &b| a + b`).

From denis.spir at gmail.com  Fri Nov 22 09:13:36 2013
From: denis.spir at gmail.com (spir)
Date: Fri, 22 Nov 2013 18:13:36 +0100
Subject: [rust-dev] byval & byref (was: The need for iterators that
 return by value)
In-Reply-To: <49F9EC54-B204-4C35-8BCC-66F76D5506A1@icloud.com>
References: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>	<528EEECD.6040307@mozilla.com>
	<49F9EC54-B204-4C35-8BCC-66F76D5506A1@icloud.com>
Message-ID: <528F90C0.3090502@gmail.com>

On 11/22/2013 07:01 AM, Tommi wrote:
> Now, off-topic: I've been trying to post the following question to this mailing list for like 4 times, but no dice. I seem to have better luck when replying to posts, so here it goes:
>
> struct Value {
>      n: int
> }
>
> impl Value {
>      fn squared(mut self) -> Value {
>          self.n *= self.n;
>          self
>      }
> }
>
> fn main() {
>      let x = Value{ n: 3 };
>      let y = x.squared();
>      println!("{} {}", x.n, y.n); // prints 9 9
> }
>
> self isn't being passed by value to squared, since x.n gets mutated as well. This must be a bug, right?

That is not what I'd expect, in any case!
;-)

PS: cannot run the code, get:

_.rs:12:16: 12:19 error: found `self` in ident position
_.rs:12     fn squared (mut self) -> Value {
                         ^~~

??? (also, underlining looks wrong; unless the actual error is about mut?)

Denis

From philippe.delrieu at free.fr  Fri Nov 22 10:22:11 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 22 Nov 2013 19:22:11 +0100
Subject: [rust-dev] Json example code
In-Reply-To: <CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
References: <528F16CB.7090108@free.fr>
	<CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
Message-ID: <528FA0D3.80804@free.fr>

I've done the modification in json.rs (add comment with sample code in 
md format and test code).
I've do the commit and git pull.

The test compile but I didn't manage to run it.
I use the command: make -j 20 check TESTNAME=src/libextra/json.rs
There are errors before and when I force the assert to false I have no 
error for json.

Tell me if it's ok.

Philippe

Le 22/11/2013 10:07, Corey Richardson a ?crit :
> On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
> <philippe.delrieu at free.fr> wrote:
>> I finished my test with the rust json API. I made a non trivial example code
>> that summaries what I understand. I put it at the end of the mail. Could
>> someone (the developer of the API for example) add it to the comment of the
>> json API. I don't think I have the right. It can be good to add it as a test
>> case to validate that it stay up to date.
>> Put any remarks about the code if I've made some mistake or if there is
>> better code.
>>
> Send a pull request adding it.
>
>


From banderson at mozilla.com  Fri Nov 22 10:32:56 2013
From: banderson at mozilla.com (Brian Anderson)
Date: Fri, 22 Nov 2013 10:32:56 -0800
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <528EE360.5070504@mozilla.com>
References: <528EE360.5070504@mozilla.com>
Message-ID: <528FA358.8060807@mozilla.com>

On 11/21/2013 08:53 PM, Patrick Walton wrote:
> There are several issues in the backwards-compatible milestone related 
> to Unicode identifiers:
>
> #4928: XID_Start/XID_Continue might not be correct
> #2253: Do NKFC normalization in lexer
>
> Given the extreme lack of use of Unicode identifiers and the fact that 
> we have much more pressing issues for 1.0, I propose putting support 
> for identifiers that don't match 
> /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ behind a feature gate.
>
> Thoughts?

This is ok by me. Let's keep looking for rough corners like this to 
scale back or remove.

From pnkfelix at mozilla.com  Fri Nov 22 10:41:09 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Fri, 22 Nov 2013 19:41:09 +0100
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <528FA358.8060807@mozilla.com>
References: <528EE360.5070504@mozilla.com> <528FA358.8060807@mozilla.com>
Message-ID: <528FA545.8010506@mozilla.com>

On 22/11/2013 19:32, Brian Anderson wrote:
> On 11/21/2013 08:53 PM, Patrick Walton wrote:
>> There are several issues in the backwards-compatible milestone 
>> related to Unicode identifiers:
>>
>> #4928: XID_Start/XID_Continue might not be correct
>> #2253: Do NKFC normalization in lexer
>>
>> Given the extreme lack of use of Unicode identifiers and the fact 
>> that we have much more pressing issues for 1.0, I propose putting 
>> support for identifiers that don't match 
>> /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ behind a feature gate.
>>
>> Thoughts?
>
> This is ok by me. Let's keep looking for rough corners like this to 
> scale back or remove.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
I agree with the sentiments expressed by Patrick and Brian.

But Patrick, are you also suggesting that in the default case outside 
the feature gate, we would only allow underscore solely as a leading 
character, and not as an embedded one?  Or were you just whipping up a 
quick regexp on the fly and left out the potential for a non-leading 
underscore?

% js
js> var r =  /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/;
js> r.exec("a3b")
["a3b"]
js> r.exec("_a3b")
["_a3b"]
js> r.exec("a_b")
null
js> r.exec("_a_b")
null
js>


Cheers,
-Felix

-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com


From pwalton at mozilla.com  Fri Nov 22 11:01:27 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 22 Nov 2013 11:01:27 -0800
Subject: [rust-dev] RFC: Put Unicode identifiers behind a feature gate
In-Reply-To: <528FA545.8010506@mozilla.com>
References: <528EE360.5070504@mozilla.com> <528FA358.8060807@mozilla.com>
	<528FA545.8010506@mozilla.com>
Message-ID: <584acc58-c4c8-4e59-ba66-17f33c1e5d85@email.android.com>

Yeah, I realized that regex was wrong. Now I have two problems :)

Embedded underscores should be permitted.

Patrick 

"Felix S. Klock II" <pnkfelix at mozilla.com> wrote:
>On 22/11/2013 19:32, Brian Anderson wrote:
>> On 11/21/2013 08:53 PM, Patrick Walton wrote:
>>> There are several issues in the backwards-compatible milestone 
>>> related to Unicode identifiers:
>>>
>>> #4928: XID_Start/XID_Continue might not be correct
>>> #2253: Do NKFC normalization in lexer
>>>
>>> Given the extreme lack of use of Unicode identifiers and the fact 
>>> that we have much more pressing issues for 1.0, I propose putting 
>>> support for identifiers that don't match 
>>> /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/ behind a feature gate.
>>>
>>> Thoughts?
>>
>> This is ok by me. Let's keep looking for rough corners like this to 
>> scale back or remove.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>I agree with the sentiments expressed by Patrick and Brian.
>
>But Patrick, are you also suggesting that in the default case outside 
>the feature gate, we would only allow underscore solely as a leading 
>character, and not as an embedded one?  Or were you just whipping up a 
>quick regexp on the fly and left out the potential for a non-leading 
>underscore?
>
>% js
>js> var r =  /^(?:[A-Za-z][A-Za-z0-9]*|_[A-Za-z0-9]+)$/;
>js> r.exec("a3b")
>["a3b"]
>js> r.exec("_a3b")
>["_a3b"]
>js> r.exec("a_b")
>null
>js> r.exec("_a_b")
>null
>js>
>
>
>Cheers,
>-Felix
>
>-- 
>irc: pnkfelix on irc.mozilla.org
>email: {fklock, pnkfelix}@mozilla.com
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131122/1df652e1/attachment.html>

From laden at csclub.uwaterloo.ca  Fri Nov 22 13:58:57 2013
From: laden at csclub.uwaterloo.ca (Luqman Aden)
Date: Fri, 22 Nov 2013 13:58:57 -0800
Subject: [rust-dev] byval & byref (was: The need for iterators that
 return by value)
In-Reply-To: <528F90C0.3090502@gmail.com>
References: <79DA7977-1D8B-417F-B226-A928CA3006B3@icloud.com>
	<528EEECD.6040307@mozilla.com>
	<49F9EC54-B204-4C35-8BCC-66F76D5506A1@icloud.com>
	<528F90C0.3090502@gmail.com>
Message-ID: <CADRTvEA=TT1CgdPHiSGpKru0A1K-TfzMvfTYuuRZ4jw3y6Q8wA@mail.gmail.com>

Tommi: Yes, that's a bug. Thanks for uncovering it! Filed it here:
https://github.com/mozilla/rust/issues/10615

Denis: The reason you get that error is because you're using an older
version (0.8 maybe?). In builds from git master you can now place self
in a mut slot.

On Fri, Nov 22, 2013 at 9:13 AM, spir <denis.spir at gmail.com> wrote:
> On 11/22/2013 07:01 AM, Tommi wrote:
>>
>> Now, off-topic: I've been trying to post the following question to this
>> mailing list for like 4 times, but no dice. I seem to have better luck when
>> replying to posts, so here it goes:
>>
>> struct Value {
>>      n: int
>> }
>>
>> impl Value {
>>      fn squared(mut self) -> Value {
>>          self.n *= self.n;
>>          self
>>      }
>> }
>>
>> fn main() {
>>      let x = Value{ n: 3 };
>>      let y = x.squared();
>>      println!("{} {}", x.n, y.n); // prints 9 9
>> }
>>
>> self isn't being passed by value to squared, since x.n gets mutated as
>> well. This must be a bug, right?
>
>
> That is not what I'd expect, in any case!
> ;-)
>
> PS: cannot run the code, get:
>
> _.rs:12:16: 12:19 error: found `self` in ident position
> _.rs:12     fn squared (mut self) -> Value {
>                         ^~~
>
> ??? (also, underlining looks wrong; unless the actual error is about mut?)
>
> Denis
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From ktt3ja at virginia.edu  Sat Nov 23 19:44:28 2013
From: ktt3ja at virginia.edu (Kiet Tran)
Date: Sat, 23 Nov 2013 22:44:28 -0500
Subject: [rust-dev] Some questions about dead-code elimination pass
Message-ID: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>

Hi,

I'm doing the dead-code elimination pass for a school project, which
comprises of two parts: (a) do a warning pass for dead code and (b)
eliminate dead code generation. For part (a), the approach I'm taking
is reuse reachable.rs to mark live codes, since the set of live codes
is essentially a superset reachable codes, and the propagation logic
is similar. Then I do another walk to check for items that are not in
the live codes set and warn that they are dead. Though outdated, you
can see my PR and how I approach it here:

https://github.com/mozilla/rust/pull/10477/files

In doing this, I ran into a few questions that I would like answers
to:

1. Is doing part (b) necessary? That is, does LLVM's optimization
already eliminate unused code?

2. My code marks `RuntimeGlue` struct in libstd/task/spawn.rs as dead.
This is because the struct is private and never used directly.
Instead, it contains static methods that are used, so it's not
desirable to warn it. Currently, when my code sees, e.g.,
`RuntimeGlue::kill_task`, it would mark the `kill_task` method
definition as live. What I would like to do in addition is mark the
`RuntimeGlue` struct definition as live, but I'm unable to find a way
to look up a struct given its method. How do I do that?

3. My code also marks the function `load_argc_and_argv` in
libstd/os.rs as dead when in fact it isn't. I would guess it's because
that function is only used when compiling the rustc source code on
Mac, whereas I'm compiling it on Linux. How do I modify my code to
take account of that?

4. I'm unable to finish compiling rustc because my addition spots a
number of dead codes in rustc source code. Assuming they are not false
positive, I then have three options: (i) remove the dead code, (ii)
comment it out, or (iii) put an `#[allow(dead_code)];` at the top of
the module. As I'm unfamiliar with the codebase, it's hard to decide
what to do in each case (I'm thankful to dbaupp for much help in this
area). When in doubt, which would be best to do?

Sincerely,
Kiet Tran

From acrichton at mozilla.com  Sun Nov 24 01:15:02 2013
From: acrichton at mozilla.com (Alex Crichton)
Date: Sun, 24 Nov 2013 01:15:02 -0800
Subject: [rust-dev] Some questions about dead-code elimination pass
In-Reply-To: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
References: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
Message-ID: <CAFnh-memuMX0ztsSb5-smcMPRN-fRMjyaiKCAwdJv_vrNhs1Uw@mail.gmail.com>

> 1. Is doing part (b) necessary? That is, does LLVM's optimization
> already eliminate unused code?

I don't believe that it is from a final binary point of view.
Unreachable functions will be flagged as internal, and LLVM can do
whatever it wants with internal symbols. I would imagine that it would
discard these symbols and functions.

That being said, we still go through all the time of generating code
for the unused functions, and LLVM probably optimizes them at least a
little bit. This is such a small percentage of code, however, that I
wouldn't worry about doing this step.

> 2. My code marks `RuntimeGlue` struct in libstd/task/spawn.rs as dead.
> This is because the struct is private and never used directly.
> Instead, it contains static methods that are used, so it's not
> desirable to warn it. Currently, when my code sees, e.g.,
> `RuntimeGlue::kill_task`, it would mark the `kill_task` method
> definition as live. What I would like to do in addition is mark the
> `RuntimeGlue` struct definition as live, but I'm unable to find a way
> to look up a struct given its method. How do I do that?

I personally do not know of a method to do this in the compiler right
now (although one may surely exist), but if it doesn't this would
probably be a table calculated as part of the resolve pass.

> 3. My code also marks the function `load_argc_and_argv` in
> libstd/os.rs as dead when in fact it isn't. I would guess it's because
> that function is only used when compiling the rustc source code on
> Mac, whereas I'm compiling it on Linux. How do I modify my code to
> take account of that?

The function should probably be #[cfg(target_os = "linux")]

> 4. I'm unable to finish compiling rustc because my addition spots a
> number of dead codes in rustc source code. Assuming they are not false
> positive, I then have three options: (i) remove the dead code, (ii)
> comment it out, or (iii) put an `#[allow(dead_code)];` at the top of
> the module. As I'm unfamiliar with the codebase, it's hard to decide
> what to do in each case (I'm thankful to dbaupp for much help in this
> area). When in doubt, which would be best to do?

I would recommend removing whatever possible, but allow(dead_code) is
indicative of a bug in the analysis pass or a change which needs to be
present in the code. I would not recommend commenting out code (that's
what a git history is for).

From dbau.pp at gmail.com  Sun Nov 24 02:18:21 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sun, 24 Nov 2013 21:18:21 +1100
Subject: [rust-dev] Some questions about dead-code elimination pass
In-Reply-To: <CAFnh-memuMX0ztsSb5-smcMPRN-fRMjyaiKCAwdJv_vrNhs1Uw@mail.gmail.com>
References: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
	<CAFnh-memuMX0ztsSb5-smcMPRN-fRMjyaiKCAwdJv_vrNhs1Uw@mail.gmail.com>
Message-ID: <5291D26D.6000504@gmail.com>

On 24/11/13 20:15, Alex Crichton wrote:
>> 3. My code also marks the function `load_argc_and_argv` in
>> libstd/os.rs as dead when in fact it isn't. I would guess it's because
>> that function is only used when compiling the rustc source code on
>> Mac, whereas I'm compiling it on Linux. How do I modify my code to
>> take account of that?
> The function should probably be #[cfg(target_os = "linux")]

This should be `#[cfg(target_os = "macos")]` since it's only used on Mac.



Huon

From ma.adameit at gmail.com  Sun Nov 24 02:49:44 2013
From: ma.adameit at gmail.com (Manuel)
Date: Sun, 24 Nov 2013 11:49:44 +0100
Subject: [rust-dev] Idea for versioned language specifications with
	automatic conversions
In-Reply-To: <5291D8E9.5060205@gmail.com>
References: <5291D8E9.5060205@gmail.com>
Message-ID: <5291D9C8.3080902@gmail.com>

I had the following idea to approach language evolution:

Problem:
Languages try to be backward compatible by stabilizing, and only slowly 
deprecating old features. This results in a language which does not 
evolve. Some different takes about this:
C++: adds new features but does not fix problems, and often does not 
remove obsolete features resulting in, well, C++.
Python: Minor versions which add new features, big version jump from 2 
to 3 to make backward incompatible changes. The resulting 
incompatibility was a big problem, almost 5 years after the release of 
3.0 (December 3rd, 2008) people are still using 2.x. Rust seems to 
follow a similar approach, devs are already defering features to 2.0 to 
stabilize.
Other languages simply do not evolve at all and are replaced.

My idea to improve this situation would be to add a version tag in every 
main crate, something like "#ver 0.10". For each version jump the 
compiler would fix the code automatically, and convert it to the current 
language specification. When the library/code is multiple versions 
behind the conversions could be applied successively. This can be done 
in a lot of cases, see python 2to3 script and even Google did this for 
go with the tool gofix during development. With this change not updated 
libraries would still be usable in rust. To simplify updating libraries 
the compiler could, on demand, print out a report of problematic parts 
and propose fixes. Some things can not be fixed with an automatic 
approach, for these cases a classic deprecation mechanism or something 
else could still be used.

Advantages:
Kind of backward compatibility to old code bases.
Rust can evolve and stay streamlined at the same time.
Compiler does not have to deal with deprecation mechanism, because you 
can remove, and change things instantly.

When this would be in place i think it would be best to release 
incompatible updates often, but with only a few changes. Every six 
months for example.


What do you think about this?

Manuel


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131124/f3efe26f/attachment.html>

From matthieu.monrocq at gmail.com  Sun Nov 24 04:13:51 2013
From: matthieu.monrocq at gmail.com (Matthieu Monrocq)
Date: Sun, 24 Nov 2013 13:13:51 +0100
Subject: [rust-dev] Idea for versioned language specifications with
 automatic conversions
In-Reply-To: <5291D9C8.3080902@gmail.com>
References: <5291D8E9.5060205@gmail.com>
	<5291D9C8.3080902@gmail.com>
Message-ID: <CAKE6RfgzDMWSTgPQ4=LqXDCRR_NmKzzGbWxwb--K9+Tt8t3x-A@mail.gmail.com>

Hi Manuel,

I must say that on a conceptual point of view I like the approach, keeping
one's libraries up to date is the only way to go, however I am afraid that
you are glossing over certain details here:

- you assume that the source code is available, this is a problem if I am
using a 3rd party library for which I only get the binary and THEY have not
migrated yet; how can I use library X (released in 0.9 and 0.10) and
library Y (released in 0.11 and 0.12) in the same project ? Smaller
milestones make it a smoother process to upgrade at the individual level
but larger milestones help multiple people/corporations coordinate.

- you assume that I can actually upgrade; I work at a large software
company, with over 5,000 employees now, and this apply a *large* source
code base. A migration entails an extensive test phase of the target
software/version following by a careful migration of a few pilot products
simply because migrating costs a lot and migrating to a "flawed" version
just to rollback the migration is a cost sink. As a result though, this
creates inertia. Internally we are *always* in the middle of several
migrations (compiler, 3rd party libraries, in-house middleware, ...) and
the larger ones take years. Because of this, once again we need some
coordination: we just cannot afford to migrate every 6 months (not enough
testing time). This means that while it would not prevent Rust from
migrating every 6 months, we would still be expecting fixes to previous
releases for a year or two.

The former means that 6 months might a little *too* fast pace for
industrial projects, the latter means that on top of defining releases
schedule the Rust team will also have to provide a clear plan for support
of "older" versions (how long, what kind of bugs, ...) and the number of
branches impacted may grow quickly: 6 months releases + 2 years support
means at least 4 branches, maybe 5 if we count the one being developed (and
2 years is nothing fancy, as support goes).

-- Matthieu



On Sun, Nov 24, 2013 at 11:49 AM, Manuel <ma.adameit at gmail.com> wrote:

>  I had the following idea to approach language evolution:
>
> Problem:
> Languages try to be backward compatible by stabilizing, and only slowly
> deprecating old features. This results in a language which does not evolve.
> Some different takes about this:
> C++: adds new features but does not fix problems, and often does not
> remove obsolete features resulting in, well, C++.
> Python: Minor versions which add new features, big version jump from 2 to
> 3 to make backward incompatible changes. The resulting incompatibility was
> a big problem, almost 5 years after the release of 3.0 (December 3rd,
> 2008) people are still using 2.x. Rust seems to follow a similar
> approach, devs are already defering features to 2.0 to stabilize.
> Other languages simply do not evolve at all and are replaced.
>
> My idea to improve this situation would be to add a version tag in every
> main crate, something like "#ver 0.10". For each version jump the compiler
> would fix the code automatically, and convert it to the current language
> specification. When the library/code is multiple versions behind the
> conversions could be applied successively. This can be done in a lot of
> cases, see python 2to3 script and even Google did this for go with the tool
> gofix during development. With this change not updated libraries would
> still be usable in rust. To simplify updating libraries the compiler could,
> on demand, print out a report of problematic parts and propose fixes. Some
> things can not be fixed with an automatic approach, for these cases a
> classic deprecation mechanism or something else could still be used.
>
> Advantages:
> Kind of backward compatibility to old code bases.
> Rust can evolve and stay streamlined at the same time.
> Compiler does not have to deal with deprecation mechanism, because you can
> remove, and change things instantly.
>
> When this would be in place i think it would be best to release
> incompatible updates often, but with only a few changes. Every six months
> for example.
>
>
> What do you think about this?
>
> Manuel
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131124/8ac57029/attachment-0001.html>

From corey at octayn.net  Sun Nov 24 05:38:42 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 24 Nov 2013 08:38:42 -0500
Subject: [rust-dev] Some questions about dead-code elimination pass
In-Reply-To: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
References: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
Message-ID: <CA++BO6Q+HFNSqj4Q=E6tvTxa2oJQQDhfMx6K8ABxfhWm9uqxzg@mail.gmail.com>

On Sat, Nov 23, 2013 at 10:44 PM, Kiet Tran <ktt3ja at virginia.edu> wrote:
> 1. Is doing part (b) necessary? That is, does LLVM's optimization
> already eliminate unused code?
>

LLVM does, yes, but I'd still be interested in a perf comparison of us
not translating the dead code compared to LLVM stripping it later.
Clang does this, for example.

From corey at octayn.net  Sun Nov 24 06:42:26 2013
From: corey at octayn.net (Corey Richardson)
Date: Sun, 24 Nov 2013 09:42:26 -0500
Subject: [rust-dev] This Week in Rust
Message-ID: <CA++BO6TFZ5sVydbyqe=uNA4734X9wMohz7jjvwV-302mGcMbZg@mail.gmail.com>

Welcome to another issue of *This Week in Rust*!

# What's cooking on master?

47 PRs were merged this week.

## Breaking Changes

- Non-ASCII identifiers are [feature
  gated](https://github.com/mozilla/rust/pull/10605), due to open questions
  about how it should be done. They aren't being removed, just deferred to
  post-1.0.
- Some more closure reform has gone through. `~fn` has been removed, [use
  `proc` instead](https://github.com/mozilla/rust/pull/10561). `&fn` is [also
  short for this world](https://github.com/mozilla/rust/pull/10568).
- `std::util::NonCopyable` had its dummy constructor
  [removed](https://github.com/mozilla/rust/pull/10575).
- All of the functions in rustrt [have been prefixed with
  `rust_`](https://github.com/mozilla/rust/pull/10440).
- Items inside functions [no longer accept privacy
  modifiers](https://github.com/mozilla/rust/pull/10443), since it is
  meaningless.
- Reachable `extern fn`s are [no longer marked
  internal](https://github.com/mozilla/rust/pull/10539).

## Other changes

- A `Gc<T>` stub [has been added](https://github.com/mozilla/rust/pull/10576).
  New code should use this instead of `@T`.
- `..` is now [the pattern to use](https://github.com/mozilla/rust/pull/10366)
  when ignoring multiple elements in a pattern.
- Stepping through `if` in a debugger [should be much smoother
  now](https://github.com/mozilla/rust/pull/10552).
- `rustpkg -O` [will now actually
  optimize](https://github.com/mozilla/rust/pull/10526) the package it is
  building.
- Did you know we can make tags files for the Rust codebase? `make
  TAGS.{vi,emacs}`! It no longer generates tags for [all of LLVM and
  libuv](https://github.com/mozilla/rust/pull/10508), too.
- The pidigits benchmark [has been
  resurrected](https://github.com/mozilla/rust/pull/10555).
- A native mutex type [now
  exists](https://github.com/mozilla/rust/pull/10479), and it doesn't depend
  on C++.
- Some more derived methods are [marked for
  inlining](https://github.com/mozilla/rust/pull/10557).
- A bunch more [native file IO](https://github.com/mozilla/rust/pull/10495)
  was implemented, too.
- We now have support for the [win64 calling
  convention](https://github.com/mozilla/rust/pull/10527). Additionally, the
  ABI of `extern fn`s is now actually used.
- The tutorial [now covers alternatives to
  ownership](https://github.com/mozilla/rust/pull/10589) much better.
- A lint for unsafe blocks [has been
  added](https://github.com/mozilla/rust/pull/10599).
- A minor bug with privacy [has been
  fixed](https://github.com/mozilla/rust/pull/10583).

## New Contributors

Our first-time contributors this week are:

- Dave Hodder
- Ian Daniher
- Isaac Dupree
- g3xzh

# Weekly Meeting

The [weekly
meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-19)
discussed static linking, changing how `let _ = foo` is handled, task joining,
autoderef, and user-defined vector types.

# Announcements, etc

- A [new
  tutorial](http://adrientetar.legtux.org/cached/rust-tuts/index.html) project
  has sprung up.

# Servo

Thanks to Lars Bergstrom for This Week in Servo! Servo is Rust's sister
project, and I think it's nice to be able to see a highlevel of its progress.
Maybe TWiS will graduate to a separate blog someday.

## This Week in Servo

Servo is a web browser engine written in Rust and is one of the primary test
cases for the Rust language. Starting this week, TWiR will include a status
update from Servo.

There were 14 landed PRs this week.

### Notable additions

- Patrick Walton rewrote flow construction so that we can make it incremental
  and parallelizable in https://github.com/mozilla/servo/pull/1271
- Ryan Choi added support for transparant PNG files in
  https://github.com/mozilla/servo/pull/1288
- Junyoung Cho added the ACID2 test file, which is one of the big focuses of
  the team over the coming months, in
  https://github.com/mozilla/servo/pull/1287
- In his first Servo PR, Adenilson Cavalcanti contributed a help message for
  the binary in https://github.com/mozilla/servo/pull/1277

### Meetings

Having spent the prior week at a workweek with Samsung in Korea (where there
were several presentations on both Rust and Servo!
https://github.com/mozilla/servo/wiki/Videos-and-presentations ), the meeting
was pretty light this week. It mainly [covered](
https://github.com/mozilla/servo/wiki/Meeting-2013-11-18 ) getting more formal
tracking of the work required for ACID2 and prioritizing Windows support.

From ma.adameit at gmail.com  Sun Nov 24 06:42:48 2013
From: ma.adameit at gmail.com (Manuel)
Date: Sun, 24 Nov 2013 15:42:48 +0100
Subject: [rust-dev] Idea for versioned language specifications with
 automatic conversions
In-Reply-To: <CAKE6RfgzDMWSTgPQ4=LqXDCRR_NmKzzGbWxwb--K9+Tt8t3x-A@mail.gmail.com>
References: <5291D8E9.5060205@gmail.com>	<5291D9C8.3080902@gmail.com>
	<CAKE6RfgzDMWSTgPQ4=LqXDCRR_NmKzzGbWxwb--K9+Tt8t3x-A@mail.gmail.com>
Message-ID: <52921068.30407@gmail.com>

> Hi Manuel,
>
> I must say that on a conceptual point of view I like the approach, 
> keeping one's libraries up to date is the only way to go, however I am 
> afraid that you are glossing over certain details here:
>
> - you assume that the source code is available, this is a problem if I 
> am using a 3rd party library for which I only get the binary and THEY 
> have not migrated yet; how can I use library X (released in 0.9 and 
> 0.10) and library Y (released in 0.11 and 0.12) in the same project ? 
> Smaller milestones make it a smoother process to upgrade at the 
> individual level but larger milestones help multiple 
> people/corporations coordinate.
>
> - you assume that I can actually upgrade; I work at a large software 
> company, with over 5,000 employees now, and this apply a *large* 
> source code base. A migration entails an extensive test phase of the 
> target software/version following by a careful migration of a few 
> pilot products simply because migrating costs a lot and migrating to a 
> "flawed" version just to rollback the migration is a cost sink. As a 
> result though, this creates inertia. Internally we are *always* in the 
> middle of several migrations (compiler, 3rd party libraries, in-house 
> middleware, ...) and the larger ones take years. Because of this, once 
> again we need some coordination: we just cannot afford to migrate 
> every 6 months (not enough testing time). This means that while it 
> would not prevent Rust from migrating every 6 months, we would still 
> be expecting fixes to previous releases for a year or two.
>
> The former means that 6 months might a little *too* fast pace for 
> industrial projects, the latter means that on top of defining releases 
> schedule the Rust team will also have to provide a clear plan for 
> support of "older" versions (how long, what kind of bugs, ...) and the 
> number of branches impacted may grow quickly: 6 months releases + 2 
> years support means at least 4 branches, maybe 5 if we count the one 
> being developed (and 2 years is nothing fancy, as support goes).
>
> -- Matthieu
>

Ok this makes sense, a release cycle of 2 years + 2 years support for 
example might be better once the language is more mature. Until then i 
think the suggested approach with the version specified in the source 
code and an assisted upgrade path would be helpful to keep the libraries 
updated. Also for these larger, less frequent updates such helpers make 
the cost of updating smaller.

Thanks for your answer, i was almost sure that it won't be that simple.

Manuel
>
>
> On Sun, Nov 24, 2013 at 11:49 AM, Manuel <ma.adameit at gmail.com 
> <mailto:ma.adameit at gmail.com>> wrote:
>
>     I had the following idea to approach language evolution:
>
>     Problem:
>     Languages try to be backward compatible by stabilizing, and only
>     slowly deprecating old features. This results in a language which
>     does not evolve. Some different takes about this:
>     C++: adds new features but does not fix problems, and often does
>     not remove obsolete features resulting in, well, C++.
>     Python: Minor versions which add new features, big version jump
>     from 2 to 3 to make backward incompatible changes. The resulting
>     incompatibility was a big problem, almost 5 years after the
>     release of 3.0 (December 3rd, 2008) people are still using 2.x.
>     Rust seems to follow a similar approach, devs are already defering
>     features to 2.0 to stabilize.
>     Other languages simply do not evolve at all and are replaced.
>
>     My idea to improve this situation would be to add a version tag in
>     every main crate, something like "#ver 0.10". For each version
>     jump the compiler would fix the code automatically, and convert it
>     to the current language specification. When the library/code is
>     multiple versions behind the conversions could be applied
>     successively. This can be done in a lot of cases, see python 2to3
>     script and even Google did this for go with the tool gofix during
>     development. With this change not updated libraries would still be
>     usable in rust. To simplify updating libraries the compiler could,
>     on demand, print out a report of problematic parts and propose
>     fixes. Some things can not be fixed with an automatic approach,
>     for these cases a classic deprecation mechanism or something else
>     could still be used.
>
>     Advantages:
>     Kind of backward compatibility to old code bases.
>     Rust can evolve and stay streamlined at the same time.
>     Compiler does not have to deal with deprecation mechanism, because
>     you can remove, and change things instantly.
>
>     When this would be in place i think it would be best to release
>     incompatible updates often, but with only a few changes. Every six
>     months for example.
>
>
>     What do you think about this?
>
>     Manuel
>
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131124/e0670bd6/attachment.html>

From ben.striegel at gmail.com  Sun Nov 24 07:39:38 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sun, 24 Nov 2013 10:39:38 -0500
Subject: [rust-dev] Some questions about dead-code elimination pass
In-Reply-To: <CA++BO6Q+HFNSqj4Q=E6tvTxa2oJQQDhfMx6K8ABxfhWm9uqxzg@mail.gmail.com>
References: <CACeDKetYC9uV+v68vCUozs4uj+xUSxpuSSw_=MGCfRM53-=Uxw@mail.gmail.com>
	<CA++BO6Q+HFNSqj4Q=E6tvTxa2oJQQDhfMx6K8ABxfhWm9uqxzg@mail.gmail.com>
Message-ID: <CAAvrL-=Wf_5=110nGMSzvQHKNyG_Z0a+CQ7_K05-Q92=gRgUWw@mail.gmail.com>

> LLVM does, yes, but I'd still be interested in a perf comparison of us
> not translating the dead code compared to LLVM stripping it later.
> Clang does this, for example.

But if the idea here is also to provide a dead-code warning during
compilation, is it necessary to add this feature to the front-end or should
we presume that compilation-speed-conscious users will acknowledge the
warning and remove that code?


On Sun, Nov 24, 2013 at 8:38 AM, Corey Richardson <corey at octayn.net> wrote:

> On Sat, Nov 23, 2013 at 10:44 PM, Kiet Tran <ktt3ja at virginia.edu> wrote:
> > 1. Is doing part (b) necessary? That is, does LLVM's optimization
> > already eliminate unused code?
> >
>
> LLVM does, yes, but I'd still be interested in a perf comparison of us
> not translating the dead code compared to LLVM stripping it later.
> Clang does this, for example.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131124/4fbe47dd/attachment-0001.html>

From niko at alum.mit.edu  Mon Nov 25 02:56:21 2013
From: niko at alum.mit.edu (Niko Matsakis)
Date: Mon, 25 Nov 2013 05:56:21 -0500
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
Message-ID: <20131125105621.GC2317@Mr-Bennet>

On Wed, Nov 20, 2013 at 09:33:15PM +0100, G?bor Lehel wrote:
> This is an even sillier idea, but then what about keeping `loop` and
> dropping `while`?

We considered this for a while -- as well as making `loop if` be the
way you write `while` -- and decided "why antagonize people."
Besides, `while` has it's place.


Niko

From val at markovic.io  Mon Nov 25 08:32:06 2013
From: val at markovic.io (Val Markovic)
Date: Mon, 25 Nov 2013 08:32:06 -0800
Subject: [rust-dev] list of all reserved keywords of the language
In-Reply-To: <20131125105621.GC2317@Mr-Bennet>
References: <CANK7tAEseCur7XyviPdDV3nMfg=gdq=4irQ6UFt=nnrCkEnXnw@mail.gmail.com>
	<CAOvJiVUmDXK2u67V3UFs_q=9=pc9=vWe9n+YNvHwSjQR6TcvCA@mail.gmail.com>
	<CA+DvKQLqKq4Vb785oLGJBqdc=chUK92At_R9bRy1++==hknH7Q@mail.gmail.com>
	<CACQYfiLgWFyxwAyVnO6CMm3mrcsSbyV8sr4we9xDNZyw3XdWRQ@mail.gmail.com>
	<528B44D0.6080401@gmail.com>
	<CA+DvKQKp1oP2RW+KK3jGCBOLV8pG033AdyYe1NR0TTSO=eZuQA@mail.gmail.com>
	<528B8173.9060201@mozilla.com> <20131120171408.GG11345@Mr-Bennet>
	<528D014F.3040406@mozilla.com>
	<CAPNUp0-D_SkX+an0y__OhocW+E5P0BYDbjZzk5pETR=no1VZxg@mail.gmail.com>
	<20131125105621.GC2317@Mr-Bennet>
Message-ID: <CAK9U+m0CCWVU9gfKwfgdEPUJtta4bzMJ2xmcO7Hf27ABcBFFEg@mail.gmail.com>

On Mon, Nov 25, 2013 at 2:56 AM, Niko Matsakis <niko at alum.mit.edu> wrote:

> On Wed, Nov 20, 2013 at 09:33:15PM +0100, G?bor Lehel wrote:
> > This is an even sillier idea, but then what about keeping `loop` and
> > dropping `while`?
>
> We considered this for a while -- as well as making `loop if` be the
> way you write `while` -- and decided "why antagonize people."


That was the correct decision. While some of us might think that "loop if"
is a better way of saying "while" (I'd include myself here), the latter is
so entrenched that changing it would only make newcomers angry for little
(if any) benefit.


> Besides, `while` has it's place.
>
>
> Niko
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131125/c329e07c/attachment.html>

From corey at octayn.net  Tue Nov 26 00:58:58 2013
From: corey at octayn.net (Corey Richardson)
Date: Tue, 26 Nov 2013 03:58:58 -0500
Subject: [rust-dev] Mentoring + E-easy
Message-ID: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>

Hey fellow Rusties,

We have a fair number of new contributors, and my devious mind wonders
how we can get more. My first thought was a new tag, E-mentored, where
someone can volunteer to mentor someone through an E-easy issue. It's
a very lightweight, non-formal process, and can hopefully give some
more guidance to people who come into #rust asking for a good issue to
get started with.

This is intended for brand-new contributors, whereas I feel E-easy is
a teeny bit misused.

I also propose that, when tagging an issue as E-easy, a comment
describing the nature of the fix and where (file + function ideal) one
would look to start the fix.

From singingboyo at gmail.com  Tue Nov 26 01:03:25 2013
From: singingboyo at gmail.com (Brandon Sanderson)
Date: Tue, 26 Nov 2013 01:03:25 -0800
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
Message-ID: <CAK-XjKUxy_SYhjR1zbwOfj1yhFuFcXLY8RCcUeSTtkRxGGbcdg@mail.gmail.com>

I'd definitely be in support of the change to easy tagging - I've seen
quute a few issues where I've thought 'I could do this' but then realized I
have no idea where to start.
On 2013-11-26 12:59 AM, "Corey Richardson" <corey at octayn.net> wrote:

> Hey fellow Rusties,
>
> We have a fair number of new contributors, and my devious mind wonders
> how we can get more. My first thought was a new tag, E-mentored, where
> someone can volunteer to mentor someone through an E-easy issue. It's
> a very lightweight, non-formal process, and can hopefully give some
> more guidance to people who come into #rust asking for a good issue to
> get started with.
>
> This is intended for brand-new contributors, whereas I feel E-easy is
> a teeny bit misused.
>
> I also propose that, when tagging an issue as E-easy, a comment
> describing the nature of the fix and where (file + function ideal) one
> would look to start the fix.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131126/871ea310/attachment.html>

From gaetan at xeberon.net  Tue Nov 26 01:11:50 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 26 Nov 2013 10:11:50 +0100
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CAK-XjKUxy_SYhjR1zbwOfj1yhFuFcXLY8RCcUeSTtkRxGGbcdg@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
	<CAK-XjKUxy_SYhjR1zbwOfj1yhFuFcXLY8RCcUeSTtkRxGGbcdg@mail.gmail.com>
Message-ID: <CANK7tAFAqzxxznM+10G4DX5gvR=kdCAOkyt=E-7TLw_MLNPesA@mail.gmail.com>

agree !

-----
Gaetan



2013/11/26 Brandon Sanderson <singingboyo at gmail.com>

> I'd definitely be in support of the change to easy tagging - I've seen
> quute a few issues where I've thought 'I could do this' but then realized I
> have no idea where to start.
>  On 2013-11-26 12:59 AM, "Corey Richardson" <corey at octayn.net> wrote:
>
>> Hey fellow Rusties,
>>
>> We have a fair number of new contributors, and my devious mind wonders
>> how we can get more. My first thought was a new tag, E-mentored, where
>> someone can volunteer to mentor someone through an E-easy issue. It's
>> a very lightweight, non-formal process, and can hopefully give some
>> more guidance to people who come into #rust asking for a good issue to
>> get started with.
>>
>> This is intended for brand-new contributors, whereas I feel E-easy is
>> a teeny bit misused.
>>
>> I also propose that, when tagging an issue as E-easy, a comment
>> describing the nature of the fix and where (file + function ideal) one
>> would look to start the fix.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131126/1c001b17/attachment.html>

From denis.spir at gmail.com  Tue Nov 26 01:31:19 2013
From: denis.spir at gmail.com (spir)
Date: Tue, 26 Nov 2013 10:31:19 +0100
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CAK-XjKUxy_SYhjR1zbwOfj1yhFuFcXLY8RCcUeSTtkRxGGbcdg@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
	<CAK-XjKUxy_SYhjR1zbwOfj1yhFuFcXLY8RCcUeSTtkRxGGbcdg@mail.gmail.com>
Message-ID: <52946A67.1040202@gmail.com>

On 11/26/2013 10:03 AM, Brandon Sanderson wrote:
> I'd definitely be in support of the change to easy tagging - I've seen
> quute a few issues where I've thought 'I could do this' but then realized I
> have no idea where to start.
> On 2013-11-26 12:59 AM, "Corey Richardson" <corey at octayn.net> wrote:

Same for me. Even if it's obviously easy, even trivial, (1) there are usually 
some annoying, unknown points of the lang itself involved (2) we don't know the 
code base!

People seem never to take the latter point into account when tagging the 
difficulty level of an issue to be solved, while in fact it is the main barrier; 
not the difficulty of correcting the issue itself. A trivial, 3 min, correction 
can require weeks of discovering, understanding, "digesting", the relevant parts 
of the code base.

Side-note: as a consequence, "un-quality", in particular un-clarity, of a code 
base is for me the blocker #1 to participation. A possible good side-effect to 
this mentoring project is that it may help & improve code clarity and overall 
quality: novices will stump on numerous code issues, and mentors themselves will 
feel uneasy when having to explain "bad" parts of the code. ==> amelioration

Denis

From dteller at mozilla.com  Tue Nov 26 01:40:59 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Tue, 26 Nov 2013 10:40:59 +0100
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
Message-ID: <52946CAB.7020505@mozilla.com>

It would be great if these bugs could be indexed by Bugsahoy:
 http://www.joshmatthews.net/bugsahoy/
This is the search system we use in Mozilla to lead contributors towards
mentored tasks, so that would only make sense.

Cheers,
 David

On 11/26/13 9:58 AM, Corey Richardson wrote:
> Hey fellow Rusties,
> 
> We have a fair number of new contributors, and my devious mind wonders
> how we can get more. My first thought was a new tag, E-mentored, where
> someone can volunteer to mentor someone through an E-easy issue. It's
> a very lightweight, non-formal process, and can hopefully give some
> more guidance to people who come into #rust asking for a good issue to
> get started with.
> 
> This is intended for brand-new contributors, whereas I feel E-easy is
> a teeny bit misused.
> 
> I also propose that, when tagging an issue as E-easy, a comment
> describing the nature of the fix and where (file + function ideal) one
> would look to start the fix.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 


-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From gaetan at xeberon.net  Tue Nov 26 02:07:00 2013
From: gaetan at xeberon.net (Gaetan)
Date: Tue, 26 Nov 2013 11:07:00 +0100
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <52946CAB.7020505@mozilla.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
	<52946CAB.7020505@mozilla.com>
Message-ID: <CANK7tAEn7-tqJy-gSmYinDio_c+EMZd1E52Q7AOOqQmoUt03Lw@mail.gmail.com>

I strongly support this kind of human to human interaction. When arriving
in a new project, there is a lot things to know that is not properly
described in a proper document, set of general rules, etc. Things like how
to handle this error situation, or weird error message from the compiler. I
don't want to annoy the mailing list with obvious error message, trivial
situations.

I think we can learn a lot from well organised documentation, but talking
to someone who already know is extremely valuable.

-----
Gaetan



2013/11/26 David Rajchenbach-Teller <dteller at mozilla.com>

> It would be great if these bugs could be indexed by Bugsahoy:
>  http://www.joshmatthews.net/bugsahoy/
> This is the search system we use in Mozilla to lead contributors towards
> mentored tasks, so that would only make sense.
>
> Cheers,
>  David
>
> On 11/26/13 9:58 AM, Corey Richardson wrote:
> > Hey fellow Rusties,
> >
> > We have a fair number of new contributors, and my devious mind wonders
> > how we can get more. My first thought was a new tag, E-mentored, where
> > someone can volunteer to mentor someone through an E-easy issue. It's
> > a very lightweight, non-formal process, and can hopefully give some
> > more guidance to people who come into #rust asking for a good issue to
> > get started with.
> >
> > This is intended for brand-new contributors, whereas I feel E-easy is
> > a teeny bit misused.
> >
> > I also propose that, when tagging an issue as E-easy, a comment
> > describing the nature of the fix and where (file + function ideal) one
> > would look to start the fix.
> > _______________________________________________
> > Rust-dev mailing list
> > Rust-dev at mozilla.org
> > https://mail.mozilla.org/listinfo/rust-dev
> >
>
>
> --
> David Rajchenbach-Teller, PhD
>  Performance Team, Mozilla
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131126/19e883fb/attachment-0001.html>

From philippe.delrieu at free.fr  Tue Nov 26 10:15:44 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Tue, 26 Nov 2013 19:15:44 +0100
Subject: [rust-dev] Json example code
In-Reply-To: <528FA0D3.80804@free.fr>
References: <528F16CB.7090108@free.fr>	<CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
	<528FA0D3.80804@free.fr>
Message-ID: <5294E550.4020601@free.fr>

I try to commit my change on json.rs but I didn't manage to make it work.
I'am not very use to git. I've done :
 >git clone https://github.com/mozilla/rust.git
 >git rebase master
 >git push  --> error 403. I use my github account

Sorry for to ask for get but can anybody tell me what to do to send my 
change.

Philippe Delrieu

Le 22/11/2013 19:22, Philippe Delrieu a ?crit :
> I've done the modification in json.rs (add comment with sample code in 
> md format and test code).
> I've do the commit and git pull.
>
> The test compile but I didn't manage to run it.
> I use the command: make -j 20 check TESTNAME=src/libextra/json.rs
> There are errors before and when I force the assert to false I have no 
> error for json.
>
> Tell me if it's ok.
>
> Philippe
>
> Le 22/11/2013 10:07, Corey Richardson a ?crit :
>> On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
>> <philippe.delrieu at free.fr> wrote:
>>> I finished my test with the rust json API. I made a non trivial 
>>> example code
>>> that summaries what I understand. I put it at the end of the mail. 
>>> Could
>>> someone (the developer of the API for example) add it to the comment 
>>> of the
>>> json API. I don't think I have the right. It can be good to add it 
>>> as a test
>>> case to validate that it stay up to date.
>>> Put any remarks about the code if I've made some mistake or if there is
>>> better code.
>>>
>> Send a pull request adding it.
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From clements at brinckerhoff.org  Tue Nov 26 13:43:01 2013
From: clements at brinckerhoff.org (John Clements)
Date: Tue, 26 Nov 2013 13:43:01 -0800
Subject: [rust-dev] Json example code
In-Reply-To: <5294E550.4020601@free.fr>
References: <528F16CB.7090108@free.fr>	<CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
	<528FA0D3.80804@free.fr> <5294E550.4020601@free.fr>
Message-ID: <37DCE644-B840-4DC8-877B-C36DBE9E6714@brinckerhoff.org>


On Nov 26, 2013, at 10:15 AM, Philippe Delrieu wrote:

> I try to commit my change on json.rs but I didn't manage to make it work.
> I'am not very use to git. I've done :
> >git clone https://github.com/mozilla/rust.git
> >git rebase master
> >git push  --> error 403. I use my github account
> 
> Sorry for to ask for get but can anybody tell me what to do to send my change.

For Rust (and most other projects of this size), you can't just push to the master thread. What you need to do instead is to issue a "Pull Request". This says, in effect: "Hey Rust developers: here's a patch! Would you put it into the tree?"  

In order to do this, you'll want to go to github, fork the rust project, make changes to your own repo, push the changes back to your own repo, then click the "Pull Request" button to request integration of your changes into mozilla's repo.

That was a super-high-level overview, sorry for being so brief.

John Clements

> 
> Philippe Delrieu
> 
> Le 22/11/2013 19:22, Philippe Delrieu a ?crit :
>> I've done the modification in json.rs (add comment with sample code in md format and test code).
>> I've do the commit and git pull.
>> 
>> The test compile but I didn't manage to run it.
>> I use the command: make -j 20 check TESTNAME=src/libextra/json.rs
>> There are errors before and when I force the assert to false I have no error for json.
>> 
>> Tell me if it's ok.
>> 
>> Philippe
>> 
>> Le 22/11/2013 10:07, Corey Richardson a ?crit :
>>> On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
>>> <philippe.delrieu at free.fr> wrote:
>>>> I finished my test with the rust json API. I made a non trivial example code
>>>> that summaries what I understand. I put it at the end of the mail. Could
>>>> someone (the developer of the API for example) add it to the comment of the
>>>> json API. I don't think I have the right. It can be good to add it as a test
>>>> case to validate that it stay up to date.
>>>> Put any remarks about the code if I've made some mistake or if there is
>>>> better code.
>>>> 
>>> Send a pull request adding it.
>>> 
>>> 
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
> 
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From platt.nicholas at gmail.com  Tue Nov 26 10:13:47 2013
From: platt.nicholas at gmail.com (Nicholas Platt)
Date: Tue, 26 Nov 2013 13:13:47 -0500
Subject: [rust-dev] Mentoring + E-easy
In-Reply-To: <CANK7tAEn7-tqJy-gSmYinDio_c+EMZd1E52Q7AOOqQmoUt03Lw@mail.gmail.com>
References: <CA++BO6RnHaz-3W-Hgc3Pf6w7hoVFQJAi9tkv7OniPKyTHv1vMg@mail.gmail.com>
	<52946CAB.7020505@mozilla.com>
	<CANK7tAEn7-tqJy-gSmYinDio_c+EMZd1E52Q7AOOqQmoUt03Lw@mail.gmail.com>
Message-ID: <CAGbqFKnNFfgt9h5Zp4FWUCSTT6q3BGMBXPHAdeViHWYhVLqVWQ@mail.gmail.com>

This sounds like a very appealing option for someone like myself who is
looking
to contribute but lacks experience and know-how. I'll be following this
thread
and am encouraged by the willingness of developers to bring on new members.



On Tue, Nov 26, 2013 at 5:07 AM, Gaetan <gaetan at xeberon.net> wrote:

> I strongly support this kind of human to human interaction. When arriving
> in a new project, there is a lot things to know that is not properly
> described in a proper document, set of general rules, etc. Things like how
> to handle this error situation, or weird error message from the compiler. I
> don't want to annoy the mailing list with obvious error message, trivial
> situations.
>
> I think we can learn a lot from well organised documentation, but talking
> to someone who already know is extremely valuable.
>
> -----
> Gaetan
>
>
>
> 2013/11/26 David Rajchenbach-Teller <dteller at mozilla.com>
>
>> It would be great if these bugs could be indexed by Bugsahoy:
>>  http://www.joshmatthews.net/bugsahoy/
>> This is the search system we use in Mozilla to lead contributors towards
>> mentored tasks, so that would only make sense.
>>
>> Cheers,
>>  David
>>
>> On 11/26/13 9:58 AM, Corey Richardson wrote:
>> > Hey fellow Rusties,
>> >
>> > We have a fair number of new contributors, and my devious mind wonders
>> > how we can get more. My first thought was a new tag, E-mentored, where
>> > someone can volunteer to mentor someone through an E-easy issue. It's
>> > a very lightweight, non-formal process, and can hopefully give some
>> > more guidance to people who come into #rust asking for a good issue to
>> > get started with.
>> >
>> > This is intended for brand-new contributors, whereas I feel E-easy is
>> > a teeny bit misused.
>> >
>> > I also propose that, when tagging an issue as E-easy, a comment
>> > describing the nature of the fix and where (file + function ideal) one
>> > would look to start the fix.
>> > _______________________________________________
>> > Rust-dev mailing list
>> > Rust-dev at mozilla.org
>> > https://mail.mozilla.org/listinfo/rust-dev
>> >
>>
>>
>> --
>> David Rajchenbach-Teller, PhD
>>  Performance Team, Mozilla
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131126/1c60a4fe/attachment.html>

From andrew at andrewchin.net  Tue Nov 26 10:30:05 2013
From: andrew at andrewchin.net (Andrew Chin)
Date: Tue, 26 Nov 2013 13:30:05 -0500
Subject: [rust-dev] Json example code
In-Reply-To: <5294E550.4020601@free.fr>
References: <528F16CB.7090108@free.fr>
	<CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
	<528FA0D3.80804@free.fr> <5294E550.4020601@free.fr>
Message-ID: <CAFanbzdLhO82UPZQ8UU22FFtX9kpem+2nZM8KxazbmfnuuV4SA@mail.gmail.com>

You must fork the rust repository, and then push your changes to your
fork, and then open a pull request.

See https://github.com/mozilla/rust/wiki/Note-development-policy and
https://github.com/mozilla/rust/wiki/Note-git-workflow


On Tue, Nov 26, 2013 at 1:15 PM, Philippe Delrieu
<philippe.delrieu at free.fr> wrote:
> I try to commit my change on json.rs but I didn't manage to make it work.
> I'am not very use to git. I've done :
>>git clone https://github.com/mozilla/rust.git
>>git rebase master
>>git push  --> error 403. I use my github account
>
> Sorry for to ask for get but can anybody tell me what to do to send my
> change.
>
> Philippe Delrieu
>
> Le 22/11/2013 19:22, Philippe Delrieu a ?crit :
>
>> I've done the modification in json.rs (add comment with sample code in md
>> format and test code).
>> I've do the commit and git pull.
>>
>> The test compile but I didn't manage to run it.
>> I use the command: make -j 20 check TESTNAME=src/libextra/json.rs
>> There are errors before and when I force the assert to false I have no
>> error for json.
>>
>> Tell me if it's ok.
>>
>> Philippe
>>
>> Le 22/11/2013 10:07, Corey Richardson a ?crit :
>>>
>>> On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
>>> <philippe.delrieu at free.fr> wrote:
>>>>
>>>> I finished my test with the rust json API. I made a non trivial example
>>>> code
>>>> that summaries what I understand. I put it at the end of the mail. Could
>>>> someone (the developer of the API for example) add it to the comment of
>>>> the
>>>> json API. I don't think I have the right. It can be good to add it as a
>>>> test
>>>> case to validate that it stay up to date.
>>>> Put any remarks about the code if I've made some mistake or if there is
>>>> better code.
>>>>
>>> Send a pull request adding it.
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev



-- 
Andrew Chin | andrew at andrewchin.net

From philippe.delrieu at free.fr  Tue Nov 26 22:43:55 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Wed, 27 Nov 2013 07:43:55 +0100
Subject: [rust-dev] Json example code
In-Reply-To: <37DCE644-B840-4DC8-877B-C36DBE9E6714@brinckerhoff.org>
References: <528F16CB.7090108@free.fr>	<CA++BO6RYbaO44UPBUKCzNb_NLXaHemC5fWY7W9HJ7Y1zp+MLcw@mail.gmail.com>
	<528FA0D3.80804@free.fr> <5294E550.4020601@free.fr>
	<37DCE644-B840-4DC8-877B-C36DBE9E6714@brinckerhoff.org>
Message-ID: <529594AB.3030403@free.fr>

Thank you for your help.
I manage to make it works. Now I know how to do it. I miss the fork in 
my first attempt that why it can't work.

Philippe

Le 26/11/2013 22:43, John Clements a ?crit :
> On Nov 26, 2013, at 10:15 AM, Philippe Delrieu wrote:
>
>> I try to commit my change on json.rs but I didn't manage to make it work.
>> I'am not very use to git. I've done :
>>> git clone https://github.com/mozilla/rust.git
>>> git rebase master
>>> git push  --> error 403. I use my github account
>> Sorry for to ask for get but can anybody tell me what to do to send my change.
> For Rust (and most other projects of this size), you can't just push to the master thread. What you need to do instead is to issue a "Pull Request". This says, in effect: "Hey Rust developers: here's a patch! Would you put it into the tree?"
>
> In order to do this, you'll want to go to github, fork the rust project, make changes to your own repo, push the changes back to your own repo, then click the "Pull Request" button to request integration of your changes into mozilla's repo.
>
> That was a super-high-level overview, sorry for being so brief.
>
> John Clements
>
>> Philippe Delrieu
>>
>> Le 22/11/2013 19:22, Philippe Delrieu a ?crit :
>>> I've done the modification in json.rs (add comment with sample code in md format and test code).
>>> I've do the commit and git pull.
>>>
>>> The test compile but I didn't manage to run it.
>>> I use the command: make -j 20 check TESTNAME=src/libextra/json.rs
>>> There are errors before and when I force the assert to false I have no error for json.
>>>
>>> Tell me if it's ok.
>>>
>>> Philippe
>>>
>>> Le 22/11/2013 10:07, Corey Richardson a ?crit :
>>>> On Fri, Nov 22, 2013 at 3:33 AM, Philippe Delrieu
>>>> <philippe.delrieu at free.fr> wrote:
>>>>> I finished my test with the rust json API. I made a non trivial example code
>>>>> that summaries what I understand. I put it at the end of the mail. Could
>>>>> someone (the developer of the API for example) add it to the comment of the
>>>>> json API. I don't think I have the right. It can be good to add it as a test
>>>>> case to validate that it stay up to date.
>>>>> Put any remarks about the code if I've made some mistake or if there is
>>>>> better code.
>>>>>
>>>> Send a pull request adding it.
>>>>
>>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>


From omeragacan at gmail.com  Wed Nov 27 19:37:23 2013
From: omeragacan at gmail.com (=?ISO-8859-9?Q?=D6mer_Sinan_A=F0acan?=)
Date: Thu, 28 Nov 2013 05:37:23 +0200
Subject: [rust-dev] any tips and tricks for faster compilation of compiler
	itself?
Message-ID: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>

Hello everyone,

I'm trying to make some changes on the Rust compiler(and I'll
hopefully open some pull requests) but I'm suffering from incredibly
long compilation times. I know some part of it is related with my
computer but I don't have anything to do about that for now, so I'm
looking for tips and tricks to make compilation of compiler itself
faster on same hardware.

Any helps would be really appreciated, currently one line of trivial
change takes literally 5+ minutes to compile on my system.

Thanks,

From corey at octayn.net  Wed Nov 27 19:44:19 2013
From: corey at octayn.net (Corey Richardson)
Date: Wed, 27 Nov 2013 22:44:19 -0500
Subject: [rust-dev] any tips and tricks for faster compilation of
	compiler itself?
In-Reply-To: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
References: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
Message-ID: <CA++BO6Q1fQtaMQarmccZWXfQBo8KTPx+FV=EBwMersOraDOOTg@mail.gmail.com>

5+ minutes isn't bad, actually. On my (fairly beefy) desktop building
stage1 takes about that long. There isn't really too much to do to
help with compile times right now, unfortunately :( The only advice I
have is "don't bootstrap": use the stage1 make targets. Their names
slip my mind, so someone else will have to toss them out there. `make
check-stage1` in particular is useful, though, and `make
check-stage1-std NO_REBUILD=1` can help if you're working on the std
lib and not the compiler.

On Wed, Nov 27, 2013 at 10:37 PM, ?mer Sinan A?acan
<omeragacan at gmail.com> wrote:
> Hello everyone,
>
> I'm trying to make some changes on the Rust compiler(and I'll
> hopefully open some pull requests) but I'm suffering from incredibly
> long compilation times. I know some part of it is related with my
> computer but I don't have anything to do about that for now, so I'm
> looking for tips and tricks to make compilation of compiler itself
> faster on same hardware.
>
> Any helps would be really appreciated, currently one line of trivial
> change takes literally 5+ minutes to compile on my system.
>
> Thanks,
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

From josh at joshmatthews.net  Wed Nov 27 21:54:46 2013
From: josh at joshmatthews.net (Josh Matthews)
Date: Thu, 28 Nov 2013 00:54:46 -0500
Subject: [rust-dev] any tips and tricks for faster compilation of
	compiler itself?
In-Reply-To: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
References: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
Message-ID: <CAOvJiVUUEFGR_6Ui+9JOVyeuaLyDZn9T6y7hzNeLZEsdUiWFoA@mail.gmail.com>

I recommend 'make rustc-stage1' to ensure that your changes build, then
'make check-stage1' to run tests like compile-fail/run-fail/run-pass.

Cheers,
Josh


On 27 November 2013 22:37, ?mer Sinan A?acan <omeragacan at gmail.com> wrote:

> Hello everyone,
>
> I'm trying to make some changes on the Rust compiler(and I'll
> hopefully open some pull requests) but I'm suffering from incredibly
> long compilation times. I know some part of it is related with my
> computer but I don't have anything to do about that for now, so I'm
> looking for tips and tricks to make compilation of compiler itself
> faster on same hardware.
>
> Any helps would be really appreciated, currently one line of trivial
> change takes literally 5+ minutes to compile on my system.
>
> Thanks,
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131128/f4c46a79/attachment.html>

From remifontan at yahoo.fr  Thu Nov 28 01:26:31 2013
From: remifontan at yahoo.fr (=?UTF-8?B?UsOpbWkgRm9udGFu?=)
Date: Thu, 28 Nov 2013 22:26:31 +1300
Subject: [rust-dev] function overloading,
	double dispatch technique and performance
Message-ID: <CAFKqbfR0d2_q7P7ZwW1s7UVr=_soqvESK0vBtXfwyrOvSO_Sjw@mail.gmail.com>

Hi,

would you know what is the cost of implementing the double dispatch
technique as described on following link? (section "What if I want
overloading?")


http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/

does using traits means making used of something similar to vtable? Or
would the compiler optimise those double dispatch to a very optimise code?

The motivation is to have multiple implementation of mathematical operators
for struct like vector 2d, 3d, matrices, and having them as efficient as
possible is important.

cheers,

R?mi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131128/62179462/attachment.html>

From dbau.pp at gmail.com  Thu Nov 28 02:00:34 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Thu, 28 Nov 2013 21:00:34 +1100
Subject: [rust-dev] function overloading,
 double dispatch technique and performance
In-Reply-To: <CAFKqbfR0d2_q7P7ZwW1s7UVr=_soqvESK0vBtXfwyrOvSO_Sjw@mail.gmail.com>
References: <CAFKqbfR0d2_q7P7ZwW1s7UVr=_soqvESK0vBtXfwyrOvSO_Sjw@mail.gmail.com>
Message-ID: <52971442.4030801@gmail.com>

On 28/11/13 20:26, R?mi Fontan wrote:
> Hi,
>
> would you know what is the cost of implementing the double dispatch 
> technique as described on following link? (section "What if I want 
> overloading?")
>
> http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/
>
> does using traits means making used of something similar to vtable? Or 
> would the compiler optimise those double dispatch to a very optimise code?
>
> The motivation is to have multiple implementation of mathematical 
> operators for struct like vector 2d, 3d, matrices, and having them as 
> efficient as possible is important.
>
> cheers,
>
> R?mi
>

Generics are always monomorphised to be static dispatch; explicit trait 
objects (~Trait, &Trait, etc) are the only times that one gets dynamic 
dispatch (using a vtable). So, trait methods be purely compile time if 
you never box the types into trait objects, i.e.

     fn static_with_generics<T: Trait>(x: &T) { ... }
     fn dynamic_with_vtables(x: &Trait) { ... }

The layered traits like in the example in that blog-post are the same as 
normal generics, just the compiler has to do a little more work (but 
this is only at compile time).

Huon

From philippe.delrieu at free.fr  Thu Nov 28 03:55:41 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Thu, 28 Nov 2013 12:55:41 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
Message-ID: <52972F3D.6010901@free.fr>

I try to develop a function that take a Encodable parameter but I have 
the error wrong number of type arguments: expected 1 but found 0

pub fn memory_encode(to_encode_object: &serialize::Encodable) -> @mut 
MemWriter  {
    //Serialize the object in a string using a writer
     let m = @mut MemWriter::new();
     let mut encoder = Encoder(m as @mut Writer);
     to_encode_object.encode(&mut encoder);
     m
}

The encodable trait is :
pub trait Encodable<S:Encoder> {
     fn encode(&self, s: &mut S);
}

I try this definition
memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object: &T) -> 
@mut MemWriter

But I can't use the method with a struct that implement Encodable. The 
error : mismatched types: expected `&<V31>` but found ..

I have another question :
I would like to return a MemWriter and not a @mut MemWriter . I didn't 
find a way to convert the @mut to ~

Philippe Delrieu

From omeragacan at gmail.com  Thu Nov 28 05:23:14 2013
From: omeragacan at gmail.com (=?ISO-8859-9?Q?=D6mer_Sinan_A=F0acan?=)
Date: Thu, 28 Nov 2013 15:23:14 +0200
Subject: [rust-dev] any tips and tricks for faster compilation of
	compiler itself?
In-Reply-To: <CAOvJiVUUEFGR_6Ui+9JOVyeuaLyDZn9T6y7hzNeLZEsdUiWFoA@mail.gmail.com>
References: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
	<CAOvJiVUUEFGR_6Ui+9JOVyeuaLyDZn9T6y7hzNeLZEsdUiWFoA@mail.gmail.com>
Message-ID: <CAMQQO3kNTrm3_Din5amO28oSaUxggy_6ANi9isoHMFLGDzhdMg@mail.gmail.com>

> I recommend 'make rustc-stage1' to ensure that your changes build, then
> 'make check-stage1' to run tests like compile-fail/run-fail/run-pass.

Thanks, I tried rustc-stage1 on one line of change and it took 19.43s. Awesome.

From omeragacan at gmail.com  Thu Nov 28 05:34:55 2013
From: omeragacan at gmail.com (=?ISO-8859-9?Q?=D6mer_Sinan_A=F0acan?=)
Date: Thu, 28 Nov 2013 15:34:55 +0200
Subject: [rust-dev] any tips and tricks for faster compilation of
	compiler itself?
In-Reply-To: <CAMQQO3kNTrm3_Din5amO28oSaUxggy_6ANi9isoHMFLGDzhdMg@mail.gmail.com>
References: <CAMQQO3nKKYxCAeUF+HuK2xFU3_O7OtVf9jtRiRBT_E7pJjsuhg@mail.gmail.com>
	<CAOvJiVUUEFGR_6Ui+9JOVyeuaLyDZn9T6y7hzNeLZEsdUiWFoA@mail.gmail.com>
	<CAMQQO3kNTrm3_Din5amO28oSaUxggy_6ANi9isoHMFLGDzhdMg@mail.gmail.com>
Message-ID: <CAMQQO3=5WBR-rX05o=WM+325uQ-eSGY5eJvAF3MeHywcWV7xRQ@mail.gmail.com>

> Thanks, I tried rustc-stage1 on one line of change and it took 19.43s. Awesome.

Or not. Apparently 19.43s was because I had an error in my code. Now
it took 285.13s.

From erick.tryzelaar at gmail.com  Thu Nov 28 13:27:27 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Thu, 28 Nov 2013 13:27:27 -0800
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <52972F3D.6010901@free.fr>
References: <52972F3D.6010901@free.fr>
Message-ID: <CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>

Good afternoon Phillippe,

Here's how to do it, assuming you're using rust 0.8 and the json library:

```
#[feature(managed_boxes)];

extern mod extra;

use std::io::mem::MemWriter;
use extra::serialize::{Encoder, Encodable};
use extra::json;

pub fn memory_encode<
    T: Encodable<json::Encoder>
>(to_encode_object: &T) -> @mut MemWriter {
    //Serialize the object in a string using a writer
    let m = @mut MemWriter::new();
    let mut encoder = json::Encoder(m as @mut Writer);
    to_encode_object.encode(&mut encoder);
    m
}

fn main() {
}
```

Regarding the trouble returning a `MemWriter` instead of a `@mut
MemWriter`, the easiest thing would be to fix library to use `&mut ...`
instead of `@mut ...`. I'll put in a PR to do that.



On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu
<philippe.delrieu at free.fr>wrote:

> I try to develop a function that take a Encodable parameter but I have the
> error wrong number of type arguments: expected 1 but found 0
>
> pub fn memory_encode(to_encode_object: &serialize::Encodable) -> @mut
> MemWriter  {
>    //Serialize the object in a string using a writer
>     let m = @mut MemWriter::new();
>     let mut encoder = Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     m
> }
>
> The encodable trait is :
> pub trait Encodable<S:Encoder> {
>     fn encode(&self, s: &mut S);
> }
>
> I try this definition
> memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object: &T) ->
> @mut MemWriter
>
> But I can't use the method with a struct that implement Encodable. The
> error : mismatched types: expected `&<V31>` but found ..
>
> I have another question :
> I would like to return a MemWriter and not a @mut MemWriter . I didn't
> find a way to convert the @mut to ~
>
> Philippe Delrieu
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131128/0f40e9ca/attachment.html>

From remifontan at yahoo.fr  Thu Nov 28 23:37:48 2013
From: remifontan at yahoo.fr (=?UTF-8?B?UsOpbWkgRm9udGFu?=)
Date: Fri, 29 Nov 2013 20:37:48 +1300
Subject: [rust-dev] function overloading,
	double dispatch technique and performance
In-Reply-To: <52971442.4030801@gmail.com>
References: <CAFKqbfR0d2_q7P7ZwW1s7UVr=_soqvESK0vBtXfwyrOvSO_Sjw@mail.gmail.com>
	<52971442.4030801@gmail.com>
Message-ID: <CAFKqbfSh6-_jo0y6k9u1Pxg_UpQ1=g3JphNdJD6qRgmBh0uFyA@mail.gmail.com>

good to know that.

thanks

R?mi


On Thu, Nov 28, 2013 at 11:00 PM, Huon Wilson <dbau.pp at gmail.com> wrote:

> On 28/11/13 20:26, R?mi Fontan wrote:
>
>> Hi,
>>
>> would you know what is the cost of implementing the double dispatch
>> technique as described on following link? (section "What if I want
>> overloading?")
>>
>> http://smallcultfollowing.com/babysteps/blog/2012/10/04/
>> refining-traits-slash-impls/
>>
>> does using traits means making used of something similar to vtable? Or
>> would the compiler optimise those double dispatch to a very optimise code?
>>
>> The motivation is to have multiple implementation of mathematical
>> operators for struct like vector 2d, 3d, matrices, and having them as
>> efficient as possible is important.
>>
>> cheers,
>>
>> R?mi
>>
>>
> Generics are always monomorphised to be static dispatch; explicit trait
> objects (~Trait, &Trait, etc) are the only times that one gets dynamic
> dispatch (using a vtable). So, trait methods be purely compile time if you
> never box the types into trait objects, i.e.
>
>     fn static_with_generics<T: Trait>(x: &T) { ... }
>     fn dynamic_with_vtables(x: &Trait) { ... }
>
> The layered traits like in the example in that blog-post are the same as
> normal generics, just the compiler has to do a little more work (but this
> is only at compile time).
>
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
R?mi Fontan : remifontan at yahoo.fr
mobile: +64 21 855 351
93 Otaki Street, Miramar 6022
Wellington, New Zealand
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/13490394/attachment.html>

From philippe.delrieu at free.fr  Fri Nov 29 00:27:13 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 29 Nov 2013 09:27:13 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>
References: <52972F3D.6010901@free.fr>
	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>
Message-ID: <52984FE1.80505@free.fr>

Thank you for the help. I've try this signature and I had an compile 
error. I thought it came from the signature but the problem when from 
the call.
It works now.

For the return type @mut MemWriter I work on the json doc and some 
example of use. I can make the change. I didn't find the issue about it. 
Did you create it?

Philippe

Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
> Good afternoon Phillippe,
>
> Here's how to do it, assuming you're using rust 0.8 and the json library:
>
> ```
> #[feature(managed_boxes)];
>
> extern mod extra;
>
> use std::io::mem::MemWriter;
> use extra::serialize::{Encoder, Encodable};
> use extra::json;
>
> pub fn memory_encode<
>     T: Encodable<json::Encoder>
> >(to_encode_object: &T) -> @mut MemWriter {
>     //Serialize the object in a string using a writer
>     let m = @mut MemWriter::new();
>     let mut encoder = json::Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     m
> }
>
> fn main() {
> }
> ```
>
> Regarding the trouble returning a `MemWriter` instead of a `@mut 
> MemWriter`, the easiest thing would be to fix library to use `&mut 
> ...` instead of `@mut ...`. I'll put in a PR to do that.
>
>
>
> On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu 
> <philippe.delrieu at free.fr <mailto:philippe.delrieu at free.fr>> wrote:
>
>     I try to develop a function that take a Encodable parameter but I
>     have the error wrong number of type arguments: expected 1 but found 0
>
>     pub fn memory_encode(to_encode_object: &serialize::Encodable) ->
>     @mut MemWriter  {
>        //Serialize the object in a string using a writer
>         let m = @mut MemWriter::new();
>         let mut encoder = Encoder(m as @mut Writer);
>         to_encode_object.encode(&mut encoder);
>         m
>     }
>
>     The encodable trait is :
>     pub trait Encodable<S:Encoder> {
>         fn encode(&self, s: &mut S);
>     }
>
>     I try this definition
>     memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object:
>     &T) -> @mut MemWriter
>
>     But I can't use the method with a struct that implement Encodable.
>     The error : mismatched types: expected `&<V31>` but found ..
>
>     I have another question :
>     I would like to return a MemWriter and not a @mut MemWriter . I
>     didn't find a way to convert the @mut to ~
>
>     Philippe Delrieu
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/f20e991e/attachment.html>

From gaetan at xeberon.net  Fri Nov 29 01:44:32 2013
From: gaetan at xeberon.net (Gaetan)
Date: Fri, 29 Nov 2013 10:44:32 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <52984FE1.80505@free.fr>
References: <52972F3D.6010901@free.fr>
	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>
	<52984FE1.80505@free.fr>
Message-ID: <CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>

I would prefere this function returns a str.
Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr> a
?crit :

>  Thank you for the help. I've try this signature and I had an compile
> error. I thought it came from the signature but the problem when from the
> call.
> It works now.
>
> For the return type @mut MemWriter I work on the json doc and some example
> of use. I can make the change. I didn't find the issue about it. Did you
> create it?
>
> Philippe
>
> Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>
>  Good afternoon Phillippe,
>
>  Here's how to do it, assuming you're using rust 0.8 and the json library:
>
> ```
> #[feature(managed_boxes)];
>
> extern mod extra;
>
> use std::io::mem::MemWriter;
> use extra::serialize::{Encoder, Encodable};
> use extra::json;
>
> pub fn memory_encode<
>     T: Encodable<json::Encoder>
> >(to_encode_object: &T) -> @mut MemWriter {
>     //Serialize the object in a string using a writer
>     let m = @mut MemWriter::new();
>     let mut encoder = json::Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     m
> }
>
> fn main() {
> }
> ```
>
>  Regarding the trouble returning a `MemWriter` instead of a `@mut
> MemWriter`, the easiest thing would be to fix library to use `&mut ...`
> instead of `@mut ...`. I'll put in a PR to do that.
>
>
>
> On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu <
> philippe.delrieu at free.fr> wrote:
>
>> I try to develop a function that take a Encodable parameter but I have
>> the error wrong number of type arguments: expected 1 but found 0
>>
>> pub fn memory_encode(to_encode_object: &serialize::Encodable) -> @mut
>> MemWriter  {
>>    //Serialize the object in a string using a writer
>>     let m = @mut MemWriter::new();
>>     let mut encoder = Encoder(m as @mut Writer);
>>     to_encode_object.encode(&mut encoder);
>>     m
>> }
>>
>> The encodable trait is :
>> pub trait Encodable<S:Encoder> {
>>     fn encode(&self, s: &mut S);
>> }
>>
>> I try this definition
>> memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object: &T) ->
>> @mut MemWriter
>>
>> But I can't use the method with a struct that implement Encodable. The
>> error : mismatched types: expected `&<V31>` but found ..
>>
>> I have another question :
>> I would like to return a MemWriter and not a @mut MemWriter . I didn't
>> find a way to convert the @mut to ~
>>
>> Philippe Delrieu
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/b3a5bc7d/attachment-0001.html>

From leo.testard at gmail.com  Fri Nov 29 03:01:09 2013
From: leo.testard at gmail.com (=?ISO-8859-1?Q?L=E9o_Testard?=)
Date: Fri, 29 Nov 2013 12:01:09 +0100
Subject: [rust-dev] Separated/Incremential compilation
Message-ID: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>

Hello,

I think everyone here will agree to say that compilation times in Rust are
problematic. Recently, there was an argument on IRC about reducing
compilation times by reducing the use of GC and failures. Although I agree
it's good to reduce Rustc's overhead, I think there are more important
problems. The total duration of a build matters only because you have to
recompile the whole crate on each modification. In C++, the duration of the
complete build of a project matters less because when you compile
incrementally, you only have to rebuild a couple of files - those you
modified. I know the "1 crate = 1 compilation unit" is the model chosen by
Rust, but this is a major issue for production. Nobody will ever use Rust
in production if they have to recompile thousands of lines of code on each
modification.

On some of my personal projects, I "solved" this problem by splitting the
codebase into several crates, that I compile statically, and then link
together using extern mod. This is not really a solution, because this
implies that there is no cyclic dependency between each of the small
crates, or I end up with issues trying to compile it, because using extern
mod requires that the library corresponding to that mod exists before
compiling the crate that depends on it.

But strictly speaking, a compiled crate is nothing more than a module
hierarchy, and so is a single Rust source file, so we should be able to
compile a single file to some sort of .o and then link all together to form
a crate. References to modules outside of this file just require the first
passes of the build, not the code generation, so it should be ok regarding
to cyclic dependencies, and if not, we could still introduce some kind of
auto-generated interface file, like Caml does. I know it's quite a big
work, and that the current system is quite good, but having this is very
important if we want Rust to be used in production.

Sorry if this topic has already been posted several times, but I feel this
is important, and the related issues seem to date (#2369). I think it's a
real mistake to report this to post-1.0.

Leo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/6ec7ecbb/attachment.html>

From eperso.mail at gmail.com  Fri Nov 29 03:22:51 2013
From: eperso.mail at gmail.com (Guillaume HERVIER)
Date: Fri, 29 Nov 2013 12:22:51 +0100
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
Message-ID: <5298790B.3090709@gmail.com>

+1 for this issue. I think that compilation time is really important if
we want Rust to be used as production language.

For example, I think that if we can reduce significantly the Rust
compiler's compilation time, it could allow more developers to
contribute to the Rust language (as they won't have to wait 30min for
each small modifications in the compiler).
Personally, it's the only thing which blocks me when I want to
contribute to Rust, because I like to often compile code when I do small
modifications to test each of these small modifications, partly because
I don't know the language very well.

On 11/29/2013 12:01 PM, L?o Testard wrote:
>
> Hello,
>
> I think everyone here will agree to say that compilation times in Rust
> are problematic. Recently, there was an argument on IRC about reducing
> compilation times by reducing the use of GC and failures. Although I
> agree it's good to reduce Rustc's overhead, I think there are more
> important problems. The total duration of a build matters only because
> you have to recompile the whole crate on each modification. In C++,
> the duration of the complete build of a project matters less because
> when you compile incrementally, you only have to rebuild a couple of
> files - those you modified. I know the "1 crate = 1 compilation unit"
> is the model chosen by Rust, but this is a major issue for production.
> Nobody will ever use Rust in production if they have to recompile
> thousands of lines of code on each modification.
>
> On some of my personal projects, I "solved" this problem by splitting
> the codebase into several crates, that I compile statically, and then
> link together using extern mod. This is not really a solution, because
> this implies that there is no cyclic dependency between each of the
> small crates, or I end up with issues trying to compile it, because
> using extern mod requires that the library corresponding to that mod
> exists before compiling the crate that depends on it.
>
> But strictly speaking, a compiled crate is nothing more than a module
> hierarchy, and so is a single Rust source file, so we should be able
> to compile a single file to some sort of .o and then link all together
> to form a crate. References to modules outside of this file just
> require the first passes of the build, not the code generation, so it
> should be ok regarding to cyclic dependencies, and if not, we could
> still introduce some kind of auto-generated interface file, like Caml
> does. I know it's quite a big work, and that the current system is
> quite good, but having this is very important if we want Rust to be
> used in production.
>
> Sorry if this topic has already been posted several times, but I feel
> this is important, and the related issues seem to date (#2369). I
> think it's a real mistake to report this to post-1.0.
>
> Leo
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/8c77f5bc/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 555 bytes
Desc: OpenPGP digital signature
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/8c77f5bc/attachment.sig>

From philippe.delrieu at free.fr  Fri Nov 29 03:55:38 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 29 Nov 2013 12:55:38 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>
	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>
Message-ID: <529880BA.2090006@free.fr>

I made a remark about that on the GitHub pull request where the idea was 
proposed. I'm agree with you. It's simplier  to return a str or perhaps 
a [u8] if it's use in a stream purpose.
I'm not very fan of creating a MemWriter and return it.

I'll modify to add two functions:
pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str
pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]

and remove the other.

Any remaqs?

Philippe


Le 29/11/2013 10:44, Gaetan a ?crit :
>
> I would prefere this function returns a str.
>
> Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr 
> <mailto:philippe.delrieu at free.fr>> a ?crit :
>
>     Thank you for the help. I've try this signature and I had an
>     compile error. I thought it came from the signature but the
>     problem when from the call.
>     It works now.
>
>     For the return type @mut MemWriter I work on the json doc and some
>     example of use. I can make the change. I didn't find the issue
>     about it. Did you create it?
>
>     Philippe
>
>     Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>>     Good afternoon Phillippe,
>>
>>     Here's how to do it, assuming you're using rust 0.8 and the json
>>     library:
>>
>>     ```
>>     #[feature(managed_boxes)];
>>
>>     extern mod extra;
>>
>>     use std::io::mem::MemWriter;
>>     use extra::serialize::{Encoder, Encodable};
>>     use extra::json;
>>
>>     pub fn memory_encode<
>>         T: Encodable<json::Encoder>
>>     >(to_encode_object: &T) -> @mut MemWriter {
>>         //Serialize the object in a string using a writer
>>         let m = @mut MemWriter::new();
>>         let mut encoder = json::Encoder(m as @mut Writer);
>>         to_encode_object.encode(&mut encoder);
>>         m
>>     }
>>
>>     fn main() {
>>     }
>>     ```
>>
>>     Regarding the trouble returning a `MemWriter` instead of a `@mut
>>     MemWriter`, the easiest thing would be to fix library to use
>>     `&mut ...` instead of `@mut ...`. I'll put in a PR to do that.
>>
>>
>>
>>     On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu
>>     <philippe.delrieu at free.fr <mailto:philippe.delrieu at free.fr>> wrote:
>>
>>         I try to develop a function that take a Encodable parameter
>>         but I have the error wrong number of type arguments: expected
>>         1 but found 0
>>
>>         pub fn memory_encode(to_encode_object: &serialize::Encodable)
>>         -> @mut MemWriter  {
>>            //Serialize the object in a string using a writer
>>             let m = @mut MemWriter::new();
>>             let mut encoder = Encoder(m as @mut Writer);
>>             to_encode_object.encode(&mut encoder);
>>             m
>>         }
>>
>>         The encodable trait is :
>>         pub trait Encodable<S:Encoder> {
>>             fn encode(&self, s: &mut S);
>>         }
>>
>>         I try this definition
>>         memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object:
>>         &T) -> @mut MemWriter
>>
>>         But I can't use the method with a struct that implement
>>         Encodable. The error : mismatched types: expected `&<V31>`
>>         but found ..
>>
>>         I have another question :
>>         I would like to return a MemWriter and not a @mut MemWriter .
>>         I didn't find a way to convert the @mut to ~
>>
>>         Philippe Delrieu
>>         _______________________________________________
>>         Rust-dev mailing list
>>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>         https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
>     _______________________________________________
>     Rust-dev mailing list
>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>     https://mail.mozilla.org/listinfo/rust-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/b3d49ff7/attachment-0001.html>

From philippe.delrieu at free.fr  Fri Nov 29 04:57:44 2013
From: philippe.delrieu at free.fr (Philippe Delrieu)
Date: Fri, 29 Nov 2013 13:57:44 +0100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <529880BA.2090006@free.fr>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>
	<529880BA.2090006@free.fr>
Message-ID: <52988F48.6010407@free.fr>

I try to implement the two methods and I have a problem with the copy of 
memory.
The first attempt :

  pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
~[u8]  {
    //Serialize the object in a string using a writer
     let m = @mut MemWriter::new();
     let mut encoder = Encoder(m as @mut Writer);
     to_encode_object.encode(&mut encoder);
     let buff:&~[u8] = m.inner_ref();
     (buff.clone())
}

pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
     let buff:~[u8] = buffer_encode(to_encode_object);
     str::from_utf8(*buff)
}

When I call str_encode I copy at least two times the content of the 
MemWriter buffer (one inside clone and one inside from_utf8).
If I implements str_encode like that

pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
     let m = @mut MemWriter::new();
     let mut encoder = Encoder(m as @mut Writer);
     to_encode_object.encode(&mut encoder);
     let buff:&~[u8] = m.inner_ref();
     str::from_utf8(*buff)
}

I'll do at least one copy (one less than the other impl) but the code is 
copied.

Is there a better way to manage pointer of memory across function calls?

Philippe

Le 29/11/2013 12:55, Philippe Delrieu a ?crit :
> I made a remark about that on the GitHub pull request where the idea 
> was proposed. I'm agree with you. It's simplier  to return a str or 
> perhaps a [u8] if it's use in a stream purpose.
> I'm not very fan of creating a MemWriter and return it.
>
> I'll modify to add two functions:
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str
> pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]
>
> and remove the other.
>
> Any remaqs?
>
> Philippe
>
>
> Le 29/11/2013 10:44, Gaetan a ?crit :
>>
>> I would prefere this function returns a str.
>>
>> Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr 
>> <mailto:philippe.delrieu at free.fr>> a ?crit :
>>
>>     Thank you for the help. I've try this signature and I had an
>>     compile error. I thought it came from the signature but the
>>     problem when from the call.
>>     It works now.
>>
>>     For the return type @mut MemWriter I work on the json doc and
>>     some example of use. I can make the change. I didn't find the
>>     issue about it. Did you create it?
>>
>>     Philippe
>>
>>     Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>>>     Good afternoon Phillippe,
>>>
>>>     Here's how to do it, assuming you're using rust 0.8 and the json
>>>     library:
>>>
>>>     ```
>>>     #[feature(managed_boxes)];
>>>
>>>     extern mod extra;
>>>
>>>     use std::io::mem::MemWriter;
>>>     use extra::serialize::{Encoder, Encodable};
>>>     use extra::json;
>>>
>>>     pub fn memory_encode<
>>>         T: Encodable<json::Encoder>
>>>     >(to_encode_object: &T) -> @mut MemWriter {
>>>         //Serialize the object in a string using a writer
>>>         let m = @mut MemWriter::new();
>>>         let mut encoder = json::Encoder(m as @mut Writer);
>>>         to_encode_object.encode(&mut encoder);
>>>         m
>>>     }
>>>
>>>     fn main() {
>>>     }
>>>     ```
>>>
>>>     Regarding the trouble returning a `MemWriter` instead of a `@mut
>>>     MemWriter`, the easiest thing would be to fix library to use
>>>     `&mut ...` instead of `@mut ...`. I'll put in a PR to do that.
>>>
>>>
>>>
>>>     On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu
>>>     <philippe.delrieu at free.fr <mailto:philippe.delrieu at free.fr>> wrote:
>>>
>>>         I try to develop a function that take a Encodable parameter
>>>         but I have the error wrong number of type arguments:
>>>         expected 1 but found 0
>>>
>>>         pub fn memory_encode(to_encode_object:
>>>         &serialize::Encodable) -> @mut MemWriter  {
>>>            //Serialize the object in a string using a writer
>>>             let m = @mut MemWriter::new();
>>>             let mut encoder = Encoder(m as @mut Writer);
>>>             to_encode_object.encode(&mut encoder);
>>>             m
>>>         }
>>>
>>>         The encodable trait is :
>>>         pub trait Encodable<S:Encoder> {
>>>             fn encode(&self, s: &mut S);
>>>         }
>>>
>>>         I try this definition
>>>         memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object:
>>>         &T) -> @mut MemWriter
>>>
>>>         But I can't use the method with a struct that implement
>>>         Encodable. The error : mismatched types: expected `&<V31>`
>>>         but found ..
>>>
>>>         I have another question :
>>>         I would like to return a MemWriter and not a @mut MemWriter
>>>         . I didn't find a way to convert the @mut to ~
>>>
>>>         Philippe Delrieu
>>>         _______________________________________________
>>>         Rust-dev mailing list
>>>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>         https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>>
>>     _______________________________________________
>>     Rust-dev mailing list
>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>     https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/68ff0f02/attachment.html>

From dbau.pp at gmail.com  Fri Nov 29 05:06:50 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 30 Nov 2013 00:06:50 +1100
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <52988F48.6010407@free.fr>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>	<529880BA.2090006@free.fr>
	<52988F48.6010407@free.fr>
Message-ID: <5298916A.8040105@gmail.com>

Yes; wait for Erick to submit the PR that fixes extra::json to use &mut 
Writer rather than @mut Writer, so that one can write something like

   pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
~[u8]  {
       let mut m = MemWriter::new();
       { // I think this scope is necessary to restrict the borrows
           let mut encoder = Encoder(&mut m as &mut Writer);
           to_encode_object.encode(&mut encoder);
       }
       m.inner()
   }

One is then just moving the `~[u8]` around without copying all the elements.

Also, `str_encode` shouldn't need to do any additional copies, even 
right now, since the `std::str::from_utf8_owned` function exists. 
(`from_utf8` is bad with its implicit and normally unnecessary copy, 
I've got https://github.com/mozilla/rust/pull/10701 open that removes 
that function for that reason.)


(Tangentially (and a genuine question), do we really need these 
functions in extra::json (assuming this is part of the plan)? How often 
does one need to encode to a buffer or string, rather than to stdout, a 
file or network socket, which can be done by writing directly to the 
corresponding writers.)

Huon


On 29/11/13 23:57, Philippe Delrieu wrote:
> I try to implement the two methods and I have a problem with the copy 
> of memory.
> The first attempt :
>
>  pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> 
> ~[u8]  {
>    //Serialize the object in a string using a writer
>     let m = @mut MemWriter::new();
>     let mut encoder = Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     let buff:&~[u8] = m.inner_ref();
>     (buff.clone())
> }
>
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>     let buff:~[u8] = buffer_encode(to_encode_object);
>     str::from_utf8(*buff)
> }
>
> When I call str_encode I copy at least two times the content of the 
> MemWriter buffer (one inside clone and one inside from_utf8).
> If I implements str_encode like that
>
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>     let m = @mut MemWriter::new();
>     let mut encoder = Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     let buff:&~[u8] = m.inner_ref();
>     str::from_utf8(*buff)
> }
>
> I'll do at least one copy (one less than the other impl) but the code 
> is copied.
>
> Is there a better way to manage pointer of memory across function calls?
>
> Philippe
>
> Le 29/11/2013 12:55, Philippe Delrieu a ?crit :
>> I made a remark about that on the GitHub pull request where the idea 
>> was proposed. I'm agree with you. It's simplier  to return a str or 
>> perhaps a [u8] if it's use in a stream purpose.
>> I'm not very fan of creating a MemWriter and return it.
>>
>> I'll modify to add two functions:
>> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str
>> pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]
>>
>> and remove the other.
>>
>> Any remaqs?
>>
>> Philippe
>>
>>
>> Le 29/11/2013 10:44, Gaetan a ?crit :
>>>
>>> I would prefere this function returns a str.
>>>
>>> Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr 
>>> <mailto:philippe.delrieu at free.fr>> a ?crit :
>>>
>>>     Thank you for the help. I've try this signature and I had an
>>>     compile error. I thought it came from the signature but the
>>>     problem when from the call.
>>>     It works now.
>>>
>>>     For the return type @mut MemWriter I work on the json doc and
>>>     some example of use. I can make the change. I didn't find the
>>>     issue about it. Did you create it?
>>>
>>>     Philippe
>>>
>>>     Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>>>>     Good afternoon Phillippe,
>>>>
>>>>     Here's how to do it, assuming you're using rust 0.8 and the
>>>>     json library:
>>>>
>>>>     ```
>>>>     #[feature(managed_boxes)];
>>>>
>>>>     extern mod extra;
>>>>
>>>>     use std::io::mem::MemWriter;
>>>>     use extra::serialize::{Encoder, Encodable};
>>>>     use extra::json;
>>>>
>>>>     pub fn memory_encode<
>>>>         T: Encodable<json::Encoder>
>>>>     >(to_encode_object: &T) -> @mut MemWriter {
>>>>         //Serialize the object in a string using a writer
>>>>         let m = @mut MemWriter::new();
>>>>         let mut encoder = json::Encoder(m as @mut Writer);
>>>>         to_encode_object.encode(&mut encoder);
>>>>         m
>>>>     }
>>>>
>>>>     fn main() {
>>>>     }
>>>>     ```
>>>>
>>>>     Regarding the trouble returning a `MemWriter` instead of a
>>>>     `@mut MemWriter`, the easiest thing would be to fix library to
>>>>     use `&mut ...` instead of `@mut ...`. I'll put in a PR to do that.
>>>>
>>>>
>>>>
>>>>     On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu
>>>>     <philippe.delrieu at free.fr <mailto:philippe.delrieu at free.fr>> wrote:
>>>>
>>>>         I try to develop a function that take a Encodable parameter
>>>>         but I have the error wrong number of type arguments:
>>>>         expected 1 but found 0
>>>>
>>>>         pub fn memory_encode(to_encode_object:
>>>>         &serialize::Encodable) -> @mut MemWriter  {
>>>>            //Serialize the object in a string using a writer
>>>>             let m = @mut MemWriter::new();
>>>>             let mut encoder = Encoder(m as @mut Writer);
>>>>             to_encode_object.encode(&mut encoder);
>>>>             m
>>>>         }
>>>>
>>>>         The encodable trait is :
>>>>         pub trait Encodable<S:Encoder> {
>>>>             fn encode(&self, s: &mut S);
>>>>         }
>>>>
>>>>         I try this definition
>>>>         memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object:
>>>>         &T) -> @mut MemWriter
>>>>
>>>>         But I can't use the method with a struct that implement
>>>>         Encodable. The error : mismatched types: expected `&<V31>`
>>>>         but found ..
>>>>
>>>>         I have another question :
>>>>         I would like to return a MemWriter and not a @mut MemWriter
>>>>         . I didn't find a way to convert the @mut to ~
>>>>
>>>>         Philippe Delrieu
>>>>         _______________________________________________
>>>>         Rust-dev mailing list
>>>>         Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>>         https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>
>>>
>>>     _______________________________________________
>>>     Rust-dev mailing list
>>>     Rust-dev at mozilla.org <mailto:Rust-dev at mozilla.org>
>>>     https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/767ffae5/attachment-0001.html>

From pnkfelix at mozilla.com  Fri Nov 29 05:46:07 2013
From: pnkfelix at mozilla.com (Felix S. Klock II)
Date: Fri, 29 Nov 2013 14:46:07 +0100
Subject: [rust-dev] Plz separate mail threads for separated compilation [was
 Re: Separated/Incremential compilation]
In-Reply-To: <5298790B.3090709@gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298790B.3090709@gmail.com>
Message-ID: <52989A9F.2000504@mozilla.com>

First off, the topic of rustc slowness and long bootstrap times has 
indeed been discussed many times.  If you have not yet tried skimming 
the archives, I recommend doing so, e.g. via

http://lmgtfy.com/?q=+site%3Amail.mozilla.org+rust+crate+compilation+speed

(I provide a (surely incomplete) list of previous-post links below.)

----

Now, a request: when discussing this topic, please try to avoid conflating:

    1. librustc+libstd bootstrap time,

from the somewhat separate issues of

    2. models for incremental compilation, and

    3. compilation times when running rustc on projects other than rustc 
itself.


In particular, incremental compilation alone is not going to solve (1).  
(At least, not as long as one is using the default make rule that 
rebuilds all of librustc+libstd atop the newly built rustc, and rustc 
itself draws upon a (large) libstd.  Under the latter two constraints, 
you *have* to redo the build for all of librustc+libstd: the compiler 
itself was changed.  Incremental compilation does not solve this.)

I am concerned that we will waste time debating tasks/designs related to 
(2) and then people will be disappointed when it does not provide the 
gains that they were expecting for issues like (1).

----

In case its not clear from the comments above: the team is well aware 
that rustc itself runs more slowly than it should; it is a common topic 
of discussion.

The team is also well aware that the time to bootstrap librustc+libstd 
is longer than many developers can cope with.

I am not sure I agree with the assertion that the approach of breaking a 
project into multiple crates is not a solution.  Yes, we may need better 
tools here (though I don't know how much rustpkg could help with this 
problem).

----

As promised, here are some relevant links to previous posts.  In *all* 
of the cases below, the *whole thread* is often worth review.

   * A great overview from pcwalton
     Thread subject: " Why does Rust compile slowly?"
https://mail.mozilla.org/pipermail/rust-dev/2012-October/002462.html

   * In early 2013 there was discussion of easing crate decomposition:
     Thread subject: " Plans for improving compiler performance"
https://mail.mozilla.org/pipermail/rust-dev/2013-January/002878.html

   * strcat and graydon each had good points in this discussion:
     Thread subject: "Please tell me about making rustc faster"
https://mail.mozilla.org/pipermail/rust-dev/2013-May/004326.html
https://mail.mozilla.org/pipermail/rust-dev/2013-May/004328.html

   * The team internally discussed whether to break lubrustc into 
multiple subcrates here:
     Thread subject: " code generation and rustc speed"
https://mail.mozilla.org/pipermail/rust-dev/2013-June/004493.html


Cheers,
-Felix

On 29/11/2013 12:22, Guillaume HERVIER wrote:
> +1 for this issue. I think that compilation time is really important 
> if we want Rust to be used as production language.
>
> For example, I think that if we can reduce significantly the Rust 
> compiler's compilation time, it could allow more developers to 
> contribute to the Rust language (as they won't have to wait 30min for 
> each small modifications in the compiler).
> Personally, it's the only thing which blocks me when I want to 
> contribute to Rust, because I like to often compile code when I do 
> small modifications to test each of these small modifications, partly 
> because I don't know the language very well.
>
> On 11/29/2013 12:01 PM, L?o Testard wrote:
>>
>> Hello,
>>
>> I think everyone here will agree to say that compilation times in 
>> Rust are problematic. Recently, there was an argument on IRC about 
>> reducing compilation times by reducing the use of GC and failures. 
>> Although I agree it's good to reduce Rustc's overhead, I think there 
>> are more important problems. The total duration of a build matters 
>> only because you have to recompile the whole crate on each 
>> modification. In C++, the duration of the complete build of a project 
>> matters less because when you compile incrementally, you only have to 
>> rebuild a couple of files - those you modified. I know the "1 crate = 
>> 1 compilation unit" is the model chosen by Rust, but this is a major 
>> issue for production. Nobody will ever use Rust in production if they 
>> have to recompile thousands of lines of code on each modification.
>>
>> On some of my personal projects, I "solved" this problem by splitting 
>> the codebase into several crates, that I compile statically, and then 
>> link together using extern mod. This is not really a solution, 
>> because this implies that there is no cyclic dependency between each 
>> of the small crates, or I end up with issues trying to compile it, 
>> because using extern mod requires that the library corresponding to 
>> that mod exists before compiling the crate that depends on it.
>>
>> But strictly speaking, a compiled crate is nothing more than a module 
>> hierarchy, and so is a single Rust source file, so we should be able 
>> to compile a single file to some sort of .o and then link all 
>> together to form a crate. References to modules outside of this file 
>> just require the first passes of the build, not the code generation, 
>> so it should be ok regarding to cyclic dependencies, and if not, we 
>> could still introduce some kind of auto-generated interface file, 
>> like Caml does. I know it's quite a big work, and that the current 
>> system is quite good, but having this is very important if we want 
>> Rust to be used in production.
>>
>> Sorry if this topic has already been posted several times, but I feel 
>> this is important, and the related issues seem to date (#2369). I 
>> think it's a real mistake to report this to post-1.0.
>>
>> Leo
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


-- 
irc: pnkfelix on irc.mozilla.org
email: {fklock, pnkfelix}@mozilla.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/638b7903/attachment.html>

From danielmicay at gmail.com  Fri Nov 29 07:31:58 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 29 Nov 2013 10:31:58 -0500
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298790B.3090709@gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298790B.3090709@gmail.com>
Message-ID: <CA+DvKQ+NS8R0u40UY_jORRL1Rbx=psGsnWk88ft3DMaeANEczA@mail.gmail.com>

On Fri, Nov 29, 2013 at 6:22 AM, Guillaume HERVIER
<eperso.mail at gmail.com> wrote:
> +1 for this issue. I think that compilation time is really important if we
> want Rust to be used as production language.
>
> For example, I think that if we can reduce significantly the Rust compiler's
> compilation time, it could allow more developers to contribute to the Rust
> language (as they won't have to wait 30min for each small modifications in
> the compiler).
> Personally, it's the only thing which blocks me when I want to contribute to
> Rust, because I like to often compile code when I do small modifications to
> test each of these small modifications, partly because I don't know the
> language very well.

The compiler has to bootstrap itself so incremental compilation won't
decrease the build times. Splitting up crates into many crates does
allow for incremental compilation, but it will also increase the
*total* build time, since work is being redone for any generic or
cross-crate inlined functions.

The final binary will also be larger and slower than using a single
crate, so supporting link-time optimization for release builds is
important.

From pcwalton at mozilla.com  Fri Nov 29 08:24:03 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 08:24:03 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
Message-ID: <5298BFA3.2080701@mozilla.com>

On 11/29/13 3:01 AM, L?o Testard wrote:
> Hello,
>
> I think everyone here will agree to say that compilation times in Rust
> are problematic.

I disagree. Rust doesn't compile that much slower than other languages 
at this point.

 > For example, I think that if we can reduce significantly the Rust 
compiler's compilation time, it could allow more developers to 
contribute to the Rust language (as they won't have to wait 30min for 
each small modifications in the compiler).

This is because of bootstrapping, not the language.

Patrick

From comexk at gmail.com  Fri Nov 29 09:00:54 2013
From: comexk at gmail.com (comex)
Date: Fri, 29 Nov 2013 12:00:54 -0500
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298BFA3.2080701@mozilla.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
Message-ID: <CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>

On Fri, Nov 29, 2013 at 11:24 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
> I disagree. Rust doesn't compile that much slower than other languages at
> this point.

If by other languages you mean C++, C++ compile times are a huge
turnoff for me, especially when I know that the work that
theoretically needs to be done to compile a small incremental change
is almost zero.  Rust, which has actual modules, should be much faster
to compile, not slower.  Just my two cents.

Of course, I don't know whether you're actually talking about C++;
without experience compiling large Rust codebases, the only number
I've gotten to know is rustc being about 4 times slower to compile an
empty crate than clang for an empty c file (even if the latter has
some standard #includes), but that's mostly unrelated.

From danielmicay at gmail.com  Fri Nov 29 09:07:59 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 29 Nov 2013 12:07:59 -0500
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
	<CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
Message-ID: <CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>

On Fri, Nov 29, 2013 at 12:00 PM, comex <comexk at gmail.com> wrote:
> On Fri, Nov 29, 2013 at 11:24 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
>> I disagree. Rust doesn't compile that much slower than other languages at
>> this point.
>
> If by other languages you mean C++, C++ compile times are a huge
> turnoff for me, especially when I know that the work that
> theoretically needs to be done to compile a small incremental change
> is almost zero.  Rust, which has actual modules, should be much faster
> to compile, not slower.  Just my two cents.
>
> Of course, I don't know whether you're actually talking about C++;
> without experience compiling large Rust codebases, the only number
> I've gotten to know is rustc being about 4 times slower to compile an
> empty crate than clang for an empty c file (even if the latter has
> some standard #includes), but that's mostly unrelated.

A minimal program definitely doesn't compile more slowly than `clang`:

```
int main(void) {
    return 0;
}
```

clang foo.c -emit-llvm  0.03s user 0.03s system 91% cpu 0.062 total

```
#[no_std];

#[start]
fn main(_: int, _: **u8) -> int {
    0
}
```

rustc foo.rs --emit-llvm  0.02s user 0.01s system 91% cpu 0.025 total

From pcwalton at mozilla.com  Fri Nov 29 09:09:30 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 09:09:30 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
Message-ID: <5298CA4A.7000106@mozilla.com>

On 11/29/13 3:01 AM, L?o Testard wrote:
> Although I
> agree it's good to reduce Rustc's overhead, I think there are more
> important problems. The total duration of a build matters only because
> you have to recompile the whole crate on each modification. In C++, the
> duration of the complete build of a project matters less because when
> you compile incrementally, you only have to rebuild a couple of files -
> those you modified. I know the "1 crate = 1 compilation unit" is the
> model chosen by Rust, but this is a major issue for production. Nobody
> will ever use Rust in production if they have to recompile thousands of
> lines of code on each modification.

In practice this isn't as much of a benefit for C++ as claimed. In C++, 
when you change a header file you often have to rebuild huge numbers of 
files, and most nontrivial changes change header files. In fact, Firefox 
is moving away from the C++ model to a more Rust-like model of unified 
builds on a per-directory basis precisely because it improves 
compilation times. This thread [1] reports build time increases of 6x-15x!

Furthermore, when you do link-time optimization, which is generally a 
requirement for software that needs to be fast these days, you can't 
really do separate compilation at all.

I shouldn't say that Rust has no problems with build times--it could 
always be faster, and in particular the memory representations are 
inefficient, particularly around ASTs--but when you actually run with 
`-Z time-passes`, you'll see that the vast majority of the time for any 
reasonably-sized crate is spent in LLVM. There isn't much we can do to 
make that faster by an order of magnitude, other than to try to push on 
the parallel per-function optimization and codegen work that is 
happening in some upstream branches. Mergefunc, disabling exceptions, 
and the no-zeroing-out stuff that Niko is doing would be nice, but they 
won't improve build times by an order of magnitude.

Patrick

[1]: 
https://groups.google.com/forum/#!topic/mozilla.dev.platform/WjcCfckml4A


From comexk at gmail.com  Fri Nov 29 10:26:47 2013
From: comexk at gmail.com (comex)
Date: Fri, 29 Nov 2013 13:26:47 -0500
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
	<CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
	<CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>
Message-ID: <CAPM5UJ1i+fJGrzg-OaV9zvKprixAuO3m0yy1nnHkbQL+B4N1Xg@mail.gmail.com>

On Fri, Nov 29, 2013 at 12:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:
> A minimal program definitely doesn't compile more slowly than `clang`:

Well, I said it was mostly unrelated. :)

Importing the std crate is responsible for the overhead, but if the C
program can bring in basic library functions in the time it takes Rust
to bring in nothing, it's still faster.

...but according to Instruments, almost 70% of the compilation time
for an empty non-#[no_std] crate is being spent inside
flate::inflate_bytes (93ms).  If that's accurate, it doesn't sound too
hard to fix, if it matters to anyone.  Compilation time for more
substantial crates is more interesting, of course, but I do like the
instantaneous feeling of compiling small C utilities.

From jurily at gmail.com  Fri Nov 29 10:29:04 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Fri, 29 Nov 2013 19:29:04 +0100
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298CA4A.7000106@mozilla.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298CA4A.7000106@mozilla.com>
Message-ID: <5298DCF0.3070903@gmail.com>

On 11/29/2013 06:09 PM, Patrick Walton wrote:
> compilation times. This thread [1] reports build time increases of 6x-15x!

No, he reported build time *improvements* of 6x-15x. Quoting later:

 > You're right, I did in fact use ccache because I was using the wrong 
mozconfig!  (Rookie mistake.)  With that fixed, we go down from 1m51s on
my machine to 31s, which is only about 4x faster!

...which sounds about right for unified C++ builds. The downside being, 
of course, the memory usage and the longer edit/compile/run cycle.

From pcwalton at mozilla.com  Fri Nov 29 10:29:08 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 10:29:08 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAPM5UJ1i+fJGrzg-OaV9zvKprixAuO3m0yy1nnHkbQL+B4N1Xg@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
	<CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
	<CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>
	<CAPM5UJ1i+fJGrzg-OaV9zvKprixAuO3m0yy1nnHkbQL+B4N1Xg@mail.gmail.com>
Message-ID: <5298DCF4.1050701@mozilla.com>

On 11/29/13 10:26 AM, comex wrote:
> On Fri, Nov 29, 2013 at 12:07 PM, Daniel Micay <danielmicay at gmail.com> wrote:
>> A minimal program definitely doesn't compile more slowly than `clang`:
>
> Well, I said it was mostly unrelated. :)
>
> Importing the std crate is responsible for the overhead, but if the C
> program can bring in basic library functions in the time it takes Rust
> to bring in nothing, it's still faster.
>
> ...but according to Instruments, almost 70% of the compilation time
> for an empty non-#[no_std] crate is being spent inside
> flate::inflate_bytes (93ms).  If that's accurate, it doesn't sound too
> hard to fix, if it matters to anyone.  Compilation time for more
> substantial crates is more interesting, of course, but I do like the
> instantaneous feeling of compiling small C utilities.

Yeah, we need to rework the representation of metadata. I'd also like to 
try switching to Snappy at some point (or just not compressing).

Patrick

From pcwalton at mozilla.com  Fri Nov 29 10:29:49 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 10:29:49 -0800
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298DCF0.3070903@gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>	<5298CA4A.7000106@mozilla.com>
	<5298DCF0.3070903@gmail.com>
Message-ID: <5298DD1D.9020300@mozilla.com>

On 11/29/13 10:29 AM, Gy?rgy Andrasek wrote:
> On 11/29/2013 06:09 PM, Patrick Walton wrote:
>> compilation times. This thread [1] reports build time increases of
>> 6x-15x!
>
> No, he reported build time *improvements* of 6x-15x. Quoting later:

Yeah, that's what I meant to say. Too early in the morning. :)

Patrick


From erick.tryzelaar at gmail.com  Fri Nov 29 10:49:23 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Fri, 29 Nov 2013 10:49:23 -0800
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <5298916A.8040105@gmail.com>
References: <52972F3D.6010901@free.fr>
	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>
	<52984FE1.80505@free.fr>
	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>
	<529880BA.2090006@free.fr> <52988F48.6010407@free.fr>
	<5298916A.8040105@gmail.com>
Message-ID: <CALdfqQLxNxjFbRLMJiuAsMeyOwz-db47QSojffdb-9bJA8U1Vg@mail.gmail.com>

I've submitted the pull request to remove the '@' boxes from json here:
https://github.com/mozilla/rust/pull/10727.



On Fri, Nov 29, 2013 at 5:06 AM, Huon Wilson <dbau.pp at gmail.com> wrote:

>  Yes; wait for Erick to submit the PR that fixes extra::json to use &mut
> Writer rather than @mut Writer, so that one can write something like
>
>
>   pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) ->
> ~[u8]  {
>       let mut m = MemWriter::new();
>       { // I think this scope is necessary to restrict the borrows
>           let mut encoder = Encoder(&mut m as &mut Writer);
>           to_encode_object.encode(&mut encoder);
>       }
>       m.inner()
>   }
>
> One is then just moving the `~[u8]` around without copying all the
> elements.
>
> Also, `str_encode` shouldn't need to do any additional copies, even right
> now, since the `std::str::from_utf8_owned` function exists. (`from_utf8` is
> bad with its implicit and normally unnecessary copy, I've got
> https://github.com/mozilla/rust/pull/10701 open that removes that
> function for that reason.)
>
>
> (Tangentially (and a genuine question), do we really need these functions
> in extra::json (assuming this is part of the plan)? How often does one need
> to encode to a buffer or string, rather than to stdout, a file or network
> socket, which can be done by writing directly to the corresponding writers.)
>
> Huon
>
>
>
> On 29/11/13 23:57, Philippe Delrieu wrote:
>
> I try to implement the two methods and I have a problem with the copy of
> memory.
> The first attempt :
>
>  pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) ->
> ~[u8]  {
>    //Serialize the object in a string using a writer
>     let m = @mut MemWriter::new();
>     let mut encoder = Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     let buff:&~[u8] = m.inner_ref();
>     (buff.clone())
> }
>
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>     let buff:~[u8] = buffer_encode(to_encode_object);
>     str::from_utf8(*buff)
> }
>
> When I call str_encode I copy at least two times the content of the
> MemWriter buffer (one inside clone and one inside from_utf8).
> If I implements str_encode like that
>
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str  {
>     let m = @mut MemWriter::new();
>     let mut encoder = Encoder(m as @mut Writer);
>     to_encode_object.encode(&mut encoder);
>     let buff:&~[u8] = m.inner_ref();
>     str::from_utf8(*buff)
> }
>
> I'll do at least one copy (one less than the other impl) but the code is
> copied.
>
> Is there a better way to manage pointer of memory across function calls?
>
> Philippe
>
> Le 29/11/2013 12:55, Philippe Delrieu a ?crit :
>
> I made a remark about that on the GitHub pull request where the idea was
> proposed. I'm agree with you. It's simplier  to return a str or perhaps a
> [u8] if it's use in a stream purpose.
> I'm not very fan of creating a MemWriter and return it.
>
> I'll modify to add two functions:
> pub fn str_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~str
> pub fn buffer_encode<T:Encodable<Encoder>>(to_encode_object: &T) -> ~[u8]
>
> and remove the other.
>
> Any remaqs?
>
> Philippe
>
>
> Le 29/11/2013 10:44, Gaetan a ?crit :
>
> I would prefere this function returns a str.
> Le 29 nov. 2013 09:27, "Philippe Delrieu" <philippe.delrieu at free.fr> a
> ?crit :
>
>>  Thank you for the help. I've try this signature and I had an compile
>> error. I thought it came from the signature but the problem when from the
>> call.
>> It works now.
>>
>> For the return type @mut MemWriter I work on the json doc and some
>> example of use. I can make the change. I didn't find the issue about it.
>> Did you create it?
>>
>> Philippe
>>
>> Le 28/11/2013 22:27, Erick Tryzelaar a ?crit :
>>
>>  Good afternoon Phillippe,
>>
>>  Here's how to do it, assuming you're using rust 0.8 and the json library:
>>
>> ```
>> #[feature(managed_boxes)];
>>
>> extern mod extra;
>>
>> use std::io::mem::MemWriter;
>> use extra::serialize::{Encoder, Encodable};
>> use extra::json;
>>
>> pub fn memory_encode<
>>     T: Encodable<json::Encoder>
>> >(to_encode_object: &T) -> @mut MemWriter {
>>     //Serialize the object in a string using a writer
>>     let m = @mut MemWriter::new();
>>     let mut encoder = json::Encoder(m as @mut Writer);
>>     to_encode_object.encode(&mut encoder);
>>     m
>> }
>>
>> fn main() {
>> }
>> ```
>>
>>  Regarding the trouble returning a `MemWriter` instead of a `@mut
>> MemWriter`, the easiest thing would be to fix library to use `&mut ...`
>> instead of `@mut ...`. I'll put in a PR to do that.
>>
>>
>>
>> On Thu, Nov 28, 2013 at 3:55 AM, Philippe Delrieu <
>> philippe.delrieu at free.fr> wrote:
>>
>>> I try to develop a function that take a Encodable parameter but I have
>>> the error wrong number of type arguments: expected 1 but found 0
>>>
>>> pub fn memory_encode(to_encode_object: &serialize::Encodable) -> @mut
>>> MemWriter  {
>>>    //Serialize the object in a string using a writer
>>>     let m = @mut MemWriter::new();
>>>     let mut encoder = Encoder(m as @mut Writer);
>>>     to_encode_object.encode(&mut encoder);
>>>     m
>>> }
>>>
>>> The encodable trait is :
>>> pub trait Encodable<S:Encoder> {
>>>     fn encode(&self, s: &mut S);
>>> }
>>>
>>> I try this definition
>>> memory_encode<T:serialize::Encodable<Encoder>>(to_encode_object: &T) ->
>>> @mut MemWriter
>>>
>>> But I can't use the method with a struct that implement Encodable. The
>>> error : mismatched types: expected `&<V31>` but found ..
>>>
>>> I have another question :
>>> I would like to return a MemWriter and not a @mut MemWriter . I didn't
>>> find a way to convert the @mut to ~
>>>
>>> Philippe Delrieu
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
>
> _______________________________________________
> Rust-dev mailing listRust-dev at mozilla.orghttps://mail.mozilla.org/listinfo/rust-dev
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/dad5ad91/attachment-0001.html>

From pcwalton at mozilla.com  Fri Nov 29 10:50:30 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 10:50:30 -0800
Subject: [rust-dev] Problem to use Encodable as fn parameter
In-Reply-To: <CALdfqQLxNxjFbRLMJiuAsMeyOwz-db47QSojffdb-9bJA8U1Vg@mail.gmail.com>
References: <52972F3D.6010901@free.fr>	<CALdfqQL14JnYbpJ19PLbEBqcNKzbm45m8cnEkN=BeqRz_o5puQ@mail.gmail.com>	<52984FE1.80505@free.fr>	<CANK7tAGNFgQcO+TyhKk-KR5hfrr0dOwUzfO22TP2UAtX39O5uQ@mail.gmail.com>	<529880BA.2090006@free.fr>
	<52988F48.6010407@free.fr>	<5298916A.8040105@gmail.com>
	<CALdfqQLxNxjFbRLMJiuAsMeyOwz-db47QSojffdb-9bJA8U1Vg@mail.gmail.com>
Message-ID: <5298E1F6.9090002@mozilla.com>

On 11/29/13 10:49 AM, Erick Tryzelaar wrote:
> I've submitted the pull request to remove the '@' boxes from json here:
> https://github.com/mozilla/rust/pull/10727.

\o/

Patrick


From zcarterc at gmail.com  Fri Nov 29 10:51:56 2013
From: zcarterc at gmail.com (Carter Charbonneau)
Date: Fri, 29 Nov 2013 11:51:56 -0700
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <5298DCF4.1050701@mozilla.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
	<CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
	<CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>
	<CAPM5UJ1i+fJGrzg-OaV9zvKprixAuO3m0yy1nnHkbQL+B4N1Xg@mail.gmail.com>
	<5298DCF4.1050701@mozilla.com>
Message-ID: <CAA+VN--KXmGN821ttNsXjsUdBgV5Fwtxcbv3csHs6hYfy4aRxA@mail.gmail.com>

Why not lz4? It's faster than snappy.
On Nov 29, 2013 11:29 AM, "Patrick Walton" <pcwalton at mozilla.com> wrote:

> On 11/29/13 10:26 AM, comex wrote:
>
>> On Fri, Nov 29, 2013 at 12:07 PM, Daniel Micay <danielmicay at gmail.com>
>> wrote:
>>
>>> A minimal program definitely doesn't compile more slowly than `clang`:
>>>
>>
>> Well, I said it was mostly unrelated. :)
>>
>> Importing the std crate is responsible for the overhead, but if the C
>> program can bring in basic library functions in the time it takes Rust
>> to bring in nothing, it's still faster.
>>
>> ...but according to Instruments, almost 70% of the compilation time
>> for an empty non-#[no_std] crate is being spent inside
>> flate::inflate_bytes (93ms).  If that's accurate, it doesn't sound too
>> hard to fix, if it matters to anyone.  Compilation time for more
>> substantial crates is more interesting, of course, but I do like the
>> instantaneous feeling of compiling small C utilities.
>>
>
> Yeah, we need to rework the representation of metadata. I'd also like to
> try switching to Snappy at some point (or just not compressing).
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/05716e4a/attachment.html>

From marcianx at gmail.com  Fri Nov 29 15:33:51 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Fri, 29 Nov 2013 18:33:51 -0500
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
Message-ID: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>

Previously we had the Copy trait, which when implemented by trait T
allowed one to write
[Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
not sure how to get that behavior.  Concretely, here is the code I
want to get compiling. (Just to check, I added both Clone and
DeepClone, even though they don't automatically allow implicit
copyability).

----
use std::num::Zero;

enum Constants {
    SZ = 2
}

struct Foo<T>([T, ..SZ]);

impl<T : Clone + DeepClone + Zero> Foo<T> {
    pub fn new() -> Foo<T> {
        Foo([Zero::zero(), ..SZ])
    }
}
----

The error I get is:

error: copying a value of non-copyable type `T`
tmp.rs:155         Foo([Zero::zero(), ..SZ])


Any way to do this? Or is this no longer supported for general types?
Any intentions to add this behavior again?  Otherwise, I can't even
initialize my struct while being agnostic to the specific value of SZ.

Ashish

From danielmicay at gmail.com  Fri Nov 29 15:42:42 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Fri, 29 Nov 2013 18:42:42 -0500
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
Message-ID: <CA+DvKQK9QK7bFmi_bg48qgkn=MX-fodNTzYuKpL8LsaZNhM1DQ@mail.gmail.com>

On Fri, Nov 29, 2013 at 6:33 PM, Ashish Myles <marcianx at gmail.com> wrote:
> Previously we had the Copy trait, which when implemented by trait T
> allowed one to write
> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
> not sure how to get that behavior.  Concretely, here is the code I
> want to get compiling. (Just to check, I added both Clone and
> DeepClone, even though they don't automatically allow implicit
> copyability).
>
> ----
> use std::num::Zero;
>
> enum Constants {
>     SZ = 2
> }
>
> struct Foo<T>([T, ..SZ]);
>
> impl<T : Clone + DeepClone + Zero> Foo<T> {
>     pub fn new() -> Foo<T> {
>         Foo([Zero::zero(), ..SZ])
>     }
> }
> ----
>
> The error I get is:
>
> error: copying a value of non-copyable type `T`
> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>
>
> Any way to do this? Or is this no longer supported for general types?
> Any intentions to add this behavior again?  Otherwise, I can't even
> initialize my struct while being agnostic to the specific value of SZ.
>
> Ashish

The `Clone` and `DeepClone` traits are defined entirely in the
standard library. Of course, another issue is that fixed-size vectors
can't have methods implemented on them at the moment.

From dbau.pp at gmail.com  Fri Nov 29 15:47:06 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 30 Nov 2013 10:47:06 +1100
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
Message-ID: <5299277A.70209@gmail.com>

On 30/11/13 10:33, Ashish Myles wrote:
> Previously we had the Copy trait, which when implemented by trait T
> allowed one to write
> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
> not sure how to get that behavior.  Concretely, here is the code I
> want to get compiling. (Just to check, I added both Clone and
> DeepClone, even though they don't automatically allow implicit
> copyability).
>
> ----
> use std::num::Zero;
>
> enum Constants {
>      SZ = 2
> }
>
> struct Foo<T>([T, ..SZ]);
>
> impl<T : Clone + DeepClone + Zero> Foo<T> {
>      pub fn new() -> Foo<T> {
>          Foo([Zero::zero(), ..SZ])
>      }
> }
> ----
>
> The error I get is:
>
> error: copying a value of non-copyable type `T`
> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>
>
> Any way to do this? Or is this no longer supported for general types?
> Any intentions to add this behavior again?  Otherwise, I can't even
> initialize my struct while being agnostic to the specific value of SZ.
>
> Ashish
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately 
requires that `T` is implicitly copyable (that is, it doesn't move 
ownership when passed by value), and there's no way around this other 
than [foo(), foo(), foo(),...].


Huon

From corey at octayn.net  Fri Nov 29 16:02:24 2013
From: corey at octayn.net (Corey Richardson)
Date: Fri, 29 Nov 2013 19:02:24 -0500
Subject: [rust-dev] Separated/Incremential compilation
In-Reply-To: <CAA+VN--KXmGN821ttNsXjsUdBgV5Fwtxcbv3csHs6hYfy4aRxA@mail.gmail.com>
References: <CAEtvjQiuv7QBKGNCT5=NO0epxai1h4ot8FtJFONW8QTkZ7+9Nw@mail.gmail.com>
	<5298BFA3.2080701@mozilla.com>
	<CAPM5UJ3-XOuraR5=iCkoU9LQxH1fjAwBkQ7-OJyw8bgtSawc=A@mail.gmail.com>
	<CA+DvKQ+uy3ut9JGEMCZ+O4K00b3eDXpci1NYhKLu0MH0Oipa7g@mail.gmail.com>
	<CAPM5UJ1i+fJGrzg-OaV9zvKprixAuO3m0yy1nnHkbQL+B4N1Xg@mail.gmail.com>
	<5298DCF4.1050701@mozilla.com>
	<CAA+VN--KXmGN821ttNsXjsUdBgV5Fwtxcbv3csHs6hYfy4aRxA@mail.gmail.com>
Message-ID: <CA++BO6Q9ayZFb4=g4N4_14G+YXtznHD+uVD_GkQZhgOp_yZMxQ@mail.gmail.com>

I experimented with LZ4. https://github.com/mozilla/rust/pull/6954. It
isn't worth it, IMO.

On Fri, Nov 29, 2013 at 1:51 PM, Carter Charbonneau <zcarterc at gmail.com> wrote:
> Why not lz4? It's faster than snappy.
>
> On Nov 29, 2013 11:29 AM, "Patrick Walton" <pcwalton at mozilla.com> wrote:
>>
>> On 11/29/13 10:26 AM, comex wrote:
>>>
>>> On Fri, Nov 29, 2013 at 12:07 PM, Daniel Micay <danielmicay at gmail.com>
>>> wrote:
>>>>
>>>> A minimal program definitely doesn't compile more slowly than `clang`:
>>>
>>>
>>> Well, I said it was mostly unrelated. :)
>>>
>>> Importing the std crate is responsible for the overhead, but if the C
>>> program can bring in basic library functions in the time it takes Rust
>>> to bring in nothing, it's still faster.
>>>
>>> ...but according to Instruments, almost 70% of the compilation time
>>> for an empty non-#[no_std] crate is being spent inside
>>> flate::inflate_bytes (93ms).  If that's accurate, it doesn't sound too
>>> hard to fix, if it matters to anyone.  Compilation time for more
>>> substantial crates is more interesting, of course, but I do like the
>>> instantaneous feeling of compiling small C utilities.
>>
>>
>> Yeah, we need to rework the representation of metadata. I'd also like to
>> try switching to Snappy at some point (or just not compressing).
>>
>> Patrick
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>

From marcianx at gmail.com  Fri Nov 29 19:05:07 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Fri, 29 Nov 2013 22:05:07 -0500
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <5299277A.70209@gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
Message-ID: <CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>

Is there a plan to support fix-sized vector initialization without manual
replication?  My example is just a simplified version -- this was part of a
macro that takes the size as input ($n:expr) and the initialization was
[Zero::zero(), .. $n].  Is this use case no longer intended to be
supported?
On Nov 29, 2013 6:47 PM, "Huon Wilson" <dbau.pp at gmail.com> wrote:

> On 30/11/13 10:33, Ashish Myles wrote:
>
>> Previously we had the Copy trait, which when implemented by trait T
>> allowed one to write
>> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
>> not sure how to get that behavior.  Concretely, here is the code I
>> want to get compiling. (Just to check, I added both Clone and
>> DeepClone, even though they don't automatically allow implicit
>> copyability).
>>
>> ----
>> use std::num::Zero;
>>
>> enum Constants {
>>      SZ = 2
>> }
>>
>> struct Foo<T>([T, ..SZ]);
>>
>> impl<T : Clone + DeepClone + Zero> Foo<T> {
>>      pub fn new() -> Foo<T> {
>>          Foo([Zero::zero(), ..SZ])
>>      }
>> }
>> ----
>>
>> The error I get is:
>>
>> error: copying a value of non-copyable type `T`
>> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>>
>>
>> Any way to do this? Or is this no longer supported for general types?
>> Any intentions to add this behavior again?  Otherwise, I can't even
>> initialize my struct while being agnostic to the specific value of SZ.
>>
>> Ashish
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately
> requires that `T` is implicitly copyable (that is, it doesn't move
> ownership when passed by value), and there's no way around this other than
> [foo(), foo(), foo(),...].
>
>
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/50b99853/attachment.html>

From kevin at sb.org  Fri Nov 29 19:20:46 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 29 Nov 2013 19:20:46 -0800
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
	<CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
Message-ID: <148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>

If you're willing to use unsafe code and std::unstable, you can do it.

use std::num::Zero;
use std::unstable::intrinsics;

enum Constants {
    SZ = 2
}

struct Foo<T>([T, ..SZ]);

impl<T: Clone + DeepClone + Zero> Foo<T> {
    pub fn new() -> Foo<T> {
        let mut ary: [T, ..SZ];
        unsafe {
            ary = intrinsics::uninit();
            for i in range(0u, SZ as uint) {
                intrinsics::move_val_init(&mut ary[i], Zero::zero());
            }
        }
        Foo(ary)
    }
}

-Kevin

On Nov 29, 2013, at 7:05 PM, Ashish Myles <marcianx at gmail.com> wrote:

> Is there a plan to support fix-sized vector initialization without manual replication?  My example is just a simplified version -- this was part of a macro that takes the size as input ($n:expr) and the initialization was [Zero::zero(), .. $n].  Is this use case no longer intended to be supported?
> 
> On Nov 29, 2013 6:47 PM, "Huon Wilson" <dbau.pp at gmail.com> wrote:
> On 30/11/13 10:33, Ashish Myles wrote:
> Previously we had the Copy trait, which when implemented by trait T
> allowed one to write
> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
> not sure how to get that behavior.  Concretely, here is the code I
> want to get compiling. (Just to check, I added both Clone and
> DeepClone, even though they don't automatically allow implicit
> copyability).
> 
> ----
> use std::num::Zero;
> 
> enum Constants {
>      SZ = 2
> }
> 
> struct Foo<T>([T, ..SZ]);
> 
> impl<T : Clone + DeepClone + Zero> Foo<T> {
>      pub fn new() -> Foo<T> {
>          Foo([Zero::zero(), ..SZ])
>      }
> }
> ----
> 
> The error I get is:
> 
> error: copying a value of non-copyable type `T`
> tmp.rs:155         Foo([Zero::zero(), ..SZ])
> 
> 
> Any way to do this? Or is this no longer supported for general types?
> Any intentions to add this behavior again?  Otherwise, I can't even
> initialize my struct while being agnostic to the specific value of SZ.
> 
> Ashish
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately requires that `T` is implicitly copyable (that is, it doesn't move ownership when passed by value), and there's no way around this other than [foo(), foo(), foo(),...].
> 
> 
> Huon
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/8ffd734b/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/8ffd734b/attachment-0001.p7s>

From marcianx at gmail.com  Fri Nov 29 20:37:49 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Fri, 29 Nov 2013 23:37:49 -0500
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
	<CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
	<148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>
Message-ID: <CAEsTQVNtB3Z1P6W+ugVFevVhbGZXack1ACyXsspeYRC6uGaAAw@mail.gmail.com>

That's some seriously nifty stuff, which got my stuff compiling again. :)

But for the long term, it would be nice to have a syntax that behaves
as was the case with the Copy trait -- it takes a single value and
clones it into the elements of the static array.  Or perhaps the
developers disagree and consider it to be a niche use (static arrays
with sizes known a-priori when writing the code) -- it would be good
to get some clarity on this.

Thanks,
Ashish


On Fri, Nov 29, 2013 at 10:20 PM, Kevin Ballard <kevin at sb.org> wrote:
> If you're willing to use unsafe code and std::unstable, you can do it.
>
> use std::num::Zero;
> use std::unstable::intrinsics;
>
>
> enum Constants {
>     SZ = 2
> }
>
> struct Foo<T>([T, ..SZ]);
>
> impl<T: Clone + DeepClone + Zero> Foo<T> {
>     pub fn new() -> Foo<T> {
>         let mut ary: [T, ..SZ];
>         unsafe {
>             ary = intrinsics::uninit();
>             for i in range(0u, SZ as uint) {
>                 intrinsics::move_val_init(&mut ary[i], Zero::zero());
>             }
>         }
>         Foo(ary)
>     }
> }
>
> -Kevin
>
> On Nov 29, 2013, at 7:05 PM, Ashish Myles <marcianx at gmail.com> wrote:
>
> Is there a plan to support fix-sized vector initialization without manual
> replication?  My example is just a simplified version -- this was part of a
> macro that takes the size as input ($n:expr) and the initialization was
> [Zero::zero(), .. $n].  Is this use case no longer intended to be supported?
>
> On Nov 29, 2013 6:47 PM, "Huon Wilson" <dbau.pp at gmail.com> wrote:
>>
>> On 30/11/13 10:33, Ashish Myles wrote:
>>>
>>> Previously we had the Copy trait, which when implemented by trait T
>>> allowed one to write
>>> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
>>> not sure how to get that behavior.  Concretely, here is the code I
>>> want to get compiling. (Just to check, I added both Clone and
>>> DeepClone, even though they don't automatically allow implicit
>>> copyability).
>>>
>>> ----
>>> use std::num::Zero;
>>>
>>> enum Constants {
>>>      SZ = 2
>>> }
>>>
>>> struct Foo<T>([T, ..SZ]);
>>>
>>> impl<T : Clone + DeepClone + Zero> Foo<T> {
>>>      pub fn new() -> Foo<T> {
>>>          Foo([Zero::zero(), ..SZ])
>>>      }
>>> }
>>> ----
>>>
>>> The error I get is:
>>>
>>> error: copying a value of non-copyable type `T`
>>> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>>>
>>>
>>> Any way to do this? Or is this no longer supported for general types?
>>> Any intentions to add this behavior again?  Otherwise, I can't even
>>> initialize my struct while being agnostic to the specific value of SZ.
>>>
>>> Ashish
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>> Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately
>> requires that `T` is implicitly copyable (that is, it doesn't move ownership
>> when passed by value), and there's no way around this other than [foo(),
>> foo(), foo(),...].
>>
>>
>> Huon
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>

From kevin at sb.org  Fri Nov 29 21:39:22 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 29 Nov 2013 21:39:22 -0800
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <CAEsTQVNtB3Z1P6W+ugVFevVhbGZXack1ACyXsspeYRC6uGaAAw@mail.gmail.com>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
	<CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
	<148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>
	<CAEsTQVNtB3Z1P6W+ugVFevVhbGZXack1ACyXsspeYRC6uGaAAw@mail.gmail.com>
Message-ID: <89849A08-511B-4E98-95AD-055178690831@sb.org>

Personally, I think it would be nicer to just have a syntax that says "create an array of length N by executing the following expression (typically a function call) N times".

Something along the lines of

    let ary = [Foo::new().., ..32];

This would be more generic, because it will work with non-Clonable values, and if you wanted cloned values you'd just say

    let ary = [foo.clone().., ..32];

Although if we ever get the ability to make generics that have integral parameters (which is necessary to implement traits on arbitrary arrays) then we could do this in the libraries by writing a function like I had before. Something like the following:

libstd/array.rs:

#[inline]
fn from_fn<T, N as uint> init(f: |uint| -> T) -> [T, ..N] {
    let mut ary: [T, ..N];
    unsafe {
        ary = intrinsics::uninit();
        for i in range(0u, N) {
            intrinsics::move_val_init(&mut ary[i], f(i));
        }
    }
    ary
}


This would let you call it like Foo(array::from_fn(|_| Zero::zero())).

-Kevin

On Nov 29, 2013, at 8:37 PM, Ashish Myles <marcianx at gmail.com> wrote:

> That's some seriously nifty stuff, which got my stuff compiling again. :)
> 
> But for the long term, it would be nice to have a syntax that behaves
> as was the case with the Copy trait -- it takes a single value and
> clones it into the elements of the static array.  Or perhaps the
> developers disagree and consider it to be a niche use (static arrays
> with sizes known a-priori when writing the code) -- it would be good
> to get some clarity on this.
> 
> Thanks,
> Ashish
> 
> 
> On Fri, Nov 29, 2013 at 10:20 PM, Kevin Ballard <kevin at sb.org> wrote:
>> If you're willing to use unsafe code and std::unstable, you can do it.
>> 
>> use std::num::Zero;
>> use std::unstable::intrinsics;
>> 
>> 
>> enum Constants {
>>    SZ = 2
>> }
>> 
>> struct Foo<T>([T, ..SZ]);
>> 
>> impl<T: Clone + DeepClone + Zero> Foo<T> {
>>    pub fn new() -> Foo<T> {
>>        let mut ary: [T, ..SZ];
>>        unsafe {
>>            ary = intrinsics::uninit();
>>            for i in range(0u, SZ as uint) {
>>                intrinsics::move_val_init(&mut ary[i], Zero::zero());
>>            }
>>        }
>>        Foo(ary)
>>    }
>> }
>> 
>> -Kevin
>> 
>> On Nov 29, 2013, at 7:05 PM, Ashish Myles <marcianx at gmail.com> wrote:
>> 
>> Is there a plan to support fix-sized vector initialization without manual
>> replication?  My example is just a simplified version -- this was part of a
>> macro that takes the size as input ($n:expr) and the initialization was
>> [Zero::zero(), .. $n].  Is this use case no longer intended to be supported?
>> 
>> On Nov 29, 2013 6:47 PM, "Huon Wilson" <dbau.pp at gmail.com> wrote:
>>> 
>>> On 30/11/13 10:33, Ashish Myles wrote:
>>>> 
>>>> Previously we had the Copy trait, which when implemented by trait T
>>>> allowed one to write
>>>> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
>>>> not sure how to get that behavior.  Concretely, here is the code I
>>>> want to get compiling. (Just to check, I added both Clone and
>>>> DeepClone, even though they don't automatically allow implicit
>>>> copyability).
>>>> 
>>>> ----
>>>> use std::num::Zero;
>>>> 
>>>> enum Constants {
>>>>     SZ = 2
>>>> }
>>>> 
>>>> struct Foo<T>([T, ..SZ]);
>>>> 
>>>> impl<T : Clone + DeepClone + Zero> Foo<T> {
>>>>     pub fn new() -> Foo<T> {
>>>>         Foo([Zero::zero(), ..SZ])
>>>>     }
>>>> }
>>>> ----
>>>> 
>>>> The error I get is:
>>>> 
>>>> error: copying a value of non-copyable type `T`
>>>> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>>>> 
>>>> 
>>>> Any way to do this? Or is this no longer supported for general types?
>>>> Any intentions to add this behavior again?  Otherwise, I can't even
>>>> initialize my struct while being agnostic to the specific value of SZ.
>>>> 
>>>> Ashish
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> 
>>> Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately
>>> requires that `T` is implicitly copyable (that is, it doesn't move ownership
>>> when passed by value), and there's no way around this other than [foo(),
>>> foo(), foo(),...].
>>> 
>>> 
>>> Huon
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/2fdecebc/attachment.p7s>

From marcianx at gmail.com  Fri Nov 29 21:53:24 2013
From: marcianx at gmail.com (Ashish Myles)
Date: Sat, 30 Nov 2013 00:53:24 -0500
Subject: [rust-dev] Define copyable types for [T,
	..2] static vector initialization
In-Reply-To: <89849A08-511B-4E98-95AD-055178690831@sb.org>
References: <CAEsTQVO_ou1oQ6BdqNFCcTgMG7NEUYuHapmrqOPnWkQsX-UW2A@mail.gmail.com>
	<5299277A.70209@gmail.com>
	<CAEsTQVOvXTQy3wtshgzEK08SdwyP6hFzY5rRhq3kvLKMzkogOg@mail.gmail.com>
	<148F15B8-ED59-4460-B962-15A91BAECFEE@sb.org>
	<CAEsTQVNtB3Z1P6W+ugVFevVhbGZXack1ACyXsspeYRC6uGaAAw@mail.gmail.com>
	<89849A08-511B-4E98-95AD-055178690831@sb.org>
Message-ID: <CAEsTQVP4uXf+nSgOggd8+kx37C=LLY4pQzn0b9f2zJXfEFEJ9Q@mail.gmail.com>

+1 on specifying function. That potentially lowers the requirements on
the Traits -- e.g. don't have to force clone-ability as long as you
can create+move it; perhaps even create it in place.

I have been waiting on integer parameters on traits since I first ran
into Rust, but the rust team might be avoiding that to prevent getting
Turing complete generics/templates.

Ashish


On Sat, Nov 30, 2013 at 12:39 AM, Kevin Ballard <kevin at sb.org> wrote:
> Personally, I think it would be nicer to just have a syntax that says "create an array of length N by executing the following expression (typically a function call) N times".
>
> Something along the lines of
>
>     let ary = [Foo::new().., ..32];
>
> This would be more generic, because it will work with non-Clonable values, and if you wanted cloned values you'd just say
>
>     let ary = [foo.clone().., ..32];
>
> Although if we ever get the ability to make generics that have integral parameters (which is necessary to implement traits on arbitrary arrays) then we could do this in the libraries by writing a function like I had before. Something like the following:
>
> libstd/array.rs:
>
> #[inline]
> fn from_fn<T, N as uint> init(f: |uint| -> T) -> [T, ..N] {
>     let mut ary: [T, ..N];
>     unsafe {
>         ary = intrinsics::uninit();
>         for i in range(0u, N) {
>             intrinsics::move_val_init(&mut ary[i], f(i));
>         }
>     }
>     ary
> }
>
>
> This would let you call it like Foo(array::from_fn(|_| Zero::zero())).
>
> -Kevin
>
> On Nov 29, 2013, at 8:37 PM, Ashish Myles <marcianx at gmail.com> wrote:
>
>> That's some seriously nifty stuff, which got my stuff compiling again. :)
>>
>> But for the long term, it would be nice to have a syntax that behaves
>> as was the case with the Copy trait -- it takes a single value and
>> clones it into the elements of the static array.  Or perhaps the
>> developers disagree and consider it to be a niche use (static arrays
>> with sizes known a-priori when writing the code) -- it would be good
>> to get some clarity on this.
>>
>> Thanks,
>> Ashish
>>
>>
>> On Fri, Nov 29, 2013 at 10:20 PM, Kevin Ballard <kevin at sb.org> wrote:
>>> If you're willing to use unsafe code and std::unstable, you can do it.
>>>
>>> use std::num::Zero;
>>> use std::unstable::intrinsics;
>>>
>>>
>>> enum Constants {
>>>    SZ = 2
>>> }
>>>
>>> struct Foo<T>([T, ..SZ]);
>>>
>>> impl<T: Clone + DeepClone + Zero> Foo<T> {
>>>    pub fn new() -> Foo<T> {
>>>        let mut ary: [T, ..SZ];
>>>        unsafe {
>>>            ary = intrinsics::uninit();
>>>            for i in range(0u, SZ as uint) {
>>>                intrinsics::move_val_init(&mut ary[i], Zero::zero());
>>>            }
>>>        }
>>>        Foo(ary)
>>>    }
>>> }
>>>
>>> -Kevin
>>>
>>> On Nov 29, 2013, at 7:05 PM, Ashish Myles <marcianx at gmail.com> wrote:
>>>
>>> Is there a plan to support fix-sized vector initialization without manual
>>> replication?  My example is just a simplified version -- this was part of a
>>> macro that takes the size as input ($n:expr) and the initialization was
>>> [Zero::zero(), .. $n].  Is this use case no longer intended to be supported?
>>>
>>> On Nov 29, 2013 6:47 PM, "Huon Wilson" <dbau.pp at gmail.com> wrote:
>>>>
>>>> On 30/11/13 10:33, Ashish Myles wrote:
>>>>>
>>>>> Previously we had the Copy trait, which when implemented by trait T
>>>>> allowed one to write
>>>>> [Zero::zero(), ..SZ] where T implemented the Zero trait.  But now I am
>>>>> not sure how to get that behavior.  Concretely, here is the code I
>>>>> want to get compiling. (Just to check, I added both Clone and
>>>>> DeepClone, even though they don't automatically allow implicit
>>>>> copyability).
>>>>>
>>>>> ----
>>>>> use std::num::Zero;
>>>>>
>>>>> enum Constants {
>>>>>     SZ = 2
>>>>> }
>>>>>
>>>>> struct Foo<T>([T, ..SZ]);
>>>>>
>>>>> impl<T : Clone + DeepClone + Zero> Foo<T> {
>>>>>     pub fn new() -> Foo<T> {
>>>>>         Foo([Zero::zero(), ..SZ])
>>>>>     }
>>>>> }
>>>>> ----
>>>>>
>>>>> The error I get is:
>>>>>
>>>>> error: copying a value of non-copyable type `T`
>>>>> tmp.rs:155         Foo([Zero::zero(), ..SZ])
>>>>>
>>>>>
>>>>> Any way to do this? Or is this no longer supported for general types?
>>>>> Any intentions to add this behavior again?  Otherwise, I can't even
>>>>> initialize my struct while being agnostic to the specific value of SZ.
>>>>>
>>>>> Ashish
>>>>> _______________________________________________
>>>>> Rust-dev mailing list
>>>>> Rust-dev at mozilla.org
>>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>>> Initialising a fixed size vector [T, ..n] by [foo(), .. n] unfortunately
>>>> requires that `T` is implicitly copyable (that is, it doesn't move ownership
>>>> when passed by value), and there's no way around this other than [foo(),
>>>> foo(), foo(),...].
>>>>
>>>>
>>>> Huon
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>

From kevin at sb.org  Fri Nov 29 21:56:23 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 29 Nov 2013 21:56:23 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
Message-ID: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>

I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.

Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):

~in(place) val
in(place) ~val
~val in place  (assuming this isn't somehow ambiguous)
~~val in place (the existing ~~val would have to be written ~(~val))
~~(place) val  (the existing ~~val would have to be written ~(~val))
~<place> val
~=place val
~>place val    (this looks like an arrow pointing to the place)
~>(place) val

Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.

-Kevin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 4118 bytes
Desc: not available
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/0320acc9/attachment-0001.p7s>

From pwalton at mozilla.com  Fri Nov 29 22:48:44 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 22:48:44 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
Message-ID: <694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>

None of these look like allocation.

Patrick

Kevin Ballard <kevin at sb.org> wrote:
>I am very saddened by the fact that we're apparently reserving `new` as
>a keyword, and even more by the fact that the proposed placement new
>syntax is `new(foo) bar`. This looks exactly like C++, and it goes
>against the strong precedence we already have of using new() as a
>static function for types. Path::init("foo") looks extremely wrong to
>me.
>
>Surely there's another syntax we can use for placement new that doesn't
>involve reserving `new` as a keyword? Here's a few random ideas (where
>"val" is the value expression and "place" is the place expression):
>
>~in(place) val
>in(place) ~val
>~val in place  (assuming this isn't somehow ambiguous)
>~~val in place (the existing ~~val would have to be written ~(~val))
>~~(place) val  (the existing ~~val would have to be written ~(~val))
>~<place> val
>~=place val
>~>place val    (this looks like an arrow pointing to the place)
>~>(place) val
>
>Personally I think `~in(place) val` is perfectly fine. It's not the
>prettiest of syntaxes, but placement new should be very rare, and this
>allows us to avoid reserving `new` and continue to use ~ as the
>allocation operator.
>
>-Kevin
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/6d050883/attachment.html>

From me at chrismorgan.info  Fri Nov 29 23:02:08 2013
From: me at chrismorgan.info (Chris Morgan)
Date: Sat, 30 Nov 2013 18:02:08 +1100
Subject: [rust-dev] do
Message-ID: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>

(Do I win the prize for the shortest thread name yet?)

> error: last argument in `do` call has non-procedure type: ||

In the past three or four days I've seen at least as many enquiries in
#rust about this error, and I'm sure there have been at least several
others while I haven't been monitoring it. This is evidently causing
quite a bit of confusion.

Here's a summary of the change. The syntax is the same as it was before::

    do expr { block }
    do expr |args| { block }
    do expr(args) { block }
    do expr(args) |args| { block }

These used to desugar to the following, respectively::

    expr(|| { block })
    expr(|args| { block })
    expr(args, || { block })
    expr(args, |args| { block })

These now desugar to the following, respectively::

    expr(proc() { block })
    expr(proc(args) { block })
    expr(args, proc() { block })
    expr(args, proc(args) { block })

The change is that it now accepts a procedure rather than a closure.
No syntax change, just a semantics change which breaks a lot of code.

Closure: a stack function; used to be ``&fn(..) -> _``, is now ``|..|
-> _``. Can be called multiple times, requires no allocations and is
not Send.

Procedure: a heap function; used to be ``~once fn(..) -> _``, is now
``proc(..) -> _``. Can be called once, requires heap allocation and is
Send.

Procedures are good for sending cross-task; things like the task body
are a good match. Still, I think there are a few problems with how
things are at present (i.e. after the do semantics change):

1. ``do`` is still using the syntax of a closure (``|..| { .. }``),
despite it now being a procedure.

2. All of a sudden, things using closures need to shift away from
using ``do`` or use procedures; this is causing confusion and may
cause bad design decisions where nice sugar triumphs over what is
actually needed; often the best solution may not be clear. (I, for
example, had not thought about the fact that ``proc`` was going to
allocate; the ``~once fn`` name was clearer about that. I'll speak
about ``&once fn`` another time. Don't mention it now, this thread is
just about ``do``.)

I have two solutions that I think could answer these concerns. Leaving
it as it is seems a bad idea to me.

(a) Kill ``do``
---------------

I've had mixed feelings about ``do``. Overall, it's pretty trivial
syntax sugar, but it's sugar of a dubious sort, because it changes
something that looks like a function call with N arguments to be a
function call with N+1 arguments. That's just a matter of learning it.

Still, ``do`` *is* nice sugar in the way it gets rid of parentheses at
the end. Overall, is it worth it? I don't know.

Once ``do`` is gone, there's no problem left: just remove the sugar
*everywhere* it was used and everything works and will do for the
foreseeable future.

(b) Make ``do`` support both closures and procedures
----------------------------------------------------

The syntax of ``do`` can be clearly seen to include the closure
syntax. We could easily extend it to support both closures and
procedures.

Here is a proposed ``do`` using closures once more, keeping the syntax
it had last week::

    do expr || { block }
    do expr(args) || { block }
    do expr |args| { block }
    do expr(args) |args| { block }

Here is a proposed ``do`` using procedures as the current behaviour
is, but with new syntax which is clearly a procedure::

    do expr proc() { block }
    do expr(args) proc() { block }
    do expr proc(args) { block }
    do expr(args) proc(args) { block }

This does leave these cases which are currently valid unclear::

    do expr { block }
    do expr(args) { block }

The options for this are (a) disallowing it; (b) making it always of
the function types; and (c) inferring the type. I generally prefer the
last solution but it is the most difficult. I'm not sure how it all
fits into the function traits stuff at all.

Incidentally, all this leaves the possibility open of making ``do``
work for *any* argument type, where ``do expr1 expr2`` simply desugars
to ``expr1(expr2)`` and ``do expr1(args) expr2`` to ``do expr1(args,
expr2)``. I don't know if that would be a good thing or not; it's
probably best to avoid discussion of that at present.

Summary
=======

Leaving ``do`` in its present form seems to me a distinctly bad idea,
with the syntax of one form of function while it uses another form of
function. I think we need to redo ``do`` very soon. (I'd save this
joke for later in the thread, but I'm afraid someone else might steal
it. I expect all responses to indicate they're in favour of this by
using the title "Re: do" :P.)

For myself, I have no preference to indicate; I am torn between the two options.

From kevin at sb.org  Fri Nov 29 23:10:22 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 29 Nov 2013 23:10:22 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
Message-ID: <6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>

As I said in the IRC channel, the reason why users often don't realize that `~T` is allocation, is not a failure of syntax, but a failure of documentation. The only reason why a user would know that `new Foo` allocates is because they've been exposed to that syntax from another language, one that actually documents the fact that it allocates. Users who haven't been exposed to `new Foo` from other languages will have no reason to understand that this allocates without being told that it allocates.

As such, there is no reason why we cannot simply fix the documentation to explain that `~` is the allocation operator, and that when it's used in an expression it means it allocates a value.

It was then explained to me that the "real" reason we needed `new` wasn't because of the issues with users understanding allocation, but because of a need for placement new. That is why I suggested some alternative syntaxes.

Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.

-Kevin

On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> None of these look like allocation.
> 
> Patrick
> 
> Kevin Ballard <kevin at sb.org> wrote:
> I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.
> 
> Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):
> 
> ~in(place) val
> in(place) ~val
> ~val in place  (assuming this isn't somehow ambiguous)
> ~~val in place (the existing ~~val would have to be written ~(~val))
> ~~(place) val  (the existing ~~val would have to be written ~(~val))
> ~<place> val
> ~=place val
> ~>place val    (this looks like an arrow pointing to the place)
> ~>(place) val
> 
> Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.
> 
> -Kevin
> 
> 
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/3d1a54e3/attachment.html>

From pwalton at mozilla.com  Fri Nov 29 23:26:55 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Fri, 29 Nov 2013 23:26:55 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
Message-ID: <3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>

There's also the fact that the exchange heap is the default place to allocate, so anything that needs an object (e.g. "in") doesn't work, as "in Unique" would probably be too verbose.

Looking like C++ is a goal of Rust, in any case...

Patrick

Kevin Ballard <kevin at sb.org> wrote:
>As I said in the IRC channel, the reason why users often don't realize
>that `~T` is allocation, is not a failure of syntax, but a failure of
>documentation. The only reason why a user would know that `new Foo`
>allocates is because they've been exposed to that syntax from another
>language, one that actually documents the fact that it allocates. Users
>who haven't been exposed to `new Foo` from other languages will have no
>reason to understand that this allocates without being told that it
>allocates.
>
>As such, there is no reason why we cannot simply fix the documentation
>to explain that `~` is the allocation operator, and that when it's used
>in an expression it means it allocates a value.
>
>It was then explained to me that the "real" reason we needed `new`
>wasn't because of the issues with users understanding allocation, but
>because of a need for placement new. That is why I suggested some
>alternative syntaxes.
>
>Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated
>value from the result of `n + m`, but `new (n + m)` is pretty
>nonsensical.
>
>-Kevin
>
>On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com>
>wrote:
>
>> None of these look like allocation.
>> 
>> Patrick
>> 
>> Kevin Ballard <kevin at sb.org> wrote:
>> I am very saddened by the fact that we're apparently reserving `new`
>as a keyword, and even more by the fact that the proposed placement new
>syntax is `new(foo) bar`. This looks exactly like C++, and it goes
>against the strong precedence we already have of using new() as a
>static function for types. Path::init("foo") looks extremely wrong to
>me.
>> 
>> Surely there's another syntax we can use for placement new that
>doesn't involve reserving `new` as a keyword? Here's a few random ideas
>(where "val" is the value expression and "place" is the place
>expression):
>> 
>> ~in(place) val
>> in(place) ~val
>> ~val in place  (assuming this isn't somehow ambiguous)
>> ~~val in place (the existing ~~val would have to be written ~(~val))
>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>> ~<place> val
>> ~=place val
>> ~>place val    (this looks like an arrow pointing to the place)
>> ~>(place) val
>> 
>> Personally I think `~in(place) val` is perfectly fine. It's not the
>prettiest of syntaxes, but placement new should be very rare, and this
>allows us to avoid reserving `new` and continue to use ~ as the
>allocation operator.
>> 
>> -Kevin
>> 
>> 
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/47ff6ba0/attachment-0001.html>

From kevin at sb.org  Fri Nov 29 23:28:15 2013
From: kevin at sb.org (Kevin Ballard)
Date: Fri, 29 Nov 2013 23:28:15 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
Message-ID: <BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>

On Nov 29, 2013, at 11:26 PM, Patrick Walton <pwalton at mozilla.com> wrote:

> There's also the fact that the exchange heap is the default place to allocate, so anything that needs an object (e.g. "in") doesn't work, as "in Unique" would probably be too verbose.

`in Unique` is too verbose, but `new(Unique)` isn't?

> Looking like C++ is a goal of Rust, in any case...

I thought C++ performance was a goal. Since when is C++ syntax considered to be a goal?

-Kevin

> Patrick
> 
> Kevin Ballard <kevin at sb.org> wrote:
> As I said in the IRC channel, the reason why users often don't realize that `~T` is allocation, is not a failure of syntax, but a failure of documentation. The only reason why a user would know that `new Foo` allocates is because they've been exposed to that syntax from another language, one that actually documents the fact that it allocates. Users who haven't been exposed to `new Foo` from other languages will have no reason to understand that this allocates without being told that it allocates.
> 
> As such, there is no reason why we cannot simply fix the documentation to explain that `~` is the allocation operator, and that when it's used in an expression it means it allocates a value.
> 
> It was then explained to me that the "real" reason we needed `new` wasn't because of the issues with users understanding allocation, but because of a need for placement new. That is why I suggested some alternative syntaxes.
> 
> Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.
> 
> -Kevin
> 
> On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com> wrote:
> 
>> None of these look like allocation.
>> 
>> Patrick
>> 
>> Kevin Ballard <kevin at sb.org> wrote:
>> I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.
>> 
>> Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):
>> 
>> ~in(place) val
>> in(place) ~val
>> ~val in place  (assuming this isn't somehow ambiguous)
>> ~~val in place (the existing ~~val would have to be written ~(~val))
>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>> ~<place> val
>> ~=place val
>> ~>place val    (this looks like an arrow pointing to the place)
>> ~>(place) val
>> 
>> Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.
>> 
>> -Kevin
>> 
>> 
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
> 
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131129/7424b741/attachment.html>

From oren at ben-kiki.org  Fri Nov 29 23:34:08 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 30 Nov 2013 09:34:08 +0200
Subject: [rust-dev] do
In-Reply-To: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
Message-ID: <CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>

I find `do` syntax form is vital for DSL-ish code. Getting rid of it makes
a lot of code look downright ugly. I'd rather it used a more Ruby-ish
notation though, I find that putting the `do` far away from the `{ ... }`
doesn't read well. `foo(....) do |...| { ... }` would have made more sense
for me (think of `do` as a macro-ish binary operation injecting the proc
into the function on the left). But the current form is acceptable.

Syntax niceties aside, I find it extremely problematic that we have only
two forms of "callable", one that is on the stack but can be called
multiple times, and one that is on the heap and can only be called once.
This arrangement sort-of-makes-sense when one thinks from an implementation
point of view, but I find it to lack a crucial use case, that of a form
that is on the stack and is also called only once.

The reason this 3rd form is so important is the extremely common case of a
container that wants to take an action as a parameter for a method.

```
... some_non_sendable_variable ...
... some_owned_variable ...
do container.do_something_at_most_once |...| { ... use *both* variables ...
}
```

This is a lose-lose situation. If the container takes a `proc`, then Rust
complains that it can't capture the non-send-able variable. But if the
container takes a stack closure, then Rust complains it can't use the owned
variable. Of course, the container will _not_ send the action and will also
_not_ call it twice, but it can't express this in the action type :-) The
only workaround I found is to use a closure and wrap each and every
non-send-able variable in a cell - this is an pointless and downright
annoying manual boilerplate code.

As long as this area of the language is being changed, I think that adding
this missing 3rd variant should definitely be discussed (and hopefully
implemented). This would affect the syntax discussion because there would
be three forms instead of two; there are some more and less obvious choices
here but they are secondary to the core issue of allowing the 3rd variant
in the 1st place.

On Sat, Nov 30, 2013 at 9:02 AM, Chris Morgan <me at chrismorgan.info> wrote:

> (a) Kill ``do``
>
...

> (b) Make ``do`` support both closures and procedures
>
...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/3c125a54/attachment.html>

From pwalton at mozilla.com  Sat Nov 30 00:23:08 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 00:23:08 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
Message-ID: <20612104-0833-48af-9891-32a364be4c0f@email.android.com>

I don't want stack once functions, because I feel that their use cases are better served with RAII, which serves the same purposes without rightward drift and without forcing LLVM to perform devirtualization.

Patrick 

Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>I find `do` syntax form is vital for DSL-ish code. Getting rid of it
>makes
>a lot of code look downright ugly. I'd rather it used a more Ruby-ish
>notation though, I find that putting the `do` far away from the `{ ...
>}`
>doesn't read well. `foo(....) do |...| { ... }` would have made more
>sense
>for me (think of `do` as a macro-ish binary operation injecting the
>proc
>into the function on the left). But the current form is acceptable.
>
>Syntax niceties aside, I find it extremely problematic that we have
>only
>two forms of "callable", one that is on the stack but can be called
>multiple times, and one that is on the heap and can only be called
>once.
>This arrangement sort-of-makes-sense when one thinks from an
>implementation
>point of view, but I find it to lack a crucial use case, that of a form
>that is on the stack and is also called only once.
>
>The reason this 3rd form is so important is the extremely common case
>of a
>container that wants to take an action as a parameter for a method.
>
>```
>... some_non_sendable_variable ...
>... some_owned_variable ...
>do container.do_something_at_most_once |...| { ... use *both* variables
>...
>}
>```
>
>This is a lose-lose situation. If the container takes a `proc`, then
>Rust
>complains that it can't capture the non-send-able variable. But if the
>container takes a stack closure, then Rust complains it can't use the
>owned
>variable. Of course, the container will _not_ send the action and will
>also
>_not_ call it twice, but it can't express this in the action type :-)
>The
>only workaround I found is to use a closure and wrap each and every
>non-send-able variable in a cell - this is an pointless and downright
>annoying manual boilerplate code.
>
>As long as this area of the language is being changed, I think that
>adding
>this missing 3rd variant should definitely be discussed (and hopefully
>implemented). This would affect the syntax discussion because there
>would
>be three forms instead of two; there are some more and less obvious
>choices
>here but they are secondary to the core issue of allowing the 3rd
>variant
>in the 1st place.
>
>On Sat, Nov 30, 2013 at 9:02 AM, Chris Morgan <me at chrismorgan.info>
>wrote:
>
>> (a) Kill ``do``
>>
>...
>
>> (b) Make ``do`` support both closures and procedures
>>
>...
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/db77d468/attachment.html>

From pwalton at mozilla.com  Sat Nov 30 00:26:11 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 00:26:11 -0800
Subject: [rust-dev] do
In-Reply-To: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
Message-ID: <61bc80a0-bf71-4627-87a2-bf962b4c8b82@email.android.com>

The main reason for "do"'s existence is to make task spawning look nice. The closure inference was removed throughout the language because it masked allocation and doesn't work well with custom smart pointers. If "do" is still causing confusion, I'd rather just remove it entirely.

Patrick

Chris Morgan <me at chrismorgan.info> wrote:
>(Do I win the prize for the shortest thread name yet?)
>
>> error: last argument in `do` call has non-procedure type: ||
>
>In the past three or four days I've seen at least as many enquiries in
>#rust about this error, and I'm sure there have been at least several
>others while I haven't been monitoring it. This is evidently causing
>quite a bit of confusion.
>
>Here's a summary of the change. The syntax is the same as it was
>before::
>
>    do expr { block }
>    do expr |args| { block }
>    do expr(args) { block }
>    do expr(args) |args| { block }
>
>These used to desugar to the following, respectively::
>
>    expr(|| { block })
>    expr(|args| { block })
>    expr(args, || { block })
>    expr(args, |args| { block })
>
>These now desugar to the following, respectively::
>
>    expr(proc() { block })
>    expr(proc(args) { block })
>    expr(args, proc() { block })
>    expr(args, proc(args) { block })
>
>The change is that it now accepts a procedure rather than a closure.
>No syntax change, just a semantics change which breaks a lot of code.
>
>Closure: a stack function; used to be ``&fn(..) -> _``, is now ``|..|
>-> _``. Can be called multiple times, requires no allocations and is
>not Send.
>
>Procedure: a heap function; used to be ``~once fn(..) -> _``, is now
>``proc(..) -> _``. Can be called once, requires heap allocation and is
>Send.
>
>Procedures are good for sending cross-task; things like the task body
>are a good match. Still, I think there are a few problems with how
>things are at present (i.e. after the do semantics change):
>
>1. ``do`` is still using the syntax of a closure (``|..| { .. }``),
>despite it now being a procedure.
>
>2. All of a sudden, things using closures need to shift away from
>using ``do`` or use procedures; this is causing confusion and may
>cause bad design decisions where nice sugar triumphs over what is
>actually needed; often the best solution may not be clear. (I, for
>example, had not thought about the fact that ``proc`` was going to
>allocate; the ``~once fn`` name was clearer about that. I'll speak
>about ``&once fn`` another time. Don't mention it now, this thread is
>just about ``do``.)
>
>I have two solutions that I think could answer these concerns. Leaving
>it as it is seems a bad idea to me.
>
>(a) Kill ``do``
>---------------
>
>I've had mixed feelings about ``do``. Overall, it's pretty trivial
>syntax sugar, but it's sugar of a dubious sort, because it changes
>something that looks like a function call with N arguments to be a
>function call with N+1 arguments. That's just a matter of learning it.
>
>Still, ``do`` *is* nice sugar in the way it gets rid of parentheses at
>the end. Overall, is it worth it? I don't know.
>
>Once ``do`` is gone, there's no problem left: just remove the sugar
>*everywhere* it was used and everything works and will do for the
>foreseeable future.
>
>(b) Make ``do`` support both closures and procedures
>----------------------------------------------------
>
>The syntax of ``do`` can be clearly seen to include the closure
>syntax. We could easily extend it to support both closures and
>procedures.
>
>Here is a proposed ``do`` using closures once more, keeping the syntax
>it had last week::
>
>    do expr || { block }
>    do expr(args) || { block }
>    do expr |args| { block }
>    do expr(args) |args| { block }
>
>Here is a proposed ``do`` using procedures as the current behaviour
>is, but with new syntax which is clearly a procedure::
>
>    do expr proc() { block }
>    do expr(args) proc() { block }
>    do expr proc(args) { block }
>    do expr(args) proc(args) { block }
>
>This does leave these cases which are currently valid unclear::
>
>    do expr { block }
>    do expr(args) { block }
>
>The options for this are (a) disallowing it; (b) making it always of
>the function types; and (c) inferring the type. I generally prefer the
>last solution but it is the most difficult. I'm not sure how it all
>fits into the function traits stuff at all.
>
>Incidentally, all this leaves the possibility open of making ``do``
>work for *any* argument type, where ``do expr1 expr2`` simply desugars
>to ``expr1(expr2)`` and ``do expr1(args) expr2`` to ``do expr1(args,
>expr2)``. I don't know if that would be a good thing or not; it's
>probably best to avoid discussion of that at present.
>
>Summary
>=======
>
>Leaving ``do`` in its present form seems to me a distinctly bad idea,
>with the syntax of one form of function while it uses another form of
>function. I think we need to redo ``do`` very soon. (I'd save this
>joke for later in the thread, but I'm afraid someone else might steal
>it. I expect all responses to indicate they're in favour of this by
>using the title "Re: do" :P.)
>
>For myself, I have no preference to indicate; I am torn between the two
>options.
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/b0ec1852/attachment-0001.html>

From pwalton at mozilla.com  Sat Nov 30 00:34:57 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 00:34:57 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
Message-ID: <c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>

Plain "new" would allocate in the exchange heap by default.

And yes, C++ syntax has always been a goal. That's why Rust has had curly braces from day one, for example. Of course it deviates when C++ syntax would lead to lack of expressivity (using "let" and colons before types allows for destructuring assignment, for example), but in general if the C++ way fits the language we go with it.

IMHO sigils made sense back when there were a couple of ways to allocate that were built into the language and there was no facility for custom smart pointers. Now that we have moved all that stuff into the library, sigils seem to make less sense to me, as punctuation is a non-extensible "closed set" to borrow a term from linguistics. Besides, they were a very frequent source of confusion. Documentation is good, but being self-documenting is better.

Patrick

Kevin Ballard <kevin at sb.org> wrote:
>On Nov 29, 2013, at 11:26 PM, Patrick Walton <pwalton at mozilla.com>
>wrote:
>
>> There's also the fact that the exchange heap is the default place to
>allocate, so anything that needs an object (e.g. "in") doesn't work, as
>"in Unique" would probably be too verbose.
>
>`in Unique` is too verbose, but `new(Unique)` isn't?
>
>> Looking like C++ is a goal of Rust, in any case...
>
>I thought C++ performance was a goal. Since when is C++ syntax
>considered to be a goal?
>
>-Kevin
>
>> Patrick
>> 
>> Kevin Ballard <kevin at sb.org> wrote:
>> As I said in the IRC channel, the reason why users often don't
>realize that `~T` is allocation, is not a failure of syntax, but a
>failure of documentation. The only reason why a user would know that
>`new Foo` allocates is because they've been exposed to that syntax from
>another language, one that actually documents the fact that it
>allocates. Users who haven't been exposed to `new Foo` from other
>languages will have no reason to understand that this allocates without
>being told that it allocates.
>> 
>> As such, there is no reason why we cannot simply fix the
>documentation to explain that `~` is the allocation operator, and that
>when it's used in an expression it means it allocates a value.
>> 
>> It was then explained to me that the "real" reason we needed `new`
>wasn't because of the issues with users understanding allocation, but
>because of a need for placement new. That is why I suggested some
>alternative syntaxes.
>> 
>> Also, FWIW, `~(n + m)` makes sense, as a way of producing an
>allocated value from the result of `n + m`, but `new (n + m)` is pretty
>nonsensical.
>> 
>> -Kevin
>> 
>> On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com>
>wrote:
>> 
>>> None of these look like allocation.
>>> 
>>> Patrick
>>> 
>>> Kevin Ballard <kevin at sb.org> wrote:
>>> I am very saddened by the fact that we're apparently reserving `new`
>as a keyword, and even more by the fact that the proposed placement new
>syntax is `new(foo) bar`. This looks exactly like C++, and it goes
>against the strong precedence we already have of using new() as a
>static function for types. Path::init("foo") looks extremely wrong to
>me.
>>> 
>>> Surely there's another syntax we can use for placement new that
>doesn't involve reserving `new` as a keyword? Here's a few random ideas
>(where "val" is the value expression and "place" is the place
>expression):
>>> 
>>> ~in(place) val
>>> in(place) ~val
>>> ~val in place  (assuming this isn't somehow ambiguous)
>>> ~~val in place (the existing ~~val would have to be written ~(~val))
>>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>>> ~<place> val
>>> ~=place val
>>> ~>place val    (this looks like an arrow pointing to the place)
>>> ~>(place) val
>>> 
>>> Personally I think `~in(place) val` is perfectly fine. It's not the
>prettiest of syntaxes, but placement new should be very rare, and this
>allows us to avoid reserving `new` and continue to use ~ as the
>allocation operator.
>>> 
>>> -Kevin
>>> 
>>> 
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> -- 
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>> 
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/b1a85616/attachment.html>

From denis.spir at gmail.com  Sat Nov 30 00:55:17 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 30 Nov 2013 09:55:17 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
Message-ID: <5299A7F5.7070006@gmail.com>

On 11/30/2013 08:10 AM, Kevin Ballard wrote:
> As I said in the IRC channel, the reason why users often don't realize that `~T` is allocation, is not a failure of syntax, but a failure of documentation. The only reason why a user would know that `new Foo` allocates is because they've been exposed to that syntax from another language, one that actually documents the fact that it allocates. Users who haven't been exposed to `new Foo` from other languages will have no reason to understand that this allocates without being told that it allocates.
>
> As such, there is no reason why we cannot simply fix the documentation to explain that `~` is the allocation operator, and that when it's used in an expression it means it allocates a value.
>
> It was then explained to me that the "real" reason we needed `new` wasn't because of the issues with users understanding allocation, but because of a need for placement new. That is why I suggested some alternative syntaxes.
>
> Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.

Since this issue is all about placing something into memory, why not use 'mem' ?

Denis

From bjzaba at yahoo.com.au  Sat Nov 30 01:01:13 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sat, 30 Nov 2013 19:01:13 +1000
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299A7F5.7070006@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<5299A7F5.7070006@gmail.com>
Message-ID: <F92E702B-7B3E-439E-B3C9-77E6EB2EE30F@yahoo.com.au>

On 30 Nov 2013, at 6:55 pm, spir <denis.spir at gmail.com> wrote:

> Since this issue is all about placing something into memory, why not use 'mem' ?
> 
> Denis

Some folks have suggested using `alloc`.

From kevin at sb.org  Sat Nov 30 01:01:55 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 01:01:55 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
Message-ID: <A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>

`new` isn't self-documenting. It's merely consistent with C++, but consistency with C++ cannot be considered self-documentation because there are a great many programmers out there who have never touched C++ (or any language with a `new` operator). To someone who hasn't encountered `new` before, an equally-valid interpretation of `new Foo` would be to construct a `Foo` value by invoking a standard initializer, returning it by-value.

Is consistency with C++ really so important as to break what is now a pretty strong library convention? Especially since the replacement convention, as seen in PR #10697, is pretty bad (namely, using ::init() instead of ::new(); init() to me seems as though it should merely initialize a value, not construct a new value. Heck, the old Path convention of using Path(..) is better than Path::init(..)). As I've been arguing, `new` is not inherently self-documenting, and the confusion around ~ can be solved with proper documentation (just as a C++ programmer needs to be taught that `new` is the allocation operator, a Rust programmer would be taught that ~ is the allocation operator). As for placement new, while it needs to be supported in some fashion, it's going to be used pretty rarely, such that I don't think it's worth reserving a keyword just for that. We have existing keywords and syntactical tokens that can be used. Among my previous suggestions I'm fond of both `~in(place) val` and `~>(place) val`.

We've been moving stuff from the language into the libraries, yes. But losing ~ seems like losing a big part of the "flavor" of Rust, so to speak. And semantically speaking, both `new` and ~ are the same operator, so I don't think the closed-set nature of sigils is an issue in this case.

-Kevin

On Nov 30, 2013, at 12:34 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> Plain "new" would allocate in the exchange heap by default.
> 
> And yes, C++ syntax has always been a goal. That's why Rust has had curly braces from day one, for example. Of course it deviates when C++ syntax would lead to lack of expressivity (using "let" and colons before types allows for destructuring assignment, for example), but in general if the C++ way fits the language we go with it.
> 
> IMHO sigils made sense back when there were a couple of ways to allocate that were built into the language and there was no facility for custom smart pointers. Now that we have moved all that stuff into the library, sigils seem to make less sense to me, as punctuation is a non-extensible "closed set" to borrow a term from linguistics. Besides, they were a very frequent source of confusion. Documentation is good, but being self-documenting is better.
> 
> Patrick
> 
> Kevin Ballard <kevin at sb.org> wrote:
> On Nov 29, 2013, at 11:26 PM, Patrick Walton <pwalton at mozilla.com> wrote:
> 
>> There's also the fact that the exchange heap is the default place to allocate, so anything that needs an object (e.g. "in") doesn't work, as "in Unique" would probably be too verbose.
> 
> `in Unique` is too verbose, but `new(Unique)` isn't?
> 
>> Looking like C++ is a goal of Rust, in any case...
> 
> I thought C++ performance was a goal. Since when is C++ syntax considered to be a goal?
> 
> -Kevin
> 
>> Patrick
>> 
>> Kevin Ballard <kevin at sb.org> wrote:
>> As I said in the IRC channel, the reason why users often don't realize that `~T` is allocation, is not a failure of syntax, but a failure of documentation. The only reason why a user would know that `new Foo` allocates is because they've been exposed to that syntax from another language, one that actually documents the fact that it allocates. Users who haven't been exposed to `new Foo` from other languages will have no reason to understand that this allocates without being told that it allocates.
>> 
>> As such, there is no reason why we cannot simply fix the documentation to explain that `~` is the allocation operator, and that when it's used in an expression it means it allocates a value.
>> 
>> It was then explained to me that the "real" reason we needed `new` wasn't because of the issues with users understanding allocation, but because of a need for placement new. That is why I suggested some alternative syntaxes.
>> 
>> Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.
>> 
>> -Kevin
>> 
>> On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com> wrote:
>> 
>>> None of these look like allocation.
>>> 
>>> Patrick
>>> 
>>> Kevin Ballard <kevin at sb.org> wrote:
>>> I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.
>>> 
>>> Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):
>>> 
>>> ~in(place) val
>>> in(place) ~val
>>> ~val in place  (assuming this isn't somehow ambiguous)
>>> ~~val in place (the existing ~~val would have to be written ~(~val))
>>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>>> ~<place> val
>>> ~=place val
>>> ~>place val    (this looks like an arrow pointing to the place)
>>> ~>(place) val
>>> 
>>> Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.
>>> 
>>> -Kevin
>>> 
>>> 
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>> 
>>> -- 
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>> 
>> 
>> -- 
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
> 
> 
> -- 
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/4d6c9d94/attachment-0001.html>

From dteller at mozilla.com  Sat Nov 30 01:07:32 2013
From: dteller at mozilla.com (David Rajchenbach-Teller)
Date: Sat, 30 Nov 2013 10:07:32 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
Message-ID: <5299AAD4.6090304@mozilla.com>

On 11/30/13 10:01 AM, Kevin Ballard wrote:
> `new` isn't self-documenting. It's merely consistent with C++, but
> consistency with C++ cannot be considered self-documentation because
> there are a great many programmers out there who have never touched C++
> (or any language with a `new` operator). To someone who hasn't
> encountered `new` before, an equally-valid interpretation of `new Foo`
> would be to construct a `Foo` value by invoking a standard initializer,
> returning it by-value.

I believe that Patrick's argument is that the primary target of Rust is
people who are already familiar with C++. To them, `new` will be
self-documenting. Programmers who are not familiar with `new` (who are
getting rare these days) will still need to learn a new construct, just
as they would with sigils.

I do not have a very strong opinion, but I believe that `new` is indeed
a good way to astonish the least amount of newcomers.

Cheers,
 David

-- 
David Rajchenbach-Teller, PhD
 Performance Team, Mozilla

From hatahet at gmail.com  Sat Nov 30 01:14:45 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 30 Nov 2013 01:14:45 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299AAD4.6090304@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
Message-ID: <CAN1rdExPKs1pSD=dHkrNuhXRgF1WvnjoOEpCOzHHRvdon4EUSA@mail.gmail.com>

Would it not be possible to have "new" be a keyword, yet not a reserved
word (since they are not the same thing). This leaves the possibility of
using it as a method name (e.g. Struct::new()), while still using it as an
operator.

--
Ziad


On Sat, Nov 30, 2013 at 1:07 AM, David Rajchenbach-Teller <
dteller at mozilla.com> wrote:

> On 11/30/13 10:01 AM, Kevin Ballard wrote:
> > `new` isn't self-documenting. It's merely consistent with C++, but
> > consistency with C++ cannot be considered self-documentation because
> > there are a great many programmers out there who have never touched C++
> > (or any language with a `new` operator). To someone who hasn't
> > encountered `new` before, an equally-valid interpretation of `new Foo`
> > would be to construct a `Foo` value by invoking a standard initializer,
> > returning it by-value.
>
> I believe that Patrick's argument is that the primary target of Rust is
> people who are already familiar with C++. To them, `new` will be
> self-documenting. Programmers who are not familiar with `new` (who are
> getting rare these days) will still need to learn a new construct, just
> as they would with sigils.
>
> I do not have a very strong opinion, but I believe that `new` is indeed
> a good way to astonish the least amount of newcomers.
>
> Cheers,
>  David
>
> --
> David Rajchenbach-Teller, PhD
>  Performance Team, Mozilla
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/0ede4baa/attachment.html>

From kevin at sb.org  Sat Nov 30 01:24:19 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 01:24:19 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299AAD4.6090304@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
Message-ID: <9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>

On Nov 30, 2013, at 1:07 AM, David Rajchenbach-Teller <dteller at mozilla.com> wrote:

> On 11/30/13 10:01 AM, Kevin Ballard wrote:
>> `new` isn't self-documenting. It's merely consistent with C++, but
>> consistency with C++ cannot be considered self-documentation because
>> there are a great many programmers out there who have never touched C++
>> (or any language with a `new` operator). To someone who hasn't
>> encountered `new` before, an equally-valid interpretation of `new Foo`
>> would be to construct a `Foo` value by invoking a standard initializer,
>> returning it by-value.
> 
> I believe that Patrick's argument is that the primary target of Rust is
> people who are already familiar with C++. To them, `new` will be
> self-documenting. Programmers who are not familiar with `new` (who are
> getting rare these days) will still need to learn a new construct, just
> as they would with sigils.
> 
> I do not have a very strong opinion, but I believe that `new` is indeed
> a good way to astonish the least amount of newcomers.

Assuming for the moment that most Rust programmers will, both now and in the future, have started with C++, we still need to document the allocation operator in such a way that people who have not seen it before will understand it. Given that, I do not see that there is much benefit to using `new` over ~ for the sake of familiarity to a subset of programmers, as that does not absolve us from our need for good documentation. Not to mention the proposed `new` operator here will actually behave differently than it does in C++ anyway, which means that familiarity might actually be a bad thing as it will lead users to think they understand the operator when they don't! Notably, in C++ the `new` operator invokes a class constructor, whereas in Rust it allocates an arbitrary expression's value into a memory location (typically on the exchange heap, or into an explicit location with placement new). What is a C++ programmer supposed to think when they see `new (x + y)`?

Speaking of `new (x + y)`, has any thought been given to differentiating `new (expr)` from placement-new? AFAIK whitespace after keywords/identifiers is not significant anywhere else in the language, so one would expect `new (foo)` to be an attempt at placement-new with the destination expression `foo`, just like `new(foo)`. But if that's the case, how does one allocate the value of a parenthesized expression? `~(x + y)` is perfectly legal today. The only appropriate solution I can think of is `new() (x + y)`, which is ugly and surprising.

Given all this, my inclination at this point is to say that trying to piggyback on C++ programmers' familiarity of `new` is actually a really bad idea, as Rust's allocation operator differs in a few important ways from C++. In fact, offhand I can't think of any language with a `new `operator that uses it for something other than invoking a class constructor.

-Kevin

From gaetan at xeberon.net  Sat Nov 30 02:09:51 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 30 Nov 2013 11:09:51 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
Message-ID: <CANK7tAHsOzVvodJw3D9WSG2-voe36oDj9y_B-D06dCj5xm+xEw@mail.gmail.com>

Thanks for this explanation about ~! Can you add a paragraph in the
tutorial or manual?
Le 30 nov. 2013 08:10, "Kevin Ballard" <kevin at sb.org> a ?crit :

> As I said in the IRC channel, the reason why users often don't realize
> that `~T` is allocation, is not a failure of syntax, but a failure of
> documentation. The only reason why a user would know that `new Foo`
> allocates is because they've been exposed to that syntax from another
> language, one that actually documents the fact that it allocates. Users who
> haven't been exposed to `new Foo` from other languages will have no reason
> to understand that this allocates without being told that it allocates.
>
> As such, there is no reason why we cannot simply fix the documentation to
> explain that `~` is the allocation operator, and that when it's used in an
> expression it means it allocates a value.
>
> It was then explained to me that the "real" reason we needed `new` wasn't
> because of the issues with users understanding allocation, but because of a
> need for placement new. That is why I suggested some alternative syntaxes.
>
> Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated
> value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.
>
> -Kevin
>
> On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com> wrote:
>
> None of these look like allocation.
>
> Patrick
>
> Kevin Ballard <kevin at sb.org> wrote:
>>
>> I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.
>>
>> Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):
>>
>> ~in(place) val
>> in(place) ~val
>> ~val in place  (assuming this isn't somehow ambiguous)
>> ~~val in place (the existing ~~val would have to be written ~(~val))
>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>> ~<place> val
>> ~=place val
>> ~>place val    (this looks like an arrow pointing to the place)
>> ~>(place) val
>>
>> Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.
>>
>> -Kevin
>>
>>
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/555e9f73/attachment.html>

From gaetan at xeberon.net  Sat Nov 30 02:14:57 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 30 Nov 2013 11:14:57 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
Message-ID: <CANK7tAFz295Dr2tGyyQWJrfB5wN0E3XPD1iehDAj+O6GmnQ54Q@mail.gmail.com>

If looking like c++ is a goal, why not using the same naming convention as
it for constructor? Having an init () function or new () function is
generally a bad idea, it is just a name.
I prefere personnally the "new" name.

What i dont really like is the fn keyword, it is too short. func or
function would have been perfectly acceptable.
Le 30 nov. 2013 10:02, "Kevin Ballard" <kevin at sb.org> a ?crit :

> `new` isn't self-documenting. It's merely consistent with C++, but
> consistency with C++ cannot be considered self-documentation because there
> are a great many programmers out there who have never touched C++ (or any
> language with a `new` operator). To someone who hasn't encountered `new`
> before, an equally-valid interpretation of `new Foo` would be to construct
> a `Foo` value by invoking a standard initializer, returning it by-value.
>
> Is consistency with C++ really so important as to break what is now a
> pretty strong library convention? Especially since the replacement
> convention, as seen in PR #10697, is pretty bad (namely, using ::init()
> instead of ::new(); init() to me seems as though it should merely
> initialize a value, not construct a new value. Heck, the old Path
> convention of using Path(..) is better than Path::init(..)). As I've been
> arguing, `new` is not inherently self-documenting, and the confusion around
> ~ can be solved with proper documentation (just as a C++ programmer needs
> to be taught that `new` is the allocation operator, a Rust programmer would
> be taught that ~ is the allocation operator). As for placement new, while
> it needs to be supported in some fashion, it's going to be used pretty
> rarely, such that I don't think it's worth reserving a keyword just for
> that. We have existing keywords and syntactical tokens that can be used.
> Among my previous suggestions I'm fond of both `~in(place) val` and
> `~>(place) val`.
>
> We've been moving stuff from the language into the libraries, yes. But
> losing ~ seems like losing a big part of the "flavor" of Rust, so to speak.
> And semantically speaking, both `new` and ~ are the same operator, so I
> don't think the closed-set nature of sigils is an issue in this case.
>
> -Kevin
>
> On Nov 30, 2013, at 12:34 AM, Patrick Walton <pwalton at mozilla.com> wrote:
>
> Plain "new" would allocate in the exchange heap by default.
>
> And yes, C++ syntax has always been a goal. That's why Rust has had curly
> braces from day one, for example. Of course it deviates when C++ syntax
> would lead to lack of expressivity (using "let" and colons before types
> allows for destructuring assignment, for example), but in general if the
> C++ way fits the language we go with it.
>
> IMHO sigils made sense back when there were a couple of ways to allocate
> that were built into the language and there was no facility for custom
> smart pointers. Now that we have moved all that stuff into the library,
> sigils seem to make less sense to me, as punctuation is a non-extensible
> "closed set" to borrow a term from linguistics. Besides, they were a very
> frequent source of confusion. Documentation is good, but being
> self-documenting is better.
>
> Patrick
>
> Kevin Ballard <kevin at sb.org> wrote:
>>
>> On Nov 29, 2013, at 11:26 PM, Patrick Walton <pwalton at mozilla.com> wrote:
>>
>> There's also the fact that the exchange heap is the default place to
>> allocate, so anything that needs an object (e.g. "in") doesn't work, as "in
>> Unique" would probably be too verbose.
>>
>>
>> `in Unique` is too verbose, but `new(Unique)` isn't?
>>
>> Looking like C++ is a goal of Rust, in any case...
>>
>>
>> I thought C++ performance was a goal. Since when is C++ syntax considered
>> to be a goal?
>>
>> -Kevin
>>
>> Patrick
>>
>> Kevin Ballard <kevin at sb.org> wrote:
>>>
>>> As I said in the IRC channel, the reason why users often don't realize
>>> that `~T` is allocation, is not a failure of syntax, but a failure of
>>> documentation. The only reason why a user would know that `new Foo`
>>> allocates is because they've been exposed to that syntax from another
>>> language, one that actually documents the fact that it allocates. Users who
>>> haven't been exposed to `new Foo` from other languages will have no reason
>>> to understand that this allocates without being told that it allocates.
>>>
>>> As such, there is no reason why we cannot simply fix the documentation
>>> to explain that `~` is the allocation operator, and that when it's used in
>>> an expression it means it allocates a value.
>>>
>>> It was then explained to me that the "real" reason we needed `new`
>>> wasn't because of the issues with users understanding allocation, but
>>> because of a need for placement new. That is why I suggested some
>>> alternative syntaxes.
>>>
>>> Also, FWIW, `~(n + m)` makes sense, as a way of producing an allocated
>>> value from the result of `n + m`, but `new (n + m)` is pretty nonsensical.
>>>
>>> -Kevin
>>>
>>> On Nov 29, 2013, at 10:48 PM, Patrick Walton <pwalton at mozilla.com>
>>> wrote:
>>>
>>> None of these look like allocation.
>>>
>>> Patrick
>>>
>>> Kevin Ballard <kevin at sb.org> wrote:
>>>>
>>>> I am very saddened by the fact that we're apparently reserving `new` as a keyword, and even more by the fact that the proposed placement new syntax is `new(foo) bar`. This looks exactly like C++, and it goes against the strong precedence we already have of using new() as a static function for types. Path::init("foo") looks extremely wrong to me.
>>>>
>>>> Surely there's another syntax we can use for placement new that doesn't involve reserving `new` as a keyword? Here's a few random ideas (where "val" is the value expression and "place" is the place expression):
>>>>
>>>> ~in(place) val
>>>> in(place) ~val
>>>> ~val in place  (assuming this isn't somehow ambiguous)
>>>> ~~val in place (the existing ~~val would have to be written ~(~val))
>>>> ~~(place) val  (the existing ~~val would have to be written ~(~val))
>>>> ~<place> val
>>>> ~=place val
>>>> ~>place val    (this looks like an arrow pointing to the place)
>>>> ~>(place) val
>>>>
>>>> Personally I think `~in(place) val` is perfectly fine. It's not the prettiest of syntaxes, but placement new should be very rare, and this allows us to avoid reserving `new` and continue to use ~ as the allocation operator.
>>>>
>>>> -Kevin
>>>>
>>>>
>>>> ------------------------------
>>>>
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>>
>>> --
>>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>>
>>>
>>>
>> --
>> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>>
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/5eec6da1/attachment-0001.html>

From jurily at gmail.com  Sat Nov 30 02:24:10 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sat, 30 Nov 2013 11:24:10 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
Message-ID: <5299BCCA.5060707@gmail.com>

On 11/30/2013 09:34 AM, Patrick Walton wrote:
> IMHO sigils made sense back when there were a couple of ways to allocate
> that were built into the language and there was no facility for custom
> smart pointers. Now that we have moved all that stuff into the library,
> sigils seem to make less sense to me


What really bugs me about `~` is that it conflates the idea of lifetime 
and ownership (which is a zero-cost annotation) with allocation (which 
is an actual expensive operation to stay away from). This wasn't a 
problem with `@`, but it's gone now.

My choice would be to keep `~` in types, but use `new` for allocation:

     let foo: ~Foo = new Foo(bar);

From jurily at gmail.com  Sat Nov 30 02:26:12 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sat, 30 Nov 2013 11:26:12 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <F92E702B-7B3E-439E-B3C9-77E6EB2EE30F@yahoo.com.au>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<5299A7F5.7070006@gmail.com>
	<F92E702B-7B3E-439E-B3C9-77E6EB2EE30F@yahoo.com.au>
Message-ID: <5299BD44.2030002@gmail.com>

On 11/30/2013 10:01 AM, Brendan Zabarauskas wrote:
> Some folks have suggested using `alloc`.

We could call it `malloc` and make it a library function!

From dbau.pp at gmail.com  Sat Nov 30 02:58:58 2013
From: dbau.pp at gmail.com (Huon Wilson)
Date: Sat, 30 Nov 2013 21:58:58 +1100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299BCCA.5060707@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<5299BCCA.5060707@gmail.com>
Message-ID: <5299C4F2.9080609@gmail.com>

On 30/11/13 21:24, Gy?rgy Andrasek wrote:
> On 11/30/2013 09:34 AM, Patrick Walton wrote:
>> IMHO sigils made sense back when there were a couple of ways to allocate
>> that were built into the language and there was no facility for custom
>> smart pointers. Now that we have moved all that stuff into the library,
>> sigils seem to make less sense to me
>
>
> What really bugs me about `~` is that it conflates the idea of 
> lifetime and ownership (which is a zero-cost annotation) with 
> allocation (which is an actual expensive operation to stay away from). 
> This wasn't a problem with `@`, but it's gone now.
>
> My choice would be to keep `~` in types, but use `new` for allocation:
>
>     let foo: ~Foo = new Foo(bar);
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev

The ownership ideas apply to all values always, i.e. `let foo: Foo = 
Foo(bar);` is equally as "owned" as `let foo: ~Foo = ...;`, the only 
difference is the latter is always pointer sized (and always has a 
destructor, even if `Foo` doesn't).



Huon

From oren at ben-kiki.org  Sat Nov 30 03:25:52 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 30 Nov 2013 13:25:52 +0200
Subject: [rust-dev] do
In-Reply-To: <20612104-0833-48af-9891-32a364be4c0f@email.android.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<20612104-0833-48af-9891-32a364be4c0f@email.android.com>
Message-ID: <CADJiDhsL1RG4GHFDMnOyRRQh-0BtrmYajMOgoW_D2x9Cj6zQtA@mail.gmail.com>

Once stack functions have nothing to do with RAII. It is about container
manipulation methods. Consider the mangle function of a hashmap for
example. It makes perfect sense to be able to access a borrowed pointer and
also consume an owned pointer inside the mangle actions. This is currently
impossible "just because".

I have ~10K of Rust LOC in my pet project and I run into this problem more
than a dozen times. I ended up using cells and other nastiness to work
around what is essentially an artificial restriction.

Passing actions to other tasks is all well and good, and repeatedly
applying a function to many container members (e.g., "mapping" or
"folding") is also common. Both of these use cases are very well supported.
But it is as common to have a container that invokes a function exactly
once on one specific member (as another example, basically any function of
the Option type that invokes an action). And this common use case is very
badly supported.



On Sat, Nov 30, 2013 at 10:23 AM, Patrick Walton <pwalton at mozilla.com>wrote:

> I don't want stack once functions, because I feel that their use cases are
> better served with RAII, which serves the same purposes without rightward
> drift and without forcing LLVM to perform devirtualization.
>
> Patrick
>
> Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>>
>> I find `do` syntax form is vital for DSL-ish code. Getting rid of it
>> makes a lot of code look downright ugly. I'd rather it used a more Ruby-ish
>> notation though, I find that putting the `do` far away from the `{ ... }`
>> doesn't read well. `foo(....) do |...| { ... }` would have made more sense
>> for me (think of `do` as a macro-ish binary operation injecting the proc
>> into the function on the left). But the current form is acceptable.
>>
>> Syntax niceties aside, I find it extremely problematic that we have only
>> two forms of "callable", one that is on the stack but can be called
>> multiple times, and one that is on the heap and can only be called once.
>> This arrangement sort-of-makes-sense when one thinks from an implementation
>> point of view, but I find it to lack a crucial use case, that of a form
>> that is on the stack and is also called only once.
>>
>> The reason this 3rd form is so important is the extremely common case of
>> a container that wants to take an action as a parameter for a method.
>>
>> ```
>> ... some_non_sendable_variable ...
>> ... some_owned_variable ...
>> do container.do_something_at_most_once |...| { ... use *both* variables
>> ... }
>> ```
>>
>> This is a lose-lose situation. If the container takes a `proc`, then Rust
>> complains that it can't capture the non-send-able variable. But if the
>> container takes a stack closure, then Rust complains it can't use the owned
>> variable. Of course, the container will _not_ send the action and will also
>> _not_ call it twice, but it can't express this in the action type :-) The
>> only workaround I found is to use a closure and wrap each and every
>> non-send-able variable in a cell - this is an pointless and downright
>> annoying manual boilerplate code.
>>
>> As long as this area of the language is being changed, I think that
>> adding this missing 3rd variant should definitely be discussed (and
>> hopefully implemented). This would affect the syntax discussion because
>> there would be three forms instead of two; there are some more and less
>> obvious choices here but they are secondary to the core issue of allowing
>> the 3rd variant in the 1st place.
>>
>> On Sat, Nov 30, 2013 at 9:02 AM, Chris Morgan <me at chrismorgan.info>wrote:
>>
>>> (a) Kill ``do``
>>>
>> ...
>>
>>> (b) Make ``do`` support both closures and procedures
>>>
>> ...
>>
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/7d2d5665/attachment.html>

From ben at 0x539.de  Sat Nov 30 06:20:32 2013
From: ben at 0x539.de (Benjamin Herr)
Date: Sat, 30 Nov 2013 15:20:32 +0100
Subject: [rust-dev] do
In-Reply-To: <CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
Message-ID: <1385821232.12948.12.camel@vigil>

On Sat, 2013-11-30 at 09:34 +0200, Oren Ben-Kiki wrote:

> This is a lose-lose situation. If the container takes a `proc`, then
> Rust complains that it can't capture the non-send-able variable. But
> if the container takes a stack closure, then Rust complains it can't
> use the owned variable. Of course, the container will _not_ send the
> action and will also _not_ call it twice, but it can't express this in
> the action type :-) The only workaround I found is to use a closure
> and wrap each and every non-send-able variable in a cell - this is an
> pointless and downright annoying manual boilerplate code.

I think another previously mentioned workaround is to change all your
closure-taking functions to have a name ending in "_with" and take an
extra generic parameter by value that is then passed to the closure. In
practice, that might end up being a tuple with all the values you're
need to move into and from within the closure.

It's not ideal and requires cooperation from the API but it probably
reads better than a bunch of cells. :)

-benh


From oren at ben-kiki.org  Sat Nov 30 06:34:55 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 30 Nov 2013 16:34:55 +0200
Subject: [rust-dev] do
In-Reply-To: <1385821232.12948.12.camel@vigil>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
Message-ID: <CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>

That would help a bit, but it would still require the programmer to
manually setup and teardown the tuples, pass them to the closure, and so
on. We'll also need to change each and every function that takes an action
parameter to take the extra tuple in every container or container-like
type. And then there's the possibility of modifying variables... It sounds
like a lot of effort working around something the compiler can do
automatically and actually already does automatically; all it needs is the
ability to communicate the programmer intent via the type system so it can
support and enforce it.


On Sat, Nov 30, 2013 at 4:20 PM, Benjamin Herr <ben at 0x539.de> wrote:

> On Sat, 2013-11-30 at 09:34 +0200, Oren Ben-Kiki wrote:
>
> > This is a lose-lose situation. If the container takes a `proc`, then
> > Rust complains that it can't capture the non-send-able variable. But
> > if the container takes a stack closure, then Rust complains it can't
> > use the owned variable. Of course, the container will _not_ send the
> > action and will also _not_ call it twice, but it can't express this in
> > the action type :-) The only workaround I found is to use a closure
> > and wrap each and every non-send-able variable in a cell - this is an
> > pointless and downright annoying manual boilerplate code.
>
> I think another previously mentioned workaround is to change all your
> closure-taking functions to have a name ending in "_with" and take an
> extra generic parameter by value that is then passed to the closure. In
> practice, that might end up being a tuple with all the values you're
> need to move into and from within the closure.
>
> It's not ideal and requires cooperation from the API but it probably
> reads better than a bunch of cells. :)
>
> -benh
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/a7f6d4e9/attachment-0001.html>

From ben.striegel at gmail.com  Sat Nov 30 08:06:20 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 11:06:20 -0500
Subject: [rust-dev] do
In-Reply-To: <61bc80a0-bf71-4627-87a2-bf962b4c8b82@email.android.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<61bc80a0-bf71-4627-87a2-bf962b4c8b82@email.android.com>
Message-ID: <CAAvrL-k543ExRisL0-xGpxrtW-11j-dWaFArfcSX=DX-H932Tg@mail.gmail.com>

> If "do" is still causing confusion, I'd rather just remove it entirely.

I rather like `do`. I agree that if it's confusing it should be considered
for removal, but IMO the confusion here stems from familiarity with the
prior, obsolete semantics rather than any inherent problem with the
construct itself. I say we should wait for people to familiarize themselves
with the new closure types before thinking about giving it the axe.


On Sat, Nov 30, 2013 at 3:26 AM, Patrick Walton <pwalton at mozilla.com> wrote:

> The main reason for "do"'s existence is to make task spawning look nice.
> The closure inference was removed throughout the language because it masked
> allocation and doesn't work well with custom smart pointers. If "do" is
> still causing confusion, I'd rather just remove it entirely.
>
> Patrick
>
> Chris Morgan <me at chrismorgan.info> wrote:
>>
>> (Do I win the prize for the shortest thread name yet?)
>>
>> error: last argument in `do` call has non-procedure type: ||
>>
>>
>> In the past three or four days I've seen at least as many enquiries in
>> #rust about this error, and I'm sure there have been at least several
>> others while I haven't been monitoring it. This is evidently causing
>>
>> quite a bit of confusion.
>>
>> Here's a summary of the change. The syntax is the same as it was before::
>>
>> do expr { block }
>> do expr |args| { block }
>> do expr(args) { block }
>> do expr(args) |args| { block }
>>
>> These used to desugar to the following, respectively::
>>
>> expr(|| { block })
>> expr(|args| { block })
>> expr(args, || { block })
>> expr(args, |args| { block })
>>
>> These now desugar to the following, respectively
>>  ::
>>
>> expr(proc() { block })
>> expr(proc(args) { block })
>> expr(args, proc() { block })
>> expr(args, proc(args) { block })
>>
>> The change is that it now accepts a procedure rather than a closure.
>> No syntax change, just a semantics change which breaks a lot of code.
>>
>> Closure: a stack function; used to be ``&fn(..) -> _``, is now ``|..|
>> -> _``. Can be called multiple times, requires no allocations and is
>> not Send.
>>
>> Procedure: a heap function; used to be ``~once fn(..) -> _``, is now
>>
>> ``proc(..) -> _``. Can be called once, requires heap allocation and is
>> Send.
>>
>> Procedures are good for sending cross-task; things like the task body
>> are a good match. Still, I think there are a few problems with how
>>
>> things are at present (i.e. after the do semantics change):
>>
>> 1. ``do`` is still using the syntax of a closure (``|..| { .. }``),
>> despite it now being a procedure.
>>
>>
>>  2. All
>> of a sudden, things using closures need to shift away from
>> using ``do`` or use procedures; this is causing confusion and may
>> cause bad design decisions where nice sugar triumphs over what is
>> actually needed; often the best solution may not be clear. (I, for
>>
>> example, had not thought about the fact that ``proc`` was going to
>> allocate; the ``~once fn`` name was clearer about that. I'll speak
>> about ``&once fn`` another time. Don't mention it now, this thread is
>>
>> just about ``do``.)
>>
>> I have two solutions that I think could answer these concerns. Leaving
>> it as it is seems a bad idea to me.
>>
>> (a) Kill ``do``
>> ---------------
>>
>> I've had mixed feelings about ``do``. Overall, it's pretty trivial
>>
>> syntax sugar, but it's sugar of a dubious sort, because it changes
>> something that looks like a function call with N arguments to be a
>> function call with N+1 arguments. That's just a matter of learning it.<
>>  br
>> />
>>
>> Still, ``do`` *is* nice sugar in the way it gets rid of parentheses at
>> the end. Overall, is it worth it? I don't know.
>>
>> Once ``do`` is gone, there's no problem left: just remove the sugar
>>
>> *everywhere* it was used and everything works and will do for the
>> foreseeable future.
>>
>> (b) Make ``do`` support both closures and procedures
>> ------------------------------
>>
>>
>> The syntax of ``do`` can be clearly seen to include the closure
>>
>> syntax. We could easily extend it to support both closures and
>> procedures.
>>
>> Here is a proposed ``do`` using closures once more, keeping the syntax
>> it had last week::
>>
>> do expr || { block }
>> do expr(args) || { block }
>>
>> do expr |args| { block }
>> do expr(args) |args| { block }
>>
>> Here is a proposed ``do`` using procedures as the current behaviour
>> is, but with new syntax which is clearly a procedure::
>>
>> do expr proc() { block }
>> do expr(args) proc() { block }<
>>  br />do
>> expr proc(args) { block }
>>
>> do expr(args) proc(args) { block }
>>
>> This does leave these cases which are currently valid unclear::
>>
>> do expr { block }
>> do expr(args) { block }
>>
>> The options for this are (a) disallowing it; (b) making it always of
>>
>> the function types; and (c) inferring the type. I generally prefer the
>> last solution but it is the most difficult. I'm not sure how it all
>> fits into the function traits stuff at all.
>>
>> Incidentally, all this leaves the possibility open of making ``do``
>>
>> work for *any* argument type, where ``do expr1 expr2`` simply desugars
>> to ``expr1(expr2)`` and ``do expr1(args) expr2`` to ``do expr1(args,
>> expr2)``. I don't know if that would be a good thing or not; it's
>>
>> probably best to avoid discussion of that at present.
>>
>> Summary
>> =======
>>
>> Leaving ``do`` in its present form seems to me a distinctly bad idea,
>> with the syntax of one form of funct
>>  ion
>> while it uses another form of
>> function. I think we need to redo ``do`` very soon. (I'd save this
>> joke for later in the thread, but I'm afraid someone else might steal
>> it. I expect all responses to indicate they're in favour of this by
>>
>> using the title "Re: do" :P.)
>>
>> For myself, I have no preference to indicate; I am torn between the two options.
>> ------------------------------
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
> --
> Sent from my Android phone with K-9 Mail. Please excuse my brevity.
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/28b05212/attachment.html>

From tiffany at stormbit.net  Sat Nov 30 08:32:54 2013
From: tiffany at stormbit.net (Tiffany Bennett)
Date: Sat, 30 Nov 2013 11:32:54 -0500
Subject: [rust-dev] do
In-Reply-To: <CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
Message-ID: <CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>

On Sat, Nov 30, 2013 at 9:34 AM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> That would help a bit, but it would still require the programmer to
> manually setup and teardown the tuples, pass them to the closure, and so
> on. We'll also need to change each and every function that takes an action
> parameter to take the extra tuple in every container or container-like
> type. And then there's the possibility of modifying variables... It sounds
> like a lot of effort working around something the compiler can do
> automatically and actually already does automatically; all it needs is the
> ability to communicate the programmer intent via the type system so it can
> support and enforce it.
>

I agree, having annotations so that the type system can enforce safety is a
better idea than hacking around it with alternate versions of every
function for taking closures only used once.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/9c56a0fb/attachment.html>

From danielmicay at gmail.com  Sat Nov 30 09:03:00 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 30 Nov 2013 12:03:00 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299BCCA.5060707@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<5299BCCA.5060707@gmail.com>
Message-ID: <CA+DvKQJn153V=FDWYS+bnHiV_b+U4NCLgRzCd2ueab5bP3sFTA@mail.gmail.com>

On Sat, Nov 30, 2013 at 5:24 AM, Gy?rgy Andrasek <jurily at gmail.com> wrote:
>
> What really bugs me about `~` is that it conflates the idea of lifetime and
> ownership (which is a zero-cost annotation) with allocation (which is an
> actual expensive operation to stay away from). This wasn't a problem with
> `@`, but it's gone now.
>
> My choice would be to keep `~` in types, but use `new` for allocation:
>
>     let foo: ~Foo = new Foo(bar);

It doesn't conflate these ideas. There's no useful property of `~T` if
you don't need the pointer-size invariant provided by dynamic memory
allocation.

A plain `T` is already owned, wrapping it as `~T` just adds an extra
destructor and makes it the size of a pointer - it has value semantics
either way.

From denis.spir at gmail.com  Sat Nov 30 09:18:36 2013
From: denis.spir at gmail.com (spir)
Date: Sat, 30 Nov 2013 18:18:36 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <5299BCCA.5060707@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<5299BCCA.5060707@gmail.com>
Message-ID: <529A1DEC.5050808@gmail.com>

On 11/30/2013 11:24 AM, Gy?rgy Andrasek wrote:
> On 11/30/2013 09:34 AM, Patrick Walton wrote:
>> IMHO sigils made sense back when there were a couple of ways to allocate
>> that were built into the language and there was no facility for custom
>> smart pointers. Now that we have moved all that stuff into the library,
>> sigils seem to make less sense to me
>
>
> What really bugs me about `~` is that it conflates the idea of lifetime and
> ownership (which is a zero-cost annotation) with allocation (which is an actual
> expensive operation to stay away from). This wasn't a problem with `@`, but it's
> gone now.
>
> My choice would be to keep `~` in types, but use `new` for allocation:
>
>      let foo: ~Foo = new Foo(bar);

Looks quite nice :-) and nicely separates syntax items for "kind of pointing" 
and "watch, runtime mem alloc ahead!". (However, as others have noted, 'new' in 
itself means nothing; for non-C++-ers like myself, a proper term would be better.)

Denis

From danielmicay at gmail.com  Sat Nov 30 09:20:34 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 30 Nov 2013 12:20:34 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A1DEC.5050808@gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<5299BCCA.5060707@gmail.com> <529A1DEC.5050808@gmail.com>
Message-ID: <CA+DvKQKCy0zZQOXXR-JPjGNjGsXzHbPwSxgscdS97gEfFGAkLw@mail.gmail.com>

On Sat, Nov 30, 2013 at 12:18 PM, spir <denis.spir at gmail.com> wrote:
>
> Looks quite nice :-) and nicely separates syntax items for "kind of
> pointing" and "watch, runtime mem alloc ahead!". (However, as others have
> noted, 'new' in itself means nothing; for non-C++-ers like myself, a proper
> term would be better.)
>
> Denis

You would still need an allocation to get any `~T` and in fact it's
*deallocation* that's expensive with most allocators.

From pcwalton at mozilla.com  Sat Nov 30 10:02:06 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 10:02:06 -0800
Subject: [rust-dev] do
In-Reply-To: <CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
Message-ID: <529A281E.2070508@mozilla.com>

On 11/30/13 8:32 AM, Tiffany Bennett wrote:
>
> On Sat, Nov 30, 2013 at 9:34 AM, Oren Ben-Kiki <oren at ben-kiki.org
> <mailto:oren at ben-kiki.org>> wrote:
>
>     That would help a bit, but it would still require the programmer to
>     manually setup and teardown the tuples, pass them to the closure,
>     and so on. We'll also need to change each and every function that
>     takes an action parameter to take the extra tuple in every container
>     or container-like type. And then there's the possibility of
>     modifying variables... It sounds like a lot of effort working around
>     something the compiler can do automatically and actually already
>     does automatically; all it needs is the ability to communicate the
>     programmer intent via the type system so it can support and enforce it.
>
>
> I agree, having annotations so that the type system can enforce safety
> is a better idea than hacking around it with alternate versions of every
> function for taking closures only used once.

You don't need alternate versions: you just need one version that passes 
arguments through.

I don't agree in general that the right solution for every problem that 
can be solved through the type system is in the type system. Every type 
system feature has a cost; when something can be done via what's already 
present in the language then it becomes difficult to justify adding more 
features to what is already a quite complex type system by industry 
standards.

Patrick

From pcwalton at mozilla.com  Sat Nov 30 10:05:17 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 10:05:17 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhsL1RG4GHFDMnOyRRQh-0BtrmYajMOgoW_D2x9Cj6zQtA@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<20612104-0833-48af-9891-32a364be4c0f@email.android.com>
	<CADJiDhsL1RG4GHFDMnOyRRQh-0BtrmYajMOgoW_D2x9Cj6zQtA@mail.gmail.com>
Message-ID: <529A28DD.3020305@mozilla.com>

On 11/30/13 3:25 AM, Oren Ben-Kiki wrote:
> Once stack functions have nothing to do with RAII. It is about container
> manipulation methods. Consider the mangle function of a hashmap for
> example. It makes perfect sense to be able to access a borrowed pointer
> and also consume an owned pointer inside the mangle actions. This is
> currently impossible "just because".

You can use the "with" pattern, as discussed elsewhere in the thread.

> But it is as common to have a container that invokes a
> function exactly once on one specific member (as another example,
> basically any function of the Option type that invokes an action).

That doesn't work if `Option` is to actually implement the container 
traits, since it has to have the same signature. And if it doesn't 
implement those traits, the "with" pattern works.

Patrick


From me at kevincantu.org  Sat Nov 30 10:05:59 2013
From: me at kevincantu.org (Kevin Cantu)
Date: Sat, 30 Nov 2013 10:05:59 -0800
Subject: [rust-dev] do
In-Reply-To: <529A281E.2070508@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
Message-ID: <CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>

While we're changing this stuff, I'd like to see lambdas allow return, now
that the need for forbidding that is gone, IIRC.  That's more likely to
continually trip me up than unusual allocation mechanisms.

Kevin
On Nov 30, 2013 10:02 AM, "Patrick Walton" <pcwalton at mozilla.com> wrote:

> On 11/30/13 8:32 AM, Tiffany Bennett wrote:
>
>>
>> On Sat, Nov 30, 2013 at 9:34 AM, Oren Ben-Kiki <oren at ben-kiki.org
>> <mailto:oren at ben-kiki.org>> wrote:
>>
>>     That would help a bit, but it would still require the programmer to
>>     manually setup and teardown the tuples, pass them to the closure,
>>     and so on. We'll also need to change each and every function that
>>     takes an action parameter to take the extra tuple in every container
>>     or container-like type. And then there's the possibility of
>>     modifying variables... It sounds like a lot of effort working around
>>     something the compiler can do automatically and actually already
>>     does automatically; all it needs is the ability to communicate the
>>     programmer intent via the type system so it can support and enforce
>> it.
>>
>>
>> I agree, having annotations so that the type system can enforce safety
>> is a better idea than hacking around it with alternate versions of every
>> function for taking closures only used once.
>>
>
> You don't need alternate versions: you just need one version that passes
> arguments through.
>
> I don't agree in general that the right solution for every problem that
> can be solved through the type system is in the type system. Every type
> system feature has a cost; when something can be done via what's already
> present in the language then it becomes difficult to justify adding more
> features to what is already a quite complex type system by industry
> standards.
>
> Patrick
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/69fbe7df/attachment.html>

From pcwalton at mozilla.com  Sat Nov 30 10:20:03 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 10:20:03 -0800
Subject: [rust-dev] do
In-Reply-To: <CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
Message-ID: <529A2C53.90001@mozilla.com>

On 11/30/13 10:05 AM, Kevin Cantu wrote:
> While we're changing this stuff, I'd like to see lambdas allow return,
> now that the need for forbidding that is gone, IIRC.  That's more likely
> to continually trip me up than unusual allocation mechanisms.

No objections here.

Patrick


From ptalbot at hyc.io  Sat Nov 30 10:41:56 2013
From: ptalbot at hyc.io (Pierre Talbot)
Date: Sat, 30 Nov 2013 19:41:56 +0100
Subject: [rust-dev] Ideas of small projects or improvements
Message-ID: <529A3174.8060701@hyc.io>

Hello folks,

I'm a French student finishing his study this year and a teacher gave us 
a project to finish by the end of the year which is to modify (or add) a 
small feature to an existing interpreter (or compiler, language,...) 
such as a primitive or a control structure.
I'm pretty new to Rust and I wonder if you have some ideas, some works 
that could possibly be useful to Rust, even if extremely small. My 
objective is to get into Rust with this homework and then work further 
on Rust later.
I can guess how much is hard to understand a compiler and start working 
on it, and that's basically why I'm asking you for an idea. I already 
worked on open-source projects (mainly in C++) so I don't have much 
"outside lessons" to take (such as learning git).

Do you have suggestions that could fit well for this kind of project?

Best regards,
Pierre Talbot.

From jurily at gmail.com  Sat Nov 30 10:59:03 2013
From: jurily at gmail.com (=?ISO-8859-1?Q?Gy=F6rgy_Andrasek?=)
Date: Sat, 30 Nov 2013 19:59:03 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529A3174.8060701@hyc.io>
References: <529A3174.8060701@hyc.io>
Message-ID: <529A3577.4000601@gmail.com>

On 11/30/2013 07:41 PM, Pierre Talbot wrote:
> Do you have suggestions that could fit well for this kind of project?

Make the following code compile:

```
fn foo() {
   bar()
   fn bar() {}
}
```

i.e. allow nested function declarations after a semicolonless return 
expression.

From gaetan at xeberon.net  Sat Nov 30 11:17:46 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 30 Nov 2013 20:17:46 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529A3577.4000601@gmail.com>
References: <529A3174.8060701@hyc.io>
	<529A3577.4000601@gmail.com>
Message-ID: <CANK7tAGsG=Ucp0PX8bYz_2=omRhjjMvGgzwkcjaS71B3R2VMSw@mail.gmail.com>

Is is possible to get rid of this returnless return?

I mean, it is really hard yo read, why not enforcing the use of return
statement, always?
Le 30 nov. 2013 19:59, "Gy?rgy Andrasek" <jurily at gmail.com> a ?crit :

> On 11/30/2013 07:41 PM, Pierre Talbot wrote:
>
>> Do you have suggestions that could fit well for this kind of project?
>>
>
> Make the following code compile:
>
> ```
> fn foo() {
>   bar()
>   fn bar() {}
> }
> ```
>
> i.e. allow nested function declarations after a semicolonless return
> expression.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/d1f260ff/attachment-0001.html>

From ben.striegel at gmail.com  Sat Nov 30 11:20:04 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 14:20:04 -0500
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CANK7tAGsG=Ucp0PX8bYz_2=omRhjjMvGgzwkcjaS71B3R2VMSw@mail.gmail.com>
References: <529A3174.8060701@hyc.io> <529A3577.4000601@gmail.com>
	<CANK7tAGsG=Ucp0PX8bYz_2=omRhjjMvGgzwkcjaS71B3R2VMSw@mail.gmail.com>
Message-ID: <CAAvrL-=tFE272N-9VsFV5w0-p22j84jZ-PQ5kwYEid0bcnP3ow@mail.gmail.com>

> Is is possible to get rid of this returnless return?
> I mean, it is really hard yo read, why not enforcing the use of return
statement, always?

This isn't the point of this thread, and also I don't think anybody is
willing to revisit this issue. Consider that ship as having sailed beyond
the horizon.


On Sat, Nov 30, 2013 at 2:17 PM, Gaetan <gaetan at xeberon.net> wrote:

> Is is possible to get rid of this returnless return?
>
> I mean, it is really hard yo read, why not enforcing the use of return
> statement, always?
> Le 30 nov. 2013 19:59, "Gy?rgy Andrasek" <jurily at gmail.com> a ?crit :
>
> On 11/30/2013 07:41 PM, Pierre Talbot wrote:
>>
>>> Do you have suggestions that could fit well for this kind of project?
>>>
>>
>> Make the following code compile:
>>
>> ```
>> fn foo() {
>>   bar()
>>   fn bar() {}
>> }
>> ```
>>
>> i.e. allow nested function declarations after a semicolonless return
>> expression.
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/65bca091/attachment.html>

From hatahet at gmail.com  Sat Nov 30 11:20:27 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 30 Nov 2013 11:20:27 -0800
Subject: [rust-dev] do
In-Reply-To: <529A2C53.90001@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
Message-ID: <CAN1rdEyv35-KbcQVogR8yK5ZaOJ7xyvi1hhZx_1-RvAcJSFuEg@mail.gmail.com>

Should an issue for this be filed then?

--
Ziad


On Sat, Nov 30, 2013 at 10:20 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 10:05 AM, Kevin Cantu wrote:
>
>> While we're changing this stuff, I'd like to see lambdas allow return,
>> now that the need for forbidding that is gone, IIRC.  That's more likely
>> to continually trip me up than unusual allocation mechanisms.
>>
>
> No objections here.
>
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/c7493848/attachment.html>

From ben.striegel at gmail.com  Sat Nov 30 11:24:23 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 14:24:23 -0500
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <529A3174.8060701@hyc.io>
References: <529A3174.8060701@hyc.io>
Message-ID: <CAAvrL-mWw+GYKa1Han4gdPhwcE2epqQ8d2Wmw1x3DRk9aOLtZQ@mail.gmail.com>

Currently our `for` loops are implemented strangely. In essence, right now
a `for` loop is just syntax sugar that gets expanded during the parsing
stage. This was easy to implement, but it means that our error messages
around `for` loops are strange and it limits our ability to do more
intelligent things, like so:

    for i in [1,2,3] {  // currently we can't do this, you need to write
out `[1,2,3].iter()`

If you could implement `for` loops in the "proper" way, it would be a great
boon to us. However, I'm not the one who really knows exactly what the
"proper" way is. :) And I wasn't able to find an issue in the bug tracker
for this with any details. Perhaps Daniel Micay (strcat) could elaborate.


On Sat, Nov 30, 2013 at 1:41 PM, Pierre Talbot <ptalbot at hyc.io> wrote:

> Hello folks,
>
> I'm a French student finishing his study this year and a teacher gave us a
> project to finish by the end of the year which is to modify (or add) a
> small feature to an existing interpreter (or compiler, language,...) such
> as a primitive or a control structure.
> I'm pretty new to Rust and I wonder if you have some ideas, some works
> that could possibly be useful to Rust, even if extremely small. My
> objective is to get into Rust with this homework and then work further on
> Rust later.
> I can guess how much is hard to understand a compiler and start working on
> it, and that's basically why I'm asking you for an idea. I already worked
> on open-source projects (mainly in C++) so I don't have much "outside
> lessons" to take (such as learning git).
>
> Do you have suggestions that could fit well for this kind of project?
>
> Best regards,
> Pierre Talbot.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/c096e78f/attachment.html>

From kevin at sb.org  Sat Nov 30 11:38:30 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 11:38:30 -0800
Subject: [rust-dev] do
In-Reply-To: <529A281E.2070508@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
Message-ID: <4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>

On Nov 30, 2013, at 10:02 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> I don't agree in general that the right solution for every problem that can be solved through the type system is in the type system. Every type system feature has a cost; when something can be done via what's already present in the language then it becomes difficult to justify adding more features to what is already a quite complex type system by industry standards.

The problem here is that the type system already understands the idea of a `once` fn, it just has an artificial limitation that means it can only apply that to a heap closure and not a stack closure.

-Kevin

From kevin at sb.org  Sat Nov 30 11:40:14 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 11:40:14 -0800
Subject: [rust-dev] do
In-Reply-To: <529A2C53.90001@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
Message-ID: <6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>

On Nov 30, 2013, at 10:20 AM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/30/13 10:05 AM, Kevin Cantu wrote:
>> While we're changing this stuff, I'd like to see lambdas allow return,
>> now that the need for forbidding that is gone, IIRC.  That's more likely
>> to continually trip me up than unusual allocation mechanisms.
> 
> No objections here.

Quite a while ago the restriction on `return` was explained to me as conforming to some principle (I forget the name, sadly) that basically says that wrapping a block of code in a closure and immediately calling the closure should not change the semantics of the code. Basically, `return` shouldn't return from the lambda because that's not what it would do if the closure was inlined manually.

I didn't really understand the point of this, of course.

-Kevin

From oren at ben-kiki.org  Sat Nov 30 12:04:50 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 30 Nov 2013 22:04:50 +0200
Subject: [rust-dev] do
In-Reply-To: <6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
Message-ID: <CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>

Just to mention in passing - there's a related principle that converting a
block to a closure shouldn't change its semantics. This obviously doesn't
fully work because of return/break/continue; that said, if a block without
such flow control constructs is wrapped into a closure, you'd expect it to
just work. It doesn't, because to work it would have to be a
once-called-stack-allocated lambda, which Rust doesn't have (I don't get
the reason for that either :-)

On Sat, Nov 30, 2013 at 9:40 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Nov 30, 2013, at 10:20 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
> > On 11/30/13 10:05 AM, Kevin Cantu wrote:
> >> While we're changing this stuff, I'd like to see lambdas allow return,
> >> now that the need for forbidding that is gone, IIRC.  That's more likely
> >> to continually trip me up than unusual allocation mechanisms.
> >
> > No objections here.
>
> Quite a while ago the restriction on `return` was explained to me as
> conforming to some principle (I forget the name, sadly) that basically says
> that wrapping a block of code in a closure and immediately calling the
> closure should not change the semantics of the code. Basically, `return`
> shouldn't return from the lambda because that's not what it would do if the
> closure was inlined manually.
>
> I didn't really understand the point of this, of course.
>
> -Kevin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/77002ff0/attachment.html>

From ben.striegel at gmail.com  Sat Nov 30 12:14:54 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 15:14:54 -0500
Subject: [rust-dev] do
In-Reply-To: <6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
Message-ID: <CAAvrL-=s7QyHLbK-KTOUDrAjhPG_Lq7dnmMm5Xhkon_WKNa90Q@mail.gmail.com>

> (I forget the name, sadly)

This is usually referred to as Tennet's Correspondence Principle:

http://gafter.blogspot.com/2006/08/tennents-correspondence-principle-and.html

...though it is sometimes debated whether or not the modern interpretation
of this principle is actually what Tennet intended (the book in which it
appeared is apparently quite hard to get a hold of).


On Sat, Nov 30, 2013 at 2:40 PM, Kevin Ballard <kevin at sb.org> wrote:

> On Nov 30, 2013, at 10:20 AM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
> > On 11/30/13 10:05 AM, Kevin Cantu wrote:
> >> While we're changing this stuff, I'd like to see lambdas allow return,
> >> now that the need for forbidding that is gone, IIRC.  That's more likely
> >> to continually trip me up than unusual allocation mechanisms.
> >
> > No objections here.
>
> Quite a while ago the restriction on `return` was explained to me as
> conforming to some principle (I forget the name, sadly) that basically says
> that wrapping a block of code in a closure and immediately calling the
> closure should not change the semantics of the code. Basically, `return`
> shouldn't return from the lambda because that's not what it would do if the
> closure was inlined manually.
>
> I didn't really understand the point of this, of course.
>
> -Kevin
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/55ab117d/attachment.html>

From pcwalton at mozilla.com  Sat Nov 30 13:17:39 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:17:39 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
Message-ID: <529A55F3.1070205@mozilla.com>

On 11/30/13 1:01 AM, Kevin Ballard wrote:
> Is consistency with C++ really so important as to break what is now a
> pretty strong library convention?

We've broken conventions so much in the past. I don't think backwards 
compatibility is a concern yet.

> Especially since the replacement
> convention, as seen in PR #10697, is pretty bad (namely, using ::init()
> instead of ::new(); init() to me seems as though it should merely
> initialize a value, not construct a new value. Heck, the old Path
> convention of using Path(..) is better than Path::init(..)). As I've
> been arguing, `new` is not inherently self-documenting, and the
> confusion around ~ can be solved with proper documentation (just as a
> C++ programmer needs to be taught that `new` is the allocation operator,
> a Rust programmer would be taught that ~ is the allocation operator).

That was the justification for sigils, but it hasn't worked so far. I've 
seen many people trying Rust get stuck on the sigils and move to other 
languages.

> As
> for placement new, while it needs to be supported in some fashion, it's
> going to be used pretty rarely, such that I don't think it's worth
> reserving a keyword just for that.

Placement new is not going to be used rarely. In Servo, for example, 
it's used all over the place.

> We've been moving stuff from the language into the libraries, yes. But
> losing ~ seems like losing a big part of the "flavor" of Rust, so to
> speak.

That "flavor" is much of the reason for Rust's reputation as an overly 
complex language.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 13:23:07 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:23:07 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
Message-ID: <529A573B.60005@mozilla.com>

On 11/30/13 6:34 AM, Oren Ben-Kiki wrote:
> That would help a bit, but it would still require the programmer to
> manually setup and teardown the tuples, pass them to the closure, and so
> on. We'll also need to change each and every function that takes an
> action parameter to take the extra tuple in every container or
> container-like type.

As I mentioned before, most of those in the library can be turned into 
RAII. (I made informal measurements of the number of them that could be 
RAII-ified when I was removing "do"; the vast majority would be better 
as RAII.) Some of those that can't are generic container traits that 
wouldn't benefit from `once fn` anyway. For the remainder, adding the 
tuples doesn't seem much of a burden to me.

If it is, we can always add `once fn` if we have to, but we haven't 
really tried not having it.

> And then there's the possibility of modifying
> variables...

Can you elaborate? You can already use "mut" on individual pattern 
bindings, including individual elements of destructured tuples.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 13:26:42 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:26:42 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A55F3.1070205@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com>
Message-ID: <529A5812.1080106@mozilla.com>

On 11/30/13 1:17 PM, Patrick Walton wrote:
>> Especially since the replacement
>> convention, as seen in PR #10697, is pretty bad (namely, using ::init()
>> instead of ::new(); init() to me seems as though it should merely
>> initialize a value, not construct a new value. Heck, the old Path
>> convention of using Path(..) is better than Path::init(..)).

Honestly, I'm not in love with `init` either. I don't find it 
particularly intuitive, and alternatives are welcome. But I do think 
that using a sigil for allocation and the lack of placement new are 
problems that needs fixing.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 13:28:11 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:28:11 -0800
Subject: [rust-dev] do
In-Reply-To: <4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>
Message-ID: <529A586B.5050204@mozilla.com>

On 11/30/13 11:38 AM, Kevin Ballard wrote:
> The problem here is that the type system already understands the idea
> of a `once` fn, it just has an artificial limitation that means it
> can only apply that to a heap closure and not a stack closure.

No, it's merged with the idea of a heap/stack closure. Separating them 
out into separate axes would increase type system complexity.

Patrick


From gaetan at xeberon.net  Sat Nov 30 13:32:44 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 30 Nov 2013 22:32:44 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A5812.1080106@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com> <529A5812.1080106@mozilla.com>
Message-ID: <CANK7tAEHZwZh8Q1wVshciiLUwZqPxWMdk8XrcwK0y0VimJ-j+w@mail.gmail.com>

Cannot this allocations be implicit to avoid sigils everywhere?
Le 30 nov. 2013 22:26, "Patrick Walton" <pcwalton at mozilla.com> a ?crit :

> On 11/30/13 1:17 PM, Patrick Walton wrote:
>
>> Especially since the replacement
>>> convention, as seen in PR #10697, is pretty bad (namely, using ::init()
>>> instead of ::new(); init() to me seems as though it should merely
>>> initialize a value, not construct a new value. Heck, the old Path
>>> convention of using Path(..) is better than Path::init(..)).
>>>
>>
> Honestly, I'm not in love with `init` either. I don't find it particularly
> intuitive, and alternatives are welcome. But I do think that using a sigil
> for allocation and the lack of placement new are problems that needs fixing.
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/221607f0/attachment-0001.html>

From gaetan at xeberon.net  Sat Nov 30 13:34:14 2013
From: gaetan at xeberon.net (Gaetan)
Date: Sat, 30 Nov 2013 22:34:14 +0100
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CAAvrL-=tFE272N-9VsFV5w0-p22j84jZ-PQ5kwYEid0bcnP3ow@mail.gmail.com>
References: <529A3174.8060701@hyc.io> <529A3577.4000601@gmail.com>
	<CANK7tAGsG=Ucp0PX8bYz_2=omRhjjMvGgzwkcjaS71B3R2VMSw@mail.gmail.com>
	<CAAvrL-=tFE272N-9VsFV5w0-p22j84jZ-PQ5kwYEid0bcnP3ow@mail.gmail.com>
Message-ID: <CANK7tAFte2K0Pw5_z+4TaGbgZx-rRcYvg_NQCCXJYqKxqHzeGg@mail.gmail.com>

Sorry for this offtopic subject..
Le 30 nov. 2013 20:20, "Benjamin Striegel" <ben.striegel at gmail.com> a ?crit
:

> > Is is possible to get rid of this returnless return?
> > I mean, it is really hard yo read, why not enforcing the use of return
> statement, always?
>
> This isn't the point of this thread, and also I don't think anybody is
> willing to revisit this issue. Consider that ship as having sailed beyond
> the horizon.
>
>
> On Sat, Nov 30, 2013 at 2:17 PM, Gaetan <gaetan at xeberon.net> wrote:
>
>> Is is possible to get rid of this returnless return?
>>
>> I mean, it is really hard yo read, why not enforcing the use of return
>> statement, always?
>> Le 30 nov. 2013 19:59, "Gy?rgy Andrasek" <jurily at gmail.com> a ?crit :
>>
>> On 11/30/2013 07:41 PM, Pierre Talbot wrote:
>>>
>>>> Do you have suggestions that could fit well for this kind of project?
>>>>
>>>
>>> Make the following code compile:
>>>
>>> ```
>>> fn foo() {
>>>   bar()
>>>   fn bar() {}
>>> }
>>> ```
>>>
>>> i.e. allow nested function declarations after a semicolonless return
>>> expression.
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/6baffdf2/attachment.html>

From pcwalton at mozilla.com  Sat Nov 30 13:49:20 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:49:20 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CANK7tAEHZwZh8Q1wVshciiLUwZqPxWMdk8XrcwK0y0VimJ-j+w@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<529A55F3.1070205@mozilla.com>	<529A5812.1080106@mozilla.com>
	<CANK7tAEHZwZh8Q1wVshciiLUwZqPxWMdk8XrcwK0y0VimJ-j+w@mail.gmail.com>
Message-ID: <529A5D60.8060705@mozilla.com>

On 11/30/13 1:32 PM, Gaetan wrote:
> Cannot this allocations be implicit to avoid sigils everywhere?

Coercions between `T` and `Smaht<T>` would make it really hard to see 
where you're allocating.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 13:50:12 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:50:12 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>	<529A281E.2070508@mozilla.com>	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>	<529A2C53.90001@mozilla.com>	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
	<CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
Message-ID: <529A5D94.6090901@mozilla.com>

On 11/30/13 12:04 PM, Oren Ben-Kiki wrote:
> Just to mention in passing - there's a related principle that converting
> a block to a closure shouldn't change its semantics. This obviously
> doesn't fully work because of return/break/continue; that said, if a
> block without such flow control constructs is wrapped into a closure,
> you'd expect it to just work. It doesn't, because to work it would have
> to be a once-called-stack-allocated lambda, which Rust doesn't have (I
> don't get the reason for that either :-)

If you decompose into a lambda plus the tupled set of upvars which it's 
moving out of, then this respects TCP.

Patrick


From oren at ben-kiki.org  Sat Nov 30 13:54:07 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sat, 30 Nov 2013 23:54:07 +0200
Subject: [rust-dev] do
In-Reply-To: <529A586B.5050204@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>
	<529A586B.5050204@mozilla.com>
Message-ID: <CADJiDhsggF8WK+cw-8dgj85akYz8XF+nNU0Wy8rV2k7jZVM56w@mail.gmail.com>

There were several threads about this,
https://mail.mozilla.org/pipermail/rust-dev/2013-October/006105.html for
example. I don't see how that code can be converted to RAII at all. Sure it
can be done with cells, or possibly with tuples (though, well, doing this
_manually_? <<shudder>>). It really just begs for
stack-allocated-once-closures.


On Sat, Nov 30, 2013 at 11:28 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 11:38 AM, Kevin Ballard wrote:
>
>> The problem here is that the type system already understands the idea
>> of a `once` fn, it just has an artificial limitation that means it
>> can only apply that to a heap closure and not a stack closure.
>>
>
> No, it's merged with the idea of a heap/stack closure. Separating them out
> into separate axes would increase type system complexity.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/ce8d32c6/attachment.html>

From pcwalton at mozilla.com  Sat Nov 30 13:54:44 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:54:44 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
Message-ID: <529A5EA4.6050607@mozilla.com>

On 11/30/13 1:24 AM, Kevin Ballard wrote:
> Speaking of `new (x + y)`, has any thought been given to
differentiating `new (expr)` from placement-new?

Yeah, this came up. We can just define new followed by `(` to resolve in 
favor of placement new.

> Given all this, my inclination at this point is to say that trying
> to
piggyback on C++ programmers' familiarity of `new` is actually a really
bad idea, as Rust's allocation operator differs in a few important ways
from C++. In fact, offhand I can't think of any language with a `new
`operator that uses it for something other than invoking a class
constructor.

Well, there aren't many languages with allocation operators period: the 
vast majority of languages implicitly allocate on the heap. Of those 
languages with an allocation operator that isn't a function, it's 
universally `new` as far as I know.

The other suggestion that's been floated that satisfies all of these 
constraints is `alloc`, and honestly, if `new` is that unpopular maybe 
we should just switch to that. It's not that I'm unconcerned about 
`new()(1 + 2)` being weird: it's that I'm more concerned about what's 
not going to make C++ programmers run away.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 13:57:10 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 13:57:10 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhsggF8WK+cw-8dgj85akYz8XF+nNU0Wy8rV2k7jZVM56w@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<1385821232.12948.12.camel@vigil>	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>	<529A281E.2070508@mozilla.com>	<4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>	<529A586B.5050204@mozilla.com>
	<CADJiDhsggF8WK+cw-8dgj85akYz8XF+nNU0Wy8rV2k7jZVM56w@mail.gmail.com>
Message-ID: <529A5F36.3040709@mozilla.com>

On 11/30/13 1:54 PM, Oren Ben-Kiki wrote:
> There were several threads about this,
> https://mail.mozilla.org/pipermail/rust-dev/2013-October/006105.html for
> example. I don't see how that code can be converted to RAII at all. Sure
> it can be done with cells, or possibly with tuples (though, well, doing
> this _manually_? <<shudder>>). It really just begs for
> stack-allocated-once-closures.

Well, the functions `attempt_1` and `attempt_2` in that message don't do 
anything, so there isn't anything to convert. Do you have other specific 
common examples of functions that can't be converted to RAII?

`mangle` is one. `Option::map` and friends are another. Are there others?

Patrick


From oren at ben-kiki.org  Sat Nov 30 14:03:06 2013
From: oren at ben-kiki.org (Oren Ben-Kiki)
Date: Sun, 1 Dec 2013 00:03:06 +0200
Subject: [rust-dev] do
In-Reply-To: <529A5F36.3040709@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<4791A70A-0458-4A42-A80F-763FD5390F3F@sb.org>
	<529A586B.5050204@mozilla.com>
	<CADJiDhsggF8WK+cw-8dgj85akYz8XF+nNU0Wy8rV2k7jZVM56w@mail.gmail.com>
	<529A5F36.3040709@mozilla.com>
Message-ID: <CADJiDhvBLdU1rwL6OGK4zBsSGf1Dtn0vePsRmYh6OeScn7zPfw@mail.gmail.com>

Like I said, this is a boiled-down example of the essence of the problem.
Yes, the hashmap mangle is an example, and the option map, and similar
standard container methods, and quite a few similar functions in my own
specific container classes (contrary to popular opinion, in non-trivial
projects people do end up writing their own specialized containers...). In
general the problem is "I am a container, give me a function to modify some
piece of me" combined with an invoker that says "do the following to modify
some piece of the container, accessing and updating all sort of variables".
It is a pretty significant use case, which seems to have nothing to do with
RAII, and bugs me a lot in my code.


On Sat, Nov 30, 2013 at 11:57 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 1:54 PM, Oren Ben-Kiki wrote:
>
>> There were several threads about this,
>> https://mail.mozilla.org/pipermail/rust-dev/2013-October/006105.html for
>> example. I don't see how that code can be converted to RAII at all. Sure
>> it can be done with cells, or possibly with tuples (though, well, doing
>> this _manually_? <<shudder>>). It really just begs for
>> stack-allocated-once-closures.
>>
>
> Well, the functions `attempt_1` and `attempt_2` in that message don't do
> anything, so there isn't anything to convert. Do you have other specific
> common examples of functions that can't be converted to RAII?
>
> `mangle` is one. `Option::map` and friends are another. Are there others?
>
> Patrick
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/9ad470c0/attachment-0001.html>

From hatahet at gmail.com  Sat Nov 30 14:16:13 2013
From: hatahet at gmail.com (Ziad Hatahet)
Date: Sat, 30 Nov 2013 14:16:13 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A5EA4.6050607@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
Message-ID: <CAN1rdEyMyV+jmxuKpgbZC_dJOKDLf8PuAxvG51CwSaUigwXmyg@mail.gmail.com>

On Sat, Nov 30, 2013 at 1:54 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> The other suggestion that's been floated that satisfies all of these
> constraints is `alloc`, and honestly, if `new` is that unpopular maybe we
> should just switch to that. It's not that I'm unconcerned about `new()(1 +
> 2)` being weird: it's that I'm more concerned about what's not going to
> make C++ programmers run away.
>
> Patrick



+1 for `alloc`. It is straightforward and to the point. Another important
(IMO) advantage is that we would be able to use `new()` as a method name,
instead of `init()`, which is very confusing, and conveys the wrong meaning.

--
Ziad
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/7ad9a1d5/attachment.html>

From pwalton at mozilla.com  Sat Nov 30 14:21:48 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 14:21:48 -0800
Subject: [rust-dev] do
In-Reply-To: <529A5D94.6090901@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<1385821232.12948.12.camel@vigil>
	<CADJiDhsNZ=9SckJeC8En6G5DDqqK-_uSa5cWEEb6Qet2erBpsg@mail.gmail.com>
	<CAKBOV9kjX=kb2k707myGY1kvCcU-n+ArO6dgrTVpFPC1cT_NVg@mail.gmail.com>
	<529A281E.2070508@mozilla.com>
	<CABq6+aeD9ZB_5N5fQFi-8zMZ_pSi3i+wYGaBGsCYDJ1_0wg6iQ@mail.gmail.com>
	<529A2C53.90001@mozilla.com>
	<6D2F0314-68F4-4AA9-BE83-7F00F35E569E@sb.org>
	<CADJiDhsDsCqmSdJ_DerFbuVt7KMfDd0sc8PMQqwfSXz9Z3SiFw@mail.gmail.com>
	<529A5D94.6090901@mozilla.com>
Message-ID: <3f2ecdb6-e0f5-43b0-85bf-81a1d4c2cb5f@email.android.com>

It's also not clear to me how "&once fn" can decompose into a trait in the future. The goal in the future is to make "fn()" a type of trait, to allow for C++-like zero-indirection closures. The different types of functions that we have today correspond to different "self" parameters: "|A|->B" corresponds to "&mut self" and "proc()" corresponds to "~self". But I don't see where "&once fn" fits in.

Perhaps the right thing is to gate "&once fn" on by-value anonymous closures. I think once functions may be able to be made to work as function trait bounds. But implementing "&once fn" right now seems to close off our ability to have closures with the same efficiency as C++11 in the future, unless there's something I'm missing.

Patrick 

Patrick Walton <pcwalton at mozilla.com> wrote:
>On 11/30/13 12:04 PM, Oren Ben-Kiki wrote:
>> Just to mention in passing - there's a related principle that
>converting
>> a block to a closure shouldn't change its semantics. This obviously
>> doesn't fully work because of return/break/continue; that said, if a
>> block without such flow control constructs is wrapped into a closure,
>> you'd expect it to just work. It doesn't, because to work it would
>have
>> to be a once-called-stack-allocated lambda, which Rust doesn't have
>(I
>> don't get the reason for that either :-)
>
>If you decompose into a lambda plus the tupled set of upvars which it's
>
>moving out of, then this respects TCP.
>
>Patrick
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/76d9e43a/attachment.html>

From ohler at gnu.org  Sat Nov 30 14:22:51 2013
From: ohler at gnu.org (Christian Ohler)
Date: Sat, 30 Nov 2013 14:22:51 -0800
Subject: [rust-dev] Error casting to trait: "value may contain borrowed
	pointers"
Message-ID: <CAPzKZDw5YXTxTYkJNvVHrdb4norENAEObPBxtdOx=N8MCw+HKA@mail.gmail.com>

Hi all,

I'm trying to learn rust and ran into an error message I don't
understand, and would appreciate some help.  This code:

trait T {}

fn f<'a, V: T>(v: &'a V) -> &'a T {
    v as &'a T
}


is rejected with this error message:

trait-cast.rs:4:4: 4:5 error: value may contain borrowed pointers; add
`'static` bound
trait-cast.rs:4     v as &'a T


I'm trying to upcast from V to T so that I can put v in a container of
element type T (in code not shown here).  The suggestion to add a
'static bound doesn't sound like what I'm looking for.

What is the concern about borrowed pointers here?  What would an
implementation of T and a caller of f look like to lead to a safety
problem?

I'm using a version of rust that is a few days old.

Thanks,
Christian.

From illissius at gmail.com  Sat Nov 30 14:26:04 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 30 Nov 2013 23:26:04 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A55F3.1070205@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com>
Message-ID: <CAPNUp0_wjF-47GtW5iLY7hmgPCX=JAJ_cMbhbY2Deywti5HqKQ@mail.gmail.com>

On Sat, Nov 30, 2013 at 10:17 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 1:01 AM, Kevin Ballard wrote:
>
>> As
>> for placement new, while it needs to be supported in some fashion, it's
>> going to be used pretty rarely, such that I don't think it's worth
>> reserving a keyword just for that.
>>
>
> Placement new is not going to be used rarely. In Servo, for example, it's
> used all over the place.


Can that (or even the totality of currently existing Rust code!) be
considered a representative sample? I'm guessing, though I don't have
knowledge, that web browser engines written in C++ also use placement new a
lot. But I'd also think that if you consider all C++ code in existence, you
would find that it's used pretty rarely.

(Of course, C++ /does/ reserve the keyword. But presumably not for the
reason that placement new is super-common.)


>
>
>  We've been moving stuff from the language into the libraries, yes. But
>> losing ~ seems like losing a big part of the "flavor" of Rust, so to
>> speak.
>>
>
> That "flavor" is much of the reason for Rust's reputation as an overly
> complex language.
>

I really like the way current Rust thinks of the various sigils as "just
another constructor". I also like the consistency with other major
languages of `new`, so I'm conflicted. And yes, the constructor-like
property seems unfortunately difficult to extend to third-party smart
pointers... but in general I really don't like the solution to "$thing is
not as convenient with third-party types as with the built-in ones" being
to make it equally inconvenient for the built-in ones. Now you have two
problems.

I think the complexity you mention is an inherent part of the semantics of
Rust. The most intuitive and ergonomic way to expose it to the programmer
is a very important consideration, but you're still not doing more than
pushing the complexity around.

Basically, I'm not sure Rust's reputation as a complex language is
something you could cause to go away in this fashion. If you replace all of
the sigils with explicit `Foo<T>` and `new` syntax, will that make people
see it as less complex?


>
> Patrick
>
> _______________________________________________
>
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/0269dfb9/attachment.html>

From ben.striegel at gmail.com  Sat Nov 30 14:26:04 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 17:26:04 -0500
Subject: [rust-dev] Ideas of small projects or improvements
In-Reply-To: <CANK7tAFte2K0Pw5_z+4TaGbgZx-rRcYvg_NQCCXJYqKxqHzeGg@mail.gmail.com>
References: <529A3174.8060701@hyc.io> <529A3577.4000601@gmail.com>
	<CANK7tAGsG=Ucp0PX8bYz_2=omRhjjMvGgzwkcjaS71B3R2VMSw@mail.gmail.com>
	<CAAvrL-=tFE272N-9VsFV5w0-p22j84jZ-PQ5kwYEid0bcnP3ow@mail.gmail.com>
	<CANK7tAFte2K0Pw5_z+4TaGbgZx-rRcYvg_NQCCXJYqKxqHzeGg@mail.gmail.com>
Message-ID: <CAAvrL-m4N6Ro8oep-=POGMK8XgT7sF+HwkPmtWB-kh4W4jozGg@mail.gmail.com>

It's okay, it's our own fault for not having yet written a document
entitled "Things That Absolutely Will Not Change And That We Are Tired Of
Discussing." :P


On Sat, Nov 30, 2013 at 4:34 PM, Gaetan <gaetan at xeberon.net> wrote:

> Sorry for this offtopic subject..
> Le 30 nov. 2013 20:20, "Benjamin Striegel" <ben.striegel at gmail.com> a
> ?crit :
>
>  > Is is possible to get rid of this returnless return?
>> > I mean, it is really hard yo read, why not enforcing the use of return
>> statement, always?
>>
>> This isn't the point of this thread, and also I don't think anybody is
>> willing to revisit this issue. Consider that ship as having sailed beyond
>> the horizon.
>>
>>
>> On Sat, Nov 30, 2013 at 2:17 PM, Gaetan <gaetan at xeberon.net> wrote:
>>
>>> Is is possible to get rid of this returnless return?
>>>
>>> I mean, it is really hard yo read, why not enforcing the use of return
>>> statement, always?
>>> Le 30 nov. 2013 19:59, "Gy?rgy Andrasek" <jurily at gmail.com> a ?crit :
>>>
>>> On 11/30/2013 07:41 PM, Pierre Talbot wrote:
>>>>
>>>>> Do you have suggestions that could fit well for this kind of project?
>>>>>
>>>>
>>>> Make the following code compile:
>>>>
>>>> ```
>>>> fn foo() {
>>>>   bar()
>>>>   fn bar() {}
>>>> }
>>>> ```
>>>>
>>>> i.e. allow nested function declarations after a semicolonless return
>>>> expression.
>>>> _______________________________________________
>>>> Rust-dev mailing list
>>>> Rust-dev at mozilla.org
>>>> https://mail.mozilla.org/listinfo/rust-dev
>>>>
>>>
>>> _______________________________________________
>>> Rust-dev mailing list
>>> Rust-dev at mozilla.org
>>> https://mail.mozilla.org/listinfo/rust-dev
>>>
>>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/21de218f/attachment-0001.html>

From pwalton at mozilla.com  Sat Nov 30 14:32:16 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 14:32:16 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAPNUp0_wjF-47GtW5iLY7hmgPCX=JAJ_cMbhbY2Deywti5HqKQ@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com>
	<CAPNUp0_wjF-47GtW5iLY7hmgPCX=JAJ_cMbhbY2Deywti5HqKQ@mail.gmail.com>
Message-ID: <87635875-5c54-4cfb-8c62-16a1a9b7d59d@email.android.com>

Presumably Arc, MutexArc, and friends are going to be used with placement new to save one move operation. So basically any Rust program that uses shared memory (except for maybe pure fork-join code) will use placement new. I imagine that's pretty common.

Your conflicted feelings pretty much sum up the way I feel. We're blazing new language design trails here in Rust, and anything we pick is going to feel a bit uncomfortable. I tend to want to err on the side of a little verbosity if it makes the most unfamiliar parts of Rust feel more intuitive. But verbosity must of course be used sparingly...

Patrick

"G?bor Lehel" <illissius at gmail.com> wrote:
>On Sat, Nov 30, 2013 at 10:17 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> On 11/30/13 1:01 AM, Kevin Ballard wrote:
>>
>>> As
>>> for placement new, while it needs to be supported in some fashion,
>it's
>>> going to be used pretty rarely, such that I don't think it's worth
>>> reserving a keyword just for that.
>>>
>>
>> Placement new is not going to be used rarely. In Servo, for example,
>it's
>> used all over the place.
>
>
>Can that (or even the totality of currently existing Rust code!) be
>considered a representative sample? I'm guessing, though I don't have
>knowledge, that web browser engines written in C++ also use placement
>new a
>lot. But I'd also think that if you consider all C++ code in existence,
>you
>would find that it's used pretty rarely.
>
>(Of course, C++ /does/ reserve the keyword. But presumably not for the
>reason that placement new is super-common.)
>
>
>>
>>
>>  We've been moving stuff from the language into the libraries, yes.
>But
>>> losing ~ seems like losing a big part of the "flavor" of Rust, so to
>>> speak.
>>>
>>
>> That "flavor" is much of the reason for Rust's reputation as an
>overly
>> complex language.
>>
>
>I really like the way current Rust thinks of the various sigils as
>"just
>another constructor". I also like the consistency with other major
>languages of `new`, so I'm conflicted. And yes, the constructor-like
>property seems unfortunately difficult to extend to third-party smart
>pointers... but in general I really don't like the solution to "$thing
>is
>not as convenient with third-party types as with the built-in ones"
>being
>to make it equally inconvenient for the built-in ones. Now you have two
>problems.
>
>I think the complexity you mention is an inherent part of the semantics
>of
>Rust. The most intuitive and ergonomic way to expose it to the
>programmer
>is a very important consideration, but you're still not doing more than
>pushing the complexity around.
>
>Basically, I'm not sure Rust's reputation as a complex language is
>something you could cause to go away in this fashion. If you replace
>all of
>the sigils with explicit `Foo<T>` and `new` syntax, will that make
>people
>see it as less complex?
>
>
>>
>> Patrick
>>
>> _______________________________________________
>>
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
>-- 
>Your ship was destroyed in a monadic eruption.

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/816544a9/attachment.html>

From ben.striegel at gmail.com  Sat Nov 30 14:35:56 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sat, 30 Nov 2013 17:35:56 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A5EA4.6050607@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
Message-ID: <CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>

> The other suggestion that's been floated that satisfies all of these
constraints is `alloc`, and honestly, if `new` is that unpopular maybe we
should just switch to that.

I much prefer `new` to `alloc`. It *is* a shame that `foo::new()` has to
change, but `alloc` is much grosser than `init`. And maybe we can think of
a better naming convention for constructors... perhaps `foo::make()`.

Honestly, `new` seems ideal here. Easier to type than `~` and easier on the
eyes than `alloc`. The only argument that I can think of against it would
be if its semantics are different enough from C++ that it would cause more
confusion than it alleviates.


On Sat, Nov 30, 2013 at 4:54 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 1:24 AM, Kevin Ballard wrote:
>
>> Speaking of `new (x + y)`, has any thought been given to
>>
> differentiating `new (expr)` from placement-new?
>
> Yeah, this came up. We can just define new followed by `(` to resolve in
> favor of placement new.
>
>
>  Given all this, my inclination at this point is to say that trying
>> to
>>
> piggyback on C++ programmers' familiarity of `new` is actually a really
> bad idea, as Rust's allocation operator differs in a few important ways
> from C++. In fact, offhand I can't think of any language with a `new
> `operator that uses it for something other than invoking a class
> constructor.
>
> Well, there aren't many languages with allocation operators period: the
> vast majority of languages implicitly allocate on the heap. Of those
> languages with an allocation operator that isn't a function, it's
> universally `new` as far as I know.
>
> The other suggestion that's been floated that satisfies all of these
> constraints is `alloc`, and honestly, if `new` is that unpopular maybe we
> should just switch to that. It's not that I'm unconcerned about `new()(1 +
> 2)` being weird: it's that I'm more concerned about what's not going to
> make C++ programmers run away.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/ea673da9/attachment.html>

From illissius at gmail.com  Sat Nov 30 14:37:03 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 30 Nov 2013 23:37:03 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A5812.1080106@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com> <529A5812.1080106@mozilla.com>
Message-ID: <CAPNUp08qUhs9z4LR2Taa1hg_f3DyJfa=nGA95eaC+B8Dsofu0g@mail.gmail.com>

On Sat, Nov 30, 2013 at 10:26 PM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 1:17 PM, Patrick Walton wrote:
>
>> Especially since the replacement
>>> convention, as seen in PR #10697, is pretty bad (namely, using ::init()
>>> instead of ::new(); init() to me seems as though it should merely
>>> initialize a value, not construct a new value. Heck, the old Path
>>> convention of using Path(..) is better than Path::init(..)).
>>>
>>
> Honestly, I'm not in love with `init` either. I don't find it particularly
> intuitive, and alternatives are welcome. But I do think that using a sigil
> for allocation and the lack of placement new are problems that needs fixing.


Pretty basic question, but: what does placement new in a Rust context even
mean, precisely? The very same thing as in C++?

Because in C++ allocation and placement new are pretty orthogonal. If you
write `new Foo`, it means: allocate memory for a Foo and run its
constructor in that memory. If you write `new (foo) Foo`, it means: *don't*
allocate memory, just construct a Foo directly into `foo`, which is some
existing piece of memory I provide. So while `new` is the allocation
operator, placement new is in fact just a funny syntax for running
constructors. Which I think is confusing as heck.

All of that leading up to: if these are different things, mightn't it make
sense for Rust to use different syntax for them?

(And if placement new in Rust is different from placement new in C++, then
what's the difference?)



>
>
> Patrick
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>



-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/a12e79ab/attachment.html>

From erick.tryzelaar at gmail.com  Sat Nov 30 14:41:15 2013
From: erick.tryzelaar at gmail.com (Erick Tryzelaar)
Date: Sat, 30 Nov 2013 14:41:15 -0800
Subject: [rust-dev] weird code that performs better by calling a closure
 instead of calling a fn directly
Message-ID: <CALdfqQLjFiAHQn3_BENpS=8_6f1xCX9vxVQtmAt7sUfnVRXvJw@mail.gmail.com>

I must be hitting some weird edge case inside Rust or LLVM where I'm right
on the line between inlining or not a block of code. I've been playing
around with the collatz fns from:

http://www.mit.edu/~mtikekar/posts/stream-fusion.html

but I stumbled upon two weird mis-optimizations at --opt-level=2 and
--opt-level=3. It appears that my code is *faster* when I call a function
indirectly through a closure *and* when I call `.clone()` on a uint. Here's
the main snippet of code:

```
fn collatz_next(a: uint) -> uint {
    (if a % 2 == 0 { a } else { 3 * a + 1 }) / 2
}

struct RecursiveIterator<'a> {
    priv value: uint,
    priv f: 'a |uint| -> uint,
}

fn collatz_len_fast(a0: uint) -> uint {
    let mut len = 0;
    let mut iter = RecursiveIterator { value: a0, f: collatz_next };

    loop {
        let a = {
            let value = iter.value;
            let a = iter.value.clone();
            // let a = iter.value;
            iter.value = (iter.f)(a);
            // iter.value = collatz_next(a);
            value
        };

        if a == 1 { break; }
        len += 1;
    }
    len
}
```

If I swap which code is commented out it is 18% slower, but I have no idea
why. Here's my gist that has all the code and my performance numbers:

https://gist.github.com/erickt/7725346

Does anyone have an idea of what's going on here?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/48d325d4/attachment-0001.html>

From pwalton at mozilla.com  Sat Nov 30 14:42:56 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 14:42:56 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAPNUp08qUhs9z4LR2Taa1hg_f3DyJfa=nGA95eaC+B8Dsofu0g@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<529A55F3.1070205@mozilla.com> <529A5812.1080106@mozilla.com>
	<CAPNUp08qUhs9z4LR2Taa1hg_f3DyJfa=nGA95eaC+B8Dsofu0g@mail.gmail.com>
Message-ID: <2130b5ab-d8b4-46da-adcf-9825d0843623@email.android.com>

In Rust "new(place) expr" means "call a special method on 'place' to create room for 'expr', then evaluate 'expr' with its destination set to that newly created location". A full description of "destination" is beyond the scope of this email :) But for function calls in particular, it means the hidden return pointer is set to the newly allocated location.

Patrick

"G?bor Lehel" <illissius at gmail.com> wrote:
>On Sat, Nov 30, 2013 at 10:26 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> On 11/30/13 1:17 PM, Patrick Walton wrote:
>>
>>> Especially since the replacement
>>>> convention, as seen in PR #10697, is pretty bad (namely, using
>::init()
>>>> instead of ::new(); init() to me seems as though it should merely
>>>> initialize a value, not construct a new value. Heck, the old Path
>>>> convention of using Path(..) is better than Path::init(..)).
>>>>
>>>
>> Honestly, I'm not in love with `init` either. I don't find it
>particularly
>> intuitive, and alternatives are welcome. But I do think that using a
>sigil
>> for allocation and the lack of placement new are problems that needs
>fixing.
>
>
>Pretty basic question, but: what does placement new in a Rust context
>even
>mean, precisely? The very same thing as in C++?
>
>Because in C++ allocation and placement new are pretty orthogonal. If
>you
>write `new Foo`, it means: allocate memory for a Foo and run its
>constructor in that memory. If you write `new (foo) Foo`, it means:
>*don't*
>allocate memory, just construct a Foo directly into `foo`, which is
>some
>existing piece of memory I provide. So while `new` is the allocation
>operator, placement new is in fact just a funny syntax for running
>constructors. Which I think is confusing as heck.
>
>All of that leading up to: if these are different things, mightn't it
>make
>sense for Rust to use different syntax for them?
>
>(And if placement new in Rust is different from placement new in C++,
>then
>what's the difference?)
>
>
>
>>
>>
>> Patrick
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>
>-- 
>Your ship was destroyed in a monadic eruption.

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/eed3a933/attachment.html>

From illissius at gmail.com  Sat Nov 30 14:43:53 2013
From: illissius at gmail.com (=?ISO-8859-1?Q?G=E1bor_Lehel?=)
Date: Sat, 30 Nov 2013 23:43:53 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
Message-ID: <CAPNUp09PgKkGLoogHOyyazpVrT3iPe+pwhKW1MCG8sues57BNQ@mail.gmail.com>

On Sat, Nov 30, 2013 at 11:35 PM, Benjamin Striegel
<ben.striegel at gmail.com>wrote:

> > The other suggestion that's been floated that satisfies all of these
> constraints is `alloc`, and honestly, if `new` is that unpopular maybe we
> should just switch to that.
>
> I much prefer `new` to `alloc`. It *is* a shame that `foo::new()` has to
> change, but `alloc` is much grosser than `init`. And maybe we can think of
> a better naming convention for constructors... perhaps `foo::make()`.
>

FWIW, in Objective-C:

    [MyType new] is shorthand for [[MyType alloc] init]

(Not saying we should do the same, just some prior art.)

-- 
Your ship was destroyed in a monadic eruption.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/5a5763a4/attachment.html>

From pwalton at mozilla.com  Sat Nov 30 14:50:50 2013
From: pwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 14:50:50 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
Message-ID: <17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>

Right, I agree with this. Kevin's argument that C++ "new" has different behavior is valid though, and makes me conflicted.

BTW, I was thinking about "make" as well. Go is precedent that both "new" and "make" can coexist (though not without controversy...) Old Rust used to use "mk" as the constructor convention.

Patrick

Benjamin Striegel <ben.striegel at gmail.com> wrote:
>> The other suggestion that's been floated that satisfies all of these
>constraints is `alloc`, and honestly, if `new` is that unpopular maybe
>we
>should just switch to that.
>
>I much prefer `new` to `alloc`. It *is* a shame that `foo::new()` has
>to
>change, but `alloc` is much grosser than `init`. And maybe we can think
>of
>a better naming convention for constructors... perhaps `foo::make()`.
>
>Honestly, `new` seems ideal here. Easier to type than `~` and easier on
>the
>eyes than `alloc`. The only argument that I can think of against it
>would
>be if its semantics are different enough from C++ that it would cause
>more
>confusion than it alleviates.
>
>
>On Sat, Nov 30, 2013 at 4:54 PM, Patrick Walton
><pcwalton at mozilla.com>wrote:
>
>> On 11/30/13 1:24 AM, Kevin Ballard wrote:
>>
>>> Speaking of `new (x + y)`, has any thought been given to
>>>
>> differentiating `new (expr)` from placement-new?
>>
>> Yeah, this came up. We can just define new followed by `(` to resolve
>in
>> favor of placement new.
>>
>>
>>  Given all this, my inclination at this point is to say that trying
>>> to
>>>
>> piggyback on C++ programmers' familiarity of `new` is actually a
>really
>> bad idea, as Rust's allocation operator differs in a few important
>ways
>> from C++. In fact, offhand I can't think of any language with a `new
>> `operator that uses it for something other than invoking a class
>> constructor.
>>
>> Well, there aren't many languages with allocation operators period:
>the
>> vast majority of languages implicitly allocate on the heap. Of those
>> languages with an allocation operator that isn't a function, it's
>> universally `new` as far as I know.
>>
>> The other suggestion that's been floated that satisfies all of these
>> constraints is `alloc`, and honestly, if `new` is that unpopular
>maybe we
>> should just switch to that. It's not that I'm unconcerned about
>`new()(1 +
>> 2)` being weird: it's that I'm more concerned about what's not going
>to
>> make C++ programmers run away.
>>
>> Patrick
>>
>>
>> _______________________________________________
>> Rust-dev mailing list
>> Rust-dev at mozilla.org
>> https://mail.mozilla.org/listinfo/rust-dev
>>
>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Rust-dev mailing list
>Rust-dev at mozilla.org
>https://mail.mozilla.org/listinfo/rust-dev

-- 
Sent from my Android phone with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/68a04582/attachment.html>

From bascule at gmail.com  Sat Nov 30 16:55:41 2013
From: bascule at gmail.com (Tony Arcieri)
Date: Sat, 30 Nov 2013 16:55:41 -0800
Subject: [rust-dev] do
In-Reply-To: <CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
Message-ID: <CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>

On Fri, Nov 29, 2013 at 11:34 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I find `do` syntax form is vital for DSL-ish code.
>

 On Sat, Nov 30, 2013 at 12:26 AM, Patrick Walton <pwalton at mozilla.com>
 wrote:

> The main reason for "do"'s existence is to make task spawning look nice.


I've got to say that the "do" syntax is one of the things that appeals to
me about Rust, and will probably appeal to the people that Steve Klabnik is
drawing to the language with Rust for Rubyists.

It might seem like a small thing but the effects on the type of programs
you can write, it actually has a pretty profound effect, IMO.

-- 
Tony Arcieri
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/9e6126b9/attachment.html>

From florob at babelmonkeys.de  Sat Nov 30 17:51:58 2013
From: florob at babelmonkeys.de (Florian Zeitz)
Date: Sun, 01 Dec 2013 02:51:58 +0100
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
Message-ID: <529A963E.5030101@babelmonkeys.de>

On 30.11.2013 23:50, Patrick Walton wrote:
> Right, I agree with this. Kevin's argument that C++ "new" has different
> behavior is valid though, and makes me conflicted.
> 
> BTW, I was thinking about "make" as well. Go is precedent that both
> "new" and "make" can coexist (though not without controversy...) Old
> Rust used to use "mk" as the constructor convention.
> 
> Patrick
> 

If I may chime in here.
I agree with Kevin that the different semantics of `new` are more likely
to create confusion, than alleviate it.

Personally I would suggest calling this operator `box`, since it "boxes"
its argument into a newly allocated memory box.
After all, these are different semantics from C++'s `new` (and also Go's
`make` AFAICT), therefore, presuming that a sigil is not a sufficient
indicator of a non-stack allocation, using an unprecedented keyword
seems the way to go to me.

Regards,
Florian

From corey at octayn.net  Sat Nov 30 17:54:25 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 30 Nov 2013 20:54:25 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529A963E.5030101@babelmonkeys.de>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
Message-ID: <CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>

On Sat, Nov 30, 2013 at 8:51 PM, Florian Zeitz <florob at babelmonkeys.de> wrote:
> Personally I would suggest calling this operator `box`, since it "boxes"
> its argument into a newly allocated memory box.
>

I really like this proposal. I've watched this thread and the original
`new` proposal with indifference, but `box` really makes sense to me.

From kevin at sb.org  Sat Nov 30 18:30:31 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 18:30:31 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
Message-ID: <372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>

I'm still very much a fan of leaving ~ as the allocation operator. Despite what Patrick says, I'm pretty sure the reason why users are confused about it is purely due to sub-par documentation, and not due to any actual inherent problems with using a non-alphabetic symbol as an operator. Heck, we have plenty of other non-alphabetic operators that don't cause confusion, why is this one special?

That said, of all the alternative proposals, `box` seems the most sensible to me.

-Kevin

On Nov 30, 2013, at 5:54 PM, Corey Richardson <corey at octayn.net> wrote:

> On Sat, Nov 30, 2013 at 8:51 PM, Florian Zeitz <florob at babelmonkeys.de> wrote:
>> Personally I would suggest calling this operator `box`, since it "boxes"
>> its argument into a newly allocated memory box.
>> 
> 
> I really like this proposal. I've watched this thread and the original
> `new` proposal with indifference, but `box` really makes sense to me.
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev


From corey at octayn.net  Sat Nov 30 18:49:22 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 30 Nov 2013 21:49:22 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
Message-ID: <CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>

On Sat, Nov 30, 2013 at 9:30 PM, Kevin Ballard <kevin at sb.org> wrote:
> I'm still very much a fan of leaving ~ as the allocation operator. Despite what Patrick says, I'm pretty sure the reason why users are confused about it is purely due to sub-par documentation, and not due to any actual inherent problems with using a non-alphabetic symbol as an operator. Heck, we have plenty of other non-alphabetic operators that don't cause confusion, why is this one special?
>

I'll admit, I don't find the "confusing" argument very convincing. I
just think `box` looks better than `~`.

From corey at octayn.net  Sat Nov 30 19:01:55 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 30 Nov 2013 22:01:55 -0500
Subject: [rust-dev] This Week in Rust
Message-ID: <CA++BO6RApVJfB6Md12obxnyQSAbOnz_P4hdUKuxGF06MymuDCw@mail.gmail.com>

Welcome to another issue of *This Week in Rust*, a weekly newsletter
summarizing Rust's progress and community activity. As always, if you have
something you'd like to be featured, just [send me an
email](mailto:corey at octayn.net?subject=This Week in Rust Suggestion).

Last week was very slow, but this week more than makes up for it I think!
Static linking landed, and there's been some nice cleanup of error messages
and various APIs.

# What's cooking on master?

59 PRs were merged this week.

## Breaking Changes

- Names of methods creating iterators have [changed
  drastically](https://github.com/mozilla/rust/pull/10622) to remove the
  `_iter` suffix. This reflects that iterators are a primary focus of APIs.
  The PR description has all of the changes summarized.
- We now have [static linking
  support](https://github.com/mozilla/rust/pull/10528)! It does, however,
  involve some changes with how the `link` attribute works. The error messages
  should guide you to the fixes.
- In preparation for the placement new changes, the `Path` constructor has
  been [renamed from `new` to
  `init`](https://github.com/mozilla/rust/pull/10697),.
- Some overly-permissive borrow checking for `&mut &mut` [has been
  fixed](https://github.com/mozilla/rust/pull/10519). This is fairly obscure,
  most code shouldn't have hit it.
- The parser is [more strict](https://github.com/mozilla/rust/pull/10642)
  about what it accepts as a doc comment. Now, only `///` and `/**`  are
  counted as introducing doc comments (previously, `////` and `/***` would
  also introduce a doc comment).
- `std::{uint, int}::{min, max}` [have been
  removed](https://github.com/mozilla/rust/pull/10719). They were identical to
  the functions in `std::cmp`, so use those instead.
- `extra::json` [has been rid of @
  boxes](https://github.com/mozilla/rust/pull/10727), and now uses idiomatic
  constructor names.
- The `type_id` intrinsic [now uses a language item as its return
  value](https://github.com/mozilla/rust/pull/10722).
- Some [cleanup](https://github.com/mozilla/rust/pull/10662) has been done to
  `std::rt::thread`, which is an interface to native threads (rather than
  tasks).
- `do` blocks are [no longer
  allowed](https://github.com/mozilla/rust/pull/10581) in non-`proc` contexts.
  This means that `do` can not be used with a function whose last argument is
  not a `proc`. A fairly large [thread on the mailing
  list](https://mail.mozilla.org/pipermail/rust-dev/2013-November/006999.html)
  is ongoing about this change.
- `LittleLock` now [uses RAII](https://github.com/mozilla/rust/pull/10660).
- C-like enums are [now represented as an
  integer](https://github.com/mozilla/rust/pull/10652) rather than a struct,
  at the LLVM level. This affects ABI.
- Linked failure [has been
  removed](https://github.com/mozilla/rust/pull/10603) from the runtime.
- `extra::term` [no longer uses `@mut
  Writer`](https://github.com/mozilla/rust/pull/10637), instead taking the
  writer to use by value.

## Other changes

- `RefCell<T>`, previously known as `Mut<T>`, [has finally
  landed](https://github.com/mozilla/rust/pull/10514), for all your dynamic
  borrow checking needs.
- A lint for unknown attributes [has finally been
  added](https://github.com/mozilla/rust/pull/10316). The compiler will now
  warn when it sees an attribute it doesn't recognize.
- A lock-free [Chase-Lev
  deque](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf)
  has [been added to the runtime](https://github.com/mozilla/rust/pull/10678).
- The shootout-spectralnorm benchmark [has been
  resurrected](https://github.com/mozilla/rust/pull/10704).
- Unknown feature gates [are now
  linted](https://github.com/mozilla/rust/pull/10680), rather than being a
  hard failure.
- The AST is [now frozen](https://github.com/mozilla/rust/pull/10693)!
- `GenericPort` [now has an
  iterator](https://github.com/mozilla/rust/pull/10688) over the messages it
  receives.
- `NodeId`, `CrateNum`, `Name`, and `Mrk` (types in libsyntax) [have been
  shrunk to 32 bits](https://github.com/mozilla/rust/pull/10670).
- The restriction on macros expanding to a single item [has been
  lifted](https://github.com/mozilla/rust/pull/10649). This obviates the need
  for macros hackily expanding to a module containing the desired items. Do
  note that this only works when the macro is in "item position", or where an
  item is expected. There is an
  [issue](https://github.com/mozilla/rust/issues/10681) open for lifting this
  restriction.
- A `thread_local` attribute [has been
  added](https://github.com/mozilla/rust/pull/10312), which exposes a
  platform's native TLS, a la C11/C++11 `thread_local`.
- Cross compilation to win64 (via mingw-w64) [is now
  supported](https://github.com/mozilla/rust/pull/10578). There were also a
  [bunch of fixes](https://github.com/mozilla/rust/pull/10631) on real win64.
- The parser gives a [better error
  message](https://github.com/mozilla/rust/pull/10641) when it encounters an
  unclosed delimiter it didn't expect.
- There is a [better error
  message](https://github.com/mozilla/rust/pull/10475) when a module name is
  used as a type (the motivating example being `impl SomeTrait for
some_module`).
- JSON decoding [now gives better
  errors](https://github.com/mozilla/rust/pull/10625).
- Linker optimizations are [now
  used](https://github.com/mozilla/rust/pull/10620) on Linux.

## New contributors

Our first-time contributors this week are:

- Andreas Ots
- Eric Biggers
- Jannis Harder
- Kiet Tran

# Weekly Meeting

The [weekly
meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-26)
discussed bootstrap times, the `thread_local` PR, mutexes, and the GC. In
particular, it was decided that we should have nightlies.

# This Week in Servo

Servo is a web browser engine written in Rust and is one of the primary test
cases for the Rust language.

This was a short week due to the US Thanksgiving holiday, but there were still
17 landed PRs this week.

## Notable additions
- Hyunjune Kim and Sammy Kim landed some border style extensions in
  [#1276](http://github.com/mozilla/servo/pull/1322).
- Youngmin Yoo, Seonghyun Kim, and Jaemin Moon landed overflow:hidden in
  [#1298](http://github.com/mozilla/servo/pull/1298).
- Isabelle Carter landed changing the unrendered portion of content to use the
  doc's background color in [#1210](http://github.com/mozilla/servo/pull/1210).
- Patrick Walton has been experimenting with some very promising parallel
  layout work, which he described in a
  [message](https://groups.google.com/forum/#!topic/mozilla.dev.servo/1nKmBvFewIs)
  to the mailing list.

## Meetings

This week's [meeting](https://github.com/mozilla/servo/wiki/Meeting-2013-11-25)
covered the poor situation with Nvidia support on Linux, fleshed out the string
interning plan during CSS selector parsing/matching, and went into some Servo
and Rust-related build issues.

# Announcements etc

Do note that all the links are pulled directly from the
[subreddit](https://reddit.com/r/rust).

- [Matrix Multiply Performance in
Rust](http://www.reddit.com/r/rust/comments/1rf8rz/matrix_multiply_performance_in_rust/)
- [nrays](https://github.com/sebcrozet/nrays) - a 3d/4d raytracer
- [SprocketNES: Practical Systems Programming in
  Rust](https://air.mozilla.org/sprocketnes-practical-systems-programming-in-rust/).
  Contrary to the title, this is actually a recording of the presentations at
  the Bay Area meetup.
- [uutils](https://github.com/uutils/coreutils) - an attempt at writing
  universal (as in cross-platform) CLI utils in Rust
- [lbac](https://github.com/cmr/lets-build-a-compiler) - a Rust port of Jack
  Crenshaw's "Let's Build a Compiler"

From michael.letterle+rust at gmail.com  Sat Nov 30 19:25:45 2013
From: michael.letterle+rust at gmail.com (Michael Letterle)
Date: Sat, 30 Nov 2013 22:25:45 -0500
Subject: [rust-dev] do
In-Reply-To: <CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
Message-ID: <CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>

On Sat, Nov 30, 2013 at 7:55 PM, Tony Arcieri <bascule at gmail.com> wrote:

> On Fri, Nov 29, 2013 at 11:34 PM, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> I find `do` syntax form is vital for DSL-ish code.
>>
>
>  On Sat, Nov 30, 2013 at 12:26 AM, Patrick Walton <pwalton at mozilla.com>
>  wrote:
>
>> The main reason for "do"'s existence is to make task spawning look nice.
>
>
> I've got to say that the "do" syntax is one of the things that appeals to
> me about Rust, and will probably appeal to the people that Steve Klabnik is
> drawing to the language with Rust for Rubyists.
>
> It might seem like a small thing but the effects on the type of programs
> you can write, it actually has a pretty profound effect, IMO.
>
> --
> Tony Arcieri
>
>
I agree actually, I was using do to implement some convenience logic and my
code went from:

    do function { someotherFunction() };

to

    function(|| someotherFunction());

Maybe I'm abusing something here, but I found the first format more
intuitive and elegant...

I know there's rumblings about io conditions going away, but the change
also makes that more awkward... :/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131130/a04abf22/attachment-0001.html>

From pcwalton at mozilla.com  Sat Nov 30 19:28:11 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 19:28:11 -0800
Subject: [rust-dev] do
In-Reply-To: <CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
Message-ID: <529AACCB.9060101@mozilla.com>

On 11/30/13 7:25 PM, Michael Letterle wrote:
>     I've got to say that the "do" syntax is one of the things that
>     appeals to me about Rust, and will probably appeal to the people
>     that Steve Klabnik is drawing to the language with Rust for Rubyists.
>
>     It might seem like a small thing but the effects on the type of
>     programs you can write, it actually has a pretty profound effect, IMO.
>
>     --
>     Tony Arcieri
>
>
> I agree actually, I was using do to implement some convenience logic and
> my code went from:
>
>      do function { someotherFunction() };
>
> to
>
>      function(|| someotherFunction());
>
> Maybe I'm abusing something here, but I found the first format more
> intuitive and elegant...
>
> I know there's rumblings about io conditions going away, but the change
> also makes that more awkward... :/

The point of this change was to got rid of closure type inference. With 
the old rules it was not possible to see whether you were allocating 
without looking at the type signature of the function you're calling. 
Moreover the capture rules are extremely different depending on the type 
of closure it is. It's too much magic for Rust.

Patrick


From bjzaba at yahoo.com.au  Sat Nov 30 19:35:37 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sun, 1 Dec 2013 13:35:37 +1000
Subject: [rust-dev] do
In-Reply-To: <CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
Message-ID: <D9774DFE-77C7-49A7-BB7E-4C69E206235A@yahoo.com.au>

On 30 Nov 2013, at 5:34 pm, Oren Ben-Kiki <oren at ben-kiki.org> wrote:

> I find `do` syntax form is vital for DSL-ish code. Getting rid of it makes a lot of code look downright ugly. I'd rather it used a more Ruby-ish notation though, I find that putting the `do` far away from the `{ ... }` doesn't read well. `foo(....) do |...| { ... }` would have made more sense for me (think of `do` as a macro-ish binary operation injecting the proc into the function on the left). But the current form is acceptable

This really is an important point. I would recommend folks look at Shoes (http://shoesrb.com/) for an example of how Ruby?s block syntax can help create beautiful APIs.

~Brendan

From pcwalton at mozilla.com  Sat Nov 30 19:36:22 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 19:36:22 -0800
Subject: [rust-dev] do
In-Reply-To: <D9774DFE-77C7-49A7-BB7E-4C69E206235A@yahoo.com.au>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<D9774DFE-77C7-49A7-BB7E-4C69E206235A@yahoo.com.au>
Message-ID: <529AAEB6.8080708@mozilla.com>

On 11/30/13 7:35 PM, Brendan Zabarauskas wrote:
> On 30 Nov 2013, at 5:34 pm, Oren Ben-Kiki <oren at ben-kiki.org> wrote:
>
>> I find `do` syntax form is vital for DSL-ish code. Getting rid of
>> it
makes a lot of code look downright ugly. I'd rather it used a more
Ruby-ish notation though, I find that putting the `do` far away from the
`{ ... }` doesn't read well. `foo(....) do |...| { ... }` would have
made more sense for me (think of `do` as a macro-ish binary operation
injecting the proc into the function on the left). But the current form
is acceptable
>
> This really is an important point. I would recommend folks look at
Shoes (http://shoesrb.com/) for an example of how Ruby?s block syntax
can help create beautiful APIs.

Ruby is a totally different language without two kinds of closures. The 
problem is not the sugar, it's the inference.

Patrick


From corey at octayn.net  Sat Nov 30 19:43:26 2013
From: corey at octayn.net (Corey Richardson)
Date: Sat, 30 Nov 2013 22:43:26 -0500
Subject: [rust-dev] do
In-Reply-To: <529AACCB.9060101@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
Message-ID: <CA++BO6StFKaiBNL04jE5ykSCMa4f4Hm6OVxWm2P_HZn9vHd+cw@mail.gmail.com>

On Sat, Nov 30, 2013 at 10:28 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
> On 11/30/13 7:25 PM, Michael Letterle wrote:
>>
>>     I've got to say that the "do" syntax is one of the things that
>>     appeals to me about Rust, and will probably appeal to the people
>>     that Steve Klabnik is drawing to the language with Rust for Rubyists.
>>
>>     It might seem like a small thing but the effects on the type of
>>     programs you can write, it actually has a pretty profound effect, IMO.
>>
>>     --
>>     Tony Arcieri
>>
>>
>> I agree actually, I was using do to implement some convenience logic and
>> my code went from:
>>
>>      do function { someotherFunction() };
>>
>> to
>>
>>      function(|| someotherFunction());
>>
>> Maybe I'm abusing something here, but I found the first format more
>> intuitive and elegant...
>>
>> I know there's rumblings about io conditions going away, but the change
>> also makes that more awkward... :/
>
>
> The point of this change was to got rid of closure type inference. With the
> old rules it was not possible to see whether you were allocating without
> looking at the type signature of the function you're calling. Moreover the
> capture rules are extremely different depending on the type of closure it
> is. It's too much magic for Rust.
>

Maybe `do` can just change from procs to closures. I can't really say
how often I've actually wanted a proc. Task bodies are a far minority
compared to other uses of do, from the backlash, and I don't find
`spawn(proc() { ... })` that unappealing.

From pcwalton at mozilla.com  Sat Nov 30 19:45:10 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 19:45:10 -0800
Subject: [rust-dev] do
In-Reply-To: <CA++BO6StFKaiBNL04jE5ykSCMa4f4Hm6OVxWm2P_HZn9vHd+cw@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>	<529AACCB.9060101@mozilla.com>
	<CA++BO6StFKaiBNL04jE5ykSCMa4f4Hm6OVxWm2P_HZn9vHd+cw@mail.gmail.com>
Message-ID: <529AB0C6.3010809@mozilla.com>

On 11/30/13 7:43 PM, Corey Richardson wrote:
> Maybe `do` can just change from procs to closures. I can't really say
> how often I've actually wanted a proc. Task bodies are a far minority
> compared to other uses of do, from the backlash, and I don't find
> `spawn(proc() { ... })` that unappealing.

I really don't see "do" for stack closures as something that makes sense 
in current Rust. It made sense back when we used it for loops and didn't 
use RAII (as Ruby does), but the experiment of using blocks in place of 
RAII for stuff like "with_c_str" or "unkillable" has failed: it leads to 
too much rightward drift.

Patrick


From kevin at sb.org  Sat Nov 30 19:50:25 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 19:50:25 -0800
Subject: [rust-dev] do
In-Reply-To: <529AACCB.9060101@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
Message-ID: <8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>

On Nov 30, 2013, at 7:28 PM, Patrick Walton <pcwalton at mozilla.com> wrote:

> On 11/30/13 7:25 PM, Michael Letterle wrote:
>>    I've got to say that the "do" syntax is one of the things that
>>    appeals to me about Rust, and will probably appeal to the people
>>    that Steve Klabnik is drawing to the language with Rust for Rubyists.
>> 
>>    It might seem like a small thing but the effects on the type of
>>    programs you can write, it actually has a pretty profound effect, IMO.
>> 
>>    --
>>    Tony Arcieri
>> 
>> 
>> I agree actually, I was using do to implement some convenience logic and
>> my code went from:
>> 
>>     do function { someotherFunction() };
>> 
>> to
>> 
>>     function(|| someotherFunction());
>> 
>> Maybe I'm abusing something here, but I found the first format more
>> intuitive and elegant...
>> 
>> I know there's rumblings about io conditions going away, but the change
>> also makes that more awkward... :/
> 
> The point of this change was to got rid of closure type inference. With the old rules it was not possible to see whether you were allocating without looking at the type signature of the function you're calling. Moreover the capture rules are extremely different depending on the type of closure it is. It's too much magic for Rust.

Can we not simply allow `do` to work with both stack closures and heap closures? With the current proc() stuff that would be

do spawn proc() {
    ..
}

And yes, I know do originally existed to make spawning nicer, but that's not really that ugly, and allows for using `do` with stack closures (which, in code I've seen, has been by far the majority of use-cases for `do`). Also, IMO making the existence of a proc more obvious seems like a good idea (given the effect it has on captured values). Similarly, if this change were made, then a nullary stack closure would be called like

do some_func || {
    ..
}

which I think is fine, as it makes the stack closure obvious, although the potential confusion of the || with the logical-OR operator is very slightly worrisome (but not terribly so, especially because pushing RAII should mean that functions that take nullary stack closures in tail position shouldn't be common).

-Kevin

From pcwalton at mozilla.com  Sat Nov 30 19:53:16 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 19:53:16 -0800
Subject: [rust-dev] do
In-Reply-To: <8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
Message-ID: <529AB2AC.2080107@mozilla.com>

On 11/30/13 7:50 PM, Kevin Ballard wrote:
> do spawn proc() {
>      ..
> }

That's essentially just as verbose as not having "do".

>
> And yes, I know do originally existed to make spawning nicer, but
> that's not really that ugly, and allows for using `do` with stack
> closures (which, in code I've seen, has been by far the majority of
> use-cases for `do`).

That's because, in the vast majority of cases:

(1) We don't use RAII enough. This should be fixed.

(2) `do` was being used for stuff like `do v.map { ... }`, which I've 
always considered something of an abuse. "map" is a higher order 
function; it should look like a higher order function and not an iterator.

Patrick


From danielmicay at gmail.com  Sat Nov 30 19:54:03 2013
From: danielmicay at gmail.com (Daniel Micay)
Date: Sat, 30 Nov 2013 22:54:03 -0500
Subject: [rust-dev] do
In-Reply-To: <8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
Message-ID: <CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>

On Sat, Nov 30, 2013 at 10:50 PM, Kevin Ballard <kevin at sb.org> wrote:
> On Nov 30, 2013, at 7:28 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>
>> On 11/30/13 7:25 PM, Michael Letterle wrote:
>>>    I've got to say that the "do" syntax is one of the things that
>>>    appeals to me about Rust, and will probably appeal to the people
>>>    that Steve Klabnik is drawing to the language with Rust for Rubyists.
>>>
>>>    It might seem like a small thing but the effects on the type of
>>>    programs you can write, it actually has a pretty profound effect, IMO.
>>>
>>>    --
>>>    Tony Arcieri
>>>
>>>
>>> I agree actually, I was using do to implement some convenience logic and
>>> my code went from:
>>>
>>>     do function { someotherFunction() };
>>>
>>> to
>>>
>>>     function(|| someotherFunction());
>>>
>>> Maybe I'm abusing something here, but I found the first format more
>>> intuitive and elegant...
>>>
>>> I know there's rumblings about io conditions going away, but the change
>>> also makes that more awkward... :/
>>
>> The point of this change was to got rid of closure type inference. With the old rules it was not possible to see whether you were allocating without looking at the type signature of the function you're calling. Moreover the capture rules are extremely different depending on the type of closure it is. It's too much magic for Rust.
>
> Can we not simply allow `do` to work with both stack closures and heap closures? With the current proc() stuff that would be
>
> do spawn proc() {
>     ..
> }
>
> And yes, I know do originally existed to make spawning nicer, but that's not really that ugly, and allows for using `do` with stack closures (which, in code I've seen, has been by far the majority of use-cases for `do`). Also, IMO making the existence of a proc more obvious seems like a good idea (given the effect it has on captured values). Similarly, if this change were made, then a nullary stack closure would be called like
>
> do some_func || {
>     ..
> }
>
> which I think is fine, as it makes the stack closure obvious, although the potential confusion of the || with the logical-OR operator is very slightly worrisome (but not terribly so, especially because pushing RAII should mean that functions that take nullary stack closures in tail position shouldn't be common).
>
> -Kevin

I don't understand the point of `do` beyond making zero-parameter
closures look a bit better. If it doesn't even do that, why bother? If
an editor isn't indenting it properly, that's an editor issue. As far
as I can tell, the vim indent file now handles it fine.

From bjzaba at yahoo.com.au  Sat Nov 30 20:06:25 2013
From: bjzaba at yahoo.com.au (Brendan Zabarauskas)
Date: Sun, 1 Dec 2013 14:06:25 +1000
Subject: [rust-dev] do
In-Reply-To: <529AB0C6.3010809@mozilla.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>	<529AACCB.9060101@mozilla.com>
	<CA++BO6StFKaiBNL04jE5ykSCMa4f4Hm6OVxWm2P_HZn9vHd+cw@mail.gmail.com>
	<529AB0C6.3010809@mozilla.com>
Message-ID: <3133DFB9-28B2-4F33-AC36-01B3DF719D03@yahoo.com.au>


On 1 Dec 2013, at 1:45 pm, Patrick Walton <pcwalton at mozilla.com> wrote:

> the experiment of using blocks in place of RAII for stuff like "with_c_str" or "unkillable" has failed: it leads to too much rightward drift.
> 
> Patrick

I guess I can agree with that. I remember when I first started with Rust doing: `some_c_func(?hi?.with_c_str(|s| s))`, which completely negates the safety guarantees of the closure. How would this look with RAII?

By ?rightward drift? do you mean in terms of multiple nested closures?

~Brendan

From kevin at sb.org  Sat Nov 30 20:08:14 2013
From: kevin at sb.org (Kevin Ballard)
Date: Sat, 30 Nov 2013 20:08:14 -0800
Subject: [rust-dev] do
In-Reply-To: <CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>
	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>
	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>
	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>
	<529AACCB.9060101@mozilla.com>
	<8C23930B-9603-48D2-8B7E-495DD32D2B13@sb.org>
	<CA+DvKQ+W7wY3V9p1Nd6-Ti30E+fdxPZhByRYcbD6bdVVGbE0ig@mail.gmail.com>
Message-ID: <547E2AAB-2527-4A11-B480-DDCA60D046BC@sb.org>

On Nov 30, 2013, at 7:54 PM, Daniel Micay <danielmicay at gmail.com> wrote:

> On Sat, Nov 30, 2013 at 10:50 PM, Kevin Ballard <kevin at sb.org> wrote:
>> On Nov 30, 2013, at 7:28 PM, Patrick Walton <pcwalton at mozilla.com> wrote:
>> 
>>> On 11/30/13 7:25 PM, Michael Letterle wrote:
>>>>   I've got to say that the "do" syntax is one of the things that
>>>>   appeals to me about Rust, and will probably appeal to the people
>>>>   that Steve Klabnik is drawing to the language with Rust for Rubyists.
>>>> 
>>>>   It might seem like a small thing but the effects on the type of
>>>>   programs you can write, it actually has a pretty profound effect, IMO.
>>>> 
>>>>   --
>>>>   Tony Arcieri
>>>> 
>>>> 
>>>> I agree actually, I was using do to implement some convenience logic and
>>>> my code went from:
>>>> 
>>>>    do function { someotherFunction() };
>>>> 
>>>> to
>>>> 
>>>>    function(|| someotherFunction());
>>>> 
>>>> Maybe I'm abusing something here, but I found the first format more
>>>> intuitive and elegant...
>>>> 
>>>> I know there's rumblings about io conditions going away, but the change
>>>> also makes that more awkward... :/
>>> 
>>> The point of this change was to got rid of closure type inference. With the old rules it was not possible to see whether you were allocating without looking at the type signature of the function you're calling. Moreover the capture rules are extremely different depending on the type of closure it is. It's too much magic for Rust.
>> 
>> Can we not simply allow `do` to work with both stack closures and heap closures? With the current proc() stuff that would be
>> 
>> do spawn proc() {
>>    ..
>> }
>> 
>> And yes, I know do originally existed to make spawning nicer, but that's not really that ugly, and allows for using `do` with stack closures (which, in code I've seen, has been by far the majority of use-cases for `do`). Also, IMO making the existence of a proc more obvious seems like a good idea (given the effect it has on captured values). Similarly, if this change were made, then a nullary stack closure would be called like
>> 
>> do some_func || {
>>    ..
>> }
>> 
>> which I think is fine, as it makes the stack closure obvious, although the potential confusion of the || with the logical-OR operator is very slightly worrisome (but not terribly so, especially because pushing RAII should mean that functions that take nullary stack closures in tail position shouldn't be common).
>> 
>> -Kevin
> 
> I don't understand the point of `do` beyond making zero-parameter
> closures look a bit better. If it doesn't even do that, why bother? If
> an editor isn't indenting it properly, that's an editor issue. As far
> as I can tell, the vim indent file now handles it fine.

At this point, given that stack closures no longer work with do, it seems to me that do is just Rust's attempt at providing a syntactical nicety analogous to Go's `go` operator.

If we can't have `do` working with stack closures, my feeling is we should just remove it. Keeping around special syntax purely for the case of heap closures seems like unnecessary complexity. Although my preference is still for restoring `do`'s ability to work with stack closures.

-Kevin

From pcwalton at mozilla.com  Sat Nov 30 20:08:53 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 20:08:53 -0800
Subject: [rust-dev] do
In-Reply-To: <3133DFB9-28B2-4F33-AC36-01B3DF719D03@yahoo.com.au>
References: <CAMF4Wei8BjLoJiZYGtC+6aq_C54rm52bUnr3oGoHCeD8ndbsyA@mail.gmail.com>	<CADJiDhuywjaTe_KfZaMMD=R25-gxb+SOG8yOsnSO5BxivREfZw@mail.gmail.com>	<CAHOTMVJDjnVxL36SKC0a=Y1j+K1a0zQgE0_PQPrz7NR8_2qMLg@mail.gmail.com>	<CA+UdSru4bAoeRNu5Td20oG+hYZo7CdSjd4kR3v-bk+diGWLD1w@mail.gmail.com>	<529AACCB.9060101@mozilla.com>
	<CA++BO6StFKaiBNL04jE5ykSCMa4f4Hm6OVxWm2P_HZn9vHd+cw@mail.gmail.com>
	<529AB0C6.3010809@mozilla.com>
	<3133DFB9-28B2-4F33-AC36-01B3DF719D03@yahoo.com.au>
Message-ID: <529AB655.7040003@mozilla.com>

On 11/30/13 8:06 PM, Brendan Zabarauskas wrote:
>
> On 1 Dec 2013, at 1:45 pm, Patrick Walton <pcwalton at mozilla.com> wrote:
>
>> the experiment of using blocks in place of RAII for stuff like "with_c_str" or "unkillable" has failed: it leads to too much rightward drift.
>>
>> Patrick
>
> I guess I can agree with that. I remember when I first started with Rust doing: `some_c_func(?hi?.with_c_str(|s| s))`, which completely negates the safety guarantees of the closure. How would this look with RAII?

Just return a package consisting of either an owned string (if 
allocation needed to be done) or a borrowed pointer to the original 
string (if no allocation needed to be done). Then you can put a method 
on that enum yielding the raw C pointer. Voila, no rightward drift :)

> By ?rightward drift? do you mean in terms of multiple nested closures?

Right. I've seen "with_c_str" six levels deep :(

RAII also has the advantage that you can more precisely control the 
scope of the effect that you're delimiting: you can move it around, 
destruct it early, and so on. For example, an RAII'd version of 
"task::unkillable" would not only have no rightward drift, but the token 
that makes you killable again could also be destructed on some code 
paths but not others, moved to other functions, etc.

Patrick


From pcwalton at mozilla.com  Sat Nov 30 21:42:24 2013
From: pcwalton at mozilla.com (Patrick Walton)
Date: Sat, 30 Nov 2013 21:42:24 -0800
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>	<5299AAD4.6090304@mozilla.com>	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>	<529A5EA4.6050607@mozilla.com>	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>	<529A963E.5030101@babelmonkeys.de>	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
Message-ID: <529ACC40.2020705@mozilla.com>

On 11/30/13 6:49 PM, Corey Richardson wrote:
> On Sat, Nov 30, 2013 at 9:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>> I'm still very much a fan of leaving ~ as the allocation operator. Despite what Patrick says, I'm pretty sure the reason why users are confused about it is purely due to sub-par documentation, and not due to any actual inherent problems with using a non-alphabetic symbol as an operator. Heck, we have plenty of other non-alphabetic operators that don't cause confusion, why is this one special?
>>
>
> I'll admit, I don't find the "confusing" argument very convincing. I
> just think `box` looks better than `~`.

I'm warming up to this idea -- `box 10` does make more sense than `new 10`.

Patrick


From ben.striegel at gmail.com  Sat Nov 30 22:01:40 2013
From: ben.striegel at gmail.com (Benjamin Striegel)
Date: Sun, 1 Dec 2013 01:01:40 -0500
Subject: [rust-dev] Placement new and the loss of `new` to keywords
In-Reply-To: <529ACC40.2020705@mozilla.com>
References: <8076B659-67E3-4442-B489-0595BEF3CA6C@sb.org>
	<694bd18f-3dac-408f-8f6f-46ae6ec697ae@email.android.com>
	<6F45565C-1EE3-43BB-86D8-905416EDD9CA@sb.org>
	<3fad7b41-efa8-4e25-9243-e1b96f40938b@email.android.com>
	<BB7ED76E-0AAD-40EE-B930-E022AED23FC3@sb.org>
	<c80b0b45-92f4-4ad6-a807-6ac8ce06ff79@email.android.com>
	<A92963E2-9255-4AF2-9DE6-E885232B8AF0@sb.org>
	<5299AAD4.6090304@mozilla.com>
	<9E88A001-B3BD-4615-B6F5-91D4DCF91BD9@sb.org>
	<529A5EA4.6050607@mozilla.com>
	<CAAvrL-mMezE-QGJb369TmBLVspMibLoNe+hE6-3nrJsDhwUJag@mail.gmail.com>
	<17ff76e7-56e4-47c6-94dd-bef653add100@email.android.com>
	<529A963E.5030101@babelmonkeys.de>
	<CA++BO6SO3ocrCNwQ8fLMceGo6TB0fugBULg7yyri2A42-hrXhA@mail.gmail.com>
	<372D35C9-5DEB-4669-9859-1693DFD2ACBA@sb.org>
	<CA++BO6RKqjxwrW1-PSTufTgZLt6XWcbW_9kJO7SMZaAkDG77zw@mail.gmail.com>
	<529ACC40.2020705@mozilla.com>
Message-ID: <CAAvrL-=mU8n12Pbb9QppjJJtRkx=X52eaP5f7jkZ46fWpAJa_A@mail.gmail.com>

Eh, I'm as fine with `box` as I am with `new`. Does seem a bit like jargon,
though. Though maybe it will herald a return to the days when we really
played up the "shipping container" flavor. Crates and cargo, anyone? :)


On Sun, Dec 1, 2013 at 12:42 AM, Patrick Walton <pcwalton at mozilla.com>wrote:

> On 11/30/13 6:49 PM, Corey Richardson wrote:
>
>> On Sat, Nov 30, 2013 at 9:30 PM, Kevin Ballard <kevin at sb.org> wrote:
>>
>>> I'm still very much a fan of leaving ~ as the allocation operator.
>>> Despite what Patrick says, I'm pretty sure the reason why users are
>>> confused about it is purely due to sub-par documentation, and not due to
>>> any actual inherent problems with using a non-alphabetic symbol as an
>>> operator. Heck, we have plenty of other non-alphabetic operators that don't
>>> cause confusion, why is this one special?
>>>
>>>
>> I'll admit, I don't find the "confusing" argument very convincing. I
>> just think `box` looks better than `~`.
>>
>
> I'm warming up to this idea -- `box 10` does make more sense than `new 10`.
>
> Patrick
>
>
> _______________________________________________
> Rust-dev mailing list
> Rust-dev at mozilla.org
> https://mail.mozilla.org/listinfo/rust-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.mozilla.org/pipermail/rust-dev/attachments/20131201/7f3f98f6/attachment.html>

